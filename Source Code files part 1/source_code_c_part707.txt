illSocket(pNewConnection->socket,TRUE,FALSE);
        FreeConnection(pNewConnection);
    }
    LEAVE_DPSP();
    return hr;
    
}  // AddSocketToReceiveList

// updates the player associated with a socket in the send list
void UpdateSocketPlayerID(LPGLOBALDATA pgd, SOCKADDR_IN6 *pSockAddr, DPID dpidPlayer)
{
    UINT i=0;
    IN6_ADDR *pIPCurrent, *pIPFind;
    BOOL bFound = FALSE;

    ASSERT(pSockAddr);

    DEBUGPRINTADDR(9, "Updating player id for socket connected to - ",pSockAddr);

    ENTER_DPSP();

    while (!bFound && (i < pgd->nSocketsInBag))
    {
        pIPCurrent = &(((SOCKADDR_IN6 *)&pgd->BagOSockets[i].sockaddr)->sin6_addr);
        pIPFind = &(((SOCKADDR_IN6 *)pSockAddr)->sin6_addr);

        // todo - we are only comparing the IP here, need to look at the complete socket address
        if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
            !memcmp(pIPCurrent, pIPFind, sizeof(IN6_ADDR)))
        {            
            bFound = TRUE;
            // update the player id
            pgd->BagOSockets[i].dwPlayerID = dpidPlayer;
        }

        i++;
    }

    LEAVE_DPSP();

    return;
}

BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket)
{
    UINT i=0;
    IN6_ADDR *pIPCurrent, *pIPFind;
    BOOL bFound = FALSE;

    ASSERT(psSocket);

    ENTER_DPSP();

    while (!bFound && (i < pgd->ReceiveList.nConnections))
    {
        pIPCurrent = &(((SOCKADDR_IN6 *)&pgd->ReceiveList.pConnection[i].sockAddr)->sin6_addr);
        pIPFind = &(((SOCKADDR_IN6 *)pSockAddr)->sin6_addr);

        // todo - we are only comparing the IP here, need to look at the complete socket address
        if ((INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket) && 
            !memcmp(pIPCurrent, pIPFind, sizeof(IN6_ADDR)))
        {
            *psSocket = pgd->ReceiveList.pConnection[i].socket;
            bFound = TRUE;
        }

        i++;
    }

    LEAVE_DPSP();
    
    return bFound;
}

BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer)
{
    UINT i=0;
    IN6_ADDR *pIPCurrent, *pIPFind;
    BOOL bFound = FALSE;

    ASSERT(psSocket);
    ASSERT(lpdpidPlayer);

    ENTER_DPSP();
    

    while (!bFound && (i < pgd->nSocketsInBag))
    {
        pIPCurrent = &(((SOCKADDR_IN6 *)&pgd->BagOSockets[i].sockaddr)->sin6_addr);
        pIPFind = &(((SOCKADDR_IN6 *)pSockAddr)->sin6_addr);

        if ((INVALID_SOCKET != pgd->BagOSockets[i].sSocket) &&
            !memcmp(pIPCurrent, pIPFind, sizeof(IN6_ADDR)))
        {
            *psSocket = pgd->BagOSockets[i].sSocket;
            *lpdpidPlayer = pgd->BagOSockets[i].dwPlayerID;

            DPF(9, "Found socket in send list for id %d", *lpdpidPlayer);
            bFound = TRUE;
        }

        i++;
    }

    LEAVE_DPSP();
    
    return bFound;
}

void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket)
{
    BOOL bFound = FALSE;
    UINT i=0;
    
    ENTER_DPSP();

    // look for the socket
    while (!bFound && (i < pgd->nSocketsInBag))
    {
        if (socket == pgd->BagOSockets[i].sSocket)
        {
            pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
            bFound = TRUE;
        }
        else 
        {
            i++;
        }
    } // while

    LEAVE_DPSP();
}

void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket)
{
    UINT i = 0;
    BOOL bFound = FALSE;
    SOCKET sSocket=INVALID_SOCKET;
    DWORD dwSocketFlags=0;

    ENTER_DPSP();
    
    // look for the corresponding connection
    while ( !bFound && (i < pgd->ReceiveList.nConnections))
    {
        if (socket == pgd->ReceiveList.pConnection[i].socket)
        {
            DEBUGPRINTSOCK(9, "Removing socket from receive list - ", &socket);
            socket = pgd->ReceiveList.pConnection[i].socket;            
            dwSocketFlags = pgd->ReceiveList.pConnection[i].dwFlags;
            FreeConnection(&pgd->ReceiveList.pConnection[i]);
            bFound = TRUE;
        }
        else 
        {
            i++;
        }
    } // while
    
    LEAVE_DPSP();
    
    if (bFound)
    {
        KillSocket(socket, TRUE, FALSE);
        if (dwSocketFlags & SP_CONNECTION_FULLDUPLEX)
            RemoveSocketFromBag(pgd,sSocket);
    }

    return ;    
    
} //RemoveSocketFromReceiveList

HRESULT HandleSPMessage(IDirectPlaySP *pISP, LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
    HRESULT hr;
    
    switch (SP_MESSAGE_TOKEN(pConnection->pBuffer)) 
    {        
        // VALID_SP_MESSAGE
        case TOKEN:
        {
            if (SPMESSAGEHEADERLEN == pConnection->dwTotalMessageSize)
            {
                // if we get a message w/ 0 size, it means we've accepted a connection
                // and need to add the new socket to our recv list...
                // basically, it's a no-op for the receive loop
                return DP_OK;
            }
            
            // now, we've read all the bits
            // store the address we received from w/ the message
            // todo - don't store address if it's a player - player message
            if (pgd->dwFlags & DPSP_OUTBOUNDONLY)
            {
                ((LPMESSAGEHEADER)pConnection->pBuffer)->sockaddr = pConnection->sockAddr;
            }
            else
            {
                IP6_SetAddr((LPVOID)pConnection->pBuffer,(SOCKADDR_IN6 *)&pConnection->sockAddr);
            }
            
            // pass message to dplays handler
            // need to drop the lock here...
            ASSERT( 1 == gCSCount);
            
            DPF(9, "received a complete message - handing it off to dplay");

            LEAVE_DPSP();
            
            // received a complete message - hand it off to dplay
            pISP->lpVtbl->HandleMessage(pISP, pConnection->pBuffer + sizeof(MESSAGEHEADER),
                    pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER),pConnection->pBuffer);
            
            ENTER_DPSP();

        } 
        break;
        
         // VALID_SERVER_MESSAGE
         case SERVER_TOKEN:
        {
            HandleServerMessage(pgd, pConnection->socket, pConnection->pBuffer + sizeof(MESSAGEHEADER), 
                    pConnection->dwTotalMessageSize - sizeof(MESSAGEHEADER));
                    
        }
        break;

        // if we get this token, the sender wants us to reuse the connection
        // so put it in the send list
        case REUSE_TOKEN:
        {
            DEBUGPRINTSOCK(9, "Received reuse message on - ", &pConnection->socket);

            // we only allow reusing connections in client/server mode at this time.
            // peer-peer can't work without making inbound connections
            if (pgd->dwSessionFlags & DPSESSION_CLIENTSERVER)
            {
                DEBUGPRINTSOCK(9, "Reusing connection - ", &pConnection->socket);

                hr = AddSocketToBag(pgd, pConnection->socket, 0, &pConnection->sockAddr, 
                                    SP_CONNECTION_FULLDUPLEX);
                if (FAILED(hr))
                {
                    DEBUGPRINTSOCK(0, "Failed to reuse connection - ",&pConnection->socket);
                    return hr;
                }
            }
            else
            {
                DPF(2, "Not accepting reuse request in peer-peer");
                return E_FAIL;

            }
        }
        break;

        default:
        {
            DPF(0, "Received a message with invalid token - 0x%08x",SP_MESSAGE_TOKEN(pConnection->pBuffer));
        }
        break;
    
    } // switch

    return DP_OK;
    
} // HandleSPMessage

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *        sSocket - socket to receive on
 *        ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *        pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *        suck the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(IDirectPlaySP * pISP,LPGLOBALDATA pgd, LPCONNECTION pConnection)
{
    HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
    DWORD dwMessageSize = 0;
    LPBYTE pReceiveBuffer=NULL;
    DWORD dwReceiveBufferSize;
    
    // is it a new message ?
    if (pConnection->dwCurMessageSize == 0)
    {
        // make sure we have a buffer to recive data in
        if (!pConnection->pDefaultBuffer)
        {
            DEBUGPRINTADDR(0, "No buffer to receive data - removing connection to - ",&pConnection->sockAddr);
            goto CLEANUP_EXIT;
        }
        // receive the header first
        pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
    }

    // continue receiving message
    pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
    dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

    DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

       DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

    // receive data from socket 
    // note - make exactly one call to recv after select otherwise we'll hang
    dwBytesReceived = recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

    if (0 == dwBytesReceived)
    {
        // remote side has shutdown connection gracefully
           DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);
        hr = DP_OK;
        DEBUGPRINTSOCK(5,"Remote side has shutdown connection gracefully - ",&pConnection->socket);
        goto CLEANUP_EXIT;
    }
    else if (SOCKET_ERROR == dwBytesReceived)
    {
        err = WSAGetLastError();

           DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);
        DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
        hr = E_UNEXPECTED;            
        goto CLEANUP_EXIT;
    }

    DPF(5, "received %d bytes", dwBytesReceived);
    
    // we have received this much message so far
    pConnection->dwCurMessageSize += dwBytesReceived;

    // did we receive the header
    if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
    {
        // we just completed receiving message header

        // make sure its valid
        if (VALID_DPWS_MESSAGE(pConnection->pDefaultBuffer))
        {
             dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size            

#ifdef BIGMESSAGEDEFENSE
            // make sure it is not greater that the max message len
            if (dwMessageSize > pgd->dwMaxMessageSize)
            {
                DPF(0, "Got message (%d bytes) that's bigger than max allowed len (%d)! Disconnecting sender.\n",
                    dwMessageSize - sizeof(MESSAGEHEADER), pgd->dwMaxMessageSize - sizeof(MESSAGEHEADER));
                ASSERT(dwMessageSize <= pgd->dwMaxMessageSize);
                                
                // we want to receive another 12 bytes so that DPLAY can have
                //    something to look at to decide whether or not to continue
                //    receiving this message.  So instead of setting dwMessageSize
                //    to its real size, we fake it out.
                dwMessageSize = SPMESSAGEHEADERLEN + 12;
            }
#endif
        }
        else 
        {
            DPF(2,"got invalid message - token = 0x%08x",SP_MESSAGE_TOKEN(pConnection->pDefaultBuffer));
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            goto CLEANUP_EXIT;
        }

        // prepare to receive rest of the message (after the token)
        if (dwMessageSize) 
        {
            pConnection->dwTotalMessageSize = dwMessageSize;

            // which buffer to receive message in ?
            if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
            {
                ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
                // get a new buffer to fit the message
                pConnection->pBuffer = MemAlloc(dwMessageSize);
                if (!pConnection->pBuffer)
                {
                    DPF(0,"Failed to allocate receive buffer for message - out of memory");
                    goto CLEANUP_EXIT;
                }
                // copy header into new message buffer
                memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
            }
        }
    }
#ifdef BIGMESSAGEDEFENSE
    // this MIGHT be because the message is really huge, and we're just getting
    // enough to hand to DPLAY
    else if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN + 12)
    {
        dwMessageSize = SP_MESSAGE_SIZE(pConnection->pBuffer);
        if (dwMessageSize > pgd->dwMaxMessageSize)
        {
            DPSP_MSGTOOBIG    msgTooBigErr;
            
            // okay.  This is message is too big, and we now have enough data
            // to hand to DPLAY.  Find out if it wants us to continue receiving,
            //    or bail on this connection

            // call into DPLAY to let it do its thing
            msgTooBigErr.dwType = DPSPWARN_MESSAGETOOBIG;    
            msgTooBigErr.pReceiveBuffer = pConnection->pBuffer + sizeof(MESSAGEHEADER);
            msgTooBigErr.dwBytesReceived = pConnection->dwCurMessageSize;
            msgTooBigErr.dwMessageSize = dwMessageSize - sizeof(MESSAGEHEADER);
            
            LEAVE_DPSP();

            pISP->lpVtbl->HandleSPWarning(pISP, &msgTooBigErr, sizeof(DPSP_MSGTOOBIG), pConnection->pBuffer);
            
            ENTER_DPSP();

//            now, kill the connection
            hr = E_UNEXPECTED;
            goto CLEANUP_EXIT;
        }
    }
#endif

    // did we receive a complete message ?
    if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
    {
        // process message
        hr = HandleSPMessage(pISP, pgd, pConnection);
        
        // cleanup up new receive buffer if any
        if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
        {
            DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
            if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
        }            
        // initialize message information
        pConnection->dwCurMessageSize = 0;
        pConnection->dwTotalMessageSize = 0;
        pConnection->pBuffer = pConnection->pDefaultBuffer;

        if (FAILED(hr))
        {
            goto CLEANUP_EXIT;
        }
    }

    // all done
    return DP_OK;    
    
CLEANUP_EXIT:

    RemoveSocketFromReceiveList(pgd,pConnection->socket);
    return hr;
         
} // StreamReceive


void EmptyConnectionList(LPGLOBALDATA pgd)
{
    UINT i;
    
    ENTER_DPSP();
    
    for (i=0;i<pgd->ReceiveList.nConnections ;i++ )
    {
        if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
        {
            KillSocket(pgd->ReceiveList.pConnection[i].socket,TRUE,FALSE);
            FreeConnection(&(pgd->ReceiveList.pConnection[i]));
        }
    }
    
    LEAVE_DPSP();
    
    return ;
    
}  // EmptyConnectionList

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
    HRESULT hr;
    int rval;
    UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
    UINT nSelected;
    IDirectPlaySP * pISP = (IDirectPlaySP *)pvCast;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    TIMEVAL tv={0,250000};    // 250000 us = 1/4 sec.
    DWORD dwPrevSelectLastError=0;
    
    // get the global data
    hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        ExitThread(0);
        return 0;
    }

    AddSocketToReceiveList(pgd,pgd->sSystemStreamSocket,SP_STREAM_ACCEPT);

    while (1)
    {
        ENTER_DPSP();

        ASSERT(pgd->readfds.pfdbigset);

        // add all sockets in our recv list to readfds
        FD_ZERO(pgd->readfds.pfdbigset);
        nSelected = 0;
        for (i=0;i < pgd->ReceiveList.nConnections ; i++)
        {
            if (INVALID_SOCKET != pgd->ReceiveList.pConnection[i].socket)
            {
                FD_BIG_SET(pgd->ReceiveList.pConnection[i].socket,&pgd->readfds);
                nSelected++;
            }
        }

        LEAVE_DPSP();

        if (0 == nSelected)        
        {
            if (pgd->bShutdown)
            {
                DPF(2,"stream receive thread proc detected shutdown - bailing");
                goto CLEANUP_EXIT;
            }
            // we should have at least one?
            DPF_ERR("No sockets in receive list - missing control socket? bailing!");
            ASSERT(FALSE);
            goto CLEANUP_EXIT;
        }

        // now, we wait for something to happen w/ our socket set
        rval = select(0,(fd_set *)(pgd->readfds.pfdbigset),NULL,NULL,&tv);
        if (SOCKET_ERROR == rval)
        {
            err = WSAGetLastError();
            if(dwPrevSelectLastError==err){
                DPF(0,"Got two bogus last errors of(%x) from select, bailing",err);
                goto CLEANUP_EXIT;
            }
            // WSAEINTR is returned when a socket is shutdown behind us - this can happen
            // when a socket is removed from the receivelist
            if (WSAEINTR != err)
            {
                dwPrevSelectLastError=err;
                DPF(2,"StreamReceiveThreadProc failing w/ sockerr = %d\n - trying again",err);
                ASSERT(FALSE);                
                rval = 0; // try again...
            } else {
                dwPrevSelectLastError=0;
            }
        } else {
            dwPrevSelectLastError=0;
        }

        // shut 'em down?
        if (pgd->bShutdown)
        {
            DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
        // a-josbor: why are we waking up with 0 events?
        // in any case, a workaround is to just go back to sleep if we have
        // no real events
        if ( rval == 0)
        {
            continue;
        }

        DPF(5,"receive thread proc - events on %d sockets",rval);
        i = 0;
        
        ENTER_DPSP();
        
        while (rval>0)
        {
            // walk the receive list, dealing w/ all new sockets
            if (i >= pgd->ReceiveList.nConnections)
            {
                DPF(0, "nConnections = %d, selected = %d", pgd->ReceiveList.nConnections, i);
                ASSERT(FALSE); // should never happen
                rval = 0; // just to be safe, reset
            }
            
            if (pgd->ReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
                // see if it's in the set
                if (FD_ISSET(pgd->ReceiveList.pConnection[i].socket,pgd->readfds.pfdbigset))
                {
                    DPF(9, "Receiving on socket %d from ReceiveList", i);

                    if(pgd->ReceiveList.pConnection[i].dwFlags != SP_STREAM_ACCEPT){

                        // got one! this socket has something going on...
                        hr = StreamReceive(pISP, pgd, &(pgd->ReceiveList.pConnection[i]));
                        if (FAILED(hr))
                        {
                            DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
                        }
                        
                    } else {
                    
                        // accept any incoming connection
                        SOCKADDR_IN6 sockaddr; 
                        INT addrlen=sizeof(sockaddr);
                        SOCKET sSocket;
                        
                        sSocket = accept(pgd->sSystemStreamSocket,(LPSOCKADDR)&sockaddr,&addrlen);
                        if (INVALID_SOCKET == sSocket) 
                        {
                            err = WSAGetLastError();
                            DPF(2,"\n stream accept error - err = %d socket = %d",err,(DWORD)sSocket);
                        } else {
                            DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
                            
                            // add the new socket to our receive q
                            hr = AddSocketToReceiveList(pgd,sSocket,0);
                            if (FAILED(hr))
                            {
                                ASSERT(FALSE);
                            }
                        }    
                    }
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
           } // while rval
        
        LEAVE_DPSP();
        
    } // while 1

CLEANUP_EXIT:

    EmptyConnectionList(pgd);
        
    return 0;
    
} // ReceiveThreadProc

// send a message of 0 length telling receiver to reuse connection
HRESULT SendReuseConnectionMessage(SOCKET sSocket)
{
    DWORD dwMessage;
    HRESULT hr=DP_OK;
    UINT err;
    
    // send a 0 sized message (w/ our header) to the stream socket, to tell 
    // receive thread proc to reuse this socket for replies to us
    SetMessageHeader(&dwMessage,0,REUSE_TOKEN);
    
    err = send(sSocket,(LPBYTE)&dwMessage,sizeof(DWORD),0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();

        // if we're shutdown, don't print a scary
        DPF(0,"SendReuseControlMessage failed with error - err = %d\n",err);
        hr = E_FAIL;
    }    

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CreateAndConnectSocket"

// called by reliable send and DoTCPEnumSessions
HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR_IN6 psockaddr, BOOL bOutBoundOnly)
{
    UINT err;
    HRESULT hr;
    int iAddrLen = sizeof(SOCKADDR_IN6);

    ASSERT(psSocket);
    
    hr = CreateSocket(pgd,psSocket,dwType,0,&sockaddr_any,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect :: create socket failed - err = %d\n",err);
           return hr;
    }
    
    // try to connect    
    hr = SPConnect(psSocket,(LPSOCKADDR)psockaddr,iAddrLen, bOutBoundOnly);
    if (FAILED(hr)) 
    {
        DPF(0,"createandconnect - connect socket failed\n");
        goto ERROR_EXIT;
    }

    if (bOutBoundOnly)
    {
        // so we receive the reply (server will reuse the connection)
        hr = AddSocketToReceiveList(pgd, *psSocket,SP_CONNECTION_FULLDUPLEX);
        if (FAILED(hr))
        {
            DPF(0, "failed to add socket to receive list");
            goto ERROR_EXIT;
        }
    }
    
    return DP_OK;
    // not a fall through

ERROR_EXIT:
    if (INVALID_SOCKET != *psSocket)
    {
        err = closesocket(*psSocket);
        if (SOCKET_ERROR == err) 
        {
            err = WSAGetLastError();
            DPF(0,"send closesocket error - err = %d\n",err);
            return E_UNEXPECTED;
        }
        *psSocket = INVALID_SOCKET;
    }

    return hr;    
    
}  // CreateAndConnectSocket


#undef DPF_MODNAME
#define DPF_MODNAME    "EnumSessions"

// starts the streamacceptthread (TCP) or the dgramlistenthreadproc (IPX) so we can 
// get replies from the nameserver for our requests
HRESULT StartupEnumThread(IDirectPlaySP * pISP,LPGLOBALDATA pgd)
{
    HRESULT hr;
    UINT err;
    DWORD dwThreadID;
    
    // set up socket
    {
        if (pgd->hStreamReceiveThread)
        {
            return DP_OK; // already running
        }
        
        // create system stream socket so we can start listening for connections
        ASSERT(INVALID_SOCKET == pgd->sSystemStreamSocket);
        hr = CreateAndInitStreamSocket(pgd); 
        if (FAILED(hr)) 
        {
            ASSERT(FALSE);
            return hr;
        }

        // start the enum accept thread (listen for new connections)
        pgd->hStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,
            (LPVOID)pISP,0,&dwThreadID);
        if (!pgd->hStreamReceiveThread)
        {
            DPF(0, "Failed to start stream receive thread");
            ASSERT(FALSE);
        } else SetThreadPriority(pgd->hDGramReceiveThread, THREAD_PRIORITY_ABOVE_NORMAL);
    }
    
    return DP_OK;
    
} // StartupEnumThread

/*
 *        Creates a dgram socket, sends enum sessions request, and closes socket.  
 *
 *        reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoUDPEnumSessions(LPGLOBALDATA pgd, SOCKADDR_IN6 *lpSockAddr, DWORD dwAddrSize,
    LPDPSP_ENUMSESSIONSDATA ped)
{
    SOCKET sSocket;
    HRESULT hr;
    BOOL bTrue=TRUE;
    UINT err;
    unsigned int index;

    DEBUGPRINTADDR(5,"enum unreliable - sending to ",lpSockAddr); 
    
    hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,0,&sockaddr_any,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"!!! enum - could not create socket error = %d\n",err);
        return E_FAIL;
    }

    if (IN6_ADDR_EQUAL(&in6addr_multicast, &lpSockAddr->sin6_addr)) {
        // Workaround a current bug in the IPv6 stack which requires
        // the scope id to be 0 and use IPV6_MULTICAST_IF instead

        index = lpSockAddr->sin6_scope_id;
        lpSockAddr->sin6_scope_id = 0;

        if( SOCKET_ERROR == setsockopt( sSocket,IPPROTO_IPV6,IPV6_MULTICAST_IF,
            (char FAR *)&index,sizeof(index) ) )
        {
            DPF(0, "IPV6_MULTICAST_IF got error = %d\n", WSAGetLastError());
            return E_FAIL;
        }
    }
    
    // send out the enum message
    err = sendto(sSocket,ped->lpMessage,ped->dwMessageSize,0,(LPSOCKADDR)lpSockAddr,dwAddrSize);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
        goto CLEANUP_EXIT;
    }

    // fall through

CLEANUP_EXIT:
    KillSocket(sSocket,TRUE,FALSE);
    return hr;
} // DoUDPEnumSessions

// A very short lived thread -- may hang in connect with invalid id to connect to.
DWORD WINAPI TCPEnumSessionsAsyncThread(LPVOID lpv)
{
    LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
    HRESULT hr;
    UINT err;


    
    DPF(9,"==> Entering TCPEnumSessionsAsyncThread(0x%08x)\n", lpv);
    
    pgd->sEnum = INVALID_SOCKET;

    DEBUGPRINTADDR(5,"enum reliable - sending to ",&pgd->saEnum); 
    
    // get us a new connection
    hr = CreateAndConnectSocket(pgd,&pgd->sEnum,SOCK_STREAM,&pgd->saEnum,pgd->bOutBoundOnly);
    if (FAILED(hr))
    {
        DPF(0, "Failed to get socket for enum sessions - hr: 0x%08x",hr);
        goto EXIT;
    }
    
    // send the request
    err = send(pgd->sEnum,pgd->lpEnumMessage,pgd->dwEnumMessageSize,0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        DEBUGPRINTADDR(0,"reliable send  - FAILED - sending to ",&pgd->saEnum);
        hr = E_FAIL;
        goto ERROR_EXIT;
        // fall through
    }

    if (!pgd->bOutBoundOnly)
    {
        DEBUGPRINTSOCK(5,"Closing enum sessions connection - ", &pgd->sEnum);
        // close the connection
        KillSocket(pgd->sEnum,TRUE,FALSE);
        pgd->sEnum=INVALID_SOCKET;
    }

    goto EXIT;
    // not a fall through

ERROR_EXIT:
    if (INVALID_SOCKET != pgd->sEnum)     {
        KillSocket(pgd->sEnum,TRUE,FALSE);
        pgd->sEnum=INVALID_SOCKET;
    }    
EXIT:

    ENTER_DPSP();
    if(pgd->hTCPEnumAsyncThread){
        CloseHandle(pgd->hTCPEnumAsyncThread);
        pgd->hTCPEnumAsyncThread=0;
    }    
    if(pgd->lpEnumMessage){
        MemFree(pgd->lpEnumMessage);
        pgd->lpEnumMessage=0;
    }
    LEAVE_DPSP();
    DPF(5,"<== Leaving TCPEnumSessionsAsyncThread\n");
    return 0;
    
} // TCPEnumSessionsAsyncThread

/*
 *        Creates a stream socket, sends enum sessions request, and closes socket 
 *        depending on bHostWillReuseConnection. If bHostWillReuseConnection is TRUE, server will
 *        close the connection after sending reply.
 *
 *        reply is received in streamlistenthreadproc and passed into dplay.
 */
HRESULT DoTCPEnumSessionsAsync(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,    
LPDPSP_ENUMSESSIONSDATA ped,BOOL bOutBoundOnly)
{
    DWORD dwJunk;
    HRESULT hr=DP_OK;

    // First see if we have a thread running already, if we do cancel it.

    KillTCPEnumAsyncThread(pgd);

    // package the request up and hand it to the thread.

    ENTER_DPSP();

    pgd->lpEnumMessage=MemAlloc(ped->dwMessageSize);
    
    if(pgd->lpEnumMessage){
        memcpy(pgd->lpEnumMessage, ped->lpMessage, ped->dwMessageSize);
        pgd->dwEnumMessageSize=ped->dwMessageSize;
    } else {
        hr=DPERR_OUTOFMEMORY;
        goto EXIT;
    }

    memcpy(&pgd->saEnum,lpSockAddr,dwAddrSize);
    pgd->dwEnumAddrSize=dwAddrSize;
    pgd->bOutBoundOnly=bOutBoundOnly;
    pgd->sEnum=INVALID_SOCKET;

    if(!(pgd->hTCPEnumAsyncThread=CreateThread(NULL,0,TCPEnumSessionsAsyncThread,pgd,0,&dwJunk))){
        MemFree(pgd->lpEnumMessage);
        pgd->lpEnumMessage=NULL;
        hr=DPERR_OUTOFMEMORY;
    }
    
EXIT:    
    LEAVE_DPSP();
    return hr;
}

void
EnumOnInterface(IPV6_INFO_INTERFACE *IF, void *Context1, void *Context2, void *Context3)
{
    LPGLOBALDATA pgd = (LPGLOBALDATA)Context1;
    LPSOCKADDR_IN6 psa = (LPSOCKADDR_IN6)Context2;
    LPDPSP_ENUMSESSIONSDATA ped = (LPDPSP_ENUMSESSIONSDATA)Context3;
    SOCKADDR_IN6 sa;

    psa->sin6_scope_id = IF->This.Index;
    DoUDPEnumSessions(pgd, psa, sizeof(SOCKADDR_IN6), ped);
}

/*
 ** EnumSessions
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: ped - see dplayi.h
 *
 *  DESCRIPTION:
 *    
 *        creates a stream socket. sends a message to the address specified by the user.
 *        fills in return address so server can reply.  
 *
 *        reply is received in streamlistenthreadproc and passed into dplay.
 *
 *  RETURNS:
 *        DP_OK always.
 *
 */
HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
#ifdef DEBUG
    SOCKET sSocket; // bcast socket
#endif // DEBUG
    SOCKADDR_IN6 sockaddr;
    INT addrlen=sizeof(sockaddr);
    HRESULT hr;
    DWORD dwErr=0;
    BOOL bTrue = TRUE;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    BOOL bOutBoundOnly = FALSE;

    DPF(5,"SP_EnumSessions");

    // get the global data
    hr =ped->lpISP->lpVtbl->GetSPData(ped->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }
    
    // Do we have an active IP address?  If not and DUN is enabled, a DUN
    // dialog will pop for enum to a specific machine.
    // bReturnStatus means no extra dialogs are wanted so we will abort
    // if there are no local connections.
    if (ped->bReturnStatus)
    {
        SOCKET_ADDRESS_LIST *pList = GetHostAddr();
        if (!pList)
        {
            DPF(0, "No Dial-up network or netcard present");
            return DPERR_NOCONNECTION;    // no local IP address = no network
        }
        FreeHostAddr(pList);
    }

    memset(&sockaddr,0,sizeof(sockaddr));
    // find out where we should send request to
    hr = GetServerAddress(pgd,&sockaddr);
    if (FAILED(hr))
    {
        DPF_ERR("failed to get enumeration address");
        return hr;
    }
    
    hr = StartupEnumThread(ped->lpISP,pgd);
    if (FAILED(hr))
    {
        DPF(0," could not start enum handler - hr = 0x%08lx\n",hr);
        return hr;
    }
    
    // set message header
    SetMessageHeader(ped->lpMessage,ped->dwMessageSize,TOKEN);

    SetReturnAddress(ped->lpMessage,SERVICE_SOCKET(pgd));        
    
#ifdef DEBUG    
    sSocket = SERVICE_SOCKET(pgd); // we'll borrow this var for our debug spew
    DEBUGPRINTSOCK(5,"enum - return address = ",&sSocket); 
#endif // DEBUG

    if (IN6_ADDR_EQUAL(&in6addr_multicast, &sockaddr.sin6_addr))
    {
        ForEachInterface(EnumOnInterface, pgd, &sockaddr, ped);
    }
    else
    {
        hr = DoUDPEnumSessions(pgd, &sockaddr, addrlen, ped);
        if (FAILED(hr))
        {
            return hr;
        }

        // send a reliable enum sessions as well, duplicates will be filtered by dplay

        // poke the correct server port
        if (pgd->wApplicationPort)
        {
            // if app specified a port, let's use the mode specified
            // because we'll be enuming the app directly
            sockaddr.sin6_port = htons(pgd->wApplicationPort);
            bOutBoundOnly = (pgd->dwFlags & DPSP_OUTBOUNDONLY);
        }
        else
        {
            // otherwise send enum to dplaysvr
            // see byte-order comment in dpsp.h for this constant
            sockaddr.sin6_port = SERVER_STREAM_PORT;
            bOutBoundOnly = FALSE;
        }
        
        hr = DoTCPEnumSessionsAsync(pgd, (LPSOCKADDR)&sockaddr, addrlen, ped, bOutBoundOnly);
    }
    
    // fall through

    DPF(5,"enum exiting");
    
    return DP_OK;

}// EnumSessions


#undef DPFSessions


#undef DPF_MODNAME
#define DPF_MODNAME    "SP_GetAddress"

// helper to handle local player address(es)
HRESULT WINAPI SP_GetAddressLocal(LPDPSP_GETADDRESSDATA pad)
{
    int i, j, count, ret;
    HRESULT hr = DP_OK;
    SOCKET_ADDRESS_LIST *pList;
    char *pszIPAddr, *pszBuf = NULL;
    DWORD dwIPAddrSize;
    WCHAR *pszIPAddrW, *pszBufW = NULL;
    LPDPCOMPOUNDADDRESSELEMENT paDPAddrEl = NULL;

    pList = GetHostAddr();
    if (!pList)
    {
        return DPERR_GENERIC;
    }

    count = pList->iAddressCount;

    // allocate our DPAddress assembly buffers
    // ANSI and UNICODE elements for each IP address plus one SP guid
    // max size of IPv6 address literal notation = INET6_ADDRSTRLEN
    ENTER_DPSP();
    // addressElement array
    paDPAddrEl = MemAlloc(sizeof(DPCOMPOUNDADDRESSELEMENT)*(2*count + 1));
    // one big buffer each for ANSI and UNICODE strings
    pszIPAddr = pszBuf = MemAlloc(INET6_ADDRSTRLEN*count);
    pszIPAddrW = pszBufW = MemAlloc(sizeof(WCHAR)*(INET6_ADDRSTRLEN*count));
    if (!paDPAddrEl || !pszBuf || !pszBufW)
    {
        ASSERT(FALSE);
        FreeHostAddr(pList);
        MemFree(paDPAddrEl);
        MemFree(pszBuf);
        MemFree(pszBufW);
        LEAVE_DPSP();
        return DPERR_NOMEMORY;
    }
    LEAVE_DPSP();
    
    // service provider chunk
    paDPAddrEl[0].guidDataType = DPAID_ServiceProvider;
    paDPAddrEl[0].dwDataSize = sizeof(GUID);
    paDPAddrEl[0].lpData = (LPVOID) &GUID_IPV6;

    // make an ANSI and UNICODE string of each IP address
    for (i=0,j=1; i<pList->iAddressCount; i++)
    {
        DWORD dwStrLen;        // includes terminator

        dwIPAddrSize = INET6_ADDRSTRLEN;
        ret = WSAAddressToString(pList->Address[i].lpSockaddr, 
                                 pList->Address[i].iSockaddrLength,
                                 NULL, pszIPAddr, &dwIPAddrSize);
        if (ret) {
            hr = DPERR_GENERIC;
            goto cleanup;
        }

        dwStrLen = (DWORD)AnsiToWide(pszIPAddrW, pszIPAddr, INET6_ADDRSTRLEN);
        if (dwStrLen == 0 || dwStrLen > INET6_ADDRSTRLEN)
        {
            ASSERT(FALSE);
            hr = DPERR_GENERIC;
            goto cleanup;
        }

        paDPAddrEl[j].guidDataType = DPAID_INet; // XXX
        paDPAddrEl[j].dwDataSize = dwStrLen;
        paDPAddrEl[j++].lpData = pszIPAddr;
        paDPAddrEl[j].guidDataType = DPAID_INetW; // XXX
        paDPAddrEl[j].dwDataSize = dwStrLen * sizeof(WCHAR);
        paDPAddrEl[j++].lpData = pszIPAddrW;
        pszIPAddr += INET6_ADDRSTRLEN;    // bump buffer ptrs by max str size
        pszIPAddrW += INET6_ADDRSTRLEN;
    }

    // create the address
    hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
                paDPAddrEl, 2*count+1, pad->lpAddress, pad->lpdwAddressSize);

cleanup:
    ENTER_DPSP();
    FreeHostAddr(pList);
    MemFree(paDPAddrEl);
    MemFree(pszBuf);
    MemFree(pszBufW);
    LEAVE_DPSP();

    return hr;
} // SP_GetAddressLocal

// get the ip address of the player from its playerdata
// ask winsock to convert that to a hostname
HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
    HRESULT hr = DP_OK;
    LPSPPLAYERDATA ppd;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    CHAR szNetName[INET6_ADDRSTRLEN];
    DWORD dwNetNameSize;
    UINT nStrLen;
    LPSOCKADDR_IN6 psockaddr;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    DPCOMPOUNDADDRESSELEMENT addressElements[3];
    WCHAR szNetNameW[HOST_NAME_LENGTH];
    INT ret;

    // get the global data
    hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }
    
    hr = pad->lpISP->lpVtbl->GetSPPlayerData(pad->lpISP,pad->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        return hr;
    }
    
    if (pad->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)    
    {
        // We use a different approach for local players
        return SP_GetAddressLocal(pad);
    }
    else 
    {
        psockaddr = DGRAM_PSOCKADDR(ppd);
        dwNetNameSize = sizeof(szNetName);
        ret = WSAAddressToString((LPSOCKADDR)psockaddr, sizeof(*psockaddr),
                                 NULL, szNetName, &dwNetNameSize);
    }
    if (ret)
    {
        // rut ro
        DPF_ERR("got no string back from getaddress");
        return E_FAIL;
    }
    nStrLen = strlen(szNetName)+1;

    DPF(2,"get address found address for player id %d = %s\n",pad->idPlayer,szNetName);

    // get UNICODE version of address
    if (!AnsiToWide(szNetNameW, szNetName, HOST_NAME_LENGTH))
        return (DPERR_GENERIC);

    // service provider chunk
    addressElements[0].guidDataType = DPAID_ServiceProvider;
    addressElements[0].dwDataSize = sizeof(GUID);
    addressElements[0].lpData = (LPVOID) &GUID_IPV6;

    // ANSI name
    addressElements[1].guidDataType = DPAID_INet;
    addressElements[1].dwDataSize = nStrLen;
    addressElements[1].lpData = szNetName;

    // UNICODE name
    addressElements[2].guidDataType = DPAID_INetW;
    addressElements[2].dwDataSize = nStrLen * sizeof(WCHAR);
    addressElements[2].lpData = szNetNameW;

    // create the address
    hr = pad->lpISP->lpVtbl->CreateCompoundAddress(pad->lpISP,
                        addressElements, 3,
                        pad->lpAddress, pad->lpdwAddressSize);

    return hr;

} // SP_GetAddress

#undef DPF_MODNAME
#define DPF_MODNAME    "Reply"
// called by ReplyThreadProc to send the reply out on the wire
HRESULT SendReply(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
    HRESULT hr;
    SOCKET sSocket;
    UINT addrlen = sizeof(SOCKADDR_IN6);
    UINT err;
    BOOL bConnectionExists = FALSE;

    // now, send out prd        
    {
            DPID dpidPlayer=0;

#ifdef FULLDUPLEX_SUPPORT
            // if client wants us to reuse a connection, it would have indicated so and the connection
            // would have been added to our send list by now. See if it exists.
            
            // todo - we don't want to search the receive list everytime -  find a better way
            bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket,&dpidPlayer);
#endif // FULLDUPLEX_SUPPORT
            
            if (!bConnectionExists)
            {

                // socket didn't exist in our send list, let's send it on a new temporary connection
                
                DEBUGPRINTADDR(9,"Sending reply on a new connection to - ", &(prd->sockaddr));                

                hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,&sockaddr_any,&err,FALSE);
                if (FAILED(hr)) 
                {
                    DPF(0,"create reply socket failed - err = %d\n",err);
                    return hr;
                }

                SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket);        
                hr = SPConnect(&sSocket,(LPSOCKADDR)&(prd->sockaddr),addrlen,FALSE);
                if (FAILED(hr))
                {
                    DEBUGPRINTADDR(0,"reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
                }
                else 
                {
                    DEBUGPRINTADDR(9,"Sending reply to - ", &(prd->sockaddr));
                    err = send(sSocket,prd->lpMessage,prd->dwMessageSize,0);                    
                    if (SOCKET_ERROR == err) 
                    {
                        err = WSAGetLastError();
                        DPF(0,"reply - send error - err = %d\n",err);
                        hr = E_FAIL;
                    }
                }
                
                // nuke the socket
                KillSocket(sSocket,TRUE,FALSE);
                
            }
            else
            {
                DEBUGPRINTADDR(9,"Sending reply on an existing connection to - ", &(prd->sockaddr));                

                err = send(prd->sSocket,prd->lpMessage,prd->dwMessageSize,0);                    
                if (SOCKET_ERROR == err) 
                {
                       err = WSAGetLastError();
                       DPF(0,"reply - send error - err = %d\n",err);
                    hr = E_FAIL;
                }

                // close the connection if it's a temporary one (no player id yet).
                if (0 == dpidPlayer)
                {
                    RemoveSocketFromReceiveList(pgd,prd->sSocket);
                    RemoveSocketFromBag(pgd,prd->sSocket);
                }
            }
            
    }
    
    return hr;
    
} // SendReply


DWORD WINAPI ReplyThreadProc(LPVOID pvCast)
{
    LPREPLYLIST prd,prdNext;
    HRESULT hr=DP_OK;
    DWORD dwRet;
    LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
    
    
    while (1)
    {
        // wait on our event.  when it's set, we either split, or empty the reply list
        dwRet = WaitForSingleObject(pgd->hReplyEvent,INFINITE);
        if (WAIT_OBJECT_0 != dwRet)
        {
            ASSERT(FALSE);
            goto CLEANUP_EXIT;
        }

        // shutdown?        
        if (pgd->bShutdown)
        {
            goto CLEANUP_EXIT;
        }

    Top:
        // find our reply node
        ENTER_DPSP();
        
        // take the first one off the list
        prd = pgd->pReplyList;        
        if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
        
        LEAVE_DPSP();
        
        while (prd)
        {
            hr = SendReply(pgd,prd);
            if (FAILED(hr))
            {
                DPF_ERR("SendReply failed hr = 0x%08lx\n");
                // we can't reach the guy, clean out other async sends.
                RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
                goto Top;
            }
            
            // free up the reply node
            ENTER_DPSP();
                
            if (prd->lpMessage) MemFree(prd->lpMessage);
            MemFree(prd);

            // take the next one off the list
            prd = pgd->pReplyList;
            if (pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
                
            LEAVE_DPSP();
        }

    } // 1

CLEANUP_EXIT:
    
    ENTER_DPSP();

    // cleanout reply list
    prd = pgd->pReplyList;    
    while (prd)
    {
        prdNext = prd->pNextReply;
        if (prd->lpMessage) MemFree(prd->lpMessage);
        MemFree(prd);
        prd = prdNext;
    }
    pgd->pReplyList = NULL;
    
    CloseHandle(pgd->hReplyEvent);
    pgd->hReplyEvent = 0;
    
    LEAVE_DPSP();
    
    DPF(6,"replythreadproc exit");
    
    return 0;
    
}  // ReplyThreadProc

HRESULT StartReplyThread(LPGLOBALDATA pgd)
{
    HANDLE hThread;
    DWORD dwThreadID;
    
    // 1st, create the event
    pgd->hReplyEvent = CreateEvent(NULL,FALSE,FALSE,NULL);    
    if (!pgd->hReplyEvent)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    // now, spin the thread    
    if (hWS2)
    {
        hThread = CreateThread(NULL,0,AsyncSendThreadProc,pgd,0,&dwThreadID);
    }
    else 
    {
        hThread = CreateThread(NULL,0,ReplyThreadProc,pgd,0,&dwThreadID);
    }

    if (!hThread)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
    pgd->hReplyThread = hThread;
    
    return DP_OK;
    
} // StartReplyThread

HRESULT WINAPI InternalSP_Reply(LPDPSP_REPLYDATA prd, DPID dwPlayerID)
{
    LPSOCKADDR_IN6 psockaddr;
    HRESULT hr=DP_OK;
    LPMESSAGEHEADER phead;
    LPBYTE pSendBufferCopy;
    LPREPLYLIST prl,prlList;    
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;

    // get the global data
    hr =prd->lpISP->lpVtbl->GetSPData(prd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }
    
    if (prd->dwMessageSize > SPMAXMESSAGELEN)
    {
        ASSERT(FALSE); 
        return DPERR_SENDTOOBIG;
    }

    // check the header
    if (!prd->lpSPMessageHeader || !VALID_DPWS_MESSAGE(prd->lpSPMessageHeader))
    {
        DPF_ERR("    YIKES! Got invalid SP header - can't reply ");
        ASSERT(FALSE);
        return E_FAIL;
    }
    
    // get the address to reply to
    phead = (LPMESSAGEHEADER)prd->lpSPMessageHeader;
    psockaddr = &(phead->sockaddr);
    DEBUGPRINTADDR(5,"reply - sending to ",psockaddr);

    DPF(7,"reply - q'ing %d bytes hEvent = 0x%08lx\n",prd->dwMessageSize,pgd->hReplyEvent);

    // stick the message size in the message
    SetMessageHeader(prd->lpMessage,prd->dwMessageSize,TOKEN);

    // build a copy of everything for our receive thread
    ENTER_DPSP();
    
    prl = MemAlloc(sizeof(REPLYLIST));
    
    if (!prl)
    {
        LEAVE_DPSP();                
        DPF_ERR("could not send reply - out of memory");
        return E_OUTOFMEMORY;
    }

    
    pSendBufferCopy = MemAlloc(prd->dwMessageSize);
    if (!pSendBufferCopy)
    {
        MemFree(prl);
        LEAVE_DPSP();
        DPF_ERR("could not send reply - out of memory");
        return E_OUTOFMEMORY;
    }
    
    memcpy(pSendBufferCopy,prd->lpMessage,prd->dwMessageSize);
    
    prl->lpMessage = pSendBufferCopy;
    prl->dwMessageSize = prd->dwMessageSize;
    prl->sockaddr = *psockaddr;
    prl->sSocket = INVALID_SOCKET;
    // since are replies could be sent async, we need to keep track
    // of how many bytes have gone out
    prl->pbSend = pSendBufferCopy;
    prl->dwBytesLeft = prd->dwMessageSize;
    prl->dwPlayerTo=dwPlayerID;     
    // put prl on the end of the reply list
    prlList = pgd->pReplyList;
    if (!prlList)
    {
        pgd->pReplyList = prl;    
    }
    else
    {
        // find the end
        while (prlList->pNextReply) prlList = prlList->pNextReply;
        ASSERT(!prlList->pNextReply);
        prlList->pNextReply = prl;
    }
     
    // do we need to start the reply event?
    if (!pgd->hReplyThread)
    {
        hr = StartReplyThread(pgd);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
        }
    }
    
    LEAVE_DPSP();
        
    // tell the reply event to do its thing
    SetEvent(pgd->hReplyEvent);
    
    return DP_OK;
    
}    // reply

/*
 ** Reply
 *
 *  CALLED BY: DPLAY
 *
 *  PARAMETERS: prd - see dplayi.h
 *
 *  DESCRIPTION:
 *        when one of the receive loops calls into dplay, dplay may call reply.
 *        the receive loop extracts the return address out of the message, and passes
 *        it to dplay .  dplay passes this to reply (via prd), which figures out how to send the
 *        return message.
 *        
 *
 *  RETURNS:   E_FAIL on a socket error or DP_OK.
 *
 */
HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
    return InternalSP_Reply(prd, 0);
}



#undef DPF_MODNAME
#define DPF_MODNAME    "CreatePlayer"

// 
// if we're starting up a nameserver, register it w/ dphelp.exe
// see %MANROOT%\misc\w95help.c and %MANROOT%\ddhelp\dphelp.c
HRESULT StartDPHelp(LPGLOBALDATA pgd, USHORT port)
{
    DWORD hpid = 0, dwFlags=0;
    HRESULT    hr;

    CreateHelperProcess( &hpid );
    
    if (!hpid)
    {
        // could't start one...
        return DPERR_UNAVAILABLE;
    }

    if (!WaitForHelperStartup())
    {
        return DPERR_UNAVAILABLE;
    }
    
    hr = HelperAddDPlayServer(port);

    return hr;

}  // StartDPHelp


//
// we've just created a player of type dwFlags. 
// if it's a system player, see if we need to start up our receive thread procs
//
HRESULT StartPlayerListenThreads(IDirectPlaySP * pISP,LPGLOBALDATA pgd,DWORD dwFlags)
{
    DWORD dwThreadID;
    HANDLE hThread;
        
    if ( !(dwFlags & DPLAYI_PLAYER_SYSPLAYER) ) return DP_OK;
    
    if (!pgd->hDGramReceiveThread)
    {
        ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
        hThread = CreateThread(NULL,0,DgramListenThreadProc,
            (LPVOID)pISP,0,&dwThreadID);
        ASSERT(hThread);
        if(pgd->hDGramReceiveThread = hThread){ // check for non-zero hThread
            SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
        }
        
    }
    if (!pgd->hStreamReceiveThread)
    {        
        ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
        hThread = CreateThread(NULL,0,StreamReceiveThreadProc,
            (LPVOID)pISP,0,&dwThreadID);            
        ASSERT(hThread);        
        if(pgd->hStreamReceiveThread = hThread){ // check for non-zero hThread
            SetThreadPriority(hThread, THREAD_PRIORITY_ABOVE_NORMAL);
        }
    }

    return DP_OK;
    
} // StartPlayerListenThreads
    
// create a player.  get a stream and dgram socket for it, and start their listen threads.
HRESULT WINAPI SP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
    LPSPPLAYERDATA ppd;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;

    // get the global data
    hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    if (!(pcpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
        DWORD dwSize = sizeof(SPPLAYERDATA);
        LPMESSAGEHEADER pmsg;

        hr = pcpd->lpISP->lpVtbl->GetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            return hr;
        }

        if (sizeof(SPPLAYERDATA) != dwSize)
        {
            // this can happen if it's a game server supplied player
            return DP_OK;
        }
        
        pmsg = (LPMESSAGEHEADER)pcpd->lpSPMessageHeader;
        if (!pmsg)
        {
            // this can happen if it's a game server supplied player
            return DP_OK;
        }
        // make it multihomed.  we passed the received address w/ the createplayer message.
        // set the receive address on the player here.

        // if the ip addr wasn't set, this player hasn't been "homed" yet.
        // we set it here.
        IP6_GetAddr((SOCKADDR_IN6 *)DGRAM_PSOCKADDR(ppd),(SOCKADDR_IN6 *)&(pmsg->sockaddr));
        IP6_GetAddr((SOCKADDR_IN6 *)STREAM_PSOCKADDR(ppd),(SOCKADDR_IN6 *)&(pmsg->sockaddr));
            
#ifdef FULLDUPLEX_SUPPORT
        // if client want's us to reuse a connection, the socket would have been added to the 
        // send bag already, but the id would be 0. Update the player id.
        UpdateSocketPlayerID(pgd,&pmsg->sockaddr,pcpd->idPlayer);
#endif // FULLDUPLEX_SUPPORT        
        
        return DP_OK;
    } // !Local

    // it's local, so get it some sockets + threads if we need to

    // alloc the sp player data for this player
    ENTER_DPSP();
    
    ppd = MemAlloc(sizeof(SPPLAYERDATA));
    
    LEAVE_DPSP();
    
    if (!ppd) 
    {
        DPF_ERR("could not alloc player data struct");
        return E_OUTOFMEMORY;
    }

    hr =  CreatePlayerDgramSocket(pgd,ppd,pcpd->dwFlags);
    if (FAILED(hr))
    {
        DPF_ERR("could not create dgram socket"); 
        goto CLEANUP_EXIT;
    }

    hr =  CreatePlayerStreamSocket(pgd,ppd,pcpd->dwFlags);
    if (FAILED(hr))
    {
        DPF_ERR("could not create stream socket"); 
        goto CLEANUP_EXIT;
    }
     
    // store the ppd
    hr = pcpd->lpISP->lpVtbl->SetSPPlayerData(pcpd->lpISP,pcpd->idPlayer,ppd,dwSize,DPSET_REMOTE);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto CLEANUP_EXIT;
    }

    // see if we need to start listen thread for this player type.
    hr = StartPlayerListenThreads(pcpd->lpISP,pgd,pcpd->dwFlags);
    
    // if we need ddhelp, start it up
    if (pcpd->dwFlags & DPLAYI_PLAYER_NAMESRVR)
    {
        // it's ok to pass dgram port to dplaysvr always - we use the same number for stream
        // socket as well
        hr = StartDPHelp(pgd,IP_DGRAM_PORT(ppd));
        if (FAILED(hr))
        {
            // ddhelp.exe barfed
            DPF_ERR(" CREATE SERVER - COULD NOT START ENUM LISTEN APPLICATION");
            DPF_ERR(" GAME WILL PLAY - BUT WILL NOT RECEIVE ENUMSESSIONS REQUESTS");
            goto CLEANUP_EXIT;
        }
    }

    // fall through to clean up
CLEANUP_EXIT:    

    ENTER_DPSP();
    
    if (ppd) MemFree(ppd);
    
    LEAVE_DPSP();
    
    return hr;

} // CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME    "DeletePlayer"
void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID)
{
    UINT i=0;
    BOOL bFound = FALSE;
    SOCKET sSocket=INVALID_SOCKET;
    DWORD dwSocketFlags;
    
    if (0 == dwID)
    {
        return;
    }

    ENTER_DPSP();

    // see if we've got one
    while (!bFound && (i<pgd->nSocketsInBag))
    {
        if (pgd->BagOSockets[i].dwPlayerID == dwID) 
        {
            bFound = TRUE;
            sSocket = pgd->BagOSockets[i].sSocket;            
            dwSocketFlags = pgd->BagOSockets[i].dwFlags;
            
            DPF(5,"removing socket from bago id = %d, slot = %d",dwID,i);
            pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
            pgd->BagOSockets[i].dwPlayerID = 0;
        }
        else i++;
    }

    LEAVE_DPSP();
    
    if (bFound)    
    {
        if (INVALID_SOCKET == sSocket) return ;

        // if socket is fullduplex, remove it from the receive list as well
        if (dwSocketFlags & DPSP_OUTBOUNDONLY)
        {
            // this function will kill the socket as well
            RemoveSocketFromReceiveList(pgd,sSocket);
        }
        else
        {        
            KillSocket(sSocket,TRUE,FALSE);
        }
    }

    return ;
    
} // RemovePlayerFromSocketBag

HRESULT WINAPI SP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    HRESULT hr;
    DWORD sleepcount=0;


    DPF(9, "Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
        pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
    
    // get the global data
    hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    // give the reply list 5 seconds to clear out
    while(bAsyncSendsPending(pgd, pdpd->idPlayer)){
        Sleep(100);
        if(sleepcount++ == 50){
            break;
        }
    }

    RemovePendingAsyncSends(pgd, pdpd->idPlayer);

    // if it's not local, we don't care
    if (!(pdpd->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
        RemovePlayerFromSocketBag(pgd,pdpd->idPlayer);
        return DP_OK;
    }

    // if it's not a sysplayer - we're done
    // if its a sysplayer, we kill 'em, cause we may need to rebind to a new port
    if (!(pdpd->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        return DP_OK;
    }
    
    if (pdpd->dwFlags & DPLAYI_PLAYER_NAMESRVR)
    {
        USHORT port;
        LPSPPLAYERDATA ppd;
        DWORD dwSize = sizeof(SPPLAYERDATA);
         
        // we need to get the port to to delete the server 
        hr = pdpd->lpISP->lpVtbl->GetSPPlayerData(pdpd->lpISP,pdpd->idPlayer,&ppd,&dwSize,DPGET_REMOTE);
        if ( FAILED(hr) || (sizeof(SPPLAYERDATA) != dwSize) )
        {
            ASSERT(FALSE);
        }
        else 
        {
            // tell dplaysvr to delete this server
            port = IP_DGRAM_PORT(ppd);
            if ( !HelperDeleteDPlayServer(port) )
            {
                // ddhelp.exe barfed
                DPF_ERR(" could not unregister w/ dphelp");
                // keep going...
            }
        }
    }

    return DP_OK;

} // DeletePlayer

#undef DPF_MODNAME
#define DPF_MODNAME    "UnreliableSend"
HRESULT UnreliableSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR_IN6 sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    LPSPPLAYERDATA ppdTo;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    
    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
    {
        return DPERR_SENDTOOBIG;
    }

    if (INVALID_SOCKET == pgd->sUnreliableSocket)
    {
        hr = CreateSocket(pgd,&(pgd->sUnreliableSocket),SOCK_DGRAM,0,&sockaddr_any,&err,FALSE);
        if (FAILED(hr)) 
        {
            DPF(0,"create unreliable send socket failed - err = %d\n",err);
            return hr;
        }
    }

    // get to address    
    if (0 == psd->idPlayerTo) 
    {
        sockaddr = pgd->saddrNS;
    }
    else
    {
        hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            return hr;
        }

        CopyMemory(&sockaddr, DGRAM_PSOCKADDR(ppdTo), iAddrLen);
    }

    // put the token + size on front of the mesage
    SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

    if (psd->bSystemMessage) 
    {
        SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));
    } // reply
    else 
    {
        // see if we can send this message w/ no header
        // if the message is smaller than a dword, or, if it's a valid sp header (fooling us
        // on the other end, don't send any header
        if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(psd->lpMessage))) )
        {
            psd->lpMessage = (LPBYTE)psd->lpMessage +sizeof(MESSAGEHEADER);
            psd->dwMessageSize -= sizeof(MESSAGEHEADER);
        }
    }
    
    DEBUGPRINTADDR(5,"unreliable send - sending to ",&sockaddr);    

       err = sendto(pgd->sUnreliableSocket,psd->lpMessage,psd->dwMessageSize,0,
           (LPSOCKADDR)&sockaddr,iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        hr = E_UNEXPECTED;
    }

// fall through...
    return hr;
        
} // UnreliableSend

#undef DPF_MODNAME
#define DPF_MODNAME    "ReliableSend"

// see if we can find or create a connected socket in our
// bag o' sockets for player dwID
HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID,
LPSOCKADDR_IN6 psockaddr)
{
    HRESULT hr;
    UINT i=0;
    BOOL bFound = FALSE;
    BOOL bTrue = TRUE;
    UINT err;
    SOCKET sSocket;
    
    DPF(9, "GetSocketFromBag for id %d",dwID);

    if (0 == dwID)
    {
        // need a real id
        return E_FAIL;
    }

    ENTER_DPSP();

    // see if we've got one    already hooked up
    while ((i < pgd->nSocketsInBag) && !bFound)
    {
        // if it's a valid socket and the id's match, use it
        if ( (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) && 
            (pgd->BagOSockets[i].dwPlayerID == dwID) )
        {
            bFound = TRUE;
        }
        else i++;
    }

    LEAVE_DPSP();

    if (bFound)    
    {
        // bingo! got one
        DPF(7, "Found socket in bag for player %d",dwID);
        *psSocket = pgd->BagOSockets[i].sSocket;
        return DP_OK;
    }

    // we don't have a socket for this player, let's get a new one
    DPF(5,"adding new socket to bag for id = %d, slot = %d",dwID,i);

    // create and connect socket
    hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,psockaddr, (pgd->dwFlags & DPSP_OUTBOUNDONLY));
    if (FAILED(hr))
    {
        return hr;
    }

    // enable keepalives
    if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_KEEPALIVE,
        (char FAR *)&bTrue,sizeof(bTrue) ) )
    {
        err = WSAGetLastError();
        DPF(2,"create - could not turn on keepalive err = %d\n",err);
        // keep trying
    }

    hr = AddSocketToBag(pgd, sSocket, dwID, psockaddr, 0);
    if (FAILED(hr))
    {
        DPF(0,"Failed to add socket to bag: hr = 0x%08x", hr);
        return hr;
    }
    DPF(7,"Created a new socket for player %d",dwID);
    
    *psSocket = sSocket ;

    return hr;
    
} // GetSocketFromBag



HRESULT ReliableSend(LPDPSP_SENDDATA psd)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR_IN6 sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    LPSPPLAYERDATA ppdTo;
    BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;

    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    // get player to
    if (0 == psd->idPlayerTo) 
    {
        sockaddr = pgd->saddrNS;
    }
    else
    {
        hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
        if (FAILED(hr))
        {
            DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
            if (hr != DPERR_INVALIDPLAYER)     // this can happen because of race conditions
                ASSERT(FALSE);
            return hr;
        }

        CopyMemory(&sockaddr, STREAM_PSOCKADDR(ppdTo), iAddrLen);
    }

    if (psd->bSystemMessage) 
    {
        SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));
    }

    // put the token + size on front of the mesage
    SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);

    DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

    hr = InternalReliableSend(pgd,psd->idPlayerTo,&sockaddr, psd->lpMessage, psd->dwMessageSize);

    return hr;
    
} // InternalReliableSend

// puts together a replynode, and calls sp_reply to do 
// an async send
HRESULT AsyncSend(LPDPSP_SENDDATA psd)
{
    SOCKADDR_IN6 sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    LPSPPLAYERDATA ppdTo;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    MESSAGEHEADER head;
    DPSP_REPLYDATA rd;
    
    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    // get player to
    if (0 == psd->idPlayerTo) 
    {
        sockaddr = pgd->saddrNS;
    }
    else
    {
        hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            return hr;
        }

        iAddrLen = sizeof(SOCKADDR_IN6);
        CopyMemory(&sockaddr,STREAM_PSOCKADDR(ppdTo), iAddrLen);
    }

    // write the return address into the on the wire message
    SetReturnAddress(psd->lpMessage,SERVICE_SOCKET(pgd));

    // put the token + size on front of the mesage
    SetMessageHeader(psd->lpMessage,psd->dwMessageSize,TOKEN);
    
    // set up a header.  this will be passed to reply, and will tell the reply thread
    // whre to send teh message
    CopyMemory(& head.sockaddr, &sockaddr, iAddrLen);

    // put our token on the front so the reply thread knows its a valid reply
    SetMessageHeader((LPDWORD)(&head),0,TOKEN); 
    
    // use SP_Reply to send this for us...
    memset(&rd,0,sizeof(rd));
    rd.lpSPMessageHeader = &head;
    rd.lpMessage = psd->lpMessage;
    rd.dwMessageSize = psd->dwMessageSize;
       rd.lpISP = psd->lpISP;
    
    hr = InternalSP_Reply(&rd,psd->idPlayerTo);
    
    return hr;

} // AsyncSend

#ifdef SENDEX

HRESULT WINAPI SP_GetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pgqd)
{

    LPGLOBALDATA pgd;
    DWORD        dwDataSize;
    BILINK       *pBilinkWalker;
    DWORD        dwNumMsgs = 0;
    DWORD        dwNumBytes = 0;

    LPSENDINFO lpSendInfo;
    HRESULT hr;

    hr = pgqd->lpISP->lpVtbl->GetSPData(pgqd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);

    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    EnterCriticalSection(&pgd->csSendEx);

    if(!pgqd->idFrom && !pgqd->idTo){
        // just wants totals, I already know that!
        dwNumMsgs  = pgd->dwMessagesPending;
        dwNumBytes = pgd->dwBytesPending;
    } else {
        // gotta walk the list.
        pBilinkWalker=pgd->PendingSendQ.next;
        while(pBilinkWalker != &pgd->PendingSendQ) 
        {
            lpSendInfo=CONTAINING_RECORD(pBilinkWalker, SENDINFO, PendingSendQ);
            pBilinkWalker=pBilinkWalker->next;

            if(pgqd->idTo && pgqd->idFrom) {
            
                if(lpSendInfo->idTo==pgqd->idTo && lpSendInfo->idFrom==pgqd->idFrom){
                    dwNumMsgs++;
                    dwNumBytes+=lpSendInfo->dwMessageSize;
                }    
                
            } else if (pgqd->idTo){
                if(lpSendInfo->idTo==pgqd->idTo){
                    dwNumMsgs++;
                    dwNumBytes+=lpSendInfo->dwMessageSize;
                }    
            } else if (pgqd->idFrom) {
                if(lpSendInfo->idFrom==pgqd->idFrom){
                    dwNumMsgs++;
                    dwNumBytes+=lpSendInfo->dwMessageSize;
                }    
            } else {
                ASSERT(0);
            }
        }
    }

    LeaveCriticalSection(&pgd->csSendEx);

    if(pgqd->lpdwNumMsgs){
        *pgqd->lpdwNumMsgs = dwNumMsgs;
    }
    if(pgqd->lpdwNumBytes){
        *pgqd->lpdwNumBytes = dwNumBytes;
    }    
    
    
    return DP_OK;

}

HRESULT WINAPI SP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr=DP_OK;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    LPSENDINFO lpSendInfo;

    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    if (psd->dwMessageSize >= SPMAXMESSAGELEN)
    {
        return DPERR_SENDTOOBIG;
    }

    // overlapped and SPheader buffer are allocated together.
    lpSendInfo     = pgd->pSendInfoPool->Get(pgd->pSendInfoPool);
    if(!lpSendInfo){
        hr=DPERR_OUTOFMEMORY;
        DPF(0,"WSOCK: sendex couldn't allocate overlapped, out of memory!\n");
        goto EXIT;
    }
    
    lpSendInfo->SendArray[0].buf = (CHAR *)(lpSendInfo+1);
    lpSendInfo->SendArray[0].len = sizeof(MESSAGEHEADER);

    ASSERT(psd->cBuffers < MAX_SG-1); //BUGBUG: coalesce please!
    
    memcpy(&lpSendInfo->SendArray[1], psd->lpSendBuffers, psd->cBuffers*sizeof(SGBUFFER));

    if (psd->dwFlags & DPSEND_GUARANTEE)
    {
        hr = ReliableSendEx(psd,lpSendInfo);    
        if (hr!=DPERR_PENDING && FAILED(hr)) {
            pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
            DPF(0,"reliable sendex failed - error - hr = 0x%08lx\n",hr);
        }
    }
    else
    {
        hr = UnreliableSendEx(psd,lpSendInfo);
        if (hr!=DPERR_PENDING && FAILED(hr)) {
            pgd->pSendInfoPool->Release(pgd->pSendInfoPool, lpSendInfo);
            DPF(0,"unreliable sendex failed - error -  hr = 0x%08lx\n",hr);
        }    
    }
EXIT:
    return hr;

} // send



HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKET sSocket = INVALID_SOCKET;
    SOCKADDR_IN6 sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr;
    DWORD dwSize = sizeof(SPPLAYERDATA);
    LPSPPLAYERDATA ppdTo;
    BOOL fKillSocket = FALSE; // don't kill this socket, it's from the bago
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;

    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    // get player to
    if (0 == psd->idPlayerTo) 
    {
        sockaddr = pgd->saddrNS;
    }
    else
    {
        hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
        if (FAILED(hr))
        {
            DPF(1, "GetSPPlayerData for player %d returned err %d", psd->idPlayerTo, hr);
            if (hr != DPERR_INVALIDPLAYER)     // this can happen because of race conditions
                ASSERT(FALSE);
            return hr;
        }

        iAddrLen = sizeof(SOCKADDR_IN6);
        CopyMemory(&sockaddr, STREAM_PSOCKADDR(ppdTo), iAddrLen);
    }

    if (psd->bSystemMessage) 
    {
        SetReturnAddress((pSendInfo->SendArray)[0].buf,SERVICE_SOCKET(pgd));
    }

    // put the token + size on front of the mesage
    SetMessageHeader((LPVOID)(pSendInfo->SendArray)[0].buf,psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);

    DEBUGPRINTADDR(5,"reliable send - sending to ",&sockaddr);

    hr = InternalReliableSendEx(pgd,psd,pSendInfo,&sockaddr);

    return hr;
    
} // ReliableSendEx

#endif //SENDEX

HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR_IN6 *
                            lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize)
{
    HRESULT hr;
    SOCKET sSocket = INVALID_SOCKET;
    UINT err;

    // see if we have a connection already
    hr = GetSocketFromBag(pgd,&sSocket,idPlayerTo,lpSockAddr);
    if (SUCCEEDED(hr))
    {
        // we do, send the message
        err = send(sSocket,lpMessage,dwMessageSize,0);
        if (SOCKET_ERROR == err) 
        {
            err = WSAGetLastError();
            // we got a socket from the bag.  send failed,
            // so we're cruising it from the bag
            DPF(0,"send error - err = %d\n",err);
            DPF(4,"send failed - removing socket from bag");
            RemovePlayerFromSocketBag(pgd,idPlayerTo);
            if(err==WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
                hr=DPERR_CONNECTIONLOST;
            } else {
                hr = E_FAIL;
            }
        }

        return hr;
    }

    // if we reach here, we don't have a connection so get a new one

    hr = CreateAndConnectSocket(pgd,&sSocket,SOCK_STREAM,lpSockAddr,(pgd->dwFlags & DPSP_OUTBOUNDONLY));
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // send the message
    err = send(sSocket,lpMessage,dwMessageSize,0);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"send error - err = %d\n",err);
        if(err == WSAECONNRESET || err==WSAENETRESET || err==WSAENOTCONN){
            hr = DPERR_CONNECTIONLOST;
        } else {
            hr = E_FAIL;
        }    
        goto CLEANUP_EXIT;
    }

    // success
    hr = DP_OK;

    // fall through

CLEANUP_EXIT:

    // if we are in outbound only mode, receiver will close the connection, so don't bother
    if ((INVALID_SOCKET != sSocket) && !(pgd->dwFlags & DPSP_OUTBOUNDONLY))
    {
        KillSocket(sSocket, TRUE, FALSE);
    }
    return hr;
}

// called when a to player can't be reached or is deleted.
VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
    LPREPLYLIST prl, prlPrev;
    #ifdef DEBUG
    DWORD dwBlowAwayCount=0;
    #endif
    if(!dwPlayerTo){
        return;
    }
    
    ENTER_DPSP();
    
    prlPrev = (LPREPLYLIST)(&pgd->pReplyList); // HACKHACK, treat struct as dummy node.
    prl     = pgd->pReplyList;
    
    while(prl){
        if(prl->dwPlayerTo == dwPlayerTo){
            prlPrev->pNextReply=prl->pNextReply;
            if(prl->lpMessage) {
                MemFree(prl->lpMessage);
            }    
            MemFree(prl);
            #ifdef DEBUG
            dwBlowAwayCount++;
            #endif
        } else {
            prlPrev=prl;
        }    
        prl=prlPrev->pNextReply;
        
    }
    DPF(4,"RemovePendingAsyncSends for player %x, blew away %d pending sends\n",dwPlayerTo,dwBlowAwayCount);
    LEAVE_DPSP();
}

// In order to ensure send ordering even if we are doing async sends, we 
// check and wait for any pending async sends to complete.  If they don't complete
// in 5 seconds then we make the send async.
BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo)
{
    LPREPLYLIST prlList;

    if(!dwPlayerTo){
        return FALSE;
    }
    ENTER_DPSP();
    prlList = pgd->pReplyList;
    while(prlList){
        if(prlList->dwPlayerTo == dwPlayerTo){
            LEAVE_DPSP();
            return TRUE;
        }
        prlList=prlList->pNextReply;
    }
    LEAVE_DPSP()
    return FALSE;
}


HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
    HRESULT hr=DP_OK;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;

    // get the global data
    hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    if (psd->dwMessageSize >= SPMAXMESSAGELEN)
    {
        return DPERR_SENDTOOBIG;
    }

    if (psd->dwFlags & DPSEND_GUARANTEE)
    {
        if (psd->dwFlags & DPSEND_ASYNC) hr = AsyncSend(psd);
        else {
            if(bAsyncSendsPending(pgd, psd->idPlayerTo)){
                hr = AsyncSend(psd);
            } else {
                hr = ReliableSend(psd);    
            }    
        }
        if (FAILED(hr)) DPF(0,"reliable send failed - error - hr = 0x%08lx\n",hr);
    }
    else
    {
        hr = UnreliableSend(psd);
        if (FAILED(hr)) DPF(0,"unreliable send failed - error -  hr = 0x%08lx\n",hr);
    }

    return hr;

} // send


#ifdef SENDEX
HRESULT InitGlobalsInPlace(LPGLOBALDATA pgd)
{
    InitBilink(&pgd->PendingSendQ);
    InitBilink(&pgd->ReadyToSendQ);
    //pgd->dwBytesPending=0;    //by memset below.
    //pgd->dwMessagesPending=0; //by memset below.
    // Initialize the pool for send headers and overlapped stucts
    pgd->pSendInfoPool=FPM_Init(sizeof(SENDINFO)+sizeof(MESSAGEHEADER),NULL,NULL,NULL);
    
    if(!pgd->pSendInfoPool){
        goto ERROR_EXIT;
    }
    
    InitializeCriticalSection(&pgd->csSendEx);

    return DP_OK;
    
ERROR_EXIT:
    return DPERR_NOMEMORY;
}
#endif

void KillTCPEnumAsyncThread(LPGLOBALDATA pgd)
{
    HANDLE hTCPEnumAsyncThread;
    DWORD SleepCount=0;

    ENTER_DPSP();

    if(pgd->hTCPEnumAsyncThread){
    
        DPF(9,"Killing Running Async TCP enum thread\n");
        //hTCPEnumAsyncThread is 0, thread knows we are 
        //waiting for thread to finish, so we own closing 
        // the handle.
        hTCPEnumAsyncThread=pgd->hTCPEnumAsyncThread;
        pgd->hTCPEnumAsyncThread=0;

        // We need to close the socket out from under the
        // TCPEnum thread in order to have it continue and
        // exit.  So make sure the socket has been allocated
        // first, but don't wait if the thread has exited 
        // already (which is why we check lpEnumMessage.)
        while(pgd->sEnum==INVALID_SOCKET && pgd->lpEnumMessage){
            LEAVE_DPSP();
            Sleep(500);    
            ENTER_DPSP();
            if(SleepCount++ > 10 )break; // don't wait more than 5 seconds.
        }

        if(pgd->sEnum!=INVALID_SOCKET){
            if(pgd->bOutBoundOnly){
                RemoveSocketFromReceiveList(pgd,pgd->sEnum);
            } else {
                closesocket(pgd->sEnum);
            }
        }    
        LEAVE_DPSP();
        
        WaitForSingleObject(hTCPEnumAsyncThread,150*1000);
        CloseHandle(hTCPEnumAsyncThread);
        
        DPF(9,"Async enum thread is dead.\n");
    } else {
        LEAVE_DPSP();
    }    
}        

void InitGlobals(LPGLOBALDATA pgd)
{
    if(pgd->hTCPEnumAsyncThread){
        KillTCPEnumAsyncThread(pgd);
    }

    ENTER_DPSP();

    if (pgd->BagOSockets)    
    {
        MemFree(pgd->BagOSockets);
    }
    
    if (pgd->ReceiveList.pConnection)
    {
         MemFree(pgd->ReceiveList.pConnection);
    }

    if (pgd->readfds.pfdbigset)
    {
         MemFree(pgd->readfds.pfdbigset);
    }
    
#ifdef SENDEX    
    if(pgd->bSendThreadRunning){
        pgd->bStopSendThread=TRUE;
        SetEvent(pgd->hSendWait);
    }
    while(pgd->bSendThreadRunning){
        Sleep(0);
    }
    if(pgd->hSendWait){
        CloseHandle(pgd->hSendWait);
        pgd->hSendWait=NULL;
    }
    if(pgd->pSendInfoPool){
        pgd->pSendInfoPool->Fini(pgd->pSendInfoPool,0);
        DeleteCriticalSection(&pgd->csSendEx);
        //pgd->pSendInfoPool=NULL; //by memset below.
    }
#endif
    // set global data to 0    
    memset(pgd,0,sizeof(GLOBALDATA));

    // uses INVALID_SOCKET, not 0, to indicate bogus socket
    pgd->sSystemDGramSocket= INVALID_SOCKET;
    pgd->sSystemStreamSocket= INVALID_SOCKET;
    pgd->sUnreliableSocket = INVALID_SOCKET;
#ifdef BIGMESSAGEDEFENSE
    pgd->dwMaxMessageSize = SPMAXMESSAGELEN;
#endif
    ZeroMemory(&pgd->saddrEnumAddress, sizeof(pgd->saddrEnumAddress));

    LEAVE_DPSP();

} // InitGlobals

HRESULT WaitForThread(HANDLE hThread)
{
    DWORD dwRet;
    
    if (!hThread) return DP_OK;
    
    // we assume the thread has been told to go away
    // we wait for it to do so
    dwRet = WaitForSingleObject(hThread,INFINITE);
    if (WAIT_OBJECT_0 != dwRet)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
    
    CloseHandle(hThread);
    
    return DP_OK;
} // WaitForThread

HRESULT WINAPI SP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
    UINT err;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    HRESULT hr;
    DPSP_CLOSEDATA cd;
    BOOL bFree;
    
    DPF(2," dpwsock - got shutdown!!\n");

    // get the global data
    hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }
    
    // call close
    cd.lpISP = psd->lpISP;
    hr = SP_Close(&cd);
    if (FAILED(hr))
    {
        DPF(0," shutdown - could not close SP hr = 0x%08lx\n",hr);
        ASSERT(FALSE);
        // rut roh!  - keep trying
    }

#ifdef DPLAY_VOICE_SUPPORT
    // turn off voice, if it exists...
    if (gbVoiceInit) 
    {
        ASSERT(!gbVoiceOpen); // dplay should have shut it down!
        FiniVoice();
        gbVoiceInit = FALSE;
    }
#endif // DPLAY_VOICE_SUPPORT
    
    DPF(2,"shutdown, calling WSACleanup");
    // it's ok to call this for each idirectplaysp that goes away, since
    // we called WSAStartup once for each one at SPInit
    if ( SOCKET_ERROR == WSACleanup()) 
    {
        err = WSAGetLastError();
        DPF(0,"could not stop winsock err = %d\n",err);
        // keep trying...
    }

    // if we have a winsock2, free it 
    if (hWS2)
    {
        bFree = FreeLibrary(hWS2);
        if (!bFree)
        {
            DWORD dwError = GetLastError();
            DPF(0,"SP_Shutdown - could not free ws2 library - error = %d\n",dwError);
            // keep trying
        }
        hWS2 = NULL;
    }
    if (hWSHIP6)
    {
        bFree = FreeLibrary(hWSHIP6);
        if (!bFree)
        {
            DWORD dwError = GetLastError();
            DPF(0,"SP_Shutdown - could not free wship6 library - error = %d\n",dwError);
            // keep trying
        }
        hWSHIP6 = NULL;
    }
    
    // reset everything...
    InitGlobals(pgd);

    gdwDPlaySPRefCount--;

    DPF(2,"shutdown leaving");
    return DP_OK;
    
} //Shutdown

// sp only sets fields it cares about
HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    HRESULT hr;

    // get the global data
    hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    {
        // AF_INET6 optimizes guaranteed
        pcd->lpCaps->dwFlags |= DPCAPS_GUARANTEEDOPTIMIZED;
        
        if (pcd->dwFlags & DPGETCAPS_GUARANTEED)
        {
            // TCP
            pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
            pcd->lpCaps->dwMaxBufferSize = SPMAXMESSAGELEN -sizeof(MESSAGEHEADER);
            pcd->lpCaps->dwMaxPlayers = pgd->nSocketsInBag;
        }
        else 
        {
            // UDP
            pcd->lpCaps->dwHeaderLength = sizeof(MESSAGEHEADER);
            pcd->lpCaps->dwMaxBufferSize = pgd->iMaxUdpDg-sizeof(MESSAGEHEADER);
        }
    }

    // set async caps flags
    if(pgd->bSendThreadRunning){
        // we are supporting async.
        pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);
    }
    
    // set the timeout
    pcd->lpCaps->dwLatency = pgd->dwLatency;
    pcd->lpCaps->dwTimeout = SPTIMEOUT(pcd->lpCaps->dwLatency);

#ifdef DPLAY_VOICE_SUPPORT
    // check the voice
    if (gbVoiceInit || CheckVoice()) pcd->lpCaps->dwFlags |= DPCAPS_VOICE;
#endif // DPLAY_VOICE_SUPPORT

    return DP_OK;

} // SP_GetCaps

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
    LPMESSAGEHEADER phead;
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    HRESULT hr;
    
    DPF(5,"SP_Open");

#ifdef DPLAY_VOICE_SUPPORT
    if (pod->dwOpenFlags & DPOPEN_VOICE)    
    {
        if (gbVoiceOpen)
        {
            DPF_ERR("voice channel already open - only one per process");
            return DPERR_ALREADYINITIALIZED;
        }
        if (!gbVoiceInit)
        {
            DPF(0,"DPWSOCK - listen up!!! - init'ing voice!");
            hr = InitVoice();
            if (FAILED(hr))
            {
                DPF(0,"init voice failed hr = 0x%08lx\n");
                return hr;
            }
            gbVoiceInit = TRUE;
        }
    }
#endif // DPLAY_VOICE_SUPPORT
    
    // get the global data
    hr =pod->lpISP->lpVtbl->GetSPData(pod->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }

    // do we have a TCP connection?
    {
        SOCKET_ADDRESS_LIST *pList = GetHostAddr();
        if (!pList)
        {
            DPF(0, "No Dial-up network or netcard present");
            return DPERR_NOCONNECTION;    // no local IP address = no network
        }
        FreeHostAddr(pList);
    }

    // remember session information so we know if we need to turn off nagling
    pgd->dwSessionFlags = pod->dwSessionFlags;

    if (pod->dwOpenFlags & DPOPEN_CREATE)
    {
        // host should never go into this mode
        pgd->dwFlags &= ~(DPSP_OUTBOUNDONLY);
    }
    
    if (pod->bCreate) 
        return DP_OK; // all done

    phead =  (LPMESSAGEHEADER)pod->lpSPMessageHeader;
    // get name server address out of phead, stores it in pgd->saddrNS
    pgd->saddrNS = phead->sockaddr;

    // make sure we have a thread running to get the nametable
    hr = StartupEnumThread(pod->lpISP,pgd);
    if (FAILED(hr))
    {
        DPF(0," could not start open threads - hr = 0x%08lx\n",hr);
        return hr;
    }
    
    return DP_OK;

} // SP_Open


#ifdef DEBUG
// make sure there are no connected sockets left in the bug
void VerifySocketBagIsEmpty(LPGLOBALDATA pgd)
{
    UINT i=0;

    while (i < pgd->nSocketsInBag)
    {
        if (INVALID_SOCKET != pgd->BagOSockets[i].sSocket) 
        {
            DPF_ERR("socket bag not empty at close!");
            ASSERT(FALSE);
        }
        i++;
    }

} // VerifySocketBagIsEmpty
#endif // DEBUG

HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd)
{
    DWORD dwDataSize = sizeof(GLOBALDATA);
    LPGLOBALDATA pgd;
    HRESULT hr;
    DWORD sleepcount=0;
    
    DPF(2," dpwsock - got close");
    
    // get the global data
    hr =pcd->lpISP->lpVtbl->GetSPData(pcd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
    if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
    {
        DPF_ERR("couldn't get SP data from DirectPlay - failing");
        return E_FAIL;
    }


    // Stop asynchronous TCP enumeration thread if it's running
    KillTCPEnumAsyncThread(pgd);


    // give the reply list 5 seconds to clear out
    while(pgd->pReplyList){
        Sleep(100);
        if(sleepcount++ == 50){
            break;
        }
    }


    // reset the nameserver address
    memset(&(pgd->saddrNS),0,sizeof(SOCKADDR));

    pgd->bShutdown = TRUE;
    
    DPF(2,"close, datagram sockets");
    
    KillSocket(pgd->sSystemDGramSocket,FALSE,TRUE);
    pgd->sSystemDGramSocket = INVALID_SOCKET;

    DPF(2,"Waiting for stream receive thread");

    WaitForThread(pgd->hStreamReceiveThread);
    pgd->hStreamReceiveThread = NULL;

    DPF(2,"close stream socket");
    
    closesocket(pgd->sSystemStreamSocket);
    pgd->sSystemStreamSocket = INVALID_SOCKET;    

    DPF(2,"close unreliable socket");
    
    KillSocket(pgd->sUnreliableSocket,FALSE,TRUE);
    pgd->sUnreliableSocket = INVALID_SOCKET;    
    
    DPF(2,"close, waiting on threads");

    // signal the reply thread
    if (pgd->hReplyEvent)
    {
        SetEvent(pgd->hReplyEvent);
    }

    WaitForThread(pgd->hDGramReceiveThread);
    pgd->hDGramReceiveThread = NULL;
    
    WaitForThread(pgd->hReplyThread);
    pgd->hReplyThread = NULL;

    pgd->bShutdown = FALSE;
    
#ifdef DEBUG    
    // verify that the bag o' sockets is really empty
    VerifySocketBagIsEmpty(pgd);
#endif 

    while(pgd->dwMessagesPending){
        DPF(0,"Waiting for pending messages to complete\n");
        Sleep(55);
    }
    
    return DP_OK;

} // SP_Close

#ifdef FIND_IP
//
// we get the ip addr of our host.  this is for debug purposes only.
// we never use the ip addr of our host, since it may be multihomed.
// the receiving system assigns our players their ip addresses
HRESULT DebugFindIPAddresses(void)
{
    SOCKET_ADDRESS_LIST *pList;
    int i;

    pList = GetHostAddr();
    if (NULL == pList) 
    {
        return E_FAIL;
    }

    for (i=0; i<pList->iAddressCount; i++)
    {
        DEBUGPRINTADDR(0,"sp - found host addr = %s \n",pList->Address[i].lpSockaddr);
    }

    FreeHostAddr(pList);
    return DP_OK;

} // DebugFindIPAddresses

#endif  // FIND_IP


/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

BOOL FAR PASCAL EnumConnectionData(REFGUID lpguidDataType, DWORD dwDataSize,
                            LPCVOID lpData, LPVOID lpContext)
{
    LPGLOBALDATA pgd = (LPGLOBALDATA) lpContext;
    
    // this is an ANSI internet address
    if (IsEqualGUID(lpguidDataType, &DPAID_INet))
    {
        // make sure there is room (for terminating null too)
        if (dwDataSize > ADDR_BUFFER_SIZE)
            dwDataSize = (ADDR_BUFFER_SIZE - 1);

        // copy string for use later
        memcpy(pgd->szServerAddress, lpData, dwDataSize);

        pgd->bHaveServerAddress = TRUE;        // we have a server address
    }
    // this is a UNICODE internet address
    else if (IsEqualGUID(lpguidDataType, &DPAID_INetW))
    {
        if (WideToAnsi(pgd->szServerAddress, (LPWSTR) lpData, ADDR_BUFFER_SIZE))
            pgd->bHaveServerAddress = TRUE;    // we have a server address
    }
    else if (IsEqualGUID(lpguidDataType, &DPAID_INetPort))
    {
        pgd->wApplicationPort = *(LPWORD)lpData;
        DPF(5, "Application port specified in dp address: %d",pgd->wApplicationPort);
    }
    
#ifdef BIGMESSAGEDEFENSE
    else if (IsEqualGUID(lpguidDataType, &DPAID_MaxMessageSize))
    {
        pgd->dwMaxMessageSize = *(LPDWORD)lpData;
        ASSERT(pgd->dwMaxMessageSize > 11);    // set an arbitrary minimum
        if (pgd->dwMaxMessageSize < 12)
            pgd->dwMaxMessageSize = 12;
        DPF(5, "Max message size specified in dp address: %d",pgd->dwMaxMessageSize);
        pgd->dwMaxMessageSize += sizeof(MESSAGEHEADER);    // add a little extra for the shop
    }
#endif

    return TRUE;

} // EnumConnectionData

// nSockets was passed into spinit as dwReserved2
HRESULT InitBagOSockets(LPGLOBALDATA pgd,DWORD nSockets)
{
    UINT i;

    ENTER_DPSP();
        
    if (0 == nSockets)
    {
        pgd->nSocketsInBag = MAX_CONNECTED_SOCKETS;
    }
    else 
    {
        pgd->nSocketsInBag = nSockets;
    }
    
    pgd->BagOSockets = MemAlloc(pgd->nSocketsInBag * sizeof(PLAYERSOCK));
    
    LEAVE_DPSP();
    
    if (!pgd->BagOSockets)
    {
        pgd->nSocketsInBag = 0;
        DPF_ERR("could not alloc space for socket cache - out of memory");
        return E_OUTOFMEMORY; 
    }
    
    for (i=0;i<pgd->nSocketsInBag;i++ )
    {
        pgd->BagOSockets[i].sSocket = INVALID_SOCKET;
    }
    
    return DP_OK ;
} // InitBagOSockets

extern void InitIPv6Library();

// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI SPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
    UINT err;
    GLOBALDATA gd,*pgd;
    UINT dwSize;
    SOCKET sVerifySocket; // used to verify support for the requested address family
                          // so, if they ask for ipx, and it's not installed, we fail here 
    WORD wVersion;
    OSVERSIONINFO osInfo;
    HANDLE hAlertThread;

    // initialize global data
    memset(&gd,0,sizeof(gd));
    InitGlobals(&gd);

    ASSERT(pSD->lpGuid);
    if (IsEqualIID(pSD->lpGuid,&GUID_LOCAL_IPV6))
    {
        ZeroMemory(&gd.saddrEnumAddress, sizeof(gd.saddrEnumAddress));
        gd.saddrEnumAddress.sin6_family = AF_INET6;
        gd.saddrEnumAddress.sin6_addr = in6addr_multicast;
        DPF(0," ** DPWSOCK -- RUNNING LOCAL TCP / IP ** ");            
    }
    else 
    {
        DPF(0," ** DPWSOCK -- RUNNING INTERNET TCP / IP ** ");
    }

    gd.AddressFamily = AF_INET6;            
    
    // find out what os we are running on
    memset(&osInfo,0,sizeof(osInfo));
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);
    if (!GetVersionEx(&osInfo)) 
    {
        err = GetLastError();
        DPF(0,"Failed to get OS information - err = %d\n", err);
        return DPERR_GENERIC;
    }    

    // start up sockets
    if (gwsaData.wVersion)
    {
        // note - there is a bug in winsock 1.1.  if you've called WSAStartup 1x in a process,
        // then if any subsequent call asks for a version # > then that returned to the first
        // call, we get WSAEVERNOTSUPPORTED.  So, if we've already got a version in the wsadata,
        // we make sure to use that
        wVersion = gwsaData.wVersion;
        
    }
    // otherwise, ask for winsock 2.0
    else 
    {
        // if we are trying to initialize IPX on a non-NT platform, don't look for Winsock 2.0
        // Only look for Winsock 1.1 as Winsock 2.0 functionality is not supported for IPX on
        // Memphis and Win'95.
        wVersion = MAKEWORD(2,0);
    }
    
    err = WSAStartup(wVersion, &gwsaData);
    if (WSAVERNOTSUPPORTED == err)
    {
        // they (the app) must have already called WSAStartup.  see note above 
        // about winsock 1.1 bug.
        wVersion = MAKEWORD(1,1);
        err = WSAStartup(wVersion, &gwsaData);
    }
    if (err) 
    {
        DPF(0,"could not start winsock err = %d\n",err);
        return E_FAIL;
    }

    DPF(1,"spinit - name = %ls,dwReserved1 = %d,dwReserved2 = %d\n",pSD->lpszName,
        pSD->dwReserved1,pSD->dwReserved2);        

    gd.iMaxUdpDg = gwsaData.iMaxUdpDg;

    DPF(0,"detected winsock version %d.%d\n",LOBYTE(gwsaData.wVersion),HIBYTE(gwsaData.wVersion));    
    if (LOBYTE(gwsaData.wVersion) >= 2)
    {
        hr = InitWinsock2();
        if (FAILED(hr))
        {
            DPF_ERR("detected winsock 2, but could not init it! yikes!");
            ASSERT(FALSE);
        }
    }

    DPF(1,"\nspinit - setting latency to %d\n\n", pSD->dwReserved1);
    gd.dwLatency = pSD->dwReserved1;
    
    hr = InitBagOSockets(&gd,pSD->dwReserved2);    
    if (FAILED(hr))
    {
        DPF_ERR("could not init socket cache. bailing");
        goto ERROR_EXIT;
    }
                
    // make sure support exists for address family
    hr = CreateSocket(&gd,&sVerifySocket,SOCK_DGRAM,0,&sockaddr_any,&err,FALSE);
    if (FAILED(hr)) 
    {
        DPF(0,"    COULD NOT CREATE SOCKET IN REQUESTED ADDRESS FAMILY af = %d, err = %d\n",gd.AddressFamily,err);
        DPF(0," SERVICE PROVIDER INITIALIZATION FAILED");
        // return the same error as the modem service provider
        hr = DPERR_UNAVAILABLE;
        goto ERROR_EXIT;
    }

    if (LOBYTE(gwsaData.wVersion) >= 2)
    {
        // get max udp buffer size through getsockopt because
        // WSAStartup doesn't return this info from winsock 2.0 onwards.
        hr = GetMaxUdpBufferSize(sVerifySocket, &gd.iMaxUdpDg);
        if (FAILED(hr))
        {
            DPF(0,"Failed to get max udp buffer size");
            // since memphis still returns this value in WSAStartup
            // use it. This is just a workaround for memphis bug #43655
            if (gwsaData.iMaxUdpDg)
            {
                DPF(0, "Using iMaxUdpDg value from WSAStartup: %d", gwsaData.iMaxUdpDg);
                gd.iMaxUdpDg = gwsaData.iMaxUdpDg;
            }
            else
            {
                DPF_ERR("No max UDP buffer size could be found!");

                // all done w/ verify socket
                KillSocket(sVerifySocket,FALSE,TRUE);
                goto ERROR_EXIT;
            }
        }
    }

    // all done w/ verify socket
    KillSocket(sVerifySocket,FALSE,TRUE);

    InitIPv6Library();

#ifdef FIND_IP
    // print out the ip address(es) of this host
    DebugFindIPAddresses();
#endif 

    // set up callbacks
    pSD->lpCB->CreatePlayer = SP_CreatePlayer;
    pSD->lpCB->DeletePlayer = SP_DeletePlayer;
    pSD->lpCB->Send = SP_Send;
    pSD->lpCB->EnumSessions = SP_EnumSessions;
    pSD->lpCB->Reply = SP_Reply;
    pSD->lpCB->ShutdownEx = SP_Shutdown;
    pSD->lpCB->GetCaps = SP_GetCaps;
    pSD->lpCB->Open = SP_Open;
    pSD->lpCB->CloseEx = SP_Close;
    pSD->lpCB->GetAddress = SP_GetAddress;
#ifdef DPLAY_VOICE_SUPPORT
    pSD->lpCB->OpenVoice = SP_OpenVoice;
    pSD->lpCB->CloseVoice = SP_CloseVoice;
#endif // DPLAY_VOICE_SUPPORT

#ifdef SENDEX
    if(LOBYTE(gwsaData.wVersion) >= 2)
    {
        DPF(1,"SENDEX being provided by SP\n");
        // Only do new functions when Winsock 2 functions avail.
        // NOTE: not supported on IPX with win9x at present, but reports 1.1 in this case.
        
        //pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
        //pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
        pSD->lpCB->SendEx           = SP_SendEx;                    // required for async
        pSD->lpCB->GetMessageQueue = SP_GetMessageQueue;    
    } else {
        DPF(1,"SENDEX not being provided by SP on winsock ver < 2\n");
    }
#endif

    // we put (at most) 1 sockaddr and one dword (size) in each message
    pSD->dwSPHeaderSize = sizeof(MESSAGEHEADER);

    // return version number so DirectPlay will treat us with respect
    pSD->dwSPVersion = VERSIONNUMBER;

    // look at connnection data
    if (pSD->dwAddressSize)
    {
        // ask dplay to enum the chunks for us. if one of them is
        // af_inet, we'll use it as our name servers address
        pSD->lpISP->lpVtbl->EnumAddress(pSD->lpISP, EnumConnectionData, 
                                 pSD->lpAddress, pSD->dwAddressSize,
                                 &gd);
    }

#ifdef FULLDUPLEX_SUPPORT
    // get the flags from registry
    hr = GetFlagsFromRegistry(pSD->lpGuid, &gd.dwFlags);
    if (FAILED(hr))
    {
        DPF(2, "Failed to get sp flags from the registry");        
    }
#endif // FULLDUPLEX_SUPPORT

    // store the globaldata
    hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto ERROR_EXIT;
    }
    
    hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto ERROR_EXIT;
    }
#ifdef SENDEX    
    if(LOBYTE(gwsaData.wVersion) >= 2) {
        // some globals are self referential, can't set until here.
        hr=InitGlobalsInPlace(pgd);
        if(FAILED(hr))
        {
            ASSERT(FALSE);
            goto ERROR_EXIT;
        }

        // added alertable thread.
        pgd->hSendWait=CreateEvent(NULL, FALSE, FALSE, NULL); // autoreset.
        if(!pgd->hSendWait){
            ASSERT(FALSE);
            goto ERROR_EXIT;
        }
        pgd->bSendThreadRunning=TRUE;
        hAlertThread=CreateThread(NULL, 4000, SPSendThread, pgd, 0, (ULONG *)&hAlertThread);
        if(!hAlertThread){
            pgd->bSendThreadRunning=FALSE;
            ASSERT(FALSE);
            goto ERROR_EXIT;
        } else {
            SetThreadPriority(hAlertThread, THREAD_PRIORITY_ABOVE_NORMAL);
        }
        CloseHandle(hAlertThread);// don't need a handle.
    }
    
#endif    
    
    gdwDPlaySPRefCount++;

    
    // success!
    return DP_OK;    

ERROR_EXIT:

    DPF_ERR("SPInit - abnormal exit");

    // call this again to clean up anything we alloc'ed
    InitGlobals(&gd);
    
    DPF(2,"SPInit - calling WSACleanup");
    if ( SOCKET_ERROR == WSACleanup()) 
    {
        err = WSAGetLastError();
        DPF(0,"could not stop winsock err = %d\n",err);
    }

    return hr;

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dpsp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:    DirectPlay data structures
 *  History:
 *   Date               By      Reason
 *   ====               ==      ======
 *      1/96            andyco  created it
 *  1/26/96             andyco  list data structures
 *      4/10/96         andyco  removed dpmess.h
 *      4/23/96         andyco  added ipx support
 *      4/25/96         andyco  messages now have blobs (sockaddr's) instead of dwReserveds  
 *      8/10/96         kipo    update max message size to be (2^20) - 1
 *      8/15/96         andyco  added local data
 *      8/30/96         andyco  clean it up b4 you shut it down! added globaldata.
 *      9/3/96          andyco  bagosockets
 *      12/18/96        andyco  de-threading - use a fixed # of prealloced threads.
 *                                              cruised the enum socket / thread - use the system
 *                                              socket / thread instead. updated global struct.
 *      2/7/97          andyco  moved all per IDirectPlay globals into globaldata
 *      3/17/97         kipo    GetServerAddress() now returns an error so that we can
 *                                              return DPERR_USERCANCEL from the EnumSessions dialog
 *      3/25/97         andyco  dec debug lock counter b4 dropping lock! 
 *      4/11/97         andyco  added saddrControlSocket
 *      5/12/97         kipo    added ADDR_BUFFER_SIZE constant and removed unused variables
 *      5/15/97         andyco  added ipx spare thread to global data - used when nameserver 
 *                                              migrates to this host to make sure that old system receive 
 *                                              thread shuts down 
 *      6/22/97         kipo    include wsnwlink.h
 *      7/11/97         andyco  added support for ws2 + async reply thread
 *      8/25/97         sohailm added DEFAULT_RECEIVE_BUFFERSIZE
 *      12/5/97         andyco  voice support
 *      01/5/97         sohailm added fd big set related definitions and macros (#15244).
 *      1/20/98         myronth #ifdef'd out voice support
 *      1/27/98         sohailm added firewall support
 *  2/13/98     aarono  added async support
 *      2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  12/15/98    aarono  make async enum run async
 **************************************************************************/

#ifndef __DPSP_INCLUDED__
#define __DPSP_INCLUDED__
#include "windows.h"
#include "windowsx.h"
#include "wsipx.h"
#include "wsnwlink.h"
#include "dplaysp.h"
#include "bilink.h"
#include "fpm.h"

#ifdef DPLAY_VOICE_SUPPORT
#include "nmvoice.h"
#endif // DPLAY_VOICE_SUPPORT

#include "dpf.h"
#include "dputils.h"
#include "memalloc.h"
#include "resource.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ntddip6.h>

// to turn off SendEx support, comment this flag out.
#define SENDEX 1

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT

typedef WORD PORT;
typedef UINT SOCKERR;

// server ports
// Oops! We forgot to convert these constants to net byte order in the code so we
// are really using port 47624 (0xBA08) instead of 2234 (0x08BA)
// We are living with the mistake.
#define SERVER_STREAM_PORT 2234
#define SERVER_DGRAM_PORT 2234

// range of ports used by sp (these are properly converted in the code)
#define DPSP_MIN_PORT   2300
#define DPSP_MAX_PORT   2400
#define DPSP_NUM_PORTS   ((DPSP_MAX_PORT - DPSP_MIN_PORT)+1)

#define SPMESSAGEHEADERLEN (sizeof(DWORD))
#define DEFAULT_RECEIVE_BUFFERSIZE      (4*1024)        // default receive buffer size per connection

// token means this message was received from a remote
// dplay.  
#define TOKEN 0xFAB00000

// helper_token means this message was forwarded by our server helper (host)
#define HELPER_TOKEN 0xCAB00000

// server_token means this message is exchanged with dplaysvr (needed to distinguish 
// messages from a remote dpwsockx)
#define SERVER_TOKEN 0xBAB00000

// tells receiver to reuse the connection for replies (needed to support fullduplex
// connections)
#define REUSE_TOKEN 0xAAB00000


// masks
#define TOKEN_MASK 0xFFF00000
#define SIZE_MASK (~TOKEN_MASK)

// maxmessagelen = 2^20 (need 12 bits for token)
#define SPMAXMESSAGELEN ( 1048576 - 1)
#define VALID_SP_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == TOKEN ? TRUE : FALSE)
#define VALID_HELPER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == HELPER_TOKEN ? TRUE : FALSE)
#define VALID_REUSE_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == REUSE_TOKEN ? TRUE : FALSE)
#define VALID_SERVER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == SERVER_TOKEN ? TRUE : FALSE)
#define SP_MESSAGE_SIZE(pMsg) ( (*((DWORD *)pMsg) & SIZE_MASK))
#define SP_MESSAGE_TOKEN(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK))

#define VALID_DPWS_MESSAGE(pMsg) (  VALID_SP_MESSAGE(pMsg) || VALID_HELPER_MESSAGE(pMsg) || \
                                                                        VALID_SERVER_MESSAGE(pMsg) || VALID_REUSE_MESSAGE(pMsg) )
#define VALID_DPLAYSVR_MESSAGE(pMsg) (  VALID_SP_MESSAGE(pMsg) || VALID_SERVER_MESSAGE(pMsg) || \
                                                                                VALID_REUSE_MESSAGE(pMsg) )

// relation of timeout to latency
#define TIMEOUT_SCALE 10
#define SPTIMEOUT(latency) (TIMEOUT_SCALE * latency)

// the default size of the socket cache (gBagOSockets)
#define MAX_CONNECTED_SOCKETS 64

// the initial size of the receive list
#define INITIAL_RECEIVELIST_SIZE 16

// version number for service provider
#define SPMINORVERSION      0x0000                              // service provider-specific version number
#define VERSIONNUMBER           (DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

// biggest user enterable addess
#define ADDR_BUFFER_SIZE 128
                                                                 
// macro picks the service socket depending on ipx vs. tcp
// ipx uses dgram, tcp uses stream
#define SERVICE_SOCKET(pgd) ( pgd->sSystemStreamSocket)

//
// In order to listen to any number of sockets we need our own version
// of fd_set and FD_SET().  We call them fd_big_set and FD_BIG_SET().
//
typedef struct fd_big_set {
    u_int   fd_count;           // how many are SET?   
    SOCKET  fd_array[0];        // an array of SOCKETs 
} fd_big_set;

// stolen from winsock2.h

#ifndef _WINSOCK2API_

typedef HANDLE WSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD        Internal;
    DWORD        InternalHigh;
    DWORD        Offset;
    DWORD        OffsetHigh;
    WSAEVENT     hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;
 
#endif // _WINSOCK2API_

#define MAX_SG 9
typedef WSABUF SENDARRAY[MAX_SG];
typedef SENDARRAY *PSENDARRAY;

#define SI_RELIABLE 0x0000001
#define SI_DATAGRAM 0x0000000

typedef struct _SENDINFO {
        WSAOVERLAPPED wsao;
        SENDARRAY     SendArray;        // Array of buffers
        DWORD         dwFlags;
        DWORD         dwSendFlags;  // DPLAY Send Flags.
        UINT          iFirstBuf;        // First buffer in array to use
        UINT          cBuffers;         // number of buffers to send (starting at iFirstBuf)
        BILINK        PendingSendQ; // when we're pending
        BILINK        ReadyToSendQ; // still waiting to send on this queue.
        DPID          idTo;
        DPID          idFrom;
        SOCKET        sSocket;          // reliable sends
        SOCKADDR_IN6  sockaddr;         // datagram sends
        DWORD_PTR     dwUserContext;
        DWORD         dwMessageSize;
        DWORD         RefCount;
        LONG          Status;
        struct _GLOBALDATA *pgd;
        IDirectPlaySP * lpISP;                  //  indication interface
        #ifdef DEBUG
        DWORD         wserr;                    // winsock extended error on wsasend call
        #endif
} SENDINFO, FAR *LPSENDINFO;

//
// This code is stolen from winsock.h.  It does the same thing as FD_SET()
// except that it assumes the fd_array is large enough.  AddSocketToReceiveList()
// grows the buffer as needed, so this better always be true.
//

#define FD_BIG_SET(fd, address) do { \
    ASSERT((address)->dwArraySize > (address)->pfdbigset->fd_count); \
    (address)->pfdbigset->fd_array[(address)->pfdbigset->fd_count++]=(fd);\
} while(0)

typedef struct fds {
        DWORD           dwArraySize;    // # of sockets that can be stored in pfdbigset->fd_array buffer
        fd_big_set      *pfdbigset;             
} FDS;

typedef struct _CONNECTION
{
        SOCKET  socket;                         // socket we can receive off of
        DWORD   dwCurMessageSize;       // current message size
        DWORD   dwTotalMessageSize;     // total message size
        SOCKADDR_IN6 sockAddr;  // addresses connected to
        LPBYTE  pBuffer;                        // points to either default or temporary receive buffer
        LPBYTE  pDefaultBuffer;         // default receive buffer (pBuffer points to this by default)
        // added in DX6
        DWORD   dwFlags;                        // connection attributes e.g. SP_CONNECION_FULLDUPLEX
} CONNECTION, *LPCONNECTION;

typedef struct _RECEIVELIST
{
        UINT nConnections;                      // how many peers are we connected to
        LPCONNECTION pConnection;// list of connections
} RECEIVELIST;

typedef struct _REPLYLIST * LPREPLYLIST;
typedef struct _REPLYLIST
{
        LPREPLYLIST pNextReply; // next reply in list
        LPVOID  lpMessage; // bufffer to send
        SOCKADDR_IN6 sockaddr;  // addr to send to
        DWORD dwMessageSize;
        SOCKET sSocket; // socket to send on
        LPBYTE pbSend; // index into message pointing to next byte to send
        DWORD  dwBytesLeft; // how many bytes are left to send
        DWORD  dwPlayerTo; // dpid of to player, 0=>not in use.
} REPLYLIST;

// w store one of these w/ each sys player
typedef struct _SPPLAYERDATA 
{
        SOCKADDR_IN6 saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

        
// the message header
typedef struct _MESSAGEHEADER
{
        DWORD dwMessageSize; // size of message
        SOCKADDR_IN6 sockaddr;
} MESSAGEHEADER,*LPMESSAGEHEADER;


// this is one element in our bagosockets
typedef struct _PLAYERSOCK
{
        SOCKET sSocket;
        DPID dwPlayerID;
        // added in DX6
        SOCKADDR_IN6 sockaddr;
        DWORD dwFlags;                  // SP_CONNECTION_FULLDUPLEX, etc.
} PLAYERSOCK,*LPPLAYERSOCK;

// flags that describe a socket
#define SP_CONNECTION_FULLDUPLEX        0x00000001
// stream accept socket in the socket list.
#define SP_STREAM_ACCEPT            0x00000002  

#ifdef SENDEX
typedef struct FPOOL *LPFPOOL;
#endif

typedef struct _GLOBALDATA
{
        SOCKET sSystemDGramSocket;
        SOCKET sSystemStreamSocket;
        HANDLE hStreamReceiveThread;    // does receive and accept.
        HANDLE hDGramReceiveThread;
        HANDLE hReplyThread;
        RECEIVELIST ReceiveList;  // the list of sockets that StreamReceiveThread is listening on
        SOCKET sUnreliableSocket; // cached for unreliable send
        // reply thread 
        LPREPLYLIST pReplyList; // list of replies for reply thread to send
        HANDLE hReplyEvent; // signal the replythread that something is up
        // bago sockets stuff
        LPPLAYERSOCK BagOSockets; // socket cache
        UINT nSocketsInBag; // how many sockets in our bag
        SOCKADDR_IN6 saddrEnumAddress; // address entered by user for game server
        ULONG AddressFamily;
        SOCKADDR_IN6 saddrNS; // address for name server
        DWORD dwLatency; // from dwreserved1 in registry
        BOOL bShutdown;
        SOCKADDR_IN6 saddrControlSocket;
        BOOL bHaveServerAddress;
    CHAR szServerAddress[ADDR_BUFFER_SIZE];
        UINT iMaxUdpDg;                 // maximum udp datagram size
        // added in DX6
        FDS     readfds;                        // dynamic read fdset
        DWORD dwFlags;                  // DPSP_OUTBOUNDONLY, etc.
        DWORD dwSessionFlags;   // session flags passed by app
        WORD wApplicationPort;  // port used for creating system player sockets
#ifdef BIGMESSAGEDEFENSE
        DWORD   dwMaxMessageSize;       // the max message size we should receive
#endif

        HANDLE  hTCPEnumAsyncThread; // fix async enum.
        LPVOID  lpEnumMessage;
        DWORD   dwEnumMessageSize;
        SOCKADDR_IN6 saEnum;
        DWORD    dwEnumAddrSize;
        SOCKET   sEnum;
        BOOL     bOutBoundOnly;

#ifdef SENDEX
        CRITICAL_SECTION csSendEx;  // locks sendex data.
        LPFPOOL pSendInfoPool;     // pool for allocating SENDINFO+SPHeaders for scatter gather sends
        DWORD   dwBytesPending;         // count of total bytes in pending messages.
        DWORD   dwMessagesPending;  // count of total bytes pending.
        BILINK  PendingSendQ;
        BILINK  ReadyToSendQ;
        HANDLE  hSendWait;         // alert thread wait here.
        HANDLE  BogusHandle;       // don't be fooled by waitfor multiple probs in Win9x, put -1 here.
        BOOL    bSendThreadRunning;
        BOOL    bStopSendThread;
#endif

} GLOBALDATA,*LPGLOBALDATA;

/*
 * SP Flags (from registry)
 */
#define DPSP_OUTBOUNDONLY       0x00000001

/*
 * DPLAYSVR - DPWSOCKX communication related information
 */

// MSG_HDR indicates a dpwsock system message
#define MSG_HDR 0x736F636B

#define SP_MSG_VERSION  1       // DX6

#define IS_VALID_DPWS_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define COMMAND_MASK 0X0000FFFF

#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)

#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )
#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
        | (SP_MSG_VERSION<<16)) )

typedef struct {
        DWORD dwHeader;
    DWORD dwCmdToken;   
} MSG_GENERIC, *LPMSG_GENERIC;


// DPLAYSVR


// macros for manipulating the sockaddr in the player data
#ifdef DEBUG
extern int gCSCount;
#endif
extern CRITICAL_SECTION gcsDPSPCritSection;     // defined in dllmain.c
#define INIT_DPSP_CSECT() InitializeCriticalSection(&gcsDPSPCritSection);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&gcsDPSPCritSection);
#ifdef DEBUG
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection),gCSCount++;
#define LEAVE_DPSP() gCSCount--,LeaveCriticalSection(&gcsDPSPCritSection);
#else
#define ENTER_DPSP() EnterCriticalSection(&gcsDPSPCritSection);
#define LEAVE_DPSP() LeaveCriticalSection(&gcsDPSPCritSection);
#endif // DEBUG

// get a pointer to the players socket address - used by macros below
#define DGRAM_PSOCKADDR(ppd) ((SOCKADDR_IN6 *)&(((LPSPPLAYERDATA)ppd)->saddrDatagram))
#define STREAM_PSOCKADDR(ppd) ((SOCKADDR_IN6 *)&(((LPSPPLAYERDATA)ppd)->saddrStream))

// get the udp ip addr from a player
#define IP_DGRAM_PORT(ppd)      (DGRAM_PSOCKADDR(ppd)->sin6_port)

// get the stream ip addr from a player
#define IP_STREAM_PORT(ppd) (STREAM_PSOCKADDR(ppd)->sin6_port)

// used to get the name of the computer we're running on in spinit
#define HOST_NAME_LENGTH 50

// 84a22c0b-45af-4ad9-a4f1-4bf547f7d0d2
DEFINE_GUID(GUID_IPV6,
0x84a22c0b, 0x45af, 0x4ad9, 0xa4, 0xf1, 0x4b, 0xf5, 0x47, 0xf7, 0xd0, 0xd2);

// 0855c42a-4193-4ed1-bbbc-39a9c597157e
DEFINE_GUID(GUID_LOCAL_IPV6, 
0x0855c42a, 0x4193, 0x4ed1, 0xbb, 0xbc, 0x39, 0xa9, 0xc5, 0x97, 0x15, 0x7e);


// globals
// ghinstance is used when putting up the dialog box to prompt for ip addr
extern HANDLE ghInstance; // set in dllmain. instance handle for dpwsock.dll

extern const IN6_ADDR in6addr_multicast;
extern const SOCKADDR_IN6 sockaddr_any;

#ifdef DEBUG

extern void DebugPrintAddr(UINT level,LPSTR pStr,SOCKADDR * psockaddr);
#define DEBUGPRINTADDR(n,pstr,psockaddr) DebugPrintAddr(n,pstr,(LPSOCKADDR)psockaddr);
extern void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock);
#define DEBUGPRINTSOCK(n,pstr,psock) DebugPrintSocket(n,pstr,psock);

#else // debug

#define DEBUGPRINTADDR(n,pstr,psockaddr)
#define DEBUGPRINTSOCK(n,pstr,psock)

#endif // debug

// global vars
extern BOOL gbVoiceOpen; // set to TRUE if we have nm call open

// from dpsp.c
#define IN6ADDR_MULTICAST_INIT {0xff,0x02,0,0,0,0,0,0,0,0,0,0,0,0,0x01,0x30}
extern HRESULT WaitForThread(HANDLE hThread);
extern HRESULT SetupControlSocket();
extern HRESULT WINAPI SP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT InternalReliableSend(LPGLOBALDATA pgd, DPID idPlayerTo, SOCKADDR_IN6 *
        lpSockAddr, LPBYTE lpMessage, DWORD dwMessageSize);
extern HRESULT DoTCPEnumSessions(LPGLOBALDATA pgd, SOCKADDR *lpSockAddr, DWORD dwAddrSize,
        LPDPSP_ENUMSESSIONSDATA ped, BOOL bHostWillReuseConnection);
extern HRESULT SendControlMessage(LPGLOBALDATA pgd);
extern HRESULT SendReuseConnectionMessage(SOCKET sSocket);
extern HRESULT AddSocketToBag(LPGLOBALDATA pgd, SOCKET socket, DPID dpid, SOCKADDR_IN6 *psockaddr, DWORD dwFlags);
extern BOOL FindSocketInReceiveList(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket);
extern void RemoveSocketFromReceiveList(LPGLOBALDATA pgd, SOCKET socket);
extern void RemoveSocketFromBag(LPGLOBALDATA pgd, SOCKET socket);
extern BOOL FindSocketInBag(LPGLOBALDATA pgd, SOCKADDR *pSockAddr, SOCKET * psSocket, LPDPID lpdpidPlayer);
extern HRESULT GetSocketFromBag(LPGLOBALDATA pgd,SOCKET * psSocket, DWORD dwID, LPSOCKADDR_IN6 psockaddr);
extern HRESULT CreateAndConnectSocket(LPGLOBALDATA pgd,SOCKET * psSocket,DWORD dwType,LPSOCKADDR_IN6 psockaddr, BOOL bOutBoundOnly);
extern void RemovePlayerFromSocketBag(LPGLOBALDATA pgd,DWORD dwID);
extern void SetMessageHeader(LPDWORD pdwMsg,DWORD dwSize, DWORD dwToken);
extern void KillTCPEnumAsyncThread(LPGLOBALDATA pgd);
extern SOCKET_ADDRESS_LIST *GetHostAddr(void);
extern void FreeHostAddr(SOCKET_ADDRESS_LIST *pList);

// Support for SendEx in dpsp.c

extern HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO lpSendInfo);
extern HRESULT ReliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo);
extern VOID RemovePendingAsyncSends(LPGLOBALDATA pgd, DPID dwPlayerTo);
extern BOOL bAsyncSendsPending(LPGLOBALDATA pgd, DPID dwPlayerTo);

// from winsock.c
extern HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,
        WORD port,const SOCKADDR_IN6 * psockaddr,SOCKERR * perr, BOOL bInRange);
extern HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly);
extern HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd);
extern HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream); 
extern HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags); 
extern HRESULT SetDescriptionAddress(LPSPPLAYERDATA ppd,LPDPSESSIONDESC2 lpsdDesc);
extern HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket);
extern HRESULT GetReturnAddress(LPVOID pmsg,LPSOCKADDR_IN6 psockaddr);
extern HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR_IN6 psockaddr) ;
extern void IP6_GetAddr(SOCKADDR_IN6 * paddrDest,SOCKADDR_IN6 * paddrSrc) ;
extern void IP6_SetAddr(LPVOID pBuffer,SOCKADDR_IN6 * psockaddr);
extern HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard);
extern HRESULT KillPlayerSockets();
extern HRESULT GetAddress(SOCKADDR_IN6 * puAddress,char *pBuffer,int cch);
extern HRESULT KillThread(HANDLE hThread);

// from wsock2.c
extern DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast);
extern HRESULT InitWinsock2();
extern HRESULT GetMaxUdpBufferSize(SOCKET socket, unsigned int * lpiSize);

extern HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, 
                                LPSENDINFO pSendInfo, SOCKADDR_IN6 *lpSockAddr);
extern DWORD WINAPI SPSendThread(LPVOID lpv);

extern int Dplay_GetAddrInfo(const char FAR *nodename, const char FAR *servname,
                LPADDRINFO hints, ADDRINFO FAR * FAR * res);
extern void Dplay_FreeAddrInfo(LPADDRINFO pai);


#ifdef DPLAY_VOICE_SUPPORT
// from spvoice.c
extern HRESULT WINAPI SP_OpenVoice(LPDPSP_OPENVOICEDATA pod) ;
extern HRESULT WINAPI SP_CloseVoice(LPDPSP_CLOSEVOICEDATA pod) ;
#endif // DPLAY_VOICE_SUPPORT

// from handler.c
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize);

// from ipv6.c
extern DWORD ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *, void *,void *,
                void *), void *Context1, void *Context2, void *Context3);
extern void ForEachAddress(IPV6_INFO_INTERFACE *IF, void 
                (*func)(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *, void *), 
                void *);
extern UINT JoinEnumGroup(SOCKET sSocket, UINT ifindex);

#ifdef FULLDUPLEX_SUPPORT
// from registry.c
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags);
#endif // FULLDUPLEX_SUPPORT

// MACROS based on fixed pool manager.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\dputils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.h
 *  Content:	common upport routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

// char used when we can't convert from unicode to ansi
#define DPLAY_DEFAULT_CHAR "-"

extern int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
extern int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "windows.h"
#include "dpsp.h"
#include "fpm.h"

#ifdef SENDEX

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = GlobalAlloc(GPTR, this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			GlobalFree(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

#ifdef DEBUG
void DebugCheckList(void *pvList, void *pvItem)
{
	void *pvWalker;
	DWORD n=0;
	pvWalker=pvList;

	while(pvWalker){
		if(pvWalker==pvItem){
			DPF(0,"ERROR: Found Item %x in List %x, item # %d\n",pvList,pvItem,n);
			DEBUG_BREAK();
		}
		n++;
		pvWalker=*((void **)pvWalker);
	}
}
#else
#define DebugCheckList()
#endif

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	DebugCheckList(this->pPool, pvItem); //BUGBUG: debug only.
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			GlobalFree(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		GlobalFree(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		DPF(0,"WSOCK: Exiting with unfreed FPM pool items\n");
	}
	DeleteCriticalSection(&this->cs);
	GlobalFree(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)GlobalAlloc(GPTR,sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\handler.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandleMessage"

// this function is called with dpws lock taken
HRESULT HandleServerMessage(LPGLOBALDATA pgd, SOCKET sSocket, LPBYTE pBuffer, DWORD dwSize)
{
	LPMSG_GENERIC pMessage = (LPMSG_GENERIC) pBuffer;
	DWORD dwType;
	DWORD dwVersion;
	HRESULT hr=DP_OK;

	ASSERT(pMessage);
	
	dwType = GET_MESSAGE_COMMAND(pMessage);
	dwVersion = GET_MESSAGE_VERSION(pMessage);
	
	switch (dwType) {
			
	default:
		DPF(0,"dpwsock received unrecognized message of type 0x%08x\n",dwType);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\helpcli.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.h
 *  Content:	header file for dplay helper interface
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#ifndef __HELPCLI_INCLUDED__
#define __HELPCLI_INCLUDED__
#include "windows.h"
#include "dplaysvr.h"
#include "dpf.h"

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL CreateHelperProcess( LPDWORD ppid );
extern BOOL WaitForHelperStartup( void );
extern HRESULT HelperAddDPlayServer(USHORT port);
extern BOOL HelperDeleteDPlayServer(USHORT port);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\helpcli.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helpcli.c
 *  Content:	client code to talk to dplaysvr.exe
 *					allows multiple dplay winscock clients to share
 *					a single port.  see %manroot%\dplay\dplaysvr\dphelp.c
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/15/97		andyco	created from w95help.h
 *
 ***************************************************************************/
#include "helpcli.h"

extern DWORD	dwHelperPid;

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
    LPDPHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        CloseHandle( hstartevent );
        return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
                DPHELP_SHARED_NAME );
    if( hmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
        DPF( 1, "Could not create view of file!" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex!" );
        UnmapViewOfFile( phd );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DPHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
    if( SetEvent( hstartevent ) )
    {
        WaitForSingleObject( hackevent, INFINITE );
        memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
        rc = TRUE;
    }
    else
    {
        DPF( 1, "Could not signal event to notify DPHELP" );
        rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */


/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE	hevent;
    DWORD	rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
        return FALSE;
    }
    DPF( 3, "Wait DPHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, INFINITE );
    CloseHandle( hevent );
    return TRUE;

} /* WaitForHelperStartup */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
        STARTUPINFO		si;
        PROCESS_INFORMATION	pi;
        HANDLE			h;

        h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
        if( h == NULL )
        {
            si.cb = sizeof(STARTUPINFO);
            si.lpReserved = NULL;
            si.lpDesktop = NULL;
            si.lpTitle = NULL;
            si.dwFlags = 0;
            si.cbReserved2 = 0;
            si.lpReserved2 = NULL;

            DPF( 3, "Creating helper process dplsvr6.exe now" );
            if( !CreateProcess("dplsvr6.exe", NULL, NULL, NULL, FALSE,
                               NORMAL_PRIORITY_CLASS,
                               NULL, NULL, &si, &pi) )
            {
                DPF( 2, "Could not create DPHELP.EXE" );
                return FALSE;
            }
            dwHelperPid = pi.dwProcessId;
            DPF( 3, "Helper Process created" );
        }
        else
        {
            DPHELPDATA	hd;
            DPF( 3, "dplsvr6 already exists, waiting for dplsvr6 event" );
            WaitForSingleObject( h, INFINITE );
            CloseHandle( h );
            DPF( 3, "Asking for DPHELP pid" );
            hd.req = DPHELPREQ_RETURNHELPERPID;
            sendRequest( &hd );
            dwHelperPid = hd.pid;
            DPF( 3, "DPHELP pid = %08lx", dwHelperPid );
        }
        *ppid = dwHelperPid;
        return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

// notify dphelp.c that we have a new server on this system
HRESULT HelperAddDPlayServer(USHORT port)
{
    DPHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    memset(&hd, 0, sizeof(DPHELPDATA));
    hd.req = DPHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd.port = port;
    if (sendRequest(&hd)) return hd.hr;
    else return E_FAIL;
				
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(USHORT port)
{
    DPHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

	memset(&hd, 0, sizeof(DPHELPDATA));
    hd.req = DPHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
	hd.port = port;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\leverage.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       leverage.c
 *  Content:	code to allow third parties to hook our wsock sp
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	8/30/96	andyco	moved this code from dpsp.c for more better clean
 *	2/18/98 a-peterz Comment byte order for address and port parameters
 **************************************************************************/

#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"dpwsock helper functions- "


// the functions below are exported from dpwsock so sp's sitting on 
// top of us can hook our enum routine (e.g. for Kali)
// return the port of our enum socket (net byte order)
HRESULT DPWS_GetEnumPort(IDirectPlaySP * pISP,LPWORD pPort)
{
	SOCKADDR_IN6 sockaddr;
	int iAddrLen = sizeof(sockaddr);
	UINT err;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;
		
	if (!pISP)
	{
		DPF_ERR("must pass in IDirectPlaySP pointer!");
		return E_FAIL;
	}
	
	// get the global data
	hr =pISP->lpVtbl->GetSPData(pISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		ExitThread(0);
		return 0;

	}

	ASSERT(pPort);
	ASSERT(INVALID_SOCKET != pgd->sSystemStreamSocket);
	
    err = getsockname(pgd->sSystemStreamSocket,(SOCKADDR *)&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"GetEnumPort - getsockname - err = %d\n",err);
		return E_FAIL;
    } 

	*pPort = sockaddr.sin6_port;
	
	return DP_OK;
} // GetEnumPort
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "newdpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lBytesAlloc;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
	lBytesAlloc+=pmt->dwSize;\
		{	\
			IN_WRITESTATS InWS;	\
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	\
		 	InWS.stat_USER3=lBytesAlloc;	\
			DbgWriteStats(&InWS);	\
		} \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

#ifdef DEBUG
	    lBytesAlloc -= pmt->dwSize;
		{	
			IN_WRITESTATS InWS;	
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	
		 	InWS.stat_USER3=lBytesAlloc;	
			DbgWriteStats(&InWS);	
		}
#endif

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	lBytesAlloc -= pmt->dwSize;

	pmt->dwSize = size - sizeof( MEMTRACK );

	lBytesAlloc += pmt->dwSize;

	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER3=lBytesAlloc;
		DbgWriteStats(&InWS);
	}

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lBytesAlloc = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\ipv6.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Helper functions for dealing with the IPv6 protocol stack.
// Really these should be in a library of some kind.
//

#include "dpsp.h"

HANDLE Handle;

//
// Initialize this module.
// Returns FALSE for failure.
//
int
InitIPv6Library(void)
{
    //
    // Get a handle to the IPv6 device.
    // We will use this for ioctl operations.
    //
    Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                         0,      // access mode
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,   // security attributes
                         OPEN_EXISTING,
                         0,      // flags & attributes
                         NULL);  // template file

    return Handle != INVALID_HANDLE_VALUE;
}

DWORD
ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *, void *, void *, void *), void *Context1, void *Context2, void *Context3)
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;
    DWORD dwErr = NO_ERROR;
    
    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MemAlloc(InfoSize);
    if (IF == NULL) {
        return GetLastError();
    }

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            dwErr = GetLastError();
            break;
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {
                // inconsistent interface info length
                return ERROR_INVALID_DATA;
            }

            (*func)(IF, Context1, Context2, Context3);
        }
        else {
            if (BytesReturned != sizeof IF->Next) {
                // inconsistent interface info length
                dwErr = ERROR_INVALID_DATA;
                break;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    MemFree(IF);
    return dwErr;
}

void
ForEachAddress(IPV6_INFO_INTERFACE *IF,
               void (*func)(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *, void *),
               void *Context)
{
    IPV6_QUERY_ADDRESS Query;
    IPV6_INFO_ADDRESS ADE;
    u_int BytesReturned;
    DWORD dwErr;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL)) {
            // bad address
            dwErr = GetLastError();
            DPF(0, "Query address failed with error = %d\n", dwErr);
            return;
        }

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if (BytesReturned != sizeof ADE) {
                // inconsistent address info length
                return;
            }

            (*func)(IF, &ADE, Context);
        }
        else {
            if (BytesReturned != sizeof ADE.Next) {
                // inconsistent address info length
                return;
            }
        }

        if (IN6_ADDR_EQUAL(&ADE.Next.Address, &in6addr_any))
            break;
        Query = ADE.Next;
    }
}

UINT
JoinEnumGroup(SOCKET sSocket, UINT ifindex)
{
    IPV6_MREQ mreq;

    mreq.ipv6mr_interface = ifindex;
    mreq.ipv6mr_multiaddr = in6addr_multicast;

    return setsockopt(sSocket, IPPROTO_IPV6, IPV6_JOIN_GROUP,
                      (CHAR FAR *)&mreq, sizeof mreq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\addr.c ===
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME    "GetHostAddr"

#define DUMMYPORTNAME "1" // value unused but must be non-zero

void
AddAddress(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, void *Context)
{
    int i;
    LPSOCKADDR_IN6 ps;
    SOCKET_ADDRESS_LIST *pList = (SOCKET_ADDRESS_LIST *)Context;
    ULONG ulSize = sizeof(SOCKADDR_IN6);

    // Skip it if it's not a unicast address
    if (IN6_IS_ADDR_MULTICAST(&ADE->This.Address))
    {
        return;
    }

    ps = MemAlloc(ulSize);
    if (ps == NULL)
    {
        // Memory allocation failed
        DEBUGPRINTADDR(0,"Could not add address : \n",ps);
        return;
    }
    
    i = pList->iAddressCount++;
    
    ZeroMemory(ps, ulSize);
    ps->sin6_family = AF_INET6;
    ps->sin6_addr = ADE->This.Address;
    ps->sin6_scope_id = IF->ZoneIndices[ADE->Scope];
    
    pList->Address[i].iSockaddrLength = ulSize;
    pList->Address[i].lpSockaddr = (LPSOCKADDR)ps;

    DEBUGPRINTADDR(0,"Added address : \n",ps);
}

void
AddInterfaceAddresses(IPV6_INFO_INTERFACE *IF, void *Context1, void *Context2, void *Context3)
{
    // Skip the loopback interface
    if (IF->This.Index == 1)
    {
        return;
    }

    DPF(0,"Processing interface %d",IF->This.Index);
    ForEachAddress(IF, AddAddress, Context1);
}

void
CountAddress(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE, void *Context)
{
    ULONG *pulNumAddresses = (ULONG *)Context; 

    // Skip it if it's not a unicast address
    if (IN6_IS_ADDR_MULTICAST(&ADE->This.Address))
    {
        return;
    }

    (*pulNumAddresses)++;
}

void
CountInterfaceAddresses(IPV6_INFO_INTERFACE *IF, void *Context1, void *Context2, void *Context3)
{
    // Skip the loopback interface
    if (IF->This.Index == 1)
    {
        return;
    }

    ForEachAddress(IF, CountAddress, Context1);
}

// Helper function to retrieve host IP Address(es).
// Caller must call FreeHostAddr on list returned
SOCKET_ADDRESS_LIST *GetHostAddr(void)
{
    UINT err;
    ULONG ulNumAddresses = 0;
    SOCKET_ADDRESS_LIST *pList;

    ForEachInterface(CountInterfaceAddresses, &ulNumAddresses, NULL, NULL);
    if (ulNumAddresses == 0)
    {
        DPF(0,"could not get addresses for local machine\n");
        return NULL;
    }

    pList = MemAlloc( FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address[ulNumAddresses] ));
    if (pList == NULL) 
    {
        DPF(0,"could not get addresses for local machine - err = %d\n", GetLastError());
        return NULL;
    }

    pList->iAddressCount = 0;
    ForEachInterface(AddInterfaceAddresses, pList, NULL, NULL);

    return pList;
} // GetHostAddr

void
FreeHostAddr(SOCKET_ADDRESS_LIST *pList)
{
    int i;
    for (i=0; i<pList->iAddressCount; i++)
    {
        MemFree(pList->Address[i].lpSockaddr);
    }
    MemFree(pList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   6/10/98   a-peterz Check CreateFile() result against INVALID_HANDLE_VALUE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "newdpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
    extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;

int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl(
HANDLE hDevice,             // handle to device of interest
DWORD dwIoControlCode,      // control code of operation to perform
LPVOID lpInBuffer,          // pointer to buffer to supply input data
DWORD nInBufferSize,        // size of input buffer
LPVOID lpOutBuffer,         // pointer to buffer to receive output data
DWORD nOutBufferSize,       // size of output buffer
LPDWORD lpBytesReturned,    // pointer to variable to receive output byte count
LPOVERLAPPED lpOverlapped   // pointer to overlapped structure for asynchronous operation
);
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG   (FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG  (FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)

HANDLE hDPLAY_VxD=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;

typedef struct _LOGENTRY {
    CHAR    debuglevel;
    CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
    UINT    nLogEntries;
    UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
    UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
    CHAR    debuglevel;
    CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
    UINT    hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

void DbgWriteStats(PIN_WRITESTATS pIn)
{
    UINT rc;
    UINT cbRet;

    if(hDPLAY_VxD){
        DeviceIoControl(hDPLAY_VxD,WRITE_STATS,pIn,sizeof(IN_WRITESTATS), &rc, sizeof(rc), &cbRet, NULL);
    }
}

static BOOL InitMemLogString(VOID)
{
    DWORD dwLastError;

    hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
    dwLastError=GetLastError();
    hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
    pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

    if(!hLogFile || !hLogMutex || !pLogFile){
        if(hLogFile){
            CloseHandle(hLogFile);
            hLogFile=0;
        }
        if(hLogMutex){
            CloseHandle(hLogMutex);
            hLogMutex=0;
        }
        if(pLogFile){
            UnmapViewOfFile(pLogFile);
            pLogFile=NULL;
        }
        return FALSE;
    } else {
        WaitForSingleObject(hLogMutex,INFINITE);
            if((dwLastError!=ERROR_ALREADY_EXISTS) ||
                (pLogFile->nEntries > DPLOG_NUMENTRIES) || (pLogFile->nEntries == 0) ||
                (pLogFile->cbLine   > DPLOG_ENTRYSIZE)  || (pLogFile->cbLine   == 0) ||
                (pLogFile->iWrite   > DPLOG_NUMENTRIES) ||
                (pLogFile->cInUse   > DPLOG_NUMENTRIES)
            ){
                pLogFile->nEntries = DPLOG_NUMENTRIES;
                pLogFile->cbLine   = DPLOG_ENTRYSIZE;
                pLogFile->iWrite   = 0;
                pLogFile->cInUse   = 0;
            }
        ReleaseMutex(hLogMutex);
    }
    return TRUE;
}

static void MemLogString(LPSTR str)
{
    PLOG_ENTRY pEntry;
    DWORD cbCopy;

    if(!hLogFile){
        if(!InitMemLogString()){
            return;
        }
    }

    WaitForSingleObject(hLogMutex,INFINITE);

    pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
    pEntry->hThread=GetCurrentThreadId();
    pEntry->tLogged=timeGetTime();
    pEntry->DebugLevel=0;

    cbCopy=strlen(str)+1;
    if(cbCopy > DPLOG_ENTRYSIZE){
        str[DPLOG_ENTRYSIZE]=0;
        cbCopy=DPLOG_ENTRYSIZE;
    }
    memcpy(pEntry->str, str, cbCopy);

    if(pLogFile->iWrite+1 > pLogFile->cInUse){
        pLogFile->cInUse=pLogFile->iWrite+1;
    }

    pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
    ReleaseMutex(hLogMutex);

}

static void LogString( LPSTR str )
{
    char logstring[MAX_STRING+sizeof(LOGENTRY)];
    int  i=0;
    PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
    UINT rc;
    UINT cbRet;
    int maxlen = MAX_STRING+sizeof(LOGENTRY);

    if(hDPLAY_VxD && str){
        while(str[i] && i < maxlen)
            i++;
        pLogEntry->debuglevel=0;
        memcpy(pLogEntry->str,str,i+1);
        DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
    }

    if(bLogging & 2){
        MemLogString(str);
    }
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
    if(!bLogging || bLogging & 1)
    {
        OUTPUTDEBUGSTRING( str );
        OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
        LogString(str);
    }

}

void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT   "DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
            hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
            if(hDPLAY_VxD != INVALID_HANDLE_VALUE){
                IN_LOGINIT In;
                OUT_LOGINIT Out;
                UINT cbRet;
                In.nCharsPerLine=MAX_STRING;
                In.nLogEntries=5000;
                DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
            }
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(volatile DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;

    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) UlongToPtr(arg);

    cMsg[0]=0;

    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;

}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
    /*
     * Into the debugger we go...
     */
    DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\dplaysvr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.h
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share 
 *				a single winsock port
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp 
 *	1/29/98		sohailm	added macros for critical section
 *
 ***************************************************************************/
#ifndef __DPLAYSVR_INCLUDED__
#define __DPLAYSVR_INCLUDED__

// need this for hresult
#include "ole2.h"

// crit section
extern CRITICAL_SECTION gcsCritSection;	// defined in dphelp.c
#define INIT_DPLAYSVR_CSECT() InitializeCriticalSection(&gcsCritSection);
#define FINI_DPLAYSVR_CSECT() DeleteCriticalSection(&gcsCritSection);

#ifdef DEBUG
extern int gnCSCount; // count of dplaysvr lock
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection),gnCSCount++;
#define LEAVE_DPLAYSVR() gnCSCount--;ASSERT(gnCSCount>=0);LeaveCriticalSection(&gcsCritSection);
#else 
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection);
#define LEAVE_DPLAYSVR() LeaveCriticalSection(&gcsCritSection);
#endif

/*
 * named objects
 */
#define DPHELP_EVENT_NAME			"__DPHelpEvent__"
#define DPHELP_ACK_EVENT_NAME		"__DPHelpAckEvent__"
#define DPHELP_STARTUP_EVENT_NAME	"__DPHelpStartupEvent__"
#define DPHELP_SHARED_NAME			"__DPHelpShared__"
#define DPHELP_MUTEX_NAME			"__DPHelpMutex__"

/*
 * requests 
 */
#define DPHELPREQ_SUICIDE			1
#define DPHELPREQ_DPLAYADDSERVER	2
#define DPHELPREQ_DPLAYDELETESERVER	3
#define DPHELPREQ_RETURNHELPERPID 	4

/*
 * communication data
 */
typedef struct DPHELPDATA
{
    int			req;
    DWORD		pid;
	USHORT		port;
    HRESULT		hr;
} DPHELPDATA, *LPDPHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\ipv6.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Helper functions for dealing with the IPv6 protocol stack.
// Really these should be in a library of some kind.
//

#include "dpsp.h"

HANDLE Handle;

//
// Initialize this module.
// Returns FALSE for failure.
//
int
InitIPv6Library(void)
{
    //
    // Get a handle to the IPv6 device.
    // We will use this for ioctl operations.
    //
    Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                         0,      // access mode
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,   // security attributes
                         OPEN_EXISTING,
                         0,      // flags & attributes
                         NULL);  // template file

    return Handle != INVALID_HANDLE_VALUE;
}

DWORD
ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *, void *, void *, void *), void *Context1, void *Context2, void *Context3)
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;
    DWORD dwErr = NO_ERROR;
    
    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MemAlloc(InfoSize);
    if (IF == NULL) {
        return GetLastError();
    }

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            dwErr = GetLastError();
            break;
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {
                // inconsistent interface info length
                return ERROR_INVALID_DATA;
            }

            (*func)(IF, Context1, Context2, Context3);
        }
        else {
            if (BytesReturned != sizeof IF->Next) {
                // inconsistent interface info length
                dwErr = ERROR_INVALID_DATA;
                break;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    MemFree(IF);
    return dwErr;
}

void
ForEachAddress(IPV6_INFO_INTERFACE *IF,
               void (*func)(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *, void *),
               void *Context)
{
    IPV6_QUERY_ADDRESS Query;
    IPV6_INFO_ADDRESS ADE;
    u_int BytesReturned;
    DWORD dwErr;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL)) {
            // bad address
            dwErr = GetLastError();
            DPF(0, "Query address failed with error = %d\n", dwErr);
            return;
        }

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if (BytesReturned != sizeof ADE) {
                // inconsistent address info length
                return;
            }

            (*func)(IF, &ADE, Context);
        }
        else {
            if (BytesReturned != sizeof ADE.Next) {
                // inconsistent address info length
                return;
            }
        }

        if (IN6_ADDR_EQUAL(&ADE.Next.Address, &in6addr_any))
            break;
        Query = ADE.Next;
    }
}

UINT
JoinEnumGroup(SOCKET sSocket, UINT ifindex)
{
    IPV6_MREQ mreq;

    mreq.ipv6mr_interface = ifindex;
    mreq.ipv6mr_multiaddr = in6addr_multicast;

    return setsockopt(sSocket, IPPROTO_IPV6, IPV6_JOIN_GROUP,
                      (CHAR FAR *)&mreq, sizeof mreq);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\wsock2.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wsock2.c
 *  Content:    DirectPlay Winsock 2 SP support.  Called from dpsp.c.
 *  History:
 *   Date               By              Reason
 *   ====               ==              ======
 *      7/11//97        andyco  created it
 *  2/13/98     aarono  added async support.
 *  4/6/98      aarono  mapped WSAECONNRESET to DPERR_CONNECTIONLOST
 *  6/6/98      aarono  B#27187 fix ref counting on send blocks in sync error case
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 **************************************************************************/

// this module is for async connections and sends
// currently only used as the reply thread proc for async replies. see dpsp.c::sp_reply

#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#include <winsock2.h>
#include "dpsp.h"

#undef DPF_MODNAME
#define DPF_MODNAME     "AsyncSendThreadProc"

extern HINSTANCE hWS2;  // dynaload the ws2_32.dll, so if it's not installed
                                                // (e.g. win 95 gold) we still load

extern HINSTANCE hWSHIP6;       // dynaload the wship6.dll, so if it's not installed

// prototypes for our dynaload fn's                                             

LPFN_WSAWAITFORMULTIPLEEVENTS g_WSAWaitForMultipleEvents;
LPFN_WSASEND g_WSASend;
LPFN_WSASENDTO g_WSASendTo;
LPFN_WSACLOSEEVENT g_WSACloseEvent;
LPFN_WSACREATEEVENT g_WSACreateEvent;
LPFN_WSAENUMNETWORKEVENTS g_WSAEnumNetworkEvents;
LPFN_WSAEVENTSELECT g_WSAEventSelect;
LPFN_GETSOCKOPT g_getsockopt;
LPFN_GETADDRINFO g_getaddrinfo;
LPFN_FREEADDRINFO g_freeaddrinfo;

// if no getaddrinfo, try loading from wship6.dll for Win2000 tech preview
HRESULT InitWship6()
{
    hWSHIP6 = LoadLibrary("wship6.dll");
        if (!hWSHIP6)
        {
                DPF(0,"Could not load wship6.dll\n");
                goto LOADLIBRARYFAILED;
        }

        // get pointers to the entry points we need
        g_getaddrinfo = (LPFN_GETADDRINFO)GetProcAddress(hWSHIP6, "getaddrinfo");
        if (!g_getaddrinfo) goto GETPROCADDRESSFAILED;

        g_freeaddrinfo = (LPFN_FREEADDRINFO)GetProcAddress(hWSHIP6, "freeaddrinfo");
        if (!g_freeaddrinfo) goto GETPROCADDRESSFAILED;

        return DP_OK;   

GETPROCADDRESSFAILED:

        FreeLibrary(hWSHIP6);
        hWSHIP6 = NULL;
        // fall through
        
LOADLIBRARYFAILED:

        g_getaddrinfo = NULL;
        g_freeaddrinfo = NULL;

        return DPERR_UNAVAILABLE;
}

// attempt to load the winsock 2 dll, and get our proc addresses from it
HRESULT InitWinsock2()
{
        // load winsock library
    hWS2 = LoadLibrary("ws2_32.dll");
        if (!hWS2)
        {
                DPF(0,"Could not load ws2_32.dll\n");
                // reset our winsock 2 global
                goto LOADLIBRARYFAILED;
        }

        // get pointers to the entry points we need
        g_WSAWaitForMultipleEvents = (LPFN_WSAWAITFORMULTIPLEEVENTS)GetProcAddress(hWS2, "WSAWaitForMultipleEvents");
        if(!g_WSAWaitForMultipleEvents) goto GETPROCADDRESSFAILED;

        g_WSASend = (LPFN_WSASEND)GetProcAddress(hWS2, "WSASend");
        if (!g_WSASend) goto GETPROCADDRESSFAILED;

        g_WSASendTo = (LPFN_WSASENDTO)GetProcAddress(hWS2, "WSASendTo");
        if (!g_WSASendTo) goto GETPROCADDRESSFAILED;

    g_WSAEventSelect = ( LPFN_WSAEVENTSELECT )GetProcAddress(hWS2, "WSAEventSelect");
        if (!g_WSAEventSelect) goto GETPROCADDRESSFAILED;

        g_WSAEnumNetworkEvents = (LPFN_WSAENUMNETWORKEVENTS)GetProcAddress(hWS2, "WSAEnumNetworkEvents");
        if (!g_WSAEnumNetworkEvents) goto GETPROCADDRESSFAILED;

        g_WSACreateEvent = (LPFN_WSACREATEEVENT)GetProcAddress(hWS2, "WSACreateEvent");
        if (!g_WSACreateEvent) goto GETPROCADDRESSFAILED;

        g_WSACloseEvent = (LPFN_WSACLOSEEVENT)GetProcAddress(hWS2, "WSACloseEvent");
        if (!g_WSACloseEvent) goto GETPROCADDRESSFAILED;

        g_getsockopt = (LPFN_GETSOCKOPT)GetProcAddress(hWS2, "getsockopt");
        if (!g_getsockopt) goto GETPROCADDRESSFAILED;

        g_getaddrinfo = (LPFN_GETADDRINFO)GetProcAddress(hWS2, "getaddrinfo");
        g_freeaddrinfo = (LPFN_FREEADDRINFO)GetProcAddress(hWS2, "freeaddrinfo");

    if (!g_getaddrinfo || !g_freeaddrinfo) 
    {
        if (FAILED(InitWship6()))
        {
            goto GETPROCADDRESSFAILED;
        }
    }

        return DP_OK;   

GETPROCADDRESSFAILED:

        DPF(0,"Could not find required Winsock entry point");
        FreeLibrary(hWS2);
        hWS2 = NULL;
        // fall through
        
LOADLIBRARYFAILED:

        g_WSAEventSelect = NULL;
        g_WSAEnumNetworkEvents = NULL;
        g_WSACreateEvent = NULL;
        g_WSACloseEvent = NULL;

        return DPERR_UNAVAILABLE;
        
} // InitWinsock2

// remove the reply node from the list
void DeleteReplyNode(LPGLOBALDATA pgd,LPREPLYLIST prd, BOOL bKillSocket)
{       
        LPREPLYLIST prdPrev;
        
        ENTER_DPSP();

        // 1st, remove prd from the list
        
        // is it the root?
        if (prd == pgd->pReplyList) pgd->pReplyList = pgd->pReplyList->pNextReply;
        else
        {
                BOOL bFound = FALSE;
                
                // it's not the root - take it out of the middle
                prdPrev = pgd->pReplyList;
                while (prdPrev && !bFound)
                {
                        if (prdPrev->pNextReply == prd)
                        {
                                prdPrev->pNextReply = prd->pNextReply;
                                bFound = TRUE;
                        }
                        else
                        {
                                prdPrev = prdPrev->pNextReply;
                        }
                } // while
                
                ASSERT(bFound);
                
        } // not the root

        // now clean up prd
        
        // nuke the socket
        if (bKillSocket)
                KillSocket(prd->sSocket,TRUE,FALSE);
        
        // free up the node
        if (prd->lpMessage) MemFree(prd->lpMessage);
        MemFree(prd);
        
        LEAVE_DPSP();
        
        return ;

} // DeleteReplyNode

/*
 **  AsyncConnectAndSend
 *
 *  CALLED BY: AsyncSendThreadProc
 *
 *  DESCRIPTION:
 *                      
 *                      if necessary, creates a non-blocking socket, and initiates a connection
 *                              to address specified in prd
 *                      once connection has been completed, does a synchronous (blocking) send and
 *                              removes prd from the global list
 */
HRESULT AsyncConnectAndSend(LPGLOBALDATA pgd,LPREPLYLIST prd)
{
        UINT err;
        HRESULT hr;
    SOCKADDR_IN6 sockaddr;
        UINT addrlen = sizeof(SOCKADDR_IN6);    
        BOOL bConnectionExists = FALSE;
        BOOL bKillConnection = TRUE;

        if (INVALID_SOCKET == prd->sSocket)
        {
                u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
                DPID dpidPlayer=0;
                
#ifdef FULLDUPLEX_SUPPORT       
                // if client wants us to reuse a connection, it would have indicated so and the connection
                // would have been added to our send list by now. See if it exists.
                
                // TODO - we don't want to search the list everytime -  find a better way
                bConnectionExists = FindSocketInBag(pgd, &prd->sockaddr, &prd->sSocket, &dpidPlayer);
#endif // FULLDUPLEX_SUPPORT

                if (!bConnectionExists)
                {
                        SOCKET sSocket; 

                        // socket didn't exist in our send list, let's send it on a new temporary connection
                        DEBUGPRINTADDR(9,"Sending aync reply on a new connection to - ", &(prd->sockaddr));                             
                        
                        // need to get the new socket
                        hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,0,&sockaddr_any,&err,FALSE);
                        if (FAILED(hr))
                        {
                                DPF(0,"create async socket failed - err = %d\n",err);
                                return hr;
                        }
                        
                        prd->sSocket = sSocket;
                        
                        // set socket to non-blocking
                        err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
                        if (SOCKET_ERROR == err)
                        {
                                err = WSAGetLastError();
                                DPF(0,"could not set non-blocking mode on socket err = %d!",err);
                                DPF(0,"will revert to synchronous behavior.  bummer");
                        }

                        // now, start the connect
                        SetReturnAddress(prd->lpMessage,pgd->sSystemStreamSocket);              
                        err = connect(prd->sSocket,(LPSOCKADDR)&prd->sockaddr,addrlen);
                        if (SOCKET_ERROR == err)
                        {
                                err = WSAGetLastError();
                                if (WSAEWOULDBLOCK == err)
                                {
                                        // this is expected. the operation needs time to complete.
                                        // select will tell us when the socket is good to go.
                                        return DP_OK;
                                }
                                // else it's a real error!
                                DPF(0,"async reply - connect failed - error = %d\n",err);                       
                                DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
                                goto CLEANUP_EXIT;
                        }
                }
                else
                {
                        // we found our connection, let's reuse it
                        // set it to non-blocking
                        
                        DEBUGPRINTADDR(9,"Sending async reply on an existing connection to - ", &(prd->sockaddr));

                        err = ioctlsocket(prd->sSocket,FIONBIO,&lNonBlock);
                        if (SOCKET_ERROR == err)
                        {
                                err = WSAGetLastError();
                                DPF(0,"could not set non-blocking mode on socket err = %d!",err);
                                DPF(0,"will revert to synchronous behavior.  bummer");
                        }

                        // once we have a player id, the session has started. let's hold on to the connection
                        // we have and reuse it for the rest of the session
                        if (dpidPlayer) bKillConnection = FALSE;
                        
                } // FindSocketInBag
        
        } // INVALID_SOCKET

        // once we get here, we should have a connected socket ready to send!
        err = 0;
        // keep spitting bits at the socket until we finish or get an error
        while ((prd->dwBytesLeft != 0) && (SOCKET_ERROR != err))
        {
            err = send(prd->sSocket,prd->pbSend,prd->dwBytesLeft,0);
                if (SOCKET_ERROR != err)
                {
                        // some bytes went out on the wire
                        prd->dwBytesLeft -= err; // we just sent err bytes
                        prd->pbSend     += err; // advance our send buffer by err bytes         
                }
        }
        // now, we've either finished the send, or we have an error
        if (SOCKET_ERROR == err)
        {
                err = WSAGetLastError();
                if (WSAEWOULDBLOCK == err)
                {
                        // this means we couldn't send any bytes w/o blocking
                        // that's ok.  we'll let select tell us when it's ready to not block                    
                        return DP_OK;   
                }
                // else it's a real eror!
                // any other error, we give up and clean up this reply
                DPF(0,"async send - send failed - error = %d\n",err);                   
                DEBUGPRINTADDR(0,"async send - send failed - addr = ",(LPSOCKADDR)&(prd->sockaddr));
        }
        else ASSERT(0 == prd->dwBytesLeft); // if it's not an error, we better have sent it all
        
        // fall through

CLEANUP_EXIT:

        if (bConnectionExists && bKillConnection)
        {
                // close the connection after we're done
                RemoveSocketFromReceiveList(pgd,prd->sSocket);
                RemoveSocketFromBag(pgd,prd->sSocket);
                // so DeleteReplyNode won't try to kill socket again
                prd->sSocket = INVALID_SOCKET;
        }
        // remove the node from the list
        DeleteReplyNode(pgd,prd,bKillConnection);
        
        return DP_OK;

} // AsyncConnectAndSend

// walk the reply list, tell winsock to watch any of the nodes which has a valid socket
// (i.e. has a connection or send pending)
HRESULT DoEventSelect(LPGLOBALDATA pgd,WSAEVENT hSelectEvent)
{
        UINT err;
        LPREPLYLIST prd;

        ENTER_DPSP();
        
        prd = pgd->pReplyList;
        while (prd)
        {
                if (INVALID_SOCKET != prd->sSocket)
                {
                        // have winscok tell us when anything good (connection complete, ready to write more data)
                        // happens on this socket
                        err = g_WSAEventSelect(prd->sSocket,hSelectEvent,FD_WRITE | FD_CONNECT);
                        if (SOCKET_ERROR == err)
                        {
                                err = WSAGetLastError();
                                DPF(0,"could not do event select ! err = %d!",err);
                                // keep trying...
                        }
                } // invalid_socket
                
                prd = prd->pNextReply;
        }

        LEAVE_DPSP();
        
        return DP_OK;
        
} // DoEventSelect

// wsaeventselect woke us up.  one or more of our sockets had something happen
// (e.g. connect completed, send ready for more data, etc.)
// walk the reply list, find nodes who need to be serviced
void ServiceReplyList(LPGLOBALDATA pgd,WSAEVENT hEvent)
{
        UINT err;
        LPREPLYLIST prd,prdNext;
        WSANETWORKEVENTS WSANetEvents;

        ENTER_DPSP();
        
Top:    
        prd = pgd->pReplyList;
        while (prd)
        {
                // save this now - asyncconnectandsend could destroy prd
                prdNext = prd->pNextReply;
                if (INVALID_SOCKET != prd->sSocket)
                {
                        // go ask winsock if this socket had anything intersting happen
                        err = g_WSAEnumNetworkEvents(prd->sSocket,NULL,&WSANetEvents);

                        if (SOCKET_ERROR == err)
                        {
                                err = WSAGetLastError();
                                DPF(0,"could not enum events!! err = %d!",err);
                                // keep trying...
                        }
                        else
                        {
                                BOOL bError=FALSE;
                                // no error - go see what we got
                                if ((WSANetEvents.lNetworkEvents & FD_CONNECT) || (WSANetEvents.lNetworkEvents & FD_WRITE))
                                {
                                        // was there an error?
                                        if (WSANetEvents.iErrorCode[FD_CONNECT_BIT])
                                        {
                                                // we got a connect error!
                                                DPF(0,"async reply - WSANetEvents - connect failed - error = %d\n",
                                                        WSANetEvents.iErrorCode[FD_CONNECT_BIT]);
                                                DEBUGPRINTADDR(0,"async reply - connect failed - addr = ",
                                                        (LPSOCKADDR)&(prd->sockaddr));
                                                RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
                                                goto Top;
                                                        
                                        }

                                        if (WSANetEvents.iErrorCode[FD_WRITE_BIT])
                                        {
                                                // we got a send error!
                                                DPF(0,"async reply - WSANetEvents - send failed - error = %d\n",
                                                        WSANetEvents.iErrorCode[FD_WRITE_BIT]);
                                                DEBUGPRINTADDR(0,"async reply - send failed - addr = ",
                                                        (LPSOCKADDR)&(prd->sockaddr));
                                                RemovePendingAsyncSends(pgd, prd->dwPlayerTo);
                                                goto Top;
                                        }
                                        // note - we try + send even if there was an error.     seems like it's worth a shot...
                                        // go try + send

                                        AsyncConnectAndSend(pgd,prd);
                                }
                        }
                } // invalid_socket
                else
                {
                        // it it's an invalid socket, we need to init our connect and send
                        AsyncConnectAndSend(pgd,prd);   
                }
                
                prd = prdNext;          
                
        }

        LEAVE_DPSP();
        
        return ;
        
} // ServiceReplyList

// this thread works on doing async sends
DWORD WINAPI AsyncSendThreadProc(LPVOID pvCast)
{
        HRESULT hr=DP_OK;
        LPGLOBALDATA pgd = (LPGLOBALDATA) pvCast;
        HANDLE hHandleList[3];
        DWORD rc;
        WSAEVENT hSelectEvent; // event used by WSASelectEvent

        DPF(9,"Entered AsyncSendThreadProc\n");


        // get the event 4 selectevent
        hSelectEvent = g_WSACreateEvent();

        if (WSA_INVALID_EVENT == hSelectEvent)
        {
                rc = WSAGetLastError();
                DPF(0,"could not create winsock event - rc = %d\n",rc);
                ExitThread(0);
                return 0;
        }
        
        hHandleList[0] = hSelectEvent;
        hHandleList[1] = pgd->hReplyEvent;
        // This extra handle is here because of a Windows 95 bug.  Windows
        // will occasionally miss when it walks the handle table, causing
        // my thread to wait on the wrong handles.  By putting a guaranteed
        // invalid handle at the end of our array, the kernel will do a
        // forced re-walk of the handle table and find the correct handles.
        hHandleList[2] = INVALID_HANDLE_VALUE;

        while (1)
        {
                // tell winsock to watch all of our reply nodes.  it will set our event
                // when something cool happens...
                DoEventSelect(pgd,hSelectEvent);

                // wait on our event.  when it's set, we either split, or empty the reply list
                rc = WaitForMultipleObjectsEx(2,hHandleList,FALSE,INFINITE,TRUE);
                if ((DWORD)-1 == rc)
                {
                        DWORD dwError = GetLastError();
                        // rut roh!  errror on the wait
                        DPF(0,"!!!!!    error on WaitForMultipleObjects -- async reply bailing -- dwError = %d",dwError);
                        goto CLEANUP_EXIT;                      
                        
                }
                
                if (rc == WAIT_OBJECT_0)        // a-josbor: need to reset this manual event
                {
                        ResetEvent(hSelectEvent);
                }
                
                // ok.  someone woke us up.  it could be 1. shutdown,  or 2. one
                // of our sockets needs attention (i.e. a connect completed), or 3. someone
                // put a new reply node on the list
                
                // shutdown?            
                if (pgd->bShutdown)
                {
                        goto CLEANUP_EXIT;
                }
                
                DPF(8,"In AsyncSendThreadProc, servicing event %d\n", rc - WAIT_OBJECT_0);

                // otherwise, it must be a socket in need or a new replynode
                ServiceReplyList(pgd,hSelectEvent);
        } // 1

CLEANUP_EXIT:
        
        ENTER_DPSP();

        // cleanout reply list
        while (pgd->pReplyList) DeleteReplyNode(pgd,pgd->pReplyList,TRUE);
        
        CloseHandle(pgd->hReplyEvent);
        pgd->hReplyEvent = 0;

        LEAVE_DPSP();

        g_WSACloseEvent(hSelectEvent);
        
        DPF(6,"replythreadproc exit");
        
        return 0;

} // AsyncSendThreadProc


HRESULT GetMaxUdpBufferSize(SOCKET socket, UINT * piMaxUdpDg)
{
        INT iBufferSize;
        INT err;

        ASSERT(piMaxUdpDg);

        iBufferSize = sizeof(UINT);
        err = g_getsockopt(socket, SOL_SOCKET, SO_MAX_MSG_SIZE, (LPBYTE)piMaxUdpDg, &iBufferSize);
        if (SOCKET_ERROR == err)
        {
                DPF(0,"getsockopt for SO_MAX_MSG_SIZE returned err = %d", WSAGetLastError());
                return DPERR_UNAVAILABLE;
        }

        return DP_OK;
}

int
Dplay_GetAddrInfo(const char FAR * nodename, const char FAR * servname, LPADDRINFO hints, ADDRINFO FAR * FAR * res)
{
    return g_getaddrinfo(nodename, servname, hints, res);
}

void
Dplay_FreeAddrInfo(LPADDRINFO ai)
{
    g_freeaddrinfo(ai);
}

#ifdef SENDEX

DWORD wsaoDecRef(LPSENDINFO pSendInfo)
{
        #define pgd (pSendInfo->pgd)
        
        DWORD count;
#ifdef DEBUG
                EnterCriticalSection(&pgd->csSendEx);
                count=(--pSendInfo->RefCount);
                LeaveCriticalSection(&pgd->csSendEx);
#else
        count=InterlockedDecrement(&pSendInfo->RefCount);
#endif

        if(!count){
        
                EnterCriticalSection(&pgd->csSendEx);
                
                        Delete(&pSendInfo->PendingSendQ);
                        pgd->dwBytesPending -= pSendInfo->dwMessageSize;
                        pgd->dwMessagesPending -= 1;
                
                LeaveCriticalSection(&pgd->csSendEx);

                DPF(9,"RefCount 0 pSendInfo %x , SC context %x, status=%x \n",pSendInfo, pSendInfo->dwUserContext,pSendInfo->Status);

                if(pSendInfo->dwSendFlags & DPSEND_ASYNC){
                        pSendInfo->lpISP->lpVtbl->SendComplete(pSendInfo->lpISP,(LPVOID)pSendInfo->dwUserContext,pSendInfo->Status);
                }       
                
                pgd->pSendInfoPool->Release(pgd->pSendInfoPool, pSendInfo);
        } else {
                DPF(9,"wsaoDecRef pSendInfo %x, Refcount= %d\n",pSendInfo,pSendInfo->RefCount);
        }

        if(count& 0x80000000){
                DEBUG_BREAK();
        }
        
        return count;
        
        #undef pgd
}


void CALLBACK SendComplete(
  DWORD dwError,
  DWORD cbTransferred,
  LPWSAOVERLAPPED lpOverlapped,
  DWORD dwFlags
)
{
        LPSENDINFO lpSendInfo=(LPSENDINFO)CONTAINING_RECORD(lpOverlapped,SENDINFO,wsao);

        DPF(9,"DPWSOCK:SendComplete, lpSendInfo %x\n",lpSendInfo);

        if(dwError){
                DPF(0,"DPWSOCK: send completion error, dwError=x%x\n",dwError);
                lpSendInfo->Status=DPERR_GENERIC;
        }

        wsaoDecRef(lpSendInfo);
}

HRESULT DoSend(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
        #define fAsync (pSendInfo->dwSendFlags & DPSEND_ASYNC)
        
        DWORD dwBytesSent;
        UINT err;
        HRESULT hr;
        
        if(pSendInfo->dwFlags & SI_RELIABLE){
        
                // Reliable Send
                DPF(9,"WSASend, pSendInfo %x\n",pSendInfo);

                // send the message
                err = g_WSASend(pSendInfo->sSocket,
                                          (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
                                          pSendInfo->cBuffers,
                                          &dwBytesSent,
                                          0,                            /*flags*/
                                          (fAsync)?(&pSendInfo->wsao):NULL,
                                          (fAsync)?(SendComplete):NULL);

                if(!err){
                                DPF(9,"WSASend, sent synchronously, pSendInfo %x\n",pSendInfo);
                                wsaoDecRef(pSendInfo);
                                hr=DP_OK;
                } else {

                        if (SOCKET_ERROR == err)
                        {
                        
                                err = WSAGetLastError();

                                if(err==WSA_IO_PENDING){
                                        hr=DPERR_PENDING;
                                        wsaoDecRef(pSendInfo);
                                        DPF(9,"ASYNC SEND Pending pSendInfo %x\n",pSendInfo);
                                } else {
                                        if(err==WSAECONNRESET){
                                                hr=DPERR_CONNECTIONLOST;
                                        } else {
                                                hr=DPERR_GENERIC;
                                        }       
                                        if(fAsync){
                                                // Got an error, need to dump 2 refs.
                                                pSendInfo->RefCount=1;
                                                pSendInfo->Status=hr;
                                        }       
                                        wsaoDecRef(pSendInfo);
                                        // we got a socket from the bag.  send failed,
                                        // so we're cruising it from the bag
                                        DPF(0,"send error - err = %d\n",err);
                                                DPF(4,"send failed - removing socket from bag");
                                                RemovePlayerFromSocketBag(pgd,pSendInfo->idTo);
                                }       
                        
                        }
                }       
        
        } else {
        
                // Datagram Send
                DEBUGPRINTADDR(5,"unreliable send - sending to ",&pSendInfo->sockaddr); 
                // send the message
                err = g_WSASendTo(pSendInfo->sSocket,
                                                  (LPWSABUF)&pSendInfo->SendArray[pSendInfo->iFirstBuf],
                                                  pSendInfo->cBuffers,
                                                  &dwBytesSent,
                                                  0,                            /*flags*/
                                                  (LPSOCKADDR)&pSendInfo->sockaddr,
                                              sizeof(SOCKADDR),
                                                  (fAsync)?(&pSendInfo->wsao):NULL,
                                                  (fAsync)?(SendComplete):NULL);


                if(!err){
                        hr=DP_OK;
                        wsaoDecRef(pSendInfo);
                } else {
                    if (SOCKET_ERROR == err)
                    {
                        err = WSAGetLastError();
                
                        if(err==WSA_IO_PENDING){
                                hr=DPERR_PENDING;
                                        wsaoDecRef(pSendInfo);
                                } else {
                                        hr=DPERR_GENERIC;
                                        if(fAsync){
                                                // some error, force completion.
                                                pSendInfo->RefCount=1;
                                                pSendInfo->Status=DPERR_GENERIC;
                                        }       
                                        wsaoDecRef(pSendInfo);
                                DPF(0,"send error - err = %d\n",err);
                        }
                    } else {
                        DEBUG_BREAK();// SHOULD NEVER HAPPEN
                    }

                }
                
        }
        return hr;
        
        #undef fAsync
}

// Alert thread provides a thread for send completions to run on.

DWORD WINAPI SPSendThread(LPVOID lpv)
{
        LPGLOBALDATA pgd=(LPGLOBALDATA) lpv;
        LPSENDINFO  pSendInfo;

        DWORD rcWait=WAIT_IO_COMPLETION;
        BILINK *pBilink;
        BOOL bSent;

        pgd->BogusHandle=INVALID_HANDLE_VALUE;  // workaround win95 wait for multiple bug.
        
        while(!pgd->bStopSendThread){
                rcWait=g_WSAWaitForMultipleEvents(1,&pgd->hSendWait,FALSE,INFINITE,TRUE);
                #ifdef DEBUG
                if(rcWait==WAIT_IO_COMPLETION){
                        DPF(9,"ooooh, IO completion\n");
                }
                #endif

                do {
                        bSent = FALSE;
                
                        EnterCriticalSection(&pgd->csSendEx);

                        pBilink=pgd->ReadyToSendQ.next;

                        if(pBilink != &pgd->ReadyToSendQ){
                                Delete(pBilink);
                                LeaveCriticalSection(&pgd->csSendEx);
                                pSendInfo=CONTAINING_RECORD(pBilink, SENDINFO, ReadyToSendQ);
                                DoSend(pgd, pSendInfo);
                                bSent=TRUE;
                        } else {
                                LeaveCriticalSection(&pgd->csSendEx);
                        }       
                } while (bSent);
        }       

        pgd->bSendThreadRunning=FALSE;
        
        return FALSE;
        
        #undef hWait
}




void QueueForSend(LPGLOBALDATA pgd,LPSENDINFO pSendInfo)
{
        EnterCriticalSection(&pgd->csSendEx);
                InsertBefore(&pSendInfo->ReadyToSendQ,&pgd->ReadyToSendQ);
        LeaveCriticalSection(&pgd->csSendEx);
        
        SetEvent(pgd->hSendWait);
}

// some common code for InternalReliableSendEx and UnreliableSendEx
VOID CommonInitForSend(LPGLOBALDATA pgd,LPDPSP_SENDEXDATA psd,LPSENDINFO pSendInfo)
{

        pSendInfo->dwMessageSize= psd->dwMessageSize;
        pSendInfo->dwUserContext= (DWORD_PTR)psd->lpDPContext;
        pSendInfo->RefCount     = 2;            // one for completion, 1 for this routine
        pSendInfo->pgd          = pgd;
        pSendInfo->lpISP        = psd->lpISP;
        pSendInfo->Status       = DP_OK;
        pSendInfo->idTo         = psd->idPlayerTo;
        pSendInfo->idFrom       = psd->idPlayerFrom;
        pSendInfo->dwSendFlags  = psd->dwFlags;
        
        if(psd->lpdwSPMsgID){
                *psd->lpdwSPMsgID=0;
        }       

        EnterCriticalSection(&pgd->csSendEx);
        
                InsertBefore(&pSendInfo->PendingSendQ,&pgd->PendingSendQ);
                pgd->dwBytesPending += psd->dwMessageSize;
                pgd->dwMessagesPending += 1;
                
        LeaveCriticalSection(&pgd->csSendEx);
}

VOID UnpendSendInfo(LPGLOBALDATA pgd, LPSENDINFO pSendInfo)
{
        EnterCriticalSection(&pgd->csSendEx);
        Delete(&pSendInfo->PendingSendQ);
        pgd->dwBytesPending -= pSendInfo->dwMessageSize;
        pgd->dwMessagesPending -= 1;
        LeaveCriticalSection(&pgd->csSendEx);
}

HRESULT InternalReliableSendEx(LPGLOBALDATA pgd, LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo, SOCKADDR_IN6 *lpSockAddr)
{
        HRESULT hr;
        SOCKET sSocket = INVALID_SOCKET;
        BOOL fCreate=FALSE;

        // see if we have a connection already
        hr = GetSocketFromBag(pgd,&sSocket,psd->idPlayerTo,lpSockAddr);

        if(hr != DP_OK){
                hr=DPERR_GENERIC;
                return hr;
        }
        
        CommonInitForSend(pgd,psd,pSendInfo); // puts 2 refs on send.
        pSendInfo->dwFlags      = SI_RELIABLE;
        pSendInfo->sSocket      = sSocket;
        pSendInfo->iFirstBuf    = 0;
        pSendInfo->cBuffers     = psd->cBuffers+1;

        if(psd->dwFlags & DPSEND_ASYNC){
                QueueForSend(pgd,pSendInfo);
                hr=DPERR_PENDING;
        } else {
                hr=DoSend(pgd,pSendInfo);
                if(hr==DP_OK || hr==DPERR_PENDING){
                        wsaoDecRef(pSendInfo);
                } else {
                        // error,
                        UnpendSendInfo(pgd, pSendInfo);
                }
        }

        return hr;
}

HRESULT UnreliableSendEx(LPDPSP_SENDEXDATA psd, LPSENDINFO pSendInfo)
{
    SOCKADDR_IN6 sockaddr;
    INT iAddrLen = sizeof(sockaddr);
    HRESULT hr=DP_OK;
    UINT err;
        DWORD dwSize = sizeof(SPPLAYERDATA);
        LPSPPLAYERDATA ppdTo;
        DWORD dwDataSize = sizeof(GLOBALDATA);
        LPGLOBALDATA pgd;

        BOOL bSendHeader;
        
        // get the global data
        hr =psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
        if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
        {
                DPF_ERR("couldn't get SP data from DirectPlay - failing");
                return E_FAIL;
        }

        if (pgd->iMaxUdpDg && (psd->dwMessageSize >= pgd->iMaxUdpDg))
        {
                return DPERR_SENDTOOBIG;
        }

        if (INVALID_SOCKET == pgd->sUnreliableSocket)
        {
            hr = CreateSocket(pgd,&(pgd->sUnreliableSocket),SOCK_DGRAM,0,&sockaddr_any,&err,FALSE);
            if (FAILED(hr))
            {
                DPF(0,"create unreliable send socket failed - err = %d\n",err);
                return hr;
            }
        }

        // get to address       
    if (0 == psd->idPlayerTo)
    {
                sockaddr = pgd->saddrNS;
    }
    else
    {
                hr = psd->lpISP->lpVtbl->GetSPPlayerData(psd->lpISP,psd->idPlayerTo,&ppdTo,&dwSize,DPGET_REMOTE);
                if (FAILED(hr))
                {
                        ASSERT(FALSE);
                        return hr;
                }

        sockaddr = *(DGRAM_PSOCKADDR(ppdTo));
    }

        // put the token + size on front of the mesage
        SetMessageHeader((LPVOID)(pSendInfo->SendArray[0].buf),psd->dwMessageSize+sizeof(MESSAGEHEADER),TOKEN);
        bSendHeader=TRUE;
        
        if (psd->bSystemMessage)
    {
                SetReturnAddress(pSendInfo->SendArray[0].buf,SERVICE_SOCKET(pgd));
    } // reply
        else
        {
                // see if we can send this message w/ no header
                // if the message is smaller than a dword, or, if it's a valid sp header (fooling us
                // on the other end, don't send any header
                if ( !((psd->dwMessageSize >= sizeof(DWORD)) &&  !(VALID_SP_MESSAGE(pSendInfo->SendArray[0].buf))) )
                {
                        bSendHeader=FALSE;
                }
        }

    CommonInitForSend(pgd,psd,pSendInfo);
        pSendInfo->dwFlags      = SI_DATAGRAM;
        pSendInfo->sSocket      = pgd->sUnreliableSocket;
        pSendInfo->sockaddr     = sockaddr;

        if(bSendHeader){
                pSendInfo->iFirstBuf=0;
                pSendInfo->cBuffers =psd->cBuffers+1;
        } else {
                pSendInfo->iFirstBuf=1;
                pSendInfo->cBuffers=psd->cBuffers;
        }

        if(psd->dwFlags & DPSEND_ASYNC){
                QueueForSend(pgd,pSendInfo);
                hr=DPERR_PENDING;
        } else {
                hr=DoSend(pgd,pSendInfo);
                if(hr==DP_OK || hr==DPERR_PENDING){
                        wsaoDecRef(pSendInfo);
                } else {
                        UnpendSendInfo(pgd, pSendInfo);
                }
        }
        
        return hr;

} // UnreliableSendEx

#endif //SendEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\dphelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.h
 *  Content:	header for dphelp.c
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-jul-96	andyco	initial implementation
 *   25-jul-96	andyco	added watchnewpid
 *	 23-jan-97	kipo	prototypes for winsock calls
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/

#ifndef __DPHELP_INCLUDED__
#define __DPHELP_INCLUDED__

#include "windows.h"
#include "dplaysvr.h"
#include "newdpf.h"
//#include "winsock2.h"
// we include dpsp.h since we'll be poking bits (sockaddr's)
// into dpsp's header
#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 	60

typedef struct _SPNODE * LPSPNODE;

typedef struct _SPNODE
{
	SOCKADDR_IN6 sockaddr;  // socket addr of server
	DWORD pid;
	LPSPNODE  pNextNode;
} SPNODE;

// protos

// from dphelp.c
extern HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd);
extern BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL fFreeAll);
extern HRESULT DPlayHelp_Init();
extern void DPlayHelp_FreeServerList();
extern DWORD WINAPI StreamAcceptThreadProc(LPVOID pvCast);
extern DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast);
extern void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN6 * psockaddr);

// from help.c
extern void WatchNewPid(LPDPHELPDATA phd);

// from reliable.c
void RemoveSocketFromList(SOCKET socket);


//prototypes for winsock calls
typedef int (PASCAL FAR * cb_accept)(SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen);
extern cb_accept	g_accept;

typedef int (PASCAL FAR * cb_bind)(SOCKET s, const struct sockaddr FAR *addr, int namelen);
extern	cb_bind	g_bind;

typedef int (PASCAL FAR * cb_closesocket)(SOCKET s);
extern	cb_closesocket	g_closesocket;

typedef struct hostent FAR * (PASCAL FAR * cb_gethostbyname)(const char FAR * name);
extern	cb_gethostbyname	g_gethostbyname;

typedef int (PASCAL FAR * cb_gethostname)(char FAR * name, int namelen);
extern	cb_gethostname	g_gethostname;

typedef int (PASCAL FAR * cb_getpeername)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getpeername	g_getpeername;

typedef int (PASCAL FAR * cb_getsockname)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getsockname	g_getsockname;

typedef u_short (PASCAL FAR * cb_htons)(u_short hostshort);
extern	cb_htons		g_htons;

typedef int (PASCAL FAR * cb_listen)(
    SOCKET s,
    int backlog
    );
extern cb_listen		g_listen;

typedef int (PASCAL FAR * cb_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );
extern cb_recv		g_recv;

typedef int (PASCAL FAR * cb_recvfrom)(SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);
extern	cb_recvfrom	g_recvfrom;

typedef SOCKET (PASCAL FAR * cb_select)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR * timeout
    );
extern cb_select	g_select;

typedef int (PASCAL FAR * cb_send)(SOCKET s, const char FAR * buf, int len, int flags);
extern	cb_send		g_send;

typedef int (PASCAL FAR * cb_sendto)(SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);
extern	cb_sendto	g_sendto;

typedef int (PASCAL FAR * cb_setsockopt)(SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);
extern	cb_setsockopt	g_setsockopt;

typedef int (PASCAL FAR * cb_shutdown)(SOCKET s, int how);
extern cb_shutdown	g_shutdown;

typedef SOCKET (PASCAL FAR * cb_socket)(int af, int type, int protocol);
extern	cb_socket	g_socket;

typedef int (PASCAL FAR * cb_WSAFDIsSet)(SOCKET, fd_set FAR *);
extern 	cb_WSAFDIsSet	g_WSAFDIsSet;

typedef int (PASCAL FAR * cb_WSAGetLastError)(void);
extern	cb_WSAGetLastError	g_WSAGetLastError;

typedef int (PASCAL FAR * cb_WSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
extern	cb_WSAStartup	g_WSAStartup;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\dplaysvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.c
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share
 *				a single winsock port
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/

#ifdef WINNT
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"

HANDLE 				hInstApp;
BOOL		   		bNoCallbacks;
CRITICAL_SECTION    gcsCritSection;	// the crit section we take in winmain
                                	// this is a global so dphelp can take it before
                                	// forwarding enum requests that come in on its
                                	// receive thread (manbugs 3907)
int					gnCSCount;		// dplaysvr lock count

/*
 * Externs
 */
extern RECEIVELIST 	gReceiveList;
extern FDS			gReadfds;


// we watch every dplay process so when it exits we
// make sure it cleaned up...
typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList; 	// list of all processes that are registered
									// with us

/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
DWORD WINAPI ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    PROCESSDATA		pd;
	DPHELPDATA		hd;
	
    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 2, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                            FALSE, ppd->pid );
    if( hproc == NULL )
    {
        DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
        ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
        DPF( 1, "Wait for process %08lx failed", ppd->pid );
        CloseHandle( hproc );
        ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    ENTER_DPLAYSVR();
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr == ppd )
        {
            if( prev == NULL )
            {
                lpProcessList = curr->link;
            }
            else
            {
                prev->link = curr->link;
            }
            DPF( 2, "PID %08lx removed from list", ppd->pid );
            MemFree( curr );
            break;
        }
        prev = curr;
        curr = curr->link;
    }

    if( bNoCallbacks )
    {
		DPF( 1, "No callbacks allowed: leaving thread early" );
		LEAVE_DPLAYSVR();
		CloseHandle( hproc );
		ExitThread( 0 );
    }


	// clean up!

	memset(&hd,0,sizeof(hd));
	hd.pid = pd.pid;
	DPlayHelp_DeleteServer(&hd,TRUE);
	
    LEAVE_DPLAYSVR();
    CloseHandle( hproc );

    ExitThread( 0 );
	
	return 0;

} /* ThreadProc */

/*
 * MainWndProc
 */
LONG_PTR __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
            if( lParam == FALSE )
            {
                DPF( 3, "WM_ENDSESSION" );
                ENTER_DPLAYSVR();
                DPF( 1, "Setting NO CALLBACKS" );
                bNoCallbacks = TRUE;
                LEAVE_DPLAYSVR();
            }
            else
            {
                DPF( 3, "User logging off" );
            }

            break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DPlayHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
        DPF( 1, "RegisterClass FAILED!" );
        ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
        DPF( 1, "No monitor window!" );
        ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    DPF( 1, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by by DPlayHelp_AddServer when we get a new process attached.
// we wait for the process to go away, and then make sure it cleaned
// all its registered servers up.
//
void WatchNewPid(LPDPHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    DWORD		tid;

    DPF( 1, "watching new pid" );

    ENTER_DPLAYSVR();
	
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
        if( ppd->pid == phd->pid )
        {
            DPF( 2, "Have thread for process %08lx already", phd->pid );
			found = TRUE;
            break;
        }
        ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
        DPF( 2, "Allocating new thread for process %08lx",phd->pid );
        ppd = MemAlloc( sizeof( PROCESSDATA ) );
        if( ppd != NULL )
        {
            HANDLE	h;

            ppd->link = lpProcessList;
            lpProcessList = ppd;
            ppd->pid = phd->pid;
            h = CreateThread(NULL,
                         0,
                         (LPTHREAD_START_ROUTINE) ThreadProc,
                         (LPVOID)ppd,
                         0,
                         (LPDWORD)&tid);
            if( h != NULL )
            {
                DPF( 2, "Thread %08lx created",tid);
                CloseHandle( h );
            }
            else
            {
                #ifdef DEBUG
                    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
                    DebugBreak(); //_asm int 3;
                #endif
            }
        }
        else
        {
            #ifdef DEBUG
                DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
                DebugBreak(); //_asm int 3;
            #endif
        }
    }
    LEAVE_DPLAYSVR();
	
} // WatchNewPid

typedef DWORD (WINAPI *PFNREGISTERSERVICE)(DWORD,DWORD);
// nt's winbase.h doesn't have these constants - we need them
// so we can compile.  taken from \proj\dev\inc\winbase.h
#ifndef RSP_UNREGISTER_SERVICE
#define RSP_UNREGISTER_SERVICE  0x00000000
#endif
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

// on Win95, we want to call RegisterServiceProcess
// but, it's not available on NT, so we can't import it directly
// here we try to find it dynamically in kernel32.  if we find it,
// we call it, otherwise we assume we're on NT and it's not avaible
void MakeMeService()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not register service process - expected on NT");
		FreeLibrary(hLib);
		return ;
	}
	
    pfnRegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
	FreeLibrary(hLib);
	
	return ;
} // MakeMeService	

// on Win95, we want to call RegisterServiceProcess to Unregister
// (see MakeMeService)
void StopServiceProcess()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not unregister service process - not avail - not tragic");
		FreeLibrary(hLib);
		return ;
	}
	
	// unregistered!
    pfnRegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
	FreeLibrary(hLib);
	
	return ;

} // StopServiceProcess

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                        LPSTR lpCmdLine, int nCmdShow)
{
    DWORD		tid;
    DWORD		rc;
    HANDLE		hstartevent;
    HANDLE		hstartupevent;
    HANDLE		hmutex;
    HANDLE		hackevent;
    LPDPHELPDATA	phd;
    HANDLE		hsharedmem;
    HANDLE		h;
    char		szSystemDir[1024];

    /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);

	// try to register ourselves as a service so user can't see us
	// in task list
	MakeMeService();

#if 0	

// andyco - not sure if we need this...

    /*
     * We must guarantee that DPHELP unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and DPHELP needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"dplaysvr could not set itself to shutdown last!");
    }

#endif


    hInstApp = hInstance;

    /*
     * create startup event
     */
    hstartupevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );

    DPFINIT();
    DPF( 2, "*** dplaysvr STARTED, PID=%08lx ***", GetCurrentProcessId() );

    if( !MemInit() )
    {
        DPF( 1, "Could not init memory manager" );
        return 0;
    }

    /*
     * create shared memory area
     */
    hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
            DPHELP_SHARED_NAME );
    if( hsharedmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
    hmutex = CreateMutex( NULL, FALSE, DPHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex " DPHELP_MUTEX_NAME );
        CloseHandle( hsharedmem );
        return 0;
    }

    /*
     * create events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        return 0;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_ACK_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE) WindowThreadProc,
                 NULL,
                 0,
                 (LPDWORD)&tid );
    if( h == NULL )
    {
        DPF( 1, "Create of WindowThreadProc FAILED!" );
        CloseHandle( hackevent );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    INIT_DPLAYSVR_CSECT();

    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {
        /*
         * wait to be notified of a request
         */
        DPF( 1, "Waiting for next request" );
        rc = WaitForSingleObject( hstartevent, INFINITE );
        if( rc == WAIT_FAILED )
        {
            DPF( 1, "Wait FAILED!!!" );
            continue;
        }

        ENTER_DPLAYSVR();
        phd = (LPDPHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if( phd == NULL )
        {
            DPF( 1, "Could not create view of file!" );
            LEAVE_DPLAYSVR();
            continue;
        }

        /*
         * find out what we need to do
         */
        switch( phd->req )
        {
        case DPHELPREQ_SUICIDE:
            DPF( 1, "DPHELPREQ_SUICIDE" );

			DPlayHelp_FreeServerList();
			
            SetEvent( hackevent );
            CloseHandle( hmutex );
            UnmapViewOfFile( phd );
            CloseHandle( hsharedmem );
            CloseHandle( hstartevent );
            if (gReceiveList.pConnection)
            {
            	MemFree(gReceiveList.pConnection);
            }
            if (gReadfds.pfdbigset)
            {
            	MemFree(gReadfds.pfdbigset);
            }
            FINI_DPLAYSVR_CSECT();

            #ifdef DEBUG
            	MemState();
            #endif
            DPF( 3, "Good Night Gracie" );
            TerminateProcess( GetCurrentProcess(), 0 );
            break;

		case DPHELPREQ_RETURNHELPERPID:

		    DPF( 2, "DDHELPREQ_RETURNHELPERPID" );
		    phd->pid = GetCurrentProcessId();
	    	break;
			

        case DPHELPREQ_DPLAYADDSERVER:

		    DPF( 2, "DPHELPREQ_DPLAYADDSERVER" );
            phd->hr = DPlayHelp_AddServer(phd);
            break;

        case DPHELPREQ_DPLAYDELETESERVER:

		    DPF( 2, "DPHELPREQ_DPLAYDELETESERVER" );
            DPlayHelp_DeleteServer(phd,FALSE);
            break;

        default:
            DPF( 1, "helper - Unknown Request???" );
            break;
        }

        /*
         * let caller know we've got the news
         */
        UnmapViewOfFile( phd );
        SetEvent( hackevent );
        LEAVE_DPLAYSVR();
    }
	
	StopServiceProcess();

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLAYSVR"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplayip6\winsock.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winsock.c
 *  Content:    windows socket support for dpsp
 *  History:
 *  Date        By        Reason
 *  ====        ==        ======
 *    3/15/96        andyco    created it
 *    4/12/96        andyco    got rid of dpmess.h! use DPlay_ instead of message macros
 *    4/18/96        andyco    added multihomed support, started ipx
 *    4/25/96        andyco    messages now have blobs (sockaddr's) instead of dwReserveds  
 *    5/31/96        andyco    all non-system players share a socket (gsStream and 
 *                        gsDGramSocket).
 *    7/18/96        andyco    added dphelp for server socket
 *    8/1/96        andyco    no retry on connect failure
 *    8/15/96        andyco    local + remote data    - killthread
 *    8/30/96        andyco    clean it up b4 you shut it down! added globaldata.
 *    9/4/96        andyco    took out bye_bye message
 *    12/18/96    andyco    de-threading - use a fixed # of prealloced threads.
 *                        cruised the enum socket / thread - use the system
 *                        socket / thread instead
 *    3/17/97        kipo    rewrote server dialog code to not use global variable
 *                        to return the address and to return any errors getting
 *                        the address, especially DPERR_USERCANCEL
 *    5/12/97        kipo    the server address string is now stored in the globals
 *                        at SPInit and resolved when you do EnumSessions so we
 *                        will return any errors at that time instead of popping
 *                        the dialog again. Fixes bug #5866
 *    11/19/97    myronth    Changed LB_SETCURSEL to CB_SETCURSEL (#12711)
 *    01/27/98    sohaim    added firewall support.
 *  02/13/98    aarono  added async support.
 *   2/18/98   a-peterz Comment byte order for address and port params (CreateSocket)
 *   6/19/98    aarono  turned on keepalive on reliable sockets.  If we
 *                      don't do this we can hang if the send target crashes
 *                      while in a low buffer (i.e. no buffer) state.
 *    7/9/99    aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 ***************************************************************************/

#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 60

// how long to wait, in ms, til we abort a blocking WinSock connect() call
#define CONNECT_WATCHER_TIMEOUT        15000

/*
 ** CreateSocket
 *
 *  CALLED BY: all over
 *
 *  PARAMETERS:
 *        pgd - pointer to a global data
 *        psock - new socket. return value.
 *        type - stream or datagram
 *        port - what port we bind to (host byte order)
 *        address - what address to use (net byte order)
 *        *perr - set to the last socket error if fn fails
 *        bInRange - use reserved range of ports
 *
 *  DESCRIPTION:
 *        creates a new socket.  binds to port specified, at the address specified
 *
 *  RETURNS: DP_OK or E_FAIL. if E_FAIL, *perr is set with socket error code (see winsock.h)
 *
 */

HRESULT FAR PASCAL CreateSocket(LPGLOBALDATA pgd,SOCKET * psock,INT type,WORD wApplicationPort,const SOCKADDR_IN6 * psockaddr, 
    SOCKERR * perr,BOOL bInRange)
{
    SOCKET  sNew;
    SOCKADDR_IN6 sockAddr;
    int bTrue = TRUE;
    int protocol = 0;
    BOOL bBroadcast = FALSE;
    WORD wPort;
    BOOL bBound = FALSE;

    *psock = INVALID_SOCKET; // in case we bail

    //  Create the socket.

    sNew = socket( pgd->AddressFamily, type, protocol);
       
    if (INVALID_SOCKET == sNew) 
    {
        // no cleanup needed, just bail
        *perr = WSAGetLastError();
        return E_FAIL;
    }

    //  try to bind an address to the socket.
    // set up the sockaddr
    memset(&sockAddr,0,sizeof(sockAddr));
    if ((SOCK_STREAM == type))
    {
        BOOL bTrue = TRUE;
        UINT err;
        
        // turn ON keepalive
        if (SOCKET_ERROR == setsockopt(sNew, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
        {
            err = WSAGetLastError();
            DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
        }

        ASSERT(bTrue);
        
        // turn off nagling
        if(pgd->dwSessionFlags & DPSESSION_OPTIMIZELATENCY) 
        {

            DPF(5, "Turning nagling off on socket");
            if (SOCKET_ERROR == setsockopt(sNew, IPPROTO_TCP, TCP_NODELAY, (CHAR FAR *)&bTrue, sizeof(bTrue)))
            {
                err = WSAGetLastError();
                DPF(0,"Failed to turn off naggling - continue : err = %d\n",err);
            }
        }
    }

    sockAddr = *psockaddr;
    sockAddr.sin6_port = htons(wApplicationPort);
    if (bInRange && !wApplicationPort)
    {
        USHORT rndoffset;
        DPF(5, "Application didn't specify a port - using dplay range");

        rndoffset=(USHORT)(GetTickCount()%DPSP_NUM_PORTS);
        wPort = DPSP_MIN_PORT+rndoffset;
        do 
        {
            DPF(5, "Trying to bind to port %d",wPort);
            sockAddr.sin6_port = htons(wPort);
            
            // do the bind
            if( SOCKET_ERROR != bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr) ) )
            {
                bBound = TRUE;
                DPF(5, "Successfully bound to port %d", wPort);                    
            }
            else
            {
                if(++wPort > DPSP_MAX_PORT){
                    wPort=DPSP_MIN_PORT;
                }
            }    
        }
        while (!bBound && (wPort != DPSP_MIN_PORT+rndoffset));
    }

    // do the bind
    if( !bBound && (SOCKET_ERROR == bind( sNew, (LPSOCKADDR)&sockAddr, sizeof(sockAddr))) )
    {
        goto ERROR_EXIT;
    }
    
    // success!
    *psock = sNew;

    DEBUGPRINTSOCK(9,"created a new socket (bound) - ",psock);

    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    *perr = WSAGetLastError();
    DPF(0,"create socket failed- err = %d\n",*perr);
    closesocket(sNew);
    return E_FAIL;

}   // CreateSocket

#undef DPF_MODNAME
#define DPF_MODNAME    "KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
    UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
        return E_FAIL;
    }

    if (!fStream)
    {
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
            err = WSAGetLastError();
            DPF(0,"killsocket - dgram close err = %d\n",err);
            return E_FAIL;
        }
    }
    else 
    {
        LINGER Linger;

           if (fHard)
        {
            Linger.l_onoff=TRUE; // turn linger on
            Linger.l_linger=0; // nice small time out

            if( SOCKET_ERROR == setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
                            sizeof(Linger) ) )
            {
                err = WSAGetLastError();
                DPF(0,"killsocket - stream setopt err = %d\n",err);
            }
        }            
        if (SOCKET_ERROR == shutdown(sSocket,2)) 
        {
            // this may well fail, if e.g. no one is using this socket right now...
            // the error would be wsaenotconn 
            err = WSAGetLastError();
            DPF(5,"killsocket - stream shutdown err = %d\n",err);
        }
        if (SOCKET_ERROR == closesocket(sSocket)) 
        {
            err = WSAGetLastError();
            DPF(0,"killsocket - stream close err = %d\n",err);
            return E_FAIL;
        }
    }

    return DP_OK;
    
}// KillSocket

#undef DPF_MODNAME
#define DPF_MODNAME    "CreateAndInitStreamSocket"

// set up a stream socket to receive connections
// used w/ the gGlobalData.sStreamAcceptSocket
HRESULT CreateAndInitStreamSocket(LPGLOBALDATA pgd)
{
    HRESULT hr;
    UINT err;
    LINGER Linger;

    hr = CreateSocket(pgd,&(pgd->sSystemStreamSocket),SOCK_STREAM,pgd->wApplicationPort,&sockaddr_any,&err,TRUE);
    if (FAILED(hr)) 
    {
        DPF(0,"init listen socket failed - err = %d\n",err);
        return hr ;
    }

    // set up socket w/ max listening connections
    err = listen(pgd->sSystemStreamSocket,LISTEN_BACKLOG);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"init listen socket / listen error - err = %d\n",err);
        return E_FAIL ;
    }

    // set for hard disconnect
    Linger.l_onoff=1;
    Linger.l_linger=0;
    
    if( SOCKET_ERROR == setsockopt( pgd->sSystemStreamSocket,SOL_SOCKET,SO_LINGER,
        (char FAR *)&Linger,sizeof(Linger) ) )
    {
        err = WSAGetLastError();
        DPF(0,"Delete service socket - stream setopt err = %d\n",err);
    }
    
    DEBUGPRINTSOCK(1,"enum - listening on",&(pgd->sSystemStreamSocket));
    return DP_OK;
    
} // CreateAndInitStreamSocket



#undef DPF_MODNAME
#define DPF_MODNAME    "SPConnect"
// connect socket to sockaddr
HRESULT SPConnect(SOCKET* psSocket, LPSOCKADDR psockaddr,UINT addrlen, BOOL bOutBoundOnly)
{
    UINT err;
    HRESULT hr = DP_OK;
    DWORD dwLastError;
    u_long lNonBlock = 1; // passed to ioctlsocket to make socket non-blocking
    u_long lBlock = 0; // passed to ioctlsocket to make socket blocking again
    fd_set fd_setConnect;
    fd_set fd_setExcept;
    TIMEVAL timevalConnect;

    err=ioctlsocket(*psSocket, FIONBIO, &lNonBlock);    // make socket non-blocking
    if(SOCKET_ERROR == err){
        dwLastError=WSAGetLastError();
        DPF(0,"sp - failed to set socket %d to non-blocking mode err= %d\n", *psSocket, dwLastError);
        return DPERR_CONNECTIONLOST;
    }

    // Start the socket connecting.
    err = connect(*psSocket,psockaddr,addrlen);
    
    if(SOCKET_ERROR == err) {
        dwLastError=WSAGetLastError();
        if(dwLastError != WSAEWOULDBLOCK){
            DPF(0,"sp - connect failed err= %d\n", dwLastError);
            return DPERR_CONNECTIONLOST;
        }
        // we are going to wait for either the connect to succeed (socket to be writeable)
        // or the connect to fail (except fdset bit to be set).  So we init an FDSET with
        // the socket that is connecting and wait.
        FD_ZERO(&fd_setConnect);
        FD_SET(*psSocket, &fd_setConnect);

        FD_ZERO(&fd_setExcept);
        FD_SET(*psSocket, &fd_setExcept);

        timevalConnect.tv_sec=0;
        timevalConnect.tv_usec=CONNECT_WATCHER_TIMEOUT*1000; //msec -> usec
        
        err = select(0, NULL, &fd_setConnect, &fd_setExcept, &timevalConnect);

        // err is the number of sockets with activity or 0 for timeout 
        // or SOCKET_ERROR for error
        
        if(SOCKET_ERROR == err) {
            dwLastError=WSAGetLastError();
            DPF(0,"sp - connect failed err= %d\n", dwLastError);
            return DPERR_CONNECTIONLOST;
        } else if (0==err){
            // timed out
            DPF(0,"Connect timed out on socket %d\n",*psSocket);
            return DPERR_CONNECTIONLOST;
        }

        // Now see if the connect succeeded or the connect got an exception
        if(!(FD_ISSET(*psSocket, &fd_setConnect))){
            DPF(0,"Connect did not succeed on socket %d\n",*psSocket);
            return DPERR_CONNECTIONLOST;
        }
        if(FD_ISSET(*psSocket,&fd_setExcept)){
            DPF(0,"Got exception on socket %d during connect\n",*psSocket);
            return DPERR_CONNECTIONLOST;
        }
    }

    err=ioctlsocket(*psSocket, FIONBIO, &lBlock);    // make socket blocking again

    DEBUGPRINTSOCK(9,"successfully connected socket - ", psSocket);

    if (bOutBoundOnly)
    {
        DEBUGPRINTADDR(5, "Sending reuse connection message to - ",psockaddr);
        // tell receiver to reuse connection
        hr = SendReuseConnectionMessage(*psSocket);
    }

    return hr;

} //SPConnect
    

#undef DPF_MODNAME
#define DPF_MODNAME    "SetPlayerAddress"
// we've created a socket for a player. store its address in the players
// spplayerdata struct.  
HRESULT SetPlayerAddress(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,SOCKET sSocket,BOOL fStream) 
{
    SOCKADDR_IN6 sockaddr;
    UINT err;
    int iAddrLen = sizeof(sockaddr);

    err = getsockname(sSocket,(LPSOCKADDR)&sockaddr,&iAddrLen);
    if (SOCKET_ERROR == err) 
    {
        err = WSAGetLastError();
        DPF(0,"setplayeraddress - getsockname - err = %d\n",err);
        closesocket(sSocket);
        return E_FAIL;
    } 

    if (fStream) 
    {
        ZeroMemory(STREAM_PSOCKADDR(ppd), sizeof(SOCKADDR_IN6));
        STREAM_PSOCKADDR(ppd)->sin6_family = AF_INET6;
        IP_STREAM_PORT(ppd) = sockaddr.sin6_port;
        // we don't know the address of the local player (multihomed!)
    } // stream
    else 
    {
        ZeroMemory(DGRAM_PSOCKADDR(ppd), sizeof(SOCKADDR_IN6));
        DGRAM_PSOCKADDR(ppd)->sin6_family = AF_INET6;
        IP_DGRAM_PORT(ppd) = sockaddr.sin6_port;
        // we don't know the address of the local player (multihomed!)
    } // dgram

    return DP_OK;    
} // SetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME    "CreatePlayerSocket"

HRESULT CreatePlayerDgramSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags)
{
    HRESULT hr=DP_OK;
    UINT err;
    SOCKET sSocket;
    LPSOCKADDR_IN6 paddr;
    SOCKET_ADDRESS_LIST *pList;
    int i;
    
    if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
        if (INVALID_SOCKET == pgd->sSystemDGramSocket)
        {
            hr = CreateSocket(pgd,&sSocket,SOCK_DGRAM,pgd->wApplicationPort,&sockaddr_any,&err,TRUE);
            if (FAILED(hr)) 
            {
                DPF(0,"create sysplayer dgram socket failed - err = %d\n",err);
                return hr;
            }
                
            #ifdef DEBUG
            if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
            {
                DEBUGPRINTSOCK(2,"name server dgram socket - ",&sSocket);
            }
            #endif // DEBUG

            //
            // join link-local multicast group for enumeration on every link
            //
    
            // do a passive getaddrinfo
            pList = GetHostAddr();
            if (pList)
            {
                // for each linklocal address
                for (i=0; i<pList->iAddressCount; i++)
                {
                    paddr = (LPSOCKADDR_IN6)pList->Address[i].lpSockaddr;

                    // skip if not linklocal
                    if (!IN6_IS_ADDR_LINKLOCAL(&paddr->sin6_addr))
                    {
                        continue;
                    }

                    // join the multicast group on that ifindex
                    if (SOCKET_ERROR == JoinEnumGroup(sSocket, paddr->sin6_scope_id))
                    {
                        DPF(0,"join enum group failed - err = %d\n",WSAGetLastError());
                        closesocket(sSocket);
                        return hr;
                    }
                }
                FreeHostAddr(pList);
            }
            
            pgd->sSystemDGramSocket = sSocket;
        }
        else 
        {
            // store this for setting player address below
            sSocket = pgd->sSystemDGramSocket;    
        }
    }
    else 
    {
    
        ASSERT(INVALID_SOCKET != pgd->sSystemDGramSocket);
        sSocket = pgd->sSystemDGramSocket;    
    }

    // store the ip + port w/ the player...    
    hr = SetPlayerAddress(pgd,ppd,sSocket,FALSE);

    
    return hr; 
}  // CreatePlayerDgramSocket

HRESULT CreatePlayerStreamSocket(LPGLOBALDATA pgd,LPSPPLAYERDATA ppd,DWORD dwFlags) 
{
    SOCKET sSocket;
    HRESULT hr=DP_OK;
    UINT err;
    BOOL bListen = TRUE; // set if we created socket, + need to set it's listen
    
    if (dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
    {
        if (INVALID_SOCKET == pgd->sSystemStreamSocket)
        {
            hr = CreateSocket(pgd,&sSocket,SOCK_STREAM,pgd->wApplicationPort,&sockaddr_any,&err,TRUE);
            if (FAILED(hr)) 
            {
                DPF(0,"create player stream socket failed - err = %d\n",err);
                return hr;
            }
            
            #ifdef DEBUG
            if (dwFlags & DPLAYI_PLAYER_NAMESRVR) 
            {
                DEBUGPRINTSOCK(2,"name server stream socket - ",&sSocket);
            }
            #endif // DEBUG

            pgd->sSystemStreamSocket = sSocket;
        }
        else
        {
            sSocket = pgd->sSystemStreamSocket;    
            bListen = FALSE;
        }
            
    }
    else 
    {
        ASSERT (INVALID_SOCKET != pgd->sSystemStreamSocket);
        sSocket = pgd->sSystemStreamSocket;    
        bListen = FALSE;            
    }
    
    if (bListen)
    {
        // set up socket to receive connections
        err = listen(sSocket,LISTEN_BACKLOG);
        if (SOCKET_ERROR == err) 
        {
            err = WSAGetLastError();
            ASSERT(FALSE);
            DPF(0,"ACK! stream socket listen failed - err = %d\n",err);
            // keep trying
        }
    }
    
    hr = SetPlayerAddress(pgd,ppd,sSocket,TRUE);
    return hr;

} // CreatePlayerStreamSocket


#undef DPF_MODNAME
#define DPF_MODNAME    "PokeAddr"


// poke an ip addr into a message blob
void IP6_SetAddr(LPVOID pmsg,SOCKADDR_IN6 * paddrSrc)
{
    LPSOCKADDR_IN6  paddrDest; // tempo variable, makes casting less ugly
    LPMESSAGEHEADER phead;

    phead = (LPMESSAGEHEADER)pmsg;
    // todo - validate header

    // leave the port intact, copy over the ip addr
    paddrDest = (SOCKADDR_IN6 *)&(phead->sockaddr);
    // poke the new ip addr into the message header
    paddrDest->sin6_addr = paddrSrc->sin6_addr;

    return;
    
} // IP6_SetAddr

// get an ip addr from a message blob
void IP6_GetAddr(SOCKADDR_IN6 * paddrDest,SOCKADDR_IN6 * paddrSrc) 
{
    // leave the port intact, copy over the nodenum
    if (IN6_IS_ADDR_UNSPECIFIED(&paddrDest->sin6_addr))
    {
        DEBUGPRINTADDR(2,"remote player - setting address!! =  %s\n",paddrSrc);
        paddrDest->sin6_addr = paddrSrc->sin6_addr;
    }

    return;
        
} // IP_GetAddr

// store the port of the socket w/ the message, so the receiving end
// can reconstruct the address to reply to
HRESULT SetReturnAddress(LPVOID pmsg,SOCKET sSocket) 
{
    SOCKADDR_IN6 sockaddr;
    INT addrlen=sizeof(sockaddr);
    LPMESSAGEHEADER phead;
    UINT err;

    // find out what port gGlobalData.sEnumSocket is on
    err = getsockname(sSocket,(LPSOCKADDR)&sockaddr,&addrlen);
    if (SOCKET_ERROR == err)
    {
        err = WSAGetLastError();
        DPF(0,"could not get socket name - err = %d\n",err);
        return DP_OK;
    }

    DEBUGPRINTADDR(9,"setting return address = ",&sockaddr);

    phead = (LPMESSAGEHEADER)pmsg;
    // todo - validate header

    phead->sockaddr = sockaddr;

    return DP_OK;

} // SetReturnAddress

// code below all called by GetServerAddress. For IP, prompts user for ip address 
// for name server.
#undef DPF_MODNAME
#define DPF_MODNAME    "GetAddress"
// get the ip address from the pBuffer passed in by a user
// can either be a real ip, or a hostname
// called after the user fills out our dialog box
HRESULT GetAddress(SOCKADDR_IN6 * saAddress,char *pBuffer,int cch)
{
    UINT err;
    struct addrinfo *ai, hints;

    if ( (0 == cch)  || (!pBuffer) || (0 == strlen(pBuffer)) )
    {
        ZeroMemory(saAddress, sizeof(*saAddress));
        saAddress->sin6_family = AF_INET6;
        saAddress->sin6_addr = in6addr_multicast;
        return (DP_OK);
    } 

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET6;
    err = Dplay_GetAddrInfo(pBuffer, NULL, &hints, &ai);
    if (0 != err) {
        DPF(0,"could not get host address - err = %d\n",err);
        return (DPERR_INVALIDPARAM);
    }
    
    DEBUGPRINTADDR(1, "name server address = %s \n",ai->ai_addr);
    CopyMemory(saAddress, ai->ai_addr, sizeof(SOCKADDR_IN6));
    Dplay_FreeAddrInfo(ai);
    
    return (DP_OK);
} // GetAddress

// put up a dialog asking for a network address
// call get address to convert user specified address to network usable address
// called by GetServerAddress
INT_PTR CALLBACK DlgServer(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hWndCtl;
    char pBuffer[ADDR_BUFFER_SIZE];
    UINT cch;
    SOCKADDR_IN6 *lpsaEnumAddress;
    HRESULT hr;

    switch (msg)
    {
    case WM_INITDIALOG:
        // set focus on edit box
        hWndCtl = GetDlgItem(hDlg, IDC_EDIT1);
        if (hWndCtl == NULL)
        {
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        SetFocus(hWndCtl);
        SendMessage(hWndCtl, CB_SETCURSEL, 0, 0);

        // save pointer to enum address with the window
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG) lParam);
        return(FALSE);


    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            // get text entered in control
            cch = GetDlgItemText(hDlg, IDC_EDIT1, pBuffer, ADDR_BUFFER_SIZE);

            // get pointer to return address in
            lpsaEnumAddress = (SOCKADDR_IN6 *)GetWindowLongPtr(hDlg, DWLP_USER);

            // convert string to enum address
            hr = GetAddress(lpsaEnumAddress,pBuffer,cch);
            if (FAILED(hr))
                EndDialog(hDlg, hr);
            else
                EndDialog(hDlg, TRUE);
            return(TRUE);

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        break;
    }
    return (FALSE);
} // DlgServer

/*
 ** GetServerAddress
 *
 *  CALLED BY: EnumSessions
 *
 *  DESCRIPTION: launches the select network address dialog
 *
 *  RETURNS:  ip address (sockaddr.sin_addr.s_addr)
 *
 */
HRESULT ServerDialog(SOCKADDR_IN6 *lpsaEnumAddress)
{
    HWND hwnd;
    INT_PTR    iResult;
    HRESULT hr;
    
    // we have a valid enum address
    if (!IN6_IS_ADDR_UNSPECIFIED(&lpsaEnumAddress->sin6_addr))
        return (DP_OK);

    // use the fg window as our parent, since a ddraw app may be full screen
    // exclusive
    hwnd = GetForegroundWindow();

    iResult = DialogBoxParam(ghInstance, MAKEINTRESOURCE(IDD_SELECTSERVER), hwnd,
                             DlgServer, (LPARAM) lpsaEnumAddress);
    if (iResult == -1)
    {
        DPF_ERR("GetServerAddress - dialog failed");
        hr = DPERR_GENERIC;
    }
    else if (iResult < 0)
    {
        DPF(0, "GetServerAddress - dialog failed: %08X", iResult);
        hr = (HRESULT) iResult;
    }
    else if (iResult == 0)
    {
        hr = DPERR_USERCANCEL;
    }
    else
    {
        hr = DP_OK;
    }
        
    return (hr);
    
} //ServerDialog 

// called by enumsessions - find out where server is...
HRESULT GetServerAddress(LPGLOBALDATA pgd,LPSOCKADDR_IN6 psockaddr) 
{
    HRESULT hr;

        if (pgd->bHaveServerAddress)
        {
            // use enum address passed to SPInit
            hr = GetAddress(&pgd->saddrEnumAddress,pgd->szServerAddress,strlen(pgd->szServerAddress));
        }
        else
        {
            // ask user for enum address
            hr = ServerDialog(&pgd->saddrEnumAddress);
        }

        if (SUCCEEDED(hr))
        {
            // setup winsock to enum this address
            *psockaddr = pgd->saddrEnumAddress;
            // see byte-order comment in dpsp.h for this constant
            psockaddr->sin6_port = SERVER_DGRAM_PORT;
        }
        else
        {
            DPF(0, "Invalid server address: 0x%08lx", hr); 
        }

    return (hr);
} // GetServerAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\dphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.c
 *  Content:    allows the dplay winsock sp's to all share a single
 *      	server socket
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18-jul-96  andyco  initial implementation
 *   25-jul-96	andyco	ddhelp now watches dplay procs so it can remove
 *						them from our list when they go away
 *   3-sep-96	andyco	don't get stale ip's - pick up a default ip whenever
 *						we add a servernode. bug 3716.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *						it in dphelps receive thread before forwarding requests
 *   21-jan-97	kipo	use LoadLibrary on "wsock32.dll" instead of statically
 *						linking to it so DDHELP will still run even when Winsock
 *						is not around. This lets DDRAW and DSOUND work. Fixes
 *						bug #68596.
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *
 ***************************************************************************/
/*============================================================================
*                                                                             
*  Why this file exists :                                                     
*                                                                             
*   when you want to find a dplay game, you send a message to a well      
*   known port (an enumrequest).                                          
*                                                                             
*   if a game is being hosted on that system, it will listen on that      
*   port, and respond to the message.                                     
*                                                                             
*   BUT, only one process can listen on a given socket.                  
*                                                                             
*   So, we let ddhelp.exe listen on that socket, and forward enumrequests 
*   to all games registered as being hosted on this system.
*	
*   see also : \%MANROOT%\dplay\wsock\dpsp.h
*                                                                             
*****************************************************************************/

// todo - should we return error codes on AddServer xproc to our caller?

#include "dphelp.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DPHELP"

/*
 *  GLOBALS
 */ 
const IN6_ADDR in6addr_multicast = IN6ADDR_MULTICAST_INIT;
SOCKET gsDatagramListener = INVALID_SOCKET; // we listen for datagrams on this socket
SOCKET gsForwardSocket = INVALID_SOCKET;
SOCKET gsStreamListener;					// we listen for tcp connections on this socket
LPSPNODE gNodeList;
BOOL gbInit;
HANDLE ghDatagramReceiveThread,ghStreamReceiveThread;
BOOL gbReceiveShutdown;						// receive thread will exit when TRUE

// pointers to Winsock routines returned from GetProcAddress
cb_accept			g_accept;
cb_bind				g_bind;
cb_closesocket		g_closesocket;
cb_gethostbyname	g_gethostbyname;
cb_gethostname		g_gethostname;
cb_getpeername		g_getpeername;
cb_getsockname		g_getsockname;
cb_recvfrom			g_recvfrom;
cb_recv				g_recv;
cb_select			g_select;
cb_send				g_send;
cb_sendto			g_sendto;
cb_setsockopt		g_setsockopt;
cb_shutdown			g_shutdown;
cb_socket			g_socket;
cb_WSAFDIsSet		g_WSAFDIsSet;
cb_WSAGetLastError	g_WSAGetLastError;
cb_WSAStartup		g_WSAStartup;
cb_listen			g_listen;
cb_htons			g_htons;

#ifdef DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintAddr"

// helper function called from DEBUGPRINTADDR macro
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
    char buff[INET6_ADDRSTRLEN];
    int ret;
    LPSOCKADDR_IN6 pin6 = (LPSOCKADDR_IN6)psockaddr;
    ULONG ulLength = INET6_ADDRSTRLEN;

    ret = WSAAddressToString(psockaddr, sizeof(SOCKADDR_IN6), NULL,
            buff, &ulLength);

    if (!ret)
        DPF(nLevel,"%s af = AF_INET6 : address =  %s\n",pStr,buff);

} // DebugPrintAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintSocket"

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR_IN6 sockaddr;
	int addrlen=sizeof(sockaddr);

	g_getsockname(*pSock,(LPSOCKADDR)&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}

#endif // debug

// this is called every time we add a new server node to our list...
HRESULT GetDefaultHostAddr(SOCKADDR_IN6 * psockaddr)
{

//	a-josbor: we used to get the first interface and use that, but WebTV taught
//		us that that can be dangerous.  So we just use the loopback address.
//		It's guaranteed to be there.  Or so they say...

    ZeroMemory(psockaddr, sizeof(SOCKADDR_IN6));
    psockaddr->sin6_family = AF_INET6;
    psockaddr->sin6_addr = in6addr_loopback;
	
    return DP_OK;
	
} // GetDefaultHostAddr

// the functions DPlayHelp_xxx are called from dphelp.c

//
// add a new node to our list of servers which want to have enum 
// requests forwarded to them...
HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd)
{
    LPSPNODE pNode;
    BOOL bFoundIt=FALSE;
    HRESULT hr;
	
    if (!gbInit) 
    {
		hr = DPlayHelp_Init();
		if (FAILED(hr))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (hr);
		}
    }

    // see if we're already watching this process
	// if we are, we won't start a watcher thread (below)
    pNode = gNodeList;

    // search the list 
    while (pNode && !bFoundIt)
    {
		if (pNode->pid == phd->pid) bFoundIt = TRUE;
		pNode = pNode->pNextNode;
    }

	//
	// now, build a new server node
    pNode = MemAlloc(sizeof(SPNODE));
    if (!pNode)
    {
        DPF_ERR("could not add new server node OUT OF MEMORY");
        return (DPERR_OUTOFMEMORY);
    }
    
    pNode->pid = phd->pid;
    // build the sockaddr
    // dwReserved1 of the phd is the port that the server is listening on
    pNode->sockaddr.sin6_family =  AF_INET6;
    
    // find the default ip to use w/ this host
    hr = GetDefaultHostAddr(&(pNode->sockaddr));
	if (FAILED(hr))
    {
        DPF_ERR("could not get host IP address");
		MemFree(pNode);
        return (DPERR_UNAVAILABLE);
    }
    
    pNode->sockaddr.sin6_port = phd->port;

    DPF(5,"dphelp :: adding new server node : pid = %d, port = %d\n",phd->pid,g_htons(phd->port));

    // link our new node onto the beginning of the list
    pNode->pNextNode = gNodeList;
    gNodeList = pNode;

	// see if we need to start our watcher thread    
    if (!bFoundIt)
    {
		//
	    // set up a thread to keep on eye on this process.
	    // we'll let the thread notify us when the process goes away
	    WatchNewPid(phd);
    }

    return (DP_OK);

} // DPlayHelp_AddServer

//
// delete the server node from proc pid from our list
// called by "ThreadProc" from DPHELP.c when the process that
// goes away, or from the client side when a session goes away.
//
// if bFreeAll is TRUE, we delete all server nodes for process
// phd->pid.  otherwise, we just delete the first server node whose
// port matches phd->port
//
BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL bFreeAll)
{
    BOOL bFoundIt = FALSE;
    LPSPNODE pNode,pNodePrev,pNodeNext;

    pNode = gNodeList;
    pNodePrev = NULL;
	pNodeNext = NULL;
	
    // search the whole list
    while (pNode && !bFoundIt)
    {
		// if we have the right pid, and it's either FreeAll or the right port - cruise it!
		if ((pNode->pid == phd->pid) &&  (bFreeAll || (pNode->sockaddr.sin6_port == phd->port)) )
		{
		    // remove it from the list
		    if (pNodePrev) pNodePrev->pNextNode = pNode->pNextNode;
		    else gNodeList = pNode->pNextNode;
			
		    if (bFreeAll) 
		    {
				// pick up the next one b4 we free pNode
				pNodeNext = pNode->pNextNode;
		    }
			else 
			{
				// mark us as done
				bFoundIt = TRUE;
				pNodeNext = NULL;
			}

		    DPF(5,"dphelp :: deleting server node : pid = %d\n",pNode->pid);
		    // free up the node
		    MemFree(pNode);

			pNode = pNodeNext;
			// pNodePrev doesn't change here...
		}
		else 
		{
		    // just get the next one
		    pNodePrev = pNode;
		    pNode = pNode->pNextNode;
		}
    }


    return FALSE;

} // DPlayHelp_DeleteServer 

//
// poke an ip addr into a message blob 
// code stolen from \orange\dplay\wsock\winsock.c
void IP6_SetAddr(LPVOID pmsg,SOCKADDR_IN6 * paddrSrc)
{
    LPSOCKADDR_IN6  paddrDest; // tempo variable, makes casting less ugly
    LPMESSAGEHEADER phead;

    phead = (LPMESSAGEHEADER)pmsg;

    paddrDest = (SOCKADDR_IN6 *)&(phead->sockaddr);
    // poke the new ip addr into the message header
    paddrDest->sin6_addr = paddrSrc->sin6_addr;

    return;
	
} // IP6_SetAddr

//
// we get a message.  presumably its an enumrequest. forward it to all registered clients.
// we "home" the message (store the received ip addr w/ it) here, 'cause otherwise the clients
// would all think it came from us.  we change the token to srvr_token so the clients know it
// came from us (so they don't home it again)
void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN6 * psockaddr)
{
    LPSPNODE pNode = gNodeList;
    UINT addrlen = sizeof(SOCKADDR_IN6);
    UINT err;
	
    ASSERT(VALID_SP_MESSAGE(pBuffer));

    // reset the old token
    *( (DWORD *)pBuffer) &= ~TOKEN_MASK;
    // set the new token
    *( (DWORD *)pBuffer) |= HELPER_TOKEN;

    // home it
    IP6_SetAddr((LPVOID)pBuffer,psockaddr);
    
    // now, forward the message to all registered servers
    while (pNode)
    {
		DEBUGPRINTADDR(7,"dplay helper  :: forwarding enum request to",(SOCKADDR *)&(pNode->sockaddr));
		// send out the enum message
        err = g_sendto(gsForwardSocket,pBuffer,dwBufferSize,0,(LPSOCKADDR)&(pNode->sockaddr),
    		addrlen);
        if (SOCKET_ERROR == err) 
        {
    	    err = g_WSAGetLastError();
	    	DPF(0,"dphelp : send failed err = %d\n",err);
        }

        pNode = pNode->pNextNode;
    }

    return ;

} // HandleIncomingMessage

#if 1

void JoinEnumGroups(SOCKET s)
{
    SOCKET_ADDRESS_LIST *pList;
    int i;
    LPSOCKADDR_IN6 paddr;
    HRESULT hr;

    //
    // join link-local multicast group for enumeration on every link
    //

    // do a passive getaddrinfo
    pList = GetHostAddr();
    if (pList)
    {
        // for each linklocal address
        for (i=0; i<pList->iAddressCount; i++)
        {
            paddr = (LPSOCKADDR_IN6)pList->Address[i].lpSockaddr;

            // skip if not linklocal
            if (!IN6_IS_ADDR_LINKLOCAL(&paddr->sin6_addr))
            {
                continue;
            }

            // join the multicast group on that ifindex
            if (SOCKET_ERROR == JoinEnumGroup(s, paddr->sin6_scope_id))
            {
                DPF(0,"join enum group failed - err = %d\n",WSAGetLastError());
                closesocket(s);
            }
        }
        FreeHostAddr(pList);
    }
}
#endif

//
// BUF_SIZE is our initial guess at a receive buffer size
// if we get an enum request bigger than this, we'll realloc our
// buffer, and receive successfully if they send again
// (the only way this could happen is if they have password > ~ 1000
// bytes).
#define BUF_SIZE 1024

//
// listen on our socket for enum requests
DWORD WINAPI ListenThreadProc(LPVOID pvUnused)
{
    UINT err;
    LPBYTE pBuffer=NULL;
    SOCKADDR_IN6 sockaddr; // the from address
    INT addrlen=sizeof(sockaddr);
    DWORD dwBufSize = BUF_SIZE;

    DPF(2,"dphelp :: starting udp listen thread ");

    pBuffer = MemAlloc(BUF_SIZE);
    if (!pBuffer)
    {
        DPF_ERR("could not alloc dgram receive buffer");
        ExitThread(0);
        return 0;
    }

    JoinEnumGroups(gsDatagramListener);

    while (1)
    {
        err = g_recvfrom(gsDatagramListener,pBuffer,dwBufSize,0,(LPSOCKADDR)&sockaddr,&addrlen);
        if (SOCKET_ERROR == err) 
        {
            err = g_WSAGetLastError();
            if (WSAEMSGSIZE == err)
            {
                LPBYTE pNewBuffer;

                // buffer too small!
                dwBufSize *= 2;

	    	    DPF(9,"\n udp recv thread - resizing buffer newsize = %d\n",dwBufSize);
                pNewBuffer = MemReAlloc(pBuffer,dwBufSize);
                if (!pNewBuffer)
                {
                    DPF_ERR("could not realloc dgram receive buffer");
                    goto ERROR_EXIT;
                }
                pBuffer = pNewBuffer;
                // we can't do anything with this message, since it was truncated...
            } // WSAEMSGSIZE
            else 
            {
		#ifdef DEBUG
            	if (WSAEINTR != err) 
		        {
				    // WSAEINTR is what winsock uses to break a blocking socket out of 
				    // its wait.  it means someone killed this socket.
				    // if it's not that, then it's a real error.
		            DPF(0,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);
            	}
				else
				{
				    DPF(9,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);				
				}
		#endif // DEBUG 

                // we bail on errors other than WSAEMSGSIZE
                goto ERROR_EXIT;
            }
        } // SOCKET_ERROR
        else if ((err >= sizeof(DWORD)) &&  VALID_SP_MESSAGE(pBuffer))
        {
            // now, if we succeeded, err is the # of bytes read
	    	DEBUGPRINTADDR(9,"dplay helper  :: received enum request from ",(SOCKADDR *)&sockaddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pBuffer,err,(SOCKADDR_IN6 *)&sockaddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
        }
        else 
        {
            ASSERT(FALSE);
            // ?
        }
    } // 1

ERROR_EXIT:
    DPF(2,"UDP Listen thread exiting");
    if (pBuffer) MemFree(pBuffer);
    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

// startup winsock and find the default ip addr for this machine
HRESULT  StartupIP()
{
    UINT err;
    WSADATA wsaData;
	HINSTANCE hWinsock;

	// load winsock library
    hWinsock = LoadLibrary("wsock32.dll");
	if (!hWinsock) 
	{
		DPF(0,"Could not load wsock32.dll\n");
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need

    g_accept = (cb_accept) GetProcAddress(hWinsock, "accept");
	if (!g_accept)
		goto GETPROCADDRESSFAILED;

    g_bind = (cb_bind) GetProcAddress(hWinsock, "bind");
	if (!g_bind)
		goto GETPROCADDRESSFAILED;
		
    g_closesocket = (cb_closesocket) GetProcAddress(hWinsock, "closesocket");
	if (!g_closesocket)
		goto GETPROCADDRESSFAILED;

    g_gethostbyname = (cb_gethostbyname) GetProcAddress(hWinsock, "gethostbyname");
	if (!g_gethostbyname)
		goto GETPROCADDRESSFAILED;
		
    g_gethostname = (cb_gethostname) GetProcAddress(hWinsock, "gethostname");
	if (!g_gethostname)
		goto GETPROCADDRESSFAILED;

    g_getpeername = (cb_getpeername) GetProcAddress(hWinsock, "getpeername");
	if (!g_getpeername)
		goto GETPROCADDRESSFAILED;

    g_getsockname = (cb_getsockname) GetProcAddress(hWinsock, "getsockname");
	if (!g_getsockname)
		goto GETPROCADDRESSFAILED;

    g_htons = (cb_htons) GetProcAddress(hWinsock, "htons");
	if (!g_htons)
		goto GETPROCADDRESSFAILED;
		
    g_listen = (cb_listen) GetProcAddress(hWinsock, "listen");
	if (!g_listen)
		goto GETPROCADDRESSFAILED;
		
    g_recv = (cb_recv) GetProcAddress(hWinsock, "recv");
	if (!g_recv)
		goto GETPROCADDRESSFAILED;

    g_recvfrom = (cb_recvfrom) GetProcAddress(hWinsock, "recvfrom");
	if (!g_recvfrom)
		goto GETPROCADDRESSFAILED;

    g_select = (cb_select) GetProcAddress(hWinsock, "select");
	if (!g_select)
		goto GETPROCADDRESSFAILED;

    g_send = (cb_send) GetProcAddress(hWinsock, "send");
	if (!g_send)
		goto GETPROCADDRESSFAILED;

    g_sendto = (cb_sendto) GetProcAddress(hWinsock, "sendto");
	if (!g_sendto)
		goto GETPROCADDRESSFAILED;

    g_setsockopt = (cb_setsockopt) GetProcAddress(hWinsock, "setsockopt");
	if (!g_setsockopt)
		goto GETPROCADDRESSFAILED;

    g_shutdown = (cb_shutdown) GetProcAddress(hWinsock, "shutdown");
	if (!g_shutdown)
		goto GETPROCADDRESSFAILED;

    g_socket = (cb_socket) GetProcAddress(hWinsock, "socket");
	if (!g_socket)
		goto GETPROCADDRESSFAILED;

    g_WSAFDIsSet = (cb_WSAFDIsSet) GetProcAddress(hWinsock, "__WSAFDIsSet");
	if (!g_WSAFDIsSet)
		goto GETPROCADDRESSFAILED;
		
	g_WSAGetLastError = (cb_WSAGetLastError) GetProcAddress(hWinsock, "WSAGetLastError");
	if (!g_WSAGetLastError)
		goto GETPROCADDRESSFAILED;

    g_WSAStartup = (cb_WSAStartup) GetProcAddress(hWinsock, "WSAStartup");
	if (!g_WSAStartup)
		goto GETPROCADDRESSFAILED;

	// start up sockets, asking for version 1.1
    err = g_WSAStartup(MAKEWORD(1,1), &wsaData);
    if (err) 
    {
        DPF(0,"dphelp :: could not start winsock err = %d\n",err);
        goto WSASTARTUPFAILED;
    }
    DPF(3,"dphelp :: started up winsock succesfully");

    return DP_OK;

GETPROCADDRESSFAILED:
	DPF(0,"Could not find required Winsock entry point");
WSASTARTUPFAILED:
	FreeLibrary(hWinsock);
LOADLIBRARYFAILED:
	return DPERR_UNAVAILABLE;
} // StartupIP

// helper function to create the socket we listen on
HRESULT GetSocket(SOCKET * psock,DWORD type,PORT port,BOOL bBroadcast,BOOL bListen)
{
    SOCKADDR_IN6 sockaddr;
    UINT err;
    SOCKET sNew;

    sNew = g_socket( AF_INET6, type, 0);
    if (INVALID_SOCKET == sNew) 
    {
        goto ERROR_EXIT;
    }

    // set up the sockaddr to bind to
    ZeroMemory(&sockaddr, sizeof(sockaddr));
    sockaddr.sin6_family         = PF_INET6;
    sockaddr.sin6_port           = port;

    // do the bind
    if( SOCKET_ERROR == g_bind( sNew, (LPSOCKADDR)&sockaddr, sizeof(sockaddr) ) )
    {
        goto ERROR_EXIT;
    }

    if (bListen)
    {
	    LINGER Linger;
	    
	    // set up socket w/ max listening connections
	    err = g_listen(sNew,LISTEN_BACKLOG);
	    if (SOCKET_ERROR == err) 
	    {
	        err = g_WSAGetLastError();
	        DPF(0,"init listen socket / listen error - err = %d\n",err);
	        goto ERROR_EXIT;
	    }

		// set for hard disconnect
		Linger.l_onoff=1;
		Linger.l_linger=0;
	    
	    if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_LINGER,
			(char FAR *)&Linger,sizeof(Linger) ) )
	    {
	        err = g_WSAGetLastError();
			DPF(0,"Failed to set linger option on the socket = %d\n",err);
	    }    
    }

    // success!
    *psock = sNew;
    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    err = g_WSAGetLastError();
    DPF(0,"dphelp - could not get helper socket :: err = %d\n",err);
    if (INVALID_SOCKET != sNew)
    {
        g_closesocket(sNew);
    } 
    return E_FAIL;

}   // GetSocket

void CloseSocket(SOCKET * psSocket)
{
    UINT err;

    if (INVALID_SOCKET != *psSocket)
    {
    	if (SOCKET_ERROR == g_closesocket(*psSocket)) 
    	{
            err = g_WSAGetLastError();
    	    DPF(1,"dphelp : killsocket - socket close err = %d\n",err);
		}
	
		*psSocket = INVALID_SOCKET;
    }
    
    return ;

} // CloseSocket

extern int
InitIPv6Library(void);

HRESULT DPlayHelp_Init()
{
    DWORD dwThreadID;
    HRESULT hr;

    // start winsock, and get the default ip addr for this system
    hr = StartupIP();
    if (FAILED(hr))
    {
        return hr; // StartupIP will have printed an error
    }

    InitIPv6Library();

    // get the listen socket
    hr = GetSocket(&gsDatagramListener,SOCK_DGRAM,SERVER_DGRAM_PORT,TRUE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get the forward socket
    hr = GetSocket(&gsForwardSocket,SOCK_DGRAM,0,FALSE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get us a enum sessions stream listener
	hr = GetSocket(&gsStreamListener,SOCK_STREAM,SERVER_STREAM_PORT,FALSE,TRUE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
	

    ghDatagramReceiveThread = CreateThread(NULL,0,ListenThreadProc,NULL,0,&dwThreadID);
    if (!ghDatagramReceiveThread)
    {
        DPF_ERR("could not create udp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    ghStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,NULL,0,&dwThreadID);
    if (!ghStreamReceiveThread)
    {
        DPF_ERR("could not create tcp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
    

    DPF(5,"DPLAYHELP : init succeeded");
    gbInit = TRUE;
    return DP_OK;

ERROR_EXIT:
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);
    CloseSocket(&gsStreamListener);

    return hr;

} // DPlayHelp_Init 

void DPlayHelp_FreeServerList()
{
    LPSPNODE pNodeKill,pNodeNext;

    pNodeNext = gNodeList;

    // search the whole list
    while (pNodeNext)
    {
		// kill this node
		pNodeKill = pNodeNext;
		// but first, remember what's next
		pNodeNext = pNodeKill->pNextNode;
		// free up the node
		MemFree(pNodeKill);
    }
	
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);

	// close stream receive
	RemoveSocketFromList(gsStreamListener);
	gbReceiveShutdown = TRUE;
	
	// drop the lock so the threads can exit - they might be waiting on
	// the lock for cleanup
	LEAVE_DPLAYSVR();
		
    // wait for the threads to go away
   	if (ghDatagramReceiveThread) 
   		WaitForSingleObject(ghDatagramReceiveThread, INFINITE);
    if (ghStreamReceiveThread) 
    	WaitForSingleObject(ghStreamReceiveThread, INFINITE);
    
    ENTER_DPLAYSVR();
    
    if (ghDatagramReceiveThread)
    {
    	DPF(5,"datagram receive thread exited!");
	    CloseHandle(ghDatagramReceiveThread);
	    ghDatagramReceiveThread = NULL;
    }
    if (ghStreamReceiveThread)
    {
	    DPF(5,"stream receive thread exited!");
	    CloseHandle(ghStreamReceiveThread);
	    ghStreamReceiveThread = NULL;
    }


    return ;
    
} // DPlayHelp_FreeServerList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipsec\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   6/10/98   a-peterz Check CreateFile() result against INVALID_HANDLE_VALUE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "newdpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 0xFFFFFFFF; // 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
    extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;

int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl(
HANDLE hDevice,             // handle to device of interest
DWORD dwIoControlCode,      // control code of operation to perform
LPVOID lpInBuffer,          // pointer to buffer to supply input data
DWORD nInBufferSize,        // size of input buffer
LPVOID lpOutBuffer,         // pointer to buffer to receive output data
DWORD nOutBufferSize,       // size of output buffer
LPDWORD lpBytesReturned,    // pointer to variable to receive output byte count
LPOVERLAPPED lpOverlapped   // pointer to overlapped structure for asynchronous operation
);
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG   (FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG  (FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)

HANDLE hDPLAY_VxD=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;

typedef struct _LOGENTRY {
    CHAR    debuglevel;
    CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
    UINT    nLogEntries;
    UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
    UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
    CHAR    debuglevel;
    CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
    UINT    hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

void DbgWriteStats(PIN_WRITESTATS pIn)
{
    UINT rc;
    UINT cbRet;

    if(hDPLAY_VxD){
        DeviceIoControl(hDPLAY_VxD,WRITE_STATS,pIn,sizeof(IN_WRITESTATS), &rc, sizeof(rc), &cbRet, NULL);
    }
}

static BOOL InitMemLogString(VOID)
{
    DWORD dwLastError;

    hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
    dwLastError=GetLastError();
    hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
    pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

    if(!hLogFile || !hLogMutex || !pLogFile){
        if(hLogFile){
            CloseHandle(hLogFile);
            hLogFile=0;
        }
        if(hLogMutex){
            CloseHandle(hLogMutex);
            hLogMutex=0;
        }
        if(pLogFile){
            UnmapViewOfFile(pLogFile);
            pLogFile=NULL;
        }
        return FALSE;
    } else {
        WaitForSingleObject(hLogMutex,INFINITE);
            if((dwLastError!=ERROR_ALREADY_EXISTS) ||
                (pLogFile->nEntries > DPLOG_NUMENTRIES) || (pLogFile->nEntries == 0) ||
                (pLogFile->cbLine   > DPLOG_ENTRYSIZE)  || (pLogFile->cbLine   == 0) ||
                (pLogFile->iWrite   > DPLOG_NUMENTRIES) ||
                (pLogFile->cInUse   > DPLOG_NUMENTRIES)
            ){
                pLogFile->nEntries = DPLOG_NUMENTRIES;
                pLogFile->cbLine   = DPLOG_ENTRYSIZE;
                pLogFile->iWrite   = 0;
                pLogFile->cInUse   = 0;
            }
        ReleaseMutex(hLogMutex);
    }
    return TRUE;
}

static void MemLogString(LPSTR str)
{
    PLOG_ENTRY pEntry;
    DWORD cbCopy;

    if(!hLogFile){
        if(!InitMemLogString()){
            return;
        }
    }

    WaitForSingleObject(hLogMutex,INFINITE);

    pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
    pEntry->hThread=GetCurrentThreadId();
    pEntry->tLogged=timeGetTime();
    pEntry->DebugLevel=0;

    cbCopy=strlen(str)+1;
    if(cbCopy > DPLOG_ENTRYSIZE){
        str[DPLOG_ENTRYSIZE]=0;
        cbCopy=DPLOG_ENTRYSIZE;
    }
    memcpy(pEntry->str, str, cbCopy);

    if(pLogFile->iWrite+1 > pLogFile->cInUse){
        pLogFile->cInUse=pLogFile->iWrite+1;
    }

    pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
    ReleaseMutex(hLogMutex);

}

static void LogString( LPSTR str )
{
    char logstring[MAX_STRING+sizeof(LOGENTRY)];
    int  i=0;
    PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
    UINT rc;
    UINT cbRet;
    int maxlen = MAX_STRING+sizeof(LOGENTRY);

    if(hDPLAY_VxD && str){
        while(str[i] && i < maxlen)
            i++;
        pLogEntry->debuglevel=0;
        memcpy(pLogEntry->str,str,i+1);
        DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
    }

    if(bLogging & 2){
        MemLogString(str);
    }
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
    if(!bLogging || bLogging & 1)
    {
        OUTPUTDEBUGSTRING( str );
        OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
        LogString(str);
    }

}

void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT   "DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
            hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
            if(hDPLAY_VxD != INVALID_HANDLE_VALUE){
                IN_LOGINIT In;
                OUT_LOGINIT Out;
                UINT cbRet;
                In.nCharsPerLine=MAX_STRING;
                In.nLogEntries=5000;
                DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
            }
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(volatile DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;

    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) UlongToPtr(arg);

    cMsg[0]=0;

    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;

}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
    /*
     * Into the debugger we go...
     */
    DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "newdpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lBytesAlloc;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
	lBytesAlloc+=pmt->dwSize;\
		{	\
			IN_WRITESTATS InWS;	\
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	\
		 	InWS.stat_USER3=lBytesAlloc;	\
			DbgWriteStats(&InWS);	\
		} \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

#ifdef DEBUG
	    lBytesAlloc -= pmt->dwSize;
		{	
			IN_WRITESTATS InWS;	
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	
		 	InWS.stat_USER3=lBytesAlloc;	
			DbgWriteStats(&InWS);	
		}
#endif

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	lBytesAlloc -= pmt->dwSize;

	pmt->dwSize = size - sizeof( MEMTRACK );

	lBytesAlloc += pmt->dwSize;

	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER3=lBytesAlloc;
		DbgWriteStats(&InWS);
	}

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lBytesAlloc = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\inc\ip6.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions derived from the IPv6 protocol specifications.
//


#ifndef IP6_INCLUDED
#define IP6_INCLUDED 1

#define IPV6_ADDRESS_LENGTH     128     // Bits in an address.
#define IPV6_ID_LENGTH          64      // Bits in an interface identifier.

//
// IPv6 Header Format.
// See RFC 1883, page 5 (and subsequent draft updates to same).
//
typedef struct IPv6Header {
    u_long VersClassFlow;   // 4 bits Version, 8 Traffic Class, 20 Flow Label.
    u_short PayloadLength;  // Zero indicates Jumbo Payload hop-by-hop option.
    u_char NextHeader;      // Values are superset of IPv4's Protocol field.
    u_char HopLimit;
    struct in6_addr Source;
    struct in6_addr Dest;
} IPv6Header;

//
// Maximum value for the PayloadLength field.
// Note that the 40-byte IPv6 header is NOT included.
//
#define MAX_IPv6_PAYLOAD  65535

//
// Minimum size of an IPv6 link's MTU.
// Note that the 40-byte IPv6 header IS included,
// but any link-layer header is not.
//
#define IPv6_MINIMUM_MTU  1280

//
// Useful constants for working with various fields in the IPv6 header.
//
// NOTE: We keep the Version, Traffic Class and Flow Label fields as a single
// NOTE: 32 bit value (VersClassFlow) in network byte order (big-endian).
// NOTE: Since NT is little-endian, this means all loads/stores to/from this
// NOTE: field need to be byte swapped.
//
#define IP_VER_MASK 0x000000F0  // Version is high 4 bits of VersClassFlow.
#define IP_VERSION 0x00000060   // This is 6 << 28 (after byte swap).
#define IP_TRAFFIC_CLASS_MASK 0x0000F00F  // 0x0FF00000 (after byte swap).

#define MAX_IP_PROTOCOL  255

//
// Protocol (i.e. "Next Header" field) values for included protocols.
//
#define IP_PROTOCOL_HOP_BY_HOP 0  // IPv6 Hop-by-Hop Options Header.
#define IP_PROTOCOL_ICMPv4     1  // IPv4 Internet Control Message Protocol.
#define IP_PROTOCOL_V6        41  // IPv6 Header.
#define IP_PROTOCOL_ROUTING   43  // IPv6 Routing Header.
#define IP_PROTOCOL_FRAGMENT  44  // IPv6 Fragment Header.
#define IP_PROTOCOL_ESP       50  // IPSec Encapsulating Security Payload Hdr.
#define IP_PROTOCOL_AH        51  // IPSec Authentication Hdr.
#define IP_PROTOCOL_ICMPv6    58  // IPv6 Internet Control Message Protocol.
#define IP_PROTOCOL_NONE      59  // No next header - ignore packet remainder.
#define IP_PROTOCOL_DEST_OPTS 60  // IPv6 Destination Options Header.

__inline int
IsExtensionHeader(u_char Prot)
{
    if ((Prot == IP_PROTOCOL_HOP_BY_HOP) || (Prot == IP_PROTOCOL_ROUTING) ||
        (Prot == IP_PROTOCOL_FRAGMENT) || (Prot == IP_PROTOCOL_DEST_OPTS) ||
        (Prot == IP_PROTOCOL_ESP) || (Prot == IP_PROTOCOL_AH))
        return TRUE;
    return FALSE;
}


//
// IPv6 type-length-value (TLV) encoded option types found in some
// extension headers.  The upper two bits of each type are encoded
// so as to specify what action the node should take if it doesn't
// grok the option type.  The third-highest-order bit specifies if
// the option data can change en-route to the final destination.
// See RFC 1883, section 4.2 (pages 9-10) for more information.
//
#define IPv6_OPT_ACTION_MASK 0xc0   // High two bits.
#define IPv6_OPT_DYNDATA_MASK 0x20  // Third-highest bit.


//
// Hop-by-Hop and Destination Options Headers.
// We use a single structure for both.
//
typedef struct IPv6OptionsHeader {
    u_char NextHeader;
    u_char HeaderExtLength;  // In 8-byte units, not counting first 8.
} IPv6OptionsHeader;


//
// Routing Header.
//
typedef struct IPv6RoutingHeader {
    u_char NextHeader;
    u_char HeaderExtLength;  // In 8-byte units, not counting first 8.
    u_char RoutingType;
    u_char SegmentsLeft;     // Number of nodes still left to be visited.
    u_char Reserved[4];      // Not a u_int to avoid alignment.
} IPv6RoutingHeader;


//
// Fragment Header.
//
typedef struct FragmentHeader {
    u_char NextHeader;
    u_char Reserved;
    u_short OffsetFlag;  // Offset is upper 13 bits, flag is lowest bit.
    u_long Id;
} FragmentHeader;

#define FRAGMENT_OFFSET_MASK 0xfff8
#define FRAGMENT_FLAG_MASK 0x0001


//
// Generic Extension Header.
//
typedef struct ExtensionHeader {
    u_char NextHeader;
    u_char HeaderExtLength;  // In 8-byte units, not counting first 8.
} ExtensionHeader;

#define EXT_LEN_UNIT 8  // 8-byte units used for extension hdr length.

//
// Generic Options Header.
//
typedef struct OptionHeader {
    u_char Type;
    u_char DataLength;  // In bytes, not counting two for the header.
} OptionHeader;

//
// Format of the router alert within the Hop-by-Hop Option header.
//
typedef struct IPv6RouterAlertOption {
    u_char Type;
    u_char Length;
    u_short Value;
} IPv6RouterAlertOption;

//
// Mobile IPv6 destination option formats.
//
#pragma pack(1)
typedef struct IPv6BindingUpdateOption {
    u_char Type;
    u_char Length;
    u_char Flags;                 // See mask values below.
    u_char PrefixLength;          // Only used for "home registration" updates.
    u_short SeqNumber;
    u_int Lifetime;               // Number of seconds before binding expires.
} IPv6BindingUpdateOption;
#pragma pack()

// Masks for the Flags field.
#define IPV6_BINDING_ACK       0x80  // Request a binding acknowledgement.
#define IPV6_BINDING_HOME_REG  0x40  // Request host to act as home agent.
#define IPV6_BINDING_ROUTER    0x20  // Sender is a router (valid w/ HOME_REG).
#define IPV6_BINDING_DAD       0x10  // Request HA perform DAD on home link.

typedef u_char BindingUpdateDisposition;

#pragma pack(1)
typedef struct IPv6BindingAcknowledgementOption {
    u_char Type;
    u_char Length;
    BindingUpdateDisposition Status; // Disposition of the MN's binding update.
    u_short SeqNumber;
    u_int Lifetime;     // Granted lifetime if binding accepted.
    u_int Refresh;      // Interval recommended to send new binging update.
} IPv6BindingAcknowledgementOption;
#pragma pack()


// Disposition status values.
#define IPV6_BINDING_ACCEPTED         0
#define IPV6_BINDING_REJECTED         128   // Rejected for unspecified reason.
// was  IPV6_BINDING_POORLY_FORMED    129   // Poorly formed binding update.
#define IPV6_BINDING_PROHIBITED       130   // Administratively prohibited.
#define IPV6_BINDING_NO_RESOURCES     131
#define IPV6_BINDING_HOME_REG_NOT_SUPPORTED 132  // Registration not supported.
#define IPV6_BINDING_NOT_HOME_SUBNET  133
#define IPV6_BINDING_SEQ_NO_TOO_SMALL 134   // Internal only - never on wire.
// was  IPV6_BINDING_DYNAMIC_RESPONSE 135   // Dynamic HA discovery response.
#define IPV6_BINDING_BAD_IF_LENGTH    136   // Incorrect interface id length.
#define IPV6_BINDING_NOT_HOME_AGENT   137   // Not the HA for this mobile node.
#define IPV6_BINDING_DAD_FAILED       138   // DAD failed.

typedef struct IPv6BindingRequestOption {
    u_char Type;
    u_char Length;
} IPv6BindingRequstOption;

#pragma pack(1)
typedef struct IPv6HomeAddressOption {
    u_char Type;
    u_char Length;
    struct in6_addr HomeAddress;
} IPv6HomeAddressOption;
#pragma pack()

typedef struct SubOptionHeader {
    u_char Type;
    u_char DataLength;  // In bytes, not counting two for the header.
} SubOptionHeader;

#define SUBOPT6_UNIQUE_ID         1
#define SUBOPT6_HOME_AGENTS_LIST  2
#define SUBOPT6_CARE_OF_ADDRESS   4

#pragma pack(1)
typedef struct IPv6UniqueIdSubOption {
    u_char Type;
    u_char Length;
    u_short UniqueId;
} IPv6UniqueIdSubOption;
#pragma pack()

#pragma pack(1)
typedef struct IPv6HomeAgentsListSubOption {
    u_char Type;
    u_char Length;
    // The list of home agents follows at this point.
} IPv6HomeAgentsListSubOption;
#pragma pack()

#pragma pack(1)
typedef struct IPv6CareOfAddrSubOption {
    u_char              Type;
    u_char              Length;
    struct in6_addr     CareOfAddr;
} IPv6CareOfAddrSubOption;
#pragma pack()

// Option Header Values.
#define OPT6_PAD_1               0    // Single byte pad.
#define OPT6_PAD_N               1    // Multiple byte pad.
#define OPT6_JUMBO_PAYLOAD       194  // Jumbo payload (greater than 64KB).
#define OPT6_TUNNEL_ENCAP_LIMIT  4    // REVIEW: Tentative, waiting for IANA.
#define OPT6_ROUTER_ALERT        5    // REVIEW: Tentative, waiting for IANA.

// Options related to IPv6 Mobility.
// REVIEW: These are all tentative, waiting for IANA approval.
#define OPT6_BINDING_UPDATE   198
#define OPT6_BINDING_ACK      7
#define OPT6_BINDING_REQUEST  8
#define OPT6_HOME_ADDRESS     201

// Options we don't yet care about.
#define OPT6_ENDPOINT_ID  168    // Charles Lynn?
#define OPT6_NSAP_ADDR    195    // RFC 1888.

// REVIEW: The below duplicates the IPv6_OPT_* stuff above.
// REVIEW: The above is nicely commented, but the below is what we use.

// Type of actions to be taken with unrecognized header options.
#define OPT6_ACTION(a)  ((a) & 0xc0)    // Get action bits.
#define OPT6_A_SKIP     0x00            // Skip and continue.
#define OPT6_A_DISCARD  0x40            // Discard packet.
#define OPT6_A_SEND_ICMP_ALL  0x80      // Send ICMP regardless of source addr.
#define OPT6_A_SEND_ICMP_NON_MULTI 0xc0 // Send ICMP if non-multicast src addr.

// Determining whether and option is mutiple or not.
#define OPT6_MUTABLE  0x20
#define OPT6_ISMUTABLE(t)  ((t) & OPT6_MUTABLE)


//
// Authentication Header.
//
// The header conceptually includes a variable amount of Authentication Data
// which follows these fixed-size fields.
//
// Calling this "AHHeader" is redundant, but then again so is "TCP Protocol".
//
typedef struct AHHeader {
    u_char NextHeader;
    u_char PayloadLen;  // In 4-byte units, not counting first 8 bytes.
    u_short Reserved;   // Padding.  Must be zero on transmit.
    u_long SPI;         // Security Parameters Index.
    u_long Seq;         // Sequence number for anti-replay algorithms.
} AHHeader;


//
// Encapsulating Security Payload header and trailer.
//
// The header is followed by a variable amount of payload data, followed by
// a variable amount of padding (255 bytes maximum), followed by a byte for
// the Pad Length and a byte for the Next Header field, followed by a
// variable amount of Authentication Data.
//
// The amount of padding should be picked such that the Pad Length and
// Next Header field end up aligned on a 32 bit boundary.
//
typedef struct ESPHeader{
    u_long SPI;  // Security Parameters Index.
    u_long Seq;  // Sequence number for anti-replay algorithms.
} ESPHeader;

typedef struct ESPTrailer{
    u_char PadLength;   // Number of bytes in pad.
    u_char NextHeader;
} ESPTrailer;

#endif // IP6_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\dplsvr6\reliable.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reliable.c
 *  Content:    stream communication related routines
 *  History:
 *   Date   	By  	Reason
 *   ====   	==  	======
 *   01-29-98  	sohailm	initial implementation
 *   02-15-98  a-peterz	Remove unused SetMessageHeader
 *
 ***************************************************************************/
#include "dphelp.h"

/*
 * Globals
 */
FDS	gReadfds;							// fd set to receive data
RECEIVELIST gReceiveList;				// list of connections + listener

/*
 * Externs
 */
extern SOCKET gsStreamListener;			// we listen for tcp connections on this socket
extern gbReceiveShutdown;				// receive thread will exit when TRUE
extern LPSPNODE gNodeList;

#undef DPF_MODNAME
#define DPF_MODNAME	"MakeBufferSpace"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPLAYSVR();
	
	if (!*ppBuffer)
	{
		DPF(9, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPLAYSVR();
    return hr;    
    
}  // MakeBufferSpace

#undef DPF_MODNAME
#define DPF_MODNAME	"AddSocketToReceiveList"

HRESULT AddSocketToReceiveList(SOCKET sSocket)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection;
    
    ENTER_DPLAYSVR();
	
    // look for an empty slot 
    while ( (i < gReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == gReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    if (!bFoundSlot)
    {
		DWORD dwCurrentSize,dwNewSize;
		
		// allocate space for list of connections
		dwCurrentSize = gReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(gReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = gReceiveList.nConnections + 1; 
        	i < gReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	gReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = gReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (gReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + gReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(gReadfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        gReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		gReadfds.dwArraySize = gReceiveList.nConnections;
        
    } // !bFoundSlot

	// Initialize new connection 
	pNewConnection = &(gReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
	// allocate a default receive buffer
	pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	if (NULL == pNewConnection->pDefaultBuffer)
	{
        DPF_ERR("could not alloc default receive buffer - out of memory");        
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	// receive buffer initially points to our default buffer
	pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
	// remember the address we are connected to
	err = g_getpeername(pNewConnection->socket, (LPSOCKADDR)&(pNewConnection->sockAddr), &addrlen);
	if (SOCKET_ERROR == err) 
	{
		err = g_WSAGetLastError();
		DPF(1,"could not getpeername err = %d\n",err);
	}

	DPF(9, "Added new socket at index %d", iNewSlot);

CLEANUP_EXIT:
    
	LEAVE_DPLAYSVR();
    return hr;
    
}  // AddSocketToReceiveList

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out

		    if( SOCKET_ERROR == g_setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
		                    sizeof(Linger) ) )
		    {
		        err = g_WSAGetLastError();
				DPF(0,"killsocket - stream setopt err = %d\n",err);
		    }
		}			
		if (SOCKET_ERROR == g_shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = g_WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
    }

	return DP_OK;
	
}// KillSocket

void FreeConnection(LPCONNECTION pConnection)
{
	DEBUGPRINTSOCK(5,"Freeing connection - ",&pConnection->socket);

	KillSocket(pConnection->socket,TRUE,FALSE);

	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveSocketFromList"

void RemoveSocketFromList(SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;

    ENTER_DPLAYSVR();
    
    // look for the corresponding connection
    while ( (i < gReceiveList.nConnections) && !bFound)
    {
    	if (gReceiveList.pConnection[i].socket == socket)
    	{
    		bFound = TRUE;
			FreeConnection(&gReceiveList.pConnection[i]);
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPLAYSVR();
	
	return ;	
}


#undef DPF_MODNAME
#define DPF_MODNAME	"EmptyConnectionList"

void EmptyConnectionList(void)
{
	UINT i;
	
	DPF(5, "Emptying connection list");
	
	ENTER_DPLAYSVR();
	
	for (i=0;i<gReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
		{
			FreeConnection(&(gReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPLAYSVR();
	
	return ;
	
}  // EmptyConnectionList

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceive"

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		suck the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = g_recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

   	DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);

	DPF(5, "received %d bytes", dwBytesReceived);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
		hr = DP_OK;
		DPF(5,"Remote side has shutdown connection gracefully");
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = g_WSAGetLastError();
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		if (VALID_DPLAYSVR_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			
		}
		else 
		{
			DPF(2,"got invalid message");
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive the rest of the message (after token)
		if (dwMessageSize)
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// received a complete message - process it

		if (TOKEN == SP_MESSAGE_TOKEN(pConnection->pBuffer))
		{						
	    	DEBUGPRINTADDR(9,"dplay helper  :: received reliable enum request from ",(SOCKADDR *)&pConnection->sockAddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pConnection->pBuffer, pConnection->dwTotalMessageSize,
				(SOCKADDR_IN6 *)&pConnection->sockAddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
		}
			
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromList(pConnection->socket);
	return hr;
	 	
} // StreamReceive

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceiveThreadProc"

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	INT_PTR rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
    SOCKADDR sockaddr; // socket we receive from
    INT addrlen=sizeof(sockaddr);
	SOCKET sSocket;

	// add listener socket to receive list
	// listener socket should be the first socket in the receive list
	hr = AddSocketToReceiveList(gsStreamListener);
	if (FAILED(hr))
	{
		DPF(0, "Failed to add TCP listener to receive list");
		return hr;
	}
	
    while (1)
    {
		ENTER_DPLAYSVR();

		ASSERT(gReadfds.pfdbigset);
		
    	// add all sockets in our recv list to readfds
		FD_ZERO(gReadfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < gReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(gReceiveList.pConnection[i].socket,&gReadfds);
				nSelected++;
        	}
		}

		LEAVE_DPLAYSVR();

		if (0 == nSelected)		
		{
			if (gbReceiveShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing listener socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
		
		// now, we wait for something to happen w/ our socket set
		rval = g_select(0,(fd_set *)(gReadfds.pfdbigset),NULL,NULL,NULL);
        if (SOCKET_ERROR == rval)
        {
 	      	err = g_WSAGetLastError();
	    	if (WSAEINTR != err) 
	        {
			    // WSAEINTR is what winsock uses to break a blocking socket out of 
			    // its wait.  it means someone killed this socket.
			    // if it's not that, then it's a real error.
	            DPF(0,"\n select error = %d socket - trying again",err);
	    	}
			else
			{
			    DPF(9,"\n select error = %d socket - trying again",err);				
			}
            rval = 0;
        }

		// shut 'em down?
        if (gbReceiveShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPLAYSVR();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= gReceiveList.nConnections)
			{
				ASSERT(FALSE); // should never happen
				rval = 0; // just to be safe, reset
			}
            
            if (gReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (g_WSAFDIsSet(gReceiveList.pConnection[i].socket,(fd_set *)gReadfds.pfdbigset))
                {
                	if (0==i)
                	// we got a new connection
                	{
					    // accept any incoming connection
					    sSocket = g_accept(gReceiveList.pConnection[i].socket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = g_WSAGetLastError();
				            DPF(0,"\n stream accept error - err = %d socket = %d BAILING",err,(DWORD)sSocket);
				            DPF(0, "\n !!! stream accept thread is going away - won't get reliable enum sessions anymore !!!");
				            ASSERT(FALSE);
				            LEAVE_DPLAYSVR();
							goto CLEANUP_EXIT;
					    }
					    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);
		
						// add the new socket to our receive list
						hr = AddSocketToReceiveList(sSocket);
						if (FAILED(hr))
						{
							ASSERT(FALSE);
						}			
                	}
                	else
                	// socket has new data
                	{
						DPF(9, "Receiving on socket %d from ReceiveList", i);

    	            	// got one! this socket has something going on...
						hr = StreamReceive(&(gReceiveList.pConnection[i]));
            	        if (FAILED(hr))
                	    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
                    	}
                	}
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPLAYSVR();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList();
	DPF(5, "Stream receive thread exiting");
	    
    return 0;
    
} // ReceiveThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\inc\ipsec.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions shared between user/kernel IPsec code.
//

#ifndef IPSEC_INCLUDED
#define IPSEC_INCLUDED 1

//
// IPsec action to take when match is found in the SPD.
//
#define IPSEC_BYPASS    0x1     // Bypass IPsec processing.
#define IPSEC_DISCARD   0x2     // Discard packet.
#define IPSEC_APPLY     0x4     // Apply IPsec processing.
#define IPSEC_APPCHOICE 0x8     // Sending app determines applicable security.

//
// Authentication algorithms.
//
#define ALGORITHM_NULL          0
#define ALGORITHM_HMAC_MD5      1
#define ALGORITHM_HMAC_MD5_96   2
#define ALGORITHM_HMAC_SHA1     3
#define ALGORITHM_HMAC_SHA1_96  4
#define NUM_ALGORITHMS          5

//
// IPsec Mode.
//
#define TRANSPORT   0x1
#define TUNNEL      0x2

//
// Direction of traffic for use in SA and SP.
//
#define INBOUND       0x1
#define OUTBOUND      0x2
#define BIDIRECTIONAL 0x3

// None.
#define NONE        0

//
// Create Results.
//
#define CREATE_SUCCESS              1
#define CREATE_MEMORY_ALLOC_ERROR   2
#define CREATE_INVALID_SABUNDLE     3
#define CREATE_INVALID_DIRECTION    4
#define CREATE_INVALID_SEC_POLICY   5
#define CREATE_INVALID_INTERFACE    6
#define CREATE_INVALID_INDEX        7


//
// Possible IPsec field types.
//
#define SINGLE_VALUE    0
#define RANGE_VALUE     1
#define WILDCARD_VALUE  2

#define POLICY_SELECTOR     0
#define PACKET_SELECTOR     1

#endif // IPSEC_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipsec\ipsec.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IP Security Policy/Association management tool.
//

#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2ip6.h>
#include <ntddip6.h>
#include <ip6.h>
#include <stdio.h>
#include <stdlib.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include <winnlsp.h>
#include "localmsg.h"

#include "ipsec.h"

#define MAX_KEY_SIZE 1024

typedef struct ipv6_create_sa_and_key {
    IPV6_CREATE_SECURITY_ASSOCIATION SA;
    unsigned char Key[MAX_KEY_SIZE];
} IPV6_CREATE_SA_AND_KEY;

void CreateSecurityPolicyFile(char *BaseName);
void CreateSecurityAssociationFile(char *BaseName);
void DisplaySecurityPolicyList(unsigned int Interface);
void DisplaySecurityAssociationList(void);
void ReadConfigurationFile(char *BaseName, int Type);
void DeleteSecurityEntry(int Type, unsigned int Index);

int AdminAccess = TRUE;

HANDLE V6Stack;
IPv6Addr UnspecifiedAddr = { 0 };

//
// Entry types.
//
#define POLICY 1
#define ASSOCIATION 0

//
// Amount of "____" space.
//
#define SA_FILE_BORDER      251 // orig 236
#define SP_FILE_BORDER      273 // was 263, orig 258

// 
// Transport Protocols
//
#define IP_PROTOCOL_TCP     6
#define IP_PROTOCOL_UDP     17
#define IP_PROTOCOL_ICMPv6  58

PWCHAR
GetString(int ErrorCode, BOOL System)
{
    DWORD Count;
    static WCHAR ErrorString[2048]; // a 2K static buffer should suffice
    
    Count = FormatMessageW(
        (System
         ? FORMAT_MESSAGE_FROM_SYSTEM
         : FORMAT_MESSAGE_FROM_HMODULE) |
        FORMAT_MESSAGE_IGNORE_INSERTS   |
        FORMAT_MESSAGE_MAX_WIDTH_MASK,
        0,
        ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        ErrorString,
        2048,
        NULL);

    if (Count == 0) {           // failure
        return L"";             // return a null string
    }

    return ErrorString;         // success
}
#define GetErrorString(ErrorCode) GetString(ErrorCode, TRUE)


void
usage(void)
{
    NlsPutMsg(STDOUT, IPSEC_MESSAGE_0);
// printf("\nManipulates IPv6 IPSec security policies and associations.\n\n");
// printf("IPSEC6 [SP [interface] | SA | [L | S] database | "
//        "D [SP | SA] index]\n\n");
// printf("  SP [interface]     Displays the security policies.\n");
// printf("  SA                 Displays the security associations.\n");      
// printf("  L database         Loads the SP and SA entries from the given "
//        "database files;\n"
//        "                     database should be the filename without an "
//        "extension.\n");
// printf("  S database         Saves the current SP and SA entries to the "
//        "given database\n"
//        "                     files; database should be the filename "
//        "sans extension.\n");
// printf("  D [SP | SA] index  Deletes the given policy or association.\n");
// printf("\nSome subcommands require local Administrator privileges.\n");
    
    exit(1);
}


void
ausage(void)
{
    NlsPutMsg(STDOUT, IPSEC_MESSAGE_1);
// printf("You do not have local Administrator privileges.\n");

    exit(1);
}


void
MakeLowerCase(char *String)
{
    while(*String != '\0')
        *String++ = (char)tolower(*String);
}


int __cdecl
main(int argc, char **argv)
{
    int Error;
    WSADATA WsaData;

    //
    // This will ensure the correct language message is displayed when
    // NlsPutMsg is called.
    //
    SetThreadUILanguage(0);

    Error = WSAStartup(MAKEWORD(2, 0), &WsaData);
    if (Error) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_2, Error);
// printf("Unable to initialize Windows Sockets, error code %d.\n", Error);

        exit(1);
    }

    //
    // First request write access.
    // This will fail if the process does not have local Administrator privs.
    //
    V6Stack = CreateFileW(WIN_IPV6_DEVICE_NAME,
                         GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,   // security attributes
                         OPEN_EXISTING,
                         0,      // flags & attributes
                         NULL);  // template file
    if (V6Stack == INVALID_HANDLE_VALUE) {
        //
        // We will not have Administrator access to the stack.
        //
        AdminAccess = FALSE;

        V6Stack = CreateFileW(WIN_IPV6_DEVICE_NAME,
                             0,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,   // security attributes
                             OPEN_EXISTING,
                             0,      // flags & attributes
                             NULL);  // template file
        if (V6Stack == INVALID_HANDLE_VALUE) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_3);
// printf("Could not access IPv6 protocol stack.\n");

            exit(1);
        }
    }

    if (argc < 2) {
        usage();
    }
    MakeLowerCase(argv[1]);

    if (!strcmp(argv[1], "sp")) {
        unsigned int Interface;

        if (argc == 2) {
            Interface = 0;
        } else {
            Interface = atoi(argv[2]);
        }

        DisplaySecurityPolicyList(Interface);

    } else if (!strcmp(argv[1], "sa")) {
        DisplaySecurityAssociationList();

    } else if (!strcmp(argv[1], "s")) {
        if (argc != 3) {
            usage();
        }
        CreateSecurityPolicyFile(argv[2]);
        CreateSecurityAssociationFile(argv[2]);

    } else if (!strcmp(argv[1], "l")) {
        if (!AdminAccess)
            ausage();

        if (argc != 3) {
            usage();
        }

        ReadConfigurationFile(argv[2], POLICY);
        ReadConfigurationFile(argv[2], ASSOCIATION);

    } else if (!strcmp(argv[1], "d")) {
        unsigned int Index;
        int Type;

        if (!AdminAccess)
            ausage();

        if (argc != 4) {
            usage();
        }
        MakeLowerCase(argv[3]);
        if (!strcmp(argv[3], "all")) {
            Index = 0;
        } else {
            Index = atol(argv[3]);
            if (Index <= 0) {
                NlsPutMsg(STDOUT, IPSEC_MESSAGE_4);
// printf("Invalid entry number.\n");

                exit(1);
            }
        }

        MakeLowerCase(argv[2]);
        if (!strcmp(argv[2], "sp")) {
            Type = POLICY;
        } else if (!strcmp(argv[2], "sa")) {
            Type = ASSOCIATION;
        } else {
            usage();
        }

        DeleteSecurityEntry(Type, Index);

    } else {
        usage();
    }

    return(0);
}


//* GetSecurityPolicyEntry
//
//  Retrieves a Security Policy from the in-kernel list, given its index.
//  A query for index zero will return the first index on the list.
//
DWORD                                      // Returns: Windows error code.
GetSecurityPolicyEntry(
    unsigned int Interface,                // IF index or 0 to wildcard.
    unsigned long Index,                   // Index to lookup, or 0 for first.
    IPV6_INFO_SECURITY_POLICY_LIST *Info)  // Where to return SP info.
{
    IPV6_QUERY_SECURITY_POLICY_LIST Query;
    unsigned int BytesReturned;

    Query.SPInterface = Interface;
    Query.Index = Index;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_QUERY_SECURITY_POLICY_LIST,
                         &Query, sizeof(Query), Info, sizeof(*Info),
                         &BytesReturned, NULL)) {
        return GetLastError();
    }

    if (BytesReturned != sizeof(*Info))
        return ERROR_GEN_FAILURE;

    return ERROR_SUCCESS;
}


//* CreateSecurityPolicyEntry
//
//  Creates a Security Policy entry on the in-kernel list.
//
DWORD                                    // Returns Windows error code.
CreateSecurityPolicyEntry(
    IPV6_CREATE_SECURITY_POLICY *NewSP)  // Policy to add to kernel.
{
    unsigned int BytesReturned;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_CREATE_SECURITY_POLICY,
                         NewSP, sizeof(*NewSP), NULL, 0,
                         &BytesReturned, NULL)) {
        return GetLastError();
    }

    //
    // When DeviceIoControl is given a null output buffer, the value returned
    // in BytesReturned is undefined.  Therefore, we don't check for 0 here.
    //

    return ERROR_SUCCESS;
}


DWORD
DeleteSecurityPolicyEntry(unsigned int Index)
{
    IPV6_QUERY_SECURITY_POLICY_LIST Query;
    unsigned long BytesReturned;

    Query.Index = Index;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_DELETE_SECURITY_POLICY,
                         &Query, sizeof(Query), NULL, 0,
                         &BytesReturned, NULL)) {
        return GetLastError();
    }

    //
    // When DeviceIoControl is given a null output buffer, the value returned
    // in BytesReturned is undefined.  Therefore, we don't check for 0 here.
    //

    return ERROR_SUCCESS;
}


//* GetSecurityAssociationEntry
//
//  Retrieves a Security Association from the in-kernel list, given its index.
//  A query for index zero will return the first index on the list.
//
DWORD
GetSecurityAssociationEntry(
    unsigned long Index,                        // Index to query; 0 for first.
    IPV6_INFO_SECURITY_ASSOCIATION_LIST *Info)  // Where to return SA info.
{
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST Query;
    unsigned int BytesReturned;

    Query.Index = Index;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_QUERY_SECURITY_ASSOCIATION_LIST,
                         &Query, sizeof(Query), Info, sizeof(*Info),
                         &BytesReturned, NULL)) {
        return GetLastError();
    }

    if (BytesReturned != sizeof(*Info))
        return ERROR_GEN_FAILURE;

    return ERROR_SUCCESS;
}


//* CreateSecurityAssociationEntry
//
//  Creates a Security Association entry on the in-kernel list.
//
DWORD                               // Returns Windows error code.
CreateSecurityAssociationEntry(
    IPV6_CREATE_SA_AND_KEY *NewSA)  // Association (and key) to add to kernel.
{
    unsigned int BytesReturned;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_CREATE_SECURITY_ASSOCIATION,
                         &NewSA->SA, sizeof(NewSA->SA) + NewSA->SA.RawKeySize,
                         NULL, 0, &BytesReturned, NULL)) {
        return GetLastError();
    }

    //
    // When DeviceIoControl is given a null output buffer, the value returned
    // in BytesReturned is undefined.  Therefore, we don't check for 0 here.
    //

    return ERROR_SUCCESS;
}


DWORD
DeleteSecurityAssociationEntry(unsigned int Index)
{
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST Query;
    unsigned long BytesReturned;

    Query.Index = Index;

    if (!DeviceIoControl(V6Stack, IOCTL_IPV6_DELETE_SECURITY_ASSOCIATION,
                         &Query, sizeof(Query), NULL, 0,
                         &BytesReturned, NULL)) {
        return GetLastError();
    }

    //
    // When DeviceIoControl is given a null output buffer, the value returned
    // in BytesReturned is undefined.  Therefore, we don't check for 0 here.
    //

    return ERROR_SUCCESS;
}


//* DeleteSecurityEntry - delete a security policy or association entry.
//
//  Note: In the "delete all" case, it'd be much simpler not to query and
//  just delete wildcard until the list came up empty, but then we couldn't
//  report the index of any entries that failed to delete.
// 
void
DeleteSecurityEntry(
    int Type,            // Type of entry (POLICY or ASSOCIATION).
    unsigned int Index)  // Index of entry to delete (0 to delete all).
{
    int EntriesDeleted = 0;
    int All = FALSE;
    DWORD Error;

    if (Index == 0) {
        All = TRUE;
    }

    do {
        if (All) {
            //
            // Deleting all entries.  Find first on (remaining) list.
            //
            if (Type == POLICY) {
                IPV6_INFO_SECURITY_POLICY_LIST Info;

                Error = GetSecurityPolicyEntry(0, 0, &Info);
                if (Error == ERROR_SUCCESS) {
                    Index = Info.SPIndex;  // First entry.
                } else if (Error == ERROR_NO_MATCH) {
                    Index = 0;  // No more entries exist.
                    break;
                } else {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_5,
                              Error, GetErrorString(Error));
// printf("\nError %u accessing Security Policies: %s.\n",
//        Error, strerror(Error));

                    exit(1);
                }
            } else {
                IPV6_INFO_SECURITY_ASSOCIATION_LIST Info;

                Error = GetSecurityAssociationEntry(0, &Info);
                if (Error == ERROR_SUCCESS) {
                    Index = Info.SAIndex;  // First entry.
                } else if (Error == ERROR_NO_MATCH) {
                    Index = 0;  // No more entries exist.
                    break;
                } else {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_6,
                              Error, GetErrorString(Error));
// printf("\nError %u accessing Security Associations: %s.\n",
//        Error, strerror(Error));

                    exit(1);
                }
            }
        }

        if (Type == POLICY) {
            Error = DeleteSecurityPolicyEntry(Index);
        } else {
            Error = DeleteSecurityAssociationEntry(Index);
        }

        if (Error == ERROR_SUCCESS) {
            EntriesDeleted++;
        } else {
            if (Error == ERROR_NO_MATCH) {
                if (!All) {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_7, Index);
// printf("Error deleting entry %u: entry doesn't exist.\n", Index);

                }
                // Otherwise silently ignore ...
            } else if (Error == ERROR_GEN_FAILURE) {
                NlsPutMsg(STDOUT, IPSEC_MESSAGE_8, Index);
// printf("Error deleting entry %u.\n", Index);

            } else {
                if (Type) {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_9,
                              Error, GetErrorString(Error));
                }    else {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_56,
                              Error, GetErrorString(Error));
                }
// printf("Error %u accessing security %s: %s.\n", Error,
//        Type ? "policies" : "associations", strerror(Error));

                break;
            }
        }

    } while (All);

    if (Type == POLICY) {
        if (EntriesDeleted == 1) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_10, EntriesDeleted);
        } else {  
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_57, EntriesDeleted);
        }
// printf("Deleted %d polic%s (and any dependent associations).\n",
//        EntriesDeleted, EntriesDeleted == 1 ? "y" : "ies");

    } else {
        if (EntriesDeleted == 1) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_11, EntriesDeleted);
        } else {  
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_58, EntriesDeleted);
        }
// printf("Deleted %d association%s.\n", EntriesDeleted,
//        EntriesDeleted == 1 ? "" : "s");

    }
}

//* ParseAddress - convert address string to binary representation.
//
int
ParseAddress(char *AddrString, IPv6Addr *Address)
{
    struct addrinfo Hint;
    struct addrinfo *Result;

    memset(&Hint, 0, sizeof Hint);
    Hint.ai_family = PF_INET6;

    if (getaddrinfo(AddrString, NULL, &Hint, &Result))
        return FALSE;

    *Address = ((struct sockaddr_in6 *)Result->ai_addr)->sin6_addr;
    freeaddrinfo(Result);

    return TRUE;    
}


//* FormatIPv6Address - convert binary address to string representation.
//
//  This is only used in printing SAs, thus the unspecified address
//  means "take from policy".
//
char *
FormatIPv6Address(IPv6Addr *Address)
{
    static char Buffer[46];

    if (IN6_ADDR_EQUAL(Address, &UnspecifiedAddr)) {
        strcpy(Buffer, "POLICY");
    } else {
        struct sockaddr_in6 SockAddr;

        memset(&SockAddr, 0, sizeof(SockAddr));
        SockAddr.sin6_family = AF_INET6;
        memcpy(&SockAddr.sin6_addr, Address, sizeof(*Address));

        if (getnameinfo((struct sockaddr *)&SockAddr, sizeof(SockAddr), Buffer,
                        sizeof(Buffer), NULL, 0, NI_NUMERICHOST)) {
            strcpy(Buffer, "<invalid>");
        }
    }

    return Buffer;
}


int
ParseSAAdressEntry(char *AddrString, IPv6Addr *Address)
{
    if (!strcmp(AddrString, "POLICY")) {
        *Address = UnspecifiedAddr;
    } else {
        if (!ParseAddress(AddrString, Address)) {
            return(FALSE);
        }
    }

    return(TRUE);
}


char *
FormatSPAddressEntry(IPv6Addr *AddressStart, IPv6Addr *AddressEnd,
                     unsigned int AddressField)
{
    const char *PointerReturn;
    static char Buffer[100];
    char TempBuffer[100];
    DWORD Buflen = sizeof Buffer;
    struct sockaddr_in6 sin6;

    switch (AddressField) {

    case WILDCARD_VALUE:            
        strcpy(Buffer, "*");
        break;

    case SINGLE_VALUE:        
        sin6.sin6_family = AF_INET6;
        sin6.sin6_port = 0;
        sin6.sin6_flowinfo = 0;
        sin6.sin6_scope_id = 0;

        memcpy(&sin6.sin6_addr, AddressStart, sizeof *AddressStart);
                
        if (WSAAddressToString((struct sockaddr *) &sin6,
            sizeof sin6,
            NULL,       // LPWSAPROTOCOL_INFO
            Buffer,
            &Buflen) == SOCKET_ERROR) {
            strcpy(Buffer, "???");
        }       

        break;

    case RANGE_VALUE:
        sin6.sin6_family = AF_INET6;
        sin6.sin6_port = 0;
        sin6.sin6_flowinfo = 0;
        sin6.sin6_scope_id = 0;

        memcpy(&sin6.sin6_addr, AddressStart, sizeof *AddressStart);
                
        if (WSAAddressToString((struct sockaddr *) &sin6,
            sizeof sin6,
            NULL,       // LPWSAPROTOCOL_INFO
            Buffer,
            &Buflen) == SOCKET_ERROR) {
            strcpy(Buffer, "???");
        }  
        
        memcpy(&sin6.sin6_addr, AddressEnd, sizeof *AddressEnd);
        sin6.sin6_family = AF_INET6;
        sin6.sin6_port = 0;
        sin6.sin6_flowinfo = 0;
        sin6.sin6_scope_id = 0;  
        
        if (WSAAddressToString((struct sockaddr *) &sin6,
            sizeof sin6,
            NULL,       // LPWSAPROTOCOL_INFO
            TempBuffer,
            &Buflen) == SOCKET_ERROR) {
            strcpy(TempBuffer, "???");
        } 
        
        strcat(Buffer, "-");
        strcat(Buffer, TempBuffer);        

        break;

    default:
        strcpy(Buffer, "???");

        break;
    }

    return Buffer;
}


//* Parse an address entry
//
//  Valid forms include:
//  The wildcard indicator, "*"
//  A single address, e.g. "2001::1"
//  A range of addresses, e.g. "2001::1-2001::ffff"
//
void
ParseSPAddressEntry(
    char *EntryString,          // String we're given to parse.
    IPv6Addr *AddressStart,     // Return start of range, or single address.
    IPv6Addr *AddressEnd,       // Return end of range, or unspecified.
    unsigned int *AddressType)  // Return entry type: WILDCARD, SINGLE, RANGE.
{
    char *RangeEntry;

    RangeEntry = strchr(EntryString, '-');
    if (RangeEntry == NULL) {
        //
        // Should be a wildcard, or single value.
        //
        if (!strcmp(EntryString, "*")) {
            *AddressType = WILDCARD_VALUE;
            *AddressStart = UnspecifiedAddr;

        } else {
            if (!ParseAddress(EntryString, AddressStart)) {
                NlsPutMsg(STDOUT, IPSEC_MESSAGE_12, EntryString);
// printf("Bad IPv6 Address, %s.\n", EntryString);

                exit(1);
            }

            *AddressType = SINGLE_VALUE;
        }

        *AddressEnd = UnspecifiedAddr;

    } else {

        //
        // We were given a range.
        // Break entry string into two and parse separately.
        //
        *RangeEntry++ = '\0';

        if (!ParseAddress(EntryString, AddressStart)) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_13, EntryString);
// printf("Bad IPv6 Start Address Range, %s.\n", EntryString);

            exit(1);
        }

        if (!ParseAddress(RangeEntry, AddressEnd)) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_14, RangeEntry);
// printf("Bad IPv6 End Address Range, %s.\n", RangeEntry);

            exit(1);
        }

        *AddressType = RANGE_VALUE;
    }
}


char *
FormatIPSecProto(unsigned int ProtoNum)
{
    char *Result;

    switch(ProtoNum) {

    case IP_PROTOCOL_AH:
        Result = "AH";
        break;

    case IP_PROTOCOL_ESP:
        Result = "ESP";
        break;

    case NONE:
        Result = "NONE";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned int
ParseIPSecProto(char *Protocol)
{
    unsigned int Result;

    if (!strcmp(Protocol, "AH")) {
        Result = IP_PROTOCOL_AH;

    } else if (!strcmp(Protocol, "ESP")) {
        Result = IP_PROTOCOL_ESP;

    } else if (!strcmp(Protocol, "NONE")) {
        Result = NONE;

    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_15, Protocol);
// printf("Bad IPsec Protocol Value Entry %s.\n", Protocol);

        exit(1);
    }

    return Result;
}


char *
FormatIPSecMode(unsigned int Mode)
{
    char *Result;

    switch(Mode) {

    case TRANSPORT:
        Result = "TRANSPORT";
        break;

    case TUNNEL:
        Result = "TUNNEL";
        break;

    case NONE:
        Result = "*";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned int
ParseIPSecMode(char *Mode)
{
    unsigned int Result;

    if (!strcmp(Mode, "TRANSPORT")) {
        Result = TRANSPORT;

    } else if (!strcmp(Mode, "TUNNEL")) {
        Result = TUNNEL;

    } else if (!strcmp(Mode, "*")) {
        Result = NONE;

    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_16, Mode);
// printf("Bad IPsec Mode Value Entry %s.\n", Mode);

        exit(1);
    }

    return Result;
}


char *
FormatRemoteGW(unsigned int Mode, IPv6Addr *Address)
{
    switch (Mode) {

    case TRANSPORT:
        return "*";

    case TUNNEL:
    case NONE:
        if (IN6_ADDR_EQUAL(Address, &UnspecifiedAddr)) {
            return "*";
        } else {
            return FormatIPv6Address(Address);
        }
    }

    return NULL;
}


int
ParseRemoteGW(
    char *AddrString,
    IPv6Addr *Address,
    unsigned int Mode)
{
    switch (Mode) {

    case TRANSPORT:
        *Address = UnspecifiedAddr;
        break;

    case TUNNEL:
    case NONE:
        if (!strcmp(AddrString, "*")) {
            *Address = UnspecifiedAddr;

        } else
            if (!ParseAddress(AddrString, Address)) {
                NlsPutMsg(STDOUT, IPSEC_MESSAGE_17);
// printf("Bad IPv6 Address for RemoteGWIPAddr.\n");

                exit(1);
            }
        break;

    default:
        break;
    }

    return TRUE;
}


char *
FormatSATransportProto(unsigned short Protocol)
{
    char *Result;

    switch (Protocol) {

    case IP_PROTOCOL_TCP:
        Result = "TCP";
        break;

    case IP_PROTOCOL_UDP:
        Result = "UDP";
        break;

    case IP_PROTOCOL_ICMPv6:
        Result = "ICMP";
        break;

    case NONE:
        Result = "POLICY";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned short
ParseSATransportProto(char *Protocol)
{
    unsigned short Result;

    if (!strcmp(Protocol, "TCP")) {
        Result = IP_PROTOCOL_TCP;

    } else if (!strcmp(Protocol, "UDP")) {
        Result = IP_PROTOCOL_UDP;

    } else if (!strcmp(Protocol, "ICMP")) {
        Result = IP_PROTOCOL_ICMPv6;

    } else if (!strcmp(Protocol, "POLICY")) {
        Result = NONE;

    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_18, Protocol);
// printf("Bad Protocol Value %s.\n", Protocol);

        exit(1);
    }

    return Result;
}


char *
FormatSPTransportProto(unsigned short Protocol)
{
    char *Result;

    switch (Protocol) {

    case IP_PROTOCOL_TCP:
        Result = "TCP";
        break;

    case IP_PROTOCOL_UDP:
        Result = "UDP";
        break;

    case IP_PROTOCOL_ICMPv6:
        Result = "ICMP";
        break;

    case NONE:
        Result = "*";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned short
ParseSPTransportProto(char *Protocol)
{
    unsigned short Result;

    if (!strcmp(Protocol, "TCP")) {
        Result = IP_PROTOCOL_TCP;

    } else if (!strcmp(Protocol, "UDP")) {
        Result = IP_PROTOCOL_UDP;

    } else if (!strcmp(Protocol, "ICMP")) {
            Result = IP_PROTOCOL_ICMPv6;

    } else if (!strcmp(Protocol, "*")) {
        Result = NONE;

    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_18, Protocol);
// printf("Bad Protocol Value %s.\n", Protocol);

        exit(1);
    }

    return Result;
}


char *
FormatSAPort(unsigned short Port)
{
    static char Buffer[11];

    if (Port == NONE) {
        strcpy(Buffer, "POLICY");
    } else {
        _itoa(Port, Buffer, 10);
    }

    return Buffer;
}


unsigned int
ParseSAPort(char *Port)
{
    unsigned int Result;

    if (!strcmp(Port, "POLICY") || !strcmp(Port, " ")) {
        Result = NONE;
    } else {
        Result = atoi(Port);
    }

    return Result;
}


char *
FormatSPPort(
    unsigned short PortStart,
    unsigned short PortEnd,
    unsigned int PortField)
{
    char TempBuffer[11];
    static char Buffer[22];

    switch (PortField) {

    case WILDCARD_VALUE:
        strcpy(Buffer, "*");
        break;

    case RANGE_VALUE:
        _itoa(PortEnd, TempBuffer, 10);
        _itoa(PortStart, Buffer, 10);
        strcat(Buffer, "-");
        strcat(Buffer, TempBuffer);
        break;

    case SINGLE_VALUE:
        _itoa(PortStart, Buffer, 10);
        break;

    default:
        strcpy(Buffer, "???");
        break;
    }

    return Buffer;
}


void
ParseSPPort(
    char *EntryString,
    unsigned short *PortStart,
    unsigned short *PortEnd,
    unsigned int *PortField)
{
    char *RangeEntry;

    RangeEntry = strchr(EntryString, '-');

    if (RangeEntry == NULL) {
        //
        // Should be a wildcard, or a single value.
        //
        if (!strcmp(EntryString, "*")) {
            *PortField = WILDCARD_VALUE;
            *PortStart = NONE;
        } else {
            *PortField = SINGLE_VALUE;
            *PortStart = (unsigned short)atoi(EntryString);
        }

        *PortEnd = NONE;

    } else {

        //
        // We were given a range.
        // Break entry string into two and parse separately.
        //
        *RangeEntry++ = '\0';

        *PortStart = (unsigned short)atoi(EntryString);
        *PortEnd = (unsigned short)atoi(RangeEntry);
        *PortField = RANGE_VALUE;
    }
}


unsigned char *
FormatSelector(unsigned int Selector)
{
    char *Buffer;

    switch (Selector) {

    case PACKET_SELECTOR:
        Buffer = "+";
        break;

    case POLICY_SELECTOR:
        Buffer = "-";
        break;

    default:
        Buffer = "?";
        break;
    }

    return Buffer;
}


unsigned int
ParseSelector(char *Selector)
{
    unsigned int Result;

    if (!strcmp(Selector, "+")) {
        Result = PACKET_SELECTOR;
    } else if (!strcmp(Selector, "-")) {
        Result = POLICY_SELECTOR;
    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_19);
// printf("Bad value for one of the selector types.\n");

        exit(1);
    }

    return Result;
}


char *
FormatIndex(unsigned long Index)
{
    static char Buffer[11];

    switch (Index) {

    case NONE:
        strcpy(Buffer, "NONE");
        break;

    default:
        _itoa(Index, Buffer, 10);
        break;
    }

    return Buffer;
}


unsigned long
ParseIndex(char *Index)
{
    unsigned long Result;

    if (!strcmp(Index, "NONE")) {
        Result = NONE;
    } else {
        Result = atoi(Index);
    }

    return Result;
}


char *
FormatDirection(unsigned int Direction)
{
    char *Buffer;

    switch (Direction) {

    case INBOUND:
        Buffer = "INBOUND";
        break;

    case OUTBOUND:
        Buffer = "OUTBOUND";
        break;

    case BIDIRECTIONAL:
        Buffer = "BIDIRECT";
        break;

    default:
        Buffer = "???";
        break;
    }

    return Buffer;
}


unsigned int 
ParseDirection(char *Direction)
{
    unsigned int Result;

    if (!strcmp(Direction, "INBOUND")) {
        Result = INBOUND;

    } else if (!strcmp(Direction, "OUTBOUND")) {
        Result = OUTBOUND;

    } else if (!strcmp(Direction, "BIDIRECT")) {
        Result = BIDIRECTIONAL;

    } else {
         NlsPutMsg(STDOUT, IPSEC_MESSAGE_20, Direction);
// printf("Bad Direction Value Entry %s.\n", Direction);

         exit(1);
    }

    return Result;
}


char *
FormatIPSecAction(unsigned int PolicyFlag)
{
    char *Result;

    switch (PolicyFlag) {

    case IPSEC_BYPASS:
        Result = "BYPASS";
        break;

    case IPSEC_DISCARD:
        Result = "DISCARD";
        break;

    case IPSEC_APPLY:
        Result = "APPLY";
        break;

    case IPSEC_APPCHOICE:
        Result = "APPCHOICE";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned int
ParseIPSecAction(char *Action)
{
    unsigned int Result;

    if (!strcmp(Action, "BYPASS")) {
        Result = IPSEC_BYPASS;

    } else if (!strcmp(Action, "DISCARD")) {
        Result = IPSEC_DISCARD;

    } else if (!strcmp(Action, "APPLY")) {
        Result = IPSEC_APPLY;

    } else if (!strcmp(Action, "APPCHOICE")) {
        Result = IPSEC_APPCHOICE;

    } else {
         NlsPutMsg(STDOUT, IPSEC_MESSAGE_21, Action);
// printf("Bad IPSec Action Value Entry %s.\n", Action);

         exit(1);
    }

    return Result;
}


char *
FormatAuthAlg(unsigned int AlgorithmId)
{
    char *Result;

    switch (AlgorithmId) {

    case ALGORITHM_NULL:
        Result = "NULL";
        break;

    case ALGORITHM_HMAC_MD5:
        Result = "HMAC-MD5";
        break;

    case ALGORITHM_HMAC_MD5_96:
        Result = "HMAC-MD5-96";
        break;

    case ALGORITHM_HMAC_SHA1:
        Result = "HMAC-SHA1";
        break;

    case ALGORITHM_HMAC_SHA1_96:
        Result = "HMAC-SHA1-96";
        break;

    default:
        Result = "???";
        break;
    }

    return Result;
}


unsigned int
ParseAuthAlg(char *AuthAlg)
{
    if (!strcmp(AuthAlg, "NULL")) {
        return ALGORITHM_NULL;
    }

    if (!strcmp(AuthAlg, "HMAC-MD5")) {
        return ALGORITHM_HMAC_MD5;
    }

    if (!strcmp(AuthAlg, "HMAC-MD5-96")) {
        return ALGORITHM_HMAC_MD5_96;
    }

    if (!strcmp(AuthAlg, "HMAC-SHA1")) {
        return ALGORITHM_HMAC_SHA1;
    }

    if (!strcmp(AuthAlg, "HMAC-SHA1-96")) {
        return ALGORITHM_HMAC_SHA1_96;
    }

    NlsPutMsg(STDOUT, IPSEC_MESSAGE_22, AuthAlg);
// printf("Bad Authentication Algorithm Value Entry %s.\n", AuthAlg);

    exit(1);
}


unsigned int 
ReadKeyFile(
    char *FileName,
    unsigned char *Key)
{
    FILE *KeyFile; 
    unsigned int KeySize;

    if (!strcmp(FileName, "NONE")) {
        // This is for NULL algorithm.
        strcpy(Key, "NO KEY");
        KeySize = strlen(Key);
    } else {
        if ((KeyFile = fopen(FileName, "r")) == NULL) {
            return 0;
        }

        KeySize = fread(Key, sizeof(unsigned char), MAX_KEY_SIZE, KeyFile);

        fclose(KeyFile);
    }

    return KeySize;
}


//* PrintSecurityPolicyEntry
//
//  Print out the security policy entry, "nicely"? formatted,
//  to the given file.
//
PrintSecurityPolicyEntry(
    FILE *File,
    IPV6_INFO_SECURITY_POLICY_LIST *SPEntry)
{
    fprintf(File, "%-10lu", SPEntry->SPIndex);
    fprintf(File, "%-2s", FormatSelector(SPEntry->RemoteAddrSelector));
    fprintf(File, "%-45s", FormatSPAddressEntry(&(SPEntry->RemoteAddr),
                                                &(SPEntry->RemoteAddrData),
                                                SPEntry->RemoteAddrField));
    fprintf(File, "%-2s", FormatSelector(SPEntry->LocalAddrSelector));
    fprintf(File, "%-45s", FormatSPAddressEntry(&(SPEntry->LocalAddr),
                                                &(SPEntry->LocalAddrData),
                                                SPEntry->LocalAddrField));
    fprintf(File, "%-2s", FormatSelector(SPEntry->TransportProtoSelector));
    fprintf(File, "%-12s", FormatSPTransportProto(SPEntry->TransportProto));
    fprintf(File, "%-2s", FormatSelector(SPEntry->RemotePortSelector));
    fprintf(File, "%-12s", FormatSPPort(SPEntry->RemotePort,
                                        SPEntry->RemotePortData, 
                                        SPEntry->RemotePortField));
    fprintf(File, "%-2s", FormatSelector(SPEntry->LocalPortSelector));
    fprintf(File, "%-12s", FormatSPPort(SPEntry->LocalPort,
                                        SPEntry->LocalPortData,
                                        SPEntry->LocalPortField));
    fprintf(File, "%-15s", FormatIPSecProto(SPEntry->IPSecProtocol));
    fprintf(File, "%-12s", FormatIPSecMode(SPEntry->IPSecMode));
    fprintf(File, "%-45s", FormatRemoteGW(SPEntry->IPSecMode,
                                          &(SPEntry->RemoteSecurityGWAddr)));
    fprintf(File, "%-15s", FormatIndex(SPEntry->SABundleIndex));
    fprintf(File, "%-12s", FormatDirection(SPEntry->Direction));
    fprintf(File, "%-12s", FormatIPSecAction(SPEntry->IPSecAction));
    fprintf(File, "%-15u", SPEntry->SPInterface);
    fprintf(File, ";\n");
}


//* PrintSecurityPolicyHeader
//
//  Print out the security policy header fields to the given file.
//
PrintSecurityPolicyHeader(
    FILE *File)
{
    int Loop;

    fprintf(File, "%-10s", "Policy");
    fprintf(File, "%-2s", " ");
    fprintf(File, "%-45s", "RemoteIPAddr");
    fprintf(File, "%-2s", " ");
    fprintf(File, "%-45s", "LocalIPAddr");
    fprintf(File, "%-2s", " ");
    fprintf(File, "%-12s", "Protocol");
    fprintf(File, "%-2s", " ");
    fprintf(File, "%-12s", "RemotePort");
    fprintf(File, "%-2s", " ");
    fprintf(File, "%-12s", "LocalPort");
    fprintf(File, "%-15s", "IPSecProtocol");
    fprintf(File, "%-12s", "IPSecMode");
    fprintf(File, "%-45s", "RemoteGWIPAddr");
    fprintf(File, "%-15s", "SABundleIndex");
    fprintf(File, "%-12s", "Direction");
    fprintf(File, "%-12s", "Action");
    fprintf(File, "%-15s", "InterfaceIndex");
    fprintf(File, "\n");

    for (Loop = 0; Loop < SP_FILE_BORDER; Loop++) {
        fprintf(File, "_");
    }
    fprintf(File, "\n");
}


//* PrintSecurityPolicyFooter
//
//  Print out the security policy footer to the given file.
//
PrintSecurityPolicyFooter(
    FILE *File)
{
    int Loop;

    for (Loop = 0; Loop < SP_FILE_BORDER; Loop++) {
        fprintf(File, "_");
    }
    fprintf(File, "\n\n");

    fprintf(File, "- = Take selector from policy.\n");
    fprintf(File, "+ = Take selector from packet.\n");
}


//* PrintSecurityAssociationEntry
//
//  Print out the security association entry, "nicely"? formatted,
//  to the given file.
//
PrintSecurityAssociationEntry(
    FILE *File,
    IPV6_INFO_SECURITY_ASSOCIATION_LIST *SAEntry)
{
    fprintf(File, "%-10lu", SAEntry->SAIndex);
    fprintf(File, "%-15lu", SAEntry->SPI);
    fprintf(File, "%-45s", FormatIPv6Address(&(SAEntry->SADestAddr)));
    fprintf(File, "%-45s", FormatIPv6Address(&(SAEntry->DestAddr)));
    fprintf(File, "%-45s", FormatIPv6Address(&(SAEntry->SrcAddr)));
    fprintf(File, "%-12s", FormatSATransportProto(SAEntry->TransportProto));
    fprintf(File, "%-12s", FormatSAPort(SAEntry->DestPort));
    fprintf(File, "%-12s", FormatSAPort(SAEntry->SrcPort));
    fprintf(File, "%-12s", FormatAuthAlg(SAEntry->AlgorithmId));
    fprintf(File, "%-15s", " ");
    fprintf(File, "%-12s", FormatDirection(SAEntry->Direction));
    fprintf(File, "%-15lu", SAEntry->SecPolicyIndex);
    fprintf(File, "%-1;");
    fprintf(File, "\n");
}


//* PrintSecurityAssociationHeader
//
//  Print out the security association header fields to the given file.
//
PrintSecurityAssociationHeader(
    FILE *File)
{
    int Loop;

    fprintf(File, "Security Association List\n\n");

    fprintf(File, "%-10s", "SAEntry");
    fprintf(File, "%-15s", "SPI");
    fprintf(File, "%-45s", "SADestIPAddr");
    fprintf(File, "%-45s", "DestIPAddr");
    fprintf(File, "%-45s", "SrcIPAddr");
    fprintf(File, "%-12s", "Protocol");
    fprintf(File, "%-12s", "DestPort");
    fprintf(File, "%-12s", "SrcPort");
    fprintf(File, "%-12s", "AuthAlg");
    fprintf(File, "%-15s", "KeyFile");
    fprintf(File, "%-12s", "Direction");
    fprintf(File, "%-15s", "SecPolicyIndex");
    fprintf(File, "\n");

    for (Loop = 0; Loop < SA_FILE_BORDER; Loop++) {
        fprintf(File, "_");
    }
    fprintf(File, "\n");
}


//* PrintSecurityAssociationFooter
//
//  Print out the security association footer to the given file.
//
PrintSecurityAssociationFooter(
    FILE *File)
{
    int Loop;

    for (Loop = 0; Loop < SA_FILE_BORDER; Loop++) {
        fprintf(File, "_");
    }
    fprintf(File, "\n");
}


void
CreateSecurityPolicyFile(char *BaseName)
{
    IPV6_INFO_SECURITY_POLICY_LIST Info;
    char FileName[MAX_PATH + 1];
    FILE *File;
    unsigned long Index;
    DWORD Error;

    //
    // Copy the filename from the command line to our own buffer so we can
    // append an extension to it.  We reserve at least 4 characters for the
    // extension.  The strncpy function will zero fill up to the limit of
    // the copy, thus the character at the limit will be NULL unless the
    // command line field was too long to fit.
    //
    strncpy(FileName, BaseName, MAX_PATH - 3);
    if (FileName[MAX_PATH - 4] != 0) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_23);
// printf("\nFilename length is too long.\n");

        exit(1);
    }
    strcat(FileName, ".spd");

    if ((File = fopen(FileName, "w+")) == NULL) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_24, FileName);
// printf("\nFile %s could not be opened.\n", FileName);

        exit(1);
    }

    //
    // Find index of first policy on the in-kernel list.
    //
    Error = GetSecurityPolicyEntry(0, 0, &Info);
    switch (Error) {
    case ERROR_SUCCESS:
        Index = Info.SPIndex;  // First entry.
        break;
    case ERROR_NO_MATCH:
        Index = 0;  // No entries exist.
        break;
    default:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_25, Error, GetErrorString(Error));
// printf("\nError %u reading Security Policies: %s.\n",
//        Error, strerror(Error));

        Index = 0;
        break;
    }

    fprintf(File, "\nSecurity Policy List\n\n");
    PrintSecurityPolicyHeader(File);

    //
    // Loop through all the policies on the list.
    //
    while (Index != 0) {
        Error = GetSecurityPolicyEntry(0, Index, &Info);
        if (Error != ERROR_SUCCESS) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_25, Error, GetErrorString(Error));
// printf("\nError %u reading Security Policies: %s.\n",
//        Error, strerror(Error));

            break;
        }
        PrintSecurityPolicyEntry(File, &Info);
        Index = Info.NextSPIndex;
    }

    PrintSecurityPolicyFooter(File);
    fclose(File);
    NlsPutMsg(STDOUT, IPSEC_MESSAGE_26, FileName);
// printf("Security Policy Data -> %s\n", FileName);


    return;
}


void
CreateSecurityAssociationFile(char *BaseName)
{
    IPV6_INFO_SECURITY_ASSOCIATION_LIST Info;
    char FileName[MAX_PATH + 1];
    FILE *File;
    unsigned long Index;
    DWORD Error;

    //
    // Copy the filename from the command line to our own buffer so we can
    // append an extension to it.  We reserve at least 4 characters for the
    // extension.  The strncpy function will zero fill up to the limit of
    // the copy, thus the character at the limit will be NULL unless the
    // command line field was too long to fit.
    //
    strncpy(FileName, BaseName, MAX_PATH - 3);
    if (FileName[MAX_PATH - 4] != 0) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_27);
// printf("\nFilename length is too long.\n");

        exit(1);
    }
    strcat(FileName, ".sad");

    if ((File = fopen(FileName, "w+")) == NULL) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_28, FileName);
// printf("\nFile %s could not be opened.\n", FileName);

        exit(1);
    }

    //
    // Find index of first association on the in-kernel list.
    //
    Error = GetSecurityAssociationEntry(0, &Info);
    switch (Error) {
    case ERROR_SUCCESS:
        Index = Info.SAIndex;  // First entry.
        break;
    case ERROR_NO_MATCH:
        Index = 0;  // No entries exist.
        break;
    default:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_29, Error, GetErrorString(Error));
// printf("\nError %u reading Security Associations: %s.\n",
//        Error, strerror(Error));

        Index = 0;
        break;
    }

    PrintSecurityAssociationHeader(File);

    //
    // Loop through all the associations on the list.
    //
    while (Index != 0) {    
        Error = GetSecurityAssociationEntry(Index, &Info);
        if (Error != ERROR_SUCCESS) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_29, Error, GetErrorString(Error));
// printf("\nError %u reading Security Associations: %s.\n",
//        Error, strerror(Error));

            break;
        }
        PrintSecurityAssociationEntry(File, &Info);
        Index = Info.NextSAIndex;
    }

    PrintSecurityAssociationFooter(File);

    fclose(File);

    NlsPutMsg(STDOUT, IPSEC_MESSAGE_30, FileName);
// printf("Security Association Data -> %s\n", FileName);


    return;
}


void
DisplaySecurityPolicyList(unsigned int Interface)
{
    IPV6_INFO_SECURITY_POLICY_LIST Info;
    unsigned long Index;
    DWORD Error;

    //
    // Find index of first policy on the in-kernel list.
    //
    Error = GetSecurityPolicyEntry(Interface, 0, &Info);
    switch (Error) {
    case ERROR_SUCCESS:
        Index = Info.SPIndex;  // First entry.
        break;
    case ERROR_NOT_FOUND:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_31, Interface);
// printf("Interface %u does not exist.\n", Interface);

        exit(1);
    case ERROR_NO_MATCH:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_32);
// printf("No Security Policies exist");

        if (Interface != 0) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_33, Interface);
// printf(" for interface %d", Interface);

        }
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_34);
// printf(".\n");

        exit(1);
    default:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_25, Error, GetErrorString(Error));
// printf("\nError %u reading Security Policies: %s.\n",
//        Error, strerror(Error));

        exit(1);
    }

    if (Interface == 0) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_35);
// printf("\nAll Security Policies\n\n");

    } else {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_36, Interface);
// printf("\nSecurity Policy List for Interface %d\n\n", Interface);

    }

    PrintSecurityPolicyHeader(stdout);

    //
    // Loop through all the policies on the list.
    //
    while (Index != 0) {
        Error = GetSecurityPolicyEntry(Interface, Index, &Info);
        if (Error != ERROR_SUCCESS) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_25, Error, GetErrorString(Error));
// printf("\nError %u reading Security Policies: %s.\n",
//        Error, strerror(Error));

            exit(1);
        }
        PrintSecurityPolicyEntry(stdout, &Info);
        Index = Info.NextSPIndex;
    }

    PrintSecurityPolicyFooter(stdout);

    return;
}


void
DisplaySecurityAssociationList(void)
{
    IPV6_INFO_SECURITY_ASSOCIATION_LIST Info;
    unsigned long Index;
    DWORD Error;

    //
    // Find index of first association on the in-kernel list.
    //
    Error = GetSecurityAssociationEntry(0, &Info);
    switch (Error) {
    case ERROR_SUCCESS:
        Index = Info.SAIndex;  // First entry.
        break;
    case ERROR_NO_MATCH:
        // There are no SA entries yet.
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_37);
// printf("No Security Associations exist.\n");

        exit(1);
    default:
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_29, Error, GetErrorString(Error));
// printf("\nError %u reading Security Associations: %s.\n",
//        Error, strerror(Error));

        exit(1);
    }

    NlsPutMsg(STDOUT, IPSEC_MESSAGE_38);
// printf("\n");

    PrintSecurityAssociationHeader(stdout);

    //
    // Loop through all the associations on the list.
    //
    while (Index != 0) {
        Error = GetSecurityAssociationEntry(Index, &Info);
        if (Error != ERROR_SUCCESS) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_29, Error, GetErrorString(Error));
// printf("\nError %u reading Security Associations: %s.\n",
//        Error, strerror(Error));

            exit(1);
        }
        PrintSecurityAssociationEntry(stdout, &Info);
        Index = Info.NextSAIndex;
    }

    PrintSecurityAssociationFooter(stdout);

    return;
}


int
ParseSPLine(
    char *Line,                       // Line to parse.
    IPV6_CREATE_SECURITY_POLICY *SP)  // Where to put the data.
{
    char *Token;

    Token = strtok(Line, " ");
    if (Token == NULL) {
        return FALSE;
    }

    // Policy Number.
    SP->SPIndex = atol(Token);

    // RemoteIPAddr Selector.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->RemoteAddrSelector = ParseSelector(Token);

    // RemoteIPAddr.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSPAddressEntry(Token, &SP->RemoteAddr, &SP->RemoteAddrData,
                        &SP->RemoteAddrField);

    // LocalIPAddr Selector.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->LocalAddrSelector = ParseSelector(Token);

    // LocalIPAddr.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSPAddressEntry(Token, &SP->LocalAddr, &SP->LocalAddrData,
                        &SP->LocalAddrField);

    // Protocol Selector.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->TransportProtoSelector = ParseSelector(Token);

    // Protocol.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->TransportProto = ParseSPTransportProto(Token);

    // RemotePort Selector.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->RemotePortSelector = ParseSelector(Token);

    // RemotePort.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSPPort(Token, &SP->RemotePort, &SP->RemotePortData,
                &SP->RemotePortField);

    // LocalPort Selector.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->LocalPortSelector = ParseSelector(Token);

    // Local Port.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSPPort(Token, &SP->LocalPort, &SP->LocalPortData,
                &SP->LocalPortField);

    // IPSecProtocol.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->IPSecProtocol = ParseIPSecProto(Token);

    // IPSecMode.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->IPSecMode = ParseIPSecMode(Token);

    // RemoteGWIPAddr.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseRemoteGW(Token, &SP->RemoteSecurityGWAddr, SP->IPSecMode);

    // SABundleIndex.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->SABundleIndex = ParseIndex(Token);

    // Direction.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->Direction = ParseDirection(Token);

    // Action.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->IPSecAction = ParseIPSecAction(Token);

    // Interface SP.
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SP->SPInterface = atol(Token);

    // End of current policy.
    // REVIEW: Insist that nothing follows final valid field on the line?
    // if ((Token = strtok(NULL, " ")) != NULL) return FALSE;

    return TRUE;
}


int
ParseSALine(
    char *Line,                        // Line to parse.
    IPV6_CREATE_SA_AND_KEY *SAAndKey)  // Where to put the data.
{
    char *Token;
    IPV6_CREATE_SECURITY_ASSOCIATION *SA = &(SAAndKey->SA);

    Token = strtok(Line, " ");
    if (Token == NULL) {
        return FALSE;
    }

    // Security Association Entry Number.
    SA->SAIndex = atol(Token);

    // SPI
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->SPI = atol(Token);

    // SADestAddr
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSAAdressEntry(Token, &SA->SADestAddr);

    // DestIPAddr
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSAAdressEntry(Token, &SA->DestAddr);

    // SrcIPAddr
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    ParseSAAdressEntry(Token, &SA->SrcAddr);

    // Protocol
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->TransportProto = ParseSATransportProto(Token);

    // DestPort
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->DestPort = (unsigned short)ParseSAPort(Token);

    // SrcPort
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->SrcPort = (unsigned short)ParseSAPort(Token);

    // AuthAlg
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->AlgorithmId = ParseAuthAlg(Token);

    // KeyFile
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->RawKeySize = ReadKeyFile(Token, SAAndKey->Key);
    if (SA->RawKeySize == 0) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_39, Token);
// printf("Error reading key file %s\n", Token);

        return FALSE;
    }

    // Direction
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->Direction = ParseDirection(Token);

    // SecPolicyIndex
    if ((Token = strtok(NULL, " ")) == NULL) return FALSE;
    SA->SecPolicyIndex = atol(Token);

    // End of current association.
    // REVIEW: Insist that nothing follows final valid field on the line?
    // if ((Token = strtok(NULL, " ")) != NULL) return FALSE;

    return TRUE;
}


void
ReadConfigurationFile(char *BaseName, int Type)
{
    char Buffer[SP_FILE_BORDER + 2];  // Note: SP_FILE_BORDER > SA_FILE_BORDER
    char FileName[MAX_PATH + 1];
    unsigned int MaxLineLengthPlusOne, LineLength, Line;
    FILE *File;
    int ParseIt = 0;
    IPV6_CREATE_SECURITY_POLICY SPEntry;
    IPV6_CREATE_SA_AND_KEY SAEntry;
    int Policies = 0;
    int Associations = 0;
    DWORD Error;

    //
    // Copy the filename from the command line to our own buffer so we can
    // append an extension to it.  We reserve at least 4 characters for the
    // extension.  The strncpy function will zero fill up to the limit of
    // the copy, thus the character at the limit will be NULL unless the
    // command line field was too long to fit.
    //
    strncpy(FileName, BaseName, MAX_PATH - 3);
    if (FileName[MAX_PATH - 4] != 0) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_40);
// printf("\nFilename length is too long.\n");

        exit(1);
    }

    //
    // Add appropriate file extension.
    // Maximum line length is the size of the field entries
    // plus one for the newline character.  Since we need to
    // fgets with a value one greater than the max that can
    // be read in, we add that onto the maximum line length
    // to get MaxLineLengthPlusOne.  Saves us an add later.
    //
    if (Type == POLICY) {
        strcat(FileName, ".spd");
        MaxLineLengthPlusOne = SP_FILE_BORDER + 2;
    } else {
        if (Type == ASSOCIATION) {
            strcat(FileName, ".sad");
            MaxLineLengthPlusOne = SA_FILE_BORDER + 2;
        } else {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_41);
// printf("\nReadConfigurationFile routine called incorrectly.\n");

            exit(1);
        }
    }

    if ((File = fopen(FileName, "r")) == NULL) {
        NlsPutMsg(STDOUT, IPSEC_MESSAGE_42, FileName);
// printf("\nFile %s could not be opened.\n", FileName);

        exit(1);
    }

    for (Line = 1; !feof(File); Line++) {
        if (fgets(Buffer, MaxLineLengthPlusOne, File) == NULL)
            break;
        LineLength = strlen(Buffer);
//      printf("Line = %u, Length = %u: %s.\n", Line, LineLength, Buffer);

        if (Buffer[LineLength - 1] != '\n') {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_43, Line);
// printf("Error on line %u, line too long.\n", Line);

            break;
        } else {
            Buffer[LineLength - 1] = '\0';
        }
        if (ParseIt) {
            if (Buffer[0] == '_')
                break;
            if (Type == POLICY) {
                if (!ParseSPLine(Buffer, &SPEntry)) {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_44, Line);
// printf("Error parsing SP entry fields on line %u.\n", Line);

                    break;
                } else {
                    Error = CreateSecurityPolicyEntry(&SPEntry);
                    if (Error == ERROR_ALREADY_EXISTS) {
                        NlsPutMsg(STDOUT, IPSEC_MESSAGE_45,
                                  Line, SPEntry.SPIndex);
// printf("Error on line %u: a policy with index %u "
//        "already exists.\n", Line, SPEntry.SPIndex);

                        continue;
                    }
                    if (Error == ERROR_NOT_FOUND) {
                        NlsPutMsg(STDOUT, IPSEC_MESSAGE_46,
                                  Line, SPEntry.SPIndex);
// printf("Error on line %u: policy %u specifies a "
//        "non-existent interface.\n",
//        Line, SPEntry.SPIndex);

                        continue;
                    }
                    if (Error != ERROR_SUCCESS) {
                        NlsPutMsg(STDOUT, IPSEC_MESSAGE_47,
                                  Error,
                                  Line,
                                  SPEntry.SPIndex,
                                  GetErrorString(Error));
// printf("Error %u on line %u, policy %u: %s.\n",
//        Error, Line, SPEntry.SPIndex, strerror(Error));

                        break;
                    }
                    Policies++;
                }
            } else {
                if (!ParseSALine(Buffer, &SAEntry)) {
                    NlsPutMsg(STDOUT, IPSEC_MESSAGE_48, Line);
// printf("Error parsing SA entry fields on line %u.\n", Line);

                    break;
                } else {
                    Error = CreateSecurityAssociationEntry(&SAEntry);
                    if (Error == ERROR_ALREADY_EXISTS) {
                        NlsPutMsg(STDOUT, IPSEC_MESSAGE_49,
                                  Line, SAEntry.SA.SAIndex);
// printf("Error on line %u: an association with index "
//        "%u already exists.\n", Line,
//        SAEntry.SA.SAIndex);

                        continue;
                    }
                    if (Error != ERROR_SUCCESS) {
                        NlsPutMsg(STDOUT, IPSEC_MESSAGE_50,
                                  Error, SAEntry.SA.SAIndex, GetErrorString(Error));
// printf("Error %u adding association %u: %s.\n",
//        Error, SAEntry.SA.SAIndex, strerror(Error));

                        break;
                    }
                    Associations++;
                }
            }
        }
        if (Buffer[0] == '_')
            ParseIt = TRUE;
    }

    if (Type == POLICY) {
        if (Policies == 1) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_51, Policies);
        } else {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_59, Policies);
        }
// printf("Added %d polic%s.\n", Policies, Policies == 1 ? "y" : "ies");

    } else {
        if (Associations == 1) {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_52, Associations);
        } else {
            NlsPutMsg(STDOUT, IPSEC_MESSAGE_60, Associations);
        }
// printf("Added %d association%s.\n",
//        Associations, Associations == 1 ? "" : "s");

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\inc\ws2ip6.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Per RFC 2553.
//
// This file contains IPv6 specific information for use
// by Winsock2 compatible applications.
//
// It also declares functionality exported from wship6.lib,
// an application helper library for IPv6.
//

#ifndef WS2IP6_INCLUDED
#define WS2IP6_INCLUDED 1

#include <ipexport.h>

#ifdef _MSC_VER
#define WS2IP6_INLINE __inline
#else
#define WS2IP6_INLINE extern inline /* GNU style */
#endif

#ifdef __cplusplus
#define WS2IP6_EXTERN extern "C"
#else
#define WS2IP6_EXTERN extern
#endif

//
// Little helper functions to copy between SOCKADDR_IN6 and TDI_ADDRESS_IP6.
// Only enabled if TDI_ADDRESS_IP6 has been defined.
// By design, the two structures are identical except for sin6_family.
//
#ifdef TDI_ADDRESS_LENGTH_IP6
WS2IP6_INLINE void
CopyTDIFromSA6(TDI_ADDRESS_IP6 *To, SOCKADDR_IN6 *From)
{
    memcpy(To, &From->sin6_port, sizeof *To);
}

WS2IP6_INLINE void
CopySAFromTDI6(SOCKADDR_IN6 *To, TDI_ADDRESS_IP6 *From)
{
    To->sin6_family = AF_INET6;
    memcpy(&To->sin6_port, From, sizeof *From);
}
#endif

#endif // WS2IP6_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    Ipv6 subcontexts.

--*/

#include "precomp.h"

NS_HELPER_ATTRIBUTES g_pSubContexts[] =
{
    // 6to4 subcontext
    //
    {
        { IP6TO4_VERSION, 0 }, 
        IP6TO4_GUID, Ip6to4StartHelper, NULL
    },
};

#define g_dwSubContextCount \
            (sizeof(g_pSubContexts) / sizeof(*g_pSubContexts))

//
// Installs all of the sub contexts provided
// in this .dll (for example, "ipv6 6to4", and any new ones.)
//
DWORD
Ipv6InstallSubContexts(
    )
{
    DWORD dwErr = NO_ERROR, i;

    PNS_HELPER_ATTRIBUTES pCtx = NULL;

    for (i = 0, pCtx = g_pSubContexts; i < g_dwSubContextCount; i++, pCtx++)
    {
        // Initialize helper attributes
        //
        RegisterHelper( &g_Ipv6Guid, pCtx );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\6to4.h ===
//=============================================================================
// Copyright (c) 2001-2002 Microsoft Corporation
// File: 6to4.h
//
// Author: Dave Thaler (dthaler)
//=============================================================================


#ifndef __6TO4_H
#define __6TO4_H

#define IP6TO4_GUID \
{ 0xf1efa7e5,0x7169, 0x4ec0, { 0xa6, 0x3a, 0x9b,0x22, 0xa7,0x43, 0xe1, 0x9c } }

#define IP6TO4_VERSION 1

extern GUID g_Ip6to4Guid;

NS_HELPER_START_FN Ip6to4StartHelper;
NS_CONTEXT_DUMP_FN Ip6to4Dump;

FN_HANDLE_CMD Ip6to4HandleReset;

FN_HANDLE_CMD Ip6to4HandleSetInterface;
FN_HANDLE_CMD Ip6to4HandleSetRelay;
FN_HANDLE_CMD Ip6to4HandleSetRouting;
FN_HANDLE_CMD Ip6to4HandleSetState;

FN_HANDLE_CMD Ip6to4HandleShowInterface;
FN_HANDLE_CMD Ip6to4HandleShowRelay;
FN_HANDLE_CMD Ip6to4HandleShowRouting;
FN_HANDLE_CMD Ip6to4HandleShowState;

BOOL
GetString(
    IN HKEY    hKey,
    IN LPCTSTR lpName,
    IN PWCHAR  pwszBuff,
    IN ULONG   ulLength);

ULONG
GetInteger(
    IN HKEY    hKey,
    IN LPCTSTR lpName,
    IN ULONG   ulDefault);

DWORD
SetString(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  PWCHAR  pwcValue);

DWORD
SetInteger(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  ULONG   ulValue);

DWORD
Ip6to4PokeService();

typedef enum {
    VAL_DEFAULT = 0,
    VAL_AUTOMATIC,
    VAL_ENABLED,
    VAL_DISABLED,
    VAL_MAXIMUM
} STATE;

extern TOKEN_VALUE rgtvEnums[4];

#define KEY_GLOBAL L"System\\CurrentControlSet\\Services\\6to4\\Config"
#define KEY_INTERFACES L"System\\CurrentControlSet\\Services\\6to4\\Interfaces"
#define KEY_IPV6_INTERFACES L"System\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces"

DWORD
SetInteger(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN ULONG ulValue
    );

ULONG
GetInteger(
    IN HKEY hKey,
    IN LPCTSTR lpName,
    IN ULONG ulDefault
    );

DWORD
SetString(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  PWCHAR  pwcValue
    );

BOOL
GetString(
    IN HKEY    hKey,
    IN LPCTSTR lpName,
    IN PWCHAR  pwszBuff,
    IN ULONG   ulLength
    );

DWORD
ResetKey(
    IN HKEY hKey,
    IN PWCHAR pwcSubKey
    );

extern PWCHAR pwszStateString[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6\installipv6.cpp ===
#include <stdio.h>
#include <netcfgx.h>
#include <devguid.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include "localmsg.h"

EXTERN_C void ausage(void);

HRESULT
HrCreateINetCfg (
    IN BOOL fAcquireWriteLock,
    OUT INetCfg** ppINetCfg)
{
    HRESULT hr;
    INetCfg* pINetCfg;

    // Get the INetCfg interface.
    //
    hr = CoCreateInstance(
        CLSID_CNetCfg,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        IID_INetCfg,
        reinterpret_cast<void**>(&pINetCfg));

    if (S_OK == hr) {
        INetCfgLock * pnclock = NULL;

        if (fAcquireWriteLock) {
            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr)) {
                LPWSTR pwszLockHolder;

                // Attempt to lock the INetCfg for read/write
                hr = pnclock->AcquireWriteLock(100, L"InstallIPv6", 
                    &pwszLockHolder);
                if (S_FALSE == hr) {
                    // Couldn't acquire the lock
                    hr = NETCFG_E_NO_WRITE_LOCK;
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_0);
// printf("The write lock could not be acquired.\n");

                    NlsPutMsg(STDOUT, IPV6_MESSAGE_1, pwszLockHolder);
// printf("You must close %ls first.\n", pwszLockHolder);

                }
                if (pwszLockHolder) {
                    CoTaskMemFree(pwszLockHolder);
                }
            }
        }

        if (S_OK == hr) {
            hr = pINetCfg->Initialize (NULL);
            if (S_OK == hr) {
                *ppINetCfg = pINetCfg;
                pINetCfg->AddRef();
            }
            else {
                if (pnclock) {
                    pnclock->ReleaseWriteLock();
                }
            }
        }

        if (pnclock) {
            pnclock->Release();
        }

        //Transfer ownership to caller.
        pINetCfg->Release();
    }
    return hr;
}

VOID
pAddOrRemoveIpv6(BOOL fAddIpv6)
{
    HRESULT hr;
    INetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr) {
        INetCfgClassSetup* pSetup;

        // Get the setup interface used for installing
        // and uninstalling components.
        //
        hr = pINetCfg->QueryNetCfgClass (
                &GUID_DEVCLASS_NETTRANS,
                IID_INetCfgClassSetup,
                (VOID**)&pSetup);

        if (S_OK == hr) {
            OBO_TOKEN OboToken;
            INetCfgComponent* pIComp;

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            if (fAddIpv6) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_2);
// printf("Installing...\n");

                hr = pSetup->Install (
                        L"MS_TCPIP6",
                        &OboToken,
                        0, 0, NULL, NULL,
                        &pIComp);

                if (pIComp) {
                    pIComp->Release();
                }
            }
            else {
                // Need to remove the component.
                // Find it first.
                //
                hr = pINetCfg->FindComponent (
                        L"MS_TCPIP6",
                        &pIComp);

                if (S_OK == hr) {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_3);
// printf("Uninstalling...\n");

                    hr = pSetup->DeInstall (
                            pIComp,
                            &OboToken,
                            NULL);

                    pIComp->Release();
                }
                else {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_4);
// printf("Microsoft IPv6 Developer Edition is not installed.\n");

                }
            }

            if (SUCCEEDED(hr)) {
                if (NETCFG_S_REBOOT == hr) {
                    hr = S_OK;
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_5);
// printf("A reboot is required to complete this action.\n");

                }
                else {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_6);
// printf("Succeeded.\n");

                }
            }
            else {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_7);
// printf("Failed to complete the action.\n");

                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) {
                    hr = S_OK;
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_8);
// printf("The INF file for Microsoft IPv6 Developer Edition could not be found.\n");

                }
                else if (NETCFG_E_NEED_REBOOT == hr) {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_9);
// printf("A reboot is required before any further changes can be made.\n");

                }
                else {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_10, hr);
// printf("Error 0x%08x\n", hr);

                }
            }

            pSetup->Release();
        }

        hr = pINetCfg->Uninitialize();
        if (SUCCEEDED(hr))
        {
            INetCfgLock *   pnclock;

            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                hr = pnclock->ReleaseWriteLock();

               pnclock->Release();
            }
        }

        pINetCfg->Release();
    }
    else if (NETCFG_E_NO_WRITE_LOCK == hr) {
        // Message has already been printed
    }
    else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr) {
        ausage();
    }
    else {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_11, hr);
// printf("Problem 0x%08x occurred.\n", hr);

    }

}

EXTERN_C
BOOL
IsIpv6Installed()
{
    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;
    BOOL fPresent = FALSE;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        HRESULT hr;
        INetCfg* pINetCfg;

        hr = HrCreateINetCfg (FALSE, &pINetCfg);
        if (S_OK == hr) {
            fPresent = (S_OK == pINetCfg->FindComponent(L"MS_TCPIP6", NULL));
            pINetCfg->Uninitialize();
            pINetCfg->Release();
        }
        else {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_12, hr);
// printf("Problem 0x%08x occurred while accessing network configuration.\n", hr);

            exit(1);
        }

        if (fInitCom) {
            CoUninitialize();
        }
    }
    else {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_13, hr);
// printf("Problem 0x%08x initializing COM library\n", hr);

    }

    return fPresent;

}

EXTERN_C
void
AddOrRemoveIpv6 (
    IN BOOL fAddIpv6)
{

    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        pAddOrRemoveIpv6(fAddIpv6);

        if (fInitCom) {
            CoUninitialize();
        }
    }
    else {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_13, hr);
// printf("Problem 0x%08x initializing COM library\n", hr);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\6to4.c ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
// Abstract:
//      This module implements 6to4 configuration commands.
//=============================================================================


#include "precomp.h"
#pragma hdrstop 

#define KEY_ENABLE_6TO4             L"Enable6to4"
#define KEY_ENABLE_RESOLUTION       L"EnableResolution"
#define KEY_ENABLE_ROUTING          L"EnableRouting"
#define KEY_ENABLE_SITELOCALS       L"EnableSiteLocals"
#define KEY_RESOLUTION_INTERVAL     L"ResolutionInterval"
#define KEY_UNDO_ON_STOP            L"UndoOnStop"
#define KEY_RELAY_NAME              L"RelayName"

PWCHAR
pwszStateString[] = {
    TOKEN_VALUE_DEFAULT,
    TOKEN_VALUE_AUTOMATIC,
    TOKEN_VALUE_ENABLED,
    TOKEN_VALUE_DISABLED,
};

// The guid for this context
//
GUID g_Ip6to4Guid = IP6TO4_GUID;

// The commands supported in this context
//

CMD_ENTRY  g_Ip6to4SetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IP6TO4_SET_INTERFACE,Ip6to4HandleSetInterface),
    CREATE_CMD_ENTRY(IP6TO4_SET_RELAY,    Ip6to4HandleSetRelay),
    CREATE_CMD_ENTRY(IP6TO4_SET_ROUTING,  Ip6to4HandleSetRouting),
    CREATE_CMD_ENTRY(IP6TO4_SET_STATE,    Ip6to4HandleSetState),
};

CMD_ENTRY  g_Ip6to4ShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(IP6TO4_SHOW_INTERFACE,Ip6to4HandleShowInterface),
    CREATE_CMD_ENTRY(IP6TO4_SHOW_RELAY,    Ip6to4HandleShowRelay),
    CREATE_CMD_ENTRY(IP6TO4_SHOW_ROUTING,  Ip6to4HandleShowRouting),
    CREATE_CMD_ENTRY(IP6TO4_SHOW_STATE,    Ip6to4HandleShowState),
};


CMD_GROUP_ENTRY g_Ip6to4CmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,  g_Ip6to4SetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_Ip6to4ShowCmdTable),
};

ULONG g_ulIp6to4NumGroups = sizeof(g_Ip6to4CmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_Ip6to4TopCmds[] =
{
    CREATE_CMD_ENTRY(IP6TO4_RESET, Ip6to4HandleReset),
};

ULONG g_ulNumIp6to4TopCmds = sizeof(g_Ip6to4TopCmds)/sizeof(CMD_ENTRY);

#if 0
TOKEN_VALUE AdminStates[] = {
    { VAL_AUTOMATIC, TOKEN_AUTOMATIC },
    { VAL_ENABLED,   TOKEN_ENABLED },
    { VAL_DISABLED,  TOKEN_DISABLED },
    { VAL_DEFAULT,   TOKEN_DEFAULT },
};
#endif

BOOL
GetString(
    IN HKEY    hKey,
    IN LPCTSTR lpName,
    IN PWCHAR  pwszBuff,
    IN ULONG   ulLength)
{
    DWORD dwErr, dwType;
    ULONG ulSize, ulValue;

    if (hKey == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    ulSize = sizeof(ulValue);
    dwErr = RegQueryValueEx(hKey, lpName, NULL, &dwType, (PBYTE)pwszBuff, 
                            &ulLength);

    if (dwErr != ERROR_SUCCESS) {
        return FALSE;
    }

    if (dwType != REG_SZ) {
        return FALSE;
    }

    return TRUE;
}

ULONG
GetInteger(
    IN HKEY    hKey,
    IN LPCTSTR lpName,
    IN ULONG   ulDefault)
{
    DWORD dwErr, dwType;
    ULONG ulSize, ulValue;

    if (hKey == INVALID_HANDLE_VALUE) {
        return ulDefault;
    }
    
    ulSize = sizeof(ulValue);
    dwErr = RegQueryValueEx(hKey, lpName, NULL, &dwType, (PBYTE)&ulValue,
                            &ulSize);

    if (dwErr != ERROR_SUCCESS) {
        return ulDefault;
    }

    if (dwType != REG_DWORD) {
        return ulDefault;
    }

    return ulValue;
}

DWORD
SetInteger(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  ULONG   ulValue)
{
    DWORD dwErr;
    ULONG ulOldValue;

    ASSERT(hKey != INVALID_HANDLE_VALUE);
    
    ulOldValue = GetInteger(hKey, lpName, VAL_DEFAULT);
    if (ulValue == ulOldValue) {
        return NO_ERROR;
    }

    if (ulValue == VAL_DEFAULT) {
        dwErr = RegDeleteValue(hKey, lpName);
        if (dwErr == ERROR_FILE_NOT_FOUND) {
            dwErr = NO_ERROR;
        }
    } else {
        dwErr = RegSetValueEx(hKey, lpName, 0, REG_DWORD, (PBYTE)&ulValue,
                              sizeof(ulValue));
    }

    return dwErr;
}

DWORD
SetString(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  PWCHAR  pwcValue)
{
    DWORD dwErr;

    ASSERT(hKey != INVALID_HANDLE_VALUE);

    if (!pwcValue[0] || !_wcsicmp(pwcValue, TOKEN_VALUE_DEFAULT)) {
        dwErr = RegDeleteValue(hKey, lpName);
        if (dwErr == ERROR_FILE_NOT_FOUND) {
            dwErr = NO_ERROR;
        }
    } else {
        dwErr = RegSetValueEx(hKey, lpName, 0, REG_SZ, (PBYTE)pwcValue,
                              (DWORD) (wcslen(pwcValue)+1) * sizeof(WCHAR));
    }

    return dwErr;
}

DWORD
ResetKey(
    IN HKEY hKey,
    IN PWCHAR pwcSubKey)
/*++

Routine Description

    Used to delete everything under a key without deleting the key itself.
    We use this where we would otherwise just use SHDeleteKey or RegDeleteKey
    but we need to preserve the ACL on the key itself.

Arguments

    hKey                Handle to parent of key to reset.
    pwcSubKey           Name of key to reset.

--*/
{
    ULONG Status, ValueNameChars;
    HKEY hSubKey;

    //
    // All values we care about resetting are short.
    //
    WCHAR ValueName[256];
    
    Status = RegOpenKeyExW(hKey, pwcSubKey, 0, KEY_READ | KEY_WRITE, &hSubKey);
    if (Status != NO_ERROR) {
        return Status;
    }

    //
    // First delete values.
    //
    while (Status == NO_ERROR) {
        //
        // RegEnumValue takes the size in characters, including space
        // for the NULL, and ensures NULL termination on success.
        //
        ValueNameChars = sizeof(ValueName)/sizeof(WCHAR);

        Status = RegEnumValueW(hSubKey, 0, ValueName, &ValueNameChars,
                               NULL, NULL, NULL, NULL);
        if (Status != NO_ERROR) {
            if (Status == ERROR_NO_MORE_ITEMS) {
                Status = NO_ERROR;
            }
            break;
        }
        
        Status = RegDeleteValueW(hSubKey, ValueName);
    }

    //
    // Now delete any subkeys.
    //
    while (Status == NO_ERROR) {
        //
        // RegEnumKeyEx takes the size in characters, including space
        // for the NULL, and ensures NULL termination on success.
        //
        ValueNameChars = sizeof(ValueName)/sizeof(WCHAR);

        Status = RegEnumKeyExW(hSubKey, 0, ValueName, &ValueNameChars,
                               NULL, NULL, NULL, NULL);
        if (Status != NO_ERROR) {
            if (Status == ERROR_NO_MORE_ITEMS) {
                Status = NO_ERROR;
            }
            break;
        }
        
        Status = RegDeleteKey(hSubKey, ValueName);
    }

    RegCloseKey(hSubKey);

    return Status;
}

DWORD
WINAPI
Ip6to4StartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
/*++

Routine Description

    Used to initialize the helper.

Arguments

    pguidParent     Ifmon's guid
    pfnRegisterContext      
    
Return Value

    NO_ERROR
    other error code
--*/
{
    DWORD dwErr = NO_ERROR;
    
    NS_CONTEXT_ATTRIBUTES       attMyAttributes;


    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"6to4";
    attMyAttributes.guidHelper  = g_Ip6to4Guid;
    attMyAttributes.dwVersion   = IP6TO4_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = Ip6to4Dump;
    attMyAttributes.ulNumTopCmds= g_ulNumIp6to4TopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_Ip6to4TopCmds;
    attMyAttributes.ulNumGroups = g_ulIp6to4NumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_Ip6to4CmdGroups;

    dwErr = RegisterContext( &attMyAttributes );
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    //
    // Register ISATAP context.
    //
    return IsatapStartHelper(pguidParent, dwVersion);
}

DWORD
Ip6to4PokeService()
{
    SC_HANDLE      hService, hSCManager;
    SERVICE_STATUS ServiceStatus;
    DWORD          dwErr = NO_ERROR;

    hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ);

    if (hSCManager == NULL) {
        return GetLastError();
    }

    hService = OpenService(hSCManager, L"6to4", SERVICE_ALL_ACCESS);

    if (hService == NULL) {
        dwErr = GetLastError();
    } else {
        // Tell the 6to4 service to re-read its config info
        if (!ControlService(hService, 
                            SERVICE_CONTROL_PARAMCHANGE, 
                            &ServiceStatus)) {
            dwErr = GetLastError();
        }
    
        CloseServiceHandle(hService);
    }

    CloseServiceHandle(hSCManager);

    return dwErr; 
}

TOKEN_VALUE rgtvEnums[] = {
    { TOKEN_VALUE_AUTOMATIC, VAL_AUTOMATIC },
    { TOKEN_VALUE_ENABLED,   VAL_ENABLED },
    { TOKEN_VALUE_DISABLED,  VAL_DISABLED },
    { TOKEN_VALUE_DEFAULT,   VAL_DEFAULT },
};

#define BM_ENABLE_ROUTING    0x01
#define BM_ENABLE_SITELOCALS 0x02

DWORD
Ip6to4HandleSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hInterfaces, hIf;
    STATE    stEnableRouting = 0;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_NAME,    TRUE, FALSE},
                          {TOKEN_ROUTING, TRUE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    WCHAR    wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD    dwBufferSize = sizeof(wszInterfaceName);
    PWCHAR   wszIfFriendlyName = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              2,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // NAME
            dwErr = Connect();
            if (dwErr isnot NO_ERROR) {
                break;
            }
    
            dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                              wszInterfaceName, &dwBufferSize);
            Disconnect();

            if (dwErr isnot NO_ERROR)
            {
                DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                    ppwcArguments[i + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

            break;

        case 1: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableRouting);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_ROUTING;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_INTERFACES, 0, NULL, 0,
                           KEY_WRITE, NULL, &hInterfaces, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = RegCreateKeyEx(hInterfaces, wszInterfaceName, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hIf, NULL);

    if (dwErr != NO_ERROR) {
        RegCloseKey(hInterfaces);

        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_ROUTING) {
        dwErr = SetInteger(hIf, KEY_ENABLE_ROUTING, stEnableRouting); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hIf);
            RegCloseKey(hInterfaces);
            return dwErr;
        }
    }

    RegCloseKey(hIf);

    RegCloseKey(hInterfaces);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
Ip6to4HandleSetRouting(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hGlobal;
    STATE    stEnableRouting = 0;
    STATE    stEnableSiteLocals = 0;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_ROUTING,    FALSE, FALSE},
                          {TOKEN_SITELOCALS, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }
    
    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableRouting);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_ROUTING;
            break;

        case 1: // SITELOCALS
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableSiteLocals);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_SITELOCALS;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hGlobal, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_ROUTING) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_ROUTING, stEnableRouting); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    if (dwBitVector & BM_ENABLE_SITELOCALS) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_SITELOCALS, stEnableSiteLocals); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    RegCloseKey(hGlobal);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

#define BM_ENABLE_RESOLUTION   0x01
#define BM_RELAY_NAME          0x02
#define BM_RESOLUTION_INTERVAL 0x04

DWORD
Ip6to4HandleSetRelay(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hGlobal;
    STATE    stEnableResolution = 0;
    ULONG    ulResolutionInterval = 0;
    PWCHAR   pwszRelayName = NULL;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_RELAY_NAME, FALSE, FALSE},
                          {TOKEN_STATE,      FALSE, FALSE},
                          {TOKEN_INTERVAL,   FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }
    
    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // RELAYNAME
            pwszRelayName = ppwcArguments[dwCurrentIndex + i];
            dwBitVector |= BM_RELAY_NAME;
            break;

        case 1: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableResolution);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_RESOLUTION;
            break;

        case 2: // INTERVAL
            ulResolutionInterval = wcstoul(ppwcArguments[dwCurrentIndex + i],
                                           NULL, 10);
            dwBitVector |= BM_RESOLUTION_INTERVAL;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hGlobal, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_RESOLUTION) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_RESOLUTION, stEnableResolution); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }
    
    if (dwBitVector & BM_RELAY_NAME) {
        dwErr = SetString(hGlobal, KEY_RELAY_NAME, pwszRelayName);
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    if (dwBitVector & BM_RESOLUTION_INTERVAL) {
        dwErr = SetInteger(hGlobal, KEY_RESOLUTION_INTERVAL, ulResolutionInterval); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    RegCloseKey(hGlobal);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

#define BM_ENABLE_6TO4   0x01
#define BM_UNDO_ON_STOP  0x02

DWORD
Ip6to4HandleSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hGlobal;
    STATE    stEnable6to4 = 0;
    STATE    stUndoOnStop = 0;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_STATE,        FALSE, FALSE},
                          {TOKEN_UNDO_ON_STOP, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }
    
    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnable6to4);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_6TO4;
            break;

        case 1: // UNDOONSTOP
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stUndoOnStop);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_UNDO_ON_STOP;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hGlobal, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_6TO4) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_6TO4, stEnable6to4); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }
    
    if (dwBitVector & BM_UNDO_ON_STOP) {
        dwErr = SetInteger(hGlobal, KEY_UNDO_ON_STOP, stUndoOnStop); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    RegCloseKey(hGlobal);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
ShowInterfaceConfig(
    IN  BOOL bDump)
{
    DWORD dwErr = NO_ERROR;
    HKEY  hInterfaces, hIf;
    STATE stEnableRouting;
    int   i;
    WCHAR    wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD    dwBufferSize;
    WCHAR    wszIfFriendlyName[MAX_INTERFACE_NAME_LEN + 1];

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_INTERFACES, 0, 
                         KEY_ENUMERATE_SUB_KEYS, &hInterfaces);

    if (dwErr != NO_ERROR) {
        if (!bDump) {
            DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
        }
        return ERROR_SUPPRESS_OUTPUT;
    }
    
    dwErr = Connect();
    if (dwErr isnot NO_ERROR) {
        RegCloseKey(hInterfaces);
        return dwErr;
    }

    for (i=0; ; i++) {

        dwBufferSize = MAX_INTERFACE_NAME_LEN + 1;
        dwErr = RegEnumKeyEx(hInterfaces, i, wszInterfaceName, &dwBufferSize,
                             0, NULL, NULL, NULL);

        if (dwErr != NO_ERROR) {
            if (dwErr == ERROR_NO_MORE_ITEMS) {
                dwErr = NO_ERROR;
            }
            break;
        }

        dwBufferSize = sizeof(wszIfFriendlyName);
        dwErr = GetFriendlyNameFromIfName(wszInterfaceName,
                                          wszIfFriendlyName,
                                          &dwBufferSize);
        if (dwErr != NO_ERROR) {
            wcscpy(wszIfFriendlyName, wszInterfaceName);
        }

        dwErr = RegOpenKeyEx(hInterfaces, wszInterfaceName, 0, KEY_READ,
                             &hIf);
        if (dwErr != NO_ERROR) {
            break;
        }
    
        stEnableRouting = GetInteger(hIf, KEY_ENABLE_ROUTING, VAL_DEFAULT);

        RegCloseKey(hIf);
        
        if (bDump) {
            if (stEnableRouting != VAL_DEFAULT) {
                DisplayMessageT(DMP_IP6TO4_SET_INTERFACE);

                DisplayMessageT(DMP_QUOTED_STRING_ARG, 
                                TOKEN_NAME,
                                wszIfFriendlyName);

                DisplayMessageT(DMP_STRING_ARG, 
                                TOKEN_ROUTING,
                                pwszStateString[stEnableRouting]);

                DisplayMessage(g_hModule, MSG_NEWLINE);
            }
        } else {
            if (i==0) { 
                DisplayMessage(g_hModule, MSG_INTERFACE_HEADER);
            }
        
            DisplayMessage(g_hModule, MSG_INTERFACE_ROUTING_STATE,
                                      pwszStateString[stEnableRouting],
                                      wszIfFriendlyName);
        }
    }

    RegCloseKey(hInterfaces);

    Disconnect();

    return dwErr;
}

DWORD
Ip6to4HandleShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowInterfaceConfig(FALSE);
}

DWORD
ShowRoutingConfig(
    IN BOOL bDump)
{
    DWORD dwErr = NO_ERROR;
    HKEY  hGlobal;
    STATE stEnableRouting;
    STATE stEnableSiteLocals;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_READ,
                         &hGlobal);

    if (dwErr != NO_ERROR) {
        hGlobal = INVALID_HANDLE_VALUE;
        dwErr = NO_ERROR;
    }

    stEnableRouting     = GetInteger(hGlobal,
                                     KEY_ENABLE_ROUTING,
                                     VAL_DEFAULT); 

    stEnableSiteLocals  = GetInteger(hGlobal,
                                     KEY_ENABLE_SITELOCALS,
                                     VAL_DEFAULT);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    if (bDump) {
        if ((stEnableRouting != VAL_DEFAULT)
          || (stEnableSiteLocals != VAL_DEFAULT)) {
            DisplayMessageT(DMP_IP6TO4_SET_ROUTING);

            if (stEnableRouting != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, 
                                TOKEN_ROUTING,
                                pwszStateString[stEnableRouting]);
            }
    
            if (stEnableSiteLocals != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG,
                                TOKEN_SITELOCALS,
                                pwszStateString[stEnableSiteLocals]);
            }
    
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(g_hModule, MSG_ROUTING_STATE,
                                  pwszStateString[stEnableRouting]);

        DisplayMessage(g_hModule, MSG_SITELOCALS_STATE, 
                                  pwszStateString[stEnableSiteLocals]);
    }

    return dwErr;
}

DWORD
Ip6to4HandleShowRouting(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRoutingConfig(FALSE);
}


DWORD
ShowRelayConfig(
    IN  BOOL    bDump)
{
    DWORD dwErr = NO_ERROR;
    HKEY  hGlobal;
    STATE stEnableResolution;
    ULONG ulResolutionInterval;
    WCHAR pwszRelayName[NI_MAXHOST];
    BOOL  bHaveRelayName;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_READ,
                         &hGlobal);

    if (dwErr != NO_ERROR) {
        hGlobal = INVALID_HANDLE_VALUE;
        dwErr = NO_ERROR;
    }

    stEnableResolution  = GetInteger(hGlobal,
                                     KEY_ENABLE_RESOLUTION,
                                     VAL_DEFAULT); 

    bHaveRelayName = GetString(hGlobal, KEY_RELAY_NAME, pwszRelayName, 
                               NI_MAXHOST);

    ulResolutionInterval = GetInteger(hGlobal,
                                      KEY_RESOLUTION_INTERVAL,
                                      0);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    if (bDump) {
        if (bHaveRelayName || (stEnableResolution != VAL_DEFAULT)
            || (ulResolutionInterval > 0)) {
        
            DisplayMessageT(DMP_IP6TO4_SET_RELAY);

            if (bHaveRelayName) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_NAME,
                                                pwszRelayName);
            }

            if (stEnableResolution != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, 
                                TOKEN_STATE,
                                pwszStateString[stEnableResolution]);
            }
    
            if (ulResolutionInterval > 0) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_INTERVAL,
                                                 ulResolutionInterval);
            }

            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
                                    
    } else {
        DisplayMessage(g_hModule, MSG_RELAY_NAME);
    
        if (bHaveRelayName) {
            DisplayMessage(g_hModule, MSG_STRING, pwszRelayName);
        } else {
            DisplayMessage(g_hModule, MSG_STRING, TOKEN_VALUE_DEFAULT);
        }
    
        DisplayMessage(g_hModule, MSG_RESOLUTION_STATE,
                                  pwszStateString[stEnableResolution]);
    
        DisplayMessage(g_hModule, MSG_RESOLUTION_INTERVAL);
    
        if (ulResolutionInterval) {
            DisplayMessage(g_hModule, MSG_MINUTES, ulResolutionInterval);
        } else {
            DisplayMessage(g_hModule, MSG_STRING, TOKEN_VALUE_DEFAULT);
        }
    }

    return dwErr;
}

DWORD
Ip6to4HandleShowRelay(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRelayConfig(FALSE);
}

DWORD
Ip6to4HandleReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr;

    // Nuke global params
    dwErr = ResetKey(HKEY_LOCAL_MACHINE, KEY_GLOBAL);
    if ((dwErr != NO_ERROR) && (dwErr != ERROR_FILE_NOT_FOUND)) {
        return dwErr;
    }

    // Nuke all interface config
    dwErr = ResetKey(HKEY_LOCAL_MACHINE, KEY_INTERFACES);
    if ((dwErr != NO_ERROR) && (dwErr != ERROR_FILE_NOT_FOUND)) {
        return dwErr;
    }

    // Start/poke the service
    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
ShowStateConfig(
    IN  BOOL    bDump)
{
    DWORD dwErr = NO_ERROR;
    HKEY  hGlobal = INVALID_HANDLE_VALUE;
    STATE stEnable6to4;
    STATE stUndoOnStop;

    dwErr = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_READ, &hGlobal);
    if (dwErr != NO_ERROR) {
        dwErr = NO_ERROR;
    }
    
    stEnable6to4  = GetInteger(hGlobal, KEY_ENABLE_6TO4, VAL_DEFAULT);

    stUndoOnStop  = GetInteger(hGlobal, KEY_UNDO_ON_STOP, VAL_DEFAULT);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    if (bDump) {
        if ((stEnable6to4 != VAL_DEFAULT) || (stUndoOnStop != VAL_DEFAULT)) {
            DisplayMessageT(DMP_IP6TO4_SET_STATE);

            if (stEnable6to4 != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_STATE,
                                pwszStateString[stEnable6to4]);
            }
    
            if (stUndoOnStop != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_UNDO_ON_STOP,
                                pwszStateString[stUndoOnStop]);
            }

            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(g_hModule, MSG_IP6TO4_STATE,
                       pwszStateString[stEnable6to4]);

        DisplayMessage(g_hModule, MSG_UNDO_ON_STOP_STATE, 
                       pwszStateString[stUndoOnStop]);
    }

    return dwErr;
}

DWORD
Ip6to4HandleShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowStateConfig(FALSE);
}

DWORD
WINAPI
Ip6to4Dump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
/*++

Routine Description

    Used when dumping all contexts

Arguments
    
Return Value

    NO_ERROR

--*/
{
    DisplayMessage( g_hModule, DMP_IP6TO4_HEADER );
    DisplayMessageT(DMP_IP6TO4_PUSHD);

    ShowStateConfig(TRUE);
    ShowRelayConfig(TRUE);
    ShowRoutingConfig(TRUE);
    ShowInterfaceConfig(TRUE);

    DisplayMessageT(DMP_IP6TO4_POPD);
    DisplayMessage( g_hModule, DMP_IP6TO4_FOOTER );

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ifip.h ===
//=============================================================================
// Copyright (c) Microsoft Corporation
//
// Author: D.Thaler (dthaler)  11-Apr-2001
//=============================================================================


#ifndef _IFIP_H_
#define _IFIP_H_

DWORD
ShowTeredo(
    IN FORMAT Format
    );

DWORD
ResetTeredo(
    VOID
    );

FN_HANDLE_CMD HandleInstall;
FN_HANDLE_CMD HandleRenew;
FN_HANDLE_CMD HandleReset;
FN_HANDLE_CMD HandleUninstall;

FN_HANDLE_CMD HandleAdd6over4Tunnel;
FN_HANDLE_CMD HandleAddAddress;
FN_HANDLE_CMD HandleAddDns;
FN_HANDLE_CMD HandleAddPrefixPolicy;
FN_HANDLE_CMD HandleAddRoute;
FN_HANDLE_CMD HandleAddV6V4Tunnel;

FN_HANDLE_CMD HandleSetAddress;
FN_HANDLE_CMD HandleSetDns;
FN_HANDLE_CMD HandleSetGlobal;
FN_HANDLE_CMD HandleSetInterface;
FN_HANDLE_CMD HandleSetMobility;
FN_HANDLE_CMD HandleSetPrefixPolicy;
FN_HANDLE_CMD HandleSetPrivacy;
FN_HANDLE_CMD HandleSetRoute;
FN_HANDLE_CMD HandleSetState;
FN_HANDLE_CMD HandleSetTeredo;

FN_HANDLE_CMD HandleShowAddress;
FN_HANDLE_CMD HandleShowBindingCacheEntries;
FN_HANDLE_CMD HandleShowDns;
FN_HANDLE_CMD HandleShowGlobal;
FN_HANDLE_CMD HandleShowInterface;
FN_HANDLE_CMD HandleShowJoins;
FN_HANDLE_CMD HandleShowMobility;
FN_HANDLE_CMD HandleShowNeighbors;
FN_HANDLE_CMD HandleShowPrefixPolicy;
FN_HANDLE_CMD HandleShowPrivacy;
FN_HANDLE_CMD HandleShowDestinationCache;
FN_HANDLE_CMD HandleShowRoutes;
FN_HANDLE_CMD HandleShowSitePrefixes;
FN_HANDLE_CMD HandleShowState;
FN_HANDLE_CMD HandleShowTeredo;

FN_HANDLE_CMD HandleDelAddress;
FN_HANDLE_CMD HandleDelDestinationCache;
FN_HANDLE_CMD HandleDelDns;
FN_HANDLE_CMD HandleDelInterface;
FN_HANDLE_CMD HandleDelNeighbors;
FN_HANDLE_CMD HandleDelPrefixPolicy;
FN_HANDLE_CMD HandleDelRoute;

DWORD
ShowIpv6StateConfig(
    IN BOOL Dumping
    );

DWORD
ShowDnsServers(
    IN BOOL bDump,
    IN PWCHAR pwszIfFriendlyName
    );

#endif // _IFIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6\ipv6.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Dump current IPv6 state information.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2ip6.h>
#include <wspiapi.h>
#include <ntddip6.h>
#include <ip6.h>
#include <stdio.h>
#include <stdlib.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include <winnlsp.h>
#include "localmsg.h"

HANDLE Handle;

int Verbose = FALSE;

int AdminAccess = TRUE;

int Persistent = FALSE;

void QueryInterface(int argc, char *argv[]);
void CreateInterface(int argc, char *argv[]);
void UpdateInterface(int argc, char *argv[]);
void DeleteInterface(int argc, char *argv[]);
void UpdateRouterLinkAddress(int argc, char *argv[]);
void QueryNeighborCache(int argc, char *argv[]);
void QueryRouteCache(int argc, char *argv[]);
void QueryRouteTable(int argc, char *argv[]);
void UpdateRouteTable(int argc, char *argv[]);
void UpdateAddress(int argc, char *argv[]);
void QueryBindingCache(int argc, char *argv[]);
void FlushNeighborCache(int argc, char *argv[]);
void FlushRouteCache(int argc, char *argv[]);
void QuerySitePrefixTable(int argc, char *argv[]);
void UpdateSitePrefixTable(int argc, char *argv[]);
void QueryGlobalParameters(int argc, char *argv[]);
void UpdateGlobalParameters(int argc, char *argv[]);
void QueryPrefixPolicy(int argc, char *argv[]);
void UpdatePrefixPolicy(int argc, char *argv[]);
void DeletePrefixPolicy(int argc, char *argv[]);
void ResetManualConfig(int argc, char *argv[]);
void RenewInterface(int argc, char *argv[]);
void AddOrRemoveIpv6(BOOL fAddIpv6);
BOOL IsIpv6Installed();

void
usage(void)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_14);
// printf("usage: ipv6 [-p] [-v] if [ifindex]\n");
// printf("       ipv6 [-p] ifcr v6v4 v4src v4dst [nd] [pmld]\n");
// printf("       ipv6 [-p] ifcr 6over4 v4src\n");
// printf("       ipv6 [-p] ifc ifindex [forwards] [-forwards] [advertises] [-advertises] [mtu #bytes] [site site-identifier] [preference P]\n");
// printf("       ipv6 rlu ifindex v4dst\n");
// printf("       ipv6 [-p] ifd ifindex\n");
// printf("       ipv6 [-p] adu ifindex/address [life validlifetime[/preflifetime]] [anycast] [unicast]\n");
// printf("       ipv6 nc [ifindex [address]]\n");
// printf("       ipv6 ncf [ifindex [address]]\n");
// printf("       ipv6 rc [ifindex address]\n");
// printf("       ipv6 rcf [ifindex [address]]\n");
// printf("       ipv6 bc\n");
// printf("       ipv6 [-p] [-v] rt\n");
// printf("       ipv6 [-p] rtu prefix ifindex[/address] [life valid[/pref]] [preference P] [publish] [age] [spl SitePrefixLength]\n");
// printf("       ipv6 spt\n");
// printf("       ipv6 spu prefix ifindex [life L]\n");
// printf("       ipv6 [-p] gp\n");
// printf("       ipv6 [-p] gpu [parameter value] ... (try -?)\n");
// printf("       ipv6 renew [ifindex]\n");
// printf("       ipv6 [-p] ppt\n");
// printf("       ipv6 [-p] ppu prefix precedence P srclabel SL [dstlabel DL]\n");
// printf("       ipv6 [-p] ppd prefix\n");
// printf("       ipv6 [-p] reset\n");
// printf("       ipv6 install\n");
// printf("       ipv6 uninstall\n");
// printf("Some subcommands require local Administrator privileges.\n");

    exit(1);
}

void
ausage(void)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_15);
// printf("You do not have local Administrator privileges.\n");

    exit(1);
}

int __cdecl
main(int argc, char **argv)
{
    WSADATA wsaData;
    int i;

    //
    // This will ensure the correct language message is displayed when
    // NlsPutMsg is called.
    //
    SetThreadUILanguage(0);

    //
    // Parse any global options.
    //
    for (i = 1; i < argc; i++) {
        if (!strcmp(argv[i], "-v"))
            Verbose = TRUE;
        else if (!strcmp(argv[i], "-p"))
            Persistent = TRUE;
        else
            break;
    }

    argc -= i;
    argv += i;

    if (argc < 1) {
        usage();
    }

    if (!strcmp(argv[0], "install")) {
        if (argc != 1)
            usage();
        AddOrRemoveIpv6(TRUE);
    }
    else if (!strcmp(argv[0], "uninstall")) {
        if (argc != 1)
            usage();
        AddOrRemoveIpv6(FALSE);
    }
    else {

        //
        // We initialize Winsock only to have access
        // to WSAStringToAddress and WSAAddressToString.
        //
        if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_18);
    // printf("WSAStartup failed\n");

            exit(1);
        }

        //
        // First request write access.
        // This will fail if the process does not have appropriate privs.
        //
        Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,   // security attributes
                             OPEN_EXISTING,
                             0,      // flags & attributes
                             NULL);  // template file
        if (Handle == INVALID_HANDLE_VALUE) {
            //
            // We will not have Administrator access to the stack.
            //
            AdminAccess = FALSE;

            Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                                 0,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,   // security attributes
                                 OPEN_EXISTING,
                                 0,      // flags & attributes
                                 NULL);  // template file
            if (Handle == INVALID_HANDLE_VALUE) {
                if (IsIpv6Installed()) {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_IPV6_NOT_RUNNING);
// printf("Could not access IPv6 protocol stack - the stack is not running.\n");
// printf("To start it, please use 'net start tcpip6'.\n");
                } else {
                    NlsPutMsg(STDOUT, IPV6_MESSAGE_IPV6_NOT_INSTALLED);
// printf("Could not access IPv6 protocol stack - the stack is not installed.\n");
// printf("To install, please use 'ipv6 install'.\n");
                }

                exit(1);
            }
        }

        if (!strcmp(argv[0], "if")) {
            QueryInterface(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ifcr")) {
            if (! AdminAccess)
                ausage();
            CreateInterface(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ifc")) {
            if (! AdminAccess)
                ausage();
            UpdateInterface(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ifd")) {
            if (! AdminAccess)
                ausage();
            DeleteInterface(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "renew")) {
            if (! AdminAccess)
                ausage();
            RenewInterface(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "adu")) {
            if (! AdminAccess)
                ausage();
            UpdateAddress(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "nc")) {
            QueryNeighborCache(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ncf")) {
            if (! AdminAccess)
                ausage();
            FlushNeighborCache(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "rc")) {
            QueryRouteCache(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "rcf")) {
            if (! AdminAccess)
                ausage();
            FlushRouteCache(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "rlu")) {
            if (! AdminAccess)
                ausage();
            UpdateRouterLinkAddress(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "rt")) {
            QueryRouteTable(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "rtu")) {
            if (! AdminAccess)
                ausage();
            UpdateRouteTable(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "spt")) {
            QuerySitePrefixTable(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "spu")) {
            if (! AdminAccess)
                ausage();
            UpdateSitePrefixTable(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "bc")) {
            QueryBindingCache(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "gp")) {
            QueryGlobalParameters(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "gpu")) {
            if (! AdminAccess)
                ausage();
            UpdateGlobalParameters(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ppt")) {
            QueryPrefixPolicy(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ppu")) {
            if (! AdminAccess)
                ausage();
            UpdatePrefixPolicy(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "ppd")) {
            if (! AdminAccess)
                ausage();
            DeletePrefixPolicy(argc - 1, argv + 1);
        }
        else if (!strcmp(argv[0], "reset")) {
            if (! AdminAccess)
                ausage();
            ResetManualConfig(argc - 1, argv + 1);
        }
        else {
            usage();
        }
    }

    return 0;
}

int
GetNumber(char *astr, u_int *number)
{
    u_int num;

    num = 0;
    while (*astr != '\0') {
        if (('0' <= *astr) && (*astr <= '9'))
            num = 10 * num + (*astr - '0');
        else
            return FALSE;
        astr++;
    }

    *number = num;
    return TRUE;
}

int
GetGuid(char *astr, GUID *Guid)
{
    WCHAR GuidStr[40+1];
    UNICODE_STRING UGuidStr;

    MultiByteToWideChar(CP_ACP, 0, astr, -1, GuidStr, 40);

    RtlInitUnicodeString(&UGuidStr, GuidStr);
    return RtlGUIDFromString(&UGuidStr, Guid) == STATUS_SUCCESS;
}

char *
FormatGuid(const GUID *pGuid)
{
    static char buffer[40];

    sprintf(buffer,
            "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            pGuid->Data1,
            pGuid->Data2,
            pGuid->Data3,
            pGuid->Data4[0],
            pGuid->Data4[1],
            pGuid->Data4[2],
            pGuid->Data4[3],
            pGuid->Data4[4],
            pGuid->Data4[5],
            pGuid->Data4[6],
            pGuid->Data4[7]);
    return buffer;
}

int
GetInterface(char *astr, IPV6_QUERY_INTERFACE *Query)
{
    if (*astr == '{') {
        //
        // Read a guid.
        //
        Query->Index = 0;
        return GetGuid(astr, &Query->Guid);

    } else {
        //
        // Read a non-zero interface index.
        //
        return GetNumber(astr, &Query->Index) && (Query->Index != 0);
    }
}

#define SECONDS         1
#define MINUTES         (60 * SECONDS)
#define HOURS           (60 * MINUTES)
#define DAYS            (24 * HOURS)

int
GetLifetime(char *astr, u_int *number)
{
    char *pUnit;
    u_int units;
    u_int value;

    *number = 0;

    while ((pUnit = strpbrk(astr, "sSmMhHdD")) != NULL) {

        switch (*pUnit) {
        case 's':
        case 'S':
            units = SECONDS;
            break;
        case 'm':
        case 'M':
            units = MINUTES;
            break;
        case 'h':
        case 'H':
            units = HOURS;
            break;
        case 'd':
        case 'D':
            units = DAYS;
            break;
        }

        *pUnit = '\0';
        if (! GetNumber(astr, &value))
            return FALSE;

        *number += units * value;

        astr = pUnit + 1;
        if (*astr == '\0')
            return TRUE;
    }

    if (! GetNumber(astr, &value))
        return FALSE;

    *number += value;
    return TRUE;
}

int
GetLifetimes(char *astr, u_int *valid, u_int *preferred)
{
    char *slash;
    u_int length;

    slash = strchr(astr, '/');
    if (slash == NULL) {
        if (strcmp(astr, "infinite")) {
            if (! GetLifetime(astr, valid))
                return FALSE;

            if (preferred != NULL)
                *preferred = *valid;
        }

        return TRUE;
    }

    if (preferred == NULL)
        return FALSE;

    *slash = '\0';

    if (strcmp(astr, "infinite"))
        if (! GetLifetime(astr, valid))
            return FALSE;

    if (strcmp(slash+1, "infinite"))
        if (! GetLifetime(slash+1, preferred))
            return FALSE;

    return TRUE;
}

char *
FormatLifetime(u_int Life)
{
    static char buffer[64];
    char *s = buffer;
    u_int Days, Hours, Minutes;

    if (Life == INFINITE_LIFETIME)
        return "infinite";

    if (Verbose)
        goto FormatSeconds;

    if (Life < 2 * MINUTES)
        goto FormatSeconds;

    if (Life < 2 * HOURS)
        goto FormatMinutes;

    if (Life < 2 * DAYS)
        goto FormatHours;

    Days = Life / DAYS;
    if (Days != 0)
        s += sprintf(s, "%ud", Days);
    Life -= Days * DAYS;

FormatHours:
    Hours = Life / HOURS;
    if (Hours != 0)
        s += sprintf(s, "%uh", Hours);
    Life -= Hours * HOURS;

FormatMinutes:
    Minutes = Life / MINUTES;
    if (Minutes != 0)
        s += sprintf(s, "%um", Minutes);
    Life -= Minutes * MINUTES;

    if (Life == 0)
        return buffer;

FormatSeconds:
    (void) sprintf(s, "%us", Life);
    return buffer;
}

char *
FormatLifetimes(u_int Valid, u_int Preferred)
{
    static char buffer[128];
    char *s = buffer;

    s += sprintf(s, "%s", FormatLifetime(Valid));
    if (Preferred != Valid)
        s += sprintf(s, "/%s", FormatLifetime(Preferred));

    return buffer;
}

int
GetAddress(char *astr, IPv6Addr *address)
{
    struct sockaddr_in6 sin6;
    int addrlen = sizeof sin6;

    sin6.sin6_family = AF_INET6; // shouldn't be required but is

    if ((WSAStringToAddress(astr, AF_INET6, NULL,
                           (struct sockaddr *)&sin6, &addrlen)
                    == SOCKET_ERROR) ||
        (sin6.sin6_port != 0) ||
        (sin6.sin6_scope_id != 0))
        return FALSE;

    // The user gave us a numeric IPv6 address.

    memcpy(address, &sin6.sin6_addr, sizeof *address);
    return TRUE;
}

int
GetPrefix(char *astr, IPv6Addr *prefix, u_int *prefixlen)
{
    struct sockaddr_in6 sin6;
    int addrlen = sizeof sin6;
    char *slash;
    u_int length;

    slash = strchr(astr, '/');
    if (slash == NULL)
        return FALSE;
    *slash = '\0';

    if (! GetNumber(slash+1, &length))
        return FALSE;
    if (length > 128)
        return FALSE;

    sin6.sin6_family = AF_INET6; // shouldn't be required but is

    if ((WSAStringToAddress(astr, AF_INET6, NULL,
                           (struct sockaddr *)&sin6, &addrlen)
                    == SOCKET_ERROR) ||
        (sin6.sin6_port != 0) ||
        (sin6.sin6_scope_id != 0))
        return FALSE;

    // The user gave us a numeric IPv6 address.

    memcpy(prefix, &sin6.sin6_addr, sizeof *prefix);
    *prefixlen = length;
    return TRUE;
}

const char *PrefixConfStr[] = {
    "other", "manual", "well-known", "dhcp", "ra",
    NULL
};
#define MAX_PREFIX_CONF (sizeof(PrefixConfStr) / sizeof(char *))

const char *InterfaceIdConfStr[] = {
    "other", "manual", "well-known", "dhcp", "LL-address-derived", "random",
    NULL
};
#define MAX_IID_CONF (sizeof(InterfaceIdConfStr) / sizeof(char *))

int
GetPrefixOrigin(char *astr, u_int *origin)
{
    int i;
    for (i=0; PrefixConfStr[i]; i++) {
        if (!strcmp(astr, PrefixConfStr[i])) {
            *origin = i;
            return TRUE;
        }
    }
    return FALSE;
}

int
GetInterfaceIdOrigin(char *astr, u_int *origin)
{
    int i;
    for (i=0; InterfaceIdConfStr[i]; i++) {
        if (!strcmp(astr, InterfaceIdConfStr[i])) {
            *origin = i;
            return TRUE;
        }
    }
    return FALSE;
}

int
GetNeighbor(char *astr, IPV6_QUERY_INTERFACE *IF, IPv6Addr *addr)
{
    struct sockaddr_in6 sin6;
    int addrlen = sizeof sin6;
    char *slash;
    u_int length;

    slash = strchr(astr, '/');
    if (slash != NULL)
        *slash = '\0';

    if (! GetInterface(astr, IF))
        return FALSE;

    if (slash == NULL) {
        *addr = in6addr_any;
        return TRUE;
    }

    sin6.sin6_family = AF_INET6; // shouldn't be required but is

    if ((WSAStringToAddress(slash+1, AF_INET6, NULL,
                           (struct sockaddr *)&sin6, &addrlen)
                    == SOCKET_ERROR) ||
        (sin6.sin6_port != 0) ||
        (sin6.sin6_scope_id != 0))
        return FALSE;

    // The user gave us a numeric IPv6 address.

    *addr = sin6.sin6_addr;
    return TRUE;
}

char *
FormatIPv6Address(IPv6Addr *Address)
{
    static char buffer[128];
    DWORD buflen = sizeof buffer;
    struct sockaddr_in6 sin6;

    memset(&sin6, 0, sizeof sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_addr = *Address;

    if (WSAAddressToString((struct sockaddr *) &sin6,
                           sizeof sin6,
                           NULL,       // LPWSAPROTOCOL_INFO
                           buffer,
                           &buflen) == SOCKET_ERROR)
        strcpy(buffer, "<invalid>");

    return buffer;
}

char *
FormatIPv4Address(struct in_addr *Address)
{
    static char buffer[128];
    DWORD buflen = sizeof buffer;
    struct sockaddr_in sin;

    memset(&sin, 0, sizeof sin);
    sin.sin_family = AF_INET;
    sin.sin_addr = *Address;

    if (WSAAddressToString((struct sockaddr *) &sin,
                           sizeof sin,
                           NULL,       // LPWSAPROTOCOL_INFO
                           buffer,
                           &buflen) == SOCKET_ERROR)
        strcpy(buffer, "<invalid>");

    return buffer;
}

char *
FormatLinkLayerAddress(u_int length, u_char *addr)
{
    static char buffer[128];

    switch (length) {
    case 6: {
        int i, digit;
        char *s = buffer;

        for (i = 0; i < 6; i++) {
            if (i != 0)
                *s++ = '-';

            digit = addr[i] >> 4;
            if (digit < 10)
                *s++ = digit + '0';
            else
                *s++ = digit - 10 + 'a';

            digit = addr[i] & 0xf;
            if (digit < 10)
                *s++ = digit + '0';
            else
                *s++ = digit - 10 + 'a';
        }
        *s = '\0';
        break;
    }

    case 4:
        //
        // IPv4 address (6-over-4 link)
        //
        strcpy(buffer, FormatIPv4Address((struct in_addr *)addr));
        break;

    case 0:
        //
        // Null or loop-back address
        //
        buffer[0] = '\0';
        break;

    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_21);
// printf("unrecognized link-layer address format\n");

        exit(1);
    }

    return buffer;
}

void
ForEachAddress(IPV6_INFO_INTERFACE *IF,
               void (*func)(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *))
{
    IPV6_QUERY_ADDRESS Query;
    IPV6_INFO_ADDRESS ADE;
    u_int BytesReturned;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_22, FormatIPv6Address(&Query.Address));
// printf("bad address %s\n", FormatIPv6Address(&Query.Address));

            exit(1);
        }

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if (BytesReturned != sizeof ADE) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_INCONSISTENT_ADDRESS);
// printf("inconsistent address info length\n");
                exit(1);
            }

            (*func)(IF, &ADE);
        }
        else {
            if (BytesReturned != sizeof ADE.Next) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_INCONSISTENT_ADDRESS);
// printf("inconsistent address info length\n");
                exit(1);
            }
        }

        if (IN6_ADDR_EQUAL(&ADE.Next.Address, &in6addr_any))
            break;
        Query = ADE.Next;
    }
}

void
ForEachPersistentAddress(IPV6_INFO_INTERFACE *IF,
               void (*func)(IPV6_INFO_INTERFACE *IF, IPV6_UPDATE_ADDRESS *))
{
    IPV6_PERSISTENT_QUERY_ADDRESS Query;
    IPV6_UPDATE_ADDRESS ADE;
    u_int BytesReturned;

    Query.IF.RegistryIndex = (u_int) -1;
    Query.IF.Guid = IF->This.Guid;

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle,
                             IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL) ||
            (BytesReturned != sizeof ADE)) {

            if (GetLastError() == ERROR_NO_MORE_ITEMS)
                break;

            NlsPutMsg(STDOUT, IPV6_MESSAGE_22, FormatIPv6Address(&Query.Address));
// printf("bad address %s\n", FormatIPv6Address(&Query.Address));

            exit(1);
        }

        (*func)(IF, &ADE);
    }
}

const char *
FormatDADState(u_int DADState)
{
    static char buffer[128];

    switch (DADState) {
    case DAD_STATE_INVALID:
        return "invalid";
    case DAD_STATE_DUPLICATE:
        return "duplicate";
    case DAD_STATE_TENTATIVE:
        return "tentative";
    case DAD_STATE_DEPRECATED:
        return "deprecated";
    case DAD_STATE_PREFERRED:
        return "preferred";
    default:
        sprintf(buffer, "DAD state %u>", DADState);
        return buffer;
    }
}

const char *
FormatScopeAdj(u_int Scope)
{
    static char buffer[128];

    switch (Scope) {
    case ADE_INTERFACE_LOCAL:
        return "interface-local";
    case ADE_LINK_LOCAL:
        return "link-local";
    case ADE_SUBNET_LOCAL:
        return "subnet-local";
    case ADE_ADMIN_LOCAL:
        return "admin-local";
    case ADE_SITE_LOCAL:
        return "site-local";
    case ADE_ORG_LOCAL:
        return "org-local";
    case ADE_GLOBAL:
        return "global";
    default:
        sprintf(buffer, "scope %u", Scope);
        return buffer;
    }
}

const char *
FormatScopeNoun(u_int Scope)
{
    static char buffer[128];

    switch (Scope) {
    case ADE_INTERFACE_LOCAL:
        return "if";
    case ADE_LINK_LOCAL:
        return "link";
    case ADE_SUBNET_LOCAL:
        return "subnet";
    case ADE_ADMIN_LOCAL:
        return "admin";
    case ADE_SITE_LOCAL:
        return "site";
    case ADE_ORG_LOCAL:
        return "org";
    case ADE_GLOBAL:
        return "global";
    default:
        sprintf(buffer, "zone%u", Scope);
        return buffer;
    }
}

void
PrintAddrOrigin(u_int PrefixConf, u_int InterfaceIdConf)
{
    if ((PrefixConf == PREFIX_CONF_MANUAL) &&
        (InterfaceIdConf == IID_CONF_MANUAL)) {

        NlsPutMsg(STDOUT, IPV6_MESSAGE_25);
// printf(" (manual)");

    } else if ((PrefixConf == PREFIX_CONF_RA) &&
        (InterfaceIdConf == IID_CONF_LL_ADDRESS)) {

        NlsPutMsg(STDOUT, IPV6_MESSAGE_26);
// printf(" (public)");

    } else if ((PrefixConf == PREFIX_CONF_RA) &&
        (InterfaceIdConf == IID_CONF_RANDOM)) {

        NlsPutMsg(STDOUT, IPV6_MESSAGE_27);
// printf(" (temporary)");

    } else if ((PrefixConf == PREFIX_CONF_DHCP) &&
        (InterfaceIdConf == IID_CONF_DHCP)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_28);
// printf(" (dhcp)");

    }

    if (Verbose) {
        //
        // Show prefix origin / interface id origin
        //
        NlsPutMsg(STDOUT, IPV6_MESSAGE_29);
// printf(" (");

        if (PrefixConf >= MAX_PREFIX_CONF)
            NlsPutMsg(STDOUT, IPV6_MESSAGE_30, PrefixConf);
// printf("unknown prefix origin %u", PrefixConf);

        else
            printf(PrefixConfStr[PrefixConf]);

        NlsPutMsg(STDOUT, IPV6_MESSAGE_32);
// printf("/");

        if (InterfaceIdConf >= MAX_IID_CONF)
            NlsPutMsg(STDOUT, IPV6_MESSAGE_33, InterfaceIdConf);
// printf("unknown ifid origin %u", InterfaceIdConf);

        else
            printf(InterfaceIdConfStr[InterfaceIdConf]);

        NlsPutMsg(STDOUT, IPV6_MESSAGE_35);
// printf(")");
    }
}

void
PrintAddress(IPV6_INFO_INTERFACE *IF, IPV6_INFO_ADDRESS *ADE)
{
    if (!Verbose) {
        //
        // Suppress invalid addresses.
        //
        if ((ADE->Type == ADE_UNICAST) &&
            (ADE->DADState == DAD_STATE_INVALID))
            return;
    }

    switch (ADE->Type) {
    case ADE_UNICAST:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_23,
                  FormatDADState(ADE->DADState),
                  FormatScopeAdj(ADE->Scope),
                  FormatIPv6Address(&ADE->This.Address));
// printf("    %s %s %s, ",
//        FormatDADState(ADE->DADState),
//        FormatScopeAdj(ADE->Scope),
//        FormatIPv6Address(&ADE->This.Address));


        NlsPutMsg(STDOUT, IPV6_MESSAGE_24,
                  FormatLifetimes(ADE->ValidLifetime, ADE->PreferredLifetime));
// printf("life %s",
//        FormatLifetimes(ADE->ValidLifetime, ADE->PreferredLifetime));


        PrintAddrOrigin(ADE->PrefixConf, ADE->InterfaceIdConf);

        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

        break;

    case ADE_ANYCAST:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_37,
                  FormatScopeAdj(ADE->Scope),
                  FormatIPv6Address(&ADE->This.Address));
// printf("    anycast %s %s\n",
//        FormatScopeAdj(ADE->Scope),
//        FormatIPv6Address(&ADE->This.Address));

        break;

    case ADE_MULTICAST:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_38,
                  FormatScopeAdj(ADE->Scope),
                  FormatIPv6Address(&ADE->This.Address),
                  ADE->MCastRefCount);
// printf("    multicast %s %s, %u refs",
//        FormatScopeAdj(ADE->Scope),
//        FormatIPv6Address(&ADE->This.Address),
//        ADE->MCastRefCount);

        if (!(ADE->MCastFlags & 0x01))
            NlsPutMsg(STDOUT, IPV6_MESSAGE_39);
// printf(", not reportable");

        if (ADE->MCastFlags & 0x02)
            NlsPutMsg(STDOUT, IPV6_MESSAGE_40);
// printf(", last reporter");

        if (ADE->MCastTimer != 0)
            NlsPutMsg(STDOUT, IPV6_MESSAGE_41, ADE->MCastTimer);
// printf(", %u seconds until report", ADE->MCastTimer);

        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

        break;

    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_42,
                  FormatScopeAdj(ADE->Scope), ADE->Type);
// printf("    unknown %s address type %u\n",
//        FormatScopeAdj(ADE->Scope), ADE->Type);

        break;
    }
}

u_int
AddressScope(IPv6Addr *Address)
{
    if (IN6_IS_ADDR_LINKLOCAL(Address))
        return ADE_LINK_LOCAL;
    else if (IN6_IS_ADDR_SITELOCAL(Address))
        return ADE_SITE_LOCAL;
    else if (IN6_IS_ADDR_LOOPBACK(Address))
        return ADE_LINK_LOCAL;
    else
        return ADE_GLOBAL;
}

void
PrintPersistentAddress(IPV6_INFO_INTERFACE *IF, IPV6_UPDATE_ADDRESS *ADE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_23,
              ((ADE->Type == ADE_ANYCAST) ?
               "anycast" :
               FormatDADState((ADE->PreferredLifetime == 0) ?
                              DAD_STATE_DEPRECATED : DAD_STATE_PREFERRED)),
              FormatScopeAdj(AddressScope(&ADE->This.Address)),
              FormatIPv6Address(&ADE->This.Address));
// printf("    %s %s %s, ",

    NlsPutMsg(STDOUT, IPV6_MESSAGE_24,
              FormatLifetimes(ADE->ValidLifetime, ADE->PreferredLifetime));
// printf("life %s",

    PrintAddrOrigin(ADE->PrefixConf, ADE->InterfaceIdConf);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");
}

IPV6_INFO_INTERFACE *
GetInterfaceInfo(IPV6_QUERY_INTERFACE *Query)
{
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = malloc(InfoSize);
    if (IF == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_43);
// printf("malloc failed\n");

        exit(1);
    }

    if (!DeviceIoControl(Handle,
                         IOCTL_IPV6_QUERY_INTERFACE,
                         Query, sizeof *Query,
                         IF, InfoSize, &BytesReturned,
                         NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_44, Query->Index);
// printf("bad index %u\n", Query->Index);

        exit(1);
    }

    if ((BytesReturned < sizeof *IF) ||
        (IF->Length < sizeof *IF) ||
        (BytesReturned != IF->Length +
         ((IF->LocalLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0) +
         ((IF->RemoteLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0))) {

        NlsPutMsg(STDOUT, IPV6_MESSAGE_45);
// printf("inconsistent interface info length\n");

        exit(1);
    }

    return IF;
}

IPV6_INFO_INTERFACE *
GetPersistentInterfaceInfo(IPV6_PERSISTENT_QUERY_INTERFACE *Query)
{
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = malloc(InfoSize);
    if (IF == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_43);
// printf("malloc failed\n");

        exit(1);
    }

    if (!DeviceIoControl(Handle,
                         IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE,
                         Query, sizeof *Query,
                         IF, InfoSize, &BytesReturned,
                         NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_44, Query->RegistryIndex);
// printf("bad index %u\n", Query->RegistryIndex);

        exit(1);
    }

    if ((BytesReturned < sizeof *IF) ||
        (IF->Length < sizeof *IF) ||
        (BytesReturned != IF->Length +
         ((IF->LocalLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0) +
         ((IF->RemoteLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0))) {

        NlsPutMsg(STDOUT, IPV6_MESSAGE_45);
// printf("inconsistent interface info length\n");

        exit(1);
    }

    return IF;
}

void
ForEachInterface(void (*func)(IPV6_INFO_INTERFACE *))
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = malloc(InfoSize);
    if (IF == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_43);
// printf("malloc failed\n");

        exit(1);
    }

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_46, Query.Index);
// printf("bad index %u\n", Query.Index);

            exit(1);
        }

        if (Query.Index != (u_int) -1) {

            if ((BytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (BytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {

                NlsPutMsg(STDOUT, IPV6_MESSAGE_45);
// printf("inconsistent interface info length\n");
                exit(1);
            }

            (*func)(IF);
        }
        else {
            if (BytesReturned != sizeof IF->Next) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_45);
// printf("inconsistent interface info length\n");
                exit(1);
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    free(IF);
}

void
ForEachPersistentInterface(void (*func)(IPV6_INFO_INTERFACE *))
{
    IPV6_PERSISTENT_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = malloc(InfoSize);
    if (IF == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_43);
// printf("malloc failed\n");

        exit(1);
    }

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle,
                             IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, InfoSize, &BytesReturned,
                             NULL)) {
            if (GetLastError() == ERROR_NO_MORE_ITEMS)
                break;

            NlsPutMsg(STDOUT, IPV6_MESSAGE_46, Query.RegistryIndex);
// printf("bad index %u\n", Query.RegistryIndex);

            exit(1);
        }

        if ((BytesReturned < sizeof *IF) ||
            (IF->Length < sizeof *IF) ||
            (BytesReturned != IF->Length +
             ((IF->LocalLinkLayerAddress != 0) ?
              IF->LinkLayerAddressLength : 0) +
             ((IF->RemoteLinkLayerAddress != 0) ?
              IF->LinkLayerAddressLength : 0))) {

            NlsPutMsg(STDOUT, IPV6_MESSAGE_45);
// printf("inconsistent interface info length\n");
            exit(1);
        }

        (*func)(IF);
    }

    free(IF);
}

#ifndef IP_TYPES_INCLUDED
//
// The real version of this structure in iptypes.h
// has more fields, but these are all we need here.
//

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.

typedef struct _IP_ADAPTER_INFO {
    struct _IP_ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD Index;
} IP_ADAPTER_INFO;
#endif // IP_TYPES_INCLUDED

DWORD (WINAPI *pGetAdaptersInfo)(IP_ADAPTER_INFO *pAdapterInfo, ULONG *pOutBufLen);

IP_ADAPTER_INFO *pAdapterInfo;

HRESULT (WINAPI *pHrLanConnectionNameFromGuidOrPath)(
    const GUID *pGuid,
    LPCWSTR pszwPath,
    LPWSTR pszwName,
    LPDWORD pcchMax);

#define IPHLPAPI_LIBRARY_NAME "iphlpapi.dll"
#define NETMAN_LIBRARY_NAME   "netman.dll"

void
InitializeAdaptersInfo(void)
{
    HMODULE hModule;
    CHAR SystemDir[MAX_PATH + 1];
    CHAR Path[MAX_PATH + sizeof(IPHLPAPI_LIBRARY_NAME) + 2];

    pAdapterInfo = NULL;
    if (GetSystemDirectory(SystemDir, MAX_PATH) == 0) {
        return;
    }

    //
    // Check if the GetAdaptersInfo API is available on this system.
    //
    lstrcpy(Path, SystemDir);
    lstrcat(Path, "\\" IPHLPAPI_LIBRARY_NAME);
    hModule = LoadLibrary(Path);
    if (hModule != NULL) {

        pGetAdaptersInfo = (DWORD (WINAPI *)(IP_ADAPTER_INFO *, ULONG *))
            GetProcAddress(hModule, "GetAdaptersInfo");
        //
        // We don't release hModule, to keep the module loaded.
        //
        if (pGetAdaptersInfo != NULL) {
            ULONG BufLen = 0;
            DWORD error;

            //
            // If this returns something other than buffer-overflow,
            // it probably means that GetAdaptersInfo is not supported.
            //
            error = (*pGetAdaptersInfo)(NULL, &BufLen);
            if (error == ERROR_BUFFER_OVERFLOW) {
                pAdapterInfo = (IP_ADAPTER_INFO *) malloc(BufLen);
                if (pAdapterInfo != NULL) {
                    error = (*pGetAdaptersInfo)(pAdapterInfo, &BufLen);
                    if (error != 0) {
                        free(pAdapterInfo);
                        pAdapterInfo = NULL;
                    }
                }
            }
        }
    }

    //
    // Only bother with HrLanConnectionNameFromGuidOrPath
    // if we could get pAdapterInfo.
    //
    if (pAdapterInfo != NULL) {
        lstrcpy(Path, SystemDir);
        lstrcat(Path, "\\" NETMAN_LIBRARY_NAME);
        hModule = LoadLibrary(Path);
        if (hModule != NULL) {

            pHrLanConnectionNameFromGuidOrPath =
                (HRESULT (WINAPI *)(const GUID *, LPCWSTR, LPWSTR, LPDWORD))
                GetProcAddress(hModule, "HrLanConnectionNameFromGuidOrPath");
            //
            // We don't release hModule, to keep the module loaded.
            //
        }

        if (pHrLanConnectionNameFromGuidOrPath == NULL) {
            free(pAdapterInfo);
            pAdapterInfo = NULL;
        }
    }
}

#define MAX_FRIENDLY_NAME_LENGTH 2000

LPSTR
MapAdapterNameToFriendly(LPSTR AdapterName)
{
    WCHAR wszAdapterName[MAX_ADAPTER_NAME_LENGTH];
    WCHAR wszFriendlyName[MAX_FRIENDLY_NAME_LENGTH];
    DWORD cchFriendlyName = MAX_FRIENDLY_NAME_LENGTH;
    static CHAR FriendlyName[MAX_FRIENDLY_NAME_LENGTH];

    MultiByteToWideChar(CP_ACP, 0, AdapterName, -1,
                        wszAdapterName, MAX_ADAPTER_NAME_LENGTH);

    if((*pHrLanConnectionNameFromGuidOrPath)(
                NULL, wszAdapterName, wszFriendlyName, &cchFriendlyName))
        return NULL;

    WideCharToMultiByte(CP_ACP, 0, wszFriendlyName, -1,
                        FriendlyName, MAX_FRIENDLY_NAME_LENGTH,
                        NULL, NULL);
    return FriendlyName;
}

LPSTR
MapAdapterAddressToFriendly(u_char *Address, u_int AddressLength)
{
    IP_ADAPTER_INFO *pAdapter;

    for (pAdapter = pAdapterInfo;
         pAdapter != NULL;
         pAdapter = pAdapter->Next) {

        if ((AddressLength == pAdapter->AddressLength) &&
            ! memcmp(Address, pAdapter->Address, AddressLength))
            return MapAdapterNameToFriendly(pAdapter->AdapterName);
    }

    return NULL;
}

int
ShouldPrintZones(IPV6_INFO_INTERFACE *IF)
{
    u_int Scope;

    for (Scope = ADE_SMALLEST_SCOPE; Scope <= ADE_LINK_LOCAL; Scope++)
        if (IF->ZoneIndices[Scope] != IF->This.Index)
            return TRUE;

    for (; Scope <= ADE_LARGEST_SCOPE; Scope++)
        if (IF->ZoneIndices[Scope] != 1)
            return TRUE;

    return FALSE;
}

void
PrintInterface(IPV6_INFO_INTERFACE *IF)
{
    LPSTR FriendlyName;
    u_int Scope;

    if (IF->LocalLinkLayerAddress == 0)
        FriendlyName = NULL;
    else
        FriendlyName = MapAdapterAddressToFriendly(
            (u_char *)IF + IF->LocalLinkLayerAddress,
            IF->LinkLayerAddressLength);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_47, IF->This.Index);
// printf("Interface %u:", IF->This.Index);

    switch (IF->Type) {
    case IPV6_IF_TYPE_LOOPBACK:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_48);
        // printf(" Loopback Pseudo-Interface");
        break;
        
    case IPV6_IF_TYPE_ETHERNET:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_49);
        // printf(" Ethernet");
        break;
    case IPV6_IF_TYPE_FDDI:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_50);
        // printf(" FDDI");
        break;
        
    case IPV6_IF_TYPE_TUNNEL_AUTO:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_51);
        // printf(" Automatic Tunneling Pseudo-Interface");
        break;
        
    case IPV6_IF_TYPE_TUNNEL_6OVER4:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_52);
        // printf(" 6-over-4 Virtual Interface");
        break;
        
    case IPV6_IF_TYPE_TUNNEL_V6V4:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_53);
        // printf(" Configured Tunnel Interface");
        break;
        
    case IPV6_IF_TYPE_TUNNEL_6TO4:
        NlsPutMsg(STDOUT, IPV6_6TO4_INTERFACE);
        // printf(" 6to4 Tunneling Pseudo-Interface");
        break;
        
    case IPV6_IF_TYPE_TUNNEL_TEREDO:
        NlsPutMsg(STDOUT, IPV6_TEREDO_INTERFACE);
        // printf(" Teredo Tunneling Pseudo-Interface");
        break;
    }

    if (FriendlyName != NULL)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_54, FriendlyName);
// printf(": %s", FriendlyName);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

    NlsPutMsg(STDOUT, IPV6_MESSAGE_GUID, FormatGuid(&IF->This.Guid));
// printf("  Guid %s\n", FormatGuid(&IF->This.Guid));

    if (Verbose || ShouldPrintZones(IF)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_55);
// printf("  zones:");

        for (Scope = ADE_LINK_LOCAL; Scope < ADE_GLOBAL; Scope++) {
            u_int Expected;

            if ((Scope == ADE_LINK_LOCAL) ||
                (Scope == ADE_SITE_LOCAL))
                Expected = 0;   // Always print link & site.
            else
                Expected = IF->ZoneIndices[Scope + 1];

            if (IF->ZoneIndices[Scope] != Expected)
                NlsPutMsg(STDOUT, IPV6_MESSAGE_56,
                          FormatScopeNoun(Scope),
                          IF->ZoneIndices[Scope]);
// printf(" %s %u",
//        FormatScopeNoun(Scope),
//        IF->ZoneIndices[Scope]);

        }
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

    }

    switch (IF->MediaStatus) {
    case IPV6_IF_MEDIA_STATUS_DISCONNECTED:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_57);
// printf("  cable unplugged\n");

        break;
    case IPV6_IF_MEDIA_STATUS_RECONNECTED:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_58);
// printf("  cable reconnected\n");

        break;
    case IPV6_IF_MEDIA_STATUS_CONNECTED:
        break;
    }

    if (IF->NeighborDiscovers)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_USES_ND);
// printf("  uses Neighbor Discovery\n");
    else
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_USE_ND);
// printf("  does not use Neighbor Discovery\n");

    if (IF->RouterDiscovers)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_USES_RD);
    else
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_USE_RD);

    if (IF->Advertises)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_SENDS_RAs);
// printf("  sends Router Advertisements\n");

    if (IF->Forwards)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_FORWARDS);
// printf("  forwards packets\n");

    if (IF->PeriodicMLD)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_SENDS_PERIODIC_MLD);
// printf("  periodically sends MLD Reports\n");

    if (IF->Preference != 0)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_64, IF->Preference);
// printf("  routing preference %u\n", IF->Preference);

    if (IF->Type == IPV6_IF_TYPE_TUNNEL_AUTO) {
        if (IF->LocalLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_TOKEN_ADDRESS,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->LocalLinkLayerAddress));
// printf("  EUI-64 embedded IPv4 address: %s\n",
        }

        if (IF->RemoteLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_ROUTER_LL_ADDRESS,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->RemoteLinkLayerAddress));
// printf("  router link-layer address: %s\n",
        }
    }
    else {
        if (IF->LocalLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_65,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->LocalLinkLayerAddress));
// printf("  link-layer address: %s\n",
        }

        if (IF->RemoteLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_66,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->RemoteLinkLayerAddress));
// printf("  remote link-layer address: %s\n",
        }
    }

    ForEachAddress(IF, PrintAddress);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_67, IF->LinkMTU, IF->TrueLinkMTU);
// printf("  link MTU %u (true link MTU %u)\n",
//        IF->LinkMTU, IF->TrueLinkMTU);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_68, IF->CurHopLimit);
// printf("  current hop limit %u\n", IF->CurHopLimit);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_69,
              IF->ReachableTime, IF->BaseReachableTime);
// printf("  reachable time %ums (base %ums)\n",
//        IF->ReachableTime, IF->BaseReachableTime);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_70, IF->RetransTimer);
// printf("  retransmission interval %ums\n", IF->RetransTimer);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_71, IF->DupAddrDetectTransmits);
// printf("  DAD transmits %u\n", IF->DupAddrDetectTransmits);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_DEFAULT_SITE_PREFIX_LENGTH,
              IF->DefSitePrefixLength);
// printf("    default site prefix length %u\n",
}

void
PrintPersistentInterface(IPV6_INFO_INTERFACE *IF)
{
    u_int Scope;

    NlsPutMsg(STDOUT, IPV6_MESSAGE_INTERFACE);
// printf("Interface:"

    switch (IF->Type) {
    case IPV6_IF_TYPE_LOOPBACK:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_48);
// printf(" Loopback Pseudo-Interface");

        break;
    case IPV6_IF_TYPE_ETHERNET:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_49);
// printf(" Ethernet");

        break;
    case IPV6_IF_TYPE_FDDI:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_50);
// printf(" FDDI");

        break;
    case IPV6_IF_TYPE_TUNNEL_AUTO:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_51);
// printf(" Automatic Tunneling Pseudo-Interface");

        break;
    case IPV6_IF_TYPE_TUNNEL_6OVER4:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_52);
// printf(" 6-over-4 Virtual Interface");

        break;
    case IPV6_IF_TYPE_TUNNEL_V6V4:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_53);
// printf(" Configured Tunnel Interface");

        break;
    case IPV6_IF_TYPE_TUNNEL_6TO4:
        NlsPutMsg(STDOUT, IPV6_6TO4_INTERFACE);
        // printf(" 6to4 Tunneling Pseudo-Interface");
        break;
    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

    NlsPutMsg(STDOUT, IPV6_MESSAGE_GUID, FormatGuid(&IF->This.Guid));
// printf("  Guid %s\n", FormatGuid(&IF->This.Guid));

    if (IF->NeighborDiscovers == TRUE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_USES_ND);
// printf("  uses Neighbor Discovery\n");
    else if (IF->NeighborDiscovers == FALSE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_USE_ND);
// printf("  does not use Neighbor Discovery\n");

    if (IF->RouterDiscovers == TRUE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_USES_RD);
    else if (IF->RouterDiscovers == FALSE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_USE_RD);

    if (IF->Advertises == TRUE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_SENDS_RAs);
// printf("  sends Router Advertisements\n");
    else if (IF->Advertises == FALSE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_SEND_RAs);
// printf("  does not send Router Advertisements\n");

    if (IF->Forwards == TRUE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_FORWARDS);
// printf("  forwards packets\n");
    else if (IF->Forwards == FALSE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_FORWARD);
// printf("  does not forward packets\n");

    if (IF->PeriodicMLD == TRUE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_SENDS_PERIODIC_MLD);
// printf("  periodically sends MLD Reports\n");
    else if (IF->PeriodicMLD == FALSE)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DOESNT_SEND_PERIODIC_MLD);
// printf("  does not periodically send MLD Reports\n");

    if (IF->Preference != (u_int)-1)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_64, IF->Preference);
// printf("  routing preference %u\n", IF->Preference);


    if (IF->Type == IPV6_IF_TYPE_TUNNEL_AUTO) {
        if (IF->LocalLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_TOKEN_ADDRESS,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->LocalLinkLayerAddress));
// printf("  EUI-64 embedded IPv4 address: %s\n",
        }

        if (IF->RemoteLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_ROUTER_LL_ADDRESS,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->RemoteLinkLayerAddress));
// printf("  router link-layer address: %s\n",
        }
    }
    else {
        if (IF->LocalLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_65,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->LocalLinkLayerAddress));
// printf("  link-layer address: %s\n",
        }

        if (IF->RemoteLinkLayerAddress != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_66,
                      FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (u_char *)IF + IF->RemoteLinkLayerAddress));
// printf("  remote link-layer address: %s\n",
        }
    }

    ForEachPersistentAddress(IF, PrintPersistentAddress);

    if (IF->LinkMTU != 0) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_LINK_MTU, IF->LinkMTU);
// printf("  link MTU %u\n",
    }

    if (IF->CurHopLimit != (u_int)-1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_68, IF->CurHopLimit);
// printf("  current hop limit %u\n", IF->CurHopLimit);
    }

    if (IF->BaseReachableTime != 0) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_BASE_REACHABLE_TIME,
                  IF->BaseReachableTime);
// printf("  base reachable time %ums\n",
    }

    if (IF->RetransTimer != 0) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_70, IF->RetransTimer);
// printf("  retransmission interval %ums\n", IF->RetransTimer);
    }

    if (IF->DupAddrDetectTransmits != (u_int)-1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_71, IF->DupAddrDetectTransmits);
// printf("  DAD transmits %u\n", IF->DupAddrDetectTransmits);
    }

    if (IF->DefSitePrefixLength != (u_int)-1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_DEFAULT_SITE_PREFIX_LENGTH,
                  IF->DefSitePrefixLength);
// printf("    default site prefix length %u\n",
    }
}

IPV6_INFO_NEIGHBOR_CACHE *
GetNeighborCacheEntry(IPV6_QUERY_NEIGHBOR_CACHE *Query)
{
    IPV6_INFO_NEIGHBOR_CACHE *NCE;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;
    NCE = (IPV6_INFO_NEIGHBOR_CACHE *) malloc(InfoSize);
    if (NCE == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("malloc failed\n");

        exit(1);
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                         Query, sizeof *Query,
                         NCE, InfoSize, &BytesReturned,
                         NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_72, FormatIPv6Address(&Query->Address));
// printf("bad address %s\n", FormatIPv6Address(&Query->Address));

        exit(1);
    }

    if ((BytesReturned < sizeof *NCE) ||
        (BytesReturned != sizeof *NCE + NCE->LinkLayerAddressLength)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_73);
// printf("inconsistent neighbor cache info length\n");

        exit(1);
    }

    NCE->Query = *Query;
    return NCE;
}

void
ForEachNeighborCacheEntry(IPV6_QUERY_INTERFACE *IF,
                          void (*func)(IPV6_INFO_NEIGHBOR_CACHE *))
{
    IPV6_QUERY_NEIGHBOR_CACHE Query, NextQuery;
    IPV6_INFO_NEIGHBOR_CACHE *NCE;
    u_int InfoSize, BytesReturned;

    InfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;
    NCE = (IPV6_INFO_NEIGHBOR_CACHE *) malloc(InfoSize);
    if (NCE == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("malloc failed\n");

        exit(1);
    }

    NextQuery.IF = *IF;
    NextQuery.Address = in6addr_any;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                             &Query, sizeof Query,
                             NCE, InfoSize, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_72,
                      FormatIPv6Address(&Query.Address));
// printf("bad address %s\n", FormatIPv6Address(&Query.Address));

            exit(1);
        }

        NextQuery = NCE->Query;

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if ((BytesReturned < sizeof *NCE) ||
                (BytesReturned != sizeof *NCE + NCE->LinkLayerAddressLength)) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_73);
// printf("inconsistent neighbor cache info length\n");

                exit(1);
            }

            NCE->Query = Query;
            (*func)(NCE);
        }

        if (IN6_ADDR_EQUAL(&NextQuery.Address, &in6addr_any))
            break;
    }

    free(NCE);
}

void
PrintNeighborCacheEntry(IPV6_INFO_NEIGHBOR_CACHE *NCE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_74, NCE->Query.IF.Index,
              FormatIPv6Address(&NCE->Query.Address));
// printf("%u: %18s", NCE->Query.IF.Index,
//        FormatIPv6Address(&NCE->Query.Address));


    if (NCE->NDState != 0)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_75,
                  FormatLinkLayerAddress(
                      NCE->LinkLayerAddressLength, (u_char *)(NCE + 1)));
// printf(" %-17s", FormatLinkLayerAddress(NCE->LinkLayerAddressLength,
//                                         (u_char *)(NCE + 1)));

    else
        NlsPutMsg(STDOUT, IPV6_MESSAGE_75, "");
// printf(" %-17s", "");


    switch (NCE->NDState) {
    case ND_STATE_INCOMPLETE:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_76);
// printf(" incomplete");

        break;
    case ND_STATE_PROBE:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_77);
// printf(" probe");

        break;
    case ND_STATE_DELAY:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_78);
// printf(" delay");

        break;
    case ND_STATE_STALE:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_79);
// printf(" stale");

        break;
    case ND_STATE_REACHABLE:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_80, NCE->ReachableTimer);
// printf(" reachable (%ums)", NCE->ReachableTimer);

        break;
    case ND_STATE_PERMANENT:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_81);
// printf(" permanent");

        break;
    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_82, NCE->NDState);
// printf(" unknown ND state %u", NCE->NDState);

        break;
    }

    if (NCE->IsRouter)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_83);
// printf(" (router)");


    if (NCE->IsUnreachable)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_84);
// printf(" (unreachable)");


    NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

}

void
QueryInterface(int argc, char *argv[])
{
    InitializeAdaptersInfo();

    if (argc == 0) {
        if (Persistent)
            ForEachPersistentInterface(PrintPersistentInterface);
        else
            ForEachInterface(PrintInterface);
    }
    else if (argc == 1) {
        IPV6_INFO_INTERFACE *IF;

        if (Persistent) {
            IPV6_PERSISTENT_QUERY_INTERFACE Query;

            Query.RegistryIndex = (u_int)-1;
            if (! GetGuid(argv[0], &Query.Guid))
                usage();

            IF = GetPersistentInterfaceInfo(&Query);
            PrintPersistentInterface(IF);
            free(IF);
        }
        else {
            IPV6_QUERY_INTERFACE Query;

            if (! GetInterface(argv[0], &Query))
                usage();

            IF = GetInterfaceInfo(&Query);
            PrintInterface(IF);
            free(IF);
        }
    }
    else {
        usage();
    }
}

void
RenewViaReconnect(IPV6_INFO_INTERFACE *IF)
{
    u_int BytesReturned;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_RENEW_INTERFACE,
                         &IF->This, sizeof IF->This,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_RENEW_INTERFACE, GetLastError());
// printf("renew interface error: %x\n", GetLastError());
        exit(1);
    }
}

VOID
Poke6to4Service()
{
    SC_HANDLE Service, SCManager;
    SERVICE_STATUS Status;

    SCManager = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (SCManager == NULL) {
        return;
    }

    Service = OpenService(SCManager, "6to4", SERVICE_ALL_ACCESS);
    if (Service != NULL) {
        //
        // Tell the 6to4 service to re-read its configuration information.
        //
        (VOID) ControlService(Service, SERVICE_CONTROL_PARAMCHANGE, &Status);
        CloseServiceHandle(Service);
    }

    CloseServiceHandle(SCManager);
}

void
RenewInterface(int argc, char *argv[])
{
    BOOL PokeService = FALSE;
    
    if (argc == 0) {
        ForEachInterface(RenewViaReconnect);
        PokeService = TRUE;
    }
    else if (argc == 1) {
        IPV6_QUERY_INTERFACE Query;
        IPV6_INFO_INTERFACE *IF;

        if (! GetInterface(argv[0], &Query))
            usage();

        IF = GetInterfaceInfo(&Query);
        RenewViaReconnect(IF);

        //
        // Poke the 6to4 service if it manages the interface being renewed.
        //
        PokeService = (IF->Type == IPV6_IF_TYPE_TUNNEL_6TO4) ||
            (IF->Type == IPV6_IF_TYPE_TUNNEL_TEREDO) ||            
            (IF->Type == IPV6_IF_TYPE_TUNNEL_AUTO);            
        
        free(IF);
    }
    else {
        usage();
    }

    if (PokeService) {
        Poke6to4Service();
    }    
}

int
GetV4Address(char *astr, struct in_addr *address)
{
    struct addrinfo hints;
    struct addrinfo *result;

    memset(&hints, 0, sizeof hints);
    hints.ai_family = PF_INET;

    if (getaddrinfo(astr, NULL, &hints, &result))
        return FALSE;

    *address = ((struct sockaddr_in *)result->ai_addr)->sin_addr;
    freeaddrinfo(result);
    return TRUE;
}

void
CreateInterface(int argc, char *argv[])
{
    struct {
        IPV6_INFO_INTERFACE Info;
        struct in_addr SrcAddr;
        struct in_addr DstAddr;
    } Create;
    IPV6_QUERY_INTERFACE Result;
    u_int BytesReturned;
    u_int FlagsOn, FlagsOff;
    int i;

    IPV6_INIT_INFO_INTERFACE(&Create.Info);

    if (argc < 1)
        usage();

    if (!strcmp(argv[0], "v6v4")) {
        i = 3;
        if (argc < i)
            usage();

        if (! GetV4Address(argv[1], &Create.SrcAddr))
            usage();

        if (! GetV4Address(argv[2], &Create.DstAddr))
            usage();

        Create.Info.Type = IPV6_IF_TYPE_TUNNEL_V6V4;
        Create.Info.LinkLayerAddressLength = sizeof(struct in_addr);
        Create.Info.LocalLinkLayerAddress = (u_int)
            ((char *)&Create.SrcAddr - (char *)&Create.Info);
        Create.Info.RemoteLinkLayerAddress = (u_int)
            ((char *)&Create.DstAddr - (char *)&Create.Info);
    }
    else if (!strcmp(argv[0], "6over4")) {
        i = 2;
        if (argc < i)
            usage();

        if (! GetV4Address(argv[1], &Create.SrcAddr))
            usage();

        Create.Info.Type = IPV6_IF_TYPE_TUNNEL_6OVER4;
        Create.Info.LinkLayerAddressLength = sizeof(struct in_addr);
        Create.Info.LocalLinkLayerAddress = (u_int)
            ((char *)&Create.SrcAddr - (char *)&Create.Info);
    }
    else
        usage();

    for (; i < argc; i++) {
        if (!strcmp(argv[i], "nd")) {
            Create.Info.NeighborDiscovers = TRUE;
            Create.Info.RouterDiscovers = TRUE;
        }
        else if (!strcmp(argv[i], "pmld")) {
            Create.Info.PeriodicMLD = TRUE;
        }
        else if (!strcmp(argv[i], "nond")) {
            Create.Info.NeighborDiscovers = FALSE;
            Create.Info.RouterDiscovers = FALSE;
        }
        else
            usage();
    }

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_CREATE_INTERFACE :
                          IOCTL_IPV6_CREATE_INTERFACE),
                         &Create, sizeof Create,
                         &Result, sizeof Result, &BytesReturned, NULL) ||
        (BytesReturned != sizeof Result)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_85, GetLastError());
// printf("control interface error: %x\n", GetLastError());

        exit(1);
    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_86, Result.Index);
// printf("Created interface %u.\n", Result.Index);

}

void
UpdateInterface(int argc, char *argv[])
{
    IPV6_INFO_INTERFACE Update;
    u_int BytesReturned;
    int i;

    IPV6_INIT_INFO_INTERFACE(&Update);

    if (argc < 1)
        usage();

    if (! GetInterface(argv[0], &Update.This))
        usage();

    for (i = 1; i < argc; i++) {
        if (!strncmp(argv[i], "advertises", strlen(argv[i])))
            Update.Advertises = TRUE;
        else if (!strncmp(argv[i], "-advertises", strlen(argv[i])))
            Update.Advertises = FALSE;
        else if (!strncmp(argv[i], "forwards", strlen(argv[i])))
            Update.Forwards = TRUE;
        else if (!strncmp(argv[i], "-forwards", strlen(argv[i])))
            Update.Forwards = FALSE;
        else if (!strcmp(argv[i], "mtu") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.LinkMTU))
                usage();
            i++;
        }
        else if (!strncmp(argv[i], "preference", strlen(argv[i])) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.Preference))
                usage();
        }
        else if (!strncmp(argv[i], "basereachabletime", strlen(argv[i])) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.BaseReachableTime))
                usage();
        }
        else if (!strncmp(argv[i], "retranstimer", strlen(argv[i])) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.RetransTimer))
                usage();
        }
        else if (!strncmp(argv[i], "dupaddrdetecttransmits", strlen(argv[i])) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.DupAddrDetectTransmits))
                usage();
        }
        else if (!strncmp(argv[i], "curhoplimit", strlen(argv[i])) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.CurHopLimit))
                usage();
        }
        else if ((!strncmp(argv[i], "defsiteprefixlength", strlen(argv[i])) ||
                  !strcmp(argv[i], "spl")) &&
                 (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Update.DefSitePrefixLength))
                usage();
        }
        else if (!strcmp(argv[i], "link") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.ZoneIndices[ADE_LINK_LOCAL]))
                usage();
            i++;
        }
        else if (!strcmp(argv[i], "subnet") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.ZoneIndices[ADE_SUBNET_LOCAL]))
                usage();
            i++;
        }
        else if (!strcmp(argv[i], "admin") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.ZoneIndices[ADE_ADMIN_LOCAL]))
                usage();
            i++;
        }
        else if (!strcmp(argv[i], "site") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.ZoneIndices[ADE_SITE_LOCAL]))
                usage();
            i++;
        }
        else if (!strcmp(argv[i], "org") && (i+1 < argc)) {
            if (! GetNumber(argv[i+1], &Update.ZoneIndices[ADE_ORG_LOCAL]))
                usage();
            i++;
        }
        else
            usage();
    }

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_UPDATE_INTERFACE :
                          IOCTL_IPV6_UPDATE_INTERFACE),
                         &Update, sizeof Update,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_85, GetLastError());
// printf("control interface error: %x\n", GetLastError());

        exit(1);
    }
}

void
UpdateRouterLinkAddress(int argc, char *argv[])
{
    char Buffer[sizeof(IPV6_UPDATE_ROUTER_LL_ADDRESS) + 2 * sizeof(IN_ADDR)];
    IPV6_UPDATE_ROUTER_LL_ADDRESS *Update =
        (IPV6_UPDATE_ROUTER_LL_ADDRESS *)Buffer;
    IN_ADDR *Addr = (IN_ADDR *)(Update + 1);
    u_int BytesReturned;
    SOCKET s;
    SOCKADDR_IN sinRemote, sinLocal;

    if (argc != 2)
        usage();

    if (! GetInterface(argv[0], &Update->IF))
        usage();

    if (! GetV4Address(argv[1], &Addr[1]))
        usage();

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_85, WSAGetLastError());
        exit(1);
    }

    sinRemote.sin_family = AF_INET;
    sinRemote.sin_addr = Addr[1];

    if (WSAIoctl(s, SIO_ROUTING_INTERFACE_QUERY,
                 &sinRemote, sizeof sinRemote,
                 &sinLocal, sizeof sinLocal,
                 &BytesReturned, NULL, NULL) == SOCKET_ERROR) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_85, WSAGetLastError());
        exit(1);
    }

    closesocket(s);

    Addr[0] = sinLocal.sin_addr;
    if (Addr[0].s_addr == htonl(INADDR_LOOPBACK)) {
        //
        // We're the router.
        //
        Addr[0] = Addr[1];
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS,
                         Buffer, sizeof Buffer,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_85, GetLastError());
// printf("control interface error: %x\n", GetLastError());

        exit(1);
    }
}

void
DeleteInterface(int argc, char *argv[])
{
    IPV6_QUERY_INTERFACE Query;
    u_int BytesReturned;

    if (argc != 1)
        usage();

    if (! GetInterface(argv[0], &Query))
        usage();

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_DELETE_INTERFACE :
                          IOCTL_IPV6_DELETE_INTERFACE),
                         &Query, sizeof Query,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_87, GetLastError());
// printf("delete interface error: %x\n", GetLastError());

        exit(1);
    }
}

void
PrintNeighborCache(IPV6_INFO_INTERFACE *IF)
{
    ForEachNeighborCacheEntry(&IF->This, PrintNeighborCacheEntry);
}

void
QueryNeighborCache(int argc, char *argv[])
{
    if (argc == 0) {
        ForEachInterface(PrintNeighborCache);
    }
    else if (argc == 1) {
        IPV6_QUERY_INTERFACE Query;

        if (! GetInterface(argv[0], &Query))
            usage();

        ForEachNeighborCacheEntry(&Query, PrintNeighborCacheEntry);
    }
    else if (argc == 2) {
        IPV6_QUERY_NEIGHBOR_CACHE Query;
        IPV6_INFO_NEIGHBOR_CACHE *NCE;

        if (! GetInterface(argv[0], &Query.IF))
            usage();

        if (! GetAddress(argv[1], &Query.Address))
            usage();

        NCE = GetNeighborCacheEntry(&Query);
        PrintNeighborCacheEntry(NCE);
        free(NCE);
    }
    else {
        usage();
    }
}

IPV6_INFO_ROUTE_CACHE *
GetRouteCacheEntry(IPV6_QUERY_ROUTE_CACHE *Query)
{
    IPV6_INFO_ROUTE_CACHE *RCE;
    u_int BytesReturned;

    RCE = (IPV6_INFO_ROUTE_CACHE *) malloc(sizeof *RCE);
    if (RCE == NULL) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("malloc failed\n");

        exit(1);
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ROUTE_CACHE,
                         Query, sizeof *Query,
                         RCE, sizeof *RCE, &BytesReturned,
                         NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_88);
// printf("bad index or address\n");

        exit(1);
    }

    RCE->Query = *Query;
    return RCE;
}

void
ForEachDestination(void (*func)(IPV6_INFO_ROUTE_CACHE *))
{
    IPV6_QUERY_ROUTE_CACHE Query, NextQuery;
    IPV6_INFO_ROUTE_CACHE RCE;
    u_int BytesReturned;

    NextQuery.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ROUTE_CACHE,
                             &Query, sizeof Query,
                             &RCE, sizeof RCE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_89, Query.IF.Index);
// printf("bad index %u\n", Query.IF.Index);

            exit(1);
        }

        NextQuery = RCE.Query;

        if (Query.IF.Index != 0) {

            RCE.Query = Query;
            (*func)(&RCE);
        }

        if (NextQuery.IF.Index == 0)
            break;
    }
}

void
PrintRouteCacheEntry(IPV6_INFO_ROUTE_CACHE *RCE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_90, FormatIPv6Address(&RCE->Query.Address));
// printf("%s via ", FormatIPv6Address(&RCE->Query.Address));

    NlsPutMsg(STDOUT, IPV6_MESSAGE_91, RCE->NextHopInterface,
           FormatIPv6Address(&RCE->NextHopAddress));
// printf("%u/%s", RCE->NextHopInterface,
//        FormatIPv6Address(&RCE->NextHopAddress));


    if (! RCE->Valid)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_92);
// printf(" (stale)");


    switch (RCE->Type) {
    case RCE_TYPE_COMPUTED:
        break;
    case RCE_TYPE_REDIRECT:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_93);
// printf(" (redirect)");

        break;
    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_94, RCE->Type);
// printf(" (unknown type %u)", RCE->Type);

        break;
    }

    switch (RCE->Flags) {
    case RCE_FLAG_CONSTRAINED:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_95);
// printf(" (interface-specific)\n");

        break;
    case RCE_FLAG_CONSTRAINED_SCOPEID:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_96);
// printf(" (zone-specific)\n");

        break;
    case 0:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");

        break;
    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_97, RCE->Flags);
// printf(" (flags 0x%x)\n", RCE->Flags);

    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_98,
              RCE->Query.IF.Index, FormatIPv6Address(&RCE->SourceAddress));
// printf("     src %u/%s\n",
//        RCE->Query.IF.Index,
//        FormatIPv6Address(&RCE->SourceAddress));


    if (RCE->PathMTU == 0)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_99, IPv6_MINIMUM_MTU);
// printf("     PMTU %u-", IPv6_MINIMUM_MTU);

    else
        NlsPutMsg(STDOUT, IPV6_MESSAGE_100, RCE->PathMTU);
// printf("     PMTU %u", RCE->PathMTU);

    if (RCE->PMTUProbeTimer != INFINITE_LIFETIME)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_101, RCE->PMTUProbeTimer/1000);
// printf(" (%u seconds until PMTU probe)\n", RCE->PMTUProbeTimer/1000);

    else
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");


    if ((RCE->ICMPLastError != 0) &&
        (RCE->ICMPLastError < 10*60*1000))
        NlsPutMsg(STDOUT, IPV6_MESSAGE_102, RCE->ICMPLastError/1000);
// printf("     %d seconds since ICMP error\n", RCE->ICMPLastError/1000);


    if ((RCE->BindingSeqNumber != 0) ||
        (RCE->BindingLifetime != 0) ||
        ! IN6_ADDR_EQUAL(&RCE->CareOfAddress, &in6addr_any))
        NlsPutMsg(STDOUT, IPV6_MESSAGE_103,
                  FormatIPv6Address(&RCE->CareOfAddress),
                  RCE->BindingSeqNumber,
                  RCE->BindingLifetime);
// printf("     careof %s seq %u life %us\n",
//        FormatIPv6Address(&RCE->CareOfAddress),
//        RCE->BindingSeqNumber,
//        RCE->BindingLifetime);

}

void
QueryRouteCache(int argc, char *argv[])
{
    if (argc == 0) {
        ForEachDestination(PrintRouteCacheEntry);
    }
    else if (argc == 2) {
        IPV6_QUERY_ROUTE_CACHE Query;
        IPV6_INFO_ROUTE_CACHE *RCE;

        if (! GetInterface(argv[0], &Query.IF))
            usage();

        if (! GetAddress(argv[1], &Query.Address))
            usage();

        RCE = GetRouteCacheEntry(&Query);
        PrintRouteCacheEntry(RCE);
        free(RCE);
    }
    else {
        usage();
    }
}

void
ForEachRoute(void (*func)(IPV6_INFO_ROUTE_TABLE *))
{
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;
    u_int BytesReturned;

    NextQuery.Neighbor.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_104, Query.Neighbor.IF.Index);
// printf("bad index %u\n", Query.Neighbor.IF.Index);

            exit(1);
        }

        NextQuery = RTE.Next;

        if (Query.Neighbor.IF.Index != 0) {

            RTE.This = Query;
            (*func)(&RTE);
        }

        if (NextQuery.Neighbor.IF.Index == 0)
            break;
    }
}

void
ForEachPersistentRoute(IPV6_INFO_INTERFACE *IF,
               void (*func)(IPV6_INFO_ROUTE_TABLE *))
{
    IPV6_PERSISTENT_QUERY_ROUTE_TABLE Query;
    IPV6_INFO_ROUTE_TABLE RTE;
    u_int BytesReturned;

    Query.IF.RegistryIndex = (u_int) -1;
    Query.IF.Guid = IF->This.Guid;

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle,
                             IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &BytesReturned,
                             NULL) ||
            (BytesReturned != sizeof RTE)) {

            if (GetLastError() == ERROR_NO_MORE_ITEMS)
                break;

            NlsPutMsg(STDOUT, IPV6_MESSAGE_104, Query.RegistryIndex);
// printf("bad index %u\n", Query.RegistryIndex);
            exit(1);
        }

        (*func)(&RTE);
    }
}

void
PrintRouteTableEntry(IPV6_INFO_ROUTE_TABLE *RTE)
{
    IPV6_INFO_INTERFACE *IF;

    if (!Verbose) {
        //
        // Suppress system routes (used for loopback).
        //
        if (RTE->Type == RTE_TYPE_SYSTEM)
            return;
    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_105,
              FormatIPv6Address(&RTE->This.Prefix),
              RTE->This.PrefixLength,
              RTE->This.Neighbor.IF.Index);
// printf("%s/%u -> %u",

    if (! IN6_ADDR_EQUAL(&RTE->This.Neighbor.Address, &in6addr_any))
        NlsPutMsg(STDOUT, IPV6_MESSAGE_106,
                  FormatIPv6Address(&RTE->This.Neighbor.Address));
// printf("/%s", FormatIPv6Address(&RTE->This.Neighbor.Address));

    IF = GetInterfaceInfo(&RTE->This.Neighbor.IF);
    if (IF != NULL) {
        if (IF->Preference != 0) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_107,
                      IF->Preference, RTE->Preference,
                      IF->Preference + RTE->Preference);
// printf(" pref %uif+%u=%u ",
//        IF->Preference, RTE->Preference,
//        IF->Preference + RTE->Preference);
        }
        else {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_108, RTE->Preference);
// printf(" pref %u ", RTE->Preference);
        }
        free(IF);
    }
    else {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_108, RTE->Preference);
// printf(" pref %u ", RTE->Preference);
    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_109,
           FormatLifetimes(RTE->ValidLifetime, RTE->PreferredLifetime));
// printf("life %s",
//        FormatLifetimes(RTE->ValidLifetime, RTE->PreferredLifetime));

    if (RTE->Publish)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_110);
// printf(", publish");

    if (RTE->Immortal)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_111);
// printf(", no aging");

    if (RTE->SitePrefixLength != 0)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_112, RTE->SitePrefixLength);
// printf(", spl %u", RTE->SitePrefixLength);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_113);
// printf(" (");

    switch (RTE->Type) {
    case RTE_TYPE_SYSTEM:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_114);
// printf("system");
        break;

    case RTE_TYPE_MANUAL:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_115);
// printf("manual");
        break;

    case RTE_TYPE_AUTOCONF:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_116);
// printf("autoconf");
        break;

    case RTE_TYPE_RIP:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_117);
// printf("RIP");
        break;

    case RTE_TYPE_OSPF:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_118);
// printf("OSPF");
        break;

    case RTE_TYPE_BGP:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_119);
// printf("BGP");
        break;

    case RTE_TYPE_IDRP:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_120);
// printf("IDRP");
        break;

    case RTE_TYPE_IGRP:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_121);
// printf("IGRP");
        break;

    default:
        NlsPutMsg(STDOUT, IPV6_MESSAGE_122, RTE->Type);
// printf("type %u", RTE->Type);
        break;
    }

    NlsPutMsg(STDOUT, IPV6_MESSAGE_123);
// printf(")\n");
}

void
PrintPersistentRouteTableEntry(IPV6_INFO_ROUTE_TABLE *RTE)
{
    IPV6_INFO_INTERFACE *IF;

    NlsPutMsg(STDOUT, IPV6_MESSAGE_PRINT_PERSISTENT_ROUTE,
              FormatIPv6Address(&RTE->This.Prefix),
              RTE->This.PrefixLength,
              FormatGuid(&RTE->This.Neighbor.IF.Guid));
// printf("%s/%u -> %s",

    if (! IN6_ADDR_EQUAL(&RTE->This.Neighbor.Address, &in6addr_any))
        NlsPutMsg(STDOUT, IPV6_MESSAGE_106,
                  FormatIPv6Address(&RTE->This.Neighbor.Address));
// printf("/%s", FormatIPv6Address(&RTE->This.Neighbor.Address));

    NlsPutMsg(STDOUT, IPV6_MESSAGE_108, RTE->Preference);
// printf(" pref %u ", RTE->Preference);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_109,
           FormatLifetimes(RTE->ValidLifetime, RTE->PreferredLifetime));
// printf("life %s",
//        FormatLifetimes(RTE->ValidLifetime, RTE->PreferredLifetime));

    if (RTE->Publish)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_110);
// printf(", publish");

    if (RTE->Immortal)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_111);
// printf(", no aging");

    if (RTE->SitePrefixLength != 0)
        NlsPutMsg(STDOUT, IPV6_MESSAGE_112, RTE->SitePrefixLength);
// printf(", spl %u", RTE->SitePrefixLength);

    NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");
}

void
PrintPersistentRoutesOnInterface(IPV6_INFO_INTERFACE *IF)
{
    ForEachPersistentRoute(IF, PrintPersistentRouteTableEntry);
}

void
QueryRouteTable(int argc, char *argv[])
{
    if (argc == 0) {
        if (Persistent)
            ForEachPersistentInterface(PrintPersistentRoutesOnInterface);
        else
            ForEachRoute(PrintRouteTableEntry);
    }
    else {
        usage();
    }
}

void
UpdateRouteTable(int argc, char *argv[])
{
    IPV6_INFO_ROUTE_TABLE Route;
    u_int BytesReturned;
    int i;

    Route.SitePrefixLength = 0;
    Route.ValidLifetime = INFINITE_LIFETIME;
    Route.PreferredLifetime = INFINITE_LIFETIME;
    Route.Preference = ROUTE_PREF_HIGHEST;
    Route.Type = RTE_TYPE_MANUAL;
    Route.Publish = FALSE;
    Route.Immortal = -1;

    if (argc < 2)
        usage();

    if (! GetNeighbor(argv[1],
                      &Route.This.Neighbor.IF,
                      &Route.This.Neighbor.Address))
        usage();

    if (! GetPrefix(argv[0],
                    &Route.This.Prefix,
                    &Route.This.PrefixLength))
        usage();

    for (i = 2; i < argc; i++) {
        if (!strncmp(argv[i], "lifetime", strlen(argv[i])) &&
            (i+1 < argc)) {

            if (! GetLifetimes(argv[++i],
                               &Route.ValidLifetime,
                               &Route.PreferredLifetime))
                usage();
        }
        else if (!strncmp(argv[i], "preference", strlen(argv[i])) &&
                 (i+1 < argc)) {

            i++;
            if (!strncmp(argv[i], "low", strlen(argv[i])))
                Route.Preference = ROUTE_PREF_LOW;
            else if (!strncmp(argv[i], "medium", strlen(argv[i])))
                Route.Preference = ROUTE_PREF_MEDIUM;
            else if (!strncmp(argv[i], "high", strlen(argv[i])))
                Route.Preference = ROUTE_PREF_HIGH;
            else if (!strncmp(argv[i], "onlink", strlen(argv[i])))
                Route.Preference = ROUTE_PREF_ON_LINK;
            else if (!strncmp(argv[i], "loopback", strlen(argv[i])))
                Route.Preference = ROUTE_PREF_LOOPBACK;
            else if (! GetNumber(argv[i], &Route.Preference))
                usage();
        }
        else if (!strcmp(argv[i], "spl") && (i+1 < argc)) {

            if (! GetNumber(argv[++i], &Route.SitePrefixLength))
                usage();
        }
        else if (!strncmp(argv[i], "advertise", strlen(argv[i])) ||
                 !strncmp(argv[i], "publish", strlen(argv[i]))) {

            Route.Publish = TRUE;
        }
        else if (!strncmp(argv[i], "immortal", strlen(argv[i])) ||
                 !strncmp(argv[i], "noaging", strlen(argv[i])) ||
                 !strcmp(argv[i], "noage")) {

            Route.Immortal = TRUE;
        }
        else if (!strncmp(argv[i], "aging", strlen(argv[i])) ||
                 !strcmp(argv[i], "age")) {

            Route.Immortal = FALSE;
        }
        else if (!strcmp(argv[i], "system")) {

            Route.Type = RTE_TYPE_SYSTEM;
        }
        else if (!strcmp(argv[i], "manual")) {

            Route.Type = RTE_TYPE_MANUAL;
        }
        else if (!strcmp(argv[i], "autoconf")) {

            Route.Type = RTE_TYPE_AUTOCONF;
        }
        else if (!strcmp(argv[i], "rip")) {

            Route.Type = RTE_TYPE_RIP;
        }
        else if (!strcmp(argv[i], "ospf")) {

            Route.Type = RTE_TYPE_OSPF;
        }
        else if (!strcmp(argv[i], "bgp")) {

            Route.Type = RTE_TYPE_BGP;
        }
        else if (!strcmp(argv[i], "idrp")) {

            Route.Type = RTE_TYPE_IDRP;
        }
        else if (!strcmp(argv[i], "igrp")) {

            Route.Type = RTE_TYPE_IGRP;
        }
        else
            usage();
    }

    if (Route.Immortal == -1)
        Route.Immortal = Route.Publish;

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_UPDATE_ROUTE_TABLE :
                          IOCTL_IPV6_UPDATE_ROUTE_TABLE),
                         &Route, sizeof Route,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_124, GetLastError());
// printf("route update error: %x\n", GetLastError());

        exit(1);
    }
}

void
UpdateAddress(int argc, char *argv[])
{
    IPV6_UPDATE_ADDRESS Update;
    u_int BytesReturned;
    int i;
    int Origin;

    Update.Type = ADE_UNICAST;
    Update.PrefixConf = PREFIX_CONF_MANUAL;
    Update.InterfaceIdConf = IID_CONF_MANUAL;
    Update.ValidLifetime = INFINITE_LIFETIME;
    Update.PreferredLifetime = INFINITE_LIFETIME;

    if (argc < 1)
        usage();

    if ((strchr(argv[0], '/') == NULL) ||
        ! GetNeighbor(argv[0],
                      &Update.This.IF,
                      &Update.This.Address))
        usage();

    for (i = 1; i < argc; i++) {
        if (!strncmp(argv[i], "lifetime", strlen(argv[i])) &&
            (i+1 < argc)) {

            if (! GetLifetimes(argv[++i],
                               &Update.ValidLifetime,
                               &Update.PreferredLifetime))
                usage();
        }
        else if (!strcmp(argv[i], "unicast"))
            Update.Type = ADE_UNICAST;
        else if (!strcmp(argv[i], "anycast"))
            Update.Type = ADE_ANYCAST;
        else if (!strcmp(argv[i], "prefixorigin") &&
            (i+1 < argc)) {

            if (! GetPrefixOrigin(argv[++i], &Origin))
                usage();
            Update.PrefixConf = Origin;
        }
        else if (!strcmp(argv[i], "ifidorigin") &&
            (i+1 < argc)) {

            if (! GetInterfaceIdOrigin(argv[++i], &Origin))
                usage();
            Update.InterfaceIdConf = Origin;
        }
        else
            usage();
    }

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_UPDATE_ADDRESS :
                          IOCTL_IPV6_UPDATE_ADDRESS),
                         &Update, sizeof Update,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_125, GetLastError());
// printf("address update error: %x\n", GetLastError());

        exit(1);
    }
}


void
ForEachBinding(void (*func)(IPV6_INFO_BINDING_CACHE *))
{
    IPV6_QUERY_BINDING_CACHE Query, NextQuery;
    IPV6_INFO_BINDING_CACHE BCE;
    u_int BytesReturned;

    NextQuery.HomeAddress = in6addr_any;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_BINDING_CACHE,
                             &Query, sizeof Query,
                             &BCE, sizeof BCE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_126,
                      FormatIPv6Address(&Query.HomeAddress));
// printf("bad home address %s\n",
//        FormatIPv6Address(&Query.HomeAddress));

            exit(1);
        }

        NextQuery = BCE.Query;

        if (!IN6_ADDR_EQUAL(&Query.HomeAddress, &in6addr_any)) {
            BCE.Query = Query;
            (*func)(&BCE);
        }

        if (IN6_ADDR_EQUAL(&NextQuery.HomeAddress, &in6addr_any))
            break;
    }
}

void
PrintBindingCacheEntry(IPV6_INFO_BINDING_CACHE *BCE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_127,
              FormatIPv6Address(&BCE->HomeAddress));
// printf("home: %s\n", FormatIPv6Address(&BCE->HomeAddress));

    NlsPutMsg(STDOUT, IPV6_MESSAGE_128,
              FormatIPv6Address(&BCE->CareOfAddress));
// printf(" c/o: %s\n", FormatIPv6Address(&BCE->CareOfAddress));

    NlsPutMsg(STDOUT, IPV6_MESSAGE_129,
              BCE->BindingSeqNumber, BCE->BindingLifetime);
// printf(" seq: %u   Lifetime: %us\n\n",
//        BCE->BindingSeqNumber, BCE->BindingLifetime);

}

void
QueryBindingCache(int argc, char *argv[])
{
    if (argc == 0) {
        ForEachBinding(PrintBindingCacheEntry);
    } else {
        usage();
    }
}

void
FlushNeighborCacheForInterface(IPV6_INFO_INTERFACE *IF)
{
    IPV6_QUERY_NEIGHBOR_CACHE Query;
    u_int BytesReturned;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_130, GetLastError());
// printf("flush neighbor cache error: %x\n", GetLastError());

        exit(1);
    }
}

void
FlushNeighborCache(int argc, char *argv[])
{
    //
    // Rather than put code in the kernel ioctl to iterate
    // over the interfaces, we do it here in user space.
    //
    if (argc == 0) {
        ForEachInterface(FlushNeighborCacheForInterface);
    }
    else {
        IPV6_QUERY_NEIGHBOR_CACHE Query;
        u_int BytesReturned;

        Query.IF.Index = 0;
        Query.Address = in6addr_any;

        switch (argc) {
        case 2:
            if (! GetAddress(argv[1], &Query.Address))
                usage();
            // fall-through

        case 1:
            if (! GetInterface(argv[0], &Query.IF))
                usage();
            // fall-through

        case 0:
            break;

        default:
            usage();
        }

        if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE,
                             &Query, sizeof Query,
                             NULL, 0, &BytesReturned, NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_130, GetLastError());
// printf("flush neighbor cache error: %x\n", GetLastError());

            exit(1);
        }
    }
}

void
FlushRouteCache(int argc, char *argv[])
{
    IPV6_QUERY_ROUTE_CACHE Query;
    u_int BytesReturned;

    Query.IF.Index = (u_int)-1;
    Query.Address = in6addr_any;

    switch (argc) {
    case 2:
        if (! GetAddress(argv[1], &Query.Address))
            usage();
        // fall-through

    case 1:
        if (! GetInterface(argv[0], &Query.IF))
            usage();
        // fall-through

    case 0:
        break;

    default:
        usage();
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_ROUTE_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_131, GetLastError());
// printf("flush route cache error: %x\n", GetLastError());

        exit(1);
    }
}

void
ForEachSitePrefix(void (*func)(IPV6_INFO_SITE_PREFIX *))
{
    IPV6_QUERY_SITE_PREFIX Query, NextQuery;
    IPV6_INFO_SITE_PREFIX SPE;
    u_int BytesReturned;

    NextQuery.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_SITE_PREFIX,
                             &Query, sizeof Query,
                             &SPE, sizeof SPE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_132, Query.IF.Index);
// printf("bad index %u\n", Query.IF.Index);

            exit(1);
        }

        NextQuery = SPE.Query;

        if (Query.IF.Index != 0) {

            SPE.Query = Query;
            (*func)(&SPE);
        }

        if (NextQuery.IF.Index == 0)
            break;
    }
}

void
PrintSitePrefix(IPV6_INFO_SITE_PREFIX *SPE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_133,
              FormatIPv6Address(&SPE->Query.Prefix),
              SPE->Query.PrefixLength,
              SPE->Query.IF.Index,
              FormatLifetimes(SPE->ValidLifetime, SPE->ValidLifetime));
// printf("%s/%u -> %u (life %s)\n",
//        FormatIPv6Address(&SPE->Query.Prefix),
//        SPE->Query.PrefixLength,
//        SPE->Query.IF.Index,
//        FormatLifetimes(SPE->ValidLifetime, SPE->ValidLifetime));

}

void
QuerySitePrefixTable(int argc, char *argv[])
{
    if (argc == 0) {
        ForEachSitePrefix(PrintSitePrefix);
    }
    else {
        usage();
    }
}

void
UpdateSitePrefixTable(int argc, char *argv[])
{
    IPV6_INFO_SITE_PREFIX SitePrefix;
    u_int BytesReturned;
    int i;

    SitePrefix.ValidLifetime = INFINITE_LIFETIME;

    if (argc < 2)
        usage();

    if (! GetInterface(argv[1], &SitePrefix.Query.IF))
        usage();

    if (! GetPrefix(argv[0],
                    &SitePrefix.Query.Prefix,
                    &SitePrefix.Query.PrefixLength))
        usage();

    for (i = 2; i < argc; i++) {
        if (!strncmp(argv[i], "lifetime", strlen(argv[i])) &&
            (i+1 < argc)) {

            if (! GetLifetimes(argv[++i], &SitePrefix.ValidLifetime, NULL))
                usage();
        }
        else
            usage();
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_SITE_PREFIX,
                         &SitePrefix, sizeof SitePrefix,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_134, GetLastError());
// printf("site prefix update error: %x\n", GetLastError());

        exit(1);
    }
}

void
QueryGlobalParameters(int argc, char *argv[])
{
    IPV6_GLOBAL_PARAMETERS Params;
    u_int BytesReturned;

    if (argc != 0)
        usage();

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS :
                          IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS),
                         NULL, 0,
                         &Params, sizeof Params, &BytesReturned, NULL) ||
        (BytesReturned != sizeof Params)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_135, GetLastError());
// printf("query global params error: %x\n", GetLastError());

        exit(1);
    }

    if (Params.DefaultCurHopLimit != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_136, Params.DefaultCurHopLimit);
// printf("DefaultCurHopLimit = %u\n", Params.DefaultCurHopLimit);
    }

    if (Params.UseTemporaryAddresses != (u_int) -1) {
        switch (Params.UseTemporaryAddresses) {
        case USE_TEMP_NO:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_137);
// printf("UseTemporaryAddresses = no\n");

            break;
        case USE_TEMP_YES:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_138);
// printf("UseTemporaryAddresses = yes\n");

            break;
        case USE_TEMP_ALWAYS:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_139);
// printf("UseTemporaryAddresses = yes, new random interface id for every address\n");

            break;
        case USE_TEMP_COUNTER:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_140);
// printf("UseTemporaryAddresses = yes, incrementing interface ids\n");

            break;
        default:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_141, Params.UseTemporaryAddresses);
// printf("UseTemporaryAddresses = %u\n", Params.UseTemporaryAddresses);

            break;
        }
    }

    if (Params.MaxTempDADAttempts != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_142, Params.MaxTempDADAttempts);
// printf("MaxTempDADAttempts = %u\n", Params.MaxTempDADAttempts);
    }

    if ((Params.MaxTempValidLifetime != (u_int) -1) ||
        (Params.MaxTempPreferredLifetime != (u_int) -1)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_143,
                  FormatLifetimes(Params.MaxTempValidLifetime,
                                  Params.MaxTempPreferredLifetime));
// printf("MaxTempLifetime = %s\n",
//        FormatLifetimes(Params.MaxTempValidLifetime,
//        Params.MaxTempPreferredLifetime));
    }

    if (Params.TempRegenerateTime != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_144, Params.TempRegenerateTime);
// printf("TempRegenerateTime = %us\n", Params.TempRegenerateTime);
    }

    if (Params.MaxTempRandomTime != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_145,
                  FormatLifetime(Params.MaxTempRandomTime));
// printf("MaxTempRandomTime = %s\n",
//        FormatLifetime(Params.MaxTempRandomTime));
    }

    if (! Persistent) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_146,
                  FormatLifetime(Params.TempRandomTime));
// printf("TempRandomTime = %s\n",
//        FormatLifetime(Params.TempRandomTime));
    }

    if (Params.NeighborCacheLimit != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_147, Params.NeighborCacheLimit);
// printf("NeighborCacheLimit = %u\n", Params.NeighborCacheLimit);
    }

    if (Params.RouteCacheLimit != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_148, Params.RouteCacheLimit);
// printf("RouteCacheLimit = %u\n", Params.RouteCacheLimit);
    }

    if (Params.BindingCacheLimit != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_BCL_DISPLAY, Params.BindingCacheLimit);
// printf("BindingCacheLimit = %u\n", Params.BindingCacheLimit);
    }

    if (Params.ReassemblyLimit != (u_int) -1) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_REASS_LIMIT_DISPLAY, Params.ReassemblyLimit);
// printf("ReassemblyLimit = %u\n", Params.ReassemblyLimit);
    }

    if (Params.MobilitySecurity != -1) {
        if (Params.MobilitySecurity) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_MOBILITY_SECURITY_ON);
// printf("MobilitySecurity = on\n");
        }
        else {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_MOBILITY_SECURITY_OFF);
// printf("MobilitySecurity = off\n");
        }
    }

    if (Params.MobileIPv6Mode != (u_int) -1) {
        NlsPutMsg(STDOUT, MIPV6_MESSAGE_MODE);
// printf("MobileIPv6Mode =");
        if (Params.MobileIPv6Mode & MOBILE_MOBILE_NODE) {
            NlsPutMsg(STDOUT, MIPV6_MESSAGE_MODE_MN);
// printf(" MN");
        }
        if (Params.MobileIPv6Mode & MOBILE_HOME_AGENT) {
            NlsPutMsg(STDOUT, MIPV6_MESSAGE_MODE_HA);
// printf(" HA");
        }
        if (Params.MobileIPv6Mode & MOBILE_CORRESPONDENT) {
            NlsPutMsg(STDOUT, MIPV6_MESSAGE_MODE_CN);
// printf(" CN");
        }
        NlsPutMsg(STDOUT, IPV6_MESSAGE_36);
// printf("\n");
    }
}

void
UpdateGlobalParameters(int argc, char *argv[])
{
    IPV6_GLOBAL_PARAMETERS Params;
    u_int BytesReturned;
    int i;

    IPV6_INIT_GLOBAL_PARAMETERS(&Params);

    for (i = 0; i < argc; i++) {
        if (!strcmp(argv[i], "DefaultCurHopLimit") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.DefaultCurHopLimit))
                goto usage;
        }
        else if (!strcmp(argv[i], "UseTemporaryAddresses") && (i+1 < argc)) {
            if (!strncmp(argv[++i], "no", strlen(argv[i])))
                Params.UseTemporaryAddresses = USE_TEMP_NO;
            else if (!strncmp(argv[i], "yes", strlen(argv[i])))
                Params.UseTemporaryAddresses = USE_TEMP_YES;
            else if (!strncmp(argv[i], "always", strlen(argv[i])))
                Params.UseTemporaryAddresses = USE_TEMP_ALWAYS;
            else if (!strncmp(argv[i], "counter", strlen(argv[i])))
                Params.UseTemporaryAddresses = USE_TEMP_COUNTER;
            else
                goto usage;
        }
        else if (!strcmp(argv[i], "MaxTempDADAttempts") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.MaxTempDADAttempts))
                goto usage;
        }
        else if (!strcmp(argv[i], "MaxTempLifetime") && (i+1 < argc)) {
            if (! GetLifetimes(argv[++i],
                               &Params.MaxTempValidLifetime,
                               &Params.MaxTempPreferredLifetime))
                goto usage;
        }
        else if (!strcmp(argv[i], "TempRegenerateTime") && (i+1 < argc)) {
            if (! GetLifetime(argv[++i], &Params.TempRegenerateTime))
                goto usage;
        }
        else if (!strcmp(argv[i], "MaxTempRandomTime") && (i+1 < argc)) {
            if (! GetLifetime(argv[++i], &Params.MaxTempRandomTime))
                goto usage;
        }
        else if (!strcmp(argv[i], "TempRandomTime") && (i+1 < argc)) {
            if (! GetLifetime(argv[++i], &Params.TempRandomTime))
                goto usage;
        }
        else if (!strcmp(argv[i], "NeighborCacheLimit") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.NeighborCacheLimit))
                goto usage;
        }
        else if (!strcmp(argv[i], "RouteCacheLimit") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.RouteCacheLimit))
                goto usage;
        }
        else if (!strcmp(argv[i], "BindingCacheLimit") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.BindingCacheLimit))
                goto usage;
        }
        else if (!strcmp(argv[i], "ReassemblyLimit") && (i+1 < argc)) {
            if (! GetNumber(argv[++i], &Params.ReassemblyLimit))
                goto usage;
        }
        else if (!strcmp(argv[i], "MobilitySecurity") && (i+1 < argc)) {
            if (!strncmp(argv[++i], "on", strlen(argv[i])))
                Params.MobilitySecurity = TRUE;
            else if (!strncmp(argv[i], "off", strlen(argv[i])))
                Params.MobilitySecurity = FALSE;
            else if (!strncmp(argv[i], "yes", strlen(argv[i])))
                Params.MobilitySecurity = TRUE;
            else if (!strncmp(argv[i], "no", strlen(argv[i])))
                Params.MobilitySecurity = FALSE;
            else
                goto usage;
        }
        else if (!strcmp(argv[i], "MobileIPv6Mode")) {
            Params.MobileIPv6Mode = 0;
            while (++i < argc) {
                if (!strncmp(argv[i], "CN", strlen(argv[i])))
                    Params.MobileIPv6Mode |= MOBILE_CORRESPONDENT;
                else if (!strncmp(argv[i], "MN", strlen(argv[i])))
                    Params.MobileIPv6Mode |= MOBILE_MOBILE_NODE;
                else if (!strncmp(argv[i], "HA", strlen(argv[i])))
                    Params.MobileIPv6Mode |= MOBILE_HOME_AGENT;
                else
                    break;
            }
            i--;
            //
            // Until we have full mobility support, only allow CN.
            //
            if (Params.MobileIPv6Mode &~ MOBILE_CORRESPONDENT) {
//              printf("MobileIPv6Modes MN and HA currently unsupported\n");
                NlsPutMsg(STDOUT, MIPV6_MESSAGE_UNSUPPORTED_MODE);
                exit(1);
            }
            //
            // Disallow nonsensical combinations.
            //
            if ((Params.MobileIPv6Mode & MOBILE_MOBILE_NODE) &&
                (Params.MobileIPv6Mode & MOBILE_HOME_AGENT)) {
//              printf("invalid MobileIPv6Mode combination (HA and MN).\n");
                NlsPutMsg(STDOUT, MIPV6_MESSAGE_INVALID_MODE_COMBINATION1);
                exit(1);
            }
            if ((Params.MobileIPv6Mode & MOBILE_HOME_AGENT) &&
                !(Params.MobileIPv6Mode & MOBILE_CORRESPONDENT)) {
//              printf("invalid MobileIPv6Mode combination (HA and not CN).\n");
                NlsPutMsg(STDOUT, MIPV6_MESSAGE_INVALID_MODE_COMBINATION2);
                exit(1);
            }
        }
        else {
        usage:
            NlsPutMsg(STDOUT, IPV6_MESSAGE_149);
// printf("usage: ipv6 gpu [parameter value] ...\n");
// printf("       ipv6 gpu DefaultCurHopLimit hops\n");
// printf("       ipv6 gpu UseTemporaryAddresses [yes|no|always|counter]\n");
// printf("       ipv6 gpu MaxTempDADAttempts number\n");
// printf("       ipv6 gpu MaxTempLifetime valid[/preferred]\n");
// printf("       ipv6 gpu TempRegenerateTime time\n");
// printf("       ipv6 gpu MaxTempRandomTime time\n");
// printf("       ipv6 gpu TempRandomTime time\n");
// printf("       ipv6 gpu NeighborCacheLimit number\n");
// printf("       ipv6 gpu RouteCacheLimit number\n");
// printf("       ipv6 gpu BindingCacheLimit number\n");
// printf("       ipv6 gpu ReassemblyLimit number\n");
// printf("       ipv6 gpu MobilitySecurity [on|off]\n");
// printf("       ipv6 gpu MobileIPv6Mode [CN|MN|HA]*\n");
// printf("Use ipv6 -p gpu ... to make a persistent change\n");
// printf("in the registry. Many global parameter changes\n");
// printf("only take effect after restarting the stack.\n");
// printf("MobileIPv6Modes MN and HA are currently unsupported.\n");
            exit(1);
        }
    }

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS :
                          IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS),
                         &Params, sizeof Params,
                         NULL, 0,
                         &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_150, GetLastError());
// printf("update global params error: %x\n", GetLastError());

        exit(1);
    }
}

void
ForEachPrefixPolicy(void (*func)(IPV6_INFO_PREFIX_POLICY *))
{
    IPV6_QUERY_PREFIX_POLICY Query;
    IPV6_INFO_PREFIX_POLICY PPE;
    u_int BytesReturned;

    Query.PrefixLength = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_PREFIX_POLICY,
                             &Query, sizeof Query,
                             &PPE, sizeof PPE, &BytesReturned,
                             NULL)) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_160);
// printf("bad prefix\n");
            exit(1);
        }

        if (Query.PrefixLength != (u_int) -1) {

            if (BytesReturned != sizeof PPE) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_160);
// printf("bad prefix\n");
                exit(1);
            }

            (*func)(&PPE);
        }
        else {
            if (BytesReturned != sizeof PPE.Next) {
                NlsPutMsg(STDOUT, IPV6_MESSAGE_160);
// printf("bad prefix\n");
                exit(1);
            }
        }

        if (PPE.Next.PrefixLength == (u_int) -1)
            break;
        Query = PPE.Next;
    }
}

void
ForEachPersistentPrefixPolicy(void (*func)(IPV6_INFO_PREFIX_POLICY *))
{
    IPV6_PERSISTENT_QUERY_PREFIX_POLICY Query;
    IPV6_INFO_PREFIX_POLICY PPE;
    u_int BytesReturned;

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle,
                             IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY,
                             &Query, sizeof Query,
                             &PPE, sizeof PPE, &BytesReturned,
                             NULL)) {
            if (GetLastError() == ERROR_NO_MORE_ITEMS)
                break;

            NlsPutMsg(STDOUT, IPV6_MESSAGE_160);
// printf("bad prefix\n");
            exit(1);
        }

        if (BytesReturned != sizeof PPE) {
            NlsPutMsg(STDOUT, IPV6_MESSAGE_160);
// printf("bad prefix\n");
            exit(1);
        }

        (*func)(&PPE);
    }
}

void
PrintPrefixPolicyEntry(IPV6_INFO_PREFIX_POLICY *PPE)
{
    NlsPutMsg(STDOUT, IPV6_MESSAGE_161,
              FormatIPv6Address(&PPE->This.Prefix),
              PPE->This.PrefixLength,
              PPE->Precedence,
              PPE->SrcLabel,
              PPE->DstLabel);
// printf("%s/%u -> precedence %u srclabel %u dstlabel %u\n",
//        FormatIPv6Address(&PPE->This.Prefix),
//        PPE->This.PrefixLength,
//        PPE->Precedence,
//        PPE->SrcLabel,
//        PPE->DstLabel);

}

void
QueryPrefixPolicy(int argc, char *argv[])
{
    if (argc == 0) {
        if (Persistent)
            ForEachPersistentPrefixPolicy(PrintPrefixPolicyEntry);
        else
            ForEachPrefixPolicy(PrintPrefixPolicyEntry);
    }
    else {
        usage();
    }
}

void
UpdatePrefixPolicy(int argc, char *argv[])
{
    IPV6_INFO_PREFIX_POLICY Info;
    u_int BytesReturned;
    int i;

    if (argc < 1)
        usage();

    if (! GetPrefix(argv[0],
                    &Info.This.Prefix,
                    &Info.This.PrefixLength))
        usage();

    Info.Precedence = (u_int) -1;
    Info.SrcLabel = (u_int) -1;
    Info.DstLabel = (u_int) -1;

    for (i = 1; i < argc; i++) {
        if (!strncmp(argv[i], "precedence", strlen(argv[i])) &&
            ((i + 1) < argc)) {
            if (! GetNumber(argv[++i], &Info.Precedence))
                usage();
        }
        else if ((!strncmp(argv[i], "srclabel", strlen(argv[i])) ||
                  !strcmp(argv[i], "sl") ||
                  !strcmp(argv[i], "label")) &&
                 ((i + 1) < argc)) {
            if (! GetNumber(argv[++i], &Info.SrcLabel))
                usage();
        }
        else if ((!strncmp(argv[i], "dstlabel", strlen(argv[i])) ||
                  !strcmp(argv[i], "dl")) &&
                 ((i + 1) < argc)) {
            if (! GetNumber(argv[++i], &Info.DstLabel))
                usage();
        }
        else
            usage();
    }

    if ((Info.Precedence == (u_int) -1) ||
        (Info.SrcLabel == (u_int) -1))
        usage();

    if (Info.DstLabel == (u_int) -1)
        Info.DstLabel = Info.SrcLabel;

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_UPDATE_PREFIX_POLICY :
                          IOCTL_IPV6_UPDATE_PREFIX_POLICY),
                         &Info, sizeof Info,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_162, GetLastError());
// printf("prefix policy create error: %x\n", GetLastError());

        exit(1);
    }
}

void
DeletePrefixPolicy(int argc, char *argv[])
{
    IPV6_QUERY_PREFIX_POLICY Query;
    u_int BytesReturned;

    if (argc == 1) {
        if (! GetPrefix(argv[0],
                        &Query.Prefix,
                        &Query.PrefixLength))
            usage();
    }
    else {
        usage();
    }

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_DELETE_PREFIX_POLICY :
                          IOCTL_IPV6_DELETE_PREFIX_POLICY),
                         &Query, sizeof Query,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_163, GetLastError());
// printf("prefix policy delete error: %x\n", GetLastError());

        exit(1);
    }
}

void
ResetManualConfig(int argc, char *argv[])
{
    u_int BytesReturned;

    if (argc != 0)
        usage();

    if (!DeviceIoControl(Handle,
                         (Persistent ?
                          IOCTL_IPV6_PERSISTENT_RESET :
                          IOCTL_IPV6_RESET),
                         NULL, 0,
                         NULL, 0, &BytesReturned, NULL)) {
        NlsPutMsg(STDOUT, IPV6_MESSAGE_RESET, GetLastError());
// printf("reset error: %x\n", GetLastError());

        exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ifip.c ===
//=============================================================================
// Copyright (c) 2001 Microsoft Corporation
// Abstract:
//      This module implements IPv6 configuration commands.
//=============================================================================

#include "precomp.h"
#pragma hdrstop

typedef enum {
    ACTION_ADD,
    ACTION_SET
} ACTION;


DWORD
GetTime(
    IN PWCHAR pwszLife)
{
    PWCHAR pwcUnit;
    DWORD dwUnits = SECONDS, dwLife = 0;
    
    if (!_wcsnicmp(pwszLife, TOKEN_VALUE_INFINITE, wcslen(pwszLife))) {
        return INFINITE_LIFETIME;
    }

    while ((pwcUnit = wcspbrk(pwszLife, L"sSmMhHdD")) != NULL) {
        switch (*pwcUnit) {
        case L's':
        case L'S':
            dwUnits = SECONDS;
            break;
        case L'm':
        case L'M':
            dwUnits = MINUTES;
            break;
        case L'h':
        case L'H':
            dwUnits = HOURS;
            break;
        case L'd':
        case L'D':
            dwUnits = DAYS;
            break;
        }
        
        *pwcUnit = L'\0';
        dwLife += wcstoul(pwszLife, NULL, 10) * dwUnits;
        
        pwszLife = pwcUnit + 1;
        if (*pwszLife == L'\0')
            return dwLife;
    }
    return dwLife + wcstoul(pwszLife, NULL, 10);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to addresses
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleAddSetAddress(
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      ACTION    Action,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr, i;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE,         TRUE,  FALSE},
                              {TOKEN_ADDRESS,           TRUE,  FALSE},
                              {TOKEN_TYPE,              FALSE, FALSE},
                              {TOKEN_VALIDLIFETIME,     FALSE, FALSE},
                              {TOKEN_PREFERREDLIFETIME, FALSE, FALSE},
                              {TOKEN_STORE,             FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    IN6_ADDR     ipAddress;
    TOKEN_VALUE  rgtvTypeEnum[] = {{ TOKEN_VALUE_UNICAST, ADE_UNICAST },
                                   { TOKEN_VALUE_ANYCAST, ADE_ANYCAST }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        dwType = ADE_UNICAST;
    DWORD        dwValidLifetime = INFINITE_LIFETIME;
    DWORD        dwPreferredLifetime = INFINITE_LIFETIME;    
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            break;

        case 2: // TYPE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvTypeEnum),
                                 rgtvTypeEnum,
                                 &dwType);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 3: // VALIDLIFETIME
            dwValidLifetime = GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 4: // PREFERREDLIFETIME
            dwPreferredLifetime = GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 5: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateAddress(pwszIfFriendlyName, &ipAddress, dwType,
                         dwValidLifetime, dwPreferredLifetime, Persistent);
}

DWORD
HandleAddAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetAddress(ppwcArguments, dwCurrentIndex, dwArgCount,
                               ACTION_ADD, pbDone);
}

DWORD
HandleSetAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetAddress(ppwcArguments, dwCurrentIndex, dwArgCount,
                               ACTION_SET, pbDone);
}

DWORD
HandleDelAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr, i;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE, TRUE,  FALSE},
                              {TOKEN_ADDRESS,   TRUE,  FALSE},
                              {TOKEN_STORE,     FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    IN6_ADDR     ipAddress;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        dwType = (DWORD)-1;
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            break;

        case 2: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateAddress(pwszIfFriendlyName, &ipAddress, dwType,
                         0, 0, Persistent);
}

DWORD
HandleShowAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                          {TOKEN_LEVEL,     FALSE, FALSE},
                          {TOKEN_STORE,     FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR   pwszIfFriendlyName = NULL;
    DWORD    i;
    DWORD    Persistent = FALSE;
    FORMAT   Format = FORMAT_NORMAL;
    TOKEN_VALUE  rgtvLevelEnum[] = {{ TOKEN_VALUE_NORMAL,  FORMAT_NORMAL },
                                    { TOKEN_VALUE_VERBOSE, FORMAT_VERBOSE }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            Format = FORMAT_VERBOSE;
            break;

        case 1: // LEVEL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvLevelEnum),
                                 rgtvLevelEnum,
                                 (DWORD*)&Format);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 2: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryAddressTable(pwszIfFriendlyName, Format, Persistent);
}

DWORD
HandleShowJoins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                          {TOKEN_LEVEL,     FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR   pwszIfFriendlyName = NULL;
    DWORD    i;
    FORMAT   Format = FORMAT_NORMAL;
    TOKEN_VALUE  rgtvLevelEnum[] = {{ TOKEN_VALUE_NORMAL,  FORMAT_NORMAL },
                                    { TOKEN_VALUE_VERBOSE, FORMAT_VERBOSE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // LEVEL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvLevelEnum),
                                 rgtvLevelEnum,
                                 (DWORD*)&Format);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryMulticastAddressTable(pwszIfFriendlyName, Format);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to mobility
/////////////////////////////////////////////////////////////////////////////

TOKEN_VALUE rgtvSecurityEnum[] = {
    { TOKEN_VALUE_ENABLED,  TRUE },
    { TOKEN_VALUE_DISABLED, FALSE },
};

DWORD
HandleSetMobility(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_SECURITY,          FALSE, FALSE},
                          {TOKEN_BINDINGCACHELIMIT, FALSE, FALSE},
                          {TOKEN_CNSTATE,           FALSE, FALSE},
                          {TOKEN_STORE,             FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvCNStateEnum[] = {{ TOKEN_VALUE_DISABLED, 0 },
                                      { TOKEN_VALUE_ENABLED,  MOBILE_CORRESPONDENT }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD    i, dwEnableSecurity = (DWORD)-1, dwBindingCacheLimit = (DWORD)-1;
    DWORD    dwMode = (DWORD)-1;
    DWORD    Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // SECURITY
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvSecurityEnum),
                                 rgtvSecurityEnum,
                                 &dwEnableSecurity);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 1: // BINDINGCACHELIMIT
            dwBindingCacheLimit = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                          NULL, 10);
            break;

        case 2: // CNSTATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvCNStateEnum),
                                 rgtvCNStateEnum,
                                 &dwMode);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 3: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateMobilityParameters(dwEnableSecurity, dwBindingCacheLimit,
                                    dwMode, Persistent);
}

DWORD
HandleShowMobility(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_STORE, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    DWORD    Persistent = FALSE;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryMobilityParameters(FORMAT_NORMAL, Persistent);
}


DWORD
HandleShowBindingCacheEntries(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return QueryBindingCache();
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to other global parameters
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleSetGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr, i;
    TAG_TYPE pttTags[] = {{TOKEN_DEFAULTCURHOPLIMIT,    FALSE, FALSE},
                          {TOKEN_NEIGHBORCACHELIMIT,    FALSE, FALSE},
                          {TOKEN_DESTINATIONCACHELIMIT, FALSE, FALSE},
                          {TOKEN_REASSEMBLYLIMIT,       FALSE, FALSE},
                          {TOKEN_STORE,                 FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD    dwDefaultCurHopLimit = (DWORD)-1;
    DWORD    dwNeighborCacheLimit = (DWORD)-1;
    DWORD    dwRouteCacheLimit = (DWORD)-1;
    DWORD    dwReassemblyLimit = (DWORD)-1;
    DWORD    Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // DEFAULTCURHOPLIMIT
            dwDefaultCurHopLimit = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                           NULL, 10);
            break;

        case 1: // NEIGHBORCACHELIMIT
            dwNeighborCacheLimit = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                           NULL, 10);
            break;

        case 2: // DESTINATIONCACHELIMIT
            dwRouteCacheLimit = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                        NULL, 10);
            break;

        case 3: // REASSEMBLYLIMIT
            dwReassemblyLimit = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                        NULL, 10);
            break;

        case 4: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateGlobalParameters(dwDefaultCurHopLimit, dwNeighborCacheLimit,
                                  dwRouteCacheLimit, dwReassemblyLimit,
                                  Persistent);
}

DWORD
HandleShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_STORE, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    DWORD    Persistent = FALSE;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryGlobalParameters(FORMAT_NORMAL, Persistent);
}

DWORD
HandleSetPrivacy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr, i;
    TAG_TYPE pttTags[] = {{TOKEN_STATE,                FALSE, FALSE},
                          {TOKEN_MAXDADATTEMPTS,       FALSE, FALSE},
                          {TOKEN_MAXVALIDLIFETIME,     FALSE, FALSE},
                          {TOKEN_MAXPREFERREDLIFETIME, FALSE, FALSE},
                          {TOKEN_REGENERATETIME,       FALSE, FALSE},
                          {TOKEN_MAXRANDOMTIME,        FALSE, FALSE},
                          {TOKEN_RANDOMTIME,           FALSE, FALSE},
                          {TOKEN_STORE,                FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStateEnum[] = {{ TOKEN_VALUE_DISABLED, USE_TEMP_NO },
                                    { TOKEN_VALUE_ENABLED,  USE_TEMP_YES }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD    dwState = (DWORD)-1;
    DWORD    dwMaxDadAttempts = (DWORD)-1;
    DWORD    dwMaxValidLifetime = (DWORD)-1;
    DWORD    dwMaxPrefLifetime = (DWORD)-1;
    DWORD    dwRegenerateTime = (DWORD)-1;
    DWORD    dwMaxRandomTime = (DWORD)-1;
    DWORD    dwRandomTime = (DWORD)-1;
    DWORD    Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStateEnum),
                                 rgtvStateEnum,
                                 &dwState);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 1: // MAXDADATTEMPTS
            dwMaxDadAttempts = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                       NULL, 10);
            break;

        case 2: // MAXVALIDLIFETIME
            dwMaxValidLifetime =
                GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 3: // MAXPREFLIFETIME
            dwMaxPrefLifetime =
                GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 4: // REGENERATETIME
            dwRegenerateTime =
                GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 5: // MAXRANDOMTIME
            dwMaxRandomTime =
                GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 6: // RANDOMTIME
            dwRandomTime =
                GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 7: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdatePrivacyParameters(dwState, dwMaxDadAttempts, 
                                   dwMaxValidLifetime, dwMaxPrefLifetime, 
                                   dwRegenerateTime, dwMaxRandomTime, 
                                   dwRandomTime, Persistent);
}

DWORD
HandleShowPrivacy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_STORE, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    DWORD    Persistent = FALSE;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryPrivacyParameters(FORMAT_NORMAL, Persistent);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to interfaces
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleAddV6V4Tunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE,         TRUE,  FALSE},
                              {TOKEN_LOCALADDRESS,      TRUE,  FALSE},
                              {TOKEN_REMOTEADDRESS,     TRUE,  FALSE},
                              {TOKEN_NEIGHBORDISCOVERY, FALSE, FALSE},
                              {TOKEN_STORE,             FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD        i, dwNeighborDiscovery = FALSE;
    IN_ADDR      ipLocalAddr, ipRemoteAddr;
    PWCHAR       pwszFriendlyName = NULL;
    TOKEN_VALUE  rgtvNDEnum[] = {{ TOKEN_VALUE_DISABLED, FALSE },
                                 { TOKEN_VALUE_ENABLED,  TRUE }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // LOCALADDRESS
            dwErr = GetIpv4Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipLocalAddr);
            break;

        case 2: // REMOTEADDRESS
            dwErr = GetIpv4Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipRemoteAddr);
            break;

        case 3: // NEIGHBORDISCOVERY
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvNDEnum),
                                 rgtvNDEnum,
                                 &dwNeighborDiscovery);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 4: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    dwErr = AddTunnelInterface(pwszFriendlyName, &ipLocalAddr, &ipRemoteAddr,
                               IPV6_IF_TYPE_TUNNEL_V6V4, dwNeighborDiscovery, 
                               Persistent);

    if (dwErr == ERROR_INVALID_HANDLE) {
        DisplayMessage(g_hModule, EMSG_INVALID_ADDRESS);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

DWORD
HandleAdd6over4Tunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE,    TRUE,  FALSE},
                              {TOKEN_LOCALADDRESS, TRUE,  FALSE},
                              {TOKEN_STORE,        FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        i;
    PWCHAR       pwszFriendlyName = NULL;
    IN_ADDR      ipLocalAddr;
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // LOCALADDRESS
            dwErr = GetIpv4Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipLocalAddr);
            break;

        case 2: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    dwErr = AddTunnelInterface(pwszFriendlyName, &ipLocalAddr, NULL,
                               IPV6_IF_TYPE_TUNNEL_6OVER4, 
                               TRUE,
                               Persistent);

    if (dwErr == ERROR_INVALID_HANDLE) {
        DisplayMessage(g_hModule, EMSG_INVALID_ADDRESS);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}

DWORD
HandleSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE,        TRUE,  FALSE},
                          {TOKEN_FORWARDING,       FALSE, FALSE},
                          {TOKEN_ADVERTISE,        FALSE, FALSE},
                          {TOKEN_MTU,              FALSE, FALSE},
                          {TOKEN_SITEID,           FALSE, FALSE},
                          {TOKEN_METRIC,           FALSE, FALSE},
                          {TOKEN_FIREWALL,         FALSE, FALSE},
                          {TOKEN_SITEPREFIXLENGTH, FALSE, FALSE},
                          {TOKEN_STORE,            FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvEnum[] = {{ TOKEN_VALUE_DISABLED, FALSE },
                               { TOKEN_VALUE_ENABLED,  TRUE }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    PWCHAR   pwszIfFriendlyName = NULL;
    DWORD    i, dwMtu = 0, dwSiteId = 0, dwMetric = (DWORD)-1;
    DWORD    dwAdvertise = (DWORD)-1, dwForwarding = (DWORD)-1;
    DWORD    dwFirewall = (DWORD)-1, dwDefSitePrefixLength = (DWORD)-1;
    DWORD    Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // FORWARDING
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnum),
                                 rgtvEnum,
                                 &dwForwarding);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 2: // ADVERTISE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnum),
                                 rgtvEnum,
                                 &dwAdvertise);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 3: // MTU
            dwMtu = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 4: // SITEID 
            dwSiteId = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 5: // METRIC
            dwMetric = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 6: // FIREWALL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnum),
                                 rgtvEnum,
                                 &dwFirewall);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 7: // SITEPREFIXLENGTH
            dwDefSitePrefixLength = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                            NULL, 10);
            break;

        case 8: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateInterface(pwszIfFriendlyName, dwForwarding, dwAdvertise, 
                           dwMtu, dwSiteId, dwMetric, dwFirewall, 
                           dwDefSitePrefixLength, Persistent);
}

DWORD
HandleDelInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, TRUE, FALSE},
                          {TOKEN_STORE,     FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR   pwszIfFriendlyName = NULL;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD    i;
    DWORD    Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return DeleteInterface(pwszIfFriendlyName, Persistent);
}

DWORD
HandleShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                          {TOKEN_LEVEL,     FALSE, FALSE},
                          {TOKEN_STORE,     FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR   pwszIfFriendlyName = NULL;
    DWORD    i;
    FORMAT   Format = FORMAT_NORMAL;
    TOKEN_VALUE  rgtvLevelEnum[] = {{ TOKEN_VALUE_NORMAL,  FORMAT_NORMAL },
                                    { TOKEN_VALUE_VERBOSE, FORMAT_VERBOSE }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD    Persistent = FALSE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            Format = FORMAT_VERBOSE;
            break;

        case 1: // LEVEL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvLevelEnum),
                                 rgtvLevelEnum,
                                 (DWORD*)&Format);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 2: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryInterface(pwszIfFriendlyName, Format, Persistent);
}

DWORD
HandleRenew(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR   pwszIfFriendlyName = NULL;
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return RenewInterface(pwszIfFriendlyName);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to the neighbor cache
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleDelNeighbors(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                              {TOKEN_ADDRESS,   FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    DWORD        i;
    IN6_ADDR     ipAddress, *pipAddress = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            pipAddress = &ipAddress;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return FlushNeighborCache(pwszIfFriendlyName, pipAddress);
}

DWORD
HandleShowNeighbors(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                              {TOKEN_ADDRESS,   FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    DWORD        i;
    IN6_ADDR     ipAddress, *pipAddress = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            pipAddress = &ipAddress;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryNeighborCache(pwszIfFriendlyName, pipAddress);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to the prefix policies
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleAddSetPrefixPolicy(
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      ACTION    Action,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_PREFIX,     TRUE,  FALSE},
                              {TOKEN_PRECEDENCE, TRUE,  FALSE},
                              {TOKEN_LABEL,      TRUE,  FALSE},
                              {TOKEN_STORE,      FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        i, dwPrefixLength = 0, dwPrecedence = (DWORD)-1, 
                 dwLabel = (DWORD)-1;
    IN6_ADDR     ipAddress;
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // PREFIX
            dwErr = GetIpv6Prefix(ppwcArguments[i + dwCurrentIndex],
                                  &ipAddress, &dwPrefixLength);
            break;

        case 1: // PRECEDENCE
            dwPrecedence = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 2: // LABEL
            dwLabel = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 3: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdatePrefixPolicy(&ipAddress, dwPrefixLength, dwPrecedence, 
                              dwLabel, Persistent);
}

DWORD
HandleAddPrefixPolicy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetPrefixPolicy(ppwcArguments, dwCurrentIndex, dwArgCount,
                                    ACTION_ADD, pbDone);
}

DWORD
HandleSetPrefixPolicy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetPrefixPolicy(ppwcArguments, dwCurrentIndex, dwArgCount,
                                    ACTION_SET, pbDone);
}

DWORD
HandleDelPrefixPolicy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_PREFIX,   TRUE,  FALSE},
                              {TOKEN_STORE,    FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        i, dwPrefixLength = 0;
    IN6_ADDR     ipAddress;
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // PREFIX
            dwErr = GetIpv6Prefix(ppwcArguments[i + dwCurrentIndex],
                                  &ipAddress, &dwPrefixLength);
            break;

        case 1: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return DeletePrefixPolicy(&ipAddress, dwPrefixLength, Persistent);
}

DWORD
HandleShowPrefixPolicy(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr;
    TAG_TYPE pttTags[] = {{TOKEN_STORE, FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    DWORD    Persistent = FALSE;
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryPrefixPolicy(FORMAT_NORMAL, Persistent);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to routes
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleAddSetRoute(
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      ACTION    Action,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr, i;
    TAG_TYPE     pttTags[] = {{TOKEN_PREFIX,            TRUE,  FALSE},
                              {TOKEN_INTERFACE,         TRUE,  FALSE},
                              {TOKEN_NEXTHOP,           FALSE, FALSE},
                              {TOKEN_SITEPREFIXLENGTH,  FALSE, FALSE},
                              {TOKEN_METRIC,            FALSE, FALSE},
                              {TOKEN_PUBLISH,           FALSE, FALSE},
                              {TOKEN_VALIDLIFETIME,     FALSE, FALSE},
                              {TOKEN_PREFERREDLIFETIME, FALSE, FALSE},
                              {TOKEN_STORE,             FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvPublishEnum[] = {
                              {TOKEN_VALUE_NO,  PUBLISH_NO },
                              {TOKEN_VALUE_AGE, PUBLISH_AGE },
                              {TOKEN_VALUE_YES, PUBLISH_IMMORTAL }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        dwPrefixLength = 0, dwMetric = ROUTE_PREF_HIGHEST;
    DWORD        dwSitePrefixLength = 0;
    IN6_ADDR     ipPrefix, ipNextHop, *pipNextHop = NULL;
    PWCHAR       pwszIfFriendlyName = NULL;
    PUBLISH      Publish = PUBLISH_NO;
    DWORD        dwValidLifetime = INFINITE_LIFETIME;
    DWORD        dwPreferredLifetime = INFINITE_LIFETIME;    
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // PREFIX
            dwErr = GetIpv6Prefix(ppwcArguments[i + dwCurrentIndex],
                                  &ipPrefix, &dwPrefixLength);
            break;

        case 1: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[dwCurrentIndex + i];
            break;

        case 2: // NEXTHOP
            pipNextHop = &ipNextHop; 
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipNextHop);
            break;

        case 3: // SITEPREFIXLENGTH
            dwSitePrefixLength = wcstoul(ppwcArguments[dwCurrentIndex + i], 
                                         NULL, 10);
            break;

        case 4: // METRIC
            dwMetric = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        case 5: // PUBLISH
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvPublishEnum),
                                 rgtvPublishEnum,
                                 (DWORD*)&Publish);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 6: // VALIDLIFETIME
            dwValidLifetime = GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 7: // PREFERREDLIFETIME
            dwPreferredLifetime = GetTime(ppwcArguments[dwCurrentIndex + i]);
            break;

        case 8: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work
    if ((dwPreferredLifetime == INFINITE_LIFETIME) &&
        (dwValidLifetime != INFINITE_LIFETIME)) {
        dwPreferredLifetime = dwValidLifetime;
    }

    // Disallow persistent aging routes with non-infinite valid lifetimes,
    // since every reboot they would come back, and then go away after
    // the lifetime expires.  This would be very confusing, and so we
    // just disallow it.
    if ((Publish != PUBLISH_IMMORTAL) &&
        (dwValidLifetime != INFINITE_LIFETIME) &&
        (Persistent == TRUE)) {
        DisplayMessage(g_hModule, EMSG_CANT_PERSIST_AGING_ROUTES);
        return ERROR_SUPPRESS_OUTPUT;
    }

    return UpdateRouteTable(&ipPrefix, dwPrefixLength, pwszIfFriendlyName,
                            pipNextHop, dwMetric, Publish, dwSitePrefixLength,
                            dwValidLifetime, dwPreferredLifetime, Persistent);
}

DWORD
HandleAddRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetRoute(ppwcArguments, dwCurrentIndex, dwArgCount,
                             ACTION_ADD, pbDone);
}

DWORD
HandleSetRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return HandleAddSetRoute(ppwcArguments, dwCurrentIndex, dwArgCount,
                             ACTION_SET, pbDone);
}

DWORD
HandleDelRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr, i;
    TAG_TYPE     pttTags[] = {{TOKEN_PREFIX,           TRUE,  FALSE},
                              {TOKEN_INTERFACE,        TRUE,  FALSE},
                              {TOKEN_NEXTHOP,          FALSE, FALSE},
                              {TOKEN_STORE,            FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    DWORD        dwPrefixLength = 0, dwMetric = ROUTE_PREF_HIGHEST;
    DWORD        dwSitePrefixLength = 0;
    IN6_ADDR     ipPrefix, ipNextHop, *pipNextHop = NULL;
    PWCHAR       pwszIfFriendlyName = NULL;
    PUBLISH      Publish = PUBLISH_NO;
    DWORD        Persistent = TRUE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // PREFIX
            dwErr = GetIpv6Prefix(ppwcArguments[i + dwCurrentIndex],
                                  &ipPrefix, &dwPrefixLength);
            break;

        case 1: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[dwCurrentIndex + i];
            break;

        case 2: // NEXTHOP
            pipNextHop = &ipNextHop; 
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipNextHop);
            break;

        case 3: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return UpdateRouteTable(&ipPrefix, dwPrefixLength, pwszIfFriendlyName,
                            pipNextHop, dwMetric, Publish, dwSitePrefixLength,
                            0, 0, Persistent);
}

DWORD
HandleShowRoutes(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_LEVEL, FALSE, FALSE},
                              {TOKEN_STORE, FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD        i;
    TOKEN_VALUE  rgtvLevelEnum[] = {{ TOKEN_VALUE_NORMAL,  FORMAT_NORMAL },
                                    { TOKEN_VALUE_VERBOSE, FORMAT_VERBOSE }};
    TOKEN_VALUE  rgtvStoreEnum[] = {{ TOKEN_VALUE_ACTIVE,     FALSE },
                                    { TOKEN_VALUE_PERSISTENT, TRUE }};
    FORMAT       Format = FORMAT_NORMAL;
    DWORD        Persistent = FALSE;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // LEVEL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvLevelEnum),
                                 rgtvLevelEnum,
                                 (DWORD*)&Format);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        case 1: // STORE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvStoreEnum),
                                 rgtvStoreEnum,
                                 &Persistent);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryRouteTable(Format, Persistent);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to the destination cache
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleDelDestinationCache(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                              {TOKEN_ADDRESS,   FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    DWORD        i;
    IN6_ADDR     ipAddress, *pipAddress = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            pipAddress = &ipAddress;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return FlushRouteCache(pwszIfFriendlyName, pipAddress);
}

DWORD
HandleShowDestinationCache(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_INTERFACE, FALSE, FALSE},
                              {TOKEN_ADDRESS,   FALSE, FALSE},
                              {TOKEN_LEVEL,     FALSE, FALSE}};
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PWCHAR       pwszIfFriendlyName = NULL;
    DWORD        i;
    IN6_ADDR     ipAddress, *pipAddress = NULL;
    FORMAT       Format = FORMAT_NORMAL;
    TOKEN_VALUE  rgtvLevelEnum[] = {{ TOKEN_VALUE_NORMAL,  FORMAT_NORMAL },
                                    { TOKEN_VALUE_VERBOSE, FORMAT_VERBOSE }};

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            pipAddress = &ipAddress;
            Format = FORMAT_VERBOSE;
            break;

        case 2: // LEVEL
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvLevelEnum),
                                 rgtvLevelEnum,
                                 (DWORD*)&Format);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Now do the work

    return QueryRouteCache(pwszIfFriendlyName, pipAddress, Format);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to the site prefix table
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleShowSitePrefixes(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return QuerySitePrefixTable(FORMAT_NORMAL);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to installation
/////////////////////////////////////////////////////////////////////////////

DWORD
HandleInstall(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return AddOrRemoveIpv6(TRUE);
}

DWORD
HandleReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
#ifdef TEREDO    
    DWORD dwErr;
    dwErr = ResetTeredo();
    if ((dwErr != NO_ERROR) && (dwErr != ERROR_OKAY)) {
        return dwErr;
    }
#endif // TEREDO
            
    return ResetIpv6Config(TRUE);
}


DWORD
HandleUninstall(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return AddOrRemoveIpv6(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Commands related to deprecated functionality
/////////////////////////////////////////////////////////////////////////////

#define KEY_ENABLE_6OVER4           L"Enable6over4"
#define KEY_ENABLE_V4COMPAT         L"EnableV4Compat"

#define BM_ENABLE_6OVER4   0x01
#define BM_ENABLE_V4COMPAT 0x02

DWORD
HandleSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hGlobal;
    STATE    stEnable6over4 = 0;
    STATE    stEnableV4Compat = 0;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_6OVER4,       FALSE, FALSE},
                          {TOKEN_V4COMPAT,     FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // 6OVER4
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnable6over4);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwBitVector |= BM_ENABLE_6OVER4;
            break;

        case 1: // V4COMPAT
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableV4Compat);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            dwBitVector |= BM_ENABLE_V4COMPAT;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0,
                           NULL, 0, KEY_SET_VALUE, NULL, &hGlobal, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_6OVER4) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_6OVER4, stEnable6over4);
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    if (dwBitVector & BM_ENABLE_V4COMPAT) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_V4COMPAT, stEnableV4Compat);
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    RegCloseKey(hGlobal);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
ShowIpv6StateConfig(
    IN BOOL Dumping
    )
{
    DWORD dwErr = NO_ERROR;
    HKEY  hGlobal;
    STATE stEnable6over4;
    STATE stEnableV4Compat;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_QUERY_VALUE,
                         &hGlobal);

    if (dwErr != NO_ERROR) {
        hGlobal = INVALID_HANDLE_VALUE;
        dwErr = NO_ERROR;
    }

    stEnable6over4 = GetInteger(hGlobal, KEY_ENABLE_6OVER4, VAL_DEFAULT);
    stEnableV4Compat = GetInteger(hGlobal, KEY_ENABLE_V4COMPAT, VAL_DEFAULT);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    if (Dumping) {
        if ((stEnable6over4 != VAL_DEFAULT) || 
            (stEnableV4Compat != VAL_DEFAULT)) {

            DisplayMessageT(DMP_IP6TO4_SET_STATE);

            if (stEnable6over4 != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_6OVER4,
                                pwszStateString[stEnable6over4]);
            }

            if (stEnableV4Compat != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_V4COMPAT,
                                pwszStateString[stEnableV4Compat]);
            }

            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(g_hModule, MSG_6OVER4_STATE,
                                  pwszStateString[stEnable6over4]);

        DisplayMessage(g_hModule, MSG_V4COMPAT_STATE,
                                  pwszStateString[stEnableV4Compat]);
    }

    return dwErr;
}

DWORD
HandleShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowIpv6StateConfig(FALSE);
}

#define KEY_DNS_SERVER_LIST L"NameServer"

DWORD
GetDnsServerList(
    IN  PWCHAR                pwszIfFriendlyName,
    IN  PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT IN6_ADDR            **ppipDnsList, 
    OUT DWORD                *pdwNumEntries
    )
/*++

Routine Description: 

    Reads the list of DNS servers from the registry and returns them in
    an array which includes space for at least one more server.  The
    caller is responsible for freeing this space with FREE().

--*/
{
    HKEY hInterfaces = INVALID_HANDLE_VALUE, hIf = INVALID_HANDLE_VALUE;
    DWORD dwErr = NO_ERROR, Count = 0;
    WCHAR Servers[800], *p;
    IN6_ADDR *pipDnsList = NULL;
    SOCKADDR_IN6 saddr;
    INT Length;
    PCHAR pszAdapterName;

    dwErr = MapFriendlyNameToAdapterName(NULL, pwszIfFriendlyName,
                                         pAdapterInfo, &pszAdapterName);
    if (dwErr != NO_ERROR) {
        goto Cleanup;
    }

    Servers[0] = L'\0';

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_IPV6_INTERFACES, 0, 
                     KEY_QUERY_VALUE, 
                     &hInterfaces) != NO_ERROR) {
        goto HaveString;
    }

    if (RegOpenKeyExA(hInterfaces, pszAdapterName, 0, KEY_QUERY_VALUE, &hIf) 
           == NO_ERROR) {
        GetString(hIf, KEY_DNS_SERVER_LIST, Servers, 800);
    }

HaveString:
    // Count one server for each delimiter, plus one at the end, plus
    // one more which the caller might want to add to the array which
    // we allocate.
    for (p = Servers; *p; p++) {
        if (*p == ' ' || *p == ',' || *p == ';') {
            Count++;
        }
    }
    Count += 2;

    //
    // Now allocate an array of IN6_ADDR structures, and copy all the
    // addresses into it.
    //
    pipDnsList = MALLOC(sizeof(IN6_ADDR) * Count);
    if (pipDnsList == NULL) {
        dwErr = GetLastError();
        goto Cleanup;
    }

    Count = 0;
    for (p = wcstok(Servers, L" ,;"); p; p = wcstok(NULL, L" ,;")) {
        Length = sizeof(saddr);
        if (WSAStringToAddressW(p, AF_INET6, NULL, (LPSOCKADDR)&saddr, 
                                &Length) == NO_ERROR) {
            pipDnsList[Count++] = saddr.sin6_addr;
        }
    }

Cleanup:
    if (hIf != INVALID_HANDLE_VALUE) {
        RegCloseKey(hIf);
    }
    if (hInterfaces != INVALID_HANDLE_VALUE) {
        RegCloseKey(hInterfaces);
    }

    *pdwNumEntries = Count;
    *ppipDnsList = pipDnsList;
    return dwErr;
}

DWORD
SetDnsServerList(
    IN PWCHAR                pwszIfFriendlyName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN IN6_ADDR             *pipDnsList, 
    IN DWORD                 dwNumEntries
    )
/*++

Routine Description: 

    Writes the list of DNS servers to the registry, overwriting any
    previously list.

--*/
{
    DWORD dwErr;
    WCHAR Servers[800], *p = Servers;
    ULONG LengthLeft = 800, Length;
    DWORD i;
    SOCKADDR_IN6 saddr;
    HKEY hInterfaces, hIf;
    PCHAR pszAdapterName;

    dwErr = MapFriendlyNameToAdapterName(NULL, pwszIfFriendlyName,
                                         pAdapterInfo, &pszAdapterName);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_IPV6_INTERFACES, 0,
                           NULL, 0, KEY_CREATE_SUB_KEY, 
                           NULL, &hInterfaces, NULL);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = RegCreateKeyExA(hInterfaces, pszAdapterName, 0,
                            NULL, 0, KEY_SET_VALUE, NULL, &hIf, NULL);

    if (dwErr != NO_ERROR) {
        RegCloseKey(hInterfaces);

        return dwErr;
    }

    // Compose the string value, making sure to prevent a buffer overrun.
    Servers[0] = L'\0';
    ZeroMemory(&saddr, sizeof(saddr));
    saddr.sin6_family = AF_INET6;
    for (i = 0; i < dwNumEntries; i++) {
        saddr.sin6_addr = pipDnsList[i];
        Length = LengthLeft;
        if (WSAAddressToStringW((LPSOCKADDR)&saddr, sizeof(saddr), NULL,
                                p, &Length) != NO_ERROR) {
            continue;
        }

        // Update string taking into account that Length includes the NULL 
        // byte.
        LengthLeft -= Length;
        p += (Length-1);
        *p++ = L' ';
    }
    if (p > Servers) {
        // Null out final delimiter.
        p--;
        *p = '\0';
    }

    dwErr = SetString(hIf, KEY_DNS_SERVER_LIST, Servers);

    RegCloseKey(hIf);
    RegCloseKey(hInterfaces);

    return dwErr;
}

DWORD
HandleAddDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, NS_REQ_PRESENT, FALSE},
                          {TOKEN_ADDRESS,   NS_REQ_PRESENT, FALSE},
                          {TOKEN_INDEX,     NS_REQ_ZERO,    FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    PWCHAR   pwszIfFriendlyName = NULL;
    IN6_ADDR ipAddress = { INADDR_ANY };
    DWORD    dwIndex = (DWORD)-1;
    IN6_ADDR *ipDnsList = NULL;
    DWORD    dwNumEntries;
    PIP_ADAPTER_ADDRESSES pAdapterInfo = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                   &ipAddress);
            break;

        case 2: // INDEX
            dwIndex = wcstoul(ppwcArguments[dwCurrentIndex + i], NULL, 10);
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        goto Cleanup; 
    }

    dwErr = GetDnsServerList(pwszIfFriendlyName, pAdapterInfo, &ipDnsList, 
                             &dwNumEntries);
    if (dwErr != NO_ERROR) {
        goto Cleanup;
    }

    if ((dwIndex == -1) || (dwIndex-1 == dwNumEntries)) {
        // Append server.
        ipDnsList[dwNumEntries++] = ipAddress;
    } else if ((dwIndex == 0) || (dwIndex > dwNumEntries)) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } else {
        dwIndex--;

        // Insert server at location 'dwIndex'.
        for (i = dwNumEntries; i > dwIndex; i--) {
            ipDnsList[i] = ipDnsList[i-1];
        }
        ipDnsList[dwIndex] = ipAddress;
        dwNumEntries++;
    }

    dwErr = SetDnsServerList(pwszIfFriendlyName, pAdapterInfo, ipDnsList, 
                             dwNumEntries);

Cleanup:
    if (ipDnsList != NULL) {
        FREE(ipDnsList);
    }
    if (pAdapterInfo != NULL) {
        FREE(pAdapterInfo);
    }

    if (dwErr == NO_ERROR) {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}

DWORD
HandleDelDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, NS_REQ_PRESENT, FALSE},
                          {TOKEN_ADDRESS,   NS_REQ_PRESENT, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    PWCHAR   pwszIfFriendlyName = NULL;
    IN6_ADDR ipAddress;
    IN6_ADDR *ipDnsList = NULL;
    BOOL     bAll = FALSE;
    DWORD    dwNumEntries;
    PIP_ADAPTER_ADDRESSES pAdapterInfo = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        case 1: // ADDRESS
            {
                DWORD dwRes;
                TOKEN_VALUE rgEnums[] = {{TOKEN_VALUE_ALL, 1}};

                dwErr = MatchEnumTag(g_hModule, 
                                     ppwcArguments[i + dwCurrentIndex],
                                     NUM_TOKENS_IN_TABLE(rgEnums),
                                     rgEnums,
                                     &dwRes);
                if (NO_ERROR == dwErr) {
                    bAll = TRUE;
                } else {
                    dwErr = GetIpv6Address(ppwcArguments[i + dwCurrentIndex],
                                           &ipAddress);
                }
                break;
            }

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        goto Cleanup; 
    }

    dwErr = GetDnsServerList(pwszIfFriendlyName, pAdapterInfo, &ipDnsList, 
                             &dwNumEntries);
    if (dwErr != NO_ERROR) {
        goto Cleanup;
    }

    if (bAll) {
        // Delete all entries.
        dwNumEntries = 0;
    } else {
        // Find and delete the specified entry.
        for (i = 0; i < dwNumEntries; i++) {
            if (!memcmp(&ipAddress, &ipDnsList[i], sizeof(ipAddress))) {
                break;
            }
        }
        if (i == dwNumEntries) {
            goto Cleanup;     
        }

        for (; i + 1 < dwNumEntries; i++) {
            ipDnsList[i] = ipDnsList[i+1]; 
        }
        dwNumEntries--;
    }

    dwErr = SetDnsServerList(pwszIfFriendlyName, pAdapterInfo, ipDnsList, 
                             dwNumEntries);

Cleanup:
    if (ipDnsList != NULL) {
        FREE(ipDnsList);
    }
    if (pAdapterInfo != NULL) {
        FREE(pAdapterInfo);
    }

    if (dwErr == NO_ERROR) {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}

DWORD
ShowIfDnsServers(
    IN BOOL bDump,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN PWCHAR pwszIfFriendlyName,
    IN OUT BOOL *pbHeaderDone
    )
{
    DWORD i, dwErr;
    WCHAR buff[NI_MAXHOST];
    SOCKADDR_IN6 saddr;
    DWORD Length, dwNumEntries;
    IN6_ADDR *ipDnsList;

    dwErr = GetDnsServerList(pwszIfFriendlyName, pAdapterInfo, &ipDnsList, 
                             &dwNumEntries);
    if (dwErr != NO_ERROR) {
        goto Error;
    }

    if (!bDump && (dwNumEntries > 0)) {
        DisplayMessage(g_hModule, MSG_DNS_SERVER_HEADER, pwszIfFriendlyName);
        *pbHeaderDone = TRUE;
    }

    ZeroMemory(&saddr, sizeof(saddr));
    saddr.sin6_family = AF_INET6;
    for (i = 0; i < dwNumEntries; i++) {
        saddr.sin6_addr = ipDnsList[i];
        Length = sizeof(saddr);
        if (WSAAddressToStringW((LPSOCKADDR)&saddr, sizeof(saddr), NULL,
                                buff, &Length) != NO_ERROR) {
            continue;
        }

        if (bDump) {
            DisplayMessageT(DMP_IPV6_ADD_DNS);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE, 
                            pwszIfFriendlyName);
            DisplayMessageT(DMP_STRING_ARG, TOKEN_ADDRESS, buff);
            DisplayMessage(g_hModule, MSG_NEWLINE);
        } else {
            DisplayMessage(g_hModule, MSG_DNS_SERVER, i+1, buff);
        }
    }

Error:
    if (ipDnsList != NULL) {
        FREE(ipDnsList);
    }
    return dwErr;
}

DWORD
ShowDnsServers(
    IN BOOL bDump,
    IN PWCHAR pwszIfFriendlyName
    )
{
    PIP_ADAPTER_ADDRESSES pIf, pAdapterInfo = NULL;
    DWORD dwErr;
    BOOL bHeaderDone = FALSE;

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (pwszIfFriendlyName == NULL) {
        for (pIf = pAdapterInfo; (dwErr == NO_ERROR) && pIf; pIf = pIf->Next) {
            if (pIf->Ipv6IfIndex == 0) {
                continue;
            }
            dwErr = ShowIfDnsServers(bDump, pAdapterInfo, pIf->FriendlyName,
                                     &bHeaderDone);
        }
    } else {
        dwErr = ShowIfDnsServers(bDump, pAdapterInfo, pwszIfFriendlyName,
                                 &bHeaderDone);
    }

    if (!bDump) {
        if (!bHeaderDone) {
            DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
        }
        if (dwErr == NO_ERROR) {
            dwErr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    FREE(pAdapterInfo);
    return dwErr;
}

DWORD
HandleShowDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    TAG_TYPE pttTags[] = {{TOKEN_INTERFACE, NS_REQ_ZERO, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;
    PWCHAR   pwszIfFriendlyName = NULL;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // INTERFACE
            pwszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }


    dwErr = ShowDnsServers(FALSE, pwszIfFriendlyName);
    if (dwErr == NO_ERROR) {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\installipv6.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <netcfgx.h>
#include <devguid.h>

HRESULT
HrCreateINetCfg (
    IN BOOL fAcquireWriteLock,
    OUT INetCfg** ppINetCfg)
{
    HRESULT hr;
    INetCfg* pINetCfg;

    // Get the INetCfg interface.
    //
    hr = CoCreateInstance(
        CLSID_CNetCfg,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        IID_INetCfg,
        reinterpret_cast<void**>(&pINetCfg));

    if (S_OK == hr) {
        INetCfgLock * pnclock = NULL;

        if (fAcquireWriteLock) {
            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr)) {
                LPWSTR pwszLockHolder;

                // Attempt to lock the INetCfg for read/write
                hr = pnclock->AcquireWriteLock(100, L"InstallIPv6", 
                    &pwszLockHolder);
                if (S_FALSE == hr) {
                    // Couldn't acquire the lock
                    hr = NETCFG_E_NO_WRITE_LOCK;
                    DisplayMessage(g_hModule, EMSG_NO_WRITE_LOCK, 
                                   pwszLockHolder);
                }
                if (pwszLockHolder) {
                    CoTaskMemFree(pwszLockHolder);
                }
            }
        }

        if (S_OK == hr) {
            hr = pINetCfg->Initialize (NULL);
            if (S_OK == hr) {
                *ppINetCfg = pINetCfg;
                pINetCfg->AddRef();
            }
            else {
                if (pnclock) {
                    pnclock->ReleaseWriteLock();
                }
            }
        }

        if (pnclock) {
            pnclock->Release();
        }

        //Transfer ownership to caller.
        pINetCfg->Release();
    }
    return hr;
}


DWORD
pAddOrRemoveIpv6(BOOL fAddIpv6)
{
    HRESULT hr;
    INetCfg* pINetCfg;
    DWORD dwErr = NO_ERROR;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr) {
        INetCfgClassSetup* pSetup;

        // Get the setup interface used for installing
        // and uninstalling components.
        //
        hr = pINetCfg->QueryNetCfgClass (
                &GUID_DEVCLASS_NETTRANS,
                IID_INetCfgClassSetup,
                (VOID**)&pSetup);

        if (S_OK == hr) {
            OBO_TOKEN OboToken;
            INetCfgComponent* pIComp;

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            if (fAddIpv6) {
                hr = pSetup->Install (
                        L"MS_TCPIP6",
                        &OboToken,
                        0, 0, NULL, NULL,
                        &pIComp);

                if (pIComp) {
                    pIComp->Release();
                }
            } else {
                // Need to remove the component.
                // Find it first.
                //
                hr = pINetCfg->FindComponent (
                        L"MS_TCPIP6",
                        &pIComp);

                if (S_OK == hr) {
                    hr = pSetup->DeInstall (
                            pIComp,
                            &OboToken,
                            NULL);

                    pIComp->Release();
                } else {
                    dwErr = ERROR_OKAY;
                }
            }

            if (SUCCEEDED(hr)) {
                if (NETCFG_S_REBOOT == hr) {
                    hr = S_OK;
                    DisplayMessage(g_hModule, EMSG_REBOOT_NEEDED);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                } else {
                    dwErr = ERROR_OKAY;
                }
            } else {
                if (NETCFG_E_NEED_REBOOT == hr) {
                    DisplayMessage(g_hModule, EMSG_REBOOT_NEEDED);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                } else {
                    dwErr = hr;
                }
            }

            pSetup->Release();
        }

        hr = pINetCfg->Uninitialize();
        if (SUCCEEDED(hr)) {
            INetCfgLock *pnclock;

            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr)) {
                // Attempt to lock the INetCfg for read/write
                hr = pnclock->ReleaseWriteLock();

               pnclock->Release();
            }
        }

        pINetCfg->Release();
    }
    else if (NETCFG_E_NO_WRITE_LOCK == hr) {
        // Message has already been printed
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }
    else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr) {
        dwErr = ERROR_ACCESS_DENIED;
    }
    else {
        dwErr = hr;
    }

    return dwErr;
}

EXTERN_C
DWORD
IsIpv6Installed(
    BOOL *bInstalled)
{
    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;
    BOOL fPresent = FALSE;
    DWORD dwErr = NO_ERROR;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        HRESULT hr;
        INetCfg* pINetCfg;

        hr = HrCreateINetCfg (FALSE, &pINetCfg);
        if (S_OK == hr) {
            fPresent = (S_OK == pINetCfg->FindComponent(L"MS_TCPIP6", NULL));
            pINetCfg->Uninitialize();
            pINetCfg->Release();
        } else {
            dwErr = hr;
        }

        if (fInitCom) {
            CoUninitialize();
        }
    } else {
        dwErr = hr;
    }

    *bInstalled =  fPresent;

    return dwErr;
}

EXTERN_C
DWORD
AddOrRemoveIpv6 (
    IN BOOL fAddIpv6)
{

    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;
    DWORD dwErr = NO_ERROR;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        dwErr = pAddOrRemoveIpv6(fAddIpv6);

        if (fInitCom) {
            CoUninitialize();
        }
    }
    else {
        dwErr = hr;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ipv6mon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

--*/


#ifndef _IPV6MON_H_
#define _IPV6MON_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define IPV6MON_GUID \
{ 0x05bb0fe9,0x8d89, 0x48de, { 0xb7, 0xbb, 0x9f,0x13, 0x8b,0x2e, 0x95, 0x0c } }

#define PORTPROXY_GUID \
{ 0x86a3a33f, 0x4d51, 0x47ff, { 0xb2, 0x4c, 0x8e, 0x9b, 0x13, 0xce, 0xb3, 0xa2 } };

extern GUID g_PpGuid;
NS_HELPER_START_FN PpStartHelper;

#define PORTPROXY_HELPER_VERSION 1

#define IFMON_GUID \
{ 0x705eca1, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

extern HANDLE   g_hModule;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern BOOL     g_bIfDirty;

#define SECONDS         1
#define MINUTES         (60 * SECONDS)
#define HOURS           (60 * MINUTES)
#define DAYS            (24 * HOURS)

//
// Api's that ifmon requires of its helpers
//
typedef
DWORD
(WINAPI IF_CONTEXT_ENTRY_FN)(
    IN    PWCHAR               pwszMachineName,
    IN    PTCHAR               *pptcArguments,
    IN    DWORD                dwArgCount,
    IN    DWORD                dwFlags,
    IN    PVOID                hMibServer,
    OUT   PWCHAR               pwcNewContext
    );
typedef IF_CONTEXT_ENTRY_FN *PIF_CONTEXT_ENTRY_FN;

extern GUID g_Ipv6Guid;

NS_CONTEXT_DUMP_FN   Ipv6Dump;
NS_CONTEXT_DUMP_FN   PpDump;

DWORD
ConnectToRouter(
    IN  PWCHAR  pwszRouter
    );

BOOL
WINAPI
Ipv6DllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    );

DWORD
WINAPI
Ipv6UnInit(
    IN  DWORD   dwReserved
    );

#define GetIfNameFromFriendlyName(x,y,z) \
      NsGetIfNameFromFriendlyName(g_hMprConfig,x,y,z)
#define GetFriendlyNameFromIfName(x,y,z) \
      NsGetFriendlyNameFromIfName(g_hMprConfig,x,y,z)

DWORD
Ipv6InstallSubContexts(
    );

#ifdef __cplusplus
}
#endif

#endif // _IPV6MON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ipv6.c ===
//=============================================================================
// Copyright (c) 2001 Microsoft Corporation
// Abstract:
//      This module implements IPv6 configuration commands.
//
// This code is based off ipv6.c from Rich Draves
//=============================================================================

#include "precomp.h"
#pragma hdrstop

HANDLE Handle = INVALID_HANDLE_VALUE;
BOOL AdminAccess = TRUE;

#define IPv6_MINIMUM_MTU  1280

#define MillisToSeconds(millis) ((millis) / 1000)

DWORD
SetString(
    IN  HKEY    hKey,
    IN  LPCTSTR lpName,
    IN  PWCHAR  pwcValue
    );

PWCHAR
FormatTime(
    IN DWORD dwLife,
    OUT PWCHAR pwszLife
    )
{
    DWORD dwDays, dwHours, dwMinutes;
    PWCHAR pwszNext = pwszLife;
    
    if (dwLife == INFINITE_LIFETIME) {
        swprintf(pwszNext, L"%s", TOKEN_VALUE_INFINITE);
        return pwszLife;
    }

    if (dwLife < MINUTES)
        goto FormatSeconds;

    if (dwLife < HOURS)
        goto FormatMinutes;

    if (dwLife < DAYS)
        goto FormatHours;

    dwDays = dwLife / DAYS;
    pwszNext += swprintf(pwszNext, L"%ud", dwDays);
    dwLife -= dwDays * DAYS;

  FormatHours:
    dwHours = dwLife / HOURS;
    if (dwHours != 0)
        pwszNext += swprintf(pwszNext, L"%uh", dwHours);
    dwLife -= dwHours * HOURS;

  FormatMinutes:
    dwMinutes = dwLife / MINUTES;
    if (dwMinutes != 0)
        pwszNext += swprintf(pwszNext, L"%um", dwMinutes);
    dwLife -= dwMinutes * MINUTES;

    if (dwLife == 0) {
        return pwszLife;
    }
    
  FormatSeconds:
    swprintf(pwszNext, L"%us", dwLife);
    return pwszLife;
}

DWORD
OpenIPv6(
    FORMAT Format
    )
{
    WSADATA wsaData;
    BOOL bInstalled;
    DWORD dwErr = NO_ERROR;

    if (Handle != INVALID_HANDLE_VALUE) {
        return NO_ERROR;
    }

    dwErr = IsIpv6Installed(&bInstalled);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }
    if (!bInstalled) {
        if (Format != FORMAT_DUMP) {
            DisplayMessage(g_hModule, EMSG_PROTO_NOT_INSTALLED);
        }
        return ERROR_SUPPRESS_OUTPUT;
    }

    //
    // We initialize Winsock just so we can have access
    // to WSAStringToAddress and WSAAddressToString.
    //
    if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        return WSAGetLastError();
    }

    //
    // First request write access.
    // This will fail if the process does not have local Administrator privs.
    //
    Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                         GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,   // security attributes
                         OPEN_EXISTING,
                         0,      // flags & attributes
                         NULL);  // template file
    if (Handle == INVALID_HANDLE_VALUE) {
        //
        // We will not have Administrator access to the stack.
        //
        AdminAccess = FALSE;

        Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
                             0,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,   // security attributes
                             OPEN_EXISTING,
                             0,      // flags & attributes
                             NULL);  // template file
        if (Handle == INVALID_HANDLE_VALUE) {
            return GetLastError();
        }
    }

    return NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
// Generic interface-related functions
//////////////////////////////////////////////////////////////////////////////

IPV6_INFO_INTERFACE *
GetInterfaceByIpv6IfIndex(
    IN DWORD dwIfIndex
    )
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    DWORD dwInfoSize, dwBytesReturned;

    Query.Index = dwIfIndex;

    dwInfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(dwInfoSize);
    if (IF == NULL) {
        return NULL;
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_INTERFACE,
                         &Query, sizeof Query,
                         IF, dwInfoSize, &dwBytesReturned,
                         NULL)) {
        FREE(IF);
        return NULL;
    }

    if ((dwBytesReturned < sizeof *IF) ||
        (IF->Length < sizeof *IF) ||
        (dwBytesReturned != IF->Length +
         ((IF->LocalLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0) +
         ((IF->RemoteLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0))) {

        FREE(IF);
        return NULL;
    }

    return IF;
}

BOOL
ConvertAdapterNameToGuid(
    IN LPSTR AdapterName,
    OUT GUID *Guid
    )
{
    WCHAR GuidStr[40+1];
    UNICODE_STRING UGuidStr;

    if (MultiByteToWideChar(CP_ACP, 0, AdapterName, -1, GuidStr, 40) == 0) {
        return FALSE;
    }

    RtlInitUnicodeString(&UGuidStr, GuidStr);
    return RtlGUIDFromString(&UGuidStr, Guid) == STATUS_SUCCESS;
}

IPV6_INFO_INTERFACE *
GetPersistentInterfaceByGuid(
    IN LPSTR AdapterName
    )
{
    IPV6_PERSISTENT_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    DWORD dwInfoSize, dwBytesReturned;

    Query.RegistryIndex = (u_int)-1;
    if (!ConvertAdapterNameToGuid(AdapterName, &Query.Guid)) {
        return NULL;
    }

    dwInfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(dwInfoSize);
    if (IF == NULL) {
        return NULL;
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE,
                         &Query, sizeof Query,
                         IF, dwInfoSize, &dwBytesReturned,
                         NULL)) {
        FREE(IF);
        return NULL;
    }

    if ((dwBytesReturned < sizeof *IF) ||
        (IF->Length < sizeof *IF) ||
        (dwBytesReturned != IF->Length +
         ((IF->LocalLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0) +
         ((IF->RemoteLinkLayerAddress != 0) ?
          IF->LinkLayerAddressLength : 0))) {

        FREE(IF);
        return NULL;
    }

    return IF;
}

DWORD
GetInterfaceByFriendlyName(
    IN PWCHAR pwszFriendlyName,
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo,
    IN BOOL bPersistent,
    OUT IPV6_INFO_INTERFACE **pIF
    )
{
    DWORD dwErr;

    if (bPersistent) {
        LPSTR AdapterName;

        dwErr = MapFriendlyNameToAdapterName(NULL, pwszFriendlyName, 
                                             pAdapterInfo, &AdapterName); 
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        *pIF = GetPersistentInterfaceByGuid(AdapterName);
    } else {
        UINT IfIndex;

        dwErr = MapFriendlyNameToIpv6IfIndex(pwszFriendlyName, pAdapterInfo,
                                             &IfIndex);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    
        *pIF = GetInterfaceByIpv6IfIndex(IfIndex);
    }

    return (*pIF)? NO_ERROR : ERROR_NOT_FOUND;
}

DWORD
MyGetAdaptersInfo(
    OUT PIP_ADAPTER_ADDRESSES *ppAdapterInfo
    )
{
    IP_ADAPTER_ADDRESSES *pAdapterInfo;
    DWORD dwErr, BufLen = 0;
    DWORD Flags = GAA_FLAG_SKIP_MULTICAST;

    dwErr = GetAdaptersAddresses(AF_INET6, Flags, NULL, NULL, &BufLen);
    if (dwErr != ERROR_BUFFER_OVERFLOW) {
        return dwErr;
    }
    pAdapterInfo = (IP_ADAPTER_ADDRESSES *) MALLOC(BufLen);
    if (pAdapterInfo == NULL) {
        return GetLastError();
    }
    dwErr = GetAdaptersAddresses(AF_INET6, Flags, NULL, pAdapterInfo, &BufLen);
    if (dwErr != NO_ERROR) {
        FREE(pAdapterInfo);
        return dwErr;
    }

    *ppAdapterInfo = pAdapterInfo;
    return NO_ERROR;
}

DWORD
ForEachPersistentInterface(
    IN DWORD (*pfnFunc)(IPV6_INFO_INTERFACE *,PIP_ADAPTER_ADDRESSES,DWORD,FORMAT,BOOL),
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format
    )
{
    IPV6_PERSISTENT_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    DWORD dwInfoSize, dwBytesReturned;
    DWORD dwCount = 0;

    dwInfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(dwInfoSize);
    if (IF == NULL) {
        return 0;
    }

    for (Query.RegistryIndex = 0; ; Query.RegistryIndex++) {
        if (!DeviceIoControl(Handle, 
                             IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, dwInfoSize, &dwBytesReturned,
                             NULL)) {
            break;
        }


        if ((dwBytesReturned < sizeof *IF) ||
            (IF->Length < sizeof *IF) ||
            (dwBytesReturned != IF->Length +
             ((IF->LocalLinkLayerAddress != 0) ?
              IF->LinkLayerAddressLength : 0) +
             ((IF->RemoteLinkLayerAddress != 0) ?
              IF->LinkLayerAddressLength : 0))) {

            break;
        }

        if ((*pfnFunc)(IF, pAdapterInfo, dwCount, Format, TRUE) == NO_ERROR) {
            dwCount++;
        }
    }

    FREE(IF);

    return dwCount;
}

DWORD
ForEachInterface(
    IN DWORD (*pfnFunc)(IPV6_INFO_INTERFACE *,PIP_ADAPTER_ADDRESSES,DWORD,FORMAT,BOOL),
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_INTERFACE Query;
    IPV6_INFO_INTERFACE *IF;
    DWORD dwInfoSize, dwBytesReturned;
    DWORD dwCount = 0;

    if (bPersistent) {
        return ForEachPersistentInterface(pfnFunc, pAdapterInfo, Format);
    }

    dwInfoSize = sizeof *IF + 2 * MAX_LINK_LAYER_ADDRESS_LENGTH;
    IF = (IPV6_INFO_INTERFACE *) MALLOC(dwInfoSize);
    if (IF == NULL) {
        return 0;
    }

    Query.Index = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, 
                             IOCTL_IPV6_QUERY_INTERFACE,
                             &Query, sizeof Query,
                             IF, dwInfoSize, &dwBytesReturned,
                             NULL)) {
            break;
        }

        if (Query.Index != (u_int) -1) {

            if ((dwBytesReturned < sizeof *IF) ||
                (IF->Length < sizeof *IF) ||
                (dwBytesReturned != IF->Length +
                 ((IF->LocalLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0) +
                 ((IF->RemoteLinkLayerAddress != 0) ?
                  IF->LinkLayerAddressLength : 0))) {

                break;
            }

            if ((*pfnFunc)(IF, pAdapterInfo, dwCount, Format, FALSE) == 
                NO_ERROR) {
                dwCount++;
            }
        }
        else {
            if (dwBytesReturned != sizeof IF->Next) {
                break;
            }
        }

        if (IF->Next.Index == (u_int) -1)
            break;
        Query = IF->Next;
    }

    FREE(IF);

    return dwCount;
}


//////////////////////////////////////////////////////////////////////////////
// Site prefix table functions
//////////////////////////////////////////////////////////////////////////////

DWORD
ForEachSitePrefix(
    IN DWORD (*pfnFunc)(IPV6_INFO_SITE_PREFIX *,FORMAT,DWORD,IP_ADAPTER_ADDRESSES *), 
    IN FORMAT Format,
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo
    )
{
    IPV6_QUERY_SITE_PREFIX Query, NextQuery;
    IPV6_INFO_SITE_PREFIX SPE;
    DWORD dwBytesReturned;
    DWORD dwCount = 0;

    NextQuery.IF.Index = 0;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_SITE_PREFIX,
                             &Query, sizeof Query,
                             &SPE, sizeof SPE, &dwBytesReturned,
                             NULL)) {
            break;
        }

        NextQuery = SPE.Query;

        if (Query.IF.Index != 0) {

            SPE.Query = Query;
            if ((*pfnFunc)(&SPE, Format, dwCount, pAdapterInfo) == NO_ERROR) {
                dwCount++;
            }
        }

        if (NextQuery.IF.Index == 0) {
            break;
        }
    }

    return dwCount;
}

DWORD
PrintSitePrefix(
    IN IPV6_INFO_SITE_PREFIX *SPE, 
    IN FORMAT Format,
    IN DWORD dwCount,
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo
    )
{
    DWORD dwErr;
    WCHAR *FriendlyName;
    WCHAR wszValid[64];
    
    dwErr = MapIpv6IfIndexToFriendlyName(SPE->Query.IF.Index, pAdapterInfo,
                                         &FriendlyName);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    FormatTime(SPE->ValidLifetime, wszValid);
    
    if (Format == FORMAT_DUMP) {
        DisplayMessageT(DMP_IPV6_ADD_SITEPREFIX);
        DisplayMessageT(DMP_STRING_ARG, TOKEN_PREFIX,
                       FormatIPv6Prefix(&SPE->Query.Prefix, 
                                        SPE->Query.PrefixLength));
        DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                        FriendlyName);
        DisplayMessageT(DMP_STRING_ARG, TOKEN_LIFETIME, wszValid);
        DisplayMessage(g_hModule, MSG_NEWLINE);
    } else {
        if (!dwCount) {
            DisplayMessage(g_hModule, MSG_IPV6_SITE_PREFIX_HDR);
        }

        DisplayMessage(g_hModule, MSG_IPV6_SITE_PREFIX,
            FormatIPv6Prefix(&SPE->Query.Prefix, SPE->Query.PrefixLength),
            wszValid, FriendlyName);
    }

    return NO_ERROR;
}

DWORD
QuerySitePrefixTable(
    IN FORMAT Format
    )
{
    DWORD dwErr, dwCount = 0;
    IP_ADAPTER_ADDRESSES *pAdapterInfo;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != ERROR_NO_DATA) {
        if (dwErr == NO_ERROR) {
            dwCount = ForEachSitePrefix(PrintSitePrefix, Format, pAdapterInfo);
            FREE(pAdapterInfo);
        } else if (dwErr == ERROR_NO_DATA) {
            dwErr = NO_ERROR;
        }
    }
    if (!dwCount && (Format != FORMAT_DUMP)) {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// General global parameters functions
//////////////////////////////////////////////////////////////////////////////

DWORD
QueryGlobalParameters(
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_GLOBAL_PARAMETERS Params;
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    if (!DeviceIoControl(Handle, 
                         (bPersistent)? IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS : IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS,
                         NULL, 0,
                         &Params, sizeof Params, &dwBytesReturned, NULL) ||
        (dwBytesReturned != sizeof Params)) {
        return GetLastError(); 
    }

    if (Format == FORMAT_DUMP) {
        if ((Params.DefaultCurHopLimit != -1) ||
            (Params.NeighborCacheLimit != -1) ||
            (Params.RouteCacheLimit != -1) ||
            (Params.ReassemblyLimit != -1)) {

            DisplayMessageT(DMP_IPV6_SET_GLOBAL);
            if (Params.DefaultCurHopLimit != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_DEFAULTCURHOPLIMIT,
                                Params.DefaultCurHopLimit);
            }
            if (Params.NeighborCacheLimit != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_NEIGHBORCACHELIMIT,
                                Params.NeighborCacheLimit);
            }
            if (Params.RouteCacheLimit != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_DESTINATIONCACHELIMIT,
                                Params.RouteCacheLimit);
            }
            if (Params.ReassemblyLimit != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_REASSEMBLYLIMIT,
                                Params.ReassemblyLimit);
            }
        }
        DisplayMessage(g_hModule, MSG_NEWLINE);
    } else {
        DisplayMessage(g_hModule, MSG_IPV6_GLOBAL_PARAMETERS, 
                       Params.DefaultCurHopLimit, Params.NeighborCacheLimit, 
                       Params.RouteCacheLimit, Params.ReassemblyLimit);
    }

    return NO_ERROR;
}

DWORD
QueryPrivacyParameters(
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_GLOBAL_PARAMETERS Params;
    DWORD dwBytesReturned, dwErr;
    WCHAR wszValid[64], wszPreferred[64], wszRegenerate[64];
    WCHAR wszMaxRandom[64], wszRandom[64];
        

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    if (!DeviceIoControl(Handle, 
                         (bPersistent)? IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS : IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS,
                         NULL, 0,
                         &Params, sizeof Params, &dwBytesReturned, NULL) ||
        (dwBytesReturned != sizeof Params)) {
        return GetLastError();
    }

    FormatTime(Params.MaxTempValidLifetime, wszValid);
    FormatTime(Params.MaxTempPreferredLifetime, wszPreferred);
    FormatTime(Params.TempRegenerateTime, wszRegenerate);
    FormatTime(Params.MaxTempRandomTime, wszMaxRandom);
    FormatTime(Params.TempRandomTime, wszRandom);
    
    if (Format == FORMAT_DUMP) {
        if ((Params.UseTemporaryAddresses != -1) ||
            (Params.MaxTempDADAttempts != -1) ||
            (Params.MaxTempValidLifetime != -1) ||
            (Params.MaxTempPreferredLifetime != -1) ||
            (Params.TempRegenerateTime != -1) ||
            (Params.MaxTempRandomTime != -1)) {

            DisplayMessageT(DMP_IPV6_SET_PRIVACY);
            if (Params.UseTemporaryAddresses != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_STATE,
                                ((Params.UseTemporaryAddresses == USE_TEMP_NO)?
                                TOKEN_VALUE_DISABLED : TOKEN_VALUE_ENABLED));
            }
            if (Params.MaxTempDADAttempts != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_MAXDADATTEMPTS,
                                Params.MaxTempDADAttempts);
            }
            if (Params.MaxTempValidLifetime != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_MAXVALIDLIFETIME, 
                                wszValid);
            }
            if (Params.MaxTempPreferredLifetime != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_MAXPREFERREDLIFETIME, 
                                wszPreferred);
            }
            if (Params.TempRegenerateTime != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_REGENERATETIME, 
                                wszRegenerate);
            }
            if (Params.MaxTempRandomTime != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_MAXRANDOMTIME, 
                                wszMaxRandom);
            }
        DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(
            g_hModule, MSG_IPV6_PRIVACY_PARAMETERS,
            ((Params.UseTemporaryAddresses == USE_TEMP_NO)
             ? TOKEN_VALUE_DISABLED
             : TOKEN_VALUE_ENABLED),
            Params.MaxTempDADAttempts,
            wszValid,
            wszPreferred,
            wszRegenerate,
            wszMaxRandom,
            wszRandom);
    }

    return NO_ERROR;
}

DWORD
UpdateGlobalParameters(
    IN DWORD dwDefaultCurHopLimit, 
    IN DWORD dwNeighborCacheLimit,
    IN DWORD dwRouteCacheLimit,
    IN DWORD dwReassemblyLimit,
    IN BOOL bPersistent
    )
{
    IPV6_GLOBAL_PARAMETERS Params;
    DWORD dwBytesReturned;
    DWORD dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    IPV6_INIT_GLOBAL_PARAMETERS(&Params); 
    Params.DefaultCurHopLimit = dwDefaultCurHopLimit;
    Params.NeighborCacheLimit = dwNeighborCacheLimit;
    Params.RouteCacheLimit = dwRouteCacheLimit;
    Params.ReassemblyLimit = dwReassemblyLimit;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS,
                             &Params, sizeof Params,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS,
                         &Params, sizeof Params,
                         NULL, 0,
                         &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

DWORD 
UpdatePrivacyParameters(
    IN DWORD dwUseTemporaryAddresses,
    IN DWORD dwMaxDadAttempts,
    IN DWORD dwMaxValidLifetime,
    IN DWORD dwMaxPrefLifetime,
    IN DWORD dwRegenerateTime,
    IN DWORD dwMaxRandomTime,
    IN DWORD dwRandomTime,
    IN BOOL bPersistent
    )
{
    IPV6_GLOBAL_PARAMETERS Params;
    DWORD dwBytesReturned;
    DWORD dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    IPV6_INIT_GLOBAL_PARAMETERS(&Params);
    Params.UseTemporaryAddresses = dwUseTemporaryAddresses;
    Params.MaxTempDADAttempts = dwMaxDadAttempts;
    Params.MaxTempValidLifetime = dwMaxValidLifetime;
    Params.MaxTempPreferredLifetime = dwMaxPrefLifetime;
    Params.TempRegenerateTime = dwRegenerateTime;
    Params.MaxTempRandomTime = dwMaxRandomTime;
    Params.TempRandomTime = dwRandomTime;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS,
                             &Params, sizeof Params,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS,
                         &Params, sizeof Params,
                         NULL, 0,
                         &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// Mobility-related functions
//////////////////////////////////////////////////////////////////////////////

DWORD
ForEachBinding(
    IN DWORD (*pfnFunc)(IPV6_INFO_BINDING_CACHE *)
    )
{
    IPV6_QUERY_BINDING_CACHE Query, NextQuery;
    IPV6_INFO_BINDING_CACHE BCE;
    DWORD dwBytesReturned;
    DWORD dwCount = 0;

    NextQuery.HomeAddress = in6addr_any;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_BINDING_CACHE,
                             &Query, sizeof Query,
                             &BCE, sizeof BCE, &dwBytesReturned,
                             NULL)) {
            DisplayMessage(g_hModule, IPV6_MESSAGE_126,
                      FormatIPv6Address(&Query.HomeAddress, 0));
            break;
        }

        NextQuery = BCE.Query;

        if (!IN6_ADDR_EQUAL(&Query.HomeAddress, &in6addr_any)) {
            BCE.Query = Query;
            if ((*pfnFunc)(&BCE) == NO_ERROR) {
                dwCount++;
            }
        }

        if (IN6_ADDR_EQUAL(&NextQuery.HomeAddress, &in6addr_any)) {
            break;
        }
    }

    return dwCount;
}

DWORD
PrintBindingCacheEntry(
    IN IPV6_INFO_BINDING_CACHE *BCE
    )
{
    WCHAR wszTime[64];
    
    DisplayMessage(g_hModule, IPV6_MESSAGE_127,
              FormatIPv6Address(&BCE->HomeAddress, 0));

    DisplayMessage(g_hModule, IPV6_MESSAGE_128,
              FormatIPv6Address(&BCE->CareOfAddress, 0));

    DisplayMessage(g_hModule, IPV6_MESSAGE_129,
              BCE->BindingSeqNumber,
              FormatTime(BCE->BindingLifetime, wszTime));

    
    return NO_ERROR;
}

DWORD
QueryBindingCache(
    VOID
    )
{
    DWORD dwCount, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwCount = ForEachBinding(PrintBindingCacheEntry);

    if (dwCount == 0) {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
    }

    return NO_ERROR;
}

DWORD
QueryMobilityParameters(
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_GLOBAL_PARAMETERS Params;
    DWORD dwBytesReturned, dwErr;
    PWCHAR pwszTempString;
    PWCHAR pwszCNStateString;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    if (!DeviceIoControl(Handle,
                         (bPersistent)? IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS : IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS,
                         NULL, 0,
                         &Params, sizeof Params, &dwBytesReturned, NULL) ||
        (dwBytesReturned != sizeof Params)) {
        return GetLastError();
    }

    pwszTempString = Params.MobilitySecurity ?
            TOKEN_VALUE_ENABLED : TOKEN_VALUE_DISABLED;
    pwszCNStateString = (Params.MobileIPv6Mode & MOBILE_CORRESPONDENT)?
            TOKEN_VALUE_ENABLED : TOKEN_VALUE_DISABLED;

    if (Format == FORMAT_DUMP) {
        if ((Params.MobilitySecurity != -1) ||
            (Params.BindingCacheLimit != -1) ||
            (Params.MobileIPv6Mode != -1)) {

            DisplayMessageT(DMP_IPV6_SET_MOBILITY);
            if (Params.MobilitySecurity != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_SECURITY, pwszTempString);
            }
            if (Params.BindingCacheLimit != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_BINDINGCACHELIMIT, 
                                Params.BindingCacheLimit);
            }
            if (Params.MobileIPv6Mode != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_CNSTATE, 
                                pwszCNStateString);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(g_hModule, MSG_IPV6_MOBILITY_PARAMETERS, pwszTempString,
                       Params.BindingCacheLimit, pwszCNStateString);
    }

    return NO_ERROR;
}

DWORD
UpdateMobilityParameters(
    IN DWORD dwSecurity,
    IN DWORD dwBindingCacheLimit,
    IN DWORD dwMode,
    IN BOOL bPersistent
    )
{
    DWORD dwBytesReturned;
    DWORD dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = ERROR_OKAY;

    if ((dwBindingCacheLimit != -1) ||
        (dwSecurity != -1) ||
        (dwMode != -1)) {
        IPV6_GLOBAL_PARAMETERS Params;

        IPV6_INIT_GLOBAL_PARAMETERS(&Params);
        Params.BindingCacheLimit = dwBindingCacheLimit;
        Params.MobilitySecurity = dwSecurity;
        Params.MobileIPv6Mode = dwMode;

        if (bPersistent) {
            if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS,
                                 &Params, sizeof Params,
                                 NULL, 0,
                                 &dwBytesReturned, NULL)) {
                dwErr = GetLastError();
            }
        }

        if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS,
                             &Params, sizeof Params,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            if (dwErr == ERROR_OKAY) {
                dwErr = GetLastError();
            }
        }
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// Prefix policy table functions
//////////////////////////////////////////////////////////////////////////////

DWORD
ForEachPrefixPolicy(
    IN DWORD (*pfnFunc)(IPV6_INFO_PREFIX_POLICY *,FORMAT,DWORD), 
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_PREFIX_POLICY Query;
    IPV6_INFO_PREFIX_POLICY PPE;
    DWORD dwBytesReturned, dwCount = 0;

    Query.PrefixLength = (u_int) -1;

    for (;;) {
        if (!DeviceIoControl(Handle, 
                             (bPersistent)? IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY : IOCTL_IPV6_QUERY_PREFIX_POLICY,
                             &Query, sizeof Query,
                             &PPE, sizeof PPE, &dwBytesReturned,
                             NULL)) {
            break;
        }

        if (Query.PrefixLength != (u_int) -1) {

            if (dwBytesReturned != sizeof PPE)
                break;

            if ((*pfnFunc)(&PPE, Format, dwCount) == NO_ERROR) {
                dwCount++;
            }
        }
        else {
            if (dwBytesReturned != sizeof PPE.Next)
                break;
        }

        if (PPE.Next.PrefixLength == (u_int) -1)
            break;
        Query = PPE.Next;
    }

    return dwCount;
}

DWORD
PrintPrefixPolicyEntry(
    IN IPV6_INFO_PREFIX_POLICY *PPE, 
    IN FORMAT Format, 
    IN DWORD dwCount
    )
{
    if (Format == FORMAT_DUMP) {
        DisplayMessageT(DMP_IPV6_ADD_PREFIXPOLICY);
        DisplayMessageT(DMP_STRING_ARG, TOKEN_PREFIX,
                       FormatIPv6Prefix(&PPE->This.Prefix, 
                                        PPE->This.PrefixLength));
        DisplayMessageT(DMP_INTEGER_ARG, TOKEN_PRECEDENCE,
                        PPE->Precedence);
        DisplayMessageT(DMP_INTEGER_ARG, TOKEN_LABEL,
                        PPE->SrcLabel);
        DisplayMessage(g_hModule, MSG_NEWLINE);
    } else {
        if (!dwCount) {
            DisplayMessage(g_hModule, MSG_IPV6_PREFIX_POLICY_HDR);
        }

        DisplayMessage(g_hModule, MSG_IPV6_PREFIX_POLICY,
                       FormatIPv6Prefix(&PPE->This.Prefix,
                                        PPE->This.PrefixLength),
                       PPE->Precedence,
                       PPE->SrcLabel,
                       PPE->DstLabel);
    }

    return NO_ERROR;
}

DWORD
QueryPrefixPolicy(
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount, dwErr;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    dwCount = ForEachPrefixPolicy(PrintPrefixPolicyEntry, Format, bPersistent);

    if (!dwCount && (Format != FORMAT_DUMP)) {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
    }

    return NO_ERROR;
}

DWORD
UpdatePrefixPolicy(
    IN IN6_ADDR *IpAddress, 
    IN DWORD dwPrefixLength, 
    IN DWORD dwPrecedence, 
    IN DWORD dwLabel,
    IN BOOL bPersistent
    )
{
    IPV6_INFO_PREFIX_POLICY Info;
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    Info.This.Prefix = *IpAddress;
    Info.This.PrefixLength = dwPrefixLength;
    Info.Precedence = dwPrecedence;
    Info.SrcLabel = Info.DstLabel = dwLabel;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_PREFIX_POLICY,
                             &Info, sizeof Info,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_PREFIX_POLICY,
                         &Info, sizeof Info,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

DWORD
DeletePrefixPolicy(
    IN IN6_ADDR *IpAddress,
    IN DWORD dwPrefixLength,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_PREFIX_POLICY Query;
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    Query.Prefix = *IpAddress;
    Query.PrefixLength = dwPrefixLength;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_DELETE_PREFIX_POLICY,
                             &Query, sizeof Query,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_DELETE_PREFIX_POLICY,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// Address table functions
//////////////////////////////////////////////////////////////////////////////

DWORD
ForEachAddress(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD (*pfnFunc)(IPV6_INFO_INTERFACE *IF, PIP_ADAPTER_ADDRESSES, FORMAT, DWORD, IPV6_INFO_ADDRESS *))
{
    IPV6_QUERY_ADDRESS Query;
    IPV6_INFO_ADDRESS ADE;
    DWORD BytesReturned, dwCount = 0;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    for (;;) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL)) {
            break;
        }

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if (BytesReturned != sizeof ADE)
                break;

            if ((*pfnFunc)(IF, pAdapterInfo, Format, dwCount, &ADE) == NO_ERROR) {
                dwCount++;
            }
        }
        else {
            if (BytesReturned != sizeof ADE.Next)
                break;
        }

        if (IN6_ADDR_EQUAL(&ADE.Next.Address, &in6addr_any))
            break;
        Query = ADE.Next;
    }

    return dwCount;
}

DWORD
ForEachPersistentAddress(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD (*pfnFunc)(IPV6_INFO_INTERFACE *IF, PIP_ADAPTER_ADDRESSES, FORMAT, DWORD, IPV6_UPDATE_ADDRESS *))
{
    IPV6_PERSISTENT_QUERY_ADDRESS Query;
    IPV6_UPDATE_ADDRESS ADE;
    DWORD BytesReturned, dwCount = 0;

    Query.IF.RegistryIndex = (u_int) -1;
    Query.IF.Guid = IF->This.Guid;

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle, 
                             IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS,
                             &Query, sizeof Query,
                             &ADE, sizeof ADE, &BytesReturned,
                             NULL) ||
            (BytesReturned != sizeof ADE)) {
            break;
        }

        if ((*pfnFunc)(IF, pAdapterInfo, Format, dwCount, &ADE) == NO_ERROR) {
            dwCount++;
        }
    }

    return dwCount;
}

PWCHAR
GetDadState(
    IN DWORD dwDadState,
    OUT BOOL *bDynamic
    )
{
    PWCHAR pwszTemp;
    DWORD dwMsg = 0;
    static WCHAR wszDadState[128];

    switch (dwDadState) {
    case DAD_STATE_INVALID: 
        dwMsg = STRING_INVALID; 
        break;
    case DAD_STATE_DUPLICATE: 
        dwMsg = STRING_DUPLICATE; 
        break;
    case DAD_STATE_TENTATIVE: 
        dwMsg = STRING_TENTATIVE; 
        break;
    case DAD_STATE_DEPRECATED: 
        dwMsg = STRING_DEPRECATED; 
        break;
    case DAD_STATE_PREFERRED: 
        dwMsg = STRING_PREFERRED; 
        break;
    default:
        swprintf(wszDadState, L"%u", dwDadState);
        *bDynamic = FALSE;
        return wszDadState;
    }

    *bDynamic = TRUE;
    pwszTemp = MakeString(g_hModule, dwMsg);
    return pwszTemp;
}

PWCHAR
GetAddressType(
    IN DWORD dwScope,
    IN DWORD dwPrefixConf,
    IN DWORD dwIidConf
    )
{
    DWORD dwMsg = 0;

    if ((dwScope == ADE_LINK_LOCAL) &&
        (dwPrefixConf == PREFIX_CONF_WELLKNOWN) &&
        (dwIidConf == IID_CONF_WELLKNOWN)) {

        dwMsg = STRING_LOOPBACK;

    } else if ((dwScope == ADE_LINK_LOCAL) &&
               (dwPrefixConf == PREFIX_CONF_WELLKNOWN) &&
               (dwIidConf == IID_CONF_LL_ADDRESS)) {
    
        dwMsg = STRING_LINK;

    } else if ((dwPrefixConf == PREFIX_CONF_MANUAL) &&
               (dwIidConf == IID_CONF_MANUAL)) {

        dwMsg = STRING_MANUAL;

    } else if ((dwPrefixConf == PREFIX_CONF_RA) &&
               (dwIidConf == IID_CONF_LL_ADDRESS)) {

        dwMsg = STRING_PUBLIC;

    } else if ((dwPrefixConf == PREFIX_CONF_RA) &&
        (dwIidConf == IID_CONF_RANDOM)) {

        dwMsg = STRING_TEMPORARY;

    } else if ((dwPrefixConf == PREFIX_CONF_DHCP) &&
               (dwIidConf == IID_CONF_DHCP)) {

        dwMsg = STRING_DHCP;
    } else {
        dwMsg = STRING_OTHER;
    }

    return MakeString(g_hModule, dwMsg);
}

PWCHAR
GetScopeNoun(
    IN DWORD dwScope,
    OUT BOOL *bDynamic
    )
{
    PWCHAR pwszTemp;
    DWORD dwMsg = 0;
    static WCHAR wszScopeLevel[128];

    switch (dwScope) {
    case ADE_INTERFACE_LOCAL: 
        dwMsg = STRING_INTERFACE; 
        break;
    case ADE_LINK_LOCAL:
        dwMsg = STRING_LINK;
        break;
    case ADE_SUBNET_LOCAL:
        dwMsg = STRING_SUBNET;
        break;
    case ADE_ADMIN_LOCAL:
        dwMsg = STRING_ADMIN;
        break;
    case ADE_SITE_LOCAL:
        dwMsg = STRING_SITE;
        break;
    case ADE_ORG_LOCAL:
        dwMsg = STRING_ORG;
        break;
    case ADE_GLOBAL:
        dwMsg = STRING_GLOBAL;
        break;
    default:
        swprintf(wszScopeLevel, L"%u", dwScope);
        *bDynamic = FALSE;
        return wszScopeLevel;
    }

    *bDynamic = TRUE;
    pwszTemp = MakeString(g_hModule, dwMsg);
    return pwszTemp;
}

DWORD rgdwPrefixConfMsg[] = {
    0,
    STRING_MANUAL,
    STRING_WELLKNOWN,
    STRING_DHCP,
    STRING_RA
    };
#define PREFIX_CONF_MSG_COUNT (sizeof(rgdwPrefixConfMsg)/sizeof(DWORD))

DWORD rgdwIidConfMsg[] = {
    0,
    STRING_MANUAL,
    STRING_WELLKNOWN,
    STRING_DHCP,
    STRING_LL_ADDRESS,
    STRING_RANDOM
    };
#define IID_CONF_MSG_COUNT (sizeof(rgdwIidConfMsg)/sizeof(DWORD))

DWORD
PrintMulticastAddress(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD dwCount,
    IN IPV6_INFO_ADDRESS *ADE
    )
{
    BOOL bDynamicScope;
    PWCHAR pwszScope, pwszFriendlyName;
    DWORD dwErr = NO_ERROR;
    PWCHAR pwszLastReporter, pwszNever;
    WCHAR wszTime[64];    

    if (ADE->Type != ADE_MULTICAST) {
        return ERROR_NO_DATA;
    }

    if (dwCount == 0) {
        dwErr = MapIpv6IfIndexToFriendlyName(IF->This.Index, pAdapterInfo,
                                             &pwszFriendlyName);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        DisplayMessage(g_hModule, 
                       (Format == FORMAT_VERBOSE)? MSG_IPV6_ADDRESS_HDR_VERBOSE : MSG_IPV6_MULTICAST_ADDRESS_HDR, 
                       IF->This.Index, pwszFriendlyName);
    }

    pwszScope = GetScopeNoun(ADE->Scope, &bDynamicScope);

    pwszNever = MakeString(g_hModule, STRING_NEVER);
    pwszLastReporter = MakeString(g_hModule, (ADE->MCastFlags & 0x02)? STRING_YES : STRING_NO);

    DisplayMessage(g_hModule,
                   ((Format == FORMAT_VERBOSE)
                    ? MSG_IPV6_MULTICAST_ADDRESS_VERBOSE
                    : MSG_IPV6_MULTICAST_ADDRESS),
                   pwszScope,
                   FormatIPv6Address(&ADE->This.Address, 0),
                   ADE->MCastRefCount,
                   (ADE->MCastFlags & 0x01)
                   ? FormatTime(ADE->MCastTimer, wszTime)
                   : pwszNever,
                   pwszLastReporter);

    FreeString(pwszLastReporter);
    FreeString(pwszNever);

    if (bDynamicScope) {
        FreeString(pwszScope);
    }

    return dwErr;
}

DWORD
PrintAddress(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD dwCount,
    IN IPV6_INFO_ADDRESS *ADE
    )
{
    DWORD dwPrefixConf, dwInterfaceIdConf;
    BOOL bDynamicDadState, bDynamicScope;
    PWCHAR pwszDadState, pwszScope, pwszFriendlyName, pwszType;
    WCHAR wszValid[64], wszPreferred[64];
    DWORD dwErr = NO_ERROR;

    if (Format != FORMAT_VERBOSE) {
        //
        // Suppress invalid addresses.
        //
        if ((ADE->Type == ADE_UNICAST) &&
            (ADE->DADState == DAD_STATE_INVALID)) {
            return ERROR_NO_DATA;
        }

        //
        // Multicast addresses are handled by PrintMulticastAddress()
        // instead.
        //
        if (ADE->Type == ADE_MULTICAST) {
            return ERROR_NO_DATA;
        }
    }

    if (dwCount == 0) {
        if (IF->This.Index == 0) {
            dwErr = MapGuidToFriendlyName(NULL, &IF->This.Guid, pAdapterInfo, 
                                          &pwszFriendlyName);
        } else {
            dwErr = MapIpv6IfIndexToFriendlyName(IF->This.Index, pAdapterInfo,
                                                 &pwszFriendlyName);
        }
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_ADDRESS_HDR_VERBOSE : MSG_IPV6_ADDRESS_HDR),
                       IF->This.Index, pwszFriendlyName);
    }

    pwszScope = GetScopeNoun(ADE->Scope, &bDynamicScope);

    switch (ADE->Type) {
    case ADE_UNICAST:

        pwszDadState = GetDadState(ADE->DADState, &bDynamicDadState);

        pwszType = GetAddressType(ADE->Scope, ADE->PrefixConf, ADE->InterfaceIdConf);

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_UNICAST_ADDRESS_VERBOSE : MSG_IPV6_UNICAST_ADDRESS),
                       pwszType,
                       pwszDadState,
                       FormatIPv6Address(&ADE->This.Address, 0),
                       FormatTime(ADE->ValidLifetime, wszValid),
                       FormatTime(ADE->PreferredLifetime, wszPreferred),
                       pwszScope);

        if (bDynamicDadState) {
            FreeString(pwszDadState);
        }
        FreeString(pwszType);

        if (Format == FORMAT_VERBOSE) {
            //
            // Show prefix origin / interface id origin
            //
            DisplayMessage(g_hModule, MSG_IPV6_PREFIX_ORIGIN);

            dwPrefixConf = ADE->PrefixConf;
            if ((dwPrefixConf == PREFIX_CONF_OTHER) || 
                (dwPrefixConf >= PREFIX_CONF_MSG_COUNT)) {

                DisplayMessage(g_hModule, MSG_IPV6_INTEGER, dwPrefixConf);
            } else {
                DisplayMessage(g_hModule, rgdwPrefixConfMsg[dwPrefixConf]);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);

            DisplayMessage(g_hModule, MSG_IPV6_IID_ORIGIN);
            dwInterfaceIdConf = ADE->InterfaceIdConf;
            if ((dwInterfaceIdConf == IID_CONF_OTHER) ||
                (dwInterfaceIdConf >= IID_CONF_MSG_COUNT)) {

                DisplayMessage(g_hModule, MSG_IPV6_INTEGER, dwInterfaceIdConf);
            } else {
                DisplayMessage(g_hModule, rgdwIidConfMsg[dwInterfaceIdConf]);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }

        break;

    case ADE_ANYCAST:
        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_ANYCAST_ADDRESS_VERBOSE : MSG_IPV6_ANYCAST_ADDRESS),
                       FormatIPv6Address(&ADE->This.Address, 0),
                       pwszScope);

        break;

    case ADE_MULTICAST:
    default:
        dwErr = ERROR_NO_DATA;
        break;
    }

    if (bDynamicScope) {
        FreeString(pwszScope);
    }

    return dwErr;
}

DWORD
PrintPersistentAddress(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD dwCount,
    IN IPV6_UPDATE_ADDRESS *ADE
    )
{
    DWORD dwPrefixConf, dwInterfaceIdConf;
    BOOL bDynamicDadState, bDynamicScope;
    PWCHAR pwszDadState, pwszScope, pwszFriendlyName = NULL, pwszType;
    WCHAR wszValid[64], wszPreferred[64];
    DWORD dwErr = NO_ERROR, dwScope;

    if (Format != FORMAT_VERBOSE) {
        //
        // Multicast addresses are handled by PrintMulticastAddress()
        // instead.
        //
        if (ADE->Type == ADE_MULTICAST) {
            return ERROR_NO_DATA;
        }
    }

    if ((dwCount == 0) || (Format == FORMAT_DUMP)) {
        dwErr = MapGuidToFriendlyName(NULL, &IF->This.Guid, pAdapterInfo, 
                                      &pwszFriendlyName);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        if (Format != FORMAT_DUMP) {
            DisplayMessage(g_hModule, 
                           ((Format == FORMAT_VERBOSE)? 
                               MSG_IPV6_ADDRESS_HDR_VERBOSE : 
                               MSG_IPV6_ADDRESS_HDR),
                           IF->This.Index, 
                           pwszFriendlyName);
        }
    }

    if (IN6_IS_ADDR_LINKLOCAL(&ADE->This.Address)) {
        dwScope = ADE_LINK_LOCAL;
    } else if (IN6_IS_ADDR_SITELOCAL(&ADE->This.Address)) {
        dwScope = ADE_SITE_LOCAL;
    } else {
        dwScope = ADE_GLOBAL;
    }

    pwszScope = GetScopeNoun(dwScope, &bDynamicScope);

    switch (ADE->Type) {
    case ADE_UNICAST:

        FormatTime(ADE->ValidLifetime, wszValid);
        FormatTime(ADE->PreferredLifetime, wszPreferred);

        if (Format == FORMAT_DUMP) {
            DisplayMessageT(DMP_IPV6_ADD_ADDRESS);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                            pwszFriendlyName);
            DisplayMessageT(DMP_STRING_ARG, TOKEN_ADDRESS,
                            FormatIPv6Address(&ADE->This.Address, 0));
            if (ADE->ValidLifetime != INFINITE_LIFETIME) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_VALIDLIFETIME, wszValid);
            }
            if (ADE->PreferredLifetime != INFINITE_LIFETIME) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_PREFERREDLIFETIME, 
                                wszPreferred);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
            break;
        } 

        pwszDadState = GetDadState(DAD_STATE_TENTATIVE, &bDynamicDadState);

        pwszType = GetAddressType(dwScope, ADE->PrefixConf, ADE->InterfaceIdConf);

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_UNICAST_ADDRESS_VERBOSE : MSG_IPV6_UNICAST_ADDRESS),
                       pwszType,
                       pwszDadState,
                       FormatIPv6Address(&ADE->This.Address, 0),
                       wszValid,
                       wszPreferred,
                       pwszScope);

        if (bDynamicDadState) {
            FreeString(pwszDadState);
        }
        FreeString(pwszType);

        if (Format == FORMAT_VERBOSE) {
            //
            // Show prefix origin / interface id origin
            //
            DisplayMessage(g_hModule, MSG_IPV6_PREFIX_ORIGIN);

            dwPrefixConf = ADE->PrefixConf;
            if ((dwPrefixConf == PREFIX_CONF_OTHER) || 
                (dwPrefixConf >= PREFIX_CONF_MSG_COUNT)) {

                DisplayMessage(g_hModule, MSG_IPV6_INTEGER, dwPrefixConf);
            } else {
                DisplayMessage(g_hModule, rgdwPrefixConfMsg[dwPrefixConf]);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);

            DisplayMessage(g_hModule, MSG_IPV6_IID_ORIGIN);
            dwInterfaceIdConf = ADE->InterfaceIdConf;
            if ((dwInterfaceIdConf == IID_CONF_OTHER) ||
                (dwInterfaceIdConf >= IID_CONF_MSG_COUNT)) {

                DisplayMessage(g_hModule, MSG_IPV6_INTEGER, dwInterfaceIdConf);
            } else {
                DisplayMessage(g_hModule, rgdwIidConfMsg[dwInterfaceIdConf]);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }

        break;

    case ADE_ANYCAST:
        if (Format == FORMAT_DUMP) {
            DisplayMessageT(DMP_IPV6_ADD_ADDRESS);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                            pwszFriendlyName);
            DisplayMessageT(DMP_STRING_ARG, TOKEN_ADDRESS,
                            FormatIPv6Address(&ADE->This.Address, 0));
            DisplayMessageT(DMP_STRING_ARG, TOKEN_TYPE, TOKEN_VALUE_ANYCAST);
            DisplayMessage(g_hModule, MSG_NEWLINE);
            break;
        } 

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_ANYCAST_ADDRESS_VERBOSE : MSG_IPV6_ANYCAST_ADDRESS),
                       FormatIPv6Address(&ADE->This.Address, 0),
                       pwszScope);

        break;

    case ADE_MULTICAST:
    default:
        dwErr = ERROR_NO_DATA;
        break;
    }

    if (bDynamicScope) {
        FreeString(pwszScope);
    }

    return dwErr;
}

DWORD
PrintAddressTable(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwIfCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount;

    if (bPersistent) {
        dwCount = ForEachPersistentAddress(IF, pAdapterInfo, Format, 
                                           PrintPersistentAddress);
    } else {
        dwCount = ForEachAddress(IF, pAdapterInfo, Format, PrintAddress);
    }
    return (dwCount > 0)? NO_ERROR : ERROR_NO_DATA;
}

DWORD
PrintMulticastAddressTable(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwIfCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount = ForEachAddress(IF, pAdapterInfo, Format, 
                                   PrintMulticastAddress);
    return (dwCount > 0)? NO_ERROR : ERROR_NO_DATA;
}

DWORD
QueryAddressTable(
    IN PWCHAR pwszIfFriendlyName,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwErr, dwCount = 0;
    IP_ADAPTER_ADDRESSES *pAdapterInfo;
    IPV6_INFO_INTERFACE *IF;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != ERROR_NO_DATA) {
        if (dwErr == NO_ERROR) {
    
            if (pwszIfFriendlyName == NULL) {
                dwCount = ForEachInterface(PrintAddressTable, pAdapterInfo, 
                                           Format, bPersistent);
            } else {
                dwErr = GetInterfaceByFriendlyName(pwszIfFriendlyName, 
                                                   pAdapterInfo, bPersistent, 
                                                   &IF);
                if (dwErr == NO_ERROR) {
                    PrintAddressTable(IF, pAdapterInfo, 0, Format, bPersistent);
                    FREE(IF);
                }
            }

            FREE(pAdapterInfo);
        } else if (dwErr == ERROR_NO_DATA) {
            dwErr = NO_ERROR;
        }
    }
    if (!dwCount && (Format != FORMAT_DUMP)) {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
    }

    return dwErr;
}

DWORD
QueryMulticastAddressTable(
    IN PWCHAR pwszIfFriendlyName,
    IN FORMAT Format
    )
{
    DWORD dwErr;
    IP_ADAPTER_ADDRESSES *pAdapterInfo;
    IPV6_INFO_INTERFACE *IF;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != ERROR_NO_DATA) {
        if (dwErr == NO_ERROR) {
    
            if (pwszIfFriendlyName == NULL) {
                ForEachInterface(PrintMulticastAddressTable, 
                                 pAdapterInfo, Format, FALSE);
            } else {
                dwErr = GetInterfaceByFriendlyName(pwszIfFriendlyName, 
                                                   pAdapterInfo, FALSE, &IF);
                if (dwErr == NO_ERROR) {
                    dwErr = PrintMulticastAddressTable(IF, pAdapterInfo, 0, 
                                                       Format, FALSE);
                    FREE(IF);
                }
            }

            FREE(pAdapterInfo);
        } else if (dwErr == ERROR_NO_DATA) {
            dwErr = NO_ERROR;
        }
    }

    return dwErr;
}

DWORD 
UpdateAddress(
    IN PWCHAR pwszIfFriendlyName, 
    IN IN6_ADDR *pipAddress,
    IN DWORD dwType, 
    IN DWORD dwValidLifetime,
    IN DWORD dwPreferredLifetime,
    IN BOOL bPersistent
    )
{
    IPV6_UPDATE_ADDRESS Update;
    DWORD dwBytesReturned, dwErr;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszIfFriendlyName, pAdapterInfo,
                                         &Update.This.IF.Index);
    if (dwErr != NO_ERROR) {
        FREE(pAdapterInfo);
        return dwErr;
    }

    if (dwType == (DWORD)-1) {
        PIP_ADAPTER_ADDRESSES pIf;
        PIP_ADAPTER_ANYCAST_ADDRESS pAddr;

        //
        // The caller doesn't know whether the existing address is unicast 
        // or anycast, so we'll check.
        //
        for (pIf = pAdapterInfo; ; pIf = pIf->Next) {
            if (pIf->Ipv6IfIndex == Update.This.IF.Index) {
                break;
            }
        }

        dwType = ADE_UNICAST;
        for (pAddr = pIf->FirstAnycastAddress; 
             pAddr != NULL; 
             pAddr = pAddr->Next) {

            if (pAddr->Address.lpSockaddr->sa_family != AF_INET6) {
                continue;
            }
            if (IN6_ADDR_EQUAL(&((PSOCKADDR_IN6)pAddr->Address.lpSockaddr)->
                                   sin6_addr, 
                               pipAddress)) {
                dwType = ADE_ANYCAST;
                break;
            }
        }
    }

    FREE(pAdapterInfo);

    Update.This.Address = *pipAddress;
    Update.Type = dwType;
    Update.PrefixConf = PREFIX_CONF_MANUAL;
    Update.InterfaceIdConf = IID_CONF_MANUAL;
    Update.ValidLifetime = dwValidLifetime;
    Update.PreferredLifetime = dwPreferredLifetime;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_ADDRESS,
                             &Update, sizeof Update,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ADDRESS,
                         &Update, sizeof Update,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// Interface table functions
//////////////////////////////////////////////////////////////////////////////

DWORD
RenewViaReconnect(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwBytesReturned;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_RENEW_INTERFACE,
                         &IF->This, sizeof IF->This,
                         NULL, 0, &dwBytesReturned, NULL)) {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD
RenewInterface(
    IN PWCHAR wszIfFriendlyName
    )
{
    DWORD dwErr;
    BOOL PokeService = FALSE;
    
    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (wszIfFriendlyName == NULL) {
        ForEachInterface(RenewViaReconnect, NULL, FALSE, FALSE);
        PokeService = TRUE;
    } else {
        IP_ADAPTER_ADDRESSES *pAdapterInfo;

        dwErr = MyGetAdaptersInfo(&pAdapterInfo);
        if (dwErr == NO_ERROR) {
            IPV6_INFO_INTERFACE *IF;

            dwErr = GetInterfaceByFriendlyName(wszIfFriendlyName, pAdapterInfo,
                                               FALSE, &IF);
            FREE(pAdapterInfo);
            if (dwErr != NO_ERROR) {
                return dwErr;
            }
    
            dwErr = RenewViaReconnect(IF, NULL, 0, FALSE, FALSE);
            //
            // Poke the 6to4 service if it manages the interface being renewed.
            //
            PokeService = (IF->Type == IPV6_IF_TYPE_TUNNEL_6TO4) ||
                (IF->Type == IPV6_IF_TYPE_TUNNEL_TEREDO) ||
                (IF->Type == IPV6_IF_TYPE_TUNNEL_AUTO);            
            FREE(IF);
        } else if (dwErr == ERROR_NO_DATA) {
            dwErr = NO_ERROR;
        }
    }

    if (PokeService) {
        Ip6to4PokeService();
    }
    
    return dwErr;
}

DWORD dwMediaSenseMsg[] = {
    STRING_DISCONNECTED,
    STRING_RECONNECTED,
    STRING_CONNECTED,
};
#define MEDIA_SENSE_MSG_COUNT (sizeof(dwMediaSenseMsg)/sizeof(DWORD))

DWORD
PrintInterface(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    PWCHAR pwszFriendlyName, pwszTemp;
    DWORD dwErr, dwMsg, dwScope;
    WCHAR wszReachable[64], wszBaseReachable[64], wszRetransTimer[64];
    PIP_ADAPTER_ADDRESSES pIf;
    CHAR szGuid[41];
    PWCHAR pwszFirewallState;
    
    dwErr = MapGuidToFriendlyName(NULL, &IF->This.Guid, pAdapterInfo,
                                  &pwszFriendlyName);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (IF->MediaStatus < MEDIA_SENSE_MSG_COUNT) {
        dwMsg = dwMediaSenseMsg[IF->MediaStatus];
    } else {
        dwMsg = STRING_UNKNOWN;
    }

    if (IF->FirewallEnabled == -1) {
        pwszFirewallState = TOKEN_VALUE_DEFAULT;
    } else if (IF->FirewallEnabled == 0) {
        pwszFirewallState = TOKEN_VALUE_DISABLED;
    } else {
        pwszFirewallState = TOKEN_VALUE_ENABLED;
    }

    switch (Format) {
    case FORMAT_DUMP:
        switch (IF->Type) {
        case IPV6_IF_TYPE_TUNNEL_6OVER4:
            DisplayMessageT(DMP_IPV6_ADD_6OVER4TUNNEL);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                            pwszFriendlyName);
            if (IF->LocalLinkLayerAddress != 0) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_LOCALADDRESS,
                        FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (UCHAR *)IF + IF->LocalLinkLayerAddress));
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
            break;
        case IPV6_IF_TYPE_TUNNEL_V6V4:
            DisplayMessageT(DMP_IPV6_ADD_V6V4TUNNEL);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                            pwszFriendlyName);
            if (IF->LocalLinkLayerAddress != 0) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_LOCALADDRESS,
                        FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (UCHAR *)IF + IF->LocalLinkLayerAddress));
            }
            if (IF->RemoteLinkLayerAddress != 0) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_REMOTEADDRESS,
                        FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (UCHAR *)IF + IF->RemoteLinkLayerAddress));
            }
            if (IF->NeighborDiscovers) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_NEIGHBORDISCOVERY,
                                TOKEN_VALUE_ENABLED);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
            break;
        }

        if ((IF->Preference != -1) ||
            (IF->LinkMTU != 0) ||
            (IF->FirewallEnabled != -1) ||
            (IF->Forwards != -1) ||
            (IF->Advertises != -1) ||
            (IF->DefSitePrefixLength != -1)) {

            DisplayMessageT(DMP_IPV6_SET_INTERFACE);
            DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                            pwszFriendlyName);
            if (IF->Preference != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_METRIC,
                                IF->Preference);
            }
            if (IF->LinkMTU != 0) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_MTU,
                                IF->LinkMTU);
            }
            if (IF->FirewallEnabled != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_FIREWALL, 
                                pwszFirewallState);
            }
            if (IF->DefSitePrefixLength != -1) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_SITEPREFIXLENGTH, 
                                IF->DefSitePrefixLength);
            }
            if (IF->Advertises != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_ADVERTISE,
                                (IF->Advertises ? 
                                    TOKEN_VALUE_ENABLED :
                                    TOKEN_VALUE_DISABLED));
            }
            if (IF->Forwards != -1) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_FORWARDING,
                                (IF->Forwards ? 
                                    TOKEN_VALUE_ENABLED :
                                    TOKEN_VALUE_DISABLED));
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }

        break;

    case FORMAT_NORMAL:
        if (dwCount == 0) {
            DisplayMessage(g_hModule, MSG_IPV6_INTERFACE_HDR);
        }

        pwszTemp = MakeString(g_hModule, dwMsg);

        DisplayMessage(g_hModule, MSG_IPV6_INTERFACE, IF->This.Index,
                       IF->Preference, IF->LinkMTU, pwszTemp, pwszFriendlyName);

        FreeString(pwszTemp);

        break;

    case FORMAT_VERBOSE:

        DisplayMessage(g_hModule, MSG_SEPARATOR);

        ForEachAddress(IF, pAdapterInfo, FORMAT_NORMAL, PrintAddress);

        //
        // Get extra interface information.
        //
        pIf = MapIfIndexToAdapter(AF_INET6, IF->This.Index, pAdapterInfo);

        pwszTemp = MakeString(g_hModule, dwMsg);

        ConvertGuidToStringA(&IF->This.Guid, szGuid);

        DisplayMessage(g_hModule, MSG_IPV6_INTERFACE_VERBOSE, 
                       szGuid,
                       pwszTemp, 
                       IF->Preference, 
                       IF->LinkMTU, 
                       IF->TrueLinkMTU, 
                       IF->CurHopLimit, 
                       FormatTime(MillisToSeconds(IF->ReachableTime),
                                  wszReachable),
                       FormatTime(MillisToSeconds(IF->BaseReachableTime),
                                  wszBaseReachable), 
                       FormatTime(MillisToSeconds(IF->RetransTimer),
                                  wszRetransTimer), 
                       IF->DupAddrDetectTransmits, 
                       (pIf)? pIf->DnsSuffix : L"",
                       pwszFriendlyName,
                       pwszFirewallState,
                       IF->DefSitePrefixLength);

        FreeString(pwszTemp);

        for (dwScope = ADE_LINK_LOCAL; dwScope < ADE_GLOBAL; dwScope++) {
            DWORD Expected = 0;

            //
            // Always print link & site.
            //
            if ((dwScope != ADE_LINK_LOCAL) && (dwScope != ADE_SITE_LOCAL)) {
                Expected = IF->ZoneIndices[dwScope + 1];
            }

            if (IF->ZoneIndices[dwScope] != Expected) {
                BOOL bDynamic;

                pwszTemp = GetScopeNoun(dwScope, &bDynamic);

                DisplayMessage(g_hModule, MSG_IPV6_INTERFACE_SCOPE,
                               pwszTemp, IF->ZoneIndices[dwScope]);

                if (bDynamic) {
                    FreeString(pwszTemp);
                }
            }
        }

        DisplayMessage(g_hModule, MSG_IPV6_ND_ENABLED);
        DisplayMessage(g_hModule, 
            (IF->NeighborDiscovers ? STRING_YES : STRING_NO));
        DisplayMessage(g_hModule, MSG_NEWLINE);
    
        DisplayMessage(g_hModule, MSG_IPV6_SENDS_RAS);
        DisplayMessage(g_hModule, 
            ((IF->Advertises == TRUE) ? STRING_YES : STRING_NO));
        DisplayMessage(g_hModule, MSG_NEWLINE);
    
        DisplayMessage(g_hModule, MSG_IPV6_FORWARDS);
        DisplayMessage(g_hModule, 
            ((IF->Forwards == TRUE) ? STRING_YES : STRING_NO));
        DisplayMessage(g_hModule, MSG_NEWLINE);

        if (IF->LocalLinkLayerAddress != 0) {
            DisplayMessage(g_hModule, MSG_IPV6_LL_ADDRESS,
                FormatLinkLayerAddress(IF->LinkLayerAddressLength,
                                (UCHAR *)IF + IF->LocalLinkLayerAddress));
        }
    
        if (IF->RemoteLinkLayerAddress != 0) {
            DisplayMessage(g_hModule, MSG_IPV6_REMOTE_LL_ADDRESS,
                FormatLinkLayerAddress(IF->LinkLayerAddressLength, 
                                (UCHAR *)IF + IF->RemoteLinkLayerAddress));
        }

        break;
    }

    return NO_ERROR;
}

DWORD
QueryInterface(
    IN PWCHAR pwszIfFriendlyName,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_INFO_INTERFACE *IF;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;
    DWORD dwErr;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr == ERROR_NO_DATA) {
        if (Format != FORMAT_DUMP) {
            DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
        }
        return NO_ERROR;
    }
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (pwszIfFriendlyName == NULL) {
        ForEachInterface(PrintInterface, pAdapterInfo, Format, bPersistent);
    } else {
        dwErr = GetInterfaceByFriendlyName(pwszIfFriendlyName, pAdapterInfo, 
                                           bPersistent, &IF);
        if (dwErr == NO_ERROR) {
            dwErr = PrintInterface(IF, pAdapterInfo, 0, Format, bPersistent);
            FREE(IF);
        }
    }

    FREE(pAdapterInfo);
    return dwErr;
}

DWORD
DeleteInterface(
    IN PWCHAR pwszIfFriendlyName,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_INTERFACE Query;
    IP_ADAPTER_ADDRESSES *pAdapterInfo;
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszIfFriendlyName, pAdapterInfo, 
                                         &Query.Index);
    FREE(pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = ERROR_OKAY;

    if (!DeviceIoControl(Handle, 
                         (bPersistent)
                            ? IOCTL_IPV6_PERSISTENT_DELETE_INTERFACE
                            : IOCTL_IPV6_DELETE_INTERFACE,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

#define KEY_TCPIP6_IF L"System\\CurrentControlSet\\Services\\Tcpip6\\Parameters\\Interfaces"

DWORD
SetFriendlyName(
    IN GUID *pGuid, 
    IN PWCHAR pwszFriendlyName
    )
{
    DWORD dwErr;
    HKEY  hInterfaces = INVALID_HANDLE_VALUE, hIf = INVALID_HANDLE_VALUE;
    UNICODE_STRING usGuid; 

    dwErr = RtlStringFromGUID(pGuid, &usGuid);
    if (!NT_SUCCESS(dwErr)) {
        return dwErr;
    }

    dwErr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, KEY_TCPIP6_IF, 0, GENERIC_READ,
                          &hInterfaces);
    if (dwErr != NO_ERROR) {
        goto Cleanup;
    }

    dwErr = RegOpenKeyExW(hInterfaces, usGuid.Buffer, 0, GENERIC_WRITE, &hIf);
    if (dwErr != NO_ERROR) {
        goto Cleanup;
    }

    dwErr = SetString(hIf, L"FriendlyName", pwszFriendlyName);

Cleanup:
    if (hInterfaces != INVALID_HANDLE_VALUE) {
        RegCloseKey(hInterfaces);
    }
    if (hIf != INVALID_HANDLE_VALUE) {
        RegCloseKey(hIf);
    }
    RtlFreeUnicodeString(&usGuid);

    return dwErr;
}

DWORD
AddTunnelInterface(
    IN PWCHAR pwszFriendlyName,
    IN IN_ADDR *pipLocalAddr,
    IN IN_ADDR *pipRemoteAddr,
    IN DWORD dwType,
    IN DWORD dwDiscovery,
    IN BOOL bPersistent
    )
{
    struct {
        IPV6_INFO_INTERFACE Info;
        IN_ADDR SrcAddr;
        IN_ADDR DstAddr;
    } Create;
    IPV6_QUERY_INTERFACE Result;
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    //
    // TODO: use pwszFriendlyName when persistent config is ready
    //

    IPV6_INIT_INFO_INTERFACE(&Create.Info);
    Create.Info.Type = dwType;
    Create.Info.NeighborDiscovers = dwDiscovery;
    Create.Info.RouterDiscovers = dwDiscovery;
    Create.Info.LinkLayerAddressLength = sizeof(IN_ADDR);
    if (pipLocalAddr != NULL) {
        Create.SrcAddr = *pipLocalAddr;
        Create.Info.LocalLinkLayerAddress = (u_int)
            ((char *)&Create.SrcAddr - (char *)&Create.Info);
    }
    if (pipRemoteAddr != NULL) {
        Create.DstAddr = *pipRemoteAddr;
        Create.Info.RemoteLinkLayerAddress = (u_int)
            ((char *)&Create.DstAddr - (char *)&Create.Info);
    }

    dwErr = ERROR_OKAY;

    if (!DeviceIoControl(Handle, 
                         (bPersistent)
                            ? IOCTL_IPV6_PERSISTENT_CREATE_INTERFACE 
                            : IOCTL_IPV6_CREATE_INTERFACE,
                         &Create, sizeof Create,
                         &Result, sizeof Result, &dwBytesReturned, NULL) ||
        (dwBytesReturned != sizeof Result)) {
        dwErr = GetLastError();
    } else if (bPersistent) {
        SetFriendlyName(&Result.Guid, pwszFriendlyName);
    }

    return dwErr;
}

DWORD
UpdateInterface(
    IN PWCHAR pwszIfFriendlyName, 
    IN DWORD dwForwarding, 
    IN DWORD dwAdvertises,
    IN DWORD dwMtu,
    IN DWORD dwSiteId,
    IN DWORD dwMetric,
    IN DWORD dwFirewall,
    IN DWORD dwDefSitePrefixLength,
    IN BOOL bPersistent
    )
{
    IPV6_INFO_INTERFACE Update;
    DWORD dwBytesReturned, dwErr;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    IPV6_INIT_INFO_INTERFACE(&Update);

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszIfFriendlyName, pAdapterInfo,
                                         &Update.This.Index);
    FREE(pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    Update.Advertises = dwAdvertises;
    Update.Forwards = dwForwarding;
    Update.FirewallEnabled = dwFirewall;
    Update.LinkMTU = dwMtu;
    Update.Preference = dwMetric;
    Update.ZoneIndices[ADE_SITE_LOCAL] = dwSiteId;
    Update.DefSitePrefixLength = dwDefSitePrefixLength;

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_INTERFACE,
                             &Update, sizeof Update,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_INTERFACE,
                         &Update, sizeof Update,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

//////////////////////////////////////////////////////////////////////////////
// Neighbor cache functions
//////////////////////////////////////////////////////////////////////////////

DWORD
PrintNeighborCacheEntry(
    IN IPV6_INFO_NEIGHBOR_CACHE *NCE,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount
    )
{
    DWORD dwErr;
    PWCHAR pwszLinkLayerAddress = L"";
    PWCHAR pwszUnreachable;

    if (NCE->NDState != ND_STATE_INCOMPLETE) {
        pwszLinkLayerAddress = FormatLinkLayerAddress(
                      NCE->LinkLayerAddressLength, (u_char *)(NCE + 1));
    }

    if (!dwCount) {
        PWCHAR pwszFriendlyName;

        dwErr = MapIpv6IfIndexToFriendlyName(NCE->Query.IF.Index, pAdapterInfo,
                                             &pwszFriendlyName);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_CACHE_HDR, 
                       NCE->Query.IF.Index, pwszFriendlyName);
    }

    pwszUnreachable = MakeString(g_hModule, MSG_IPV6_NEIGHBOR_UNREACHABLE);

    DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_CACHE_ENTRY,
                   FormatIPv6Address(&NCE->Query.Address, 0),
                   ((NCE->IsUnreachable)? pwszUnreachable : pwszLinkLayerAddress));
    FreeString(pwszUnreachable);

    switch (NCE->NDState) {
    case ND_STATE_INCOMPLETE:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_INCOMPLETE);
        break;

    case ND_STATE_PROBE:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_PROBE);
        break;

    case ND_STATE_DELAY:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_DELAY);
        break;

    case ND_STATE_STALE:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_STALE);
        break;

    case ND_STATE_REACHABLE:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_REACHABLE,
                       NCE->ReachableTimer / 1000);
        break;

    case ND_STATE_PERMANENT:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_PERMANENT);
        break;

    default:
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_UNKNOWN,
                       NCE->NDState);
        break;
    }

    if (NCE->IsRouter) {
        DisplayMessage(g_hModule, MSG_IPV6_NEIGHBOR_ISROUTER);
    }

    DisplayMessage(g_hModule, MSG_NEWLINE);

    return NO_ERROR;
}

DWORD
ForEachNeighborCacheEntry(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD (*pfnFunc)(IPV6_INFO_NEIGHBOR_CACHE *,PIP_ADAPTER_ADDRESSES,DWORD)
    )
{
    IPV6_QUERY_NEIGHBOR_CACHE Query, NextQuery;
    IPV6_INFO_NEIGHBOR_CACHE *NCE;
    DWORD dwInfoSize, dwBytesReturned;
    DWORD dwCount = 0;

    dwInfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;
    NCE = (IPV6_INFO_NEIGHBOR_CACHE *) MALLOC(dwInfoSize);
    if (NCE == NULL) {
        return 0;
    }

    NextQuery.IF = IF->This;
    NextQuery.Address = in6addr_any;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                             &Query, sizeof Query,
                             NCE, dwInfoSize, &dwBytesReturned,
                             NULL)) {
            return dwCount;
        }

        NextQuery = NCE->Query;

        if (!IN6_ADDR_EQUAL(&Query.Address, &in6addr_any)) {

            if ((dwBytesReturned < sizeof *NCE) ||
                (dwBytesReturned != sizeof *NCE + NCE->LinkLayerAddressLength)) {
                return dwCount;
            }

            NCE->Query = Query;
            if ((*pfnFunc)(NCE,pAdapterInfo,dwCount) == NO_ERROR) {
                dwCount++;
            }
        }

        if (IN6_ADDR_EQUAL(&NextQuery.Address, &in6addr_any))
            break;
    }

    FREE(NCE);

    return dwCount;
}

DWORD
PrintNeighborCache(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwIfCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount = ForEachNeighborCacheEntry(IF, pAdapterInfo, 
                                              PrintNeighborCacheEntry);
    return (dwCount > 0)? NO_ERROR : ERROR_NO_DATA;
}

IPV6_INFO_NEIGHBOR_CACHE *
GetNeighborCacheEntry(
    IN IPV6_INFO_INTERFACE *IF, 
    IN IN6_ADDR *Address
    )
{
    IPV6_QUERY_NEIGHBOR_CACHE Query;
    IPV6_INFO_NEIGHBOR_CACHE *NCE;
    DWORD dwInfoSize, dwBytesReturned;

    dwInfoSize = sizeof *NCE + MAX_LINK_LAYER_ADDRESS_LENGTH;
    NCE = (IPV6_INFO_NEIGHBOR_CACHE *) malloc(dwInfoSize);
    if (NCE == NULL) {
        return NULL;
    }

    Query.IF = IF->This;
    Query.Address = *Address;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_NEIGHBOR_CACHE,
                         &Query, sizeof Query,
                         NCE, dwInfoSize, &dwBytesReturned,
                         NULL)) {
        return NULL;
    }

    if ((dwBytesReturned < sizeof *NCE) ||
        (dwBytesReturned != sizeof *NCE + NCE->LinkLayerAddressLength)) {
        return NULL;
    }

    NCE->Query = Query;
    return NCE;
}

DWORD
QueryNeighborCache(
    IN PWCHAR pwszInterface,
    IN IN6_ADDR *pipAddress
    )
{
    IPV6_INFO_INTERFACE *IF;
    IPV6_INFO_NEIGHBOR_CACHE *NCE;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;
    DWORD dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pwszInterface) {
        ForEachInterface(PrintNeighborCache, pAdapterInfo, FORMAT_NORMAL, 
                         FALSE);
        FREE(pAdapterInfo);
        return NO_ERROR;
    } 

    dwErr = GetInterfaceByFriendlyName(pwszInterface, pAdapterInfo, FALSE, &IF);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pipAddress) {
        PrintNeighborCache(IF, pAdapterInfo, 0, FALSE, FALSE);
    } else {
        NCE = GetNeighborCacheEntry(IF, pipAddress);
        if (NCE != NULL) {
            PrintNeighborCacheEntry(NCE, pAdapterInfo, 0);
            FREE(NCE);
        }
    }

    FREE(IF);
    FREE(pAdapterInfo);
    return dwErr;
}

DWORD
FlushNeighborCacheForInterface(
    IN IPV6_INFO_INTERFACE *IF, 
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_NEIGHBOR_CACHE Query;
    DWORD dwBytesReturned;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD
FlushNeighborCache(
    IN PWCHAR pwszInterface,
    IN IN6_ADDR *pipAddress
    )
{
    IPV6_QUERY_NEIGHBOR_CACHE Query;
    DWORD dwBytesReturned, dwErr;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pwszInterface) {
        ForEachInterface(FlushNeighborCacheForInterface, NULL, FORMAT_NORMAL, 
                         FALSE);
        return NO_ERROR;
    } 

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszInterface,
                                         pAdapterInfo,
                                         &Query.IF.Index);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (pipAddress) {
        Query.Address = *pipAddress;
    } else {
        Query.Address = in6addr_any;
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        return GetLastError();
    }

    return ERROR_OKAY;
}

//////////////////////////////////////////////////////////////////////////////
// Destination cache functions
//////////////////////////////////////////////////////////////////////////////

DWORD
PrintDestination(
    IN IPV6_INFO_ROUTE_CACHE *RCE,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount,
    IN FORMAT Format
    )
{
    DWORD dwErr;
    PWCHAR pwszTemp;
    WCHAR wszTime[64];
    
    if (!dwCount) {
        PWCHAR pwszFriendlyName;

        dwErr = MapIpv6IfIndexToFriendlyName(RCE->Query.IF.Index, pAdapterInfo,
                                             &pwszFriendlyName);
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_DESTINATION_HDR_VERBOSE : MSG_IPV6_DESTINATION_HDR), 
                       RCE->Query.IF.Index, pwszFriendlyName);
    }

    DisplayMessage(g_hModule, 
                   ((Format == FORMAT_VERBOSE)? MSG_IPV6_DESTINATION_ENTRY_VERBOSE : MSG_IPV6_DESTINATION_ENTRY),
                   ((RCE->PathMTU == 0)? IPv6_MINIMUM_MTU : RCE->PathMTU),
                   FormatIPv6Address(&RCE->Query.Address, 0));
    DisplayMessage(g_hModule, 
                   ((Format == FORMAT_VERBOSE)? MSG_IPV6_DESTINATION_NEXTHOP_VERBOSE : MSG_IPV6_DESTINATION_NEXTHOP),
                   FormatIPv6Address(&RCE->NextHopAddress, 0));

    if (Format == FORMAT_VERBOSE) {

        DisplayMessage(g_hModule, 
                       MSG_IPV6_DESTINATION_SOURCE_ADDR,
                       FormatIPv6Address(&RCE->SourceAddress, 0));

        pwszTemp = MakeString(g_hModule, ((RCE->Valid)? STRING_NO : STRING_YES));
        DisplayMessage(g_hModule, MSG_IPV6_STALE, pwszTemp);

        FreeString(pwszTemp);
    
        switch (RCE->Flags) {
        case RCE_FLAG_CONSTRAINED:
            DisplayMessage(g_hModule, MSG_IPV6_IF_SPECIFIC);
            break;
    
        case RCE_FLAG_CONSTRAINED_SCOPEID:
            DisplayMessage(g_hModule, MSG_IPV6_ZONE_SPECIFIC);
            break;
        }

        if (RCE->PMTUProbeTimer != INFINITE_LIFETIME) {
            DisplayMessage(g_hModule, MSG_IPV6_PMTU_PROBE_TIME,
                           FormatTime(RCE->PMTUProbeTimer/1000, wszTime));
        }
    
        if ((RCE->ICMPLastError != 0) && (RCE->ICMPLastError < 10*60*1000)) {
            DisplayMessage(g_hModule, MSG_IPV6_ICMP_ERROR_TIME,
                           FormatTime(RCE->ICMPLastError/1000, wszTime));
        }
    
        if ((RCE->BindingSeqNumber != 0) ||
            (RCE->BindingLifetime != 0) ||
            ! IN6_ADDR_EQUAL(&RCE->CareOfAddress, &in6addr_any)) {

            DisplayMessage(g_hModule, MSG_IPV6_CAREOF,
                   FormatIPv6Address(&RCE->CareOfAddress, 0),
                   RCE->BindingSeqNumber,
                   FormatTime(RCE->BindingLifetime, wszTime));
        }
    }

    return NO_ERROR;
}

DWORD
ForEachDestination(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD (*pfnFunc)(IPV6_INFO_ROUTE_CACHE *,PIP_ADAPTER_ADDRESSES,DWORD,FORMAT)
    )
{
    IPV6_QUERY_ROUTE_CACHE Query, NextQuery;
    IPV6_INFO_ROUTE_CACHE RCE;
    DWORD dwBytesReturned, dwCount = 0;

    NextQuery.IF.Index = 0;
    NextQuery.Address = in6addr_any;

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ROUTE_CACHE,
                             &Query, sizeof Query,
                             &RCE, sizeof(RCE), &dwBytesReturned,
                             NULL)) {
            return dwCount;
        }

        NextQuery = RCE.Query;

        if (Query.IF.Index == IF->This.Index) {
            RCE.Query = Query;
            if ((*pfnFunc)(&RCE,pAdapterInfo,dwCount,Format) == NO_ERROR) {
                dwCount++;
            }
        } else if (dwCount > 0) {
            //
            // Stop if we're done with the desired interface.
            //
            break;
        }

        if (NextQuery.IF.Index == 0) {
            break;
        }
    }

    return dwCount;
}

IPV6_INFO_ROUTE_CACHE *
GetDestination(
    IN IPV6_QUERY_INTERFACE *IF,
    IN IN6_ADDR *Address
    )
{
    IPV6_QUERY_ROUTE_CACHE Query;
    IPV6_INFO_ROUTE_CACHE *RCE;
    DWORD dwBytesReturned;

    Query.IF = *IF;
    Query.Address = *Address;

    RCE = (IPV6_INFO_ROUTE_CACHE *) malloc(sizeof *RCE);
    if (RCE == NULL) {
        return NULL;
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_QUERY_ROUTE_CACHE,
                         &Query, sizeof Query,
                         RCE, sizeof *RCE, &dwBytesReturned,
                         NULL)) {
        return NULL;
    }

    RCE->Query = Query;
    return RCE;
}


DWORD
PrintRouteCache(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwIfCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount = ForEachDestination(IF, pAdapterInfo, Format, PrintDestination);
    return (dwCount > 0)? NO_ERROR : ERROR_NO_DATA;
}

DWORD
QueryRouteCache(
    IN PWCHAR pwszInterface,
    IN IN6_ADDR *pipAddress,
    IN FORMAT Format
    )
{
    IPV6_INFO_INTERFACE *IF;
    IPV6_INFO_ROUTE_CACHE *RCE;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;
    DWORD dwCount, dwErr;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pwszInterface) {
        dwCount = ForEachInterface(PrintRouteCache, pAdapterInfo, Format, 
                                   FALSE);
        FREE(pAdapterInfo);
        if (dwCount == 0) {
            DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
        }
        return NO_ERROR;
    } 

    dwErr = GetInterfaceByFriendlyName(pwszInterface, pAdapterInfo, FALSE, &IF);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pipAddress) {
        if (PrintRouteCache(IF, pAdapterInfo, 0, Format, FALSE) == ERROR_NO_DATA) {
            DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
        }
    } else {
        RCE = GetDestination(&IF->This, pipAddress);
        if (RCE != NULL) {
            PrintDestination(RCE, pAdapterInfo, 0, Format);
            FREE(RCE);
        }
    }

    FREE(IF);
    FREE(pAdapterInfo);
    return dwErr;
}


DWORD
FlushRouteCacheForInterface(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_ROUTE_CACHE Query;
    DWORD dwBytesReturned;

    Query.IF = IF->This;
    Query.Address = in6addr_any;

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_ROUTE_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD
FlushRouteCache(
    IN PWCHAR pwszInterface,
    IN IN6_ADDR *pipAddress
    )
{
    IPV6_QUERY_ROUTE_CACHE Query;
    DWORD dwBytesReturned, dwErr;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (!pwszInterface) {
        ForEachInterface(FlushRouteCacheForInterface, NULL, FORMAT_NORMAL, 
                         FALSE);
        return NO_ERROR;
    } 

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszInterface,
                                         pAdapterInfo,
                                         &Query.IF.Index);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (pipAddress) {
        Query.Address = *pipAddress;
    } else {
        Query.Address = in6addr_any;
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_FLUSH_ROUTE_CACHE,
                         &Query, sizeof Query,
                         NULL, 0, &dwBytesReturned, NULL)) {
        return GetLastError();
    }

    return ERROR_OKAY;
}

//////////////////////////////////////////////////////////////////////////////
// Route table functions
//////////////////////////////////////////////////////////////////////////////

DWORD
ForEachRoute(
    IN DWORD (*pfnFunc)(IPV6_INFO_ROUTE_TABLE *, IPV6_INFO_INTERFACE *, DWORD, PIP_ADAPTER_ADDRESSES, FORMAT), 
    IN DWORD dwArg,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    IPV6_QUERY_ROUTE_TABLE Query, NextQuery;
    IPV6_INFO_ROUTE_TABLE RTE;
    DWORD dwBytesReturned, dwCount = 0;

    ZeroMemory(&NextQuery, sizeof(NextQuery));

    for (;;) {
        Query = NextQuery;

        if (!DeviceIoControl(Handle, 
                             IOCTL_IPV6_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &dwBytesReturned,
                             NULL)) {
            return dwCount;
        }

        NextQuery = RTE.Next;

        if (Query.Neighbor.IF.Index != 0) {

            RTE.This = Query;
            if ((*pfnFunc)(&RTE, NULL, dwCount, pAdapterInfo, Format) == NO_ERROR) {
                dwCount++;
            }
        }

        if (NextQuery.Neighbor.IF.Index == 0)
            break;
    }

    return dwCount;
}

//
// These are RFC 2465 ipv6RouteProtocol values, and must match
// RTE_TYPE_... in ntddip6.h.
//
DWORD RteTypeMsg[] = { 0,0, 
                       STRING_SYSTEM, 
                       STRING_MANUAL,
                       STRING_AUTOCONF,
                       STRING_RIP,
                       STRING_OSPF,
                       STRING_BGP,
                       STRING_IDRP,
                       STRING_IGRP
                     };
#define RTE_TYPE_MSG_COUNT (sizeof(RteTypeMsg)/sizeof(DWORD))

DWORD
PrintRouteTableEntry(
    IN IPV6_INFO_ROUTE_TABLE *RTE, 
    IN IPV6_INFO_INTERFACE *IF,
    IN DWORD dwCount,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format
    )
{
    DWORD dwTypeMsg, dwErr;
    PWCHAR pwszPublishMsg, pwszFriendlyName;

    if (Format != FORMAT_VERBOSE) {
        //
        // Suppress system routes (used for loopback).
        //
        if (RTE->Type == RTE_TYPE_SYSTEM) {
            return ERROR_NO_DATA;
        }
    }

    if (RTE->This.Neighbor.IF.Index == 0) {
        dwErr = MapGuidToFriendlyName(NULL, &RTE->This.Neighbor.IF.Guid, 
                                      pAdapterInfo, &pwszFriendlyName);
    } else {
        dwErr = MapIpv6IfIndexToFriendlyName(RTE->This.Neighbor.IF.Index,
                                             pAdapterInfo, &pwszFriendlyName);
    }
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    pwszPublishMsg = TOKEN_VALUE_NO;
    if (RTE->Publish) {
        pwszPublishMsg = (RTE->Immortal)? TOKEN_VALUE_YES : TOKEN_VALUE_AGE;
    }

    if (Format == FORMAT_DUMP) {
        DisplayMessageT(DMP_IPV6_ADD_ROUTE);
        DisplayMessageT(DMP_STRING_ARG, TOKEN_PREFIX,
                       FormatIPv6Prefix(&RTE->This.Prefix,
                                        RTE->This.PrefixLength));
        DisplayMessageT(DMP_QUOTED_STRING_ARG, TOKEN_INTERFACE,
                        pwszFriendlyName);
        DisplayMessageT(DMP_INTEGER_ARG, TOKEN_METRIC, RTE->Preference);

        if (!IN6_ADDR_EQUAL(&RTE->This.Neighbor.Address, &in6addr_any)) {
            DisplayMessageT(DMP_STRING_ARG, TOKEN_NEXTHOP,
                            FormatIPv6Address(&RTE->This.Neighbor.Address, 0));
        }

        if (RTE->Publish) {
            DisplayMessageT(DMP_STRING_ARG, TOKEN_PUBLISH, pwszPublishMsg);

            if ((RTE->SitePrefixLength != 0) &&
                IN6_ADDR_EQUAL(&RTE->This.Neighbor.Address, &in6addr_any)) {

                DisplayMessageT(DMP_STRING_ARG, TOKEN_SITEPREFIXLENGTH,
                                RTE->SitePrefixLength);
            }
        }
        DisplayMessage(g_hModule, MSG_NEWLINE);
    } else {
        WCHAR wszValid[64], wszPreferred[64];
        PWCHAR pwszTemp, pwszPrefix, pwszGateway;
        BOOL bFreeIf = FALSE;
        DWORD Preference;

        if ((Format == FORMAT_NORMAL) && (dwCount == 0)) {
            DisplayMessage(g_hModule, MSG_IPV6_ROUTE_TABLE_HDR);
        }

        dwTypeMsg = (RTE->Type < RTE_TYPE_MSG_COUNT)? RteTypeMsg[RTE->Type] : STRING_UNKNOWN;
        pwszTemp = MakeString(g_hModule, dwTypeMsg);

        pwszPrefix = FormatIPv6Prefix(&RTE->This.Prefix,
                                      RTE->This.PrefixLength);

        if (IN6_ADDR_EQUAL(&RTE->This.Neighbor.Address, &in6addr_any)) {
            pwszGateway = pwszFriendlyName;
        } else {
            pwszGateway = FormatIPv6Address(&RTE->This.Neighbor.Address, 0);
        }

        if (IF == NULL) {
            IF = GetInterfaceByIpv6IfIndex(RTE->This.Neighbor.IF.Index);
            if (!IF) {
                FreeString(pwszTemp);
                return ERROR_NO_DATA;
            }
            bFreeIf = TRUE;
        }
        Preference = RTE->Preference;
        if (IF->Preference != -1) {
            Preference += IF->Preference;
        }

        DisplayMessage(g_hModule, 
                       ((Format == FORMAT_VERBOSE)? MSG_IPV6_ROUTE_TABLE_ENTRY_VERBOSE : MSG_IPV6_ROUTE_TABLE_ENTRY),
                       pwszPrefix,
                       RTE->This.Neighbor.IF.Index,
                       pwszGateway,
                       Preference,
                       pwszPublishMsg,
                       pwszTemp,
                       pwszFriendlyName,
                       FormatTime(RTE->ValidLifetime, wszValid),
                       FormatTime(RTE->PreferredLifetime, wszPreferred),
                       RTE->SitePrefixLength);

        if (bFreeIf) {
            FREE(IF);
        }

        FreeString(pwszTemp);
    }

    return NO_ERROR;
}

DWORD
ForEachPersistentRoute(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN FORMAT Format,
    IN DWORD (*pfnFunc)(IPV6_INFO_ROUTE_TABLE *, IPV6_INFO_INTERFACE *, DWORD, PIP_ADAPTER_ADDRESSES, FORMAT)
    )
{
    IPV6_PERSISTENT_QUERY_ROUTE_TABLE Query;
    IPV6_INFO_ROUTE_TABLE RTE;
    DWORD BytesReturned;
    DWORD dwCount = 0;

    Query.IF.RegistryIndex = (DWORD) -1;
    Query.IF.Guid = IF->This.Guid;

    for (Query.RegistryIndex = 0;; Query.RegistryIndex++) {

        if (!DeviceIoControl(Handle,
                             IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE,
                             &Query, sizeof Query,
                             &RTE, sizeof RTE, &BytesReturned,
                             NULL) ||
            (BytesReturned != sizeof RTE)) {

            break;
        }

        if ((*pfnFunc)(&RTE, IF, dwCount, pAdapterInfo, Format) == NO_ERROR) {
            dwCount++;
        }
    }

    return dwCount;
}

DWORD
PrintPersistentRoutesOnInterface(
    IN IPV6_INFO_INTERFACE *IF,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwIfCount,
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwCount = ForEachPersistentRoute(IF, pAdapterInfo, Format, 
                                           PrintRouteTableEntry);
    return (dwCount > 0)? NO_ERROR : ERROR_NO_DATA;
}

DWORD
QueryRouteTable(
    IN FORMAT Format,
    IN BOOL bPersistent
    )
{
    DWORD dwErr, dwCount = 0;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;

    dwErr = OpenIPv6(Format);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (Format != FORMAT_DUMP) {
        DisplayMessage(g_hModule, (bPersistent)? MSG_PERSISTENT : MSG_ACTIVE);
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != ERROR_NO_DATA) {
        
        if (dwErr != NO_ERROR) {
            return dwErr;
        }

        if (bPersistent) {
            dwCount = ForEachPersistentInterface(
                                   PrintPersistentRoutesOnInterface, 
                                   pAdapterInfo, Format);
        } else {
            dwCount = ForEachRoute(PrintRouteTableEntry, 0, pAdapterInfo, 
                                   Format, bPersistent);
        }
    
        FREE(pAdapterInfo);
    }

    if ((Format != FORMAT_DUMP) && !dwCount) {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES);
    }

    return NO_ERROR;
}

DWORD 
UpdateRouteTable(
    IN IN6_ADDR *pipPrefix, 
    IN DWORD dwPrefixLength,
    IN PWCHAR pwszIfFriendlyName, 
    IN IN6_ADDR *pipNextHop,
    IN DWORD dwMetric, 
    IN PUBLISH Publish,
    IN DWORD dwSitePrefixLength,
    IN DWORD dwValidLifetime,
    IN DWORD dwPreferredLifetime,
    IN BOOL bPersistent
    )
{
    IPV6_INFO_ROUTE_TABLE Route;
    DWORD dwBytesReturned;
    PIP_ADAPTER_ADDRESSES pAdapterInfo;
    DWORD dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MyGetAdaptersInfo(&pAdapterInfo);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = MapFriendlyNameToIpv6IfIndex(pwszIfFriendlyName, pAdapterInfo,
                                         &Route.This.Neighbor.IF.Index);

    FREE(pAdapterInfo);

    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    Route.This.Prefix = *pipPrefix;
    Route.This.PrefixLength = dwPrefixLength;
    Route.This.Neighbor.Address = (pipNextHop)? *pipNextHop : in6addr_any;

    Route.SitePrefixLength = dwSitePrefixLength;
    Route.ValidLifetime = dwValidLifetime;
    Route.PreferredLifetime = dwPreferredLifetime;
    Route.Preference = dwMetric;
    Route.Type = RTE_TYPE_MANUAL;
    switch (Publish) {
    case PUBLISH_IMMORTAL:
        Route.Publish  = TRUE;
        Route.Immortal = TRUE;
        break;
    case PUBLISH_AGE:
        Route.Publish  = TRUE;
        Route.Immortal = FALSE;
        break;
    case PUBLISH_NO:
        Route.Publish  = FALSE;
        Route.Immortal = FALSE;
        break;
    default:
        ASSERT(FALSE);
    }

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_UPDATE_ROUTE_TABLE,
                             &Route, sizeof Route,
                             NULL, 0,
                             &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_UPDATE_ROUTE_TABLE,
                         &Route, sizeof Route,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}

DWORD
ResetIpv6Config(
    IN BOOL bPersistent
    )
{
    DWORD dwBytesReturned, dwErr;

    dwErr = OpenIPv6(FORMAT_NORMAL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    dwErr = ERROR_OKAY;

    if (bPersistent) {
        if (!DeviceIoControl(Handle, IOCTL_IPV6_PERSISTENT_RESET,
                             NULL, 0,
                             NULL, 0, &dwBytesReturned, NULL)) {
            dwErr = GetLastError();
        }
    }

    if (!DeviceIoControl(Handle, IOCTL_IPV6_RESET,
                         NULL, 0,
                         NULL, 0, &dwBytesReturned, NULL)) {
        if (dwErr == ERROR_OKAY) {
            dwErr = GetLastError();
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ipv6str.h ===
#define MSG_HELP_START                         _T("%1!-14s! - ")

    //
    // Tokens for commands
    // These must be in lower case
    //

#define CMD_GROUP_SHOW                          L"show"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_DELETE                        L"delete"

    // IPv6 commands

#define CMD_IPV6_INSTALL                            L"install"
#define CMD_IPV6_RENEW                              L"renew"
#define CMD_IPV6_RESET                              L"reset"
#define CMD_IPV6_UNINSTALL                          L"uninstall"

#define CMD_IPV6_ADD_ADDRESS                        L"address"
#define CMD_IPV6_SET_ADDRESS                        L"address"
#define CMD_IPV6_DEL_ADDRESS                        L"address"
#define CMD_IPV6_SHOW_ADDRESS                       L"address"
#define CMD_IPV6_SHOW_BINDINGCACHEENTRIES           L"bindingcacheentries"
#define CMD_IPV6_ADD_DNS                            L"dns"
#define CMD_IPV6_DEL_DNS                            L"dns"
#define CMD_IPV6_SHOW_DNS                           L"dns"
#define CMD_IPV6_SHOW_GLOBAL                        L"global"
#define CMD_IPV6_SET_GLOBAL                         L"global"
#define CMD_IPV6_SET_INTERFACE                      L"interface"
#define CMD_IPV6_DEL_INTERFACE                      L"interface"
#define CMD_IPV6_SHOW_INTERFACE                     L"interface"
#define CMD_IPV6_DEL_NEIGHBORS                      L"neighbors"
#define CMD_IPV6_SHOW_NEIGHBORS                     L"neighbors"
#define CMD_IPV6_ADD_PREFIXPOLICY                   L"prefixpolicy"
#define CMD_IPV6_SET_PREFIXPOLICY                   L"prefixpolicy"
#define CMD_IPV6_DEL_PREFIXPOLICY                   L"prefixpolicy"
#define CMD_IPV6_SHOW_PREFIXPOLICY                  L"prefixpolicy"
#define CMD_IPV6_SET_PRIVACY                        L"privacy"
#define CMD_IPV6_SHOW_PRIVACY                       L"privacy"
#define CMD_IPV6_ADD_ROUTE                          L"route"
#define CMD_IPV6_SET_ROUTE                          L"route"
#define CMD_IPV6_DEL_ROUTE                          L"route"
#define CMD_IPV6_SHOW_ROUTES                        L"routes"
#define CMD_IPV6_DEL_DESTINATIONCACHE               L"destinationcache"
#define CMD_IPV6_SHOW_DESTINATIONCACHE              L"destinationcache"
#define CMD_IPV6_SHOW_SITEPREFIXES                  L"siteprefixes"
#define CMD_IPV6_ADD_V6V4TUNNEL                     L"v6v4tunnel"
#define CMD_IPV6_ADD_6OVER4TUNNEL                   L"6over4tunnel"
#define CMD_IPV6_SET_MOBILITY                       L"mobility"
#define CMD_IPV6_SHOW_MOBILITY                      L"mobility"
#define CMD_IPV6_SHOW_JOINS                         L"joins"
#define CMD_IPV6_SET_STATE                          L"state"
#define CMD_IPV6_SHOW_STATE                         L"state"

    // Teredo commands

#define CMD_IPV6_SET_TEREDO                         L"teredo"
#define CMD_IPV6_SHOW_TEREDO                        L"teredo"

    // 6to4 commands

#define CMD_IP6TO4_RESET                            L"reset"

#define CMD_IP6TO4_SHOW_INTERFACE                   L"interface"
#define CMD_IP6TO4_SHOW_RELAY                       L"relay"
#define CMD_IP6TO4_SHOW_ROUTING                     L"routing"
#define CMD_IP6TO4_SHOW_STATE                       L"state"

#define CMD_IP6TO4_SET_INTERFACE                    L"interface"
#define CMD_IP6TO4_SET_RELAY                        L"relay"
#define CMD_IP6TO4_SET_ROUTING                      L"routing"
#define CMD_IP6TO4_SET_STATE                        L"state"

    // ISATAP commands

#define CMD_ISATAP_SHOW_STATE                       L"state"
#define CMD_ISATAP_SHOW_ROUTER                      L"router"
#define CMD_ISATAP_SET_STATE                        L"state"
#define CMD_ISATAP_SET_ROUTER                       L"router"

    //
    // TOKEN_Xxx are tokens for arguments
    // These must be in lower case
    //

#define TOKEN_NAME                              L"name"
#define TOKEN_STATE                             L"state"
#define TOKEN_SITELOCALS                        L"sitelocals"
#define TOKEN_INTERVAL                          L"interval"
#define TOKEN_RELAY_NAME                        L"name"
#define TOKEN_UNDO_ON_STOP                      L"undoonstop"
#define TOKEN_6OVER4                            L"6over4"
#define TOKEN_V4COMPAT                          L"v4compat"
#define TOKEN_ROUTING                           L"routing"
#define TOKEN_INDEX                             L"index"

// token values for teredo

#define TOKEN_VALUE_CLIENT                      L"client"
#define TOKEN_VALUE_SERVER                      L"server"
#define TOKEN_TYPE                              L"type"
#define TOKEN_SERVERNAME                        L"servername"
#define TOKEN_REFRESH_INTERVAL                  L"refreshinterval"

// token values for 6to4

#define TOKEN_VALUE_AUTOMATIC                   L"automatic"
#define TOKEN_VALUE_ENABLED                     L"enabled"
#define TOKEN_VALUE_DISABLED                    L"disabled"
#define TOKEN_VALUE_DEFAULT                     L"default"

// token values for ipv6

#define TOKEN_ADDRESS                           L"address"
#define TOKEN_ADVERTISE                         L"advertise"
#define TOKEN_BINDINGCACHELIMIT                 L"bindingcachelimit"
#define TOKEN_CNSTATE                           L"correspondentnode"
#define TOKEN_DEFAULTCURHOPLIMIT                L"defaultcurhoplimit"
#define TOKEN_FIREWALL                          L"firewall"
#define TOKEN_FORWARDING                        L"forwarding"
#define TOKEN_INTERFACE                         L"interface"
#define TOKEN_LABEL                             L"label"
#define TOKEN_LEVEL                             L"level"
#define TOKEN_LIFETIME                          L"lifetime"
#define TOKEN_LOCALADDRESS                      L"localaddress"
#define TOKEN_MAXDADATTEMPTS                    L"maxdadattempts"
#define TOKEN_MAXPREFERREDLIFETIME              L"maxpreferredlifetime"
#define TOKEN_MAXRANDOMTIME                     L"maxrandomtime"
#define TOKEN_MAXVALIDLIFETIME                  L"maxvalidlifetime"
#define TOKEN_METRIC                            L"metric"
#define TOKEN_MTU                               L"mtu"
#define TOKEN_NEIGHBORCACHELIMIT                L"neighborcachelimit"
#define TOKEN_NEIGHBORDISCOVERY                 L"neighbordiscovery"
#define TOKEN_NEXTHOP                           L"nexthop"
#define TOKEN_PRECEDENCE                        L"precedence"
#define TOKEN_PREFIX                            L"prefix"
#define TOKEN_PUBLISH                           L"publish"
#define TOKEN_RANDOMTIME                        L"randomtime"
#define TOKEN_REASSEMBLYLIMIT                   L"reassemblylimit"
#define TOKEN_REGENERATETIME                    L"regeneratetime"
#define TOKEN_REMOTEADDRESS                     L"remoteaddress"
#define TOKEN_DESTINATIONCACHELIMIT             L"destinationcachelimit"
#define TOKEN_SECURITY                          L"security"
#define TOKEN_SITEID                            L"siteid"
#define TOKEN_SITEPREFIXLENGTH                  L"siteprefixlength"
#define TOKEN_STORE                             L"store"
#define TOKEN_TYPE                              L"type"
#define TOKEN_PREFERREDLIFETIME                 L"preferredlifetime"
#define TOKEN_VALIDLIFETIME                     L"validlifetime"

#define TOKEN_VALUE_NORMAL                      L"normal"
#define TOKEN_VALUE_VERBOSE                     L"verbose"
#define TOKEN_VALUE_UNICAST                     L"unicast"
#define TOKEN_VALUE_ANYCAST                     L"anycast"
#define TOKEN_VALUE_NO                          L"no"
#define TOKEN_VALUE_YES                         L"yes"
#define TOKEN_VALUE_AGE                         L"age"
#define TOKEN_VALUE_INFINITE                    L"infinite"
#define TOKEN_VALUE_ACTIVE                      L"active"
#define TOKEN_VALUE_PERSISTENT                  L"persistent"
#define TOKEN_VALUE_ALL                         L"all"

//
// Port Proxy commands.
//
#define CMD_PP_SHOW_ALL                         L"all"

#define CMD_V4TOV4                              L"v4tov4"
#define CMD_V4TOV6                              L"v4tov6"
#define CMD_V6TOV4                              L"v6tov4"
#define CMD_V6TOV6                              L"v6tov6"

#define CMD_PP_ADD_V4TOV4                       CMD_V4TOV4
#define CMD_PP_SET_V4TOV4                       CMD_V4TOV4
#define CMD_PP_DEL_V4TOV4                       CMD_V4TOV4
#define CMD_PP_SHOW_V4TOV4                      CMD_V4TOV4

#define CMD_PP_ADD_V4TOV6                       CMD_V4TOV6
#define CMD_PP_SET_V4TOV6                       CMD_V4TOV6
#define CMD_PP_DEL_V4TOV6                       CMD_V4TOV6
#define CMD_PP_SHOW_V4TOV6                      CMD_V4TOV6

#define CMD_PP_ADD_V6TOV4                       CMD_V6TOV4
#define CMD_PP_SET_V6TOV4                       CMD_V6TOV4
#define CMD_PP_DEL_V6TOV4                       CMD_V6TOV4
#define CMD_PP_SHOW_V6TOV4                      CMD_V6TOV4

#define CMD_PP_ADD_V6TOV6                       CMD_V6TOV6
#define CMD_PP_SET_V6TOV6                       CMD_V6TOV6
#define CMD_PP_DEL_V6TOV6                       CMD_V6TOV6
#define CMD_PP_SHOW_V6TOV6                      CMD_V6TOV6

#define TOKEN_LISTENADDRESS                     L"listenaddress"
#define TOKEN_LISTENPORT                        L"listenport"
#define TOKEN_CONNECTADDRESS                    L"connectaddress"
#define TOKEN_CONNECTPORT                       L"connectport"
#define TOKEN_PROTOCOL                          L"protocol"

#define TOKEN_VALUE_TCP                         L"tcp"

#define DMP_PP_PUSHD              L"pushd interface portproxy\n\nreset\n"
#define DMP_PP_POPD               L"\n\npopd\n"

//
// Messages used to dump config - these closely follow the
// set/add help messages
//

#define DMP_NEWLINE              L"\n"
#define DMP_IPV6_PUSHD              L"pushd interface ipv6\n\n"
#define DMP_IPV6_COMMAND            L"%1!s!\n"
#define DMP_IPV6_POPD               L"\n\npopd\n"

#define DMP_IPV6_ADD_6OVER4TUNNEL   L"add 6over4tunnel"
#define DMP_IPV6_ADD_V6V4TUNNEL     L"add v6v4tunnel"
#define DMP_IPV6_ADD_ADDRESS        L"add address"
#define DMP_IPV6_ADD_DNS            L"add dns"
#define DMP_IPV6_ADD_PREFIXPOLICY   L"add prefixpolicy"
#define DMP_IPV6_ADD_ROUTE          L"add route"
#define DMP_IPV6_ADD_SITEPREFIX     L"add siteprefix"
#define DMP_IPV6_SET_GLOBAL         L"set global"
#define DMP_IPV6_SET_INTERFACE      L"set interface"
#define DMP_IPV6_SET_MOBILITY       L"set mobility"
#define DMP_IPV6_SET_PRIVACY        L"set privacy"

#define DMP_IPV6_SET_TEREDO         L"set teredo"

#define DMP_IP6TO4_PUSHD            L"pushd interface ipv6 6to4\n\nreset\n"
#define DMP_IP6TO4_POPD             L"\n\n\npopd\n"

#define DMP_IP6TO4_SET_STATE        L"set state"
#define DMP_IP6TO4_SET_INTERFACE    L"set interface"
#define DMP_IP6TO4_SET_ROUTING      L"set routing"
#define DMP_IP6TO4_SET_RELAY        L"set relay"

#define DMP_ISATAP_PUSHD            L"pushd interface ipv6 isatap\n"
#define DMP_ISATAP_POPD             L"\n\n\npopd\n"
#define DMP_ISATAP_SET_STATE        L"set state %1!s!\n"
#define DMP_ISATAP_SET_ROUTER       L"set router"

#define DMP_ADD_PORT_PROXY          L"add %1!s!"

#define DMP_STRING_ARG              L" %1!s!=%2!s!"
#define DMP_INTEGER_ARG             L" %1!s!=%2!d!"
#define DMP_QUOTED_STRING_ARG       L" %1!s!=\"%2!s!\""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ipv6.h ===
//=============================================================================
// Copyright (c) Microsoft Corporation
// Abstract:
//      This module handles talking to the IPv6 stack.
//=============================================================================

#define MALLOC(dwBytes) HeapAlloc(GetProcessHeap(), 0, dwBytes)
#define FREE(ptr)       HeapFree(GetProcessHeap(), 0, ptr)

typedef enum {
    PUBLISH_NO,
    PUBLISH_AGE,
    PUBLISH_IMMORTAL
} PUBLISH;

typedef enum {
    FORMAT_NORMAL,
    FORMAT_VERBOSE,
    FORMAT_DUMP
} FORMAT;

DWORD AddTunnelInterface(PWCHAR pwszFriendlyName, IN_ADDR *pipLocalAddr, 
                         IN_ADDR *pipRemoteAddr, DWORD dwType, DWORD dwFlags,
                         BOOL bPersistent);
EXTERN_C DWORD AddOrRemoveIpv6(BOOL fAddIpv6);
DWORD DeleteInterface(PWCHAR wszIfFriendlyName, BOOL bPersistent);
DWORD DeletePrefixPolicy(IN6_ADDR *ipAddress, DWORD dwPrefixLength, 
                         BOOL bPersistent);
DWORD FlushNeighborCache(PWCHAR wszIfFriendlyName, IN6_ADDR *pipAddress);
DWORD FlushRouteCache(PWCHAR wszIfFriendlyName, IN6_ADDR *pipAddress);
IPV6_INFO_INTERFACE *GetInterfaceByIpv6IfIndex(DWORD dwIfIndex);
EXTERN_C DWORD IsIpv6Installed(BOOL *bInstalled);
DWORD QueryBindingCache();
DWORD QueryAddressTable(PWCHAR pwszIfFriendlyName, FORMAT Format, 
                        BOOL bPersistent);
DWORD QueryMulticastAddressTable(PWCHAR pwszIfFriendlyName, FORMAT Format);
DWORD QueryGlobalParameters(FORMAT Format, BOOL bPersistent);
DWORD QueryInterface(PWCHAR wszIfFriendlyName, FORMAT Format, BOOL bPersistent);
DWORD QueryMobilityParameters(FORMAT Format, BOOL bPersistent);
DWORD QueryNeighborCache(PWCHAR wszIfFriendlyName, IN6_ADDR *pipAddress);
DWORD QueryPrefixPolicy(FORMAT Format, BOOL bPersistent);
DWORD QueryPrivacyParameters(FORMAT Format, BOOL bPersistent);
DWORD QueryRouteCache(PWCHAR wszIfFriendlyName, IN6_ADDR *pipAddress,
                      FORMAT Format);
DWORD QueryRouteTable(FORMAT Format, BOOL bPersistent);
DWORD QuerySitePrefixTable(FORMAT Format);
DWORD RenewInterface(PWCHAR wszIfFriendlyName);
DWORD ResetIpv6Config(BOOL bPersistent);
DWORD UpdateMobilityParameters(DWORD dwSecurity, DWORD dwBindingCacheLimit,
                               DWORD dwMode, BOOL bPersistent);
DWORD UpdateAddress(PWCHAR pwszIfFriendlyName, IN6_ADDR *pipAddress, 
                    DWORD dwType, DWORD dwValidLifetime,
                    DWORD dwPreferredLifetime, BOOL bPersistent);
DWORD UpdateGlobalParameters(DWORD dwDefaultCurHopLimit, 
                             DWORD dwNeighborCacheLimit, 
                             DWORD dwRouteCacheLimit, DWORD dwReassemblyLimit,
                             BOOL bPersistent);
DWORD UpdateInterface(PWCHAR wszIfFriendlyName, DWORD dwForwarding, 
                      DWORD dwAdvertises, DWORD dwMtu, DWORD dwSiteId, 
                      DWORD dwMetric, DWORD dwFirewall, 
                      DWORD dwDefSitePrefixLength, BOOL bPersistent);
DWORD UpdatePrefixPolicy(IN6_ADDR *ipAddress, DWORD dwPrefixLength, 
                         DWORD dwPrecedence, DWORD dwLabel, BOOL bPersistent);
DWORD UpdatePrivacyParameters(DWORD dwUseTemporaryAddresses,
                              DWORD dwMaxDadAttempts,
                              DWORD dwMaxValidLifetime,
                              DWORD dwMaxPrefLifetime, 
                              DWORD dwRegenerateTime,
                              DWORD dwMaxRandomTime, 
                              DWORD dwRandomTime, BOOL bPersistent);
DWORD UpdateRouteTable(IN6_ADDR *ipPrefix, DWORD dwPrefixLength, 
                       PWCHAR pwszIfFriendlyName, IN6_ADDR *pipNextHop, 
                       DWORD dwMetric, PUBLISH Publish, 
                       DWORD dwSitePrefixLength, DWORD dwValidLifetime,
                       DWORD dwPreferredLifetime, BOOL bPersistent);
DWORD MyGetAdaptersInfo(OUT PIP_ADAPTER_ADDRESSES *ppAdapterInfo);
DWORD OpenIPv6(FORMAT Format);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\map.c ===
//=============================================================================
// Copyright (c) Microsoft Corporation
// Abstract:
//      This module implements ifindex-name conversion functions.
//=============================================================================
#include "precomp.h"
#pragma hdrstop

#define MAX_FRIENDLY_NAME_LENGTH 2000

HANDLE g_hMprConfig = INVALID_HANDLE_VALUE;

DWORD
Connect()
{
    return MprConfigServerConnect(NULL, &g_hMprConfig);
}

VOID
Disconnect()
{
    MprConfigServerDisconnect(g_hMprConfig);
    g_hMprConfig = INVALID_HANDLE_VALUE;
}

DWORD
MapAdapterNameToFriendlyName(
    IN PWCHAR pwszMachine,
    IN LPSTR AdapterName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT PWCHAR *ppwszFriendlyName
    )
/*++

Routine Description:

    Maps an adapter GUID to an interface friendly name.  This is IPv4/IPv6
    agnostic.

Arguments:

    AdapterName       - Supplies an adapter GUID.
    ppwszFriendlyName - Receives a pointer to a static buffer containing
                        the interface friendly name.

--*/
{
    PIP_ADAPTER_ADDRESSES pIf;

    for (pIf = pAdapterInfo; pIf; pIf = pIf->Next) {
        if (!strcmp(AdapterName, pIf->AdapterName)) {
            *ppwszFriendlyName = pIf->FriendlyName;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

#define GUID_FORMAT_A   "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

VOID
ConvertGuidToStringA(
    IN GUID *pGuid,
    OUT PCHAR pszBuffer
    )
{
    sprintf(pszBuffer, GUID_FORMAT_A,
            pGuid->Data1,
            pGuid->Data2,
            pGuid->Data3,
            pGuid->Data4[0],
            pGuid->Data4[1],
            pGuid->Data4[2],
            pGuid->Data4[3],
            pGuid->Data4[4],
            pGuid->Data4[5],
            pGuid->Data4[6],
            pGuid->Data4[7]);
}

DWORD
MapGuidToFriendlyName(
    IN PWCHAR pwszMachine,
    IN GUID *pGuid,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT PWCHAR *ppwszFriendlyName
    )
{
    CHAR szBuffer[80];

    ConvertGuidToStringA(pGuid, szBuffer);

    return MapAdapterNameToFriendlyName(pwszMachine, szBuffer,
                                        pAdapterInfo, ppwszFriendlyName);
}

DWORD
MapFriendlyNameToAdapterName(
    IN PWCHAR pwszMachine,
    IN PWCHAR pwszFriendlyName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT LPSTR *AdapterName
    )
/*++

Routine Description:

    Maps an interface friendly name to an adapter GUID.  This is IPv4/IPv6
    agnostic.

Arguments:

    pwszFriendlyName - Supplies an interface friendly name.
    pAdapterInfo     - Supplies info obtained from GetAdaptersAddresses().
    AdapterName      - Receives a pointer to a static buffer containing
                       the adapter GUID.

--*/
{
    PIP_ADAPTER_ADDRESSES pIf;

    //
    // First look for an exact match.
    //
    for (pIf = pAdapterInfo; pIf; pIf = pIf->Next) {
        if (!_wcsicmp(pwszFriendlyName, pIf->FriendlyName)) {
            *AdapterName = pIf->AdapterName;
            return NO_ERROR;
        }
    }

    //
    // Then look for a partial match.
    //
    for (pIf = pAdapterInfo; pIf; pIf = pIf->Next) {
        if (!_wcsnicmp(pwszFriendlyName, pIf->FriendlyName, 
                       wcslen(pwszFriendlyName))) {
            *AdapterName = pIf->AdapterName;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}

DWORD
MapAdapterNameToIfIndex(
    IN LPSTR AdapterName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    IN DWORD dwFamily,
    OUT UINT *pIfIndex
    )
/*++

Routine Description:

    Maps an adapter GUID to an interface index.  This is IPv4/IPv6
    specific, since each has a separate ifindex.

Arguments:

    AdapterName  - Supplies an adapter GUID.
    pAdapterInfo - Supplies info obtained from GetAdaptersAddresses().
    dwFamily     - Supplies the protocol for which an ifindex is needed.
    pIfIndex     - Receives the ifindex value.

--*/
{
    PIP_ADAPTER_ADDRESSES pIf;

    for (pIf=pAdapterInfo; pIf; pIf=pIf->Next) {
        if (!strcmp(pIf->AdapterName, AdapterName)) {
            break;
        }
    }
    if (!pIf) {
        *pIfIndex = 0;
        return ERROR_NOT_FOUND;
    }

    *pIfIndex = (dwFamily == AF_INET6)? pIf->Ipv6IfIndex : pIf->IfIndex;
    return NO_ERROR;
}

PIP_ADAPTER_ADDRESSES
MapIfIndexToAdapter(
    IN DWORD dwFamily,
    IN DWORD dwIfIndex,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo
    )
/*++

Routine Description:

    Maps an interface index to an adapter entry.  This is IPv4/IPv6
    specific, since each has a separate ifindex.

Arguments:

    dwFamily     - Supplies the protocol.
    dwIfIndex    - Supplies the interface index to map.
    pAdapterInfo - Supplies info obtained from GetAdaptersAddresses().

Returns:

    Adapter entry if found, NULL if not.

--*/
{
    PIP_ADAPTER_ADDRESSES pIf;

    for (pIf=pAdapterInfo; pIf; pIf=pIf->Next) {
        if ((dwFamily == AF_INET) && (pIf->IfIndex == dwIfIndex)) {
            break;
        }
        if ((dwFamily == AF_INET6) && (pIf->Ipv6IfIndex == dwIfIndex)) {
            break;
        }
    }
    if (!pIf) {
        return NULL;
    }

    return pIf;
}

LPSTR
MapIfIndexToAdapterName(
    IN DWORD dwFamily,
    IN DWORD dwIfIndex, 
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo
    )
/*++

Routine Description:

    Maps an interface index to an adapter GUID.  This is IPv4/IPv6
    specific, since each has a separate ifindex.

Arguments:

    dwFamily     - Supplies the protocol.
    dwIfIndex    - Supplies the interface index to map.
    pAdapterInfo - Supplies info obtained from GetAdaptersAddresses().

Returns:

    Adapter name if found, NULL if not.

--*/
{
    PIP_ADAPTER_ADDRESSES pIf;

    pIf = MapIfIndexToAdapter(dwFamily, dwIfIndex, pAdapterInfo);
    return (pIf)? pIf->AdapterName : NULL;
}

DWORD
MapFriendlyNameToIpv6IfIndex(
    IN PWCHAR pwszFriendlyName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT UINT *pIfIndex
    )
/*++

Routine Description:

    Maps an interface friendly name to an interface index.  This is IPv6
    specific, since IPv4 and IPv6 have separate ifindexes.

Arguments:

    pwszFriendlyName - Supplies the friendly name to map.
    pAdapterInfo     - Supplies info obtained from GetAdaptersAddresses().
    pIfIndex         - Receives the ifindex value.

--*/
{
    DWORD dwErr;
    LPSTR AdapterName;

    //
    // If string only contains digits, treat it as an IfIndex
    //
    if (wcsspn(pwszFriendlyName, L"1234567890") == wcslen(pwszFriendlyName)) {
        *pIfIndex = wcstoul(pwszFriendlyName, NULL, 10);
        return NO_ERROR;
    }

    dwErr = MapFriendlyNameToAdapterName(NULL, pwszFriendlyName, pAdapterInfo, 
                                         &AdapterName);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    return MapAdapterNameToIfIndex(AdapterName, pAdapterInfo, AF_INET6, pIfIndex);
}

DWORD
MapIpv6IfIndexToFriendlyName(
    IN DWORD dwIfIndex, 
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo,
    OUT PWCHAR *ppwszFriendlyName
    )
/*++

Routine Description:

    Maps an interface index to a friendly name.  This is IPv6
    specific, since IPv4 and IPv6 have separate ifindexes.

Arguments:

    dwIfIndex         - Supplies the ifindex value.
    pAdapterInfo      - Supplies info obtained from GetAdaptersAddresses().
    ppwszFriendlyName - Receives a pointer to a static buffer containing
                        the interface friendly name.

--*/
{
    IP_ADAPTER_ADDRESSES *If;

    for (If=pAdapterInfo; If; If=If->Next) {
        if (If->Ipv6IfIndex == dwIfIndex) {
            *ppwszFriendlyName = If->FriendlyName;    
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\ipv6mon.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    Netsh helper for IPv6

--*/

#include "precomp.h"

GUID g_Ipv6Guid = IPV6MON_GUID;

static const GUID g_IfGuid = IFMON_GUID;

#define IPV6_HELPER_VERSION 1

//
// The helper's commands are broken into 2 sets
//      - The top level commands are those which deal with the helper
//        itself (meta commands) and others which take 0 arguments
//      - The rest of the commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        GET or SET.  This is not for any technical reason - only for
//        staying with the semantics used in other helpers
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//

CMD_ENTRY  g_Ipv6AddCmdTable[] = 
{
    CREATE_CMD_ENTRY(IPV6_ADD_6OVER4TUNNEL, HandleAdd6over4Tunnel),
    CREATE_CMD_ENTRY(IPV6_ADD_ADDRESS, HandleAddAddress),
    CREATE_CMD_ENTRY(IPV6_ADD_DNS, HandleAddDns),
    CREATE_CMD_ENTRY(IPV6_ADD_PREFIXPOLICY, HandleAddPrefixPolicy),
    CREATE_CMD_ENTRY(IPV6_ADD_ROUTE, HandleAddRoute),
    CREATE_CMD_ENTRY(IPV6_ADD_V6V4TUNNEL, HandleAddV6V4Tunnel),
};

CMD_ENTRY  g_Ipv6DelCmdTable[] = 
{
    CREATE_CMD_ENTRY(IPV6_DEL_ADDRESS, HandleDelAddress),
    CREATE_CMD_ENTRY(IPV6_DEL_DNS, HandleDelDns),
    CREATE_CMD_ENTRY(IPV6_DEL_INTERFACE, HandleDelInterface),
    CREATE_CMD_ENTRY(IPV6_DEL_NEIGHBORS, HandleDelNeighbors),
    CREATE_CMD_ENTRY(IPV6_DEL_PREFIXPOLICY, HandleDelPrefixPolicy),
    CREATE_CMD_ENTRY(IPV6_DEL_ROUTE, HandleDelRoute),
    CREATE_CMD_ENTRY(IPV6_DEL_DESTINATIONCACHE, HandleDelDestinationCache),
};

CMD_ENTRY  g_Ipv6SetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IPV6_SET_ADDRESS, HandleSetAddress),
    CREATE_CMD_ENTRY(IPV6_SET_GLOBAL, HandleSetGlobal),
    CREATE_CMD_ENTRY(IPV6_SET_INTERFACE, HandleSetInterface),
    CREATE_CMD_ENTRY(IPV6_SET_MOBILITY, HandleSetMobility),
    CREATE_CMD_ENTRY(IPV6_SET_PREFIXPOLICY, HandleSetPrefixPolicy),
    CREATE_CMD_ENTRY(IPV6_SET_PRIVACY, HandleSetPrivacy),
    CREATE_CMD_ENTRY(IPV6_SET_ROUTE, HandleSetRoute),
    CREATE_CMD_ENTRY(IPV6_SET_STATE, HandleSetState),
#ifdef TEREDO    
    CREATE_CMD_ENTRY(IPV6_SET_TEREDO, HandleSetTeredo),
#endif // TEREDO
};

CMD_ENTRY g_Ipv6ShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(IPV6_SHOW_ADDRESS, HandleShowAddress),
    CREATE_CMD_ENTRY(IPV6_SHOW_BINDINGCACHEENTRIES, HandleShowBindingCacheEntries),
    CREATE_CMD_ENTRY(IPV6_SHOW_DNS, HandleShowDns),
    CREATE_CMD_ENTRY(IPV6_SHOW_GLOBAL, HandleShowGlobal),
    CREATE_CMD_ENTRY(IPV6_SHOW_INTERFACE, HandleShowInterface),
    CREATE_CMD_ENTRY(IPV6_SHOW_JOINS, HandleShowJoins),
    CREATE_CMD_ENTRY(IPV6_SHOW_MOBILITY, HandleShowMobility),
    CREATE_CMD_ENTRY(IPV6_SHOW_NEIGHBORS, HandleShowNeighbors),
    CREATE_CMD_ENTRY(IPV6_SHOW_PREFIXPOLICY, HandleShowPrefixPolicy),
    CREATE_CMD_ENTRY(IPV6_SHOW_PRIVACY, HandleShowPrivacy),
    CREATE_CMD_ENTRY(IPV6_SHOW_DESTINATIONCACHE, HandleShowDestinationCache),
    CREATE_CMD_ENTRY(IPV6_SHOW_ROUTES, HandleShowRoutes),
    CREATE_CMD_ENTRY(IPV6_SHOW_SITEPREFIXES, HandleShowSitePrefixes),
    CREATE_CMD_ENTRY(IPV6_SHOW_STATE, HandleShowState),
#ifdef TEREDO    
    CREATE_CMD_ENTRY(IPV6_SHOW_TEREDO, HandleShowTeredo),
#endif // TEREDO
};

CMD_GROUP_ENTRY g_Ipv6CmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_Ipv6AddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_Ipv6DelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_Ipv6ShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_Ipv6SetCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_Ipv6CmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_Ipv6TopCmds[] =
{
    CREATE_CMD_ENTRY(IPV6_INSTALL, HandleInstall),
    CREATE_CMD_ENTRY(IPV6_RENEW, HandleRenew),
    CREATE_CMD_ENTRY(IPV6_RESET, HandleReset),
    CREATE_CMD_ENTRY(IPV6_UNINSTALL, HandleUninstall),
};

ULONG   g_ulNumTopCmds = sizeof(g_Ipv6TopCmds)/sizeof(CMD_ENTRY);

HANDLE  g_hModule;
PWCHAR  g_pwszRouter = NULL;

DWORD   ParentVersion;
BOOL    g_bIfDirty = FALSE;

ULONG   g_ulInitCount;

BOOL 
WINAPI
Ipv6DllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD
WINAPI
Ipv6Dump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
/*++

Routine Description

    Used when dumping all contexts

Arguments

Return Value

    NO_ERROR

--*/
{
    DisplayMessage( g_hModule, DMP_IPV6_HEADER_COMMENTS );
    DisplayMessageT(DMP_IPV6_PUSHD);

    if (OpenIPv6(FORMAT_DUMP) == NO_ERROR) {
        DisplayMessageT(DMP_IPV6_COMMAND, CMD_IPV6_INSTALL);
        DisplayMessageT(DMP_IPV6_COMMAND, CMD_IPV6_RESET);

        //
        // Dump persistent configuration information.
        //
        QueryGlobalParameters(FORMAT_DUMP, TRUE);
        ShowIpv6StateConfig(TRUE);
        ShowDnsServers(TRUE, NULL);
        QueryPrivacyParameters(FORMAT_DUMP, TRUE);
        QueryMobilityParameters(FORMAT_DUMP, TRUE);
        QueryPrefixPolicy(FORMAT_DUMP, TRUE);
        QueryRouteTable(FORMAT_DUMP, TRUE);

        QueryInterface(NULL, FORMAT_DUMP, TRUE);
        QueryAddressTable(NULL, FORMAT_DUMP, TRUE);

#ifdef TEREDO    
        ShowTeredo(FORMAT_DUMP);
#endif // TEREDO
    } else {
        DisplayMessageT(DMP_IPV6_COMMAND, CMD_IPV6_UNINSTALL);
    }
    
    DisplayMessageT(DMP_IPV6_POPD);
    DisplayMessage( g_hModule, DMP_IPV6_FOOTER_COMMENTS );

    return NO_ERROR;
}

DWORD
WINAPI
Ipv6StartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"ipv6";
    attMyAttributes.guidHelper  = g_Ipv6Guid;
    attMyAttributes.dwVersion   = IPV6_HELPER_VERSION;
    attMyAttributes.dwFlags     = CMD_FLAG_LOCAL | CMD_FLAG_ONLINE;
    attMyAttributes.pfnDumpFn   = Ipv6Dump;
    attMyAttributes.ulNumTopCmds= g_ulNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_Ipv6TopCmds;
    attMyAttributes.ulNumGroups = g_ulNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_Ipv6CmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
Ipv6UnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement((PLONG)&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD                dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;
    WSADATA              wsa;

    //
    // See if this is the first time we are being called
    //

    if (InterlockedIncrement((PLONG)&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    dwErr = WSAStartup(MAKEWORD(2,0), &wsa);

    // Register helpers

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper = g_Ipv6Guid;
    attMyAttributes.dwVersion  = IPV6_HELPER_VERSION;
    attMyAttributes.pfnStart   = Ipv6StartHelper;
    attMyAttributes.pfnStop    = NULL;

    RegisterHelper( &g_IfGuid, &attMyAttributes );

    attMyAttributes.guidHelper = g_PpGuid;
    attMyAttributes.dwVersion  = PORTPROXY_HELPER_VERSION;
    attMyAttributes.pfnStart   = PpStartHelper;
    attMyAttributes.pfnStop    = NULL;

    RegisterHelper( &g_IfGuid, &attMyAttributes );

    dwErr = Ipv6InstallSubContexts();
    if (dwErr isnot NO_ERROR)
    {
        Ipv6UnInit(0);
        return dwErr;
    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\isatap.h ===
//=============================================================================
// Copyright (c) 2002 Microsoft Corporation
// File: isatap.h
//
// Author: Dave Thaler (dthaler)   1-23-02
//=============================================================================


#ifndef __ISATAP_H
#define __ISATAP_H

NS_HELPER_START_FN IsatapStartHelper;
NS_CONTEXT_DUMP_FN IsatapDump;

FN_HANDLE_CMD IsatapHandleReset;

FN_HANDLE_CMD IsatapHandleSetState;
FN_HANDLE_CMD IsatapHandleSetRouter;

FN_HANDLE_CMD IsatapHandleShowState;
FN_HANDLE_CMD IsatapHandleShowRouter;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\isatap.c ===
//=============================================================================
// Copyright (c) 2002 Microsoft Corporation
// Abstract:
//      This module implements ISATAP configuration commands.
//=============================================================================


#include "precomp.h"
#pragma hdrstop 

#define KEY_ENABLE_ISATAP_RESOLUTION   L"EnableIsatapResolution"
#define KEY_ISATAP_RESOLUTION_INTERVAL L"IsatapResolutionInterval"
#define KEY_ISATAP_ROUTER_NAME         L"IsatapRouterName"
#define KEY_ISATAP_STATE               L"IsatapState"

// The commands supported in this context
//

CMD_ENTRY  g_IsatapSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(ISATAP_SET_STATE,  IsatapHandleSetState),
    CREATE_CMD_ENTRY(ISATAP_SET_ROUTER, IsatapHandleSetRouter),
};

CMD_ENTRY  g_IsatapShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(ISATAP_SHOW_STATE,     IsatapHandleShowState),
    CREATE_CMD_ENTRY(ISATAP_SHOW_ROUTER,    IsatapHandleShowRouter),
};


CMD_GROUP_ENTRY g_IsatapCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_IsatapSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_IsatapShowCmdTable),
};

ULONG g_ulIsatapNumGroups = sizeof(g_IsatapCmdGroups)/sizeof(CMD_GROUP_ENTRY);

DWORD
WINAPI
IsatapStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
/*++

Routine Description

    Used to initialize the helper.

Arguments

    pguidParent     IPv6's guid
    pfnRegisterContext      
    
Return Value

    NO_ERROR
    other error code
--*/
{
    DWORD dwErr = NO_ERROR;
    
    NS_CONTEXT_ATTRIBUTES attMyAttributes;


    // Initialize attributes.  We reuse the same GUID as 6to4 since both
    // are leaf contexts.
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"isatap";
    attMyAttributes.guidHelper  = g_Ip6to4Guid;
    attMyAttributes.dwVersion   = IP6TO4_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = IsatapDump;
    attMyAttributes.ulNumTopCmds= 0;
    attMyAttributes.pTopCmds    = NULL;
    attMyAttributes.ulNumGroups = g_ulIsatapNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IsatapCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
IsatapHandleSetState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    HKEY hKey = INVALID_HANDLE_VALUE;
    STATE stState = 0;
    BOOL bState = FALSE;
    TAG_TYPE pttTags[] = {{TOKEN_STATE, NS_REQ_ZERO, FALSE}};
    DWORD rgdwTagType[sizeof(pttTags) / sizeof(TAG_TYPE)];
    DWORD i;
    
    // Parse arguments
    
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags) / sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags) / sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    for (i = 0; i < (dwArgCount - dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0:                 // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD) &stState);
            if (dwErr != NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            bState = TRUE;
            break;
            
        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hKey, NULL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (bState) {
        dwErr = SetInteger(hKey, KEY_ISATAP_STATE, stState);
        if (dwErr != NO_ERROR) {
            RegCloseKey(hKey);
            return dwErr;
        }
    }

    RegCloseKey(hKey);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

#define BM_ENABLE_RESOLUTION   0x01
#define BM_ROUTER_NAME         0x02
#define BM_RESOLUTION_INTERVAL 0x04

DWORD
IsatapHandleSetRouter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD    dwErr = NO_ERROR;
    HKEY     hGlobal;
    STATE    stEnableResolution = 0;
    ULONG    ulResolutionInterval = 0;
    PWCHAR   pwszRouterName = NULL;
    DWORD    dwBitVector = 0;
    TAG_TYPE pttTags[] = {{TOKEN_NAME,     NS_REQ_ZERO, FALSE},
                          {TOKEN_STATE,    NS_REQ_ZERO, FALSE},
                          {TOKEN_INTERVAL, NS_REQ_ZERO, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD    i;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }
    
    for (i=0; i<dwArgCount-dwCurrentIndex; i++) {
        switch(rgdwTagType[i]) {
        case 0: // ROUTERNAME
            pwszRouterName = ppwcArguments[dwCurrentIndex + i];
            dwBitVector |= BM_ROUTER_NAME;
            break;

        case 1: // STATE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD)&stEnableResolution);
            if (dwErr isnot NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            
            dwBitVector |= BM_ENABLE_RESOLUTION;
            break;

        case 2: // INTERVAL
            ulResolutionInterval = wcstoul(ppwcArguments[dwCurrentIndex + i],
                                           NULL, 10);
            dwBitVector |= BM_RESOLUTION_INTERVAL;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr isnot NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hGlobal, NULL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (dwBitVector & BM_ENABLE_RESOLUTION) {
        dwErr = SetInteger(hGlobal, KEY_ENABLE_ISATAP_RESOLUTION, 
                           stEnableResolution); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }
    
    if (dwBitVector & BM_ROUTER_NAME) {
        dwErr = SetString(hGlobal, KEY_ISATAP_ROUTER_NAME, pwszRouterName);
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    if (dwBitVector & BM_RESOLUTION_INTERVAL) {
        dwErr = SetInteger(hGlobal, KEY_ISATAP_RESOLUTION_INTERVAL, 
                           ulResolutionInterval); 
        if (dwErr != NO_ERROR) {
            RegCloseKey(hGlobal);
            return dwErr;
        }
    }

    RegCloseKey(hGlobal);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
ShowState(
    IN FORMAT Format
    )
{
    HKEY hKey = INVALID_HANDLE_VALUE;
    STATE stState;

    (VOID) RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_READ, &hKey);

    stState = GetInteger(hKey, KEY_ISATAP_STATE, VAL_DEFAULT); 
    if (stState >= VAL_MAXIMUM) {
        stState = VAL_DEFAULT;
    }
    
    if (hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if (Format == FORMAT_DUMP) {
        if (stState != VAL_DEFAULT) {
            DisplayMessageT(DMP_ISATAP_SET_STATE, pwszStateString[stState]);
        }
    } else {
        DisplayMessage(g_hModule, MSG_ISATAP_STATE, pwszStateString[stState]);
    }
    return NO_ERROR;
}

DWORD
IsatapHandleShowState(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowState(FORMAT_NORMAL);
}

DWORD
ShowRouterConfig(
    IN BOOL bDump
    )
{
    DWORD dwErr = NO_ERROR;
    HKEY  hGlobal;
    STATE stEnableResolution;
    ULONG ulResolutionInterval;
    WCHAR pwszRouterName[NI_MAXHOST];
    BOOL  bHaveRouterName;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KEY_GLOBAL, 0, KEY_READ,
                         &hGlobal);

    if (dwErr != NO_ERROR) {
        hGlobal = INVALID_HANDLE_VALUE;
        dwErr = NO_ERROR;
    }

    stEnableResolution  = GetInteger(hGlobal,
                                     KEY_ENABLE_ISATAP_RESOLUTION,
                                     VAL_DEFAULT); 

    bHaveRouterName = GetString(hGlobal, KEY_ISATAP_ROUTER_NAME, pwszRouterName,
                                NI_MAXHOST);

    ulResolutionInterval = GetInteger(hGlobal,
                                      KEY_ISATAP_RESOLUTION_INTERVAL,
                                      0);

    if (hGlobal != INVALID_HANDLE_VALUE) {
        RegCloseKey(hGlobal);
    }

    if (bDump) {
        if (bHaveRouterName || (stEnableResolution != VAL_DEFAULT)
            || (ulResolutionInterval > 0)) {
        
            DisplayMessageT(DMP_ISATAP_SET_ROUTER);

            if (bHaveRouterName) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_NAME,
                                pwszRouterName);
            }

            if (stEnableResolution != VAL_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, 
                                TOKEN_STATE,
                                pwszStateString[stEnableResolution]);
            }
    
            if (ulResolutionInterval > 0) {
                DisplayMessageT(DMP_INTEGER_ARG, TOKEN_INTERVAL,
                                ulResolutionInterval);
            }

            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
                                    
    } else {
        DisplayMessage(g_hModule, MSG_ROUTER_NAME);
    
        if (bHaveRouterName) {
            DisplayMessage(g_hModule, MSG_STRING, pwszRouterName);
        } else {
            DisplayMessage(g_hModule, MSG_STRING, TOKEN_VALUE_DEFAULT);
        }
    
        DisplayMessage(g_hModule, MSG_RESOLUTION_STATE,
                                  pwszStateString[stEnableResolution]);
    
        DisplayMessage(g_hModule, MSG_RESOLUTION_INTERVAL);
    
        if (ulResolutionInterval) {
            DisplayMessage(g_hModule, MSG_MINUTES, ulResolutionInterval);
        } else {
            DisplayMessage(g_hModule, MSG_STRING, TOKEN_VALUE_DEFAULT);
        }
    }

    return dwErr;
}

DWORD
IsatapHandleShowRouter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowRouterConfig(FALSE);
}

DWORD
WINAPI
IsatapDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
{
    DisplayMessage(g_hModule, DMP_ISATAP_HEADER);
    DisplayMessageT(DMP_ISATAP_PUSHD);

    ShowState(FORMAT_DUMP);
    ShowRouterConfig(TRUE);

    DisplayMessageT(DMP_ISATAP_POPD);
    DisplayMessage(g_hModule, DMP_ISATAP_FOOTER);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <netsh.h>
#include <netshp.h>
#include <mprapi.h>
#include <shlwapi.h>
#include <ntddip6.h>
#include <iptypes.h>
#include <iphlpapi.h>
#include "ipv6mon.h"
#include "ipv6str.h"
#include "strdefs.h"
#include "6to4.h"
#include "isatap.h"
#include "ipv6.h"
#include "ifip.h"
#include "map.h"
#include "parse.h"

#define isnot !=

//
// Unreferenced parameters are normal for netsh helpers.
//
#pragma warning(disable:4100) // unreferenced formal parameter

// #pragma warning(disable:4057)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\parse.c ===
//=============================================================================
// Copyright (c) Microsoft Corporation
// Abstract:
//      This module implements string-address conversion functions.
//=============================================================================
#include "precomp.h"
#pragma hdrstop

WCHAR *
FormatIPv6Address(
    IN IN6_ADDR *Address,
    IN DWORD dwScopeId
    )
/*++

Routine Description:

    Converts an IPv6 address to a string in a static buffer.

Arguments:

    Address      - Supplies the IPv6 address.
    dwScopeId    - Supplies the scope identifier.

Returns:

    Pointer to static buffer holding address literal string.

--*/
{
    static WCHAR Buffer[128];
    ULONG buflen = sizeof(Buffer);
    SOCKADDR_IN6 sin6;

    ZeroMemory(&sin6, sizeof(sin6));
    sin6.sin6_family = AF_INET6;
    sin6.sin6_scope_id = dwScopeId;
    sin6.sin6_addr = *Address;

    if (WSAAddressToString((SOCKADDR *) &sin6,
                           sizeof sin6,
                           NULL,       // LPWSAPROTOCOL_INFO
                           Buffer,
                           &buflen) == SOCKET_ERROR) {
        wcscpy(Buffer, L"???");
    }

    return Buffer;
}


WCHAR *
FormatIPv6Prefix(
    IN IN6_ADDR *Address,
    IN ULONG Length
    )
{
    static WCHAR Buffer[128];

    swprintf(Buffer, L"%s/%d", FormatIPv6Address(Address, 0), Length);

    return Buffer;
}

WCHAR *
FormatIPv4Address(
    IN IN_ADDR *Address
    )
{
    static WCHAR Buffer[128];
    ULONG buflen = sizeof(Buffer);
    SOCKADDR_IN sin;

    ZeroMemory(&sin, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr = *Address;

    if (WSAAddressToString((SOCKADDR *) &sin,
                           sizeof sin,
                           NULL,       // LPWSAPROTOCOL_INFO
                           Buffer,
                           &buflen) == SOCKET_ERROR) {
        wcscpy(Buffer, L"<invalid>");
    }

    return Buffer;
}

WCHAR *
FormatLinkLayerAddress(
    IN ULONG Length,
    IN UCHAR *Addr
    )
{
    static WCHAR Buffer[128];

    switch (Length) {
    case 6: {
        int i, digit;
        WCHAR *s = Buffer;

        for (i = 0; i < 6; i++) {
            if (i != 0)
                *s++ = '-';

            digit = Addr[i] >> 4;
            if (digit < 10)
                *s++ = (WCHAR)(digit + L'0');
            else
                *s++ = (WCHAR)(digit - 10 + L'a');

            digit = Addr[i] & 0xf;
            if (digit < 10)
                *s++ = (WCHAR)(digit + L'0');
            else
                *s++ = (WCHAR)(digit - 10 + L'a');
        }
        *s = '\0';
        break;
    }

    case 4:
        //
        // IPv4 Address (6-over-4 link)
        //
        wcscpy(Buffer, FormatIPv4Address((struct in_addr *)Addr));
        break;

    case 0:
    default:
        //
        // Null or loop-back address
        //
        Buffer[0] = L'\0';
        break;
    }

    return Buffer;
}

DWORD
GetIpv4Address(
    IN PWCHAR pwszArgument,
    OUT IN_ADDR *pipAddress
    )
/*++

Routine Description:

    Gets the IPv4 address from the string.

Arguments:

    pwszArgument        argument specifing an ip address
    pipAddress          ip address

Return Value:

    NO_ERROR            if success
    Failure code        o/w

--*/
{
    NTSTATUS ntStatus;
    PWCHAR   Terminator;

    //
    // Parse unicode IPv4 address with "strict" semantics (full dotted-decimal
    // only).  There's no other function that does this today other than
    // the Rtl function below.
    //
    ntStatus = RtlIpv4StringToAddressW(pwszArgument, TRUE, &Terminator,
                                       pipAddress);

    if (!NT_SUCCESS(ntStatus) || (*Terminator != 0)) {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


DWORD
GetIpv6Prefix(
    IN PWCHAR pwszArgument,
    OUT IN6_ADDR *pipAddress,
    OUT DWORD *dwPrefixLength
    )
{
    NTSTATUS ntStatus;
    PWCHAR   Terminator;
    DWORD    Length = 0;

    ntStatus = RtlIpv6StringToAddressW(pwszArgument, &Terminator,
                                       pipAddress);

    if (!NT_SUCCESS(ntStatus) || (*Terminator++ != L'/')) {
        return ERROR_INVALID_PARAMETER;
    }

    while (iswdigit(*Terminator)) {
        Length = (Length * 10) + (*Terminator++ - L'0');
    }
    if (*Terminator != 0) {
        return ERROR_INVALID_PARAMETER;
    }

    *dwPrefixLength = Length;
    return NO_ERROR;
}

DWORD
GetIpv6Address(
    IN PWCHAR pwszArgument,
    OUT IN6_ADDR *pipAddress
    )
{
    NTSTATUS ntStatus;
    PWCHAR   Terminator;

    ntStatus = RtlIpv6StringToAddressW(pwszArgument, &Terminator,
                                       pipAddress);

    if (!NT_SUCCESS(ntStatus) || (*Terminator != 0)) {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\portproxy.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    Port Proxy Helper.

--*/
#include "precomp.h"

GUID g_PpGuid = PORTPROXY_GUID;

#define KEY_PORTS L"System\\CurrentControlSet\\Services\\PortProxy"

typedef enum {
    V4TOV4,
    V4TOV6,
    V6TOV4,
    V6TOV6
} PPTYPE, *PPPTYPE;

typedef struct {
    PWCHAR Token;
    PWCHAR ListenFamily;
    PWCHAR ConnectFamily;
    PWCHAR KeyString;
} PPTYPEINFO, *PPPTYPEINFO;

#define IPV4_STR L"IPv4"
#define IPV6_STR L"IPv6"

PPTYPEINFO PpTypeInfo[] = {
    { CMD_V4TOV4, IPV4_STR, IPV4_STR, KEY_PORTS L"\\" CMD_V4TOV4 },
    { CMD_V4TOV6, IPV4_STR, IPV6_STR, KEY_PORTS L"\\" CMD_V4TOV6 },
    { CMD_V6TOV4, IPV6_STR, IPV4_STR, KEY_PORTS L"\\" CMD_V6TOV4 },
    { CMD_V6TOV6, IPV6_STR, IPV6_STR, KEY_PORTS L"\\" CMD_V6TOV6 },
};

//
// Port Proxy commands.
//
FN_HANDLE_CMD PpHandleReset;

FN_HANDLE_CMD PpHandleDelV4ToV4;
FN_HANDLE_CMD PpHandleDelV4ToV6;
FN_HANDLE_CMD PpHandleDelV6ToV4;
FN_HANDLE_CMD PpHandleDelV6ToV6;

FN_HANDLE_CMD PpHandleAddSetV4ToV4;
FN_HANDLE_CMD PpHandleAddSetV4ToV6;
FN_HANDLE_CMD PpHandleAddSetV6ToV4;
FN_HANDLE_CMD PpHandleAddSetV6ToV6;

FN_HANDLE_CMD PpHandleShowAll;
FN_HANDLE_CMD PpHandleShowV4ToV4;
FN_HANDLE_CMD PpHandleShowV4ToV6;
FN_HANDLE_CMD PpHandleShowV6ToV4;
FN_HANDLE_CMD PpHandleShowV6ToV6;

CMD_ENTRY  g_PpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(PP_ADD_V4TOV4, PpHandleAddSetV4ToV4),
    CREATE_CMD_ENTRY(PP_ADD_V4TOV6, PpHandleAddSetV4ToV6),
    CREATE_CMD_ENTRY(PP_ADD_V6TOV4, PpHandleAddSetV6ToV4),
    CREATE_CMD_ENTRY(PP_ADD_V6TOV6, PpHandleAddSetV6ToV6),
};

CMD_ENTRY  g_PpDelCmdTable[] =
{
    CREATE_CMD_ENTRY(PP_DEL_V4TOV4, PpHandleDelV4ToV4),
    CREATE_CMD_ENTRY(PP_DEL_V4TOV6, PpHandleDelV4ToV6),
    CREATE_CMD_ENTRY(PP_DEL_V6TOV4, PpHandleDelV6ToV4),
    CREATE_CMD_ENTRY(PP_DEL_V6TOV6, PpHandleDelV6ToV6),
};

CMD_ENTRY  g_PpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(PP_SET_V4TOV4, PpHandleAddSetV4ToV4),
    CREATE_CMD_ENTRY(PP_SET_V4TOV6, PpHandleAddSetV4ToV6),
    CREATE_CMD_ENTRY(PP_SET_V6TOV4, PpHandleAddSetV6ToV4),
    CREATE_CMD_ENTRY(PP_SET_V6TOV6, PpHandleAddSetV6ToV6),
};

CMD_ENTRY g_PpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(PP_SHOW_ALL,    PpHandleShowAll),
    CREATE_CMD_ENTRY(PP_SHOW_V4TOV4, PpHandleShowV4ToV4),
    CREATE_CMD_ENTRY(PP_SHOW_V4TOV6, PpHandleShowV4ToV6),
    CREATE_CMD_ENTRY(PP_SHOW_V6TOV4, PpHandleShowV6ToV4),
    CREATE_CMD_ENTRY(PP_SHOW_V6TOV6, PpHandleShowV6ToV6),
};

CMD_GROUP_ENTRY g_PpCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_PpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_PpDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_PpShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_PpSetCmdTable),
};

ULONG   g_ulNumPpCmdGroups = sizeof(g_PpCmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_PpTopCmds[] =
{
    CREATE_CMD_ENTRY(IPV6_RESET, PpHandleReset),
};

ULONG g_ulNumPpTopCmds = sizeof(g_PpTopCmds)/sizeof(CMD_ENTRY);

DWORD
WINAPI
PpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD dwParentVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"portproxy";
    attMyAttributes.guidHelper  = g_PpGuid;
    attMyAttributes.dwVersion   = PORTPROXY_HELPER_VERSION;
    attMyAttributes.dwFlags     = CMD_FLAG_LOCAL | CMD_FLAG_ONLINE;
    attMyAttributes.pfnDumpFn   = PpDump;
    attMyAttributes.ulNumTopCmds= g_ulNumPpTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_PpTopCmds;
    attMyAttributes.ulNumGroups = g_ulNumPpCmdGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_PpCmdGroups;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

VOID
ShowPorts(
    IN PPTYPE Type,
    IN FORMAT Format
    )
{
    ULONG Status, i, ListenChars, ConnectBytes, dwType;
    HKEY hType, hProto;
    WCHAR ListenBuffer[256], *ListenAddress, *ListenPort;
    WCHAR ConnectAddress[256], *ConnectPort;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PpTypeInfo[Type].KeyString, 0, 
                          KEY_QUERY_VALUE, &hType);
    if (Status != NO_ERROR) {
        return;
    }
    Status = RegOpenKeyEx(hType, TOKEN_VALUE_TCP, 0,
                          KEY_QUERY_VALUE, &hProto);
    if (Status == NO_ERROR) {
        for (i=0; ; i++) {
            ListenChars = sizeof(ListenBuffer)/sizeof(WCHAR);
            ConnectBytes = sizeof(ConnectAddress);
            Status = RegEnumValueW(hProto, i, ListenBuffer, &ListenChars, 
                                   NULL, &dwType, (PVOID)ConnectAddress, 
                                   &ConnectBytes);
            if (Status != NO_ERROR) {
                break;
            }

            if (dwType != REG_SZ) {
                continue;
            }

            ListenPort = wcschr(ListenBuffer, L'/');
            if (ListenPort) {
                //
                // Replace slash with NULL, so we have 2 strings to pass
                // to getaddrinfo.
                //
                ListenAddress = ListenBuffer;
                *ListenPort++ = L'\0';
            } else {
                //
                // If the address data didn't include a connect address
                // use "*".
                //
                ListenAddress = L"*";
                ListenPort = ListenBuffer;
            }

            ConnectPort = wcschr(ConnectAddress, L'/');
            if (ConnectPort) {
                //
                // Replace slash with NULL, so we have 2 strings to pass
                // to getaddrinfo.
                //
                *ConnectPort++ = L'\0';
            } else {
                //
                // If the address data didn't include a connect port
                // number, use the same port as the listen port number.
                //
                ConnectPort = ListenPort;
            }

            if (Format == FORMAT_NORMAL) {
                if (i==0) {
                    DisplayMessage(g_hModule, MSG_PORT_PROXY_HEADER,
                                   PpTypeInfo[Type].ListenFamily,
                                   PpTypeInfo[Type].ConnectFamily);
                }
                DisplayMessage(g_hModule, MSG_PORT_PROXY, ListenAddress,
                               ListenPort, ConnectAddress, ConnectPort);
            } else {
                DisplayMessageT(DMP_ADD_PORT_PROXY, PpTypeInfo[Type].Token);
                DisplayMessageT(DMP_STRING_ARG, TOKEN_LISTENPORT, ListenPort);
                DisplayMessageT(DMP_STRING_ARG, TOKEN_CONNECTADDRESS, ConnectAddress);
                DisplayMessageT(DMP_STRING_ARG, TOKEN_CONNECTPORT, ConnectPort);
                DisplayMessageT(DMP_NEWLINE);
            }
        }
        RegCloseKey(hProto);
    }
    RegCloseKey(hType);
}

ULONG
PpHandleShowV4ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    ShowPorts(V4TOV4, FORMAT_NORMAL);

    return STATUS_SUCCESS; 
}

ULONG
PpHandleShowV6ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    ShowPorts(V6TOV4, FORMAT_NORMAL);

    return STATUS_SUCCESS;
}

ULONG
PpHandleShowV4ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    ShowPorts(V4TOV6, FORMAT_NORMAL);

    return STATUS_SUCCESS;
}

ULONG
PpHandleShowV6ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    ShowPorts(V6TOV6, FORMAT_NORMAL);

    return STATUS_SUCCESS;
}

ULONG
PpHandleShowAll(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    ShowPorts(V4TOV4, FORMAT_NORMAL);
    ShowPorts(V4TOV6, FORMAT_NORMAL);
    ShowPorts(V6TOV4, FORMAT_NORMAL);
    ShowPorts(V6TOV6, FORMAT_NORMAL);

    return STATUS_SUCCESS;
}

PWCHAR
PpFormValue(
    IN PWCHAR Address,
    IN PWCHAR Port
    )
{
    SIZE_T Length;
    PWCHAR Value;

    Length = wcslen(Address) + wcslen(Port) + 2;
    Value = MALLOC(Length * sizeof(WCHAR));

    swprintf(Value, L"%s/%s", Address, Port);

    return Value;
}

TOKEN_VALUE g_ProtocolEnum[] = {{ TOKEN_VALUE_TCP, IPPROTO_TCP }};

ULONG
PpHandleAddSetPort(
    IN PPTYPE Type,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc
    )
{
    ULONG Status, i;
    TAG_TYPE Tags[] = {{TOKEN_LISTENPORT,     NS_REQ_PRESENT, FALSE},
                       {TOKEN_CONNECTADDRESS, NS_REQ_ZERO,    FALSE},
                       {TOKEN_CONNECTPORT,    NS_REQ_ZERO,    FALSE},
                       {TOKEN_LISTENADDRESS,  NS_REQ_ZERO,    FALSE},
                       {TOKEN_PROTOCOL,       NS_REQ_ZERO,    FALSE}};
    ULONG TagType[sizeof(Tags)/sizeof(TAG_TYPE)];
    PWCHAR ListenAddress = NULL, ListenPort = NULL;
    PWCHAR ConnectAddress = NULL, ConnectPort = NULL;
    PWCHAR ProtocolString = NULL;
    ULONG Protocol = IPPROTO_TCP;
    PWCHAR KeyValue, KeyData;
    HKEY hType, hProto;

    if ((Type == V4TOV4) || (Type == V6TOV6)) {
        Tags[1].dwRequired = NS_REQ_PRESENT;
    }

    Status = PreprocessCommand(g_hModule,
                           Argv,
                           CurrentIndex,
                           Argc,
                           Tags,
                           sizeof(Tags)/sizeof(TAG_TYPE),
                           0,
                           sizeof(Tags)/sizeof(TAG_TYPE),
                           TagType);

    for (i=0; (Status == NO_ERROR) && (i < Argc-CurrentIndex); i++) {
        switch (TagType[i]) {
        case 0: // LISTENPORT
            ListenPort = Argv[CurrentIndex + i];
            break;

        case 1: // CONNECTADDRESS
            ConnectAddress = Argv[CurrentIndex + i];
            break;

        case 2: // CONNECTPORT
            ConnectPort = Argv[CurrentIndex + i];
            break;

        case 3: // LISTENADDRESS
            ListenAddress = Argv[CurrentIndex + i];
            break;

        case 4: // PROTOCOL
            Status = MatchEnumTag(NULL,
                                  Argv[CurrentIndex + i],
                                  NUM_TOKENS_IN_TABLE(g_ProtocolEnum),
                                  g_ProtocolEnum,
                                  (PULONG)&Protocol);
            if (Status != NO_ERROR) {
                Status = ERROR_INVALID_PARAMETER;
            }
            ProtocolString = Argv[CurrentIndex + i];
            break;

        default:
            Status = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (Status != NO_ERROR) {
        return Status;
    }

    if (ConnectAddress == NULL) {
        ConnectAddress = L"localhost";
    }
    if (ListenAddress == NULL) {
        ListenAddress = L"*";
    }    
    if (ProtocolString == NULL) {
        ProtocolString = TOKEN_VALUE_TCP;
    }
    if (ConnectPort == NULL) {
        ConnectPort = ListenPort;
    }    

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, PpTypeInfo[Type].KeyString, 0,
                            NULL, 0, KEY_CREATE_SUB_KEY, 
                            NULL, &hType, NULL);
    if (Status != NO_ERROR) {
        return Status;
    }

    Status = RegCreateKeyEx(hType, ProtocolString, 0, 
                            NULL, 0, KEY_SET_VALUE, NULL, &hProto, NULL);
    if (Status != NO_ERROR) {
        RegCloseKey(hType);
        return Status;
    }

    KeyValue = PpFormValue(ListenAddress, ListenPort);
    KeyData = PpFormValue(ConnectAddress, ConnectPort);
    if (KeyValue && KeyData) {
        Status = RegSetValueEx(hProto, KeyValue, 0, REG_SZ, (PVOID)KeyData,
                               (DWORD) wcslen(KeyData) * sizeof(WCHAR));
        FREE(KeyValue);
    }

    RegCloseKey(hProto);
    RegCloseKey(hType);

    Ip6to4PokeService();

    return Status;
}

ULONG
PpHandleDeletePort(
    IN PPTYPE Type,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc
    )
{
    ULONG Status, i;
    TAG_TYPE Tags[] = {{TOKEN_LISTENPORT,     NS_REQ_PRESENT, FALSE},
                       {TOKEN_LISTENADDRESS,  NS_REQ_ZERO,    FALSE},
                       {TOKEN_PROTOCOL,       NS_REQ_ZERO,    FALSE}};
    ULONG TagType[sizeof(Tags)/sizeof(TAG_TYPE)];
    PWCHAR ListenAddress = NULL, ListenPort = NULL;
    ULONG Protocol;
    PWCHAR ProtocolString = NULL;
    HKEY hType, hProto;
    PWCHAR Value;

    Status = PreprocessCommand(g_hModule,
                           Argv,
                           CurrentIndex,
                           Argc,
                           Tags,
                           sizeof(Tags)/sizeof(TAG_TYPE),
                           0,
                           sizeof(Tags)/sizeof(TAG_TYPE),
                           TagType);

    for (i=0; (Status == NO_ERROR) && (i < Argc-CurrentIndex); i++) {
        switch (TagType[i]) {
        case 0: // LISTENPORT
            ListenPort = Argv[CurrentIndex + i];
            break;

        case 1: // LISTENADDRESS
            ListenAddress = Argv[CurrentIndex + i];
            break;

        case 2: // PROTOCOL
            Status = MatchEnumTag(NULL,
                                  Argv[CurrentIndex + i],
                                  NUM_TOKENS_IN_TABLE(g_ProtocolEnum),
                                  g_ProtocolEnum,
                                  (PULONG)&Protocol);
            if (Status != NO_ERROR) {
                Status = ERROR_INVALID_PARAMETER;
            }
            ProtocolString = Argv[CurrentIndex + i];
            break;

        default:
            Status = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (Status != NO_ERROR) {
        return Status;
    }

    if (ListenAddress == NULL) {
        ListenAddress = L"*";
    }

    if (ProtocolString == NULL) {
        ProtocolString = TOKEN_VALUE_TCP;
    }

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PpTypeInfo[Type].KeyString, 0, 
                          KEY_QUERY_VALUE, &hType);
    if (Status != NO_ERROR) {
        return Status;
    }

    Status = RegOpenKeyEx(hType, ProtocolString, 0, KEY_SET_VALUE, &hProto);
    if (Status != NO_ERROR) {
        RegCloseKey(hType);
        return Status;
    }

    Value = PpFormValue(ListenAddress, ListenPort);
    if (Value) {
        Status = RegDeleteValue(hProto, Value);
        FREE(Value);
    }

    RegCloseKey(hProto);
    RegCloseKey(hType);

    Ip6to4PokeService();

    return Status;
}

ULONG
PpHandleDelV4ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleDeletePort(V4TOV4, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleDelV4ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleDeletePort(V4TOV6, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleDelV6ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleDeletePort(V6TOV4, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleDelV6ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleDeletePort(V6TOV6, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleAddSetV4ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleAddSetPort(V4TOV4, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleAddSetV4ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleAddSetPort(V4TOV6, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleAddSetV6ToV4(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleAddSetPort(V6TOV4, Argv, CurrentIndex, Argc);
}

ULONG
PpHandleAddSetV6ToV6(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    return PpHandleAddSetPort(V6TOV6, Argv, CurrentIndex, Argc);
}

VOID
PpReset(
    IN PPTYPE Type
    )
{
    HKEY hType;
    ULONG Status;

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, PpTypeInfo[Type].KeyString, 0, 
                          KEY_CREATE_SUB_KEY, &hType);
    if (Status != NO_ERROR) {
        return;
    }

    SHDeleteKey(hType, TOKEN_VALUE_TCP);

    RegCloseKey(hType);

    Ip6to4PokeService();
}

ULONG
PpHandleReset(
    IN LPCWSTR MachineName,
    IN LPWSTR *Argv,
    IN ULONG CurrentIndex,
    IN ULONG Argc,
    IN ULONG Flags,
    IN LPCVOID Data,
    OUT BOOL *Done
    )
{
    PpReset(V4TOV4);
    PpReset(V4TOV6);
    PpReset(V6TOV4);
    PpReset(V6TOV6);

    return STATUS_SUCCESS;
}

DWORD
WINAPI
PpDump(
    IN LPCWSTR pwszRouter,
    IN OUT LPWSTR *ppwcArguments,
    IN DWORD dwArgCount,
    IN LPCVOID pvData
    )
{
    DisplayMessage(g_hModule, DMP_PP_HEADER_COMMENTS);
    DisplayMessageT(DMP_PP_PUSHD);

    ShowPorts(V4TOV4, FORMAT_DUMP);
    ShowPorts(V4TOV6, FORMAT_DUMP);
    ShowPorts(V6TOV4, FORMAT_DUMP);
    ShowPorts(V6TOV6, FORMAT_DUMP);

    DisplayMessageT(DMP_PP_POPD);
    DisplayMessage(g_hModule, DMP_PP_FOOTER_COMMENTS);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\map.h ===
//=============================================================================
// Copyright (c) Microsoft Corporation
// Abstract:
//      This module implements ifindex-name conversion functions.
//=============================================================================

extern HANDLE g_hMprConfig;

DWORD
Connect();

VOID
Disconnect();

DWORD
MapFriendlyNameToIpv6IfIndex(
    IN PWCHAR pwszFriendlyName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT UINT *pIfIndex
    );

DWORD
MapIpv6IfIndexToFriendlyName(
    IN DWORD dwIfIndex,
    IN IP_ADAPTER_ADDRESSES *pAdapterInfo,
    OUT PWCHAR *ppwszFriendlyName
    );

PIP_ADAPTER_ADDRESSES
MapIfIndexToAdapter(
    IN DWORD dwFamily,
    IN DWORD dwIfIndex,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo
    );

DWORD
MapGuidToFriendlyName(
    IN PWCHAR pwszMachine,
    IN GUID *pGuid,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT PWCHAR *ppwszFriendlyName
    );

DWORD
MapFriendlyNameToAdapterName(
    IN PWCHAR pwszMachine,
    IN PWCHAR pwszFriendlyName,
    IN PIP_ADAPTER_ADDRESSES pAdapterInfo,
    OUT LPSTR *AdapterName
    );

VOID
ConvertGuidToStringA(
    IN GUID *pGuid,
    OUT PCHAR pszString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                                1001
#define MSG_NEWLINE                             1002
#define MSG_SEPARATOR                           1003

#define MSG_PERSISTENT                          1004
#define MSG_ACTIVE                              1005

#define HLP_GROUP_ADD                           3901
#define HLP_GROUP_DELETE                        3903
#define HLP_GROUP_SET                           3905
#define HLP_GROUP_SHOW                          3907

#define HLP_IP6TO4_RESET                        3101
#define HLP_IP6TO4_RESET_EX                     3102

    // 6to4
#define HLP_IP6TO4_SET_INTERFACE                3201
#define HLP_IP6TO4_SET_INTERFACE_EX             3202
#define HLP_IP6TO4_SHOW_INTERFACE               3203
#define HLP_IP6TO4_SHOW_INTERFACE_EX            3204

#define HLP_IP6TO4_SET_ROUTING                  3301
#define HLP_IP6TO4_SET_ROUTING_EX               3302
#define HLP_IP6TO4_SHOW_ROUTING                 3303
#define HLP_IP6TO4_SHOW_ROUTING_EX              3304

#define HLP_IP6TO4_SET_RELAY                    3401
#define HLP_IP6TO4_SET_RELAY_EX                 3402
#define HLP_IP6TO4_SHOW_RELAY                   3403
#define HLP_IP6TO4_SHOW_RELAY_EX                3404

#define HLP_IP6TO4_SET_STATE                    3501
#define HLP_IP6TO4_SET_STATE_EX                 3502
#define HLP_IP6TO4_SHOW_STATE                   3503
#define HLP_IP6TO4_SHOW_STATE_EX                3504

    // ISATAP
#define HLP_ISATAP_SET_ROUTER                   3601
#define HLP_ISATAP_SET_ROUTER_EX                3602
#define HLP_ISATAP_SHOW_ROUTER                  3603
#define HLP_ISATAP_SHOW_ROUTER_EX               3604

#define HLP_ISATAP_SET_STATE                    5601
#define HLP_ISATAP_SET_STATE_EX                 5602
#define HLP_ISATAP_SHOW_STATE                   5603
#define HLP_ISATAP_SHOW_STATE_EX                5604

    // Teredo
#define HLP_IPV6_SET_TEREDO                     3701
#define HLP_IPV6_SET_TEREDO_EX                  3702
#define HLP_IPV6_SHOW_TEREDO                    3703
#define HLP_IPV6_SHOW_TEREDO_EX                 3704

    // IPv6
#define HLP_IPV6_INSTALL                        3001
#define HLP_IPV6_INSTALL_EX                     3002
#define HLP_IPV6_RENEW                          3003
#define HLP_IPV6_RENEW_EX                       3004
#define HLP_IPV6_UNINSTALL                      3005
#define HLP_IPV6_UNINSTALL_EX                   3006

#define HLP_IPV6_SHOW_BINDINGCACHEENTRIES       3707
#define HLP_IPV6_SHOW_BINDINGCACHEENTRIES_EX    3708

#define HLP_IPV6_SET_GLOBAL                     3803
#define HLP_IPV6_SET_GLOBAL_EX                  3804
#define HLP_IPV6_SHOW_GLOBAL                    3807
#define HLP_IPV6_SHOW_GLOBAL_EX                 3808

#define HLP_IPV6_SET_PRIVACY                    4003
#define HLP_IPV6_SET_PRIVACY_EX                 4004
#define HLP_IPV6_SHOW_PRIVACY                   4007
#define HLP_IPV6_SHOW_PRIVACY_EX                4008

#define HLP_IPV6_ADD_6OVER4TUNNEL               4101
#define HLP_IPV6_ADD_6OVER4TUNNEL_EX            4102

#define HLP_IPV6_ADD_PREFIXPOLICY               4201
#define HLP_IPV6_ADD_PREFIXPOLICY_EX            4202
#define HLP_IPV6_SET_PREFIXPOLICY               4203
#define HLP_IPV6_SET_PREFIXPOLICY_EX            4204
#define HLP_IPV6_DEL_PREFIXPOLICY               4205
#define HLP_IPV6_DEL_PREFIXPOLICY_EX            4206
#define HLP_IPV6_SHOW_PREFIXPOLICY              4207
#define HLP_IPV6_SHOW_PREFIXPOLICY_EX           4208

#define HLP_IPV6_DEL_NEIGHBORS                  4305
#define HLP_IPV6_DEL_NEIGHBORS_EX               4306
#define HLP_IPV6_SHOW_NEIGHBORS                 4307
#define HLP_IPV6_SHOW_NEIGHBORS_EX              4308

#define HLP_IPV6_ADD_ROUTE                      4401
#define HLP_IPV6_ADD_ROUTE_EX                   4402
#define HLP_IPV6_SET_ROUTE                      4403
#define HLP_IPV6_SET_ROUTE_EX                   4404
#define HLP_IPV6_DEL_ROUTE                      4405
#define HLP_IPV6_DEL_ROUTE_EX                   4406
#define HLP_IPV6_SHOW_ROUTES                    4407
#define HLP_IPV6_SHOW_ROUTES_EX                 4408

#define HLP_IPV6_ADD_ADDRESS                    4501
#define HLP_IPV6_ADD_ADDRESS_EX                 4502
#define HLP_IPV6_SET_ADDRESS                    4503
#define HLP_IPV6_SET_ADDRESS_EX                 4504
#define HLP_IPV6_DEL_ADDRESS                    4505
#define HLP_IPV6_DEL_ADDRESS_EX                 4506
#define HLP_IPV6_SHOW_ADDRESS                   4507
#define HLP_IPV6_SHOW_ADDRESS_EX                4508

#define HLP_IPV6_SHOW_SITEPREFIXES              4607
#define HLP_IPV6_SHOW_SITEPREFIXES_EX           4608

#define HLP_IPV6_ADD_V6V4TUNNEL                 4701
#define HLP_IPV6_ADD_V6V4TUNNEL_EX              4702

#define HLP_IPV6_DEL_DESTINATIONCACHE           4805
#define HLP_IPV6_DEL_DESTINATIONCACHE_EX        4806
#define HLP_IPV6_SHOW_DESTINATIONCACHE          4807
#define HLP_IPV6_SHOW_DESTINATIONCACHE_EX       4808

#define HLP_IPV6_SET_INTERFACE                  4903
#define HLP_IPV6_SET_INTERFACE_EX               4904
#define HLP_IPV6_DEL_INTERFACE                  4905
#define HLP_IPV6_DEL_INTERFACE_EX               4906
#define HLP_IPV6_SHOW_INTERFACE                 4907
#define HLP_IPV6_SHOW_INTERFACE_EX              4908

#define HLP_IPV6_SET_MOBILITY                   5103
#define HLP_IPV6_SET_MOBILITY_EX                5104
#define HLP_IPV6_SHOW_MOBILITY                  5107
#define HLP_IPV6_SHOW_MOBILITY_EX               5108

#define HLP_IPV6_SHOW_JOINS                     5207
#define HLP_IPV6_SHOW_JOINS_EX                  5208

#define HLP_IPV6_RESET                          5301
#define HLP_IPV6_RESET_EX                       5302

#define HLP_IPV6_SET_STATE                      5403
#define HLP_IPV6_SET_STATE_EX                   5404
#define HLP_IPV6_SHOW_STATE                     5407
#define HLP_IPV6_SHOW_STATE_EX                  5408

#define HLP_IPV6_ADD_DNS                        5501
#define HLP_IPV6_ADD_DNS_EX                     5502
#define HLP_IPV6_DEL_DNS                        5505
#define HLP_IPV6_DEL_DNS_EX                     5506
#define HLP_IPV6_SHOW_DNS                       5507
#define HLP_IPV6_SHOW_DNS_EX                    5508


//
// Port Proxy.
//
#define HLP_PP_ADD_V4TOV4                       7001
#define HLP_PP_ADD_V4TOV4_EX                    7002
#define HLP_PP_SET_V4TOV4                       7003
#define HLP_PP_SET_V4TOV4_EX                    7004
#define HLP_PP_DEL_V4TOV4                       7005
#define HLP_PP_DEL_V4TOV4_EX                    7006
#define HLP_PP_SHOW_V4TOV4                      7007
#define HLP_PP_SHOW_V4TOV4_EX                   7008

#define HLP_PP_ADD_V4TOV6                       7011
#define HLP_PP_ADD_V4TOV6_EX                    7012
#define HLP_PP_SET_V4TOV6                       7013
#define HLP_PP_SET_V4TOV6_EX                    7014
#define HLP_PP_DEL_V4TOV6                       7015
#define HLP_PP_DEL_V4TOV6_EX                    7016
#define HLP_PP_SHOW_V4TOV6                      7017
#define HLP_PP_SHOW_V4TOV6_EX                   7018

#define HLP_PP_ADD_V6TOV4                       7021
#define HLP_PP_ADD_V6TOV4_EX                    7022
#define HLP_PP_SET_V6TOV4                       7023
#define HLP_PP_SET_V6TOV4_EX                    7024
#define HLP_PP_DEL_V6TOV4                       7025
#define HLP_PP_DEL_V6TOV4_EX                    7026
#define HLP_PP_SHOW_V6TOV4                      7027
#define HLP_PP_SHOW_V6TOV4_EX                   7028

#define HLP_PP_ADD_V6TOV6                       7031
#define HLP_PP_ADD_V6TOV6_EX                    7032
#define HLP_PP_SET_V6TOV6                       7033
#define HLP_PP_SET_V6TOV6_EX                    7034
#define HLP_PP_DEL_V6TOV6                       7035
#define HLP_PP_DEL_V6TOV6_EX                    7036
#define HLP_PP_SHOW_V6TOV6                      7037
#define HLP_PP_SHOW_V6TOV6_EX                   7038

#define HLP_PP_SHOW_ALL                         7047
#define HLP_PP_SHOW_ALL_EX                      7048

#define MSG_ROUTING_STATE                       5001
#define MSG_SITELOCALS_STATE                    5002
#define MSG_RESOLUTION_STATE                    5003
#define MSG_RELAY_NAME                          5004
#define MSG_MINUTES                             5005
#define MSG_RESOLUTION_INTERVAL                 5006
#define MSG_UNDO_ON_STOP_STATE                  5007
#define MSG_STRING                              5008
#define MSG_CSTRING                             5009
#define MSG_INTERFACE_ROUTING_STATE             5010
#define MSG_IP6TO4_STATE                        5011
#define MSG_INTERFACE_HEADER                    5012
#define MSG_6OVER4_STATE                        5013
#define MSG_V4COMPAT_STATE                      5014
#define MSG_ROUTER_NAME                         5015
#define MSG_SECONDS                             5016
#define MSG_ISATAP_STATE                        5017

// strings from ipv6
#define STRING_LOOPBACK                         6001
#define STRING_TUNNEL_AUTO                      6002
#define STRING_TUNNEL_6TO4                      6003
#define STRING_SYSTEM                           6004
#define STRING_MANUAL                           6005
#define STRING_AUTOCONF                         6006
#define STRING_RIP                              6007
#define STRING_OSPF                             6008
#define STRING_BGP                              6009
#define STRING_IDRP                             6010
#define STRING_IGRP                             6011
#define STRING_PUBLIC                           6012
#define STRING_TEMPORARY                        6013
#define STRING_DHCP                             6014
#define STRING_WELLKNOWN                        6015
#define STRING_RA                               6016
#define STRING_RANDOM                           6017
#define STRING_LL_ADDRESS                       6018
#define STRING_OTHER                            6019

#define STRING_DISCONNECTED                     6101
#define STRING_RECONNECTED                      6102
#define STRING_CONNECTED                        6103
#define STRING_UNKNOWN                          6104

#define STRING_INTERFACE                        6201
#define STRING_LINK                             6202
#define STRING_SUBNET                           6203
#define STRING_ADMIN                            6204
#define STRING_SITE                             6205
#define STRING_ORG                              6208
#define STRING_GLOBAL                           6214

#define STRING_INVALID                          6301
#define STRING_DUPLICATE                        6302
#define STRING_TENTATIVE                        6303
#define STRING_DEPRECATED                       6304
#define STRING_PREFERRED                        6305

#define STRING_YES                              6401
#define STRING_NO                               6402
#define STRING_NEVER                            6403

// error messages from ipv6

#define IPV6_MESSAGE_126                       10126
#define IPV6_MESSAGE_127                       10127
#define IPV6_MESSAGE_128                       10128
#define IPV6_MESSAGE_129                       10129

// error messages for IfIp
#define EMSG_PROTO_NOT_INSTALLED                11001
#define EMSG_NO_WRITE_LOCK                      11002
#define EMSG_REBOOT_NEEDED                      11003
#define EMSG_INVALID_ADDRESS                    11004
#define EMSG_INVALID_INTERFACE                  11044
#define EMSG_CANT_PERSIST_AGING_ROUTES          11045

#define DMP_IPV6_HEADER_COMMENTS                  20001
#define DMP_IPV6_FOOTER_COMMENTS                  20002

#define MSG_IPV6_TABLE_HDR                        50001
#define MSG_IPV6_ENTRY_LONG                       50002
#define MSG_IPV6_CREDENTIALS                      50003
#define MSG_IPV6_ENTRY_SHORT                      50004

#define MSG_IPV6_GLOBAL_PARAMETERS                51005
#define MSG_IPV6_PRIVACY_PARAMETERS               51006
#define MSG_IPV6_PREFIX_POLICY_HDR                51007
#define MSG_IPV6_PREFIX_POLICY                    51008
#define MSG_IPV6_SITE_PREFIX_HDR                  51009
#define MSG_IPV6_SITE_PREFIX                      51010
#define MSG_IPV6_INTERFACE_HDR                    51011
#define MSG_IPV6_INTERFACE                        51012
#define MSG_IPV6_INTERFACE_VERBOSE                51013
#define MSG_IPV6_MOBILITY_PARAMETERS              51014
#define MSG_IPV6_NEIGHBOR_CACHE_HDR               51015
#define MSG_IPV6_NEIGHBOR_CACHE_ENTRY             51016
#define MSG_IPV6_NEIGHBOR_INCOMPLETE              51017
#define MSG_IPV6_NEIGHBOR_PROBE                   51018
#define MSG_IPV6_NEIGHBOR_DELAY                   51019
#define MSG_IPV6_NEIGHBOR_STALE                   51020
#define MSG_IPV6_NEIGHBOR_REACHABLE               51021
#define MSG_IPV6_NEIGHBOR_PERMANENT               51022
#define MSG_IPV6_NEIGHBOR_UNKNOWN                 51023
#define MSG_IPV6_NEIGHBOR_ISROUTER                51024
#define MSG_IPV6_NEIGHBOR_UNREACHABLE             51025
#define MSG_IPV6_INTERFACE_SCOPE                  51026
#define MSG_IPV6_ND_ENABLED                       51027
#define MSG_IPV6_SENDS_RAS                        51029
#define MSG_IPV6_FORWARDS                         51030
#define MSG_IPV6_LL_ADDRESS                       51031
#define MSG_IPV6_REMOTE_LL_ADDRESS                51032
#define MSG_IPV6_ADDRESS_HDR                      51033
#define MSG_IPV6_ADDRESS_HDR_VERBOSE              51034
#define MSG_IPV6_UNICAST_ADDRESS                  51035
#define MSG_IPV6_UNICAST_ADDRESS_VERBOSE          51036
#define MSG_IPV6_ANYCAST_ADDRESS                  51037
#define MSG_IPV6_ANYCAST_ADDRESS_VERBOSE          51038
#define MSG_IPV6_MULTICAST_ADDRESS_HDR            51039
#define MSG_IPV6_MULTICAST_ADDRESS                51040
#define MSG_IPV6_MULTICAST_ADDRESS_VERBOSE        51041
#define MSG_IPV6_PREFIX_ORIGIN                    51042
#define MSG_IPV6_IID_ORIGIN                       51043

#define MSG_IPV6_DESTINATION_HDR                  51101
#define MSG_IPV6_DESTINATION_ENTRY                51102
#define MSG_IPV6_DESTINATION_NEXTHOP              51103

#define MSG_IPV6_DESTINATION_HDR_VERBOSE          51201
#define MSG_IPV6_DESTINATION_ENTRY_VERBOSE        51202
#define MSG_IPV6_DESTINATION_NEXTHOP_VERBOSE      51203
#define MSG_IPV6_DESTINATION_SOURCE_ADDR          51204
#define MSG_IPV6_IF_SPECIFIC                      51205
#define MSG_IPV6_ZONE_SPECIFIC                    51206
#define MSG_IPV6_CAREOF                           51207
#define MSG_IPV6_PMTU_PROBE_TIME                  51208
#define MSG_IPV6_ICMP_ERROR_TIME                  51209
#define MSG_IPV6_STALE                            51210

#define MSG_IPV6_ROUTE_TABLE_HDR                  51305
#define MSG_IPV6_ROUTE_TABLE_ENTRY                51306
#define MSG_IPV6_ROUTE_TABLE_ENTRY_VERBOSE        51307
#define MSG_IPV6_INTEGER                          51308

#define MSG_PORT_PROXY_HEADER                     52001
#define MSG_PORT_PROXY                            52002
#define DMP_PP_HEADER_COMMENTS                    52003
#define DMP_PP_FOOTER_COMMENTS                    52004

// msgs for ifip

#define MSG_DHCP                                50021
#define MSG_STATIC                              50022
#define MSG_IPADDR_LIST                         50023
#define MSG_IPADDR_LIST1                        50024
#define MSG_IP6TO4_HEADER                         50025
#define MSG_OPTIONS_LIST                        50026
#define MSG_IFMETRIC                            50028
#define MSG_GATEWAY                             50030
#define MSG_DNS_SERVER_HEADER                   50031
#define MSG_DNS_SERVER                          50032
#define MSG_WINS_HDR                            50033
#define MSG_WINS_DHCP                           50034
#define MSG_ADDR1                               50035
#define MSG_ADDR2                               50036
#define MSG_OPTION                              50037
#define MSG_NONE                                50038
#define MSG_DEBUG_HDR                           50039
#define MSG_DNS_DHCP_HDR                        50040
#define MSG_WINS_DHCP_HDR                       50041
#define DMP_IP6TO4_HEADER                       50051
#define DMP_IP6TO4_FOOTER                       50052
#define DMP_IP6TO4_INTERFACE_HEADER             50053
#define DMP_ISATAP_HEADER                       50061
#define DMP_ISATAP_FOOTER                       50062

#define MSG_TEREDO_PARAMETERS                   50070

#define MSG_NO_SUCH_IF                          60006
#define MSG_IP_NO_ENTRIES                       60015
#define MSG_CTRL_C_TO_QUIT                      60062

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\parse.h ===
//=============================================================================
// Copyright (c) Microsoft Corporation
// Abstract:
//      This module implements string-address conversion functions.
//=============================================================================

WCHAR *
FormatIPv6Address(
    IN IN6_ADDR *Address,
    IN DWORD dwScopeId
    );

DWORD
GetIpv6Address(
    IN PWCHAR pwszArgument,
    OUT IN6_ADDR *pipAddress
    );

WCHAR *
FormatIPv4Address(
    IN IN_ADDR *Address
    );

DWORD
GetIpv4Address(
    IN PWCHAR pwszArgument,
    OUT IN_ADDR *pipAddress
    );

WCHAR *
FormatIPv6Prefix(
    IN IPv6Addr *Address,
    IN ULONG Length
    );

DWORD
GetIpv6Prefix(
    IN PWCHAR pwszArgument,
    OUT IN6_ADDR *pipAddress,
    OUT DWORD *dwPrefixLength
    );

WCHAR *
FormatLinkLayerAddress(
    IN ULONG Length,
    IN UCHAR *addr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ipv6mon\teredo.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    teredo.c

Abstract:

    Teredo commands.

Author:

    Mohit Talwar (mohitt) Wed Nov 07 22:18:53 2001

--*/

#include "precomp.h"

//
// The following enums and defines should be kept consistent with
// teredo.h in 6to4svc.
//

//
// TEREDO_TYPE
//
// Define the type of the teredo service.
//

typedef enum {
    TEREDO_DEFAULT = 0,
    TEREDO_CLIENT,
    TEREDO_SERVER,
    TEREDO_DISABLED,
    TEREDO_AUTOMATIC,
    TEREDO_MAXIMUM,
} TEREDO_TYPE, *PTEREDO_TYPE;

#define KEY_TEREDO_REFRESH_INTERVAL   L"RefreshInterval"
#define KEY_TEREDO_TYPE               L"Type"
#define KEY_TEREDO_SERVER_NAME        L"ServerName"
#define KEY_TEREDO L"System\\CurrentControlSet\\Services\\Teredo"

PWCHAR pwszTypeString[] = {
    TOKEN_VALUE_DEFAULT,
    TOKEN_VALUE_CLIENT,
    TOKEN_VALUE_SERVER,
    TOKEN_VALUE_DISABLED,
    TOKEN_VALUE_AUTOMATIC,
};

/////////////////////////////////////////////////////////////////////////////
// Commands related to teredo
/////////////////////////////////////////////////////////////////////////////

DWORD
ShowTeredo(
    IN FORMAT Format
    )
{
    HKEY hKey = INVALID_HANDLE_VALUE;
    TEREDO_TYPE tyType;
    WCHAR pwszServerName[NI_MAXHOST] = TOKEN_VALUE_DEFAULT;
    ULONG ulRefreshInterval;

    (VOID) RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, KEY_TEREDO, 0, KEY_READ, &hKey);

    tyType = GetInteger(hKey, KEY_TEREDO_TYPE, TEREDO_DEFAULT);
    if (tyType >= TEREDO_MAXIMUM) {
        tyType = TEREDO_DEFAULT;
    }
    GetString(hKey, KEY_TEREDO_SERVER_NAME, pwszServerName, NI_MAXHOST);
    ulRefreshInterval = GetInteger(hKey, KEY_TEREDO_REFRESH_INTERVAL, 0);
    
    if (hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if (Format == FORMAT_DUMP) {
        if ((tyType != TEREDO_DEFAULT) ||
            (wcscmp(pwszServerName, TOKEN_VALUE_DEFAULT) != 0) ||
            (ulRefreshInterval != 0)) {

            DisplayMessageT(DMP_IPV6_SET_TEREDO);
            if (tyType != TEREDO_DEFAULT) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_TYPE, 
                                pwszTypeString[tyType]);
            }
            if (wcscmp(pwszServerName, TOKEN_VALUE_DEFAULT) != 0) {
                DisplayMessageT(DMP_STRING_ARG, TOKEN_SERVERNAME, 
                                pwszServerName);
            }
            if (ulRefreshInterval != 0) {
                DisplayMessageT(
                    DMP_INTEGER_ARG, TOKEN_REFRESH_INTERVAL, ulRefreshInterval);
            }
            DisplayMessage(g_hModule, MSG_NEWLINE);
        }
    } else {
        DisplayMessage(
            g_hModule,
            MSG_TEREDO_PARAMETERS,
            pwszTypeString[tyType],
            pwszServerName);
        if (ulRefreshInterval == 0) {
            DisplayMessage(g_hModule, MSG_STRING, TOKEN_VALUE_DEFAULT);
        } else {
            DisplayMessage(g_hModule, MSG_SECONDS, ulRefreshInterval);
        }
    }
    return NO_ERROR;
}


DWORD
HandleSetTeredo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    DWORD dwErr = NO_ERROR;
    HKEY hKey = INVALID_HANDLE_VALUE;
    TEREDO_TYPE tyType = 0;
    PWCHAR pwszServerName = NULL;
    ULONG ulRefreshInterval = 0;

    BOOL bType, bServer, bRefreshInterval;

    TAG_TYPE pttTags[] = {{TOKEN_TYPE,              FALSE, FALSE},
                          {TOKEN_SERVERNAME,        FALSE, FALSE},
                          {TOKEN_REFRESH_INTERVAL,  FALSE, FALSE}};
    DWORD    rgdwTagType[sizeof(pttTags) / sizeof(TAG_TYPE)];

    TOKEN_VALUE rgtvEnums[] = {
        { TOKEN_VALUE_DEFAULT,      TEREDO_DEFAULT },
        { TOKEN_VALUE_CLIENT,       TEREDO_CLIENT },
        { TOKEN_VALUE_SERVER,       TEREDO_SERVER },
        { TOKEN_VALUE_DISABLED,     TEREDO_DISABLED },
        { TOKEN_VALUE_AUTOMATIC,    TEREDO_AUTOMATIC },
    };    

    DWORD    i;

    bType = bServer = bRefreshInterval = FALSE;
    
    // Parse arguments
    
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    for (i = 0; i < (dwArgCount - dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0:                 // TYPE
            dwErr = MatchEnumTag(NULL,
                                 ppwcArguments[dwCurrentIndex + i],
                                 NUM_TOKENS_IN_TABLE(rgtvEnums),
                                 rgtvEnums,
                                 (PDWORD) &tyType);
            if (dwErr != NO_ERROR) {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
            bType = TRUE;
            break;
            
        case 1:                 // SERVERNAME
            pwszServerName = ppwcArguments[dwCurrentIndex + i];
            bServer = TRUE;
            break;

        case 2:                 // REFRESHINTERVAL
            ulRefreshInterval = wcstoul(
                ppwcArguments[dwCurrentIndex + i], NULL, 10);
            bRefreshInterval = TRUE;
            break;

        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        if (dwErr != NO_ERROR) {
            return dwErr;
        }
    }

    // Now do the sets

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, KEY_TEREDO, 0, NULL, 0,
                           KEY_READ | KEY_WRITE, NULL, &hKey, NULL);
    if (dwErr != NO_ERROR) {
        return dwErr;
    }

    if (bType) {                // 0 (TEREDO_DEFAULT) resets to default.
        dwErr = SetInteger(hKey, KEY_TEREDO_TYPE, tyType);
        if (dwErr != NO_ERROR)
            goto Bail;
    }

    
    if (bServer) {              // "default" resets to default.
        dwErr = SetString(hKey, KEY_TEREDO_SERVER_NAME, pwszServerName);
        if (dwErr != NO_ERROR)
            goto Bail;
    }

    if (bRefreshInterval) {     // 0 resets to default.
        dwErr = SetInteger(
            hKey, KEY_TEREDO_REFRESH_INTERVAL, ulRefreshInterval);
        if (dwErr != NO_ERROR)
            goto Bail;
    }

Bail:
    RegCloseKey(hKey);

    Ip6to4PokeService();

    return ERROR_OKAY;
}

DWORD
HandleShowTeredo(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return ShowTeredo(FORMAT_NORMAL);
}

DWORD
ResetTeredo(
    VOID
    )
{
    DWORD dwErr;

    // Nuke teredo parameters.
    dwErr = ResetKey(HKEY_LOCAL_MACHINE, KEY_TEREDO);
    if ((dwErr != NO_ERROR) && (dwErr != ERROR_FILE_NOT_FOUND)) {
        return dwErr;
    }

    // Poke the teredo service.
    Ip6to4PokeService();

    return ERROR_OKAY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\genproxy\genproxy.c ===
//
// genproxy.c - Generic application level proxy for IPv6/IPv4
//
// This program accepts connections on a socket with a given address family
// and port, and forwards them on a socket of the other address family to
// a given address (default loopback) using the same port.
//
// Basically, it makes an unmodified IPv4 server look like an IPv6 server
// (or vice-versa).  Typically, the proxy will run on the same machine as
// the server it is fronting, but that doesn't have to be the case.
//
// Copyright 1996 - 2000 Microsoft Corporation.
// All rights reserved.
//

#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <wspiapi.h>


//
// What should the proxy server pretend to be?
// Default is an IPv6 web server.
//
#define DEFAULT_PROXY_FAMILY     PF_INET6
#define DEFAULT_SOCKTYPE         SOCK_STREAM
#define DEFAULT_PORT             "http"

//
// Configuration parameters.
//
#define BUFFER_SIZE (4 * 1024)  // Big enough?


typedef struct PerConnection PerConnection;

//
// Information we keep for each direction of a bi-directional connection.
//
typedef struct PerOperation {
    BOOL Inbound;  // Is this the "receive from client, send to server" side?
    BOOL Receiving;  // Is this operation a recv?
    WSABUF Buffer;
    WSAOVERLAPPED Overlapped;
    PerConnection *Connection;
} PerOperation;

//
// Information we keep for each client connection.
//
typedef struct PerConnection {
    int Number;
    BOOL HalfOpen;  // Has one side or the other stopped sending?
    SOCKET Client;
    SOCKET Server;
    PerOperation Inbound;
    PerOperation Outbound;
} PerConnection;

//
// Global variables
//
BOOL Verbose = FALSE;

//
// Create state information for a client.
//
PerConnection*
CreateConnectionState(Client, Server)
{
    static TotalConnections = 1;
    PerConnection *Conn;

    //
    // Allocate space for a PerConnection structure and two buffers.
    //
    Conn = (PerConnection *)malloc(sizeof(*Conn) + (2 * BUFFER_SIZE));
    if (Conn == NULL)
        return NULL;

    //
    // Fill everything in.
    //
    Conn->Number = TotalConnections++;
    Conn->HalfOpen = FALSE;
    Conn->Client = Client;
    Conn->Server = Server;
    Conn->Inbound.Inbound = TRUE;  // Recv from client, send to server.
    Conn->Inbound.Receiving = TRUE;  // Start out receiving.
    Conn->Inbound.Buffer.len = BUFFER_SIZE;
    Conn->Inbound.Buffer.buf = (char *)(Conn + 1);
    Conn->Inbound.Connection = Conn;
    Conn->Outbound.Inbound = FALSE;  // Recv from server, send to client.
    Conn->Outbound.Receiving = TRUE;  // Start out receiving.
    Conn->Outbound.Buffer.len = BUFFER_SIZE;
    Conn->Outbound.Buffer.buf = Conn->Inbound.Buffer.buf + BUFFER_SIZE;
    Conn->Outbound.Connection = Conn;

    printf("Created Connecton #%d\n", Conn->Number);

    return Conn;
}


void Usage(char *ProgName) {
    fprintf(stderr, "\nGeneric server proxy.\n");
    fprintf(stderr, "\n%s [-f family] [-p port] [-s server] [-v]\n\n",
            ProgName);
    fprintf(stderr, "  family\tFamily (PF_INET or PF_INET6) proxy exports.  (default %s)\n",
            (DEFAULT_PROXY_FAMILY == PF_INET) ? "PF_INET" : "PF_INET6");
    fprintf(stderr, "  port\t\tPort on which to bind.  (default %s)\n",
            DEFAULT_PORT);
    fprintf(stderr, "  server\tName or address to forward requests to.  (default: loopback)\n");
    WSACleanup();
    exit(1);
}


LPSTR DecodeError(int ErrorCode)
{
    static char Message[1024];

    // If this program was multi-threaded, we'd want to use
    // FORMAT_MESSAGE_ALLOCATE_BUFFER instead of a static buffer here.
    // (And of course, free the buffer when we were done with it)

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, ErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPSTR)Message, 1024, NULL);
    return Message;
}


//
// Find out how many processors are on the system.
//
DWORD
GetNumberOfProcessors(void)
{
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);
    return SystemInfo.dwNumberOfProcessors;
}


//
// This routine waits for asynchronous operations to complete on
// a particular completion port and handles them.
//
// There should be one of these threads per processor on the machine.
//
WINAPI
CompletionPortHandler(LPVOID Param)
{
    HANDLE CompletionPort = *(HANDLE *)Param;
    PerConnection *Connection;
    PerOperation *Operation;
    OVERLAPPED *Overlapped;
    DWORD BytesTransferred, AmountSent, AmountReceived, RecvFlags;
    int RetVal;

    while (1) {
        //
        // Wait for one of the asych operations to complete.
        //
        RetVal = GetQueuedCompletionStatus(CompletionPort, &BytesTransferred,
                                           (PULONG_PTR)&Connection,
                                           &Overlapped, INFINITE);
        //
        // Retrieve the state of this operation.
        //
        Operation = CONTAINING_RECORD(Overlapped, PerOperation, Overlapped);
        if (Operation->Connection != Connection) {
            printf("Pointer mismatch in completion status!\n");
            continue;
        }

        if (Verbose) {
            printf("Handling %s %s on %s side of connection #%d\n",
                   RetVal ? "completed" : "aborted",
                   Operation->Receiving ? "recv" : "send",
                   Operation->Inbound ? "inbound" : "outbound",
                   Connection->Number);
        }

        if (RetVal == 0) {
            if (GetLastError() == 64) {
                printf("Connection #%d %s was reset\n", Connection->Number,
                       Operation->Inbound ? "inbound" : "outbound");
                // Fall through, it'll be treated as a close...
            } else {
                fprintf(stderr, "GetQueuedCompletionStatus() failed with error %d: %s\n",
                        GetLastError(), DecodeError(GetLastError()));
                // REVIEW: CloseConnection?
                continue;
            }
        }

        if (Operation->Receiving == TRUE) {
            //
            // We just completed a recv.
            // Look for closed/closing connection.
            //
            if (BytesTransferred == 0) {
                if (Operation->Inbound == TRUE) {
                    //
                    // The client has closed its side of the connection.
                    //
                    if (Connection->HalfOpen == FALSE) {
                        // Server is still around,
                        // tell it that the client quits.
                        shutdown(Connection->Server, SD_SEND);
                        Connection->HalfOpen = TRUE;
                        printf("Connection #%d Client quit sending\n",
                               Connection->Number);
                    } else {
                        // Server already quit sending, so close the sockets.
                        printf("Connection #%d Client quit too\n",
                               Connection->Number);
                        closesocket(Connection->Client);
                        closesocket(Connection->Server);
                        free(Connection);
                    }
                } else {
                    //
                    // The server has closed its side of the connection.
                    //
                    if (Connection->HalfOpen == FALSE) {
                        // Client is still around,
                        // tell it that the server quits.
                        shutdown(Connection->Client, SD_SEND);
                        Connection->HalfOpen = TRUE;
                        printf("Connection #%d Server quit sending\n",
                               Connection->Number);
                    } else {
                        // Client already quit sending, so close the sockets.
                        printf("Connection #%d Server quit too\n",
                               Connection->Number);
                        closesocket(Connection->Client);
                        closesocket(Connection->Server);
                        free(Connection);
                    }
                }

                if (Verbose)
                    printf("Leaving Recv Handler\n");
                continue;
            }

            //
            // Connection is still active, and we received some data.
            // Post a send request to forward it onward.
            //
            Operation->Receiving = FALSE;
            Operation->Buffer.len = BytesTransferred;
            RetVal = WSASend(Operation->Inbound ? Connection->Server :
                             Connection->Client, &Operation->Buffer, 1,
                             &AmountSent, 0, Overlapped, NULL);
            if ((RetVal == SOCKET_ERROR) &&
                (WSAGetLastError() != WSA_IO_PENDING)) {
                //
                // Something bad happened.
                //
                fprintf(stderr, "WSASend() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                closesocket(Connection->Client);
                closesocket(Connection->Server);
                free(Connection);
            }
            
            if (Verbose)
                printf("Leaving Recv Handler\n");
            
        } else {
            //
            // We just completed a send.
            //
            if (BytesTransferred != Operation->Buffer.len) {
                fprintf(stderr, "WSASend() didn't send entire buffer!\n");
                goto CloseConnection;
            }

            //
            // Post another recv request since we but live to serve.
            //
            RecvFlags = 0;
            Operation->Receiving = TRUE;
            Operation->Buffer.len = BUFFER_SIZE;
            RetVal = WSARecv(Operation->Inbound ? Connection->Client :
                             Connection->Server, &Operation->Buffer, 1,
                             &AmountReceived, &RecvFlags, Overlapped, NULL);
            if ((RetVal == SOCKET_ERROR) &&
                (WSAGetLastError() != WSA_IO_PENDING)) {
                //
                // Something bad happened.
                //
                fprintf(stderr, "WSARecv() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
              CloseConnection:
                closesocket(Connection->Client);
                closesocket(Connection->Server);
                free(Connection);
            }
        }
    }
}


//
// Start serving on this socket.
//
StartProxy(SOCKET Proxy, ADDRINFO *ServerAI)
{
    char Hostname[NI_MAXHOST];
    int FromLen, AmountReceived, RetVal;
    SOCKADDR_STORAGE From;
    PerConnection *Conn;
    SOCKET Client, Server;
    DWORD NumberOfWorkers, Flags;
    HANDLE *CompletionPorts;
    unsigned int Loop;

    //
    // Create a completion port and a worker thread to service it.
    // Do this once for each processor on the system.
    //
    NumberOfWorkers = GetNumberOfProcessors();
    CompletionPorts = malloc(sizeof(HANDLE) * NumberOfWorkers);
    for (Loop = 0; Loop < NumberOfWorkers; Loop++) {
        HANDLE WorkerThread;

        CompletionPorts[Loop] = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                                       NULL, 0, 0);
        if (CompletionPorts[Loop] == NULL) {
            fprintf(stderr, "Couldn't create completion port, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Proxy);
            WSACleanup();
            return -1;
        }

        WorkerThread = CreateThread(NULL, 0, CompletionPortHandler,
                                    &CompletionPorts[Loop], 0, NULL);
        if (WorkerThread == NULL) {
            fprintf(stderr, "Couldn't create worker thread, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Proxy);
            WSACleanup();
            return -1;
        }
    }

    //
    // We now put the server into an eternal loop,
    // serving requests as they arrive.
    //
    Loop = 0;
    while(1) {

        //
        // Wait for a client to connect.
        //
        if (Verbose) {
            printf("Before accept\n");
        }
        FromLen = sizeof(From);
        Client = accept(Proxy, (LPSOCKADDR)&From, &FromLen);
        if (Client == INVALID_SOCKET) {
            if (WSAGetLastError() == 10022)
                continue;
            fprintf(stderr, "accept() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            break;
        }
        if (Verbose) {
            if (getnameinfo((LPSOCKADDR)&From, FromLen, Hostname,
                            sizeof(Hostname), NULL, 0, NI_NUMERICHOST) != 0)
                strcpy(Hostname, "<unknown>");
            printf("\nAccepted connection from %s\n", Hostname);
        }

        //
        // Connect to real server on client's behalf.
        //
        Server = socket(ServerAI->ai_family, ServerAI->ai_socktype,
                        ServerAI->ai_protocol);
        if (Server == INVALID_SOCKET) {
            fprintf(stderr,"Error opening real server socket, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            continue;
        }

        if (connect(Server, ServerAI->ai_addr, ServerAI->ai_addrlen) == SOCKET_ERROR) {
            fprintf(stderr, "connect() to server failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            closesocket(Server);
            continue;
        }
        if (Verbose) {
            FromLen = sizeof(From);
            if (getpeername(Server, (LPSOCKADDR)&From, &FromLen) == SOCKET_ERROR) {
                fprintf(stderr, "getpeername() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
            } else {
                if (getnameinfo((LPSOCKADDR)&From, FromLen, Hostname,
                        sizeof(Hostname), NULL, 0, NI_NUMERICHOST) != 0)
                    strcpy(Hostname, "<unknown>");
                printf("Connected to server %s, port %d\n",
                       Hostname, ntohs(SS_PORT(&From)));
            }
        }

        Conn = CreateConnectionState(Client, Server);

        if (CreateIoCompletionPort((HANDLE) Client, CompletionPorts[Loop],
                                   (ULONG_PTR)Conn, 0) == NULL) {
            fprintf(stderr, "Couldn't attach completion port, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            closesocket(Server);
            free(Conn);
            continue;
        }
        if (CreateIoCompletionPort((HANDLE) Server, CompletionPorts[Loop],
                                   (ULONG_PTR)Conn, 0) == NULL) {
            fprintf(stderr, "Couldn't attach completion port, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            closesocket(Server);
            free(Conn);
            continue;
        }

        //
        // Start things going by posting a recv on both client and server.
        //
        Flags = 0;
        RetVal = WSARecv(Client, &(Conn->Inbound.Buffer), 1, &AmountReceived,
                         &Flags, &(Conn->Inbound.Overlapped), NULL);

        if ((RetVal == SOCKET_ERROR) &&
            (WSAGetLastError() != WSA_IO_PENDING)) {
            //
            // Something bad happened.
            //
            fprintf(stderr, "WSARecv() on Client failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            closesocket(Server);
            free(Conn);
            continue;
        }

        Flags = 0;
        RetVal = WSARecv(Server, &(Conn->Outbound.Buffer), 1, &AmountReceived,
                         &Flags, &(Conn->Outbound.Overlapped), NULL);
        if ((RetVal == SOCKET_ERROR) &&
            (WSAGetLastError() != WSA_IO_PENDING)) {
            //
            // Something bad happened.
            //
            fprintf(stderr, "WSARecv() on Server failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(Client);
            closesocket(Server);
            free(Conn);
            continue;
        }

        if (++Loop == NumberOfWorkers)
            Loop = 0;
    }

    //
    // Only get here if something bad happened.
    //
    closesocket(Proxy);
    WSACleanup();
    return -1;
}


int __cdecl
main(int argc, char **argv)
{
    int ServerFamily;
    int ProxyFamily = DEFAULT_PROXY_FAMILY;
    char *Port = DEFAULT_PORT;
    char *Address = NULL;
    int i, RetVal;
    WSADATA wsaData;
    ADDRINFO Hints, *AI;
    SOCKET Proxy;

    // Parse arguments
    if (argc > 1) {
        for (i = 1;i < argc; i++) {
            if ((argv[i][0] == '-') || (argv[i][0] == '/') &&
                (argv[i][1] != 0) && (argv[i][2] == 0)) {
                switch(tolower(argv[i][1])) {
                case 'f':
                    if (!argv[i+1])
                        Usage(argv[0]);
                    if (!strcmp(argv[i+1], "PF_INET"))
                        ProxyFamily = PF_INET;
                    else if (!strcmp(argv[i+1], "PF_INET6"))
                        ProxyFamily = PF_INET6;
                    else
                        Usage(argv[0]);
                    i++;
                    break;

                case 's':
                    if (argv[i+1]) {
                        if (argv[i+1][0] != '-') {
                            Address = argv[++i];
                            break;
                        }
                    }
                    Usage(argv[0]);
                    break;

                case 'p':
                    if (argv[i+1]) {
                        if (argv[i+1][0] != '-') {
                            Port = argv[++i];
                            break;
                        }
                    }
                    Usage(argv[0]);
                    break;

                case 'v':
                    Verbose = TRUE;
                    break;

                default:
                    Usage(argv[0]);
                    break;
                }
            } else
                Usage(argv[0]);
        }
    }

    ServerFamily = (ProxyFamily == PF_INET6) ? PF_INET : PF_INET6;

    // Ask for Winsock version 2.2.
    if ((RetVal = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
        fprintf(stderr, "WSAStartup failed with error %d: %s\n",
                RetVal, DecodeError(RetVal));
        WSACleanup();
        return -1;
    }
    
    if (Port == NULL) {
        Usage(argv[0]);
    }

    //
    // Determine parameters to use to create and bind the proxy's socket.
    //
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = ProxyFamily;
    Hints.ai_socktype = DEFAULT_SOCKTYPE;
    Hints.ai_flags = AI_PASSIVE;
    RetVal = getaddrinfo(NULL, Port, &Hints, &AI);
    if (RetVal != 0) {
        fprintf(stderr, "getaddrinfo failed with error %d: %s\n",
                RetVal, gai_strerror(RetVal));
        WSACleanup();
        return -1;
    }

    Proxy = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
    if (Proxy == INVALID_SOCKET){
        fprintf(stderr, "socket() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
        freeaddrinfo(AI);
        WSACleanup();
        return -1;
    }

    if (bind(Proxy, AI->ai_addr, AI->ai_addrlen) == SOCKET_ERROR) {
        fprintf(stderr,"bind() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
        freeaddrinfo(AI);
        closesocket(Proxy);
        WSACleanup();
        return -1;
    }

    if (listen(Proxy, 5) == SOCKET_ERROR) {
        fprintf(stderr, "listen() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
        freeaddrinfo(AI);
        closesocket(Proxy);
        WSACleanup();
        return -1;
    }

    printf("'Listening' on port %s, protocol family %s\n",
           Port, (AI->ai_family == PF_INET) ? "PF_INET" : "PF_INET6");

    freeaddrinfo(AI);

    //
    // Determine the parameters to use to create and connect the
    // sockets used to communicate with the real server.
    //
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = ServerFamily;
    Hints.ai_socktype = DEFAULT_SOCKTYPE;
    RetVal = getaddrinfo(Address, Port, &Hints, &AI);
    if (RetVal != 0) {
        fprintf(stderr, "Cannot resolve address [%s] and port [%s], error %d: %s\n",
                Address, Port, RetVal, gai_strerror(RetVal));
        closesocket(Proxy);
        WSACleanup();
        return -1;
    }

    StartProxy(Proxy, AI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\simple\client.c ===
//
// client.c - Simple TCP/UDP client using Winsock 2.2
// 
//      This is a part of the Microsoft Source Code Samples.
//      Copyright 1996 - 2000 Microsoft Corporation.
//      All rights reserved.
//      This source code is only intended as a supplement to
//      Microsoft Development Tools and/or WinHelp documentation.
//      See these sources for detailed information regarding the
//      Microsoft samples programs.
//

#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tpipv6.h>  // For IPv6 Tech Preview.
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// This code assumes that at the transport level, the system only supports
// one stream protocol (TCP) and one datagram protocol (UDP).  Therefore,
// specifying a socket type of SOCK_STREAM is equivalent to specifying TCP
// and specifying a socket type of SOCK_DGRAM is equivalent to specifying UDP.
//

#define DEFAULT_SERVER     NULL // Will use the loopback interface
#define DEFAULT_FAMILY     PF_UNSPEC // Accept either IPv4 or IPv6
#define DEFAULT_SOCKTYPE   SOCK_STREAM // TCP
#define DEFAULT_PORT       "5001" // Arbitrary, albiet a historical test port
#define DEFAULT_EXTRA      0 // Number of "extra" bytes to send

#define BUFFER_SIZE        65536

void Usage(char *ProgName) {
    fprintf(stderr, "\nSimple socket sample client program.\n");
    fprintf(stderr, "\n%s [-s server] [-f family] [-t transport] [-p port] [-b bytes] [-n number]\n\n",
            ProgName);
    fprintf(stderr, "  server\tServer name or IP address.  (default: %s)\n",
            (DEFAULT_SERVER == NULL) ? "loopback address" : DEFAULT_SERVER);
    fprintf(stderr, "  family\tOne of PF_INET, PF_INET6 or PF_UNSPEC.  (default: %s)\n",
            (DEFAULT_FAMILY == PF_UNSPEC) ? "PF_UNSPEC" :
            ((DEFAULT_FAMILY == PF_INET) ? "PF_INET" : "PF_INET6"));
    fprintf(stderr, "  transport\tEither TCP or UDP.  (default: %s)\n",
            (DEFAULT_SOCKTYPE == SOCK_STREAM) ? "TCP" : "UDP");
    fprintf(stderr, "  port\t\tPort on which to connect.  (default: %s)\n",
            DEFAULT_PORT);
    fprintf(stderr, "  bytes\t\tBytes of extra data to send.  (default: %d)\n",
            DEFAULT_EXTRA);
    fprintf(stderr, "  number\tNumber of sends to perform.  (default: 1)\n");
    fprintf(stderr, "  (-n by itself makes client run in an infinite loop,");
    fprintf(stderr, " Hit Ctrl-C to terminate)\n");
    WSACleanup();
    exit(1);
}


LPSTR DecodeError(int ErrorCode)
{
    static char Message[1024];

    // If this program was multi-threaded, we'd want to use
    // FORMAT_MESSAGE_ALLOCATE_BUFFER instead of a static buffer here.
    // (And of course, free the buffer when we were done with it)

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, ErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPSTR)Message, 1024, NULL);
    return Message;
}


int
ReceiveAndPrint(SOCKET ConnSocket, char *Buffer, int BufLen)
{
    int AmountRead;

    AmountRead = recv(ConnSocket, Buffer, BufLen, 0);
    if (AmountRead == SOCKET_ERROR) {
        fprintf(stderr, "recv() failed with error %d: %s\n", 
                WSAGetLastError(), DecodeError(WSAGetLastError()));
        closesocket(ConnSocket);
        WSACleanup();
        exit(1);
    }
    //
    // We are not likely to see this with UDP, since there is no
    // 'connection' established. 
    //
    if (AmountRead == 0) {
        printf("Server closed connection\n");
        closesocket(ConnSocket);
        WSACleanup();
        exit(0);
    }

    printf("Received %d bytes from server: [%.*s]\n",
           AmountRead, AmountRead, Buffer);

    return AmountRead;
}


int main(int argc, char **argv) {

    char Buffer[BUFFER_SIZE], AddrName[NI_MAXHOST];
    char *Server = DEFAULT_SERVER;
    int Family = DEFAULT_FAMILY;
    int SocketType = DEFAULT_SOCKTYPE;
    char *Port = DEFAULT_PORT;
    int i, RetVal, AddrLen, AmountToSend;
    int ExtraBytes = DEFAULT_EXTRA;
    unsigned int Iteration, MaxIterations = 1;
    BOOL RunForever = FALSE;
    WSADATA wsaData;
    ADDRINFO Hints, *AddrInfo, *AI;
    SOCKET ConnSocket;
    struct sockaddr_storage Addr;

    if (argc > 1) {
        for (i = 1;i < argc; i++) {
            if (((argv[i][0] == '-') || (argv[i][0] == '/')) &&
                (argv[i][1] != 0) && (argv[i][2] == 0)) {
                switch(tolower(argv[i][1])) {
                    case 'f':
                        if (!argv[i+1])
                            Usage(argv[0]);
                        if (!stricmp(argv[i+1], "PF_INET"))
                            Family = PF_INET;
                        else if (!stricmp(argv[i+1], "PF_INET6"))
                            Family = PF_INET6;
                        else if (!stricmp(argv[i+1], "PF_UNSPEC"))
                            Family = PF_UNSPEC;
                        else
                            Usage(argv[0]);
                        i++;
                        break;

                    case 't':
                        if (!argv[i+1])
                            Usage(argv[0]);
                        if (!stricmp(argv[i+1], "TCP"))
                            SocketType = SOCK_STREAM;
                        else if (!stricmp(argv[i+1], "UDP"))
                            SocketType = SOCK_DGRAM;
                        else
                            Usage(argv[0]);
                        i++;
                        break;

                    case 's':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Server = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'p':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Port = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'b':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                ExtraBytes = atoi(argv[++i]);
                                if (ExtraBytes > sizeof(Buffer) - sizeof("Message #4294967295"))
                                    Usage(argv[0]);
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'n':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                MaxIterations = atoi(argv[++i]);
                                break;
                            }
                        }
                        RunForever = TRUE;
                        break;

                    default:
                        Usage(argv[0]);
                        break;
                }
            }
            else
                Usage(argv[0]);
        }
    }

    // Ask for Winsock version 2.2.
    if ((RetVal = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
        fprintf(stderr, "WSAStartup failed with error %d: %s\n",
                RetVal, DecodeError(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // By not setting the AI_PASSIVE flag in the hints to getaddrinfo, we're
    // indicating that we intend to use the resulting address(es) to connect
    // to a service.  This means that when the Server parameter is NULL,
    // getaddrinfo will return one entry per allowed protocol family
    // containing the loopback address for that family.
    //
    
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = Family;
    Hints.ai_socktype = SocketType;
    RetVal = getaddrinfo(Server, Port, &Hints, &AddrInfo);
    if (RetVal != 0) {
        fprintf(stderr, "Cannot resolve address [%s] and port [%s], error %d: %s\n",
                Server, Port, RetVal, gai_strerror(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // Try each address getaddrinfo returned, until we find one to which
    // we can sucessfully connect.
    //
    for (AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

        // Open a socket with the correct address family for this address.
        ConnSocket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
        if (ConnSocket == INVALID_SOCKET) {
            fprintf(stderr,"Error Opening socket, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            continue;
        }

        //
        // Notice that nothing in this code is specific to whether we 
        // are using UDP or TCP.
        //
        // When connect() is called on a datagram socket, it does not 
        // actually establish the connection as a stream (TCP) socket
        // would. Instead, TCP/IP establishes the remote half of the
        // (LocalIPAddress, LocalPort, RemoteIP, RemotePort) mapping.
        // This enables us to use send() and recv() on datagram sockets,
        // instead of recvfrom() and sendto().
        //

        printf("Attempting to connect to: %s\n", Server ? Server : "localhost");
        if (connect(ConnSocket, AI->ai_addr, AI->ai_addrlen) != SOCKET_ERROR)
            break;

        i = WSAGetLastError();
        if (getnameinfo(AI->ai_addr, AI->ai_addrlen, AddrName,
                        sizeof(AddrName), NULL, 0, NI_NUMERICHOST) != 0)
            strcpy(AddrName, "<unknown>");
        fprintf(stderr, "connect() to %s failed with error %d: %s\n",
                AddrName, i, DecodeError(i));
        closesocket(ConnSocket);
    }

    if (AI == NULL) {
        fprintf(stderr, "Fatal error: unable to connect to the server.\n");
        WSACleanup();
        return -1;
    }

    //
    // This demonstrates how to determine to where a socket is connected.
    //
    AddrLen = sizeof(Addr);
    if (getpeername(ConnSocket, (LPSOCKADDR)&Addr, &AddrLen) == SOCKET_ERROR) {
        fprintf(stderr, "getpeername() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
    } else {
        if (getnameinfo((LPSOCKADDR)&Addr, AddrLen, AddrName,
                        sizeof(AddrName), NULL, 0, NI_NUMERICHOST) != 0)
            strcpy(AddrName, "<unknown>");
        printf("Connected to %s, port %d, protocol %s, protocol family %s\n",
               AddrName, ntohs(SS_PORT(&Addr)),
               (AI->ai_socktype == SOCK_STREAM) ? "TCP" : "UDP",
               (AI->ai_family == PF_INET) ? "PF_INET" : "PF_INET6");
    }

    // We are done with the address info chain, so we can free it.
    freeaddrinfo(AddrInfo);

    //
    // Find out what local address and port the system picked for us.
    //
    AddrLen = sizeof(Addr);
    if (getsockname(ConnSocket, (LPSOCKADDR)&Addr, &AddrLen) == SOCKET_ERROR) {
        fprintf(stderr, "getsockname() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
    } else {
        if (getnameinfo((LPSOCKADDR)&Addr, AddrLen, AddrName,
                        sizeof(AddrName), NULL, 0, NI_NUMERICHOST) != 0)
            strcpy(AddrName, "<unknown>");
        printf("Using local address %s, port %d\n",
               AddrName, ntohs(SS_PORT(&Addr)));
    }

    //
    // Send and receive in a loop for the requested number of iterations.
    //
    for (Iteration = 0; RunForever || Iteration < MaxIterations; Iteration++) {

        // Compose a message to send.
        AmountToSend = sprintf(Buffer, "Message #%u", Iteration + 1);
        for (i = 0; i < ExtraBytes; i++) {
            Buffer[AmountToSend++] = (char)((i & 0x3f) + 0x20);
        }

        // Send the message.  Since we are using a blocking socket, this
        // call shouldn't return until it's able to send the entire amount.
        RetVal = send(ConnSocket, Buffer, AmountToSend, 0);
        if (RetVal == SOCKET_ERROR) {
            fprintf(stderr, "send() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            WSACleanup();
            return -1;
        }

        printf("Sent %d bytes (out of %d bytes) of data: [%.*s]\n",
               RetVal, AmountToSend, AmountToSend, Buffer);

        // Clear buffer just to prove we're really receiving something.
        memset(Buffer, 0, sizeof(Buffer));

        // Receive and print server's reply.
        ReceiveAndPrint(ConnSocket, Buffer, sizeof(Buffer));
    }

    // Tell system we're done sending.
    printf("Done sending\n");
    shutdown(ConnSocket, SD_SEND);

    //
    // Since TCP does not preserve message boundaries, there may still
    // be more data arriving from the server.  So we continue to receive
    // data until the server closes the connection.
    //
    if (SocketType == SOCK_STREAM)
        while(ReceiveAndPrint(ConnSocket, Buffer, sizeof(Buffer)) != 0)
            ;

    closesocket(ConnSocket);
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\rawsock\rawsend.c ===
//
// rawsend.c - Example showing use of raw sockets.
// 
//      This is a part of the Microsoft Source Code Samples.
//      Copyright 1996 - 2000 Microsoft Corporation.
//      All rights reserved.
//      This source code is only intended as a supplement to
//      Microsoft Development Tools and/or WinHelp documentation.
//      See these sources for detailed information regarding the
//      Microsoft samples programs.
//

#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tpipv6.h>  // Needed for IPv6 Tech Preview.
#include <ip6.h>     // For IPv6Header strucuture.
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// It's too much trouble to include icmp6.h
//
typedef struct ICMPv6Header {
    unsigned char Type;
    unsigned char Code;
    unsigned short Checksum;
} ICMPv6Header;

#define DEFAULT_SERVER     NULL // Will use the loopback interface
#define DEFAULT_PROTOCOL   254  // Arbitrary unassigned protocol
#define BUFFER_SIZE        65536
#define DATA_SIZE          64

void Usage(char *ProgName) {
    fprintf(stderr, "\nRaw socket send program.\n");
    fprintf(stderr, "\n%s [-s server] [-p protocol] [-n number]\n\n",
            ProgName);
    fprintf(stderr, "  server\tServer name or IP address.  (default: %s)\n",
            (DEFAULT_SERVER == NULL) ? "loopback address" : DEFAULT_SERVER);
    fprintf(stderr, "  protocol\tNextHeader field value.  (default: %u)\n",
            DEFAULT_PROTOCOL);
    fprintf(stderr, "  number\tNumber of sends to perform.  (default: 1)\n");
    fprintf(stderr, "  (-n by itself makes client run in an infinite loop,");
    fprintf(stderr, " Hit Ctrl-C to terminate)\n");
    WSACleanup();
    exit(1);
}


LPSTR DecodeError(int ErrorCode)
{
    static char Message[1024];

    // If this program was multi-threaded, we'd want to use
    // FORMAT_MESSAGE_ALLOCATE_BUFFER instead of a static buffer here.
    // (And of course, free the buffer when we were done with it)

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, ErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPSTR)Message, 1024, NULL);
    return Message;
}


int main(int argc, char **argv) {

    char Buffer[BUFFER_SIZE], AddrName[NI_MAXHOST];
    char *Server = DEFAULT_SERVER;
    int i, RetVal;
    unsigned int Iteration, MaxIterations = 1;
    unsigned int AmountToSend;
    unsigned short PayloadLength;
    BOOL RunForever = FALSE;
    BOOL True = TRUE;
    WSADATA wsaData;
    ADDRINFO Hints, *AddrInfo, *AI;
    SOCKET Sock;
    SOCKADDR_IN6 OurAddr, PeerAddr;
    unsigned char Protocol = DEFAULT_PROTOCOL;
    IPv6Header *IP = (IPv6Header *)Buffer;
    ICMPv6Header *ICMP;

    if (argc > 1) {
        for (i = 1;i < argc; i++) {
            if (((argv[i][0] == '-') || (argv[i][0] == '/')) &&
                (argv[i][1] != 0) && (argv[i][2] == 0)) {
                switch(tolower(argv[i][1])) {
                    case 's':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Server = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'n':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                MaxIterations = atoi(argv[++i]);
                                break;
                            }
                        }
                        RunForever = TRUE;
                        break;

                    case 'p':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Protocol = atoi(argv[++i]);
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    default:
                        Usage(argv[0]);
                        break;
                }
            }
            else
                Usage(argv[0]);
        }
    }

    // Ask for Winsock version 2.2.
    if ((RetVal = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
        fprintf(stderr, "WSAStartup failed with error %d: %s\n",
                RetVal, DecodeError(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // By not setting the AI_PASSIVE flag in the hints to getaddrinfo, we're
    // indicating that we intend to use the resulting address(es) to connect
    // to a service.  This means that when the Server parameter is NULL,
    // getaddrinfo will return one entry per allowed protocol family
    // containing the loopback address for that family.
    //
    
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = PF_INET6;
    Hints.ai_socktype = SOCK_DGRAM;  // Lie until getaddrinfo is fixed.
    Hints.ai_protocol = Protocol;
    RetVal = getaddrinfo(Server, "1" /* Dummy */, &Hints, &AddrInfo);
    if (RetVal != 0) {
        fprintf(stderr, "Cannot resolve address [%s], error %d: %s\n",
                Server, RetVal, gai_strerror(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // Try each address getaddrinfo returned, until we find one to which
    // we can sucessfully connect.
    //
    for (AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

        Sock = socket(AI->ai_family, SOCK_RAW, AI->ai_protocol);
        if (Sock == INVALID_SOCKET) {
            fprintf(stderr,"Error Opening socket, error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            continue;
        }

        if (getnameinfo((LPSOCKADDR)AI->ai_addr, AI->ai_addrlen, AddrName,
                        sizeof(AddrName), NULL, 0, NI_NUMERICHOST) != 0)
            strcpy(AddrName, "<unknown>");
        printf("Attempting to connect to: %s (%s)\n",
               Server ? Server : "localhost", AddrName);

        if (connect(Sock, AI->ai_addr, AI->ai_addrlen) != SOCKET_ERROR)
            break;

        i = WSAGetLastError();
        fprintf(stderr, "connect() failed with error %d: %s\n",
                i, DecodeError(i));
    }

    if (AI == NULL) {
        fprintf(stderr, "Fatal error: unable to connect to the server.\n");
        closesocket(Sock);
        WSACleanup();
        return -1;
    }

    PeerAddr = *(SOCKADDR_IN6 *)(AI->ai_addr);

    // We are done with the address info chain, so we can free it.
    freeaddrinfo(AddrInfo);

    //
    // Make up a source address to use.
    // Use the unspecified address for now.
    //
    memset(&OurAddr, 0, sizeof(OurAddr));

    //
    // Let the stack know that we'll be contributing the IPv6 header.
    //
    if (setsockopt(Sock, IPPROTO_IPV6, IPV6_HDRINCL, (char *)&True,
                   sizeof(True)) == SOCKET_ERROR) {
        fprintf(stderr, "setsockopt() failed with error %d: %s\n",
                WSAGetLastError(), DecodeError(WSAGetLastError()));
    }

    //
    // Compose a message to send.
    // Start with IPv6 packet header.
    //
    IP->VersClassFlow = htonl(6 << 28);
    PayloadLength = 0;
    IP->NextHeader = Protocol;
    IP->HopLimit = 32;
    IP->Source = OurAddr.sin6_addr;
    IP->Dest = PeerAddr.sin6_addr;
    AmountToSend = sizeof(*IP);

    if (Protocol == IP_PROTOCOL_ICMPv6) {
        //
        // Put an ICMPv6 header on next.
        //
        ICMP = (ICMPv6Header *)(IP + 1);
        if (MaxIterations == 1)
            ICMP->Type = 255;  // Unassigned informational message.
        else
            ICMP->Type = 127;  // Unassigned error message.
        ICMP->Code = 42;
        ICMP->Checksum = 0;    // Calculated below.

        PayloadLength += sizeof(*ICMP);
        AmountToSend += sizeof(*ICMP);
    }

    //
    // Add some meaningless data.
    //
    for (i = 0; i < DATA_SIZE; i++) {
        Buffer[AmountToSend++] = (char)(i + 0x40);
    }
    PayloadLength += DATA_SIZE;

    if (Protocol == IP_PROTOCOL_ICMPv6) {
        unsigned short *Data;
        unsigned int Checksum = 0;

        //
        // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
        // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
        //

        // Pseudo-header.
        Data = (unsigned short *)&IP->Source;
        for (i = 0; i < 16; i++)
            Checksum += *Data++;
        Checksum += htons(PayloadLength);
        Checksum += (IP_PROTOCOL_ICMPv6 << 8);

        // Packet data.
        Data = (unsigned short *)ICMP;
        for (i = 0; i < (PayloadLength / 2); i++)
            Checksum += *Data++;

        // Wrap in carries.
        Checksum = (Checksum >> 16) + (Checksum & 0xffff);
        Checksum += (Checksum >> 16);

        // Take ones-complement and replace 0 with 0xffff.
        Checksum = (unsigned short) ~Checksum;
        if (Checksum == 0)
            Checksum = 0xffff;

        ICMP->Checksum = (unsigned short)Checksum;
    }

    IP->PayloadLength = htons(PayloadLength);

    //
    // Send and receive in a loop for the requested number of iterations.
    //
    for (Iteration = 0; RunForever || Iteration < MaxIterations; Iteration++) {

        //
        // Send the message.  Since we are using a blocking socket, this
        // call shouldn't return until it's able to send the entire amount.
        //
        RetVal = send(Sock, Buffer, AmountToSend, 0);
        if (RetVal == SOCKET_ERROR) {
            fprintf(stderr, "send() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            WSACleanup();
            return -1;
        }

        printf("Sent %d bytes (out of %d bytes) of data: [%.*s]\n",
               RetVal, AmountToSend, AmountToSend, Buffer);
    }

    // Tell system we're done sending.
    printf("Done sending\n");
    shutdown(Sock, SD_SEND);
    closesocket(Sock);
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\simple\server.c ===
//
// server.c - Simple TCP/UDP server using Winsock 2.2
//
//      This is a part of the Microsoft Source Code Samples.
//      Copyright 1996 - 2000 Microsoft Corporation.
//      All rights reserved.
//      This source code is only intended as a supplement to
//      Microsoft Development Tools and/or WinHelp documentation.
//      See these sources for detailed information regarding the
//      Microsoft samples programs.
//

#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tpipv6.h>  // For IPv6 Tech Preview.
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// This code assumes that at the transport level, the system only supports
// one stream protocol (TCP) and one datagram protocol (UDP).  Therefore,
// specifying a socket type of SOCK_STREAM is equivalent to specifying TCP
// and specifying a socket type of SOCK_DGRAM is equivalent to specifying UDP.
//

#define DEFAULT_FAMILY     PF_UNSPEC // Accept either IPv4 or IPv6
#define DEFAULT_SOCKTYPE   SOCK_STREAM // TCP
#define DEFAULT_PORT       "5001" // Arbitrary, albiet a historical test port

#define BUFFER_SIZE        64 // Set very small for demonstration purposes

void Usage(char *ProgName) {
    fprintf(stderr, "\nSimple socket sample server program.\n");
    fprintf(stderr, "\n%s [-f family] [-t transport] [-p port] [-a address]\n\n",
            ProgName);
    fprintf(stderr, "  family\tOne of PF_INET, PF_INET6 or PF_UNSPEC.  (default %s)\n",
            (DEFAULT_FAMILY == PF_UNSPEC) ? "PF_UNSPEC" :
            ((DEFAULT_FAMILY == PF_INET) ? "PF_INET" : "PF_INET6"));
    fprintf(stderr, "  transport\tEither TCP or UDP.  (default: %s)\n",
            (DEFAULT_SOCKTYPE == SOCK_STREAM) ? "TCP" : "UDP");
    fprintf(stderr, "  port\t\tPort on which to bind.  (default %s)\n",
            DEFAULT_PORT);
    fprintf(stderr, "  address\tIP address on which to bind.  (default: unspecified address)\n");
    WSACleanup();
    exit(1);
}


LPSTR DecodeError(int ErrorCode)
{
    static char Message[1024];

    // If this program was multi-threaded, we'd want to use
    // FORMAT_MESSAGE_ALLOCATE_BUFFER instead of a static buffer here.
    // (And of course, free the buffer when we were done with it)

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, ErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPSTR)Message, 1024, NULL);
    return Message;
}


int main(int argc, char **argv)
{
    char Buffer[BUFFER_SIZE], Hostname[NI_MAXHOST];
    int Family = DEFAULT_FAMILY;
    int SocketType = DEFAULT_SOCKTYPE;
    char *Port = DEFAULT_PORT;
    char *Address = NULL;
    int i, NumSocks, RetVal, FromLen, AmountRead;
    SOCKADDR_STORAGE From;
    WSADATA wsaData;
    ADDRINFO Hints, *AddrInfo, *AI;
    SOCKET ServSock[FD_SETSIZE];
    fd_set SockSet;

    // Parse arguments
    if (argc > 1) {
        for(i = 1;i < argc; i++) {
            if ((argv[i][0] == '-') || (argv[i][0] == '/') &&
                (argv[i][1] != 0) && (argv[i][2] == 0)) {
                switch(tolower(argv[i][1])) {
                    case 'f':
                        if (!argv[i+1])
                            Usage(argv[0]);
                        if (!stricmp(argv[i+1], "PF_INET"))
                            Family = PF_INET;
                        else if (!stricmp(argv[i+1], "PF_INET6"))
                            Family = PF_INET6;
                        else if (!stricmp(argv[i+1], "PF_UNSPEC"))
                            Family = PF_UNSPEC;
                        else
                            Usage(argv[0]);
                        i++;
                        break;

                    case 't':
                        if (!argv[i+1])
                            Usage(argv[0]);
                        if (!stricmp(argv[i+1], "TCP"))
                            SocketType = SOCK_STREAM;
                        else if (!stricmp(argv[i+1], "UDP"))
                            SocketType = SOCK_DGRAM;
                        else
                            Usage(argv[0]);
                        i++;
                        break;

                    case 'a':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Address = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'p':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Port = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    default:
                        Usage(argv[0]);
                        break;
                }
            } else
                Usage(argv[0]);
        }
    }
    
    // Ask for Winsock version 2.2.
    if ((RetVal = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
        fprintf(stderr, "WSAStartup failed with error %d: %s\n",
                RetVal, DecodeError(RetVal));
        WSACleanup();
        return -1;
    }
    
    if (Port == NULL) {
        Usage(argv[0]);
    }

    //
    // By setting the AI_PASSIVE flag in the hints to getaddrinfo, we're
    // indicating that we intend to use the resulting address(es) to bind
    // to a socket(s) for accepting incoming connections.  This means that
    // when the Address parameter is NULL, getaddrinfo will return one
    // entry per allowed protocol family containing the unspecified address
    // for that family.
    //
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = Family;
    Hints.ai_socktype = SocketType;
    Hints.ai_flags = AI_NUMERICHOST | AI_PASSIVE;
    RetVal = getaddrinfo(Address, Port, &Hints, &AddrInfo);
    if (RetVal != 0) {
        fprintf(stderr, "getaddrinfo failed with error %d: %s\n",
                RetVal, gai_strerror(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // For each address getaddrinfo returned, we create a new socket,
    // bind that address to it, and create a queue to listen on.
    //
    for (i = 0, AI = AddrInfo; AI != NULL; AI = AI->ai_next, i++) {

        // Highly unlikely, but check anyway.
        if (i == FD_SETSIZE) {
            printf("getaddrinfo returned more addresses than we could use.\n");
            break;
        }

        // This example only supports PF_INET and PF_INET6.
        if ((AI->ai_family != PF_INET) && (AI->ai_family != PF_INET6))
            continue;

        // Open a socket with the correct address family for this address.
        ServSock[i] = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol);
        if (ServSock[i] == INVALID_SOCKET){
            fprintf(stderr, "socket() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            continue;
        }

        //
        // bind() associates a local address and port combination
        // with the socket just created. This is most useful when
        // the application is a server that has a well-known port
        // that clients know about in advance.
        //
        if (bind(ServSock[i], AI->ai_addr, AI->ai_addrlen) == SOCKET_ERROR) {
            fprintf(stderr,"bind() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            continue;
        }

        //
        // So far, everything we did was applicable to TCP as well as UDP.
        // However, there are certain fundamental differences between stream
        // protocols such as TCP and datagram protocols such as UDP.
        //
        // Only connection orientated sockets, for example those of type
        // SOCK_STREAM, can listen() for incoming connections.
        //
        if (SocketType == SOCK_STREAM) {
            if (listen(ServSock[i], 5) == SOCKET_ERROR) {
                fprintf(stderr, "listen() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                continue;
            }
        }

        printf("'Listening' on port %s, protocol %s, protocol family %s\n",
               Port, (SocketType == SOCK_STREAM) ? "TCP" : "UDP",
               (AI->ai_family == PF_INET) ? "PF_INET" : "PF_INET6");
    }

    freeaddrinfo(AddrInfo);

    if (i == 0) {
        fprintf(stderr, "Fatal error: unable to serve on any address.\n");
        WSACleanup();
        return -1;
    }
    NumSocks = i;

    //
    // We now put the server into an eternal loop,
    // serving requests as they arrive.
    //
    FD_ZERO(&SockSet);
    while(1) {

        FromLen = sizeof(From);

        //
        // For connection orientated protocols, we will handle the
        // packets comprising a connection collectively.  For datagram
        // protocols, we have to handle each datagram individually.
        //

        //
        // Check to see if we have any sockets remaining to be served
        // from previous time through this loop.  If not, call select()
        // to wait for a connection request or a datagram to arrive.
        //
        for (i = 0; i < NumSocks; i++){
            if (FD_ISSET(ServSock[i], &SockSet))
                break;
        }
        if (i == NumSocks) {
            for (i = 0; i < NumSocks; i++)
                FD_SET(ServSock[i], &SockSet);
            if (select(NumSocks, &SockSet, 0, 0, 0) == SOCKET_ERROR) {
                fprintf(stderr, "select() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                WSACleanup();
                return -1;
            }
        }
        for (i = 0; i < NumSocks; i++){
            if (FD_ISSET(ServSock[i], &SockSet)) {
                FD_CLR(ServSock[i], &SockSet);
                break;
            }
        }

        if (SocketType == SOCK_STREAM) {
            SOCKET ConnSock;

            //
            // Since this socket was returned by the select(), we know we
            // have a connection waiting and that this accept() won't block.
            //
            ConnSock = accept(ServSock[i], (LPSOCKADDR)&From, &FromLen);
            if (ConnSock == INVALID_SOCKET) {
                fprintf(stderr, "accept() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                WSACleanup();
                return -1;
            }
            if (getnameinfo((LPSOCKADDR)&From, FromLen, Hostname,
                            sizeof(Hostname), NULL, 0, NI_NUMERICHOST) != 0)
                strcpy(Hostname, "<unknown>");
            printf("\nAccepted connection from %s\n", Hostname);
            
            //
            // This sample server only handles connections sequentially.
            // To handle multiple connections simultaneously, a server
            // would likely want to launch another thread or process at this
            // point to handle each individual connection.  Alternatively,
            // it could keep a socket per connection and use select()
            // on the fd_set to determine which to read from next.
            //
            // Here we just loop until this connection terminates.
            //

            while (1) {

                //
                // We now read in data from the client.  Because TCP
                // does NOT maintain message boundaries, we may recv()
                // the client's data grouped differently than it was
                // sent.  Since all this server does is echo the data it
                // receives back to the client, we don't need to concern
                // ourselves about message boundaries.  But it does mean
                // that the message data we print for a particular recv()
                // below may contain more or less data than was contained
                // in a particular client send().
                //

                AmountRead = recv(ConnSock, Buffer, sizeof(Buffer), 0);
                if (AmountRead == SOCKET_ERROR) {
                    fprintf(stderr, "recv() failed with error %d: %s\n",
                            WSAGetLastError(), DecodeError(WSAGetLastError()));
                    closesocket(ConnSock);
                    break;
                }
                if (AmountRead == 0) {
                    printf("Client closed connection\n");
                    closesocket(ConnSock);
                    break;
                }

                printf("Received %d bytes from client: [%.*s]\n",
                       AmountRead, AmountRead, Buffer);
                printf("Echoing same data back to client\n");

                RetVal = send(ConnSock, Buffer, AmountRead, 0);
                if (RetVal == SOCKET_ERROR) {
                    fprintf(stderr, "send() failed: error %d: %s\n",
                            WSAGetLastError(), DecodeError(WSAGetLastError()));
                    closesocket(ConnSock);
                    break;
                }
            }

        } else {

            //
            // Since UDP maintains message boundaries, the amount of data
            // we get from a recvfrom() should match exactly the amount of
            // data the client sent in the corresponding sendto().
            //
            AmountRead = recvfrom(ServSock[i], Buffer, sizeof(Buffer), 0,
                                  (LPSOCKADDR)&From, &FromLen);
            if (AmountRead == SOCKET_ERROR) {
                fprintf(stderr, "recvfrom() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                closesocket(ServSock[i]);
                break;
            }
            if (AmountRead == 0) {
                // This should never happen on an unconnected socket, but...
                printf("recvfrom() returned zero, aborting\n");
                closesocket(ServSock[i]);
                break;
            }
            
            RetVal = getnameinfo((LPSOCKADDR)&From, FromLen, Hostname,
                                 sizeof(Hostname), NULL, 0, NI_NUMERICHOST);
            if (RetVal != 0) {
                fprintf(stderr, "getnameinfo() failed with error %d: %s\n",
                        RetVal, DecodeError(RetVal));
                strcpy(Hostname, "<unknown>");
            }

            printf("Received a %d byte datagram from %s: [%.*s]\n",
                   AmountRead, Hostname, AmountRead, Buffer);
            printf("Echoing same data back to client\n");

            RetVal = sendto(ServSock[i], Buffer, AmountRead, 0,
                            (LPSOCKADDR)&From, FromLen);
            if (RetVal == SOCKET_ERROR) {
                fprintf(stderr, "send() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\rawsock\rawrecv.c ===
//
// server.c - Simple TCP/UDP server using Winsock 2.2
//
//      This is a part of the Microsoft Source Code Samples.
//      Copyright 1996 - 2000 Microsoft Corporation.
//      All rights reserved.
//      This source code is only intended as a supplement to
//      Microsoft Development Tools and/or WinHelp documentation.
//      See these sources for detailed information regarding the
//      Microsoft samples programs.
//

#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tpipv6.h>  // For IPv6 Tech Preview.
#include <ip6.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//
// It's too much trouble to include icmp6.h
//
typedef struct ICMPv6Header {
    unsigned char Type;
    unsigned char Code;
    unsigned short Checksum;
} ICMPv6Header;


#define DEFAULT_PROTOCOL   254  // Arbitrary unassigned protocol
#define BUFFER_SIZE        65536

void Usage(char *ProgName) {
    fprintf(stderr, "\nRaw socket receive program.\n");
    fprintf(stderr, "\n%s [-p protocol] [-a address]\n\n",
            ProgName);
    fprintf(stderr, "  protocol\t\tProtocol to receive messages for.  (default %s)\n",
            DEFAULT_PROTOCOL);
    fprintf(stderr, "  address\tIP address on which to bind.  (default: unspecified address)\n");
    WSACleanup();
    exit(1);
}


LPSTR DecodeError(int ErrorCode)
{
    static char Message[1024];

    // If this program was multi-threaded, we'd want to use
    // FORMAT_MESSAGE_ALLOCATE_BUFFER instead of a static buffer here.
    // (And of course, free the buffer when we were done with it)

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, ErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPSTR)Message, 1024, NULL);
    return Message;
}


int main(int argc, char **argv)
{
    char Buffer[BUFFER_SIZE], Hostname[NI_MAXHOST];
    unsigned char Protocol = DEFAULT_PROTOCOL;
    char *Address = NULL;
    int i, NumSocks, RetVal, FromLen, AmountRead;
    SOCKADDR_STORAGE From;
    WSADATA wsaData;
    ADDRINFO Hints, *AddrInfo, *AI;
    SOCKET ServSock[FD_SETSIZE];
    fd_set SockSet;

    // Parse arguments
    if (argc > 1) {
        for(i = 1;i < argc; i++) {
            if ((argv[i][0] == '-') || (argv[i][0] == '/') &&
                (argv[i][1] != 0) && (argv[i][2] == 0)) {
                switch(tolower(argv[i][1])) {
                    case 'a':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Address = argv[++i];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'p':
                        if (argv[i+1]) {
                            if (argv[i+1][0] != '-') {
                                Protocol = atoi(argv[++i]);
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    default:
                        Usage(argv[0]);
                        break;
                }
            } else
                Usage(argv[0]);
        }
    }
    
    // Ask for Winsock version 2.2.
    if ((RetVal = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
        fprintf(stderr, "WSAStartup failed with error %d: %s\n",
                RetVal, DecodeError(RetVal));
        WSACleanup();
        return -1;
    }
    
    //
    // By setting the AI_PASSIVE flag in the hints to getaddrinfo, we're
    // indicating that we intend to use the resulting address(es) to bind
    // to a socket(s) for accepting incoming connections.  This means that
    // when the Address parameter is NULL, getaddrinfo will return one
    // entry per allowed protocol family containing the unspecified address
    // for that family.
    //
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = PF_INET6;
    Hints.ai_socktype = SOCK_DGRAM;  // Lie until getaddrinfo is fixed.
    Hints.ai_flags = AI_NUMERICHOST | AI_PASSIVE;
    RetVal = getaddrinfo(Address, "1" /* Dummy */, &Hints, &AddrInfo);
    if (RetVal != 0) {
        fprintf(stderr, "getaddrinfo failed with error %d: %s\n",
                RetVal, gai_strerror(RetVal));
        WSACleanup();
        return -1;
    }

    //
    // For each address getaddrinfo returned, we create a new socket,
    // bind that address to it, and create a queue to listen on.
    //
    for (i = 0, AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

        // Highly unlikely, but check anyway.
        if (i == FD_SETSIZE) {
            printf("getaddrinfo returned more addresses than we could use.\n");
            break;
        }

        ServSock[i] = socket(AI->ai_family, SOCK_RAW, Protocol);
        if (ServSock[i] == INVALID_SOCKET){
            fprintf(stderr, "socket() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            continue;
        }

        //
        // bind() associates a local address and port combination
        // with the socket just created. This is most useful when
        // the application is a server that has a well-known port
        // that clients know about in advance.
        //
        if (bind(ServSock[i], AI->ai_addr, AI->ai_addrlen) == SOCKET_ERROR) {
            fprintf(stderr,"bind() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(ServSock[i]);
            continue;
        }

        i++;

        printf("Listening on protocol %d\n", Protocol);
    }

    freeaddrinfo(AddrInfo);

    if (i == 0) {
        fprintf(stderr, "Fatal error: unable to serve on any address.\n");
        WSACleanup();
        return -1;
    }
    NumSocks = i;

    //
    // We now put the server into an eternal loop,
    // serving requests as they arrive.
    //
    FD_ZERO(&SockSet);
    while(1) {

        FromLen = sizeof(From);

        //
        // For connection orientated protocols, we will handle the
        // packets comprising a connection collectively.  For datagram
        // protocols, we have to handle each datagram individually.
        //

        //
        // Check to see if we have any sockets remaining to be served
        // from previous time through this loop.  If not, call select()
        // to wait for a connection request or a datagram to arrive.
        //
        for (i = 0; i < NumSocks; i++){
            if (FD_ISSET(ServSock[i], &SockSet))
                break;
        }
        if (i == NumSocks) {
            for (i = 0; i < NumSocks; i++)
                FD_SET(ServSock[i], &SockSet);
            if (select(NumSocks, &SockSet, 0, 0, 0) == SOCKET_ERROR) {
                fprintf(stderr, "select() failed with error %d: %s\n",
                        WSAGetLastError(), DecodeError(WSAGetLastError()));
                WSACleanup();
                return -1;
            }
        }
        for (i = 0; i < NumSocks; i++){
            if (FD_ISSET(ServSock[i], &SockSet)) {
                FD_CLR(ServSock[i], &SockSet);
                break;
            }
        }

        AmountRead = recvfrom(ServSock[i], Buffer, sizeof(Buffer), 0,
                              (LPSOCKADDR)&From, &FromLen);
        if (AmountRead == SOCKET_ERROR) {
            fprintf(stderr, "recvfrom() failed with error %d: %s\n",
                    WSAGetLastError(), DecodeError(WSAGetLastError()));
            closesocket(ServSock[i]);
            break;
        }
        if (AmountRead == 0) {
            // This should never happen on an unconnected socket, but...
            printf("recvfrom() returned zero, aborting\n");
            closesocket(ServSock[i]);
            break;
        }
        
        RetVal = getnameinfo((LPSOCKADDR)&From, FromLen, Hostname,
                             sizeof(Hostname), NULL, 0, NI_NUMERICHOST);
        if (RetVal != 0) {
            fprintf(stderr, "getnameinfo() failed with error %d: %s\n",
                    RetVal, DecodeError(RetVal));
            strcpy(Hostname, "<unknown>");
        }
        
        if (Protocol == IP_PROTOCOL_ICMPv6) {
            ICMPv6Header *ICMP = (ICMPv6Header *)Buffer;

            printf("Received a ICMP message from %s\n", Hostname);
            printf("Type = %u, Code = %u\n", ICMP->Type, ICMP->Code);
            printf("Data = \"%.*s\"\n",
                   AmountRead - sizeof(*ICMP), Buffer + sizeof(*ICMP));
        } else {
            printf("Received a %d byte datagram from %s \"%.*s\"\n",
                   AmountRead, Hostname, AmountRead, Buffer);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\getaddrinfo\getaddrinfo.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// Abstract:
//
// Program to perform demonstrate name resolution via getaddrinfo.
//

#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>

void DumpAddrInfo(ADDRINFO *AddrInfo);
void ListAddrInfo(ADDRINFO *AddrInfo);

//
// getaddrinfo flags
// This array maps values to names for pretty-printing purposes.
// Used by DecodeAIFlags().
//
// TBD: When we add support for AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and
// TBD: AI_ADDRCONFIG to getaddrinfo (and thus define them in ws2tcpip.h),
// TBD: we'll need to add them here too.
//
// Note when adding flags: all the string names plus connecting OR symbols
// must fit into the buffer in DecodeAIFlags() below.  Enlarge as required.
//
typedef struct GAIFlagsArrayEntry {
    int Flag;
    char *Name;
} GAIFlagsArrayEntry;
GAIFlagsArrayEntry GAIFlagsArray [] = {
    {AI_PASSIVE, "AI_PASSIVE"},
    {AI_CANONNAME, "AI_CANONNAME"},
    {AI_NUMERICHOST, "AI_NUMERICHOST"}
};
#define NUMBER_FLAGS (sizeof(GAIFlagsArray) / sizeof(GAIFlagsArrayEntry))


//
// Global variables.
//
int Verbose = FALSE;


//
// Inform the user.
//
void Usage(char *ProgName) {
    fprintf(stderr, "\nPerforms name to address resolution.\n");
    fprintf(stderr, "\n%s [NodeName] [-s ServiceName] [-p] [-c] [-v]\n\n",
            ProgName);
    WSACleanup();
    exit(1);
}


int __cdecl
main(int argc, char **argv)
{
    WSADATA wsaData;
    char *NodeName = NULL;
    char *ServiceName = NULL;
    int ReturnValue;
    ADDRINFO Hints, *AddrInfo;
    int Loop;
    int Passive = FALSE;
    int Canonical = FALSE;
    int GotNodeName = FALSE;

    //
    // Initialize Winsock.
    //
    if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        printf("WSAStartup failed\n");
        exit(1);
    }

    //
    // Parse command arguments.
    //
    if (argc > 1) {
        for (Loop = 1;Loop < argc; Loop++) {
            if (((argv[Loop][0] == '-') || (argv[Loop][0] == '/')) &&
                (argv[Loop][1] != 0) && (argv[Loop][2] == 0)) {
                switch(tolower(argv[Loop][1])) {
                    case 's':
                        if (argv[Loop + 1]) {
                            if ((argv[Loop + 1][0] != '-') &&
                                (argv[Loop + 1][0] != '/')) {
                                ServiceName = argv[++Loop];
                                break;
                            }
                        }
                        Usage(argv[0]);
                        break;

                    case 'p':
                        Passive = TRUE;
                        break;

                    case 'c':
                        Canonical = TRUE;
                        break;

                    case 'v':
                        Verbose = TRUE;
                        break;

                    default:
                        Usage(argv[0]);
                        break;
                }
            } else if (!GotNodeName) {
                NodeName = argv[Loop];
                GotNodeName = TRUE;
            } else {
                Usage(argv[0]);
            }
        }
    }

    //
    // Prepare Hints.
    //
    memset(&Hints, 0, sizeof(Hints));
    Hints.ai_family = PF_UNSPEC;
    if (Passive) {
        Hints.ai_flags = AI_PASSIVE;
    }
    if (Canonical) {
        Hints.ai_flags |= AI_CANONNAME;
    }
    if (Verbose) {
        printf("\nHints contains:\n");
        DumpAddrInfo(&Hints);
    }

    //
    // Make the call.
    //
    if (Verbose) {
        printf("\nCalling getaddrinfo(\"%s\", \"%s\", &Hints, &AddrInfo)\n",
               NodeName, ServiceName);
    } else {
        printf("\nCalling getaddrinfo for node %s", NodeName);
        if (ServiceName) {
            printf(" and service %s", ServiceName);
        }
        printf("\n");
    }
    ReturnValue = getaddrinfo(NodeName, ServiceName, &Hints, &AddrInfo);
    printf("Returns %d (%s)\n", ReturnValue,
           ReturnValue ? gai_strerror(ReturnValue) : "no error");
    if (AddrInfo != NULL) {
        if (Verbose) {
            printf("AddrInfo contains:\n");
            DumpAddrInfo(AddrInfo);
        } else {
            if (AddrInfo->ai_canonname) {
                printf("Canonical name for %s is %s\n", NodeName,
                       AddrInfo->ai_canonname);
            }
            printf("AddrInfo contains the following records:\n");
            ListAddrInfo(AddrInfo);
        }
        freeaddrinfo(AddrInfo);
    }
    printf("\n");
}


//* inet6_ntoa - Converts a binary IPv6 address into a string.
//
//  Returns a pointer to the output string.
//
char *
inet6_ntoa(const struct in6_addr *Address)
{
    static char buffer[128];       // REVIEW: Use 128 or INET6_ADDRSTRLEN?
    DWORD buflen = sizeof buffer;
    struct sockaddr_in6 sin6;

    memset(&sin6, 0, sizeof sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_addr = *Address;

    if (WSAAddressToString((struct sockaddr *) &sin6,
                           sizeof sin6,
                           NULL,       // LPWSAPROTOCOL_INFO
                           buffer,
                           &buflen) == SOCKET_ERROR)
        strcpy(buffer, "<invalid>");

    return buffer;
}


//* DecodeAIFlags - converts flag bits to a symbolic string.
//  (i.e. 0x03 returns "AI_PASSIVE | AI_CANONNAME")
//
char *
DecodeAIFlags(unsigned int Flags)
{
    static char Buffer[1024];
    char *Pos;
    BOOL First = TRUE;
    int Loop;

    Pos = Buffer;
    for (Loop = 0; Loop < NUMBER_FLAGS; Loop++) {
        if (Flags & GAIFlagsArray[Loop].Flag) {
            if (!First)
                Pos += sprintf(Pos, " | ");
            Pos += sprintf(Pos, GAIFlagsArray[Loop].Name);
            First = FALSE;
        }
    }

    if (First)
        return "NONE";
    else
        return Buffer;
}


//* DecodeAIFamily - converts address family value to a symbolic string.
//
char *
DecodeAIFamily(unsigned int Family)
{
    if (Family == PF_INET)
        return "PF_INET";
    else if (Family == PF_INET6)
        return "PF_INET6";
    else if (Family == PF_UNSPEC)
        return "PF_UNSPEC";
    else
        return "UNKNOWN";
}


//* DecodeAISocktype - converts socktype value to a symbolic string.
//
char *
DecodeAISocktype(unsigned int Socktype)
{
    if (Socktype == SOCK_STREAM)
        return "SOCK_STREAM";
    else if (Socktype == SOCK_DGRAM)
        return "SOCK_DGRAM";
    else if (Socktype == SOCK_RAW)
        return "SOCK_RAW";
    else if (Socktype == SOCK_RDM)
        return "SOCK_RDM";
    else if (Socktype == SOCK_SEQPACKET)
        return "SOCK_SEQPACKET";
    else if (Socktype == 0)
        return "UNSPECIFIED";
    else
        return "UNKNOWN";
}


//* DecodeAIProtocol - converts protocol value to a symbolic string.
//
char *
DecodeAIProtocol(unsigned int Protocol)
{
    if (Protocol == IPPROTO_TCP)
        return "IPPROTO_TCP";
    else if (Protocol == IPPROTO_UDP)
        return "IPPROTO_UDP";
    else if (Protocol == 0)
        return "UNSPECIFIED";
    else
        return "UNKNOWN";
}


//* DumpAddrInfo - print the contents of an addrinfo structure to standard out.
//
void
DumpAddrInfo(ADDRINFO *AddrInfo)
{
    int Count;

    if (AddrInfo == NULL) {
        printf("AddrInfo = (null)\n");
        return;
    }

    for (Count = 1; AddrInfo != NULL; AddrInfo = AddrInfo->ai_next) {
        if ((Count != 1) || (AddrInfo->ai_next != NULL))
            printf("Record #%u:\n", Count++);
        printf(" ai_flags = %s\n", DecodeAIFlags(AddrInfo->ai_flags));
        printf(" ai_family = %s\n", DecodeAIFamily(AddrInfo->ai_family));
        printf(" ai_socktype = %s\n", DecodeAISocktype(AddrInfo->ai_socktype));
        printf(" ai_protocol = %s\n", DecodeAIProtocol(AddrInfo->ai_protocol));
        printf(" ai_addrlen = %u\n", AddrInfo->ai_addrlen);
        printf(" ai_canonname = %s\n", AddrInfo->ai_canonname);
        if (AddrInfo->ai_addr != NULL) {
            if (AddrInfo->ai_addr->sa_family == AF_INET) {
                struct sockaddr_in *sin;

                sin = (struct sockaddr_in *)AddrInfo->ai_addr;
                printf(" ai_addr->sin_family = AF_INET\n");
                printf(" ai_addr->sin_port = %u\n", ntohs(sin->sin_port));
                printf(" ai_addr->sin_addr = %s\n", inet_ntoa(sin->sin_addr));

            } else if (AddrInfo->ai_addr->sa_family == AF_INET6) {
                struct sockaddr_in6 *sin6;

                sin6 = (struct sockaddr_in6 *)AddrInfo->ai_addr;
                printf(" ai_addr->sin6_family = AF_INET6\n");
                printf(" ai_addr->sin6_port = %u\n", ntohs(sin6->sin6_port));
                printf(" ai_addr->sin6_flowinfo = %u\n", sin6->sin6_flowinfo);
                printf(" ai_addr->sin6_scope_id = %u\n", sin6->sin6_scope_id);
                printf(" ai_addr->sin6_addr = %s\n",
                       inet6_ntoa(&sin6->sin6_addr));

            } else {
                printf(" ai_addr->sa_family = %u\n",
                       AddrInfo->ai_addr->sa_family);
            }
        } else {
            printf(" ai_addr = (null)\n");
        }
    }
}


//* ListAddrInfo - succinctly list the contents of an addrinfo structure.
//
void
ListAddrInfo(ADDRINFO *AddrInfo)
{
    int ReturnValue;
    char Buffer[128];
    int Buflen;

    if (AddrInfo == NULL) {
        printf("AddrInfo = (null)\n");
        return;
    }

    for (; AddrInfo != NULL; AddrInfo = AddrInfo->ai_next) {
        Buflen = 128;
        ReturnValue = WSAAddressToString(AddrInfo->ai_addr,
                                         AddrInfo->ai_addrlen, NULL,
                                         Buffer, &Buflen);
        if (ReturnValue == SOCKET_ERROR) {
            printf("<invalid>\n");
        } else {
            printf("%s\n", Buffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\algrthms.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Security Algorithms for Internet Protocol Version 6.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "ipsec.h"
#include "security.h"
#include "null.h"
#include "hmacmd5.h"
#include "hmacsha1.h"

C_ASSERT(NULL_CONTEXT_SIZE <= MAX_CONTEXT_SIZE);
C_ASSERT(sizeof(MD5_CTX) <= MAX_CONTEXT_SIZE);
C_ASSERT(sizeof(A_SHA_CTX) <= MAX_CONTEXT_SIZE);

C_ASSERT(NULL_RESULT_SIZE <= MAX_RESULT_SIZE);
C_ASSERT(HMACMD5_RESULT_SIZE <= MAX_RESULT_SIZE);
C_ASSERT(HMACMD596_RESULT_SIZE <= MAX_RESULT_SIZE);
C_ASSERT(HMACSHA1_RESULT_SIZE <= MAX_RESULT_SIZE);
C_ASSERT(HMACSHA196_RESULT_SIZE <= MAX_RESULT_SIZE);

//* AlgorithmsInit - Initialize the algorithm table.
//
void
AlgorithmsInit()
{
    //
    // Null algorithm (for testing).
    //
    AlgorithmTable[ALGORITHM_NULL].KeySize = NULL_KEY_SIZE;
    AlgorithmTable[ALGORITHM_NULL].ContextSize = NULL_CONTEXT_SIZE;
    AlgorithmTable[ALGORITHM_NULL].ResultSize = NULL_RESULT_SIZE;
    AlgorithmTable[ALGORITHM_NULL].PrepareKey = NullKeyPrep;
    AlgorithmTable[ALGORITHM_NULL].Initialize = NullInit;
    AlgorithmTable[ALGORITHM_NULL].Operate = NullOp;
    AlgorithmTable[ALGORITHM_NULL].Finalize = NullFinal;

    //
    // Message Digest Version 5.
    //
    AlgorithmTable[ALGORITHM_HMAC_MD5].KeySize = HMACMD5_KEY_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_MD5].ContextSize = sizeof(MD5_CTX);
    AlgorithmTable[ALGORITHM_HMAC_MD5].ResultSize = HMACMD5_RESULT_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_MD5].PrepareKey = HMAC_MD5KeyPrep;
    AlgorithmTable[ALGORITHM_HMAC_MD5].Initialize = HMAC_MD5Init;
    AlgorithmTable[ALGORITHM_HMAC_MD5].Operate = HMAC_MD5Op;
    AlgorithmTable[ALGORITHM_HMAC_MD5].Finalize = HMAC_MD5Final;

    //
    // HMAC-MD5-96.
    //
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].KeySize = HMACMD5_KEY_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].ContextSize = sizeof(MD5_CTX);
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].ResultSize = HMACMD596_RESULT_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].PrepareKey = HMAC_MD5KeyPrep;
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].Initialize = HMAC_MD5Init;
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].Operate = HMAC_MD5Op;
    AlgorithmTable[ALGORITHM_HMAC_MD5_96].Finalize = HMAC_MD5_96Final;

    //
    // Secure Hash Algorithm.
    //
    AlgorithmTable[ALGORITHM_HMAC_SHA1].KeySize = HMACSHA1_KEY_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_SHA1].ContextSize = sizeof(A_SHA_CTX);
    AlgorithmTable[ALGORITHM_HMAC_SHA1].ResultSize = HMACSHA1_RESULT_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_SHA1].PrepareKey = HMAC_SHA1KeyPrep;
    AlgorithmTable[ALGORITHM_HMAC_SHA1].Initialize = HMAC_SHA1Init;
    AlgorithmTable[ALGORITHM_HMAC_SHA1].Operate = HMAC_SHA1Op;
    AlgorithmTable[ALGORITHM_HMAC_SHA1].Finalize = HMAC_SHA1Final;

    //
    // HMAC-SHA1-96.
    //
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].KeySize = HMACSHA1_KEY_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].ContextSize = sizeof(A_SHA_CTX);
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].ResultSize = HMACSHA196_RESULT_SIZE;
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].PrepareKey = HMAC_SHA1KeyPrep;
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].Initialize = HMAC_SHA1Init;
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].Operate = HMAC_SHA1Op;
    AlgorithmTable[ALGORITHM_HMAC_SHA1_96].Finalize = HMAC_SHA1_96Final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\samples\testai\testai.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Test program for IPv6 APIs.
//

#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>


//
// Prototypes for local functions.
//
int Test_getaddrinfo(int argc, char **argv);
int Test_getnameinfo();


//
// getaddrinfo flags
// This array maps values to names for pretty-printing purposes.
// Used by DecodeAIFlags().
//
// TBD: When we add support for AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and
// TBD: AI_ADDRCONFIG to getaddrinfo (and thus define them in ws2tcpip.h),
// TBD: we'll need to add them here too.
//
// Note when adding flags: all the string names plus connecting OR symbols
// must fit into the buffer in DecodeAIFlags() below.  Enlarge as required.
//
typedef struct GAIFlagsArrayEntry {
    int Flag;
    char *Name;
} GAIFlagsArrayEntry;
GAIFlagsArrayEntry GAIFlagsArray [] = {
    {AI_PASSIVE, "AI_PASSIVE"},
    {AI_CANONNAME, "AI_CANONNAME"},
    {AI_NUMERICHOST, "AI_NUMERICHOST"}
};
#define NUMBER_FLAGS (sizeof(GAIFlagsArray) / sizeof(GAIFlagsArrayEntry))


//
// Global variables.
//
IN_ADDR v4Address = {157, 55, 254, 211};
IN6_ADDR v6Address = {0x3f, 0xfe, 0x1c, 0xe1, 0x00, 0x00, 0xfe, 0x01,
                      0x02, 0xa0, 0xcc, 0xff, 0xfe, 0x3b, 0xce, 0xef};
IN6_ADDR DeadBeefCafeBabe = {0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
                             0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef};
IN6_ADDR MostlyZero = {0x3f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
IN6_ADDR v4Mapped = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x00, 0x00, 0xff, 0xff, 157, 55, 254, 211};

SOCKADDR_IN
v4SockAddr = {AF_INET, 6400, {157, 55, 254, 211}, 0};

SOCKADDR_IN6
v6SockAddr = {AF_INET6, 2, 0,
              {0x3f, 0xfe, 0x1c, 0xe1, 0x00, 0x00, 0xfe, 0x01,
               0x02, 0xa0, 0xcc, 0xff, 0xfe, 0x3b, 0xce, 0xef},
              0};

SOCKADDR_IN6
DBCBSockAddr = {AF_INET6, 2, 0,
                {0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
                 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
                0};

SOCKADDR_IN6
LinkLocalSockAddr = {AF_INET6, 0x1500, 0,
                     {0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
                    3};

//
// Description of a getaddrinfo test.
// Contains the values of each of the arguments passed to getaddrinfo.
//
typedef struct GAITestEntry {
    char *NodeName;
    char *ServiceName;
    ADDRINFO Hints;
} GAITestEntry;

#define TAKE_FROM_USER ((char *)1)

//
// getaddrinfo test array
//
// One entry per test.
// Each entry specifies the arguments to give to getaddrinfo for that test.
//
GAITestEntry GAITestArray[] = {
{TAKE_FROM_USER, NULL, {0, 0, 0, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, NULL, {AI_PASSIVE, 0, 0, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, NULL, {AI_CANONNAME, 0, 0, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, NULL, {AI_NUMERICHOST, 0, 0, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, NULL, {0, PF_INET, 0, 0, 0, NULL, NULL, NULL}},
{NULL, "ftp", {AI_PASSIVE, 0, SOCK_STREAM, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, "ftp", {AI_PASSIVE, 0, SOCK_STREAM, 0, 0, NULL, NULL, NULL}},
{TAKE_FROM_USER, "smtp", {0, 0, SOCK_STREAM, 0, 0, NULL, NULL, NULL}},
{"1111:2222:3333:4444:5555:6666:7777:8888", "42",
    {0, 0, 0, 0, 0, NULL, NULL, NULL}},
{"fe80::0123:4567:89ab:cdef%3", "telnet",
    {AI_NUMERICHOST, 0, SOCK_STREAM, 0, 0, NULL, NULL, NULL}},
{"157.55.254.211", "exec",
    {AI_PASSIVE | AI_NUMERICHOST, PF_INET, 0, 0, 0, NULL, NULL, NULL}},
// Ask for a stream-only service on a datagram socket.
{NULL, "exec", {AI_PASSIVE, 0, SOCK_DGRAM, 0, 0, NULL, NULL, NULL}},
// Ask for a numeric-only lookup, but give an ascii name.
{"localhost", "pop3",
    {AI_PASSIVE | AI_NUMERICHOST, 0, 0, 0, 0, NULL, NULL, NULL}},
};
#define NUMBER_GAI_TESTS (sizeof(GAITestArray) / sizeof(GAITestEntry))


//* main - various startup stuff.
//
int __cdecl
main(int argc, char **argv)
{
    WSADATA wsaData;
    int Failed = 0;

    //
    // Initialize Winsock.
    //
    if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        printf("WSAStartup failed\n");
        exit(1);
    }

    printf("\nThis program tests getaddrinfo functionality.\n");

#ifdef _WSPIAPI_H_
    //
    // Including wspiapi.h will insert code to search the appropriate
    // system libraries for an implementation of getaddrinfo et. al.
    // If they're not found on the system, it will back off to using
    // statically compiled in versions that handle IPv4 only.
    // Force getaddrinfo and friends to load now so we can report
    // which ones we are using.
    //
    printf("Compiled with wspiapi.h for backwards compatibility.\n\n");
    if (WspiapiLoad(0) == WspiapiLegacyGetAddrInfo) {
        printf("Using statically compiled-in (IPv4 only) version of getaddrinfo.\n");
    } else {
        printf("Using dynamically loaded version of getaddrinfo.\n");
    }
#else
    printf("Compiled without wspiapi.h.  "
           "Will not work on systems without getaddrinfo.\n");
#endif

    printf("\n");

    //
    // Run tests.
    //
    Failed += Test_getaddrinfo(argc, argv);
//    Failed += Test_getnameinfo();

//    printf("%d of the tests failed\n", Failed);

    return 0;
}


//* inet6_ntoa - Converts a binary IPv6 address into a string.
//
//  Returns a pointer to the output string.
//
char *
inet6_ntoa(const struct in6_addr *Address)
{
    static char buffer[128];       // REVIEW: Use 128 or INET6_ADDRSTRLEN?
    DWORD buflen = sizeof buffer;
    struct sockaddr_in6 sin6;

    memset(&sin6, 0, sizeof sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_addr = *Address;

    if (WSAAddressToString((struct sockaddr *) &sin6,
                           sizeof sin6,
                           NULL,       // LPWSAPROTOCOL_INFO
                           buffer,
                           &buflen) == SOCKET_ERROR)
        strcpy(buffer, "<invalid>");

    return buffer;
}


//* DecodeAIFlags - converts flag bits to a symbolic string.
//  (i.e. 0x03 returns "AI_PASSIVE | AI_CANONNAME")
//
char *
DecodeAIFlags(unsigned int Flags)
{
    static char Buffer[1024];
    char *Pos;
    BOOL First = TRUE;
    int Loop;

    Pos = Buffer;
    for (Loop = 0; Loop < NUMBER_FLAGS; Loop++) {
        if (Flags & GAIFlagsArray[Loop].Flag) {
            if (!First)
                Pos += sprintf(Pos, " | ");
            Pos += sprintf(Pos, GAIFlagsArray[Loop].Name);
            First = FALSE;
        }
    }

    if (First)
        return "NONE";
    else
        return Buffer;
}


//* DecodeAIFamily - converts address family value to a symbolic string.
//
char *
DecodeAIFamily(unsigned int Family)
{
    if (Family == PF_INET)
        return "PF_INET";
    else if (Family == PF_INET6)
        return "PF_INET6";
    else if (Family == PF_UNSPEC)
        return "PF_UNSPEC";
    else
        return "UNKNOWN";
}


//* DecodeAISocktype - converts socktype value to a symbolic string.
//
char *
DecodeAISocktype(unsigned int Socktype)
{
    if (Socktype == SOCK_STREAM)
        return "SOCK_STREAM";
    else if (Socktype == SOCK_DGRAM)
        return "SOCK_DGRAM";
    else if (Socktype == SOCK_RAW)
        return "SOCK_RAW";
    else if (Socktype == SOCK_RDM)
        return "SOCK_RDM";
    else if (Socktype == SOCK_SEQPACKET)
        return "SOCK_SEQPACKET";
    else if (Socktype == 0)
        return "UNSPECIFIED";
    else
        return "UNKNOWN";
}


//* DecodeAIProtocol - converts protocol value to a symbolic string.
//
char *
DecodeAIProtocol(unsigned int Protocol)
{
    if (Protocol == IPPROTO_TCP)
        return "IPPROTO_TCP";
    else if (Protocol == IPPROTO_UDP)
        return "IPPROTO_UDP";
    else if (Protocol == 0)
        return "UNSPECIFIED";
    else
        return "UNKNOWN";
}


//* DumpAddrInfo - print the contents of an addrinfo structure to standard out.
//
void
DumpAddrInfo(ADDRINFO *AddrInfo)
{
    int Count;

    if (AddrInfo == NULL) {
        printf("AddrInfo = (null)\n");
        return;
    }

    for (Count = 1; AddrInfo != NULL; AddrInfo = AddrInfo->ai_next) {
        if ((Count != 1) || (AddrInfo->ai_next != NULL))
            printf("Record #%u:\n", Count++);
        printf(" ai_flags = %s\n", DecodeAIFlags(AddrInfo->ai_flags));
        printf(" ai_family = %s\n", DecodeAIFamily(AddrInfo->ai_family));
        printf(" ai_socktype = %s\n", DecodeAISocktype(AddrInfo->ai_socktype));
        printf(" ai_protocol = %s\n", DecodeAIProtocol(AddrInfo->ai_protocol));
        printf(" ai_addrlen = %u\n", AddrInfo->ai_addrlen);
        printf(" ai_canonname = %s\n", AddrInfo->ai_canonname);
        if (AddrInfo->ai_addr != NULL) {
            if (AddrInfo->ai_addr->sa_family == AF_INET) {
                struct sockaddr_in *sin;

                sin = (struct sockaddr_in *)AddrInfo->ai_addr;
                printf(" ai_addr->sin_family = AF_INET\n");
                printf(" ai_addr->sin_port = %u\n", ntohs(sin->sin_port));
                printf(" ai_addr->sin_addr = %s\n", inet_ntoa(sin->sin_addr));

            } else if (AddrInfo->ai_addr->sa_family == AF_INET6) {
                struct sockaddr_in6 *sin6;

                sin6 = (struct sockaddr_in6 *)AddrInfo->ai_addr;
                printf(" ai_addr->sin6_family = AF_INET6\n");
                printf(" ai_addr->sin6_port = %u\n", ntohs(sin6->sin6_port));
                printf(" ai_addr->sin6_flowinfo = %u\n", sin6->sin6_flowinfo);
                printf(" ai_addr->sin6_scope_id = %u\n", sin6->sin6_scope_id);
                printf(" ai_addr->sin6_addr = %s\n",
                       inet6_ntoa(&sin6->sin6_addr));

            } else {
                printf(" ai_addr->sa_family = %u\n",
                       AddrInfo->ai_addr->sa_family);
            }
        } else {
            printf(" ai_addr = (null)\n");
        }
    }
}


//* Test_getaddrinfo - Test getaddrinfo.
//
//  Note that getaddrinfo returns an error value,
//  instead of setting last error.
//
int
Test_getaddrinfo(int argc, char **argv)
{
    char *NodeName, *TestName, *ServiceName;
    int ReturnValue;
    ADDRINFO *AddrInfo;
    int Loop;

    if (argc < 2)
        NodeName = "localhost";
    else
        NodeName = argv[1];

    for (Loop = 0; Loop < NUMBER_GAI_TESTS; Loop++) {
        printf("Running test #%u\n", Loop);

        if (GAITestArray[Loop].NodeName == TAKE_FROM_USER) {
            GAITestArray[Loop].NodeName = NodeName;
        }

        printf("Hints contains:\n");
        DumpAddrInfo(&GAITestArray[Loop].Hints);
        printf("Calling getaddrinfo(\"%s\", \"%s\", &Hints, &AddrInfo)\n",
               GAITestArray[Loop].NodeName,
               GAITestArray[Loop].ServiceName);
        ReturnValue = getaddrinfo(GAITestArray[Loop].NodeName,
                                  GAITestArray[Loop].ServiceName,
                                  &GAITestArray[Loop].Hints,
                                  &AddrInfo);
        printf("Returns %d (%s)\n", ReturnValue,
               ReturnValue ? gai_strerror(ReturnValue) : "no error");
        if (AddrInfo != NULL) {
            printf("AddrInfo contains:\n");
            DumpAddrInfo(AddrInfo);
            freeaddrinfo(AddrInfo);
        }
        printf("\n");
    }

    return 0;
};


#if 0
//* Test_getnameinfo - Test getnameinfo.
//
//  Note that getnameinfo returns an error value,
//  instead of setting last error.
//
int
Test_getnameinfo()
{
    int ReturnValue;
    char NodeName[NI_MAXHOST];
    char ServiceName[NI_MAXSERV];
    char Tiny[2];
    int Error;

    printf("\ngetnameinfo:\n\n");

    // Test with reasonable input:
    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&v4SockAddr,
                              sizeof v4SockAddr, NodeName, sizeof NodeName,
                              ServiceName, sizeof ServiceName, 0);
    printf("getnameinfo((struct sockaddr *)&v4SockAddr, "
           "sizeof v4SockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, 0)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&v6SockAddr,
                              sizeof v6SockAddr, NodeName, sizeof NodeName,
                              ServiceName, sizeof ServiceName, 0);
    printf("getnameinfo((struct sockaddr *)&v6SockAddr, "
           "sizeof v6SockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, 0)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&DBCBSockAddr,
                              sizeof DBCBSockAddr, NodeName, sizeof NodeName,
                              ServiceName, sizeof ServiceName, NI_DGRAM);
    printf("getnameinfo((struct sockaddr *)&DBCBSockAddr, "
           "sizeof DBCBSockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, NI_DGRAM)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&LinkLocalSockAddr,
                              sizeof LinkLocalSockAddr, NodeName,
                              sizeof NodeName, ServiceName,
                              sizeof ServiceName, NI_NUMERICHOST);
    printf("getnameinfo((struct sockaddr *)&LinkLocalSockAddr, "
           "sizeof LinkLocalSockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, NI_NUMERICHOST)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&LinkLocalSockAddr,
                              sizeof LinkLocalSockAddr, NodeName,
                              sizeof NodeName, ServiceName,
                              sizeof ServiceName, NI_NUMERICSERV);
    printf("getnameinfo((struct sockaddr *)&LinkLocalSockAddr, "
           "sizeof LinkLocalSockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, NI_NUMERICSERV)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&v4SockAddr,
                              sizeof v4SockAddr, NodeName, sizeof NodeName,
                              ServiceName, sizeof ServiceName,
                              NI_NUMERICHOST | NI_NUMERICSERV);
    printf("getnameinfo((struct sockaddr *)&v4SockAddr, "
           "sizeof v4SockAddr, NodeName, sizeof NodeName, "
           "ServiceName, sizeof ServiceName, "
           "NI_NUMERICHOST | NI_NUMERICSERV)\nReturns %d\n"
           "NodeName = %s\nServiceName = %s\n", ReturnValue,
           NodeName, ServiceName);
    printf("\n");

    // Try to shoehorn too much into too little.
    memset(Tiny, 0, sizeof Tiny);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&DBCBSockAddr,
                              sizeof DBCBSockAddr, Tiny, sizeof Tiny,
                              ServiceName, sizeof ServiceName, 0);
    printf("getnameinfo((struct sockaddr *)&DBCBSockAddr, "
           "sizeof DBCBSockAddr, Tiny, sizeof Tiny, "
           "ServiceName, sizeof ServiceName, 0)\nReturns %d\n"
           "Tiny = %s\nServiceName = %s\n", ReturnValue,
           Tiny, ServiceName);
    printf("\n");

    memset(Tiny, 0, sizeof Tiny);
    memset(ServiceName, 0, sizeof ServiceName);
    ReturnValue = getnameinfo((struct sockaddr *)&DBCBSockAddr,
                              sizeof DBCBSockAddr, Tiny, sizeof Tiny,
                              ServiceName, sizeof ServiceName, NI_NUMERICHOST);
    printf("getnameinfo((struct sockaddr *)&DBCBSockAddr, "
           "sizeof DBCBSockAddr, Tiny, sizeof Tiny, "
           "ServiceName, sizeof ServiceName, NI_NUMERICHOST)\nReturns %d\n"
           "Tiny = %s\nServiceName = %s\n", ReturnValue,
           Tiny, ServiceName);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(Tiny, 0, sizeof Tiny);
    ReturnValue = getnameinfo((struct sockaddr *)&v4SockAddr,
                              sizeof v4SockAddr, NodeName, sizeof NodeName,
                              Tiny, sizeof Tiny, 0);
    printf("getnameinfo((struct sockaddr *)&v4SockAddr, "
           "sizeof v4SockAddr, NodeName, sizeof NodeName, "
           "Tiny, sizeof Tiny, 0)\nReturns %d\n"
           "NodeName = %s\nTiny = %s\n", ReturnValue,
           NodeName, Tiny);
    printf("\n");

    memset(NodeName, 0, sizeof NodeName);
    memset(Tiny, 0, sizeof Tiny);
    ReturnValue = getnameinfo((struct sockaddr *)&v4SockAddr,
                              sizeof v4SockAddr, NodeName, sizeof NodeName,
                              Tiny, sizeof Tiny, NI_NUMERICSERV);
    printf("getnameinfo((struct sockaddr *)&v4SockAddr, "
           "sizeof v4SockAddr, NodeName, sizeof NodeName, "
           "Tiny, sizeof Tiny, NI_NUMERICSERV)\nReturns %d\n"
           "NodeName = %s\nTiny = %s\n", ReturnValue,
           NodeName, Tiny);
    printf("\n");

    return 0;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\hmacmd5.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions for null authentication algorithm.  For test purposes.
//

#include "md5.h"

#ifndef HMACMD5_INCLUDED
#define HMACMD5_INCLUDED 1

#define HMACMD5_KEY_SIZE 128  // In bytes.
#define HMACMD5_CONTEXT_SIZE sizeof(MD5_CTX)
#define HMACMD5_RESULT_SIZE 16  // In bytes.
#define HMACMD596_RESULT_SIZE 12 // In bytes.

AlgorithmKeyPrepProc HMAC_MD5KeyPrep;
AlgorithmInitProc HMAC_MD5Init;
AlgorithmOpProc HMAC_MD5Op;
AlgorithmFinalProc HMAC_MD5Final;
AlgorithmFinalProc HMAC_MD5_96Final;

#endif // HMACMD5_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\hmacsha1.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// HMAC (Hashed? Message Authentication Code) wrapper for SHA-1 algorithm.
// This code is based on the algorithm given in RFC 2104, which for HMAC-SHA1
// is SHA-1(Key XOR outer pad, SHA-1(Key XOR inner pad, text)), where the
// inner pad is 64 bytes of 0x36 and the outer pad is 64 bytes of 0x5c.
//

#include <string.h>
#include "oscfg.h"
#include <sha.h>


//* HMAC_SHA1KeyPrep - preprocess raw keying data into directly usuable form.
//
//  This routine is called to convert raw keying information into the most
//  convienient form for later processing.  For SHA-1, we hash keys larger than
//  64 bytes down to 64 bytes.  We also perform the XOR operations between the
//  key and the inner and outer pads here since they don't change once we have
//  the key.  Thus we return 128 bytes of data: 64 bytes of the (possibly
//  folded) key XOR'd with the inner pad, and 64 bytes of the key XOR'd with
//  the outer pad.
//
//  REVIEW: Instead of "Temp", we could operate directly "*Key".
//
void
HMAC_SHA1KeyPrep(
    uchar *RawKey,    // Raw keying information.
    uint RawKeySize,  // Size of above in bytes.
    uchar *Key)       // Resulting 128 bytes of preprocessed key info.
{
    uchar Temp[128];
    uint Loop;

    //
    // Load raw key into temp storage.
    // Constrain size of keying information to 64 bytes.
    //
    memset(Temp, 0, 64);
    if (RawKeySize > 64) {
        A_SHA_CTX Context;

        //
        // Use SHA-1 to hash key down to 20 bytes.
        //
        A_SHAInit(&Context);
        A_SHAUpdate(&Context, RawKey, RawKeySize);
        A_SHAFinal(&Context, Temp);

    } else
        memcpy(Temp, RawKey, RawKeySize);

    //
    // The first 64 bytes of "Temp" contain our (possibly hashed) key.
    // Make a copy of this in the second 64 bytes.
    //
    memcpy(&Temp[64], Temp, 64);

    //
    // XOR the first 64 bytes with the inner pad, and the second 64 bytes
    // with the outer pad.
    //
    for (Loop = 0; Loop < 64; Loop++) {
        Temp[Loop] ^= 0x36;       // Inner Pad.
        Temp[Loop + 64] ^= 0x5c;  // Outer Pad.
    }

    //
    // Return the result to location designated by our caller.
    //
    memcpy(Key, Temp, 128);

    //
    // Zero sensitive information.
    // REVIEW: Bother?
    //
    RtlSecureZeroMemory(Temp, 128);
}


//* HMAC_SHA1Init - prepare to process data.
// 
void
HMAC_SHA1Init(
    void *GenericContext,  // HMAC-SHA1 context maintained across operations.
    uchar *Key)            // Keying information.
{
    A_SHA_CTX *Context = GenericContext;

    //
    // Start off the inner hash.  I.e. "SHA-1(Key XOR inner pad, ...".
    //
    A_SHAInit(Context);
    A_SHAUpdate(Context, Key, 64);
}


//* HMAC_SHA1Op - Process a chunk of data.
// 
void
HMAC_SHA1Op(
    void *GenericContext,  // HMAC-SHA1 context maintained across operations.
    uchar *Key,            // Keying information.
    uchar *Data,           // Data to process.
    uint Len)              // Amount of above in bytes.
{
    A_SHA_CTX *Context = GenericContext;

    UNREFERENCED_PARAMETER(Key);

    //
    // Continue the inner hash.  I.e. "SHA-1(..., text)".
    //
    A_SHAUpdate(Context, Data, Len);
}


//* HMAC_SHA1Final - close off processing current data and return result.
// 
//  REVIEW: Instead of "Temp", we could operate directly "*Result".
//
void
HMAC_SHA1Final(
    void *GenericContext,  // HMAC-SHA1 context maintained across operations.
    uchar *Key,            // Keying information.
    uchar *Result)         // Where to put result of this process.
{
    uchar Temp[20];
    A_SHA_CTX *Context = GenericContext;

    //
    // Finish the inner hash.
    //
    A_SHAFinal(Context, Temp);

    //
    // Perform the outer hash.  I.e. SHA-1(Key XOR outer pad, ...).
    // SHA1Final returns the result directly to our caller.
    //
    A_SHAInit(Context);
    A_SHAUpdate(Context, &Key[64], 64);
    A_SHAUpdate(Context, Temp, 20);
    A_SHAFinal(Context, Result);

    //
    // Zero sensitive information.
    // REVIEW: Bother?
    //
    RtlSecureZeroMemory(Temp, 20);
}

void
HMAC_SHA1_96Final(
    void *GenericContext,  // HMAC-SHA1 context maintained across operations.
    uchar *Key,            // Keying information.
    uchar *Result)         // Where to put result of this process.
{
    uchar Temp[20];
    A_SHA_CTX *Context = GenericContext;

    //
    // Finish the inner hash.
    //
    A_SHAFinal(Context, Temp);

    //
    // Perform the outer hash.  I.e. SHA-1(Key XOR outer pad, ...).
    //
    A_SHAInit(Context);
    A_SHAUpdate(Context, &Key[64], 64);
    A_SHAUpdate(Context, Temp, 20);
    A_SHAFinal(Context, Temp);

    //
    // Truncate the SHA1 20 byte output to 12 bytes.
    // The first 12 bytes from the left are stored.
    //
    memcpy(Result, Temp, 12);

    //
    // Zero sensitive information.
    // REVIEW: Bother?
    //
    RtlSecureZeroMemory(Temp, 20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\hmacsha1.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions for null authentication algorithm.  For test purposes.
//

#include <sha.h>

#ifndef HMACSHA1_INCLUDED
#define HMACSHA1_INCLUDED 1

#define HMACSHA1_KEY_SIZE 128  // In bytes.
#define HMACSHA1_CONTEXT_SIZE sizeof(SHA1Context)
#define HMACSHA1_RESULT_SIZE 20  // In bytes.
#define HMACSHA196_RESULT_SIZE 12  // In bytes.

AlgorithmKeyPrepProc HMAC_SHA1KeyPrep;
AlgorithmInitProc HMAC_SHA1Init;
AlgorithmOpProc HMAC_SHA1Op;
AlgorithmFinalProc HMAC_SHA1Final;
AlgorithmFinalProc HMAC_SHA1_96Final;

#endif // HMACSHA1_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\hmacmd5.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// HMAC (Hashed? Message Authentication Code) wrapper for MD5 algorithm.
// This code is based on the algorithm given in RFC 2104, which for
// HMAC-MD5 is MD5(Key XOR outer pad, MD5(Key XOR inner pad, text)), where
// the inner pad is 64 bytes of 0x36 and the outer pad is 64 bytes of 0x5c.
//

#include <string.h>
#include "oscfg.h"
#include "md5.h"


//* HMAC_MD5KeyPrep - preprocess raw keying data into directly usuable form.
//
//  This routine is called to convert raw keying information into the most
//  convienient form for later processing.  For MD5, we hash keys larger than
//  64 bytes down to 64 bytes.  We also perform the XOR operations between the
//  key and the inner and outer pads here since they don't change once we have
//  the key.  Thus we return 128 bytes of data: 64 bytes of the (possibly
//  folded) key XOR'd with the inner pad, and 64 bytes of the key XOR'd with
//  the outer pad.
//
//  REVIEW: Instead of "Temp", we could operate directly "*Key".
//
void
HMAC_MD5KeyPrep(
    uchar *RawKey,    // Raw keying information.
    uint RawKeySize,  // Size of above in bytes.
    uchar *Key)       // Resulting 128 bytes of preprocessed key info.
{
    uchar Temp[128];
    uint Loop;

    //
    // Load raw key into temp storage.
    // Constrain size of keying information to 64 bytes.
    //
    memset(Temp, 0, 64);
    if (RawKeySize > 64) {
        MD5_CTX Context;

        //
        // Use MD5 to hash key down to 16 bytes.
        //
        MD5Init(&Context);
        MD5Update(&Context, RawKey, RawKeySize);
        MD5Final(&Context);
        memcpy(Temp, Context.digest, MD5DIGESTLEN);

    } else
        memcpy(Temp, RawKey, RawKeySize);

    //
    // The first 64 bytes of "Temp" contain our (possibly hashed) key.
    // Make a copy of this in the second 64 bytes.
    //
    memcpy(&Temp[64], Temp, 64);

    //
    // XOR the first 64 bytes with the inner pad, and the second 64 bytes
    // with the outer pad.
    //
    for (Loop = 0; Loop < 64; Loop++) {
        Temp[Loop] ^= 0x36;       // Inner Pad.
        Temp[Loop + 64] ^= 0x5c;  // Outer Pad.
    }

    //
    // Return the result to location designated by our caller.
    //
    memcpy(Key, Temp, 128);

    //
    // Zero sensitive information.
    // REVIEW: bother?
    //
    RtlSecureZeroMemory(Temp, 128);
}


//* HMAC_MD5Init - prepare to process data.
// 
void
HMAC_MD5Init(
    void *Context,  // HMAC-MD5 context maintained across operations.
    uchar *Key)     // Keying information.
{
    MD5_CTX *MD5_Context = Context;

    //
    // Start off the inner hash.  I.e. "MD5(Key XOR inner pad, ...".
    //
    MD5Init(MD5_Context);
    MD5Update(MD5_Context, Key, 64);
}


//* HMAC_MD5Op - Process a chunk of data.
// 
void
HMAC_MD5Op(
    void *Context,  // HMAC-MD5 context maintained across operations.
    uchar *Key,     // Keying information.
    uchar *Data,    // Data to process.
    uint Len)       // Amount of above in bytes.
{
    MD5_CTX *MD5_Context = Context;

    UNREFERENCED_PARAMETER(Key);

    //
    // Continue the inner hash.  I.e. "MD5(..., text)".
    //
    MD5Update(MD5_Context, Data, Len);
}


//* HMAC_MD5Finalize - close off processing current data and return result.
// 
//  REVIEW: Instead of "Temp", we could operate directly "*Result".
//
void
HMAC_MD5Final(
    void *Context,  // HMAC-MD5 context maintained across operations.
    uchar *Key,     // Keying information.
    uchar *Result)  // Where to put result of this process.
{
    uchar Temp[16];
    MD5_CTX *MD5_Context = Context;

    //
    // Finish the inner hash.
    //
    MD5Final(MD5_Context);
    memcpy(Temp, MD5_Context->digest, MD5DIGESTLEN);

    //
    // Perform the outer hash.  I.e. MD5(Key XOR outer pad, ...).
    // MD5Final returns the result directly to our caller.
    //
    MD5Init(MD5_Context);
    MD5Update(MD5_Context, &Key[64], 64);
    MD5Update(MD5_Context, Temp, 16);
    MD5Final(MD5_Context);
    memcpy(Result, MD5_Context->digest, MD5DIGESTLEN);

    //
    // Zero sensitive information.
    // REVIEW: bother?
    //
    RtlSecureZeroMemory(Temp, 16);
}

void
HMAC_MD5_96Final(
    void *Context,  // HMAC-MD5 context maintained across operations.
    uchar *Key,     // Keying information.
    uchar *Result)  // Where to put result of this process.
{
    uchar Temp[16];
    MD5_CTX *MD5_Context = Context;

    //
    // Finish the inner hash.
    //
    MD5Final(MD5_Context);
    memcpy(Temp, MD5_Context->digest, MD5DIGESTLEN);

    //
    // Perform the outer hash.  I.e. MD5(Key XOR outer pad, ...).
    //
    MD5Init(MD5_Context);
    MD5Update(MD5_Context, &Key[64], 64);
    MD5Update(MD5_Context, Temp, 16);
    MD5Final(MD5_Context);

    //
    // Truncate the MD5 16 byte output to 12 bytes.
    // The first 12 bytes from the left are stored.
    //
    memcpy(Result, MD5_Context->digest, 12);

    //
    // Zero sensitive information.
    // REVIEW: bother?
    //
    RtlSecureZeroMemory(Temp, 16);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\null.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Null authentication algorithm.  For test purposes.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "ipsec.h"
#include "security.h"
#include "null.h"


//* NullKeyPrep - preprocess raw keying data into directly usuable form.
//
//  This routine is called to convert raw keying information into the most
//  convienient form for later processing.  For the null algorithm, we just
//  return 128 zero bytes.
//
void
NullKeyPrep(
    uchar *RawKey,    // Raw keying information.
    uint RawKeySize,  // Size of above in bytes.
    uchar *Key)       // Resulting 128 bytes of preprocessed key info.
{
    UNREFERENCED_PARAMETER(RawKey);
    UNREFERENCED_PARAMETER(RawKeySize);

    //
    // Zero key size bytes at the location designated by our caller.
    //
    memset(Key, 0, NULL_KEY_SIZE);
}


//* NullInit - prepare to process data.
//
//  We don't need to maintain any context in order to do nothing, so
//  this isn't very exciting.
// 
void
NullInit(
    void *Context,  // Context info maintained across operations.
    uchar *Key)     // Keying information.
{
    UNREFERENCED_PARAMETER(Key);

    //
    // Just to test the code a bit, zero the context field.
    //
    memset(Context, 0, NULL_CONTEXT_SIZE);
}


//* NullOp - Process a chunk of data.
//
//  NullOp is a No-Op.
// 
void
NullOp(
    void *Context,  // Context info maintained across operations.
    uchar *Key,     // Keying information.
    uchar *Data,    // Data to process.
    uint Len)       // Amount of above in bytes.
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(Data);
    UNREFERENCED_PARAMETER(Len);
}


//* NullFinal - close off processing current data and return result.
//
//  Our result is always zero.
//
void
NullFinal(
    void *Context,  // Context info maintained across operations.
    uchar *Key,     // Keying information.
    uchar *Result)  // Where to put result of this process.
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Key);

    //
    // Zero result size bytes at the location designated by our caller.
    //
    memset(Result, 0, NULL_RESULT_SIZE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\alloca.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Declares the alloca compiler intrinsic.


void * __cdecl _alloca(size_t);
#if     !__STDC__
/* Non-ANSI names for compatibility */
#define alloca  _alloca
#endif  /* __STDC__*/
#if defined(_M_MRX000) || defined(_M_PPC) || defined(_M_ALPHA)
#pragma intrinsic(_alloca)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\algrthms\null.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions for null authentication algorithm.  For test purposes.
//

#ifndef NULL_INCLUDED
#define NULL_INCLUDED 1

#define NULL_KEY_SIZE 128  // In bytes.
#define NULL_CONTEXT_SIZE 4 // In bytes.  Arbitrary for null algorithm.
#define NULL_RESULT_SIZE 16  // In bytes.

AlgorithmKeyPrepProc NullKeyPrep;
AlgorithmInitProc NullInit;
AlgorithmOpProc NullOp;
AlgorithmFinalProc NullFinal;

#endif // NULL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\addr.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains the definitions of TDI address objects and related
// constants and structures.
//


#define ao_signature 0x20204F41  // 'AO  '.

#define WILDCARD_PORT 0          // 0 means assign a port.

#define MIN_USER_PORT 1025       // Minimum value for a wildcard port.
#define MAX_USER_PORT 5000       // Maximim value for a user port.
#define NUM_USER_PORTS (uint)(MaxUserPort - MIN_USER_PORT + 1)

#define NETBT_SESSION_PORT 139

typedef struct AddrObj AddrObj;

// Datagram transport-specific send function.
typedef void (*DGSendProc)(AddrObj *SrcAO, void *SendReq);

//
// Definition of the structure of an address object.  Each object represents
// a local address, and the IP portion may be a wildcard.
//
typedef struct AddrObj {
#if DBG
    ulong ao_sig;
#endif
    struct AddrObj *ao_next;           // Next address object in chain.
    KSPIN_LOCK ao_lock;                // Lock for this object.
    struct AORequest *ao_request;      // Pointer to pending request.
    Queue ao_sendq;                    // Queue of sends waiting for transmit.
    Queue ao_pendq;                    // Linkage for pending queue.
    Queue ao_rcvq;                     // Receive queue.
    IPv6Addr ao_addr;                  // IP address for this address object.
    ulong ao_scope_id;                 // Scope ID of IP address (0 if none).
    ushort ao_port;                    // Local port for this address object.
    uchar ao_prot;                     // Protocol for this AO.
    uchar ao_index;                    // Index into table of this AO.
    ulong ao_flags;                    // Flags for this object.
    uint ao_listencnt;                 // Number of listening connections.
    ushort ao_usecnt;                  // Count of 'uses' on AO.
    ushort ao_inst;                    // 'Instance' number of this AO.
    int ao_ucast_hops;                 // Hop count for unicast packets.
    uint ao_mcast_if;                  // Our multicast source interface.
    int ao_mcast_hops;                 // Hop count for multicast packets.
    int ao_mcast_loop;                 // The multicast loopback state.
    int ao_protect;                    // Protection level.
    Queue ao_activeq;                  // Queue of active connections.
    Queue ao_idleq;                    // Queue of inactive (no TCB) connctns.
    Queue ao_listenq;                  // Queue of listening connections.
    WORK_QUEUE_ITEM ao_workitem;       // Work-queue item to use for this AO.
    PConnectEvent ao_connect;          // Connect event handle.
    PVOID ao_conncontext;              // Receive DG context.
    PDisconnectEvent ao_disconnect;    // Disconnect event routine.
    PVOID ao_disconncontext;           // Disconnect event context.
    PErrorEvent ao_error;              // Error event routine.
    PVOID ao_errcontext;               // Error event context.
    PRcvEvent ao_rcv;                  // Receive event handler.
    PVOID ao_rcvcontext;               // Receive context.
    PRcvDGEvent ao_rcvdg;              // Receive DG event handler.
    PVOID ao_rcvdgcontext;             // Receive DG context.
    PRcvEvent ao_exprcv;               // Expedited receive event handler.
    PVOID ao_exprcvcontext;            // Expedited receive context.
    struct AOMCastAddr *ao_mcastlist;  // List of active multicast addresses.
    DGSendProc ao_dgsend;              // Datagram transport send function.
    PTDI_IND_ERROR_EX  ao_errorex;     // Error event routine.
    PVOID ao_errorexcontext;           // Error event context.
    ushort ao_maxdgsize;               // maximum user datagram size.
    ushort ao_udp_cksum_cover;         // UDP-Lite checksum coverage.
    ulong ao_owningpid;                // Process ID of owner.
    uint* ao_iflist;                   // List of enabled interfaces.
    PSECURITY_DESCRIPTOR ao_sd;        // SD for port-sharing access checks.
} AddrObj;

#define AO_SENTDATA_FLAG     0x00040000 // AO has had at least one send done.
#define AO_RCV_HOPLIMIT_FLAG 0x00020000 // Receive HopLimit in aux data.
//                           0x00010000    Reserved for AO_WINSET_FLAG.
//                           0x00008000    Reserved for AO_SCALE_CWIN_FLAG.
//                           0x00004000    Reserved for AO_DEFERRED_FLAG.
#define AO_PKTINFO_FLAG      0x00002000 // Packet info structure passed in
                                        // control info (WSARecvMsg).
#define AO_SHARE_FLAG        0x00001000 // AddrObj can be shared.
//                           0x00000800    Reserved for AO_CONNUDP_FLAG.
#define AO_HDRINCL_FLAG      0x00000400 // User provides IP header on raw send.
#define AO_RAW_FLAG          0x00000200 // AO is for a raw endpoint.
#define AO_DHCP_FLAG         0x00000100 // AO is bound to real 0 address.

#define AO_VALID_FLAG        0x00000080 // AddrObj is valid.
#define AO_BUSY_FLAG         0x00000040 // AddrObj is busy (i.e., has it 
                                        // exclusive).
#define AO_OOR_FLAG          0x00000020 // AddrObj is out of resources, and on
                                        // either the pending or delayed queue.
#define AO_QUEUED_FLAG       0x00000010 // AddrObj is on the pending queue.

//                           0x00000008    Reserved for AO_XSUM_FLAG.
#define AO_SEND_FLAG         0x00000004 // Send is pending.
#define AO_OPTIONS_FLAG      0x00000002 // Option set pending.
#define AO_DELETE_FLAG       0x00000001 // Delete pending.


#define AO_VALID(A) ((A)->ao_flags & AO_VALID_FLAG)
#define SET_AO_INVALID(A) (A)->ao_flags &= ~AO_VALID_FLAG

#define AO_BUSY(A) ((A)->ao_flags & AO_BUSY_FLAG)
#define SET_AO_BUSY(A) (A)->ao_flags |= AO_BUSY_FLAG
#define CLEAR_AO_BUSY(A) (A)->ao_flags &= ~AO_BUSY_FLAG

#define AO_OOR(A) ((A)->ao_flags & AO_OOR_FLAG)
#define SET_AO_OOR(A) (A)->ao_flags |= AO_OOR_FLAG
#define CLEAR_AO_OOR(A) (A)->ao_flags &= ~AO_OOR_FLAG

#define AO_QUEUED(A) ((A)->ao_flags & AO_QUEUED_FLAG)
#define SET_AO_QUEUED(A) (A)->ao_flags |= AO_QUEUED_FLAG
#define CLEAR_AO_QUEUED(A) (A)->ao_flags &= ~AO_QUEUED_FLAG

#define AO_REQUEST(A, f) ((A)->ao_flags & f##_FLAG)
#define SET_AO_REQUEST(A, f) (A)->ao_flags |= f##_FLAG
#define CLEAR_AO_REQUEST(A, f) (A)->ao_flags &= ~f##_FLAG
#define AO_PENDING(A) \
        ((A)->ao_flags & (AO_DELETE_FLAG | AO_OPTIONS_FLAG | AO_SEND_FLAG))

#define AO_SHARE(A)  ((A)->ao_flags & AO_SHARE_FLAG)
#define SET_AO_SHARE(A) (A)->ao_flags |= AO_SHARE_FLAG
#define CLEAR_AO_SHARE(A) (A)->ao_flags &= ~AO_SHARE_FLAG

#define AO_HDRINCL(A)  ((A)->ao_flags & AO_HDRINCL_FLAG)
#define SET_AO_HDRINCL(A) (A)->ao_flags |= AO_HDRINCL_FLAG
#define CLEAR_AO_HDRINCL(A) (A)->ao_flags &= ~AO_HDRINCL_FLAG

#define AO_PKTINFO(A)  ((A)->ao_flags & AO_PKTINFO_FLAG)
#define SET_AO_PKTINFO(A) (A)->ao_flags |= AO_PKTINFO_FLAG
#define CLEAR_AO_PKTINFO(A) (A)->ao_flags &= ~AO_PKTINFO_FLAG

#define AO_RCV_HOPLIMIT(A)  ((A)->ao_flags & AO_RCV_HOPLIMIT_FLAG)
#define SET_AO_RCV_HOPLIMIT(A) (A)->ao_flags |= AO_RCV_HOPLIMIT_FLAG
#define CLEAR_AO_RCV_HOPLIMIT(A) (A)->ao_flags &= ~AO_RCV_HOPLIMIT_FLAG

#define AO_SENTDATA(A)  ((A)->ao_flags & AO_SENTDATA_FLAG)
#define SET_AO_SENTDATA(A) (A)->ao_flags |= AO_SENTDATA_FLAG

#define PROTECTION_LEVEL_UNRESTRICTED  10  // For peer-to-peer apps.
#define PROTECTION_LEVEL_DEFAULT       20  // Default level.        
#define PROTECTION_LEVEL_RESTRICTED    30  // For Intranet apps.

//
// Definition of an address object search context.  This is a data structure
// used when the address object table is to be read sequentially.
//
typedef struct AOSearchContext {
    AddrObj *asc_previous;    // Previous AO found.
    IPv6Addr asc_local_addr;  // Local IP address to be found.
    IPv6Addr asc_remote_addr; // Remote IP address to check against.
    Interface *asc_interface; // Interface to check against.
    uint asc_scope_id;        // Scope id for IP address.
    ushort asc_port;          // Port to be found.
    uchar asc_prot;           // Protocol.
    uchar asc_pad;            // Pad to dword boundary.
} AOSearchContext;

//
// Definition of an AO request structure.  There structures are used only for
// queuing delete and option set requests.
//
#define aor_signature 0x20524F41

typedef struct AORequest {
#if DBG
    ulong aor_sig;
#endif
    struct AORequest *aor_next;      // Next pointer in chain.
    uint aor_id;                     // ID for the request.
    uint aor_length;                 // Length of buffer.
    void *aor_buffer;                // Buffer for this request.
    RequestCompleteRoutine aor_rtn;  // Complete routine for this request.
    PVOID aor_context;               // Request context;
} AORequest;

typedef struct AOMCastAddr {
    struct AOMCastAddr *ama_next;  // Next in list.
    IPv6Addr ama_addr;             // The address.
    uint ama_if;                   // The interface.
} AOMCastAddr;


//
// External declarations for exported functions.
//
extern uint AddrObjTableSize;
extern AddrObj **AddrObjTable;
extern AddrObj *GetAddrObj(IPv6Addr *LocalAddr, IPv6Addr *RemoteAddr,
                           uint LocalScopeId,
                           ushort LocalPort, uchar Prot, AddrObj *PreviousAO,
                           Interface* IF);
extern AddrObj *GetNextAddrObj(AOSearchContext *SearchContext);
extern AddrObj *GetFirstAddrObj(IPv6Addr *LocalAddr, IPv6Addr *RemoteAddr,
                                uint LocalScopeId,
                                ushort LocalPort, uchar Prot, Interface *IF,
                                AOSearchContext *SearchContext);
extern TDI_STATUS TdiOpenAddress(PTDI_REQUEST Request,
                                 TRANSPORT_ADDRESS UNALIGNED *AddrList,
                                 uint Protocol, void *Reuse,
                                 PSECURITY_DESCRIPTOR AddrSD);
extern TDI_STATUS TdiCloseAddress(PTDI_REQUEST Request);
extern TDI_STATUS SetAddrOptions(PTDI_REQUEST Request, uint ID, uint OptLength,
                                 void *Options);
extern TDI_STATUS TdiSetEvent(PVOID Handle, int Type, PVOID Handler,
                              PVOID Context);
extern uchar GetAddress(TRANSPORT_ADDRESS UNALIGNED *AddrList,
                        IPv6Addr *Addr, ulong *ScopeId, ushort *Port);
extern int InitAddr(void);
extern void AddrUnload(void);
extern void ProcessAORequests(AddrObj *RequestAO);
extern void DelayDerefAO(AddrObj *RequestAO);
extern void DerefAO(AddrObj *RequestAO);
extern void FreeAORequest(AORequest *FreedRequest);
extern uint ValidateAOContext(void *Context, uint *Valid);
extern uint ReadNextAO(void *Context, void *OutBuf);
extern void InvalidateAddrs(IPv6Addr *Addr, uint ScopeId);

extern uint MCastAddrOnAO(AddrObj *AO, IPv6Addr *Addr);
extern AOMCastAddr *FindAOMCastAddr(AddrObj *AO, IPv6Addr *Addr, uint IFNo, AOMCastAddr **PrevAMA, BOOLEAN Loose);
extern int DoesAOAllowPacket(AddrObj *RcvAO, Interface *IF, IPv6Addr *RemoteAddr);

#define GetBestAddrObj(localaddr, remoteaddr, scope, port, prot, if) \
            GetAddrObj(localaddr, remoteaddr, scope, port, prot, NULL, if)

#define REF_AO(a) (a)->ao_usecnt++

#define DELAY_DEREF_AO(a) DelayDerefAO((a))
#define DEREF_AO(a) DerefAO((a))
#define LOCKED_DELAY_DEREF_AO(a) (a)->ao_usecnt--; \
\
    if (!(a)->ao_usecnt && !AO_BUSY((a)) && AO_PENDING((a))) { \
        SET_AO_BUSY((a)); \
        ExQueueWorkItem(&(a)->ao_workitem, CriticalWorkQueue); \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\info.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TDI Query/SetInfo and Action definitions.
//

#include "tcpinfo.h"

#define TL_INSTANCE 0

#ifndef UDP_ONLY
extern TCPStats TStats;

typedef struct TCPConnContext {
    uint tcc_index;
    struct TCB *tcc_tcb;
} TCPConnContext;

#define TCB_STATE_DELTA 1

#endif

typedef struct UDPContext {
    uint uc_index;
    struct AddrObj *uc_ao;
} UDPContext;

extern UDPStats UStats;
extern struct TDIEntityID *EntityList;
extern uint EntityCount;

extern TDI_STATUS TdiQueryInformation(PTDI_REQUEST Request, uint QueryType, 
                                      PNDIS_BUFFER Buffer, uint *BufferSize,
                                      uint IsConn);

extern TDI_STATUS TdiSetInformation(PTDI_REQUEST Request, uint SetType, 
                                    PNDIS_BUFFER Buffer, uint BufferSize,
                                    uint IsConn);

extern TDI_STATUS TdiAction(PTDI_REQUEST Request, uint ActionType, 
                            PNDIS_BUFFER Buffer, uint BufferSize);

extern TDI_STATUS TdiQueryInformationEx(PTDI_REQUEST Request, 
                                        struct TDIObjectID *ID,
                                        PNDIS_BUFFER Buffer, uint *Size,
                                        void *Context, uint ContextSize);

extern TDI_STATUS TdiSetInformationEx(PTDI_REQUEST Request, 
                                      struct TDIObjectID *ID, void *Buffer,
                                      uint Size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\icmp.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Internet Control Message Protocol for IPv6 definitions.
// See RFC 1885 and RFC 1970 for details.
//


#ifndef ICMP_INCLUDED
#define ICMP_INCLUDED 1

#include "icmp6.h"      // Protocol definitions & constants.

//
// Stuff to handle in-kernel ping functionality.
//
typedef void (*EchoRtn)(void *, IP_STATUS,
                        const IPv6Addr *, uint, void *, uint);

typedef struct EchoControl {
    struct EchoControl *Next;  // Next control structure in list.
    ulong TimeoutTimer;        // Timeout value (in IPv6Timer ticks).
    EchoRtn CompleteRoutine;   // Routine to call when completing request.
    ulong Seq;                 // Sequence number of this ping request.
    LARGE_INTEGER WhenIssued;  // Timestamp (in system timer ticks since boot).
    void *ReplyBuf;            // Buffer to store replies.
    ulong ReplyBufLen;         // Size of reply buffer.
    IPAddr V4Dest;             // IPv4 destination (or INADDR_ANY).
} EchoControl;

extern void
ICMPv6EchoRequest(void *InputBuffer, uint InputBufferLength,
                  EchoControl *ControlBlock, EchoRtn Callback);

extern NTSTATUS
ICMPv6EchoComplete(EchoControl *ControlBlock,
                   IP_STATUS Status, const IPv6Addr *Address, uint ScopeId,
                   void *Data, uint DataSize, ULONG_PTR *BytesReturned);

extern void
ICMPv6ProcessTunnelError(IPAddr V4Dest,
                         IPv6Addr *V4Src, uint ScopeId,
                         IP_STATUS Status);

//
// General prototypes.
//

extern void
ICMPv6Send(
    RouteCacheEntry *RCE,               // RCE to send on
    PNDIS_PACKET Packet,                // Packet to send.
    uint IPv6Offset,                    // Offset to IPv6 header in packet.
    uint ICMPv6Offset,                  // Offset to ICMPv6 header in packet.
    IPv6Header UNALIGNED *IP,           // Pointer to IPv6 header.
    uint PayloadLength,                 // Length of IPv6 payload in bytes.
    ICMPv6Header UNALIGNED *ICMP);      // Pointer to ICMPv6 header.

extern void
ICMPv6SendError(
    IPv6Packet *Packet,         // Offending/invoking packet.
    uchar ICMPType,             // ICMP error type.
    uchar ICMPCode,             // ICMP error code pertaining to type.
    ulong ICMPPointer,          // ICMP pointer indicating a packet offset.
    uint NextHeader,            // Type of header following in Packet.
    int MulticastOverride);     // Allow replies to multicast packets?

extern int
ICMPv6RateLimit(RouteCacheEntry *RCE);

#endif  // ICMP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\ip6imp.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Implementation specific definitions for Internet Protocol Version 6.
//
// Things we want visible to other kernel modules, yet aren't part of the
// official specifications (i.e. are implementation specific) go here.
// 


#ifndef IP6IMP_INCLUDED
#define IP6IMP_INCLUDED 1

//
// These first few definitions (before the include of ip6.h)
// replicate definitions from winsock2.h and ws2tcpip.h.
// Unfortunately, those header files are not usable in the kernel.
//

typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;
typedef unsigned __int64 u_int64;

/* Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP */

#include <ipexport.h>

typedef struct ipv6_mreq {
    struct in6_addr ipv6mr_multiaddr;  /* IPv6 multicast address */
    unsigned int    ipv6mr_interface;  /* Interface index */
} IPV6_MREQ;

#include <ip6.h>

//
// The actual definitions can be found in ip6def.h.
//
typedef struct NetTableEntryOrInterface NetTableEntryOrInterface;
typedef struct Interface Interface;

//
// The actual definition of a Security Association Linkage
// can be found in security.h.
//
typedef struct SALinkage SALinkage;

typedef struct IPv6Packet IPv6Packet;
typedef struct IPv6PacketAuxiliary IPv6PacketAuxiliary;

//
// Structure of packet data we pass around the stack.
// Exactly one of FlatData and NdisPacket should be non-NULL.
//
struct IPv6Packet {
    IPv6Packet *Next;                   // Next entry on a list of packets.
    uint Position;                      // Current logical offset into packet.
    void *Data;                         // Current pointer into packet data.
    uint ContigSize;                    // Amount of contiguous data remaining.
    uint TotalSize;                     // Total amount of data remaining.
    NetTableEntryOrInterface *NTEorIF;  // NTE or IF we received packet on.
    void *FlatData;                     // Original flat data pointer (if any).
    PNDIS_PACKET NdisPacket;            // Original NDIS Packet (if any).
    long RefCnt;                        // References held to NdisPacket.
    IPv6PacketAuxiliary *AuxList;       // Extra memory allocated by our stack.
    uint Flags;                         // Various, see below.
    IPv6Header UNALIGNED *IP;           // IP header for this packet.
    uint IPPosition;                    // Offset at which IP header resides.
    IPv6Addr *SrcAddr;                  // Source/home addr for mobile IP.   
    SALinkage *SAPerformed;             // Security Associations performed.
    uint NextHeaderPosition;            // Offset of recent NextHeader field.
    uint SkippedHeaderLength;           // Headers skipped in AH validation.
};

// Flags for above.
#define PACKET_OURS             0x01  // We alloc'd IPv6Packet struct off heap.
#define PACKET_NOT_LINK_UNICAST 0x02  // Link-level broadcast or multicast.
#define PACKET_REASSEMBLED      0x04  // Arrived as a bunch of fragments.
#define PACKET_HOLDS_REF        0x08  // Packet holds an NTE or IF reference.
#define PACKET_JUMBO_OPTION     0x10  // Packet has a jumbo payload option.
#define PACKET_ICMP_ERROR       0x20  // Packet is an ICMP error message.
#define PACKET_SAW_HA_OPT       0x40  // Home Addr Opt modified current IP hdr.
#define PACKET_TUNNELED         0x80  // Arrived inside an outer IPv6 header.
#define PACKET_LOOPED_BACK     0x100  // Arrived via internal loopback.

// 
// Flags that are inherited by a reassembled datagram from its fragments.
//
#define PACKET_INHERITED_FLAGS (PACKET_NOT_LINK_UNICAST | \
                                PACKET_TUNNELED | \
                                PACKET_LOOPED_BACK)

struct IPv6PacketAuxiliary {
    IPv6PacketAuxiliary *Next;  // Next entry on packet's aux list.
    uint Position;              // Packet position corresponding to region.
    uint Length;                // Length of region in bytes.
    uchar *Data;                // Data comprising region.
};

//
// PacketPullup will sometimes copy more than the requested amount,
// up to this limit.
//
#define MAX_EXCESS_PULLUP       128

//
// For comparing IPv6 addresseses.
//
__inline int
IP6_ADDR_EQUAL(const IPv6Addr *x, const IPv6Addr *y)
{
    __int64 UNALIGNED *a;
    __int64 UNALIGNED *b;

    a = (__int64 UNALIGNED *)x;
    b = (__int64 UNALIGNED *)y;

    return (a[1] == b[1]) && (a[0] == b[0]);
}

//
// The actual definition of a route cache entry
// can be found in route.h.
//
typedef struct RouteCacheEntry RouteCacheEntry;


//
// Structure of a packet context.
//
// The IF field holds a reference if it is non-NULL.
// The packet holds a reference for the sending interface
// between IPv6SendLL and IPv6SendComplete.
//
// The Flags field uses NDIS Flag bits (notably NDIS_FLAGS_MULTICAST_PACKET,
// NDIS_FLAGS_LOOPBACK_ONLY, and NDIS_FLAGS_DONT_LOOPBACK)
// but it is NOT the same as the Private.Flags field,
// which NDIS uses.
//
typedef struct Packet6Context {
    PNDIS_PACKET pc_link;                     // For lists of packets.
    Interface *IF;                            // Interface sending the packet.
    uint pc_offset;                           // Offset of IPv6 header.
    // pc_adjust is used by link layers when sending packets.
    // pc_nucast is used in link layers when receiving transfer-data packets.
    // pc_drop is used in NeighborCacheTimeout.
    union {
        uint pc_adjust;                       // See AdjustPacketBuffer.
        uint pc_nucast;                       // Used in lan.c transfer-data.
        int pc_drop;                          // See NeighborCacheTimeout.
    };
    void (*CompletionHandler)(                // Called on event completion.
                PNDIS_PACKET Packet,
                IP_STATUS Status);
    void *CompletionData;                     // Data for completion handler.
    uint Flags;
    IPv6Addr DiscoveryAddress;                // Source address for ND.
} Packet6Context;


//
// The ProtocolReserved field (extra bytes after normal NDIS Packet fields)
// is structured as a Packet6Context.
//
// NB: Only packets created by IPv6 have an IPv6 Packet6Context.
// Packets that NDIS hands up to us do NOT have a Packet6Context.
//
__inline Packet6Context *
PC(NDIS_PACKET *Packet)
{
    return (Packet6Context *)Packet->ProtocolReserved;
}

__inline void
InitializeNdisPacket(NDIS_PACKET *Packet)
{
    RtlZeroMemory(PC(Packet), sizeof *PC(Packet));
}

//
// Global variables exported by the IPv6 driver for use by other
// NT kernel modules.
//
extern NDIS_HANDLE IPv6PacketPool, IPv6BufferPool;


//
// Functions exported by the IPv6 driver for use by other
// NT kernel modules.
//

void
IPv6RegisterULProtocol(uchar Protocol, void *RecvHandler, void *CtrlHandler);

extern void
IPv6SendComplete(void *, PNDIS_PACKET, IP_STATUS);

extern int
IPv6Receive(IPv6Packet *);

extern void
IPv6ReceiveComplete(void);

extern void
IPv6ProviderReady(void);

extern void
InitializePacketFromNdis(IPv6Packet *Packet,
                         PNDIS_PACKET NdisPacket, uint Offset);

extern uint
GetPacketPositionFromPointer(IPv6Packet *Packet, uchar *Pointer);

extern uint
PacketPullupSubr(IPv6Packet *Packet, uint Needed,
                 uint AlignMultiple, uint AlignOffset);

__inline int
PacketPullup(IPv6Packet *Packet, uint Needed,
             uint AlignMultiple, uint AlignOffset)
{
    return (((Needed <= Packet->ContigSize) &&
             ((PtrToUint(Packet->Data) & (AlignMultiple-1)) == AlignOffset)) ||
            (PacketPullupSubr(Packet, Needed,
                              AlignMultiple, AlignOffset) != 0));
}

extern void
PacketPullupCleanup(IPv6Packet *Packet);

extern void
AdjustPacketParams(IPv6Packet *Packet, uint BytesToSkip);

extern void
PositionPacketAt(IPv6Packet *Packet, uint NewPosition);

extern uint
CopyToBufferChain(PNDIS_BUFFER DstBuffer, uint DstOffset,
                  PNDIS_PACKET SrcPacket, uint SrcOffset, uchar *SrcData,
                  uint Length);

extern uint
CopyPacketToNdis(PNDIS_BUFFER DestBuf, IPv6Packet *Packet, uint Size,
                 uint DestOffset, uint RcvOffset);

extern void
CopyPacketToFlatOrNdis(PNDIS_BUFFER DestBuf, uchar *DestPtr, uint DestOffset,
                       IPv6Packet *SrcPkt, uint Size, uint Offset);

__inline void
CopyPacketToBuffer(uchar *DestPtr, IPv6Packet *SrcPkt, uint Size, uint Offset)
{
    CopyPacketToFlatOrNdis(NULL, DestPtr, 0, SrcPkt, Size, Offset);
}

extern int
CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
               uchar * SrcBuf, uint Size, uint * StartOffset);

extern PNDIS_BUFFER
CopyFlatToNdis(PNDIS_BUFFER DestBuf, uchar *SrcBuf, uint Size, uint *Offset,
               uint *BytesCopied);

extern int
CopyNdisToFlat(void *DstData, PNDIS_BUFFER SrcBuffer, uint SrcOffset,
               uint Length, PNDIS_BUFFER *NextBuffer, uint *NextOffset);

extern NDIS_STATUS
IPv6AllocatePacket(uint Length, PNDIS_PACKET *pPacket, void **pMemory);

extern void
IPv6FreePacket(PNDIS_PACKET Packet);

extern void
IPv6PacketComplete(PNDIS_PACKET Packet, IP_STATUS Status);

#endif // IP6IMP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\datagram.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Common datagram processing definitions.
//


#ifndef _DATAGRAM_INCLUDED_
#define _DATAGRAM_INCLUDED_  1


//
// Structure used for maintaining DG send requests.
//
#define dsr_signature 0x20525338

typedef struct DGSendReq {
#if DBG
    ulong dsr_sig;
#endif
    Queue dsr_q;                     // Queue linkage when pending.
    IPv6Addr dsr_addr;               // Remote IP Address.
    ulong dsr_scope_id;              // Scope id of remote address (if any).
    PNDIS_BUFFER dsr_buffer;         // Buffer of data to send.
    RequestCompleteRoutine dsr_rtn;  // Completion routine.
    PVOID dsr_context;               // User context.
    ushort dsr_size;                 // Size of buffer.
    ushort dsr_port;                 // Remote port.
} DGSendReq;


//
// Structure used for maintaining DG receive requests.
//
#define drr_signature 0x20525238

typedef struct DGRcvReq {
    Queue drr_q;                               // Queue linkage on AddrObj.
#if DBG
    ulong drr_sig;
#endif
    IPv6Addr drr_addr;                         // Remote IP Addr acceptable.
    ulong drr_scope_id;                        // Acceptable scope id of addr.
    PNDIS_BUFFER drr_buffer;                   // Buffer to be filled in.
    PTDI_CONNECTION_INFORMATION drr_conninfo;  // Pointer to conn. info.
    RequestCompleteRoutine drr_rtn;            // Completion routine.
    PVOID drr_context;                         // User context.
    ushort drr_size;                           // Size of buffer.
    ushort drr_port;                           // Remote port acceptable.
} DGRcvReq;


//
// External definition of exported variables.
//
extern KSPIN_LOCK DGSendReqLock;
extern KSPIN_LOCK DGRcvReqFreeLock;


//
// External definition of exported functions.
//
extern void DGSendComplete(PNDIS_PACKET Packet, IP_STATUS Status);

extern TDI_STATUS TdiSendDatagram(PTDI_REQUEST Request,
                                  PTDI_CONNECTION_INFORMATION ConnInfo,
                                  uint DataSize, ULONG *BytesSent,
                                  PNDIS_BUFFER Buffer);

extern TDI_STATUS TdiReceiveDatagram(PTDI_REQUEST Request,
                                     PTDI_CONNECTION_INFORMATION ConnInfo,
                                     PTDI_CONNECTION_INFORMATION ReturnInfo,
                                     uint RcvSize, uint *BytesRcvd,
                                     PNDIS_BUFFER Buffer);

extern void FreeDGRcvReq(DGRcvReq *RcvReq);
extern void FreeDGSendReq(DGSendReq *SendReq);
extern int InitDG(void);
extern void DGUnload(void);
extern void PutPendingQ(AddrObj *QueueingAO);

//
// The following is needed for the IPV6_PKTINFO option and echos what is
// found in ws2tcpip.h and winsock2.h.
//
#define IPV6_PKTINFO          19 // Receive packet information.

typedef struct in6_pktinfo {
    IPv6Addr ipi6_addr;    // destination IPv6 address
    uint     ipi6_ifindex; // received interface index
} IN6_PKTINFO;

//
//  Make sure the size of IN6_PKTINFO is still what we think it is.
//  If it is changed, the corresponding definition in ws2tcpip.h must be
//  changed as well.
//
C_ASSERT(sizeof(IN6_PKTINFO) == 20);


//
// Function to populate an IN6_PKTINFO ancillary object.
//
VOID
DGFillIpv6PktInfo(IPv6Addr UNALIGNED *DestAddr, uint LocalInterface, uchar **CurrPosition);

//
// The following is needed for the IPV6_HOPLIMIT option and echos what is
// found in ws2tcpip.h.
//
#define IPV6_HOPLIMIT          21 // Receive hop limit information.

//
// Function to populate an ancillary object for the IPV6_HOPLIMIT option.
//
VOID
DGFillIpv6HopLimit(int HopLimit, uchar **CurrPosition);

#endif // ifndef _DATAGRAM_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\ip6def.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IPv6 private definitions.
//
// This file contains all of the definitions for IPv6 that
// are not visible to outside layers.
//


#ifndef IPv6DEF_INCLUDED
#define IPv6DEF_INCLUDED 1

#pragma warning(push)
#pragma warning(disable:4200) // zero-sized array in struct/union

typedef struct NeighborCacheEntry NeighborCacheEntry;
typedef struct AddressEntry AddressEntry;
typedef struct MulticastAddressEntry MulticastAddressEntry;
typedef struct AnycastAddressEntry AnycastAddressEntry;
typedef struct NetTableEntryOrInterface NetTableEntryOrInterface;
typedef struct NetTableEntry NetTableEntry;
typedef struct Interface Interface;

typedef struct IPSecProc IPSecProc;

// REVIEW: Added so the build will work.
typedef unsigned long IPAddr;
#define INADDR_ANY      0

#ifndef ABORTMSG
#if DBG
#define ABORT() \
    RtlAssert( "FALSE", __FILE__, __LINE__, NULL )

#define ABORTMSG(msg) \
    RtlAssert( "FALSE", __FILE__, __LINE__, (msg) )
#else
#define ABORT()
#define ABORTMSG(msg)
#endif // DBG
#endif // ABORTMSG

//
// Per-neighbor information.  We keep address translation and unreachability
// detection info for each of our neighbors that we're in communication with.
//
// A non-zero reference count prevents the NCE from being reclaimed.
// An NCE with zero references may be kept cached.
// A per-interface lock protects all NCEs for that interface.
//
// NCEs with a non-zero reference count hold a reference for their interface.
// NCEs with a zero reference count do not hold a reference.
// This means if you hold a reference for an NCE,
// you can always safely access and dereference NCE->IF.
//
// The Next/Prev fields link NCEs into a circular doubly-linked list.
// They must be first and must match the IF->FirstNCE/LastNCE fields
// to make the casting work out.
//
// The list of NCEs is kept sorted, from most-recently-used to least.
//
struct NeighborCacheEntry {           // a.k.a. NCE
    NeighborCacheEntry *Next;         // Next entry on I/F neighbor list.
    NeighborCacheEntry *Prev;         // Previous entry on I/F neighbor list.
    IPv6Addr NeighborAddress;         // Address of I/F on neighboring node.
    void *LinkAddress;                // Media address corresponding to above.
    // NB: LinkAddressLength field not needed - use IF->LinkAddressLength.
    ushort IsRouter:1,                // Is the neighbor a router?
           IsUnreachable:1,           // Does ND indicate unreachability?
           // DoRoundRobin is only meaningful if IsUnreachable is TRUE.
           DoRoundRobin:1,            // Should FindNextHop do round-robin?
           IsLoopback:1;              // Do we loopback to this neighbor
                                      // in software?
    ushort NDState;                   // Neighbor Discovery Protocol state.
    uint LastReachability;            // Timestamp (IPv6Timer ticks).
    ushort NSTimer;                   // In IPv6Timer ticks (see IPv6Timeout).
    uchar NSCount;                    // Number of solicits sent so far.
    uchar NSLimit;                    // Total number of solicits to send.
    Interface *IF;                    // Interface on media with neighbor.
    NDIS_PACKET *WaitQueue;           // Queue of packets waiting on ND.
    long RefCnt;                      // Reference count - interlocked.
};

//
// The caller must already have a reference for the NCE.
// The interface need not be locked.
//
__inline void
AddRefNCE(NeighborCacheEntry *NCE)
{
    long RefCnt = InterlockedIncrement(&NCE->RefCnt);
    ASSERT(RefCnt != 1);
    UNREFERENCED_PARAMETER(RefCnt);
}

extern void
AddRefNCEInCache(NeighborCacheEntry *NCE);

extern void
ReleaseNCE(NeighborCacheEntry *NCE);

//
// Values for "NDState" above.  See RFC 1970, section 7.3.2 for details.
// Note: only state names are documented, we chose the values used here.
//
// In the INCOMPLETE state, the LinkAddress is not valid.
// In all other states, LinkAddress may be used to send packets.
// WaitQueue is usually only non-NULL in the INCOMPLETE state,
// but sometimes a packet is left queued for NeighborCacheTimeout.
//
// The INCOMPLETE state has two flavors, dormant and active.  If
// EventTimer and EventCount are both zero, then we are not actively
// trying to solicit the link address.  If someone tries to send to
// this neighbor, then we start soliciting the link address.  If the
// solicitation fails (or if we enter the PROBE state and then fail to
// confirm reachability), then any waiting packets are discarded and
// we reset to INCOMPLETE with zero EventTimer/EventCount.  (So with
// the next use of this neighbor, we start soliciting again from scratch.)
//
// The DELAY state is not used internally. Instead we use the PROBE state
// with zero NSCount and non-zero NSTimer to indicate that we are delaying
// the start of probing. However link-layer lip_cvaddr functions can
// return ND_STATE_DELAY and IoctlQueryNeighborCache returns ND_STATE_DELAY.
//
// The IsUnreachable flag tracks separately whether the neighbor is
// *known* to be unreachable.  For example, a new NCE will be in in the
// INCOMPLETE state, but IsUnreachable is FALSE because we don't know
// yet whether the neighbor is reachable.  Because FindNextHop uses
// IsUnreachable, code paths that change this flag must call
// InvalidateRouteCache.
//
// These definitions are also in llip6if.h and ntddip6.w.
//
#define ND_STATE_INCOMPLETE 0
#define ND_STATE_PROBE      1
#define ND_STATE_DELAY      2           // Not used internally.
#define ND_STATE_STALE      3
#define ND_STATE_REACHABLE  4
#define ND_STATE_PERMANENT  5


//
// There are a few places in the implementation where we need
// to pass a pointer which is either a NetTableEntry or an Interface.
// NetTableEntries and Interfaces share this structure as their
// first element.  With Interfaces, the IF field points back
// at the Interface itself.
//
struct NetTableEntryOrInterface {    // a.k.a. NTEorIF
    Interface *IF;
};

__inline int
IsNTE(NetTableEntryOrInterface *NTEorIF)
{
    return (NetTableEntryOrInterface *)NTEorIF->IF != NTEorIF;
}

__inline NetTableEntry *
CastToNTE(NetTableEntryOrInterface *NTEorIF)
{
    ASSERT(IsNTE(NTEorIF));
    return (NetTableEntry *) NTEorIF;
}

__inline NetTableEntryOrInterface *
CastFromNTE(NetTableEntry *NTE)
{
    return (NetTableEntryOrInterface *) NTE;
}

__inline int
IsIF(NetTableEntryOrInterface *NTEorIF)
{
    return (NetTableEntryOrInterface *)NTEorIF->IF == NTEorIF;
}

__inline Interface *
CastToIF(NetTableEntryOrInterface *NTEorIF)
{
    ASSERT(IsIF(NTEorIF));
    return (Interface *) NTEorIF;
}

__inline NetTableEntryOrInterface *
CastFromIF(Interface *IF)
{
    return (NetTableEntryOrInterface *) IF;
}


//
// Local address information. Each interface keeps track of the addresses
// assigned to the interface. Depending on the type of address, each
// ADE structure is the first element of a larger NTE, MAE, or AAE structure.
// The address information is protected by the interface's lock.
//
// The NTEorIF field must be first. In NTEs, it points to the interface
// and holds a reference for the interface.  In MAEs and AAEs, it can
// point to the interface or to one of the NTEs on the interface but in
// either case it does NOT hold a reference.
//
struct AddressEntry {            // a.k.a. ADE
    union {
        Interface *IF;
        NetTableEntry *NTE;
        NetTableEntryOrInterface *NTEorIF;
    };
    AddressEntry *Next;          // Linkage on chain.
    IPv6Addr Address;            // Address identifying this entry.
    ushort Type;                 // Address type (unicast, multicast, etc).
    ushort Scope;                // Address scope (link, site, global, etc).
};

//
// Values for address Type.
//
#define ADE_UNICAST   0x00
#define ADE_ANYCAST   0x01
#define ADE_MULTICAST 0x02
#define ADE_NONE      ((ushort)-1)      // Indicates absence of an ADE.

//
// Values for address Scope.
//
#define ADE_SMALLEST_SCOPE      0x00
#define ADE_INTERFACE_LOCAL     0x01
#define ADE_LINK_LOCAL          0x02
#define ADE_SUBNET_LOCAL        0x03
#define ADE_ADMIN_LOCAL         0x04
#define ADE_SITE_LOCAL          0x05
#define ADE_ORG_LOCAL           0x08
#define ADE_GLOBAL              0x0e
#define ADE_LARGEST_SCOPE       0x0f

#define ADE_NUM_SCOPES          (ADE_LARGEST_SCOPE - ADE_SMALLEST_SCOPE + 1)

//
// Multicast ADEs are really MAEs.
//
// MAEs can be a separate global QueryList.
// If an MAE on an Interface has a non-zero MCastTimer value,
// then it is on the QueryList.
//
// An MAE can be on the QueryList with a zero MCastTimer value
// only when it is not on any interface and it just needs
// a Done message sent before it can be deleted.
// When it is in this state (but not otherwise), MAE->IF
// holds a reference for the interface.
//
struct MulticastAddressEntry {   // a.k.a. MAE
    AddressEntry;                // Inherit the ADE fields.
    uint MCastRefCount;          // Sockets/etc receiving from this group.
    //
    // The fields below are protected by the QueryList lock.
    //
    ushort MCastFlags:4,         // Necessary info about a group.
           MCastCount:4;         // Count of initial reports left to send.
    ushort MCastTimer;           // Ticks until a membership report is sent.
    MulticastAddressEntry *NextQL;      // For the QueryList.
};

//
// Bit values for MCastFlags.
//
#define MAE_REPORTABLE          0x01    // We should send Reports.
#define MAE_LAST_REPORTER       0x02    // We should send Done.


//
// Anycast ADEs are really AAEs.
// Currently an AAE has no additional fields.
//
struct AnycastAddressEntry {     // a.k.a. AAE
    AddressEntry;                // Inherit the ADE fields.
};

//
// Unicast ADEs are really NTEs.
// There is one NTE for each source (unicast) address
// assigned to an interface.
//
// NTEs hold a reference for their interface,
// so if you have a reference for an NTE
// you can always safely access and dereference NTE->IF.
//
// Most NTE fields are either read-only or are protected
// by the interface lock. The interface WorkerLock protects
// the TdiRegistrationHandle field.
//
// Temporary addresses (AddrConf == ADDR_CONF_TEMPORARY)
// have extra fields - see TempNetTableEntry.
//
struct NetTableEntry {                // a.k.a. NTE
    AddressEntry;                     // Inherit the ADE fields.
    NetTableEntry *NextOnNTL;         // Next NTE on NetTableList.
    NetTableEntry **PrevOnNTL;        // Previous Next pointer in NetTableList.
    HANDLE TdiRegistrationHandle;     // Opaque token for TDI De/notification.
    uint TdiRegistrationScopeId;      // Scope Id when registered with TDI.
    long RefCnt;                      // Reference count - interlocked.
    uint ValidLifetime;               // In IPv6Timer ticks (see IPv6Timeout).
    uint PreferredLifetime;           // In IPv6Timer ticks (see IPv6Timeout).
    uchar AddrConf;                   // Address configuration status.
    uchar DADState;                   // Address configuration state.
    ushort DADCount;                  // How many DAD solicits left to send.
    ushort DADTimer;                  // In IPv6Timer ticks (see IPv6Timeout).
};

__inline void
AddRefNTE(NetTableEntry *NTE)
{
    InterlockedIncrement(&NTE->RefCnt);
}

__inline void
ReleaseNTE(NetTableEntry *NTE)
{
    InterlockedDecrement(&NTE->RefCnt);
}

struct AddrConfEntry {
    union {
        uchar Value;                 // Address configuration status.
        struct {
            uchar InterfaceIdConf : 4;
            uchar PrefixConf : 4;
        };
    };
};

//
// Values for PrefixConf - must fit in 4 bits.
// These must match the values in ntddip6.h, as well as the
// IP_PREFIX_ORIGIN values in iptypes.h.
//
#define PREFIX_CONF_OTHER       0       // None of the ones below.
#define PREFIX_CONF_MANUAL      1       // From a user or administrator.
#define PREFIX_CONF_WELLKNOWN   2       // IANA-assigned.
#define PREFIX_CONF_DHCP        3       // Configured via DHCP.
#define PREFIX_CONF_RA          4       // From a Router Advertisement.

//
// Values for InterfaceIdConf - must fit in 4 bits.
// These must match the values in ntddip6.h, as well as the
// IP_SUFFIX_ORIGIN values in iptypes.h.
//
#define IID_CONF_OTHER          0       // None of the ones below.
#define IID_CONF_MANUAL         1       // From a user or administrator.
#define IID_CONF_WELLKNOWN      2       // IANA-assigned.
#define IID_CONF_DHCP           3       // Configured via DHCP.
#define IID_CONF_LL_ADDRESS     4       // Derived from the link-layer address.
#define IID_CONF_RANDOM         5       // Random, e.g. temporary address.

//
// Values for AddrConf - must fit in 8 bits.
//
#define ADDR_CONF_MANUAL        ((PREFIX_CONF_MANUAL << 4) | IID_CONF_MANUAL)
#define ADDR_CONF_PUBLIC        ((PREFIX_CONF_RA << 4) | IID_CONF_LL_ADDRESS)
#define ADDR_CONF_TEMPORARY     ((PREFIX_CONF_RA << 4) | IID_CONF_RANDOM)
#define ADDR_CONF_DHCP          ((PREFIX_CONF_DHCP << 4) | IID_CONF_DHCP)
#define ADDR_CONF_WELLKNOWN     ((PREFIX_CONF_WELLKNOWN << 4) | IID_CONF_WELLKNOWN)
#define ADDR_CONF_LINK          ((PREFIX_CONF_WELLKNOWN << 4) | IID_CONF_LL_ADDRESS)

__inline int
IsValidPrefixConfValue(uint PrefixConf)
{
    return PrefixConf < (1 << 4);
}

__inline int
IsValidInterfaceIdConfValue(uint InterfaceIdConf)
{
    return InterfaceIdConf < (1 << 4);
}

__inline int
IsStatelessAutoConfNTE(NetTableEntry *NTE)
{
    return ((struct AddrConfEntry *)&NTE->AddrConf)->PrefixConf == PREFIX_CONF_RA;
}

//
// Values for DADState.
//
// The "deprecated" and "preferred" states are valid,
// meaning that addresses in those two states can be
// used as a source address, can receive packets, etc.
// The invalid states mean that the address is
// not actually assigned to the interface,
// using the terminology of RFC 2462.
//
// Valid<->invalid and deprecated<->preferred transitions
// must call InvalidateRouteCache because they affect
// source address selection.
//
// Among valid states, bigger is better
// for source address selection.
//
#define DAD_STATE_INVALID    0
#define DAD_STATE_TENTATIVE  1
#define DAD_STATE_DUPLICATE  2
#define DAD_STATE_DEPRECATED 3
#define DAD_STATE_PREFERRED  4

__inline int
IsValidNTE(NetTableEntry *NTE)
{
    return (NTE->DADState >= DAD_STATE_DEPRECATED);
}

__inline int
IsTentativeNTE(NetTableEntry *NTE)
{
    return (NTE->DADState == DAD_STATE_TENTATIVE);
}

//
// We use this infinite lifetime value for prefix lifetimes,
// router lifetimes, address lifetimes, etc.
//
#define INFINITE_LIFETIME 0xffffffff

//
// Temporary addresses have extra fields.
//
typedef struct TempNetTableEntry {
    NetTableEntry;              // Inherit the NTE fields.
    NetTableEntry *Public;      // Does not hold a reference.
    uint CreationTime;          // In ticks (see IPv6TickCount).
} TempNetTableEntry;

//
// Each interface keeps track of which link-layer multicast addresses
// are currently enabled for receive. A reference count is required because
// multiple IPv6 multicast addresses can map to a single link-layer
// multicast address. The low bit of RefCntAndFlags is a flag that, if set,
// indicates the link-layer address has been registered with the link.
//
typedef struct LinkLayerMulticastAddress {
    uint RefCntAndFlags;
    uchar LinkAddress[];        // The link-layer address follows in memory.
                                // Padded to provide alignment.
} LinkLayerMulticastAddress;

#define LLMA_FLAG_REGISTERED    0x1

__inline void
AddRefLLMA(LinkLayerMulticastAddress *LLMA)
{
    LLMA->RefCntAndFlags += (LLMA_FLAG_REGISTERED << 1);
}

__inline void
ReleaseLLMA(LinkLayerMulticastAddress *LLMA)
{
    LLMA->RefCntAndFlags -= (LLMA_FLAG_REGISTERED << 1);
}

__inline int
IsLLMAReferenced(LinkLayerMulticastAddress *LLMA)
{
    return LLMA->RefCntAndFlags > LLMA_FLAG_REGISTERED;
}


//
// Information about IPv6 interfaces.  There can be multiple NTEs for each
// interface, but there is exactly one interface per NTE.
//
struct Interface {                 // a.k.a. IF
    NetTableEntryOrInterface;      // For NTEorIF. Points to self.

    Interface *Next;               // Next interface on chain.

    long RefCnt;                   // Reference count - interlocked.

    //
    // Interface to the link layer. The functions all take
    // the LinkContext as their first argument. See comments
    // in llip6if.h.
    //
    void *LinkContext;             // Link layer context.
    void (*CreateToken)(void *Context, IPv6Addr *Address);
    const void *(*ReadLLOpt)(void *Context, const uchar *OptionData);
    void (*WriteLLOpt)(void *Context, uchar *OptionData,
                       const void *LinkAddress);
    ushort (*ConvertAddr)(void *Context,
                          const IPv6Addr *Address, void *LinkAddress);
    NTSTATUS (*SetRouterLLAddress)(void *Context, const void *TokenLinkAddress,
                                   const void *RouterLinkAddress);
    void (*Transmit)(void *Context, PNDIS_PACKET Packet,
                     uint Offset, const void *LinkAddress);
    NDIS_STATUS (*SetMCastAddrList)(void *Context, const void *LinkAddresses,
                                    uint NumKeep, uint NumAdd, uint NumDel);
    void (*Close)(void *Context);
    void (*Cleanup)(void *Context);

    uint Index;                    // Node unique index of this I/F.
    uint Type;                     // Values in ntddip6.h.
    uint Flags;                    // Changes require lock, reads don't.
    uint DefaultPreference;        // Read-only.
    uint Preference;               // For routing.

    //
    // ZoneIndices[0] (ADE_SMALLEST_SCOPE) and
    // ZoneIndices[1] (ADE_INTERFACE_LOCAL) must be Index.
    // ZoneIndices[14] (ADE_GLOBAL) and
    // ZoneIndices[15] (ADE_LARGEST_SCOPE) must be one.
    // ZoneIndices must respect zone containment:
    // If two interfaces have the same value for ZoneIndices[N],
    // then they must have the same value for ZoneIndices[N+1].
    // To ensure consistency, modifying ZoneIndices requires
    // the global ZoneUpdateLock.
    //
    uint ZoneIndices[ADE_NUM_SCOPES]; // Changes require lock, reads don't.

    AddressEntry *ADE;             // List of ADEs on this I/F.
    NetTableEntry *LinkLocalNTE;   // Primary link-local address.

    KSPIN_LOCK LockNC;             // Neighbor cache lock.
    NeighborCacheEntry *FirstNCE;  // List of active neighbors on I/F.
    NeighborCacheEntry *LastNCE;   // Last NCE in the list.
    uint NCENumUnused;             // Number of unused NCEs - interlocked.
    NDIS_PACKET *PacketList;       // List of packets to be completed.

    uint TrueLinkMTU;              // Read-only, true maximum MTU.
    uint DefaultLinkMTU;           // Read-only, default for LinkMTU.
    uint LinkMTU;                  // Manually configured or received from RAs.

    uint CurHopLimit;              // Default Hop Limit for unicast.
    uint BaseReachableTime;        // Base for random ReachableTime (in ms).
    uint ReachableTime;            // Reachable timeout (in IPv6Timer ticks).
    uint RetransTimer;             // NS timeout (in IPv6Timer ticks).
    uint DefaultDupAddrDetectTransmits; // Read-only.
    uint DupAddrDetectTransmits;   // Number of solicits during DAD.
    uint DupAddrDetects;           // Number of consecutive DAD detects.
    uint DefSitePrefixLength;      // Default Site Prefix Length for RAs.

    uint TempStateAge;             // Age of the temporary state.
    IPv6Addr TempState;            // State for generating temporary addresses.

    uint RSCount;                  // Number of Router Solicits sent.
    uint RSTimer;                  // RS timeout (in IPv6Timer ticks).
    uint RACount;                  // Number of "fast" RAs left to send.
    uint RATimer;                  // RA timeout (in IPv6Timer ticks).
    uint RALast;                   // Time of last RA (in IPv6Timer ticks).

    uint LinkAddressLength;        // Length of I/F link-level address.
    uchar *LinkAddress;            // Pointer to link-level address.
    uint LinkHeaderSize;           // Length of link-level header.

    KSPIN_LOCK Lock;               // Main interface lock.
    KMUTEX WorkerLock;             // Serializes worker thread operations.

    LinkLayerMulticastAddress *MCastAddresses;  // Current addresses.
    uint MCastAddrNum;             // Number of link-layer mcast addresses.

    uint TcpInitialRTT;            // InitialRTT that TCP connections should use
                                   // on this interface.

    HANDLE TdiRegistrationHandle;  // Opaque token for TDI De/notification.
    GUID Guid;
    NDIS_STRING DeviceName;        // IPV6_EXPORT_STRING_PREFIX + string Guid.
};

__inline NeighborCacheEntry *
SentinelNCE(Interface *IF)
{
    return (NeighborCacheEntry *) &IF->FirstNCE;
}

__inline uint
SizeofLinkLayerMulticastAddress(Interface *IF)
{
    uint RawSize = (sizeof(struct LinkLayerMulticastAddress) +
                    IF->LinkAddressLength);
    uint Align = __builtin_alignof(struct LinkLayerMulticastAddress) - 1;

    return (RawSize + Align) &~ Align;
}

//
// These values should agree with definitions also
// found in llip6if.h and ntddip6.h.
//
#define IF_TYPE_LOOPBACK           0
#define IF_TYPE_ETHERNET           1
#define IF_TYPE_FDDI               2
#define IF_TYPE_TUNNEL_AUTO        3
#define IF_TYPE_TUNNEL_6OVER4      4
#define IF_TYPE_TUNNEL_V6V4        5
#define IF_TYPE_TUNNEL_6TO4        6
#define IF_TYPE_TUNNEL_TEREDO      7
#define IF_TYPE_MIPV6              8 // Holds a mobile node's home addresses.

__inline int
IsIPv4TunnelIF(Interface *IF)
{
    return ((IF_TYPE_TUNNEL_AUTO <= IF->Type) &&
            (IF->Type <= IF_TYPE_TUNNEL_6TO4));
}

//
// These values should agree with definitions also
// found in llip6if.h and ntddip6.h.
//
#define IF_FLAG_PSEUDO                  0x00000001
#define IF_FLAG_P2P                     0x00000002
#define IF_FLAG_NEIGHBOR_DISCOVERS      0x00000004
#define IF_FLAG_FORWARDS                0x00000008
#define IF_FLAG_ADVERTISES              0x00000010
#define IF_FLAG_MULTICAST               0x00000020
#define IF_FLAG_ROUTER_DISCOVERS        0x00000040
#define IF_FLAG_PERIODICMLD             0x00000080
#define IF_FLAG_FIREWALL_ENABLED        0x00000100
#define IF_FLAG_MEDIA_DISCONNECTED      0x00001000

#define IF_FLAGS_DISCOVERS      \
        (IF_FLAG_NEIGHBOR_DISCOVERS|IF_FLAG_ROUTER_DISCOVERS)

#define IF_FLAGS_BINDINFO               0x0000ffff

#define IF_FLAG_DISABLED                0x00010000
#define IF_FLAG_MCAST_SYNC              0x00020000
#define IF_FLAG_OTHER_STATEFUL_CONFIG   0x00040000

//
// The DISCONNECTED and RECONNECTED flags should not both be set.
// RECONNECTED indicates that the host interface was recently reconnected;
// it is cleared upon receiving a Router Advertisement.
//
#define IF_FLAG_MEDIA_RECONNECTED       0x00080000

//
// This function should be used after taking the interface lock
// or interface list lock, to check if the interface is disabled.
//
__inline int
IsDisabledIF(Interface *IF)
{
    return IF->Flags & IF_FLAG_DISABLED;
}

//
// Called with the interface lock held.
//
__inline int
IsMCastSyncNeeded(Interface *IF)
{
    return IF->Flags & IF_FLAG_MCAST_SYNC;
}

//
// Active interfaces hold a reference to themselves.
// NTEs hold a reference to their interface.
// NCEs that have a non-zero ref count hold a reference.
// MAEs and AAEs do not hold a reference for their NTE or IF.
//

__inline void
AddRefIF(Interface *IF)
{
    //
    // A stronger assertion would be !IsDisabledIF(IF),
    // which is mostly true, but that assertion would
    // imply that AddRefIF could be used only while
    // holding the interface list lock or the interface lock,
    // which is an undesirable restriction.
    //
    ASSERT(IF->RefCnt > 0);

    InterlockedIncrement(&IF->RefCnt);
}

__inline void
ReleaseIF(Interface *IF)
{
    InterlockedDecrement(&IF->RefCnt);
}


//
// We have a periodic timer (IPv6Timer) that causes our IPv6Timeout
// routine to be called IPv6_TICKS_SECOND times per second.  Most of the
// timers and timeouts in this implementation are driven off this routine.
//
// There is a trade-off here between timer granularity/resolution
// and overhead.  The resolution should be subsecond because
// RETRANS_TIMER is only one second.
//
extern uint IPv6TickCount;

#define IPv6_TICKS_SECOND 2  // Two ticks per second.

#define IPv6_TIMEOUT (1000 / IPv6_TICKS_SECOND)  // In milliseconds.

#define IPv6TimerTicks(seconds) ((seconds) * IPv6_TICKS_SECOND)

//
// ConvertSecondsToTicks and ConvertTicksToSeconds
// both leave the value INFINITE_LIFETIME unchanged.
//

extern uint
ConvertSecondsToTicks(uint Seconds);

extern uint
ConvertTicksToSeconds(uint Ticks);

//
// ConvertMillisToTicks and ConvertTicksToMillis
// do not have an infinite value.
//

extern uint
ConvertMillisToTicks(uint Millis);

__inline uint
ConvertTicksToMillis(uint Ticks)
{
    return Ticks * IPv6_TIMEOUT;
}


//
// REVIEW: Hack to handle those few remaining places where we still need
// REVIEW: to allocate space for a link-level header before we know the
// REVIEW: outgoing inteface (and thus know how big said header will be).
// REVIEW: When these places have all been fixed, we won't need this.
//
#define MAX_LINK_HEADER_SIZE 32


//
// Various constants from the IPv6 RFCs...
//
// REVIEW: Some of these should be per link-layer type.
// REVIEW: Put them in the Interface structure?
//
#define MAX_INITIAL_RTR_ADVERT_INTERVAL IPv6TimerTicks(16)
#define MAX_INITIAL_RTR_ADVERTISEMENTS  3 // Produces 4 quick RAs.
#define MAX_FINAL_RTR_ADVERTISEMENTS    3
#define MIN_DELAY_BETWEEN_RAS           IPv6TimerTicks(3)
#define MAX_RA_DELAY_TIME               1 // 0.5 seconds
#define MaxRtrAdvInterval               IPv6TimerTicks(600)
#define MinRtrAdvInterval               IPv6TimerTicks(200)
//      MAX_RTR_SOLICITATION_DELAY      IPv6_TIMEOUT is used instead.
#define RTR_SOLICITATION_INTERVAL  IPv6TimerTicks(4)  // 4 seconds.
#define SLOW_RTR_SOLICITATION_INTERVAL  IPv6TimerTicks(15 * 60) // 15 minutes.
#define MAX_RTR_SOLICITATIONS      3
#define MAX_MULTICAST_SOLICIT      3  // Total transmissions before giving up.
#define MAX_UNICAST_SOLICIT        3  // Total transmissions before giving up.
#define MAX_UNREACH_SOLICIT        1  // Total transmissions before giving up.
#define UNREACH_SOLICIT_INTERVAL   IPv6TimerTicks(60) // 1 minute.
#define MAX_ANYCAST_DELAY_TIME     1    // seconds.
#define REACHABLE_TIME             (30 * 1000)  // 30 seconds in milliseconds.
#define MAX_REACHABLE_TIME         (60 * 60 * 1000) // 1 hour in milliseconds.
#define ICMP_MIN_ERROR_INTERVAL    1    // Ticks - a half second.
#define RETRANS_TIMER              IPv6TimerTicks(1)  // 1 second.
#define DELAY_FIRST_PROBE_TIME     IPv6TimerTicks(5)  // 5 seconds.
#define MIN_RANDOM_FACTOR          50   // Percentage of base value.
#define MAX_RANDOM_FACTOR          150  // Percentage of base value.
#define PREFIX_LIFETIME_SAFETY     IPv6TimerTicks(2 * 60 * 60)  // 2 hours.
#define RECALC_REACHABLE_INTERVAL  IPv6TimerTicks(3 * 60 * 60)  // 3 hours.
#define PATH_MTU_RETRY_TIME        IPv6TimerTicks(10 * 60)  // 10 minutes.
#define MLD_UNSOLICITED_REPORT_INTERVAL IPv6TimerTicks(10)  // 10 seconds.
#define MLD_QUERY_INTERVAL              IPv6TimerTicks(125) // 125 seconds.
#define MLD_NUM_INITIAL_REPORTS         2
#define MAX_TEMP_DAD_ATTEMPTS           5
#define MAX_TEMP_PREFERRED_LIFETIME     (24 * 60 * 60)  // 1 day.
#define MAX_TEMP_VALID_LIFETIME         (7 * MAX_TEMP_PREFERRED_LIFETIME)
#define TEMP_REGENERATE_TIME            5               // 5 seconds.
#define MAX_TEMP_RANDOM_TIME            (10 * 60)       // 10 minutes.
#define DEFAULT_CUR_HOP_LIMIT           0x80
#define DEFAULT_SITE_PREFIX_LENGTH      48

//
// Various implementation constants.
//
#define NEIGHBOR_CACHE_LIMIT            256
#define ROUTE_CACHE_LIMIT               32
#define BINDING_CACHE_LIMIT             32
#define SMALL_POOL                      10000
#define MEDIUM_POOL                     30000
#define LARGE_POOL                      60000

//
// Under NT, we use the assembly language version of the common core checksum
// routine instead of the C language version.
//
ULONG
tcpxsum(IN ULONG Checksum, IN PUCHAR Source, IN ULONG Length);

#define Cksum(Buffer, Length) ((ushort)tcpxsum(0, (PUCHAR)(Buffer), (Length)))


//
// Protocol Receive Procedures ("Next Header" handlers) have this prototype.
//
typedef uchar ProtoRecvProc(IPv6Packet *Packet);

typedef struct StatusArg {
    IP_STATUS Status;
    unsigned long Arg;
    IPv6Header UNALIGNED *IP;
} StatusArg;

//
// Protocol Control Receive Procedures have this prototype.
// These receive handlers are called for ICMP errors.
//
typedef uchar ProtoControlRecvProc(IPv6Packet *Packet, StatusArg *Arg);

typedef struct ProtocolSwitch {
  ProtoRecvProc *DataReceive;
  ProtoControlRecvProc *ControlReceive;
} ProtocolSwitch;

extern ProtoRecvProc IPv6HeaderReceive;
extern ProtoRecvProc ICMPv6Receive;
extern ProtoRecvProc FragmentReceive;
extern ProtoRecvProc DestinationOptionsReceive;
extern ProtoRecvProc RoutingReceive;
extern ProtoRecvProc EncapsulatingSecurityPayloadReceive;
extern ProtoRecvProc AuthenticationHeaderReceive;

extern ProtoControlRecvProc ICMPv6ControlReceive;
extern ProtoControlRecvProc ExtHdrControlReceive;

//
// Hop-by-Hop Options use a special receive handler.
// This is because they are processed even when a
// a packet is being forwarded instead of received.
// Note that they are only processed when immediately
// following an IPv6 header.
//
extern int
HopByHopOptionsReceive(IPv6Packet *Packet);


//
// The Raw Receive handler supports external protocol handlers.
//
extern int RawReceive(IPv6Packet *Packet, uchar Protocol);


//
// The actual definition of a reassembly structure
// can be found in fragment.h.
//
typedef struct Reassembly Reassembly;

#define USE_TEMP_NO             0       // Don't use temporary addresses.
#define USE_TEMP_YES            1       // Use them.
#define USE_TEMP_ALWAYS         2       // Always generating random numbers.
#define USE_TEMP_COUNTER        3       // Use them with per-interface counter.

//
// Prototypes for global variables.
//
extern uint DefaultCurHopLimit;
extern uint MaxTempDADAttempts;
extern uint MaxTempPreferredLifetime; // Ticks.
extern uint MaxTempValidLifetime; // Ticks.
extern uint TempRegenerateTime; // Ticks.
extern uint UseTemporaryAddresses; // See values above.
extern uint MaxTempRandomTime; // Ticks.
extern uint TempRandomTime; // Ticks.
extern ProtocolSwitch ProtocolSwitchTable[];
extern KSPIN_LOCK NetTableListLock;
extern NetTableEntry *NetTableList;  // Pointer to the net table.
extern KSPIN_LOCK IFListLock;
extern Interface *IFList;  // List of all interfaces on the system.
extern KSPIN_LOCK ZoneUpdateLock;
extern struct EchoControl *ICMPv6OutstandingEchos;
extern LIST_ENTRY PendingEchoList;  // def needed for initialization.
extern Interface *LoopInterface;
extern IPv6Addr UnspecifiedAddr;
extern IPv6Addr LoopbackAddr;
extern IPv6Addr AllNodesOnNodeAddr;
extern IPv6Addr AllNodesOnLinkAddr;
extern IPv6Addr AllRoutersOnLinkAddr;
extern IPv6Addr LinkLocalPrefix;
extern IPv6Addr SiteLocalPrefix;
extern IPv6Addr SixToFourPrefix;
extern IPv6Addr V4MappedPrefix;
extern PDEVICE_OBJECT IPDeviceObject;
extern HANDLE IPv6ProviderHandle;


//
// Some handy functions for working with IPv6 addresses.
//

__inline IPv6Addr *
AlignAddr(IPv6Addr UNALIGNED *Addr)
{
    //
    // IPv6 addresses only have char & short members,
    // so they need 2-byte alignment.
    // In practice addresses in headers are always
    // appropriately aligned.
    //
    ASSERT(((UINT_PTR)Addr % __builtin_alignof(IPv6Addr)) == 0);
    return (IPv6Addr *) Addr;
}

__inline int
IsUnspecified(const IPv6Addr *Addr)
{
    return IP6_ADDR_EQUAL(Addr, &UnspecifiedAddr);
}

__inline int
IsLoopback(const IPv6Addr *Addr)
{
    return IP6_ADDR_EQUAL(Addr, &LoopbackAddr);
}

__inline int
IsGlobal(const IPv6Addr *Addr)
{
    //
    // Check the format prefix and exclude addresses
    // whose high 4 bits are all zero or all one.
    // This is a cheap way of excluding v4-compatible,
    // v4-mapped, loopback, multicast, link-local, site-local.
    //
    uint High = (Addr->s6_bytes[0] & 0xf0);
    return (High != 0) && (High != 0xf0);
}

__inline int
IsMulticast(const IPv6Addr *Addr)
{
    return Addr->s6_bytes[0] == 0xff;
}

__inline int
IsLinkLocal(const IPv6Addr *Addr)
{
    return ((Addr->s6_bytes[0] == 0xfe) &&
            ((Addr->s6_bytes[1] & 0xc0) == 0x80));
}

__inline int
IsLinkLocalMulticast(const IPv6Addr *Addr)
{
    return IsMulticast(Addr) && ((Addr->s6_bytes[1] & 0xf) == ADE_LINK_LOCAL);
}

__inline int
IsInterfaceLocalMulticast(const IPv6Addr *Addr)
{
    return (IsMulticast(Addr) &&
            ((Addr->s6_bytes[1] & 0xf) == ADE_INTERFACE_LOCAL));
}

extern int
IsSolicitedNodeMulticast(const IPv6Addr *Addr);

__inline int
IsSiteLocal(const IPv6Addr *Addr)
{
    return ((Addr->s6_bytes[0] == 0xfe) &&
            ((Addr->s6_bytes[1] & 0xc0) == 0xc0));
}

__inline int
IsSiteLocalMulticast(const IPv6Addr *Addr)
{
    return IsMulticast(Addr) && ((Addr->s6_bytes[1] & 0xf) == ADE_SITE_LOCAL);
}

extern int
IP6_ADDR_LTEQ(const IPv6Addr *A, const IPv6Addr *B);

extern int
IsEUI64Address(const IPv6Addr *Addr);

extern int
IsKnownAnycast(const IPv6Addr *Addr);

extern int
IsSubnetRouterAnycast(const IPv6Addr *Addr);

extern int
IsSubnetReservedAnycast(const IPv6Addr *Addr);

extern int
IsInvalidSourceAddress(const IPv6Addr *Addr);

extern int
IsNotManualAddress(const IPv6Addr *Addr);

extern int
IsV4Compatible(const IPv6Addr *Addr);

extern void
CreateV4Compatible(IPv6Addr *Addr, IPAddr V4Addr);

extern int
IsV4Mapped(const IPv6Addr *Addr);

extern void
CreateV4Mapped(IPv6Addr *Addr, IPAddr V4Addr);

__inline IPAddr
ExtractV4Address(const IPv6Addr *Addr)
{
    return * (IPAddr UNALIGNED *) &Addr->s6_bytes[12];
}

__inline int
Is6to4(const IPv6Addr *Addr)
{
    return Addr->s6_words[0] == 0x0220;
}

__inline IPAddr
Extract6to4Address(const IPv6Addr *Addr)
{
    return * (IPAddr UNALIGNED *) &Addr->s6_bytes[2];
}

__inline int
IsISATAP(const IPv6Addr *Addr)
{
    return (((Addr->s6_words[4] & 0xFFFD) == 0x0000) &&
            (Addr->s6_words[5] == 0xfe5e));
}

__inline int
IsV4Multicast(IPAddr Addr)
{
    return (Addr & 0x000000f0) == 0x000000e0;
}

__inline int
IsV4Broadcast(IPAddr Addr)
{
    return Addr == 0xffffffff;
}

__inline int
IsV4Loopback(IPAddr Addr)
{
    return (Addr & 0x000000ff) == 0x0000007f;
}

__inline int
IsV4Unspecified(IPAddr Addr)
{
    return (Addr & 0x000000ff) == 0x00000000;
}

__inline ushort
MulticastAddressScope(const IPv6Addr *Addr)
{
    return Addr->s6_bytes[1] & 0xf;
}

extern ushort
UnicastAddressScope(const IPv6Addr *Addr);

extern ushort
AddressScope(const IPv6Addr *Addr);

extern ushort
V4AddressScope(IPAddr Addr);

extern uint
DetermineScopeId(const IPv6Addr *Addr, Interface *IF);

extern void
CreateSolicitedNodeMulticastAddress(const IPv6Addr *Addr, IPv6Addr *MCastAddr);

extern int
HasPrefix(const IPv6Addr *Addr, const IPv6Addr *Prefix, uint PrefixLength);

extern void
CopyPrefix(IPv6Addr *Addr, const IPv6Addr *Prefix, uint PrefixLength);

extern uint
CommonPrefixLength(const IPv6Addr *Addr, const IPv6Addr *Addr2);

extern int
IntersectPrefix(const IPv6Addr *Prefix1, uint Prefix1Length,
                const IPv6Addr *Prefix2, uint Prefix2Length);

//
// Function prototypes.
//

extern int
GetSystemRandomBits(uchar *Buffer, uint Length);

extern void
SeedRandom(const uchar *Seed, uint Length);

extern uint
Random(void);

extern uint
RandomNumber(uint Min, uint Max);

//
// Taken from ws2tcpip.h - unfortunately we can not include that file here.
// These numbers include space for a port number, which we do not need,
// but that's OK.
//
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65

__inline int
ParseV6Address(const WCHAR *Sz, const WCHAR **Terminator, IPv6Addr *Addr)
{
    return NT_SUCCESS(RtlIpv6StringToAddressW(Sz, Terminator, Addr));
}

__inline void
FormatV6AddressWorker(char *Sz, const IPv6Addr *Addr)
{
    (void) RtlIpv6AddressToStringA(Addr, Sz);
}

extern char *
FormatV6Address(const IPv6Addr *Addr);

__inline int
ParseV4Address(const WCHAR *Sz, const WCHAR **Terminator, IPAddr *Addr)
{
    return NT_SUCCESS(RtlIpv4StringToAddressW(Sz, TRUE, Terminator, (struct in_addr *)Addr));
}

__inline void
FormatV4AddressWorker(char *Sz, IPAddr Addr)
{
    (void) RtlIpv4AddressToStringA((struct in_addr *)&Addr, Sz);
}

extern char *
FormatV4Address(IPAddr Addr);

extern ushort
ChecksumPacket(PNDIS_PACKET Packet, uint Offset, uchar *Data, uint Length,
               const IPv6Addr *Source, const IPv6Addr *Dest, uchar NextHeader);

extern void
LoopQueueTransmit(PNDIS_PACKET Packet);

extern NDIS_STATUS
IPv6SendLater(LARGE_INTEGER Time,
              Interface *IF, PNDIS_PACKET Packet,
              uint Offset, const void *LinkAddress);

extern void
IPv6SendLL(Interface *IF, PNDIS_PACKET Packet,
           uint Offset, const void *LinkAddress);

extern void
IPv6SendND(PNDIS_PACKET Packet, uint Offset, NeighborCacheEntry *NCE,
           const IPv6Addr *DiscoveryAddress);

#define SEND_FLAG_BYPASS_BINDING_CACHE 0x00000001

extern void
IPv6Send(PNDIS_PACKET Packet, uint Offset, IPv6Header UNALIGNED *IP,
         uint PayloadLength, RouteCacheEntry *RCE, uint Flags,
         ushort TransportProtocol, ushort SourcePort, ushort DestPort);

extern void
IPv6Forward(NetTableEntryOrInterface *RecvNTEorIF,
            PNDIS_PACKET Packet, uint Offset, IPv6Header UNALIGNED *IP,
            uint PayloadLength, int Redirect, IPSecProc *IPSecToDo,
            RouteCacheEntry *RCE);

extern void
IPv6SendAbort(NetTableEntryOrInterface *NTEorIF,
              PNDIS_PACKET Packet, uint Offset,
              uchar ICMPType, uchar ICMPCode, ulong ErrorParameter,
              int MulticastOverride);

extern void
ICMPv6EchoTimeout(void);

extern void
IPULUnloadNotify(void);

extern Interface *
FindInterfaceFromIndex(uint Index);

extern Interface *
FindInterfaceFromGuid(const GUID *Guid);

extern Interface *
FindNextInterface(Interface *IF);

extern Interface *
FindInterfaceFromZone(Interface *OrigIF, uint Scope, uint Index);

extern uint
FindNewZoneIndex(uint Scope);

extern void
InitZoneIndices(uint *ZoneIndices, uint Index);

extern void
UpdateZoneIndices(Interface *IF, uint *ZoneIndices);

extern Interface *
FindDefaultInterfaceForZone(uint Scope, uint ScopeId);

extern void
IPv6Timeout(PKDPC MyDpcObject, void *Context, void *Unused1, void *Unused2);

extern int
MapNdisBuffers(NDIS_BUFFER *Buffer);

extern uchar *
GetDataFromNdis(PNDIS_BUFFER SrcBuffer, uint SrcOffset, uint Length,
                uchar *DataBuffer);

extern IPv6Header UNALIGNED *
GetIPv6Header(PNDIS_PACKET Packet, uint Offset, IPv6Header *HdrBuffer);

extern int
CheckLinkLayerMulticastAddress(Interface *IF, const void *LinkAddress);

extern void
AddNTEToInterface(Interface *IF, NetTableEntry *NTE);

extern uint
InterfaceIndex(void);

extern void
AddInterface(Interface *IF);

extern void
UpdateLinkMTU(Interface *IF, uint MTU);

extern NetTableEntry *
CreateNTE(Interface *IF, const IPv6Addr *Address,
          uint AddrConf,
          uint ValidLifetime, uint PreferredLifetime);

extern MulticastAddressEntry *
FindOrCreateMAE(Interface *IF, const IPv6Addr *Addr, NetTableEntry *NTE);

extern MulticastAddressEntry *
FindAndReleaseMAE(Interface *IF, const IPv6Addr *Addr);

extern int
FindOrCreateAAE(Interface *IF, const IPv6Addr *Addr,
                NetTableEntryOrInterface *NTEorIF);

extern int
FindAndDeleteAAE(Interface *IF, const IPv6Addr *Addr);

extern void
DestroyADEs(Interface *IF, NetTableEntry *NTE);

extern void
DestroyNTE(Interface *IF, NetTableEntry *NTE);

extern void
EnlivenNTE(Interface *IF, NetTableEntry *NTE);

extern void
DestroyIF(Interface *IF);

extern AddressEntry **
FindADE(Interface *IF, const IPv6Addr *Addr);

extern NetTableEntryOrInterface *
FindAddressOnInterface(Interface *IF, const IPv6Addr *Addr, ushort *AddrType);

extern NetTableEntry *
GetLinkLocalNTE(Interface *IF);

extern int
GetLinkLocalAddress(Interface *IF, IPv6Addr *Addr);

extern void
DeferRegisterNetAddress(NetTableEntry *NTE);

extern void
DeferSynchronizeMulticastAddresses(Interface *IF);

extern int
IPInit(void);

extern int Unloading;

extern void
IPUnload(void);

extern void
AddrConfUpdate(Interface *IF, const IPv6Addr *Prefix,
               uint ValidLifetime, uint PreferredLifetime,
               int Authenticated, NetTableEntry **pNTE);

extern int
FindOrCreateNTE(Interface *IF, const IPv6Addr *Addr,
                uint AddrConf,
                uint ValidLifetime, uint PreferredLifetime);

extern void
AddrConfDuplicate(Interface *IF, NetTableEntry *NTE);

extern void
AddrConfNotDuplicate(Interface *IF, NetTableEntry *NTE);

extern void
AddrConfResetAutoConfig(Interface *IF, uint MaxLifetime);

extern void
AddrConfTimeout(NetTableEntry *NTE);

extern void
NetTableTimeout(void);

extern void
NetTableCleanup(void);

extern void
InterfaceTimeout(void);

extern void
InterfaceCleanup(void);

extern void
InterfaceReset(void);

extern NTSTATUS
UpdateInterface(Interface *IF, int Advertises, int Forwards);

extern void
ReconnectInterface(Interface *IF);

extern void
InterfaceResetAutoConfig(Interface *IF);

extern int
LanInit(void);

extern void
LanUnload(void);

extern int
LoopbackInit(void);

extern void
ProtoTabInit(void);

extern void
ICMPv6Init(void);

extern int
IPSecInit(void);

extern void
IPSecUnload(void);

extern int
TunnelInit(void);

extern void
TunnelUnload(void);

extern NTSTATUS
TunnelCreateTunnel(IPAddr SrcAddr, IPAddr DstAddr,
                   uint Flags, Interface **ReturnIF);

extern int
TunnelGetSourceAddress(IPAddr Dest, IPAddr *Source);

extern ulong
NewFragmentId(void);

extern void
ReassemblyInit(void);

extern void
ReassemblyUnload(void);

extern void
ReassemblyRemove(Interface *IF);

extern void
CreateGUIDFromName(const char *Name, GUID *Guid);

extern void
ConfigureGlobalParameters(void);

extern void
ConfigureInterface(Interface *IF);

extern void
ConfigurePrefixPolicies(void);

extern void
ConfigurePersistentInterfaces(void);

#pragma warning(pop)
#endif // IPv6DEF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\raw.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Raw Internet Protocol interface definitions.
//


#include "datagram.h"


//
// External definitions.
//

extern void RawSend(AddrObj *SrcAO, DGSendReq *SendReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcb.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions for TCP Control Block management.
//


#define MAX_REXMIT_CNT 5
#define MAX_CONNECT_REXMIT_CNT 2  // Dropped from 3 to 2 to match IPv4.

extern uint TCPTime;
extern SeqNum ISNMonotonicPortion;

// Maximum Increment of 32K per connection.
#define MAX_ISN_INCREMENT_PER_CONNECTION 0x7FFF

// Number of connections that can increment the ISN per 100ms without
// the problem of old duplicates being a threat. Note that, this still does
// not guarantee that "wrap-around of sequence number space does not
// happen within 2MSL", which could lead to failures in reuse of Time-wait
// TCBs etc.
#define MAX_ISN_INCREMENTABLE_CONNECTIONS_PER_100MS ((0xFFFFFFFF) / \
            (MAX_REXMIT_TO * MAX_ISN_INCREMENT_PER_CONNECTION ))

// Converts a quantity represented in 100 ns units to ms.
#define X100NSTOMS(x) ((x)/10000)

//
// REVIEW: better hash function for IPv6 addresses?
//
#ifdef OLDHASH1
#define TCB_HASH(DA,SA,DP,SP) ((uint)(*(uchar *)&(DA) + *((uchar *)&(DA) + 1) \
    + *((uchar *)&(DA) + 2) + *((uchar *)&(DA) + 3)) % TcbTableSize)
#endif

#ifdef OLDHASH
#define TCB_HASH(DA,SA,DP,SP) (((DA) + (SA) + (uint)(DP) + (uint)(SP)) % \
                               TcbTableSize)
#endif

#define ROR8(x) (ushort)(((ushort)(x) >> 1) | (ushort)(((ushort)(x) & 1) << 15))

#define TCB_HASH(DA,SA,DP,SP) \
    (uint)(((uint)(ROR8(ROR8(ROR8(*(ushort *)&(DP) + \
                                  *(ushort *)&(SP)) + \
                             *(ushort *)&(DA)) + \
                        *((ushort *)&(DA) + 1)))) & \
           (TcbTableSize - 1))

extern struct TCB *FindTCB(IPv6Addr *Src, IPv6Addr *Dest,
                           uint SrcScopeId, uint DestScopeId,
                           ushort SrcPort, ushort DestPort);
extern uint InsertTCB(struct TCB *NewTCB);
extern struct TCB *AllocTCB(void);
extern void FreeTCB(struct TCB *FreedTCB);
extern uint RemoveTCB(struct TCB *RemovedTCB);

extern uint ValidateTCBContext(void *Context, uint *Valid);
extern uint ReadNextTCB(void *Context, void *OutBuf);

extern int InitTCB(void);
extern void UnloadTCB(void);
extern void CalculateMSSForTCB(struct TCB *);
extern void TCBWalk(uint (*CallRtn)(struct TCB *, void *, void *, void *),
                    void *Context1, void *Context2, void *Context3);
extern uint DeleteTCBWithSrc(struct TCB *CheckTCB, void *AddrPtr,
                             void *Unused1, void *Unused2);
extern uint SetTCBMTU(struct TCB *CheckTCB, void *DestPtr, void *SrcPtr,
                      void *MTUPtr);
extern void ReetSendNext(struct TCB *SeqTCB, SeqNum DropSeq);

extern uint TCBWalkCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\oscfg.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// General include file for definitions we want everywhere.
//


#ifndef OSCFG_INCLUDED
#define OSCFG_INCLUDED

//
// We want to cast pointer l-values for use with the += operator.
//
#pragma warning(disable:4213) // cast on l-value

#pragma warning(disable:4152) // function/data pointer conversion in expression
#pragma warning(disable:4200) // zero-sized array in struct/union

//
// We often use int rather than BOOLEAN since the assembly is often more
// efficient.
//
#pragma warning(disable:4244) // conversion from 'int' to 'BOOLEAN'

//
// Temporarily disable 4127 which is hit by PAGED_CODE(), KeQueryTickCount(),
// etc.
//
#pragma warning(disable:4127) // conditional expression is constant

#if defined (_WIN64)
#define MAX_CACHE_LINE_SIZE 128
#else
#define MAX_CACHE_LINE_SIZE 64
#endif

#define CACHE_ALIGN __declspec(align(MAX_CACHE_LINE_SIZE))

//
// Common types.
//
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

//
// Network byte-order is big-endian.
// NT runs in little-endian mode on all supported architectures.
//
__inline ushort
net_short(ushort x)
{
    return (((x & 0xff) << 8) | ((x & 0xff00) >> 8));
}

__inline ulong
net_long(ulong x)
{
    return (((x & 0xffL) << 24) | ((x & 0xff00L) << 8) |
            ((x & 0xff0000L) >> 8) | ((x &0xff000000L) >> 24));
}


//
// Find the highest power of two that is greater
// than or equal to the Value.
//
__inline ulong
ComputeLargerOrEqualPowerOfTwo(
    ulong Value
    )
{
    ulong Temp;

    for (Temp = 1; Temp < Value; Temp <<= 1);

    return Temp;
}

//
// Helpfull macros.
//
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))


//
// NT specific definitions.
//

#include <ntosp.h>
#include <zwapi.h>

#define BEGIN_INIT
#define END_INIT

#include <ndis.h>

//
// Used to report an error from an API that we've called.
// For example, ExAllocatePool failed.
//
#define DPFLTR_NTOS_ERROR       DPFLTR_INFO_LEVEL

//
// Used to report an error in an incoming packet.
// For example, a malformed packet header.
//
#define DPFLTR_BAD_PACKET       DPFLTR_WARNING_LEVEL

//
// Used to report an error in a user's system call or ioctl.
// For example, an illegal argument.
//
#define DPFLTR_USER_ERROR       DPFLTR_WARNING_LEVEL

//
// Used to report an internal error.
// For example, RouteToDestination failed.
//
#define DPFLTR_INTERNAL_ERROR   DPFLTR_WARNING_LEVEL

//
// Used to report an internal unusual occurrence.
// For example, a rare race happened.
//
#define DPFLTR_INFO_RARE        DPFLTR_INFO_LEVEL

//
// Used to report routine but unusual occurrences,
// which often indicate network configuration problem or packet loss.
// For example, fragmentation reassembly timeout.
//
#define DPFLTR_NET_ERROR        DPFLTR_TRACE_LEVEL

//
// Used to report routine state changes,
// which do not happen too frequently.
// For example, creating/deleting an interface or address.
//
#define DPFLTR_INFO_STATE       DPFLTR_INFO_LEVEL

//
// Used under IPSEC_DEBUG.
//
#define DPFLTR_INFO_IPSEC       DPFLTR_INFO_LEVEL

//
// Used under IF_TCPDBG.
//
#define DPFLTR_INFO_TCPDBG      DPFLTR_INFO_LEVEL

//
// NdisGetFirstBufferFromPacket is bad in two ways:
// It uses MmGetMdlVirtualAddress instead of MmGetSystemAddressForMdlSafe.
// It scans over all the buffers adding up the total length,
// even if you don't want it.
//
__inline PNDIS_BUFFER
NdisFirstBuffer(PNDIS_PACKET Packet)
{
    return Packet->Private.Head;
}

//
// Use the function versions of these Ndis APIs,
// so that we are immune to changes in internal NDIS structures.
//

#undef NdisRequest
VOID
NdisRequest(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );

#undef NdisSend
VOID
NdisSend(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    );

#undef NdisTransferData
VOID
NdisTransferData(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN OUT  PNDIS_PACKET        Packet,
    OUT PUINT                   BytesTransferred
    );

#ifdef _X86_
//
// The Whistler build environment renames
// ExInterlockedPopEntrySList and
// ExInterlockedPushEntrySList to remove the Ex.
// Whistler ntoskrnl.exe exposes both entry points,
// Win2k ntoskrnl.exe only has the Ex entrypoints.
// We use the older entrypoints so that we run on Win2k.
//
#undef ExInterlockedPopEntrySList
NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

#undef ExInterlockedPushEntrySList
NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );
#endif // _X86_

//
// Support for tagging memory allocations.
//
#define IP6_TAG     '6vPI'

#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, IP6_TAG)

#endif // POOL_TAGGING

#if DBG
//
// Support for debug event log.
//
// The debug event log allows for "real time" logging of events
// in a circular queue kept in non-pageable memory.  Each event consists
// of an id number and a arbitrary 32 bit value.  The LogDebugEvent
// function adds a 64 bit timestamp to the event and adds it to the log.
//

// DEBUG_LOG_SIZE must be a power of 2 for wrap around to work properly.
#define DEBUG_LOG_SIZE (8 * 1024)  // Number of debug log entries.

struct DebugLogEntry {
    LARGE_INTEGER Time;  // When.
    uint Event;          // What.
    int Arg;             // How/Who/Where/Why?
};

void LogDebugEvent(uint Event, int Arg);
#else
#define LogDebugEvent(Event, Arg)
#endif // DBG

#ifndef COUNTING_MALLOC
#define COUNTING_MALLOC DBG
#endif

#if     COUNTING_MALLOC

#if defined(ExFreePool)
#undef ExFreePool
#endif

#define ExAllocatePoolWithTag(poolType, size, tag)  CountingExAllocatePoolWithTag((poolType),(size),(tag), __FILE__, __LINE__)

#define ExFreePool(p) CountingExFreePool((p))

VOID *
CountingExAllocatePoolWithTag(
    IN POOL_TYPE        PoolType,
    IN ULONG            NumberOfBytes,
    IN ULONG            Tag,
    IN PCHAR            File,
    IN ULONG            Line);

VOID
CountingExFreePool(
    PVOID               p);

VOID
InitCountingMalloc(void);

VOID
DumpCountingMallocStats(void);

VOID
UnloadCountingMalloc(void);

#endif  // COUNTING_MALLOC

#endif // OSCFG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\queue.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP/UDP queuing definitions.
//


//
// Definition of a queue linkage field.
//
typedef struct Queue {
    struct Queue *q_next;
    struct Queue *q_prev;
} Queue;


//
// Initialize queue macro.
//
#define INITQ(q) { (q)->q_next = (q);\
                   (q)->q_prev = (q); }

//
// Macro to check for queue empty.
//
#define EMPTYQ(q) ((q)->q_next == (q))

//
// Place an element onto the end of the queue.
//
#define ENQUEUE(q, e) { (q)->q_prev->q_next = (e);\
                        (e)->q_prev = (q)->q_prev;\
                        (q)->q_prev = (e);\
                        (e)->q_next = (q); }

//
// Remove an element from the head of the queue.  This macro assumes the queue
// is not empty.  The element is returned as type t, queued through linkage l.
//
#define DEQUEUE(q, ptr, t, l) {\
               Queue *__tmp__;\
               \
               __tmp__ = (q)->q_next;\
               (q)->q_next = __tmp__->q_next;\
               __tmp__->q_next->q_prev = (q);\
               (ptr) = CONTAINING_RECORD(__tmp__, t, l);\
               }

//
// Peek at an element at the head of the queue.  Return a pointer to it
// without removing anything.
//
#define PEEKQ(q, ptr, t, l) {\
             Queue *__tmp__;\
             \
             __tmp__ = (q)->q_next;\
             (ptr) = CONTAINING_RECORD(__tmp__, t, l);\
             }

//
// Macro to push an element onto the head of a queue.
//
#define PUSHQ(q, e) { (e)->q_next = (q)->q_next;\
                      (q)->q_next->q_prev = (e);\
                      (e)->q_prev = (q);\
                      (q)->q_next = e; }

//
// Macro to remove an element from the middle of a queue.
//
#define REMOVEQ(q) { (q)->q_next->q_prev = (q)->q_prev;\
                     (q)->q_prev->q_next = (q)->q_next; }

//
// The following macros define methods for working with queue without
// dequeueing, mostly dealing with Queue structures directly.
//

// Macro to define the end of a Q, used in walking a queue sequentially.
#define QEND(q) (q)

// Macro to get the first on a queue.
#define QHEAD(q) (q)->q_next

// Macro to get a structure, given a queue.
#define QSTRUCT(t, q, l) CONTAINING_RECORD((q), t, l)

// Macro to get the next thing on q queue.
#define QNEXT(q) (q)->q_next
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\mld.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Internet Group Message Protocol for Internet Protocol Version 6.
// See RFC 1885 and RFC 2236 for details.
//


#ifndef MLD_INCLUDED
#define MLD_INCLUDED 1

//
// MLD values defined by the spec.
//
#define MLD_ROUTER_ALERT_OPTION_TYPE      0


//
// Combined structure used for inserting router alert into MLD messages.
//
typedef struct MLDRouterAlertOption {
    IPv6OptionsHeader Header;
    IPv6RouterAlertOption Option;
    OptionHeader Pad;
    // No pad data is needed since with the PadN option the sizeof
    // this struct = 8.
} MLDRouterAlertOption;

//
// MLD external functions.
//

extern KSPIN_LOCK QueryListLock;
extern MulticastAddressEntry *QueryList;

extern void
AddToQueryList(MulticastAddressEntry *MAE);

extern void
RemoveFromQueryList(MulticastAddressEntry *MAE);

extern void
MLDQueryReceive(IPv6Packet *Packet);

extern void
MLDReportReceive(IPv6Packet *Packet);

extern void
MLDInit(void);

extern void
MLDTimeout(void);

extern IP_STATUS
MLDAddMCastAddr(uint *pInterfaceNo, const IPv6Addr *Addr);

extern IP_STATUS
MLDDropMCastAddr(uint InterfaceNo, const IPv6Addr *Addr);

__inline int
IsMLDReportable(MulticastAddressEntry *MAE)
{
    return ((MAE->Scope >= ADE_LINK_LOCAL) &&
            !IP6_ADDR_EQUAL(&MAE->Address, &AllNodesOnLinkAddr));
}

#endif  // MLD_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\security.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IPsec Database data structures.
//

#ifndef SECURITY_INCLUDED
#define SECURITY_INCLUDED 1

//#define IPSEC_DEBUG

// Return values for SPLookup.
#define LOOKUP_DROP     0x01
#define LOOKUP_CONT     0x02
#define LOOKUP_BYPASS   0x04
#define LOOKUP_IKE_NEG  0x08

#define NO_TUNNEL   ((UINT)-1)

#define SA_INVALID          0
#define SA_VALID            1
#define SA_NEGOTIATING      2
#define SA_REMOVED          4

// Bound the raw key size that we'll accept when creating an SA.
// REVIEW: This should be big enough to handle any rational key.  Is it?
#define MAX_KEY_SIZE 1024
#define MAX_CONTEXT_SIZE 128
#define MAX_RESULT_SIZE 32

//
// IPSecSpec - IPsec Specification.
// This is the protocol and mode used for IPsec.  The RemoteIPAddr is set
// when a tunnel to a security gateway is used.
//
typedef struct IPSecSpec {
    uint Protocol;               // IP Protocol of IPSec employed, 0 for *.
    uint Mode;                   // Transport or Tunnel.
    IPv6Addr RemoteSecGWIPAddr;  // Set when Security Gateway Tunnel is used.
} IPSecSpec;

//
// Security algorithms have these prototypes.
// The 'Context' is per-algorithm specific.
//
// REVIEW: This enough for both encryption and authentication?
//
typedef void AlgorithmKeyPrepProc(uchar *RawKey, uint RawKeySize, uchar *Key);
typedef void AlgorithmInitProc(void *Context, uchar *Key);
typedef void AlgorithmOpProc(void *Context, uchar *Key, uchar *Data,
                             uint Len);
typedef void AlgorithmFinalProc(void *Context, uchar *Key, uchar *Result);

// REVIEW: Use Algorithm specific ContextSize or just have a universal max?
// REVIEW: Ditto for KeySize.
typedef struct SecurityAlgorithm {
    ushort KeySize;                    // Bytes used by key information.
    ushort ContextSize;                // Bytes used by contextual information.
    uint ResultSize;                   // Bytes returned by FinalProc.
    AlgorithmKeyPrepProc *PrepareKey;  // Key preprocessing.
    AlgorithmInitProc *Initialize;     // Prepare algorithm (estab. context).
    AlgorithmOpProc *Operate;          // Run algorithm on increment of data.
    AlgorithmFinalProc *Finalize;      // Get final result.
} SecurityAlgorithm;

extern void
AlgorithmsInit(void);

typedef struct SecurityPolicy SecurityPolicy;
typedef struct SecurityAssociation SecurityAssociation;


//
// Security Policy Database structure.
// 
// Contains all the information relevant to a security policy.
//
struct SecurityPolicy {               // SP entry.
    SecurityPolicy *Next;
    SecurityPolicy *Prev;

    uint RemoteAddrField;             // Single, range, or wildcard.
    uint RemoteAddrSelector;          // Packet or policy.
    IPv6Addr RemoteAddr;              // Start of range or single value.
    IPv6Addr RemoteAddrData;          // End of range.
    
    uint LocalAddrField;              // Single, range, or wildcard.
    uint LocalAddrSelector;           // Packet or policy.
    IPv6Addr LocalAddr;               // Start of range or single value.
    IPv6Addr LocalAddrData;           // End of range.
    
    uint TransportProtoSelector;      // Packet or policy.
    ushort TransportProto;            // If NONE, protocol is opaque (and 
                                      // the ports should be skipped too).
    
    uint RemotePortField;             // Single, range, or wildcard.
    uint RemotePortSelector;          // Packet or policy.
    ushort RemotePort;                // Start of range or single value.
    ushort RemotePortData;            // End of range.

    uint LocalPortField;              // Single, range, or wildcard.
    uint LocalPortSelector;           // Packet or policy.
    ushort LocalPort;                 // Start of range or single value.
    ushort LocalPortData;             // End of range.
    
    uint SecPolicyFlag;               // Bypass/Discard/Apply.

    IPSecSpec IPSecSpec;              // IPsec Protocol and Mode.

    void *Name;                       // Required (gag) selector type for
                                      // system or user@system identifiers.
                                      // If NULL, this selector is opaque.

    uint DirectionFlag;               // Direction of traffic.

    SecurityPolicy *SABundle;         // Policy for use IPsec nesting.
    SecurityPolicy *PrevSABundle;     // Pointer used during SP deletion.
    SecurityAssociation *OutboundSA;  // Pointer to outbound SA.
    SecurityAssociation *InboundSA;   // Pointer to inbound SA.

    uint Index;                       // Index used during ioctl.
    
    uint IFIndex;                     // Interface index (0 to wildcard).

    uint RefCnt;                      // Reference count.
    uint NestCount;                   // Count of nested IPSec for Bundles.    

    uint Valid;
};

//
// Security Association (SA) Database structure.
//
// A unique SA is the tuple of the SPI, the destination address,
// and the IPSec protocol of the packet.  For packets with
// multiple IPSec extension headers, there are multiple SAs,
// comprising an SA Bundle.
//
// The SA selectors are the same as the SP selectors.  If the selector entry
// in the SP has the take from policy flag set, the matching selector entry
// in the SA contains NONE (0) since the SP and SA selector are the same.  
// If the selector entry in the SP has the take from packet flag set, the
// matching selector entry in the SA contains the value from the packet.
//
struct SecurityAssociation {               // SA entry.
    SecurityAssociation *Next;
    SecurityAssociation *Prev;

    ulong SPI;                             // Security Parameter Index.
    IPv6Addr SADestAddr;                   // Destination address.
    uint IPSecProto;                       // IPSec protocol.

    ulong SequenceNum;                     // Used by anti-replay algorithms.
    uint SequenceNumOverflowFlag;          // What to do when sequence number
                                           // overflows.

#ifdef IPSEC_DEBUG
    uchar *RawKey;                         // For debugging key problems.
    uint RawKeyLength;             
#endif

    uchar *Key;                            // Pointer to secret key.
    uint KeyLength;                        // Key length in bytes.   
    
    uint AlgorithmId;                      // Algorithm to apply.
                                           
    IPv6Addr DestAddr;                     // Packet value or NONE.
    IPv6Addr SrcAddr;                      // Packet value or NONE.
    ushort TransportProto;                 // Packet value or NONE.
    ushort DestPort;                       // Packet value or NONE.
    ushort SrcPort;                        // Packet value or NONE.
     
    uint DirectionFlag;                    // Direction of traffic.

    SecurityAssociation *ChainedSecAssoc;  // Chained SA pointer.
    SecurityPolicy *SecPolicy;             // Pointer to SP entry.  Only set
                                           // for first entry of a chain or
                                           // single entry.

    uint Index;                            // Index used during ioctl.
    uint RefCnt;                           // Reference Count.

    uint Valid;                            // This entry still valid?
};

__inline void
AddRefSA(SecurityAssociation *SA)
{
    InterlockedIncrement((PLONG)&SA->RefCnt);
}

//
// Structure used to link "seen" SAs onto packet structure.
// REVIEW: using uints for Mode and NextHeader is wasteful.
//
struct SALinkage {
    SALinkage *Next;            // Next entry on stack of "seen" SAs.
    SecurityAssociation *This;  // SA used to accept this packet.
    uint Mode;                  // Mode received in (Transport or Tunnel).
    uint NextHeader;            // Header following one associated with this.
};

// Lookup result.
struct IPSecProc {
    SecurityAssociation *SA;
    uint Mode;          // Tunnel or Transport.
    uchar *AuthData;    // Where to put authentication data.
    uint Offset;        // Where to start doing the authentication (ESP only).
    uint BundleSize;    // Array Size only first element has actual size.
    uint ByteSize;      // Amount of bytes for this IPSec header.
};

//
// Global variables.
//
extern KSPIN_LOCK IPSecLock;
extern SecurityPolicy *SecurityPolicyList;  // List of current policies.
extern SecurityAssociation *SecurityAssociationList;  // List of associations.
extern ulong SecurityStateValidationCounter;  // For validating cached state.
extern SecurityAlgorithm AlgorithmTable[];  // Array of IPSec Algorithms.
extern int MobilitySecurity;  // Mobility security (on or off).


__inline void
InvalidateSecurityState(void)
{
    InterlockedIncrement((PLONG)&SecurityStateValidationCounter);
}


//
// Function prototypes.
//
extern void
RemoveSecurityAssociation(SecurityAssociation *SA);

extern int
DeleteSA(SecurityAssociation *SA);

extern void
ReleaseSA(SecurityAssociation *SA);

extern void
RemoveSecurityPolicy(SecurityPolicy *SP);

extern int 
DeleteSP(SecurityPolicy *SP);

extern int
InboundSecurityCheck(IPv6Packet *Packet, ushort TransportProtocol,
                     ushort SourcePort, ushort DestPort, Interface *IF);

extern void
FreeIPSecToDo(IPSecProc *IPSecToDo, uint Number);

extern IPSecProc *
OutboundSPLookup(IPv6Addr *SourceAddr, IPv6Addr *DestAddr, 
                 ushort TransportProtocol, ushort SourcePort,
                 ushort DestPort, Interface *IF, uint *Action);

extern SecurityPolicy *
FindSecurityPolicyMatch(SecurityPolicy *List, uint IFIndex, uint PolicyIndex);

extern SecurityAssociation *
FindSecurityAssociationMatch(ulong Index);

extern int
InsertSecurityPolicy(SecurityPolicy *SP);

extern int
InsertSecurityAssociation(SecurityAssociation *SA);

extern ulong
GetSecurityPolicyIndex(SecurityPolicy *SP);

extern uint 
IPSecBytesToInsert(IPSecProc *IPSecToDo, uint *TunnelStart,
                   uint *TrailerLength);

extern uint
IPSecInsertHeaders(uint Mode, IPSecProc *IPSecToDo, uchar **InsertPoint,
                   uchar *NewMemory, PNDIS_PACKET Packet,
                   uint *TotalPacketSize, uchar *PrevNextHdr,
                   uint TunnelStart, uint *BytesInserted,
                   uint *NumESPTrailers, uint *JUST_ESP);

extern uint  
IPSecAdjustMutableFields(uchar *InsertPoint, IPv6RoutingHeader *SavedRtHdr);

extern void
IPSecAuthenticatePacket(uint Mode, IPSecProc *IPSecToDo, uchar *InsertPoint, 
                        uint *TunnelStart, uchar *NewMemory,
                        uchar *EndNewMemory, PNDIS_BUFFER NewBuffer1);

#ifdef IPSEC_DEBUG
extern void
dump_encoded_mesg(uchar *buff, uint len);
extern
void DumpKey(uchar *buff, uint len);
#endif

#endif  // SECURITY_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\select.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Declarations and definitions for source address selection
// and destination address ordering.
//


#ifndef SELECT_INCLUDED
#define SELECT_INCLUDED 1

#include <tdi.h>

extern void InitSelect(void);

extern void UnloadSelect(void);

typedef struct PrefixPolicyEntry {
    struct PrefixPolicyEntry *Next;
    IPv6Addr Prefix;
    uint PrefixLength;
    uint Precedence;
    uint SrcLabel;
    uint DstLabel;
} PrefixPolicyEntry;

//
// SelectLock protects PrefixPolicyTable.
//
extern KSPIN_LOCK SelectLock;

extern PrefixPolicyEntry *PrefixPolicyTable;

extern void
PrefixPolicyReset(void);

extern void
PrefixPolicyUpdate(const IPv6Addr *PolicyPrefix, uint PrefixLength,
                   uint Precedence, uint SrcLabel, uint DstLabel);

extern void
PrefixPolicyDelete(const IPv6Addr *PolicyPrefix, uint PrefixLength);

extern void
PrefixPolicyLookup(const IPv6Addr *Addr,
                   uint *Precedence, uint *SrcLabel, uint *DstLabel);

extern NetTableEntry *
FindBestSourceAddress(Interface *IF, const IPv6Addr *Dest);

extern void
ProcessSiteLocalAddresses(TDI_ADDRESS_IP6 *Addrs,
                          uint *Key,
                          uint *pNumAddrs);

extern void
SortDestAddresses(const TDI_ADDRESS_IP6 *Addrs,
                  uint *Key,
                  uint NumAddrs);

#endif  // SELECT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\route.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Routing code external definitions for Internet Protocol Version 6.
//


#ifndef ROUTE_INCLUDED
#define ROUTE_INCLUDED 1

#ifndef IPINFO_INCLUDED
# include <ipinfo.h>
#endif

typedef struct BindingCacheEntry BindingCacheEntry;
typedef struct RouteTableEntry RouteTableEntry;
typedef struct SitePrefixEntry SitePrefixEntry;

extern void InitRouting(void);

extern void UnloadRouting(void);

//
// Structure of a route cache entry.
//
// A route cache entry (RCE) primarily caches two computations:
// next-hop determination and source address selection.
// An RCE also caches other information related to the destination,
// like path MTU.
//
// An RCE can also be created as a result of receiving an Redirect
// ICMP message.
//
// There is at most one RCE per destination address / interface pair.
// Our route cache corresponds to the destination cache
// mentioned in RFC 1970's conceptual data structures,
// with the addition of support for multi-homed nodes.
//
// The primary lookup key for RCEs is the destination address.
// The current implementation just searches a list of all RCEs,
// but a hash table or tree data structure would be preferable.
//
// Some nodes (like busy servers) might have many thousands of RCEs
// but only tens of NCEs, because most destinations are reached
// through only a few neighbor routers. Some nodes (like busy routers)
// will have relatively few RCEs and hundreds of NCEs, because
// forwarding does not use an RCE.
//
// The three major components of an RCE are the destination address,
// NTE (indicates both the interface, and the best source address
// on that interface to use for this destination), and NCE
// (neighbor to which to send packets for this destination).
//
// Once an RCE is created, these three components are read-only
// and anyone who holds a reference for the RCE can rely on
// them not changing. The RCE holds references for the NTE and NCE.
// This allows code that holds an RCE to access the important
// fields without acquiring any locks. Fields like the path MTU
// can also be safely read without a lock.
//
// When an RCE becomes invalid, it is removed from the route cache
// but it is not deallocated until it has zero references.
// The route cache itself holds one reference on RCEs in the cache.
//
// Because an RCE caches the result of two computations, RCEs can
// become invalid (stale) for two reasons: the preferred source
// address should be recomputed, or the next-hop neighbor should be
// recomputed.
//
// Source addresses need to be recomputed or checked when the NTEs
// on the RCE's interface change state - for example a new address
// is created, a preferred address becomes deprecated, etc.
// In practice, these should be relatively infrequent situations.
//
// Next-hop determination needs to be redone in several situations:
// a neighbor is not reachable, a neighbor stops being a router,
// a route in the routing table is removed or added, etc.
// Again, these should be relatively infrequent situations.
//
// To avoid undue time & memory overheads (for example maintaining
// a linked list of all RCEs that point to an NCE and a linked list
// of all RCEs on a given interface, so that the right RCEs can
// be immediately found when something changes), we use a "lazy" approach
// based on a validation counter.
//
// There is a single global validation counter and when any state
// changes that might potentially invalidate an RCE, this counter
// is incremented. Each RCE has a snapshot of the counter that
// can be quickly checked to validate the RCE.
//
// If the RCE is invalid, then it's contents (best source address,
// next hop neighbor) are recomputed. If they are still correct,
// then the RCE's validation counter snapshot is updated.
// Otherwise the RCE's contents are updated (if nobody is using the RCE)
// or a new RCE is created and the invalid RCE is removed from the cache.
// Because the important fields in an RCE are read-only,
// an RCE can only be updated in-place if it has no external references.
//
// For efficiency, some code may cache an RCE reference for a "long"
// time, for example in a connection control block. Before using
// the cached RCE, such code should check the invalidation counter
// to ensure that the RCE is still valid. The ValidateRCE function
// performs this check.
//
// Some RCEs are "constrained" (RCE_FLAG_CONSTRAINED). This means
// that they can only be found in RouteToDestination if the caller
// explicitly specifies an outgoing interface (RCE_FLAG_CONSTRAINED_IF)
// or scopeid (RCE_FLAG_CONSTRAINED_SCOPEID). Consider
// a multi-homed node which can reach a destination via two interfaces,
// one of which is preferred (has a longer-matching-prefix route)
// over the other. An RCE for reaching the destination via the non-preferred
// interface will be marked as "constrained", to prevent its use
// when RouteToDestination is called without a constraining NTEorIF.
//
// Because specifying an interface implicitly specifies a scopeid,
// RCEs with RCE_FLAG_CONSTRAINED_IF also have RCE_FLAG_CONSTRAINED_SCOPEID.
//
// For a given destination address, all or all but one RCE for that
// destination should be "constrained". Or put another way, at most one RCE
// should not be "constrained". Or put another way, a destination address
// sans scopeid can only have one preferred outgoing interface.
// For a destination address / scopeid pair, all or all but one RCE
// for that pair should be "interface constrained".
//
// The BCE field is non-NULL if this is a home address.
// It does not hold a reference (Binding Cache Entries are not refcounted)
// and it can only be non-NULL if the RCE is in the cache.
// Access to the BCE field requires the route cache lock.
//
struct RouteCacheEntry {
    RouteCacheEntry *Next;           // Next RCE in cache list.
    RouteCacheEntry *Prev;           // Previous entry in cache list.
    long RefCnt;
    ushort Flags;                    // Peculiarities about this entry.
    ushort Type;                     // See below.
    ulong Valid;                     // Validation counter value.
    IPv6Addr Destination;            // Where this route is to.
    struct NetTableEntry *NTE;       // Preferred source address/interface.
    NeighborCacheEntry *NCE;         // First-hop neighbor.
    uint LastError;                  // Time of last ICMP error (IPv6 ticks).
    uint PathMTU;                    // MTU of path to destination.
    uint PMTULastSet;                // Time of last PMTU reduction.
    BindingCacheEntry *BCE;          // If this is a home address.
};

//
// These flag bits indicate whether the IF or ScopeId arguments
// to FindOrCreateRoute affected the choice of RCE.
// NB: FindOrCreateRoute assumes that these are the only flag bits.
//
#define RCE_FLAG_CONSTRAINED_IF         0x1
#define RCE_FLAG_CONSTRAINED_SCOPEID    0x2
#define RCE_FLAG_CONSTRAINED            0x3

#define RCE_TYPE_COMPUTED 1
#define RCE_TYPE_REDIRECT 2

__inline void
AddRefRCE(RouteCacheEntry *RCE)
{
    InterlockedIncrement(&RCE->RefCnt);
}

extern ulong RouteCacheValidationCounter;

__inline void
InvalidateRouteCache(void)
{
    InterlockedIncrement((PLONG)&RouteCacheValidationCounter);
}

__inline void
InvalidateRCE(RouteCacheEntry *RCE)
{
    InterlockedDecrement((PLONG)&RCE->Valid);
}

//
// Structure of an entry in the route table.
//
// SitePrefixLength and PreferredLifetime
// are only used when generating a Prefix Information Option
// based on the route.
//
// If the route is published, then it does not disappear
// even when the lifetime goes to zero. It is still present
// for use in generating Router Advertisements.
// But it doesn't get used for routing.
// Similarly, system routes (RTE_TYPE_SYSTEM) are kept
// in the route table even when their lifetime is zero.
// This allows a loopback route to be allocated for an NTE/AAE
// up front, but not be enabled until the address is valid.
//
struct RouteTableEntry {
    struct RouteTableEntry *Next;  // Next entry on prefix list.
    Interface *IF;                 // Relevant interface.
    NeighborCacheEntry *NCE;       // Next-hop neighbor (may be NULL).
    IPv6Addr Prefix;               // Prefix (note not all bits are valid!).
    uint PrefixLength;             // Number of bits in above to use as prefix.
    uint SitePrefixLength;         // If non-zero, indicates a site subprefix.
    uint ValidLifetime;            // In ticks.
    uint PreferredLifetime;        // In ticks.
    uint Preference;               // Smaller is better.
    ushort Flags;
    ushort Type;
};

//
// The Type field indicates where the route came from.
// These are RFC 2465 ipv6RouteProtocol values.
// Routing protocols are free to define new values.
// Only these three values are built-in.
// ntddip6.h also defines these values, as well as others.
//
#define RTE_TYPE_SYSTEM         2
#define RTE_TYPE_MANUAL         3
#define RTE_TYPE_AUTOCONF       4

__inline int
IsValidRouteTableType(uint Type)
{
    return Type < (1 << 16);
}

//
// If the NCE is NULL, then the RTE specifies an on-link prefix.
// Otherwise the RTE specifies a route to the neighbor.
// As you would expect, generally the neighbor is on the interface.
// Loopback routes are an exception.
//
// The PUBLISH bit indicates that the RTE can be visible
// to RouterAdvertSend. That is, it is a "public" route.
// The IMMORTAL bit indicates that the RTE's lifetime
// does not age or countdown. It is useful in PUBLISHed RTEs,
// where the RTE's lifetime affects the lifetime in RAs.
// In non-PUBLISHed RTEs it is equivalent to an infinite lifetime.
//
#define RTE_FLAG_PUBLISH        0x00000001      // Used to create RAs.
#define RTE_FLAG_IMMORTAL       0x00000002      // Lifetime does not decrease.

//
// These values are also defined in ntddip6.h.
// Zero preference is reserved for administrative configuration.
// Smaller is more preferred than larger.
// We call these numbers preferences instead of metrics
// in an attempt to prevent confusion with the metrics
// employed by routing protocols. Routing protocol metrics
// need to be mapped into our routing table preferences.
// The largest preference value is 2^31-1, so that
// we can add a route preference and an interface preference
// without overflow.
//
#define ROUTE_PREF_LOW          (16*16*16)
#define ROUTE_PREF_MEDIUM       (16*16)
#define ROUTE_PREF_HIGH         16
#define ROUTE_PREF_ON_LINK      8
#define ROUTE_PREF_LOOPBACK     4
#define ROUTE_PREF_HIGHEST      0

//
// Extract a route preference value
// from the Flags field in a Router Advertisement.
//
__inline int
ExtractRoutePreference(uchar Flags)
{
    switch (Flags & 0x18) {
    case 0x08:
        return ROUTE_PREF_HIGH;
    case 0x00:
        return ROUTE_PREF_MEDIUM;
    case 0x18:
        return ROUTE_PREF_LOW;
    default:
        return 0;       // Invalid.
    }
}

//
// Encode a route preference value
// for use in a Flags field in a Router Advertisement.
//
__inline uchar
EncodeRoutePreference(uint Preference)
{
    if (Preference <= ROUTE_PREF_HIGH)
        return 0x08;
    else if (Preference <= ROUTE_PREF_MEDIUM)
        return 0x00;
    else
        return 0x18;
}

__inline int
IsValidPreference(uint Preference)
{
    return Preference < (1 << 31);
}

__inline int
IsOnLinkRTE(RouteTableEntry *RTE)
{
    return (RTE->NCE == NULL);
}


//
// Binding cache structure.  Holds references to care-of RCE's.
//
struct BindingCacheEntry {
    struct BindingCacheEntry *Next;
    struct BindingCacheEntry *Prev;
    RouteCacheEntry *CareOfRCE;
    IPv6Addr HomeAddr;
    uint BindingLifetime;            // Remaining lifetime (IPv6 ticks).
    ushort BindingSeqNumber;
};

//
// Site prefix entry.
// Used for filtering site-local addresses returned by DNS.
//
struct SitePrefixEntry {
    struct SitePrefixEntry *Next;
    Interface *IF;
    uint ValidLifetime;            // In ticks.
    uint SitePrefixLength;
    IPv6Addr Prefix;
};

//
// Global data structures.
//

//
// RouteCacheLock protects the route cache and the binding cache.
// RouteTableLock protects the route table and the site-prefix table.
//
// Lock acquisition order is:
//      RouteCacheLock before interface locks
//      interface locks before RouteTableLock
//      IoCancelSpinLock before RouteTableLock
//      RouteTableLock before neighbor cache locks
//
extern KSPIN_LOCK RouteCacheLock;
extern KSPIN_LOCK RouteTableLock;

//
// The Route Cache contains RCEs. RCEs with reference count of one
// can still be cached, but they may also be reclaimed.
// (The lone reference is from the cache itself.)
//
// The current implementation is a simple circular linked-list of RCEs.
//
extern struct RouteCache {
    uint Limit;
    uint Count;
    RouteCacheEntry *First;
    RouteCacheEntry *Last;
} RouteCache;
#define SentinelRCE     ((RouteCacheEntry *)&RouteCache.First)

extern struct RouteTable {
    RouteTableEntry *First;
    RouteTableEntry **Last;
} RouteTable;

extern struct BindingCache {
    uint Limit;
    uint Count;
    BindingCacheEntry *First;
    BindingCacheEntry *Last;
} BindingCache;
#define SentinelBCE     ((BindingCacheEntry *)&BindingCache.First)

extern SitePrefixEntry *SitePrefixTable;

//
// Set to TRUE when the routing table changes
// (for example adding/removing/changing published routes)
// so that it's a good idea to send Router Advertisements
// very promptly.
//
extern int ForceRouterAdvertisements;

//
// Contains a queue of IRPs that represent
// route notification requests.
//
extern LIST_ENTRY RouteNotifyQueue;

//
// Exported function declarations.
//

int
IsLoopbackRCE(RouteCacheEntry *RCE);

int
IsDisconnectedAndNotLoopbackRCE(RouteCacheEntry *RCE);

extern IPAddr
GetV4Destination(RouteCacheEntry *RCE);

uint
GetPathMTUFromRCE(RouteCacheEntry *RCE);

uint
GetEffectivePathMTUFromRCE(RouteCacheEntry *RCE);

void
ConfirmForwardReachability(RouteCacheEntry *RCE);

void
ForwardReachabilityInDoubt(RouteCacheEntry *RCE);

uint
GetInitialRTTFromRCE(RouteCacheEntry *RCE);


extern void
ReleaseRCE(RouteCacheEntry *RCE);

extern RouteCacheEntry *
ValidateRCE(RouteCacheEntry *RCE, NetTableEntry *NTE);

#define RTD_FLAG_STRICT 0       // Must use specified IF.
#define RTD_FLAG_NORMAL 1       // Must use specified IF unless it forwards.
#define RTD_FLAG_LOOSE  2       // Only use IF to determine/check ScopeId.

extern IP_STATUS
RouteToDestination(const IPv6Addr *Destination, uint ScopeId,
                   NetTableEntryOrInterface *NTEorIF, uint Flags,
                   RouteCacheEntry **RCE);

extern void
FlushRouteCache(Interface *IF, const IPv6Addr *Addr);

extern NetTableEntry *
FindNetworkWithAddress(const IPv6Addr *Source, uint ScopeId);

extern NTSTATUS
RouteTableUpdate(PFILE_OBJECT FileObject,
                 Interface *IF, NeighborCacheEntry *NCE,
                 const IPv6Addr *Prefix, uint PrefixLength,
                 uint SitePrefixLength,
                 uint ValidLifetime, uint PreferredLifetime,
                 uint Pref, uint Type, int Publish, int Immortal);

extern void
SitePrefixUpdate(Interface *IF,
                 const IPv6Addr *Prefix, uint SitePrefixLength,
                 uint ValidLifetime);

extern uint
SitePrefixMatch(const IPv6Addr *Destination);

extern void
RouteTableRemove(Interface *IF);

extern void
RouteTableResetAutoConfig(Interface *IF, uint MaxLifetime);

extern void
RouteTableReset(void);

extern IP_STATUS
FindOrCreateRoute(const IPv6Addr *Dest, uint ScopeId,
                  Interface *IF, RouteCacheEntry **ReturnRCE);

extern IP_STATUS
FindNextHop(Interface *IF, const IPv6Addr *Dest, uint ScopeId,
            NeighborCacheEntry **ReturnNCE, ushort *ReturnConstrained);

extern void
RouteTableTimeout(void);

extern void
SitePrefixTimeout(void);

extern void
InvalidateRouter(NeighborCacheEntry *NCE);

extern int
UpdatePathMTU(Interface *IF, const IPv6Addr *Dest, uint MTU);

extern IP_STATUS
RedirectRouteCache(const IPv6Addr *Source, const IPv6Addr *Dest,
                   Interface *IF, NeighborCacheEntry *NCE);

extern void
MoveToFrontBCE(BindingCacheEntry *BCE);

extern BindingCacheEntry *
FindBindingCacheEntry(const IPv6Addr *HomeAddr);

extern BindingUpdateDisposition
CacheBindingUpdate(IPv6BindingUpdateOption UNALIGNED *BindingUpdate,
                   const IPv6Addr *CareOfAddr,
                   NetTableEntryOrInterface *NTEorIF,
                   const IPv6Addr *HomeAddr);

extern void
BindingCacheTimeout(void);

extern void
RouterAdvertSend(Interface *IF, const IPv6Addr *Source, const IPv6Addr *Dest);

extern void
RemoveRTE(RouteTableEntry **PrevRTE, RouteTableEntry *RTE);

extern void
InsertRTEAtFront(RouteTableEntry *RTE);

extern void
InsertRTEAtBack(RouteTableEntry *RTE);

extern IP_STATUS
GetBestRouteInfo(const IPv6Addr *Addr, ulong ScopeId, IP6RouteEntry *Ire);

typedef struct {
    PIO_WORKITEM WorkItem;
    PIRP RequestList;
} CompleteRtChangeContext;

typedef struct {
    KIRQL OldIrql;
    PIRP RequestList;
    PIRP *LastRequest;
    CompleteRtChangeContext *Context;
} CheckRtChangeContext;

__inline void
InitCheckRtChangeContext(CheckRtChangeContext *Context)
{
    // Context->OldIrql must be initialized separately.
    Context->RequestList = NULL;
    Context->LastRequest = &Context->RequestList;
    Context->Context = NULL;
}

extern void
CheckRtChangeNotifyRequests(
    CheckRtChangeContext *Context,
    PFILE_OBJECT FileObject,
    RouteTableEntry *RTE);

extern void
CompleteRtChangeNotifyRequests(CheckRtChangeContext *Context);

#endif  // ROUTE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcpdeb.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmission Control Protocol debug code definitions.
//


#ifndef NO_TCP_DEFS
#if DBG

#ifndef UDP_ONLY
extern void CheckPacketList(IPv6Packet *Chain, uint Size);
extern void CheckTCBSends(TCB *SendTcb);
extern void CheckTCBRcv(TCB *RcvTCB);
#else
#define CheckPacketList(C, S)
#define CheckRBList(R, S)
#define CheckTCBSends(T)
#define CheckTCBRcv(T)
#endif  // UDP_ONLY

#else

#define CheckPacketList(C, S)
#define CheckRBList(R, S)
#define CheckTCBSends(T)
#define CheckTCBRcv(T)
#endif  // DBG
#endif  // NO_TCP_DEFS

//
// Additional debugging support for NT
//
#if DBG

extern ULONG TCPDebug;

#define TCP_DEBUG_OPEN           0x00000001
#define TCP_DEBUG_CLOSE          0x00000002
#define TCP_DEBUG_ASSOCIATE      0x00000004
#define TCP_DEBUG_CONNECT        0x00000008
#define TCP_DEBUG_SEND           0x00000010
#define TCP_DEBUG_RECEIVE        0x00000020
#define TCP_DEBUG_INFO           0x00000040
#define TCP_DEBUG_IRP            0x00000080
#define TCP_DEBUG_SEND_DGRAM     0x00000100
#define TCP_DEBUG_RECEIVE_DGRAM  0x00000200
#define TCP_DEBUG_EVENT_HANDLER  0x00000400
#define TCP_DEBUG_CLEANUP        0x00000800
#define TCP_DEBUG_CANCEL         0x00001000
#define TCP_DEBUG_RAW            0x00002000
#define TCP_DEBUG_OPTIONS        0x00004000
#define TCP_DEBUG_MSS            0x00008000

#define IF_TCPDBG(flag)  if (TCPDebug & flag)

#define CHECK_STRUCT(s, t) \
            ASSERTMSG("Structure assertion failure for type " #t, \
                      (s)->t##_sig == t##_signature)

#else // DBG

#define IF_TCPDBG(flag)   if (0)
#define CHECK_STRUCT(s, t)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcpconn.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP connection related definitions.
//
// This file contains the definitions for connection related structures,
// such as the TCPConnReq structure.
//


#define INVALID_CONN_INDEX 0xffffff

//
// Structure used for tracking Connect/Listen/Accept/Disconnect requests.
//
typedef struct TCPConnReq {
    struct TCPReq tcr_req;  // General request structure.
#if DBG
    ulong tcr_sig;
#endif
    struct _TDI_CONNECTION_INFORMATION *tcr_conninfo;  // Where to return info.
    struct _TDI_CONNECTION_INFORMATION *tcr_addrinfo;  // Where to return info.
    ushort tcr_flags;                                  // Request flags.
    ushort tcr_timeout;                                // Timeout value.
} TCPConnReq;
#define tcr_signature 0x20524354  // 'TCR '

//
// Structure used for tracking abortive-disconnect requests.
//
typedef struct TCPAbortReq {
    RequestCompleteRoutine  tar_rtn;      // Completion routine.
    void*                   tar_context;  // User context.
} TCPAbortReq;

#define MAX_CONN_PER_BLOCK 256

//
// Structure of a block of TCP connections.
//
typedef struct TCPConnBlock {
    KSPIN_LOCK cb_lock;
    uint cb_freecons;
    uint cb_nextfree;
    uint cb_blockid;
    uint cb_conninst;
    void *cb_conn[MAX_CONN_PER_BLOCK];
} TCPConnBlock;


//
// Prototype for TCPConn (see below) done handlers.
//
typedef void (*ConnDoneRtn)(struct TCPConn *, KIRQL);


//
// Structure of a TCP Connection.
// A TCP Connection points to a TCB and an address object.
//
typedef struct TCPConn {
#if DBG
    ulong tc_sig;
#endif
    Queue tc_q;                     // Linkage on AO.
    struct TCB *tc_tcb;             // Pointer to TCB for connection.
    struct AddrObj *tc_ao;          // Back pointer to AddrObj.
    uchar tc_inst;                  // Instance number.
    uchar tc_flags;                 // Flags for connection.
    ushort tc_refcnt;               // Count of TCBs which reference this conn.
    void *tc_context;               // User's context.
    RequestCompleteRoutine tc_rtn;  // Completion routine.
    PVOID tc_rtncontext;            // User context for completion routine.
    ConnDoneRtn tc_donertn;         // Routine to call when refcnt goes to 0.
    uint tc_tcbflags;               // Flags for TCB when it comes in.
    ulong tc_owningpid;             // Owning process id
    uint tc_tcbkatime;       // Initial keep alive time value for this conn.
    uint tc_tcbkainterval;   // Keep alive interval for this conn.
    uint tc_window;                 // Default window for TCB.
    TCPConnBlock *tc_ConnBlock;     // Containing block for this conn.
    uint tc_connid;                 // Cached dentifier for this conn.

} TCPConn;
#define tc_signature 0x20204354  // 'TC '

#define CONN_CLOSING 1  // Connection is closing.
#define CONN_DISACC  2  // Connection is disassociating.
#define CONN_WINSET  4  // Window explictly set.

#define CONN_INVALID (CONN_CLOSING | CONN_DISACC)

#define CONN_INDEX(c)       ((c) & 0xff)
#define CONN_BLOCKID(c)     (((c) & 0xffff00) >> 8)
#define CONN_INST(c)        ((uchar)((c) >> 24))
#define MAKE_CONN_ID(index,block,instance)  ((((uint)(instance)) << 24) | \
                                             (((uint)(block)) << 8) | \
                                             ((uint)(index)))
#define INVALID_CONN_ID     (ULONG)-1

extern TCPConnBlock **ConnTable;


typedef struct TCPAddrCheck {
    IPv6Addr SourceAddress;
    uint TickCount;
} TCPAddrCheckElement;


//
// External definitions for TDI entry points.
//
extern TDI_STATUS TdiOpenConnection(PTDI_REQUEST Request, PVOID Context);
extern TDI_STATUS TdiCloseConnection(PTDI_REQUEST Request);
extern TDI_STATUS TdiAssociateAddress(PTDI_REQUEST Request, HANDLE AddrHandle);
extern TDI_STATUS TdiDisAssociateAddress(PTDI_REQUEST Request);
extern TDI_STATUS TdiConnect(PTDI_REQUEST Request, void *Timeout,
                             PTDI_CONNECTION_INFORMATION RequestAddr,
                             PTDI_CONNECTION_INFORMATION ReturnAddr);
extern TDI_STATUS TdiListen(PTDI_REQUEST Request, ushort Flags,
                            PTDI_CONNECTION_INFORMATION AcceptableAddr,
                            PTDI_CONNECTION_INFORMATION ConnectedAddr);
extern TDI_STATUS TdiAccept(PTDI_REQUEST Request,
                            PTDI_CONNECTION_INFORMATION AcceptInfo,
                            PTDI_CONNECTION_INFORMATION ConnectedInfo);
extern TDI_STATUS TdiDisconnect(PTDI_REQUEST Request, void *TO, ushort Flags,
                                PTDI_CONNECTION_INFORMATION DiscConnInfo,
                                PTDI_CONNECTION_INFORMATION ReturnInfo,
                                TCPAbortReq *AbortReq);

extern struct TCPConnReq *GetConnReq(void);
extern void FreeConnReq(struct TCPConnReq *FreedReq);
extern void DerefTCB(struct TCB *DoneTCB, KIRQL Irql);
extern void InitRCE(struct TCB *NewTCB);
extern void AcceptConn(struct TCB *AcceptTCB, KIRQL Irql);
extern void FreeConnID(TCPConn *Conn);
extern void NotifyOfDisc(struct TCB *DiscTCB, TDI_STATUS Status,
                         PKIRQL IrqlPtr);
extern TCPConn *GetConnFromConnID(uint ConnID, KIRQL* Irql);
extern void TryToCloseTCB(struct TCB *ClosedTCB, uchar Reason, KIRQL Irql);
extern TDI_STATUS InitTCBFromConn(struct TCPConn *Conn, struct TCB *NewTCB,
                                  PTDI_CONNECTION_INFORMATION Addr,
                                  uint AOLocked);

extern void PushData(struct TCB *PushTCB);
extern TDI_STATUS MapIPError(IP_STATUS IPError, TDI_STATUS Default);
extern void GracefulClose(struct TCB *CloseTCB, uint ToTimeWait, uint Notify,
                          KIRQL Irql);
extern void RemoveTCBFromConn(struct TCB *RemovedTCB);
extern void InitAddrChecks();
extern int ConnCheckPassed(IPv6Addr *Src, ulong Prt);
extern void EnumerateConnectionList(uchar *Buffer, ulong BufferSize,
                         ulong *EntriesReturned, ulong *EntriesAvailable);

extern void GetRandomISN(SeqNum *Seq, uchar *TcbInvariants);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tdint.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file defines TDI types specific to the NT environment.
//


#ifndef _TDINT_
#define _TDINT_

#include <tdikrnl.h>

//
// Just some handy typedefs for things defined in tdikrnl.h.
// Note that some more events have been defined in tdikrnl.h
// since this was originally written.
//
typedef PTDI_IND_CONNECT     PConnectEvent;
typedef PTDI_IND_DISCONNECT  PDisconnectEvent;
typedef PTDI_IND_ERROR       PErrorEvent;
typedef PTDI_IND_RECEIVE     PRcvEvent;
typedef PTDI_IND_RECEIVE_DATAGRAM  PRcvDGEvent;
typedef PTDI_IND_RECEIVE_EXPEDITED PRcvExpEvent;

typedef IRP EventRcvBuffer;
typedef IRP ConnectEventInfo;

#endif  // ifndef _TDINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcpdeliv.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmission Control Protocol data delivery code definitions.
//


extern void FreeRcvReq(struct TCPRcvReq *FreedReq);

extern uint IndicateData(struct TCB *RcvTCB, uint RcvFlags,
                         IPv6Packet *InPacket, uint Size);
extern uint BufferData(struct TCB *RcvTCB, uint RcvFlags,
                       IPv6Packet *InPacket, uint Size);
extern uint PendData(struct TCB *RcvTCB, uint RcvFlags, IPv6Packet *InPacket,
                     uint Size);

extern void IndicatePendingData(struct TCB *RcvTCB, struct TCPRcvReq *RcvReq,
                                KIRQL Irql);

extern void HandleUrgent(struct TCB *RcvTCB, struct TCPRcvInfo *RcvInfo,
                         IPv6Packet *Packet, uint *Size);

extern TDI_STATUS TdiReceive(PTDI_REQUEST Request, ushort *Flags,
                             uint *RcvLength, PNDIS_BUFFER Buffer);

extern void PushData(struct TCB *PushTCB);

extern KSPIN_LOCK TCPRcvReqFreeLock;  // Protects rcv req free list.

extern SLIST_HEADER TCPRcvReqFree;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\transprt.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains definitions for common transport layer items.
//


#define TCP_TA_SIZE (FIELD_OFFSET(TRANSPORT_ADDRESS, Address->Address)+ \
                     sizeof(TDI_ADDRESS_IP6))

#define NdisBufferLength(Buffer) MmGetMdlByteCount(Buffer)
#define NdisBufferVirtualAddress(Buffer) MmGetSystemAddressForMdl(Buffer)


//
// Request completion routine definition.
//
typedef void (*RequestCompleteRoutine)(void *, unsigned int, unsigned int);


//
// Function prototypes.
//

extern TDI_STATUS
UpdateConnInfo(PTDI_CONNECTION_INFORMATION ConnInfo, IPv6Addr *SrcAddress,
               ulong ScopeID, ushort SrcPort);

extern void
BuildTDIAddress(uchar *Buffer, IPv6Addr *Addr, ulong ScopeID, ushort Port);

extern unsigned long
SystemUpTime(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcp.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmission Control Protocol definitions.
//


#ifndef _TCP_INCLUDED_
#define _TCP_INCLUDED_

#define IP_PROTOCOL_TCP 6
#define DEFAULT_MSS (IPv6_MINIMUM_MTU - sizeof(IPv6Header) - sizeof(TCPHeader))

// Timer stuff. We keep timers as ticks.
#define MS_PER_TICK 100
#define MS_TO_TICKS(m) ((m) / MS_PER_TICK)
#define MIN_RETRAN_TICKS 3

#define DEL_ACK_TICKS 2

// Define MAX_REXMIT_TO to be number of ticks in 2MSL (=240 seconds)
#define MAX_REXMIT_TO ((ushort)FinWait2TO)

#define SWS_TO MS_TO_TICKS(5000)

#define FIN_WAIT2_TO 240
#define PUSH_TO MS_TO_TICKS(500)

#define TCP_MD5_DATA_LENGTH  44

typedef ulong TCP_TIME;
#define MAX_CONN_TO_TICKS 0xffff
#define INFINITE_CONN_TO(t) ((t) == 0)
#define TCP_TIME_TO_TICKS(t) (((t)/MS_PER_TICK)+1)


// Sequence numbers are kept as signed 32 bit quantities, with macros
// defined to do wraparound comparisons on them.

typedef int SeqNum;  // A sequence number.

//* Macros for comparions on sequence numbers.

#define SEQ_GT(a, b) (((a) - (b)) > 0)
#define SEQ_GTE(a, b) (((a) - (b)) >= 0)
#define SEQ_LT(a, b) (((a) - (b)) < 0)
#define SEQ_LTE(a, b) (((a) - (b)) <= 0)
#define SEQ_EQ(a, b) ((a) == (b))

// The TCB - transport control block structure. This is the
// structure that contains all of the state for the transport
// connection, including sequence numbers, flow control information,
// pending sends and receives, etc.

#define tcb_signature 0x20424354 // 'TCB '

typedef struct TCB {
    struct TCB *tcb_next;  // Next pointer in TCB table.
#if DBG
    ulong tcb_sig;       // Debug signature.
#endif
    KSPIN_LOCK tcb_lock;

    // Send sequence variables.
    SeqNum tcb_senduna;              // Sequence number of first unack'd data.
    SeqNum tcb_sendnext;             // Sequence number of next byte to send.
    SeqNum tcb_sendmax;              // Max value of sendnext this epoch.
    uint tcb_sendwin;                // Send window.
    uint tcb_unacked;                // Total number of bytes of unacked data.
    uint tcb_maxwin;                 // Max send window seen.
    uint tcb_cwin;                   // Congestion window.
    uint tcb_ssthresh;               // Slow start threshold.
    struct TCPSendReq *tcb_cursend;  // Current send in use.
    PNDIS_BUFFER tcb_sendbuf;        // Current buffer chain being sent.
    uint tcb_sendofs;                // Offset into start of chain.
    uint tcb_sendsize;               // Number of bytes unsent in current send.
    Queue tcb_sendq;                 // Queue of send requests.

    // Receive sequence variables.
    SeqNum tcb_rcvnext;            // Next byte we expect to receive.
    int tcb_rcvwin;                // Receive window we're offering.
    SeqNum tcb_rcvwinwatch;        // Monitors peer's use of our rcv window.
    SeqNum tcb_sendwl1;            // Window update sequence number.
    SeqNum tcb_sendwl2;            // Window update ack number.
    struct TCPRcvReq *tcb_currcv;  // Current receive buffer.
    uint tcb_indicated;            // Bytes of data indicated.
    uint tcb_flags;                // Flags for this TCB.
    uint tcb_fastchk;              // Fast receive path check field.
    uint (*tcb_rcvhndlr)(struct TCB *, uint, IPv6Packet *, uint Size);

    // Addressing info.
    // NOTE: Do not make the [next 6] invariants non-consecutive. That would 
    // break the MD5 computation.
    union {
        struct {
            // Addressing info.
            IPv6Addr tcb_daddr;   // Destination (i.e. peer's) IP address.
            IPv6Addr tcb_saddr;   // Source (i.e. our) IP address.
            ulong tcb_dscope_id;  // Scope id of dest addr (0 if non-scoped).
            ulong tcb_sscope_id;  // Scope id of source addr (0 if non-scoped).
            ushort tcb_dport;     // Destination port.
            ushort tcb_sport;     // Source port.
        };
        uchar tcb_md5data[TCP_MD5_DATA_LENGTH];
    };

    int tcb_hops;         // Hop limit.

    uint tcb_refcnt;    // Reference count for TCB.
    SeqNum tcb_rttseq;  // Sequence number being measured for Round Trip Time.

    // Retransmit timer information. These are stored as ticks, where by
    // default each tick is 100ms.
    ushort tcb_smrtt;  // Smoothed rtt value.
    ushort tcb_delta;  // Delta value.

    ushort tcb_rexmit;    // Retransmit value.
    uchar tcb_slowcount;  // Count of reasons why we're on the slow path.
    uchar tcb_pushtimer;  // The 'push' timer.
    ushort tcb_mss;       // Maximum Segment Size for this connection.
    ushort tcb_remmss;    // MSS advertised by peer.

    // State information.
    uchar tcb_state;      // State of this TCB.
    uchar tcb_rexmitcnt;  // Count of rexmits on this TCB.
    uchar tcb_pending;    // Pending actions on this TCB.
    uchar tcb_kacount;    // Count of keep alive probes sent.
    IP_STATUS tcb_error;  // Last error we heard about from IP.

    uint tcb_rtt;  // Current round trip time TS.

    ushort tcb_rexmittimer;  // Timer for rexmit.
    ushort tcb_delacktimer;  // Timer for delayed ack.

    uint tcb_defaultwin;  // Default rcv. window.
    uint tcb_alive;       // Keep alive time value.

    struct TCPRAHdr *tcb_raq;       // Reassembly queue.
    struct TCPRcvReq *tcb_rcvhead;  // Head of recv. buffer queue.
    struct TCPRcvReq *tcb_rcvtail;  // Tail of recv. buffer queue.
    uint tcb_pendingcnt;            // Bytes waiting to be received.
    IPv6Packet *tcb_pendhead;  // Head of pending receive queue.
    IPv6Packet *tcb_pendtail;  // Tail of pending receive queue.

    struct TCPConnReq *tcb_connreq; // Connection request for this connection.
    void *tcb_conncontext;          // Connection context for this connection.

    uint tcb_bcountlow;        // Low part of byte count.
    uint tcb_bcounthi;         // High part of bytecount.
    uint tcb_totaltime;        // Total number of ticks spent sending.
    struct TCPConn *tcb_conn;  // Back pointer to conn for TCB.
    Queue tcb_delayq;          // Queue linkage for delay queue.
    uchar tcb_closereason;     // Reason we're closing.
    uchar tcb_bhprobecnt;      // BH probe count.
    ushort tcb_swstimer;       // Timer for SWS override.
    void *tcb_rcvind;          // Receive indication handler.
    union {
        void *tcb_ricontext;   // Receive indication context.
        struct TCB *tcb_aonext;// Next pointer on AddrObj.
    };

    // Miscellaneous info, for IP.
    ulong tcb_routing;                // So we know when routing state changes.
    NetTableEntry *tcb_nte;           // NTE corresponding to our src address.
    RouteCacheEntry *tcb_rce;         // RCE for this connection.
    uint tcb_pmtu;                    // So we know when RCE's PTMU changes.
    ulong tcb_security;               // So we know when IPsec changes.
    struct TCPConnReq *tcb_discwait;  // Disc-Wait req., if there is one.
    struct TCPAbortReq* tcb_abortreq; // Abort req., if there is one.
    struct TCPRcvReq *tcb_exprcv;     // Head of expedited recv. buffer queue.
    IPv6Packet *tcb_urgpending;       // Urgent data queue.
    uint tcb_urgcnt;                  // Byte count of data on urgent q.
    uint tcb_urgind;                  // Urgent bytes indicated.
    SeqNum tcb_urgstart;              // Start of urgent data.
    SeqNum tcb_urgend;                // End of urgent data.
    uint tcb_walkcount;               // Number of people 'walking' this TCB.
    uint tcb_connid;                  // Cached identifier for this TCB's Conn.
    ushort tcb_dupacks;               // Number of duplicate acks seen.
    ushort tcb_force;                 // Force send.
} TCB;

//
// Definitions for TCP states.
//
#define TCB_CLOSED     0   // Closed.
#define TCB_LISTEN     1   // Listening.
#define TCB_SYN_SENT   2   // SYN Sent.
#define TCB_SYN_RCVD   3   // SYN received.
#define TCB_ESTAB      4   // Established.
#define TCB_FIN_WAIT1  5   // FIN-WAIT-1
#define TCB_FIN_WAIT2  6   // FIN-WAIT-2
#define TCB_CLOSE_WAIT 7   // Close waiting.
#define TCB_CLOSING    8   // Closing state.
#define TCB_LAST_ACK   9   // Last ack state.
#define TCB_TIME_WAIT  10  // Time wait state.

#define SYNC_STATE(s) ((s) > TCB_SYN_RCVD)
#define GRACEFUL_CLOSED_STATE(s) ((s) >= TCB_LAST_ACK)
#define DATA_RCV_STATE(s) ((s) >= TCB_ESTAB && (s) <= TCB_FIN_WAIT2)
#define DATA_SEND_STATE(s) ((s) == TCB_ESTAB || (s) == TCB_CLOSE_WAIT)

//
// Definitions for TCB flags.
//
#define WINDOW_SET      0x00000001  // Window explictly set.
#define CLIENT_OPTIONS  0x00000002  // Have client IP options on conn.
#define CONN_ACCEPTED   0x00000004  // Connection was accepted.
#define ACTIVE_OPEN     0x00000008  // Connection came from an active open.
#define DISC_NOTIFIED   0x00000010  // Client's been notified of a disconnect.
#define IN_DELAY_Q      0x00000020  // We're in the delayed action Q.
#define RCV_CMPLTING    0x00000040  // We're completeing rcvs.
#define IN_RCV_IND      0x00000080  // We're calling a rcv. indicate handler.
#define NEED_RCV_CMPLT  0x00000100  // We need to have recvs. completed.
#define NEED_ACK        0x00000200  // We need to send an ACK.
#define NEED_OUTPUT     0x00000400  // We need to output.

#define DELAYED_FLAGS (NEED_RCV_CMPLT | NEED_ACK | NEED_OUTPUT)

#define ACK_DELAYED     0x00000800  // We've delayed sending an ACK.
#define PMTU_BH_PROBE   0x00001000  // We're probing for a PMTU BH.
#define BSD_URGENT      0x00002000  // We're using BSD urgent semantics.
#define IN_DELIV_URG    0x00004000  // We're in the DeliverUrgent routine.
#define URG_VALID       0x00008000  // Seen urgent data, and fields are valid.
#define FIN_NEEDED      0x00010000  // We need to send a FIN.
#define NAGLING         0x00020000  // We are using Nagle's algorithm.
#define IN_TCP_SEND     0x00040000  // We're in TCPSend.
#define FLOW_CNTLD      0x00080000  // We've received a zero window from peer.
#define DISC_PENDING    0x00100000  // A disconnect notification is pending.
#define TW_PENDING      0x00200000  // Waiting to finish going to TIME-WAIT.
#define FORCE_OUTPUT    0x00400000  // Output is being forced.
#define FORCE_OUT_SHIFT 22 // Shift to get FORCE_OUTPUT into low bit.
#define SEND_AFTER_RCV  0x00800000  // Need to send after we get out of recv.
#define GC_PENDING      0x01000000  // A graceful close is pending.
#define KEEPALIVE       0x02000000  // Doing keepalives on this TCB.
#define URG_INLINE      0x04000000  // Urgent data to be processed inline.
#define ACCEPT_PENDING  0x08000000  // Sent SYN-ACK before indicating to ULP.

#define FIN_OUTSTANDING 0x10000000  // We've sent a FIN 'recently', i.e.
                                    // since the last retransmit.  When
                                    // this flag is set sendnext ==  sendmax.
#define FIN_OUTS_SHIFT  28  // Shift to FIN_OUTSTANDING bit into low bit.
#define FIN_SENT        0x20000000  // We've sent a FIN that hasn't been ack'd.
                                    // Once this bit has been turned on in
                                    // FIN-WAIT-1 the sequence number of the
                                    // FIN will be sendmax-1.
#define NEED_RST        0x40000000  // We need to send a RST when closing.
#define IN_TCB_TABLE    0x80000000  // TCB is in the TCB table.

//
// The defintion of the 'slow flags'.
// If any of these flags are set we'll be forced off of the fast path.
#define TCP_SLOW_FLAGS (URG_VALID | FLOW_CNTLD | GC_PENDING | TW_PENDING | \
                        DISC_NOTIFIED | IN_DELIV_URG | FIN_NEEDED | \
                        FIN_SENT | FIN_OUTSTANDING | DISC_PENDING | \
                        PMTU_BH_PROBE)

//
// Close reasons.
//
#define TCB_CLOSE_RST     0x80  // Received a RST segment.
#define TCB_CLOSE_ABORTED 0x40  // Had a local abort.
#define TCB_CLOSE_TIMEOUT 0x20  // Connection timed out.
#define TCB_CLOSE_REFUSED 0x10  // Connect attempt was refused.
#define TCB_CLOSE_UNREACH 0x08  // Remote destination unreachable.
#define TCB_CLOSE_SUCCESS 0x01  // Successfull close.

//
// TCB Timer macros.
//
#define START_TCB_TIMER(t, v) (t) = (v)
#define STOP_TCB_TIMER(t) (t) = 0
#define TCB_TIMER_RUNNING(t) ((t) != 0)

// Macro to compute retransmit timeout.
#define REXMIT_TO(t) ((((t)->tcb_smrtt >> 2) + (t)->tcb_delta) >> 1)

//
// Definitons for pending actions.  We define a PENDING_ACTION macro that can
// be used to decide whether or not we can proceed with an activity.  The only
// pending action we really care about is DELETE - others are low priority and
// can be put off.
//
#define PENDING_ACTION(t) ((t)->tcb_pending & DEL_PENDING)
#define DEL_PENDING 0x01    // Delete is pending.
#define OPT_PENDING 0x02    // Option set is pending.
#define RST_PENDING 0x08    // RST-indication is pending.

// Macro to see if a TCB is closing.
#define CLOSING(t) ((t)->tcb_pending & DEL_PENDING)

//
// Structure of a TCP packet header.
//
typedef struct TCPHeader {
    ushort tcp_src;     // Source port.
    ushort tcp_dest;    // Destination port.
    SeqNum tcp_seq;     // Sequence number.
    SeqNum tcp_ack;     // Ack number.
    ushort tcp_flags;   // Flags and data offset.
    ushort tcp_window;  // Window offered.
    ushort tcp_xsum;    // Checksum.
    ushort tcp_urgent;  // Urgent pointer.
} TCPHeader;

//
// Definitions for TCP header flags.
//
#define TCP_FLAG_FIN  0x00000100
#define TCP_FLAG_SYN  0x00000200
#define TCP_FLAG_RST  0x00000400
#define TCP_FLAG_PUSH 0x00000800
#define TCP_FLAG_ACK  0x00001000
#define TCP_FLAG_URG  0x00002000

#define TCP_FLAGS_ALL (TCP_FLAG_FIN | TCP_FLAG_SYN | TCP_FLAG_RST | \
                       TCP_FLAG_ACK | TCP_FLAG_URG)

//
// Flags in the tcb_fastchk field that are not in the TCP header proper.
// Setting these flags forces us off the fast path.
//
#define TCP_FLAG_SLOW   0x00000001   // Need to be on slow path.
#define TCP_FLAG_IN_RCV 0x00000002   // In recv. path already.

#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)

#define MAKE_TCP_FLAGS(o, f) ((f) | ((o) << 4))

//
// TCP Option Identifiers.
//
#define TCP_OPT_EOL  0
#define TCP_OPT_NOP  1
#define TCP_OPT_MSS  2
#define MSS_OPT_SIZE 4

//
// Convenient byte swapped structure for receives.
//
typedef struct TCPRcvInfo {
    SeqNum tri_seq;   // Sequence number.
    SeqNum tri_ack;   // Ack number.
    uint tri_window;  // Window.
    uint tri_urgent;  // Urgent pointer.
    uint tri_flags;   // Flags.
} TCPRcvInfo;


//
// General structure, at the start of all command specific request structures.
//
#define tr_signature 0x20205254  // 'TR  '

typedef struct TCPReq {
    struct Queue tr_q;              // Q linkage.
#if DBG
    ulong tr_sig;
#endif
    RequestCompleteRoutine tr_rtn;  // Completion routine.
    PVOID tr_context;               // User context.
    int tr_status;                  // Final complete status.
} TCPReq;



#define TCP6_TAG    '6PCT'

#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, TCP6_TAG)

#endif // POOL_TAGGING

//
// TCP endpoint context structure allocated for each open of TCP/UDP.
// A pointer to this structure is stored in FileObject->FsContext.
//
typedef struct _TCP_CONTEXT {
    union {
        HANDLE AddressHandle;
        CONNECTION_CONTEXT ConnectionContext;
        HANDLE ControlChannel;
    } Handle;
    ULONG ReferenceCount;
    BOOLEAN CancelIrps;
    KSPIN_LOCK EndpointLock;
#if DBG
    LIST_ENTRY PendingIrpList;
    LIST_ENTRY CancelledIrpList;
#endif
    KEVENT CleanupEvent;
} TCP_CONTEXT, *PTCP_CONTEXT;


#include "tcpdeb.h"

#endif // _TCP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcpcfg.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmission Control Protocol configuration information.
//


#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE 1
#endif


//
// TCP global configuration variables.
//
extern uint AllowUserRawAccess;
extern uint PMTUDiscovery;
extern uint PMTUBHDetect;
extern uint ISNStoreSize;
extern uint KeepAliveTime;
extern uint KAInterval;
extern uint DefaultRcvWin;
extern uint MaxConnections;
extern uint MaxConnBlocks;
extern uint TcbTableSize;
extern uint MaxConnectRexmitCount;
extern uint MaxDataRexmitCount;
extern uint BSDUrgent;
extern uint PreloadCount;
extern uint FinWait2TO;
extern uint NTWMaxConnectCount;
extern uint NTWMaxConnectTime;
extern uint MaxUserPort;
extern uint SynAttackProtect;


//
// Default values for many of the above globals.
//
#define DEFAULT_DEAD_GW_DETECT TRUE
#define DEFAULT_PMTU_DISCOVERY TRUE
#define DEFAULT_PMTU_BHDETECT FALSE
#define DEFAULT_KA_TIME 7200000
#define DEFAULT_KA_INTERVAL 1000
#define DEFAULT_RCV_WIN (8192 * 2)
#define DEFAULT_MAX_CONNECTIONS (INVALID_CONN_INDEX - 1)
#define DEFAULT_MAX_CONN_BLOCKS_WS_SMALL 16
#define DEFAULT_MAX_CONN_BLOCKS_WS_MEDIUM 32
#define DEFAULT_MAX_CONN_BLOCKS_WS_LARGE 128
#define DEFAULT_MAX_CONN_BLOCKS_AS_SMALL 128
#define DEFAULT_MAX_CONN_BLOCKS_AS_MEDIUM 256
#define DEFAULT_MAX_CONN_BLOCKS_AS_LARGE 1024
#define DEFAULT_MAX_CONN_BLOCKS_AS_LARGE64 4096
#define DEFAULT_CONNECT_REXMIT_CNT 3
#define DEFAULT_DATA_REXMIT_CNT 5
#define DEFAULT_BSD_URGENT TRUE
#define DEFAULT_PRELOAD_COUNT 0
#define MAX_PRELOAD_COUNT 32
#define PRELOAD_BLOCK_SIZE 16384
#define NTW_MAX_CONNECT_COUNT 15
#define NTW_MAX_CONNECT_TIME 600
#define DEFAULT_TCB_TABLE_SIZE (128 * KeNumberProcessors * KeNumberProcessors)
#define MIN_TCB_TABLE_SIZE 64
#define MAX_TCB_TABLE_SIZE 0x10000
#define DEFAULT_AO_TABLE_SIZE_WS 31
#define DEFAULT_AO_TABLE_SIZE_AS 257
#define DEFAULT_AO_TABLE_SIZE_AS64 1021
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\tcpsend.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP send definitions.
//


#define NUM_TCP_HEADERS 32
#define NUM_TCP_BUFFERS 150
#define TCP_MAX_HDRS 0xffffffff

//#define SEND_DEBUG 1

#ifdef SEND_DEBUG
#define SEND_TICKS 10
extern KSPIN_LOCK SendUseLock;
extern struct TCPSendReq *SendUseList;
#endif

//
// Structure of a TCP send request.
//
#define tsr_signature 0x20525354  // 'TSR '

typedef struct TCPSendReq {
    struct TCPReq tsr_req;  // General request structure.
#if DBG
    ulong tsr_sig;
#endif
    uint tsr_size;               // Size in bytes of data in send.
    long tsr_refcnt;             // Reference count for this send.
    uchar tsr_flags;             // Flags for this send.
    uchar tsr_pad[3];            // Pad to dword boundary.
    uint tsr_unasize;            // Number of bytes unacked.
    uint tsr_offset;             // Offset into first buffer in chain
                                 // of start of unacked data..
    PNDIS_BUFFER tsr_buffer;     // Pointer to start of unacked buffer chain.
    PNDIS_BUFFER tsr_lastbuf;    // Pointer to last buffer in chain.
                                 // Valid iff we've sent directly from the
                                 // buffer chain w/o doing an NdisCopyBuffer.
    uint tsr_time;               // TCP time this was received.
#ifdef SEND_DEBUG
    struct TCPSendReq *tsr_next; // Debug next field.
    uint tsr_timer;              // Timer field.
    uint tsr_cmplt;              // Who completed it.
#endif
} TCPSendReq;

#define TSR_FLAG_URG 0x01  // Urgent data.

//
// Structure defining the context received during a send completes.
//
#define scc_signature 0x20434353  // 'SCC '

typedef struct SendCmpltContext {
#if DBG
    ulong scc_sig;
#endif
    TCPSendReq *scc_firstsend;  // First send in this context.
    uint scc_count;             // Number of sends in count.
    ushort scc_ubufcount;       // Number of 'user' buffers in send.
    ushort scc_tbufcount;       // Number of transport buffers in send.
} SendCmpltContext;

extern KSPIN_LOCK TCPSendReqCompleteLock;

extern void InitSendState(struct TCB *NewTCB);
extern void SendSYN(struct TCB *SYNTcb, KIRQL);
extern void SendKA(struct TCB *KATCB, KIRQL Irql);
extern void SendRSTFromHeader(struct TCPHeader UNALIGNED *TCP, uint Length,
                              IPv6Addr *Dest, uint DestScopeId,
                              IPv6Addr *Src, uint SrcScopeId);
extern void SendACK(struct TCB *ACKTcb);
extern void SendRSTFromTCB(struct TCB *RSTTcb);
extern void GoToEstab(struct TCB *EstabTCB);
extern void FreeSendReq(TCPSendReq *FreedReq);
extern void FreeTCPHeader(PNDIS_BUFFER FreedBuffer);

extern int InitTCPSend(void);
extern void UnloadTCPSend(void);

extern void TCPSend(struct TCB *SendTCB, KIRQL Irql);

extern TDI_STATUS TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
                          PNDIS_BUFFER SendBuffer);
extern uint RcvWin(struct TCB *WinTCB);

extern void ResetAndFastSend(TCB *SeqTCB, SeqNum NewSeq, uint NewCWin);
extern void TCPFastSend(TCB *SendTCB, PNDIS_BUFFER in_SendBuf, uint SendOfs,
                        TCPSendReq *CurSend, uint SendSize, SeqNum SendNext,
                        int in_ToBeSent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\lan.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// LAN driver definitions.
//


#ifndef LAN_INCLUDED
#define LAN_INCLUDED 1

#define INTERFACE_UP    0                   // Interface is up.
#define INTERFACE_INIT  1                   // Interface is initializing.
#define INTERFACE_DOWN  2                   // Interface is down.

#define MEDIA_CHECK_IDLE        0           // Not checking media connectivity.
#define MEDIA_CHECK_QUERY       1           // Media check in progress.
#define MEDIA_CHECK_CONFLICT    2           // Race occurred, must requery.

#define LOOKAHEAD_SIZE  128                 // A reasonable lookahead size.

#define IEEE_802_ADDR_LENGTH 6              // Length of an IEEE 802 address.


//
// Structure of an Ethernet header.
//
typedef struct EtherHeader {
    uchar eh_daddr[IEEE_802_ADDR_LENGTH];
    uchar eh_saddr[IEEE_802_ADDR_LENGTH];
    ushort eh_type;
} EtherHeader;

//
// Structure of a token ring header.
//
typedef struct TRHeader {
    uchar tr_ac;
    uchar tr_fc;
    uchar tr_daddr[IEEE_802_ADDR_LENGTH];
    uchar tr_saddr[IEEE_802_ADDR_LENGTH];
} TRHeader;
#define ARP_AC 0x10
#define ARP_FC 0x40
#define TR_RII 0x80

typedef struct RC {
    uchar rc_blen;  // Broadcast indicator and length.
    uchar rc_dlf;   // Direction and largest frame.
} RC;
#define RC_DIR      0x80
#define RC_LENMASK  0x1f
#define RC_SRBCST   0xc2  // Single route broadcast RC.
#define RC_BCST_LEN 0x70  // Length for a broadcast.
#define RC_LF_MASK  0x70  // Mask for length bits.

// Structure of source routing information.
typedef struct SRInfo {
    RC sri_rc;         // Routing control info.
    ushort sri_rd[1];  // Routing designators.
} SRInfo;
#define MAX_RD 8

//
// Structure of an FDDI header.
//
typedef struct FDDIHeader {
    uchar fh_pri;
    uchar fh_daddr[IEEE_802_ADDR_LENGTH];
    uchar fh_saddr[IEEE_802_ADDR_LENGTH];
} FDDIHeader;
#define FDDI_PRI 0x57
#define FDDI_MSS 4352

//
// Structure of a SNAP header.
//
typedef struct SNAPHeader {
    uchar sh_dsap;
    uchar sh_ssap;
    uchar sh_ctl;
    uchar sh_protid[3];
    ushort sh_etype;
} SNAPHeader;
#define SNAP_SAP 170
#define SNAP_UI 3

#define MAX_MEDIA_ETHER sizeof(EtherHeader)
#define MAX_MEDIA_TR (sizeof(TRHeader)+sizeof(RC)+(MAX_RD*sizeof(ushort))+sizeof(SNAPHeader))
#define MAX_MEDIA_FDDI (sizeof(FDDIHeader)+sizeof(SNAPHeader))

#define ETHER_BCAST_MASK 0x01
#define TR_BCAST_MASK    0x80
#define FDDI_BCAST_MASK  0x01

#define ETHER_BCAST_VAL 0x01
#define TR_BCAST_VAL    0x80
#define FDDI_BCAST_VAL  0x01

#define ETHER_BCAST_OFF 0x00
#define TR_BCAST_OFF FIELD_OFFSET(struct TRHeader, tr_daddr)
#define FDDI_BCAST_OFF FIELD_OFFSET(struct FDDIHeader, fh_daddr)


//
// Lan driver specific information we keep on a per-interface basis.
//
typedef struct LanInterface {
    void *ai_context;                     // Upper layer context info.
    NDIS_HANDLE ai_handle;                // NDIS binding handle.
    NDIS_HANDLE ai_unbind;                // NDIS unbinding handle.
    KSPIN_LOCK ai_lock;                   // Lock for this structure.
    PNDIS_PACKET ai_tdpacket;             // Transfer Data packet.
    uchar ai_state;                       // State of the interface.
    uchar ai_media_check;                 // Used to query media connectivity.
    int ai_resetting;                     // Is the interface resetting?
    uint ai_pfilter;                      // Packet filter for this I/F.

    //
    // Used for calling NdisOpenAdapter and NdisCloseAdapter.
    //
    KEVENT ai_event;
    NDIS_STATUS ai_status;

    NDIS_MEDIUM ai_media;                 // Media type.
    uchar ai_addr[IEEE_802_ADDR_LENGTH];  // Local HW address.
    uchar ai_addrlen;                     // Length of ai_addr.
    uchar ai_bcastmask;                   // Mask for checking unicast.
    uchar ai_bcastval;                    // Value to check against.
    uchar ai_bcastoff;                    // Offset in frame to check against.
    uchar ai_hdrsize;                     // Size of link-level header.
    ushort ai_mtu;                        // MTU for this interface.
    uint ai_speed;                        // Speed.
    uint ai_qlen;                         // Output queue length.

    uint ai_uknprotos;                    // Unknown protocols received.
    uint ai_inoctets;                     // Input octets.
    uint ai_inpcount[2];                  // Count of packets received.
    uint ai_indiscards;                   // Input packets discarded.
    uint ai_inerrors;                     // Input errors.
    uint ai_outoctets;                    // Output octets.
    uint ai_outpcount[2];                 // Count of packets sent.
    uint ai_outdiscards;                  // Output packets discarded.
    uint ai_outerrors;                    // Output errors.
} LanInterface;

//
// NOTE: These two values MUST stay at 0 and 1.
//
#define AI_UCAST_INDEX    0
#define AI_NONUCAST_INDEX 1

// Ether Types
//
// Note that the Ether-Type field from classic Ethernet frames coincides
// in the header with the Length field in IEEE 802.3 frames.  This field
// can be used to distinguish between frame types as valid values for the
// 802.3 Length field are from 0x0000 to 0x05dc.  All valid Ether Types
// are greater than this.  See discussion on p.25 of RFC 1122.
//
#define ETYPE_MIN  0x05dd
#define ETYPE_IPv6 0x86dd

#endif  // LAN_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\fragment.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IPv6 fragmentation/reassembly definitions.
//


#ifndef FRAGMENT_H_INCLUDED
#define FRAGMENT_H_INCLUDED 1

//
// Structure used to link fragments together.
//
// The fragment data follows the shim structure in memory.
//
typedef struct PacketShim {
    struct PacketShim *Next;    // Next packet on list.
    ushort Len;
    ushort Offset;
} PacketShim;

__inline uchar *
PacketShimData(PacketShim *shim)
{
    return (uchar *)(shim + 1);
}


//
// Structure used to keep track of the fragments
// being reassembled into a single IPv6 datagram.
//
// REVIEW: Some of these fields are bigger than they need to be.
//
struct Reassembly {
    struct Reassembly *Next, *Prev; // Protected by global reassembly lock.
    KSPIN_LOCK Lock;          // Protects reassembly fields below.
    uint State;               // See values below.
    IPv6Header IPHdr;         // Copy of original IP header.
    Interface *IF;            // Does not hold a reference.
    ulong Id;                 // Unique (along w/ addrs) datagram identifier.
    uchar *UnfragData;        // Pointer to unfragmentable data.
    ushort UnfragmentLength;  // Length of the unfragmentable part.
    ushort Timer;             // Time to expiration in ticks (see IPv6Timeout).
    uint DataLength;          // Length of the fragmentable part.
    PacketShim *ContigList;   // Sorted, contiguous frags (from offset zero).
    PacketShim *ContigEnd;    // Last shim on ContigList (for quick access).
    PacketShim *GapList;      // Other fragments (sorted but non-contiguous).
    uint Flags;               // Packet flags.
    uint Size;                // Amount of memory consumed in this reassembly.
    ushort Marker;            // The current marker for contiguous data.
    ushort MaxGap;            // Largest data offset in the gap list.
    ushort NextHeaderOffset;  // Offset from IPHdr to pre-FH NextHeader field.
    uchar NextHeader;         // Header type following the fragment header.
};

//
// A reassembly starts in REASSEMBLY_STATE_NORMAL.
// If you want to remove it, then change the state
// to REASSEMBLY_STATE_DELETING. This prevents someone else
// from freeing it while you unlock the reassembly,
// get the global reassembly list lock, and relock the assembly.
// Someone else can remove the deleting reassembly
// from the global list, in which case the state becomes
// REASSEMBLY_STATE_REMOVED.
//
#define REASSEMBLY_STATE_NORMAL         0
#define REASSEMBLY_STATE_DELETING       1
#define REASSEMBLY_STATE_REMOVED        2

//
// There are denial-of-service issues with reassembly.
// We limit the total amount of memory in the reassembly list.
// If we get fragments that cause us to exceed the limit,
// we remove old reassemblies.
//
// The locking order is
// 1. Global reassembly list lock.
// 2. Individual reassembly record locks.
// 3. Reassembly list size lock.
//

extern struct ReassemblyList {
    KSPIN_LOCK Lock;            // Protects Reassembly List.
    Reassembly *First;          // List of packets being reassembled.
    Reassembly *Last;

    KSPIN_LOCK LockSize;        // Protects the Size field.
    uint Size;                  // Total size of the waiting fragments.
    uint Limit;                 // Upper bound for Size.
} ReassemblyList;

#define SentinelReassembly      ((Reassembly *)&ReassemblyList.First)

//
// Per-packet and per-fragment overhead sizes.
// These are in addition to the actual size of the buffered data.
// They should be at least as large as the Reassembly
// and PacketShim struct sizes.
//
#define REASSEMBLY_SIZE_PACKET  1024
#define REASSEMBLY_SIZE_FRAG    256

#define DEFAULT_REASSEMBLY_TIMEOUT IPv6TimerTicks(60)  // 60 seconds.


extern Reassembly *
FragmentLookup(Interface *IF, ulong Id,
               const IPv6Addr *Source, const IPv6Addr *Dest);

extern void
RemoveReassembly(Reassembly *Reass);

extern void
DeleteReassembly(Reassembly *Reass);

extern void
AddToReassemblyList(Reassembly *Reass);

extern void
DeleteFromReassemblyList(Reassembly *Reass);

extern void
IncreaseReassemblySize(Reassembly *Reass, uint Size);

extern void
CheckReassemblyQuota(Reassembly *Reass);

extern void
ReassemblyTimeout(void);

extern void
ReassembleDatagram(IPv6Packet *Packet, Reassembly *Reass);

extern IPv6Packet *
CreateFragmentPacket(Reassembly *Reass);

#endif // FRAGMENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\lan.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Internet Protocol Version 6 link-level support for some common
// LAN types: Ethernet, Token Ring, etc.
//


//
// This manifest constant causes the NDIS_PROTOCOL_CHARACTERISTICS struct to 
// use the NDIS 5 format if compiled using the NT 5 ddk.  If using the NT4 ddk
// this has no effect.
//
#ifndef NDIS50
#define NDIS50 1
#endif

#include "oscfg.h"
#include "ndis.h"
#include "tunuser.h"
#include "ip6imp.h"
#include "llip6if.h"
#include "lan.h"
#include "ntddip6.h"
#include "ip6def.h"

#ifndef NDIS_API
#define NDIS_API
#endif

uint NdisVersion;  // The major NDIS version we actualy register with.

static ulong LanLookahead = LOOKAHEAD_SIZE;

#define LAN_TUNNEL_DEFAULT_PREFERENCE 1
#define NdisMediumTunnel NdisMediumMax

static WCHAR LanName[] = TCPIPV6_NAME;

NDIS_HANDLE LanHandle;  // Our NDIS protocol handle.

typedef struct LanRequest {
    NDIS_REQUEST Request;
    KEVENT Event;
    NDIS_STATUS Status;
} LanRequest;

//* DoNDISRequest - Submit a request to an NDIS driver.
//
//  This is a utility routine to submit a general request to an NDIS
//  driver.  The caller specifes the request code (OID), a buffer and
//  a length.  This routine allocates a request structure, fills it in,
//  and submits the request.
//
NDIS_STATUS
DoNDISRequest(
    LanInterface *Adapter,  // Pointer to the LanInterface adapter strucuture.
    NDIS_REQUEST_TYPE RT,   // Type of request to be done (Set or Query).
    NDIS_OID OID,           // Value to be set/queried.
    void *Info,             // Pointer to the buffer to be passed.
    uint Length,            // Length of data in above buffer.
    uint *Needed)           // Location to fill in with bytes needed in buffer.
{
    LanRequest Request;
    NDIS_STATUS Status;

    // Now fill it in.
    Request.Request.RequestType = RT;
    if (RT == NdisRequestSetInformation) {
        Request.Request.DATA.SET_INFORMATION.Oid = OID;
        Request.Request.DATA.SET_INFORMATION.InformationBuffer = Info;
        Request.Request.DATA.SET_INFORMATION.InformationBufferLength = Length;
    } else {
        Request.Request.DATA.QUERY_INFORMATION.Oid = OID;
        Request.Request.DATA.QUERY_INFORMATION.InformationBuffer = Info;
        Request.Request.DATA.QUERY_INFORMATION.InformationBufferLength = Length;
    }

    //
    // Note that we can NOT use Adapter->ai_event and ai_status here.
    // There may be multiple concurrent DoNDISRequest calls.
    //

    // Initialize our event.
    KeInitializeEvent(&Request.Event, SynchronizationEvent, FALSE);

    if (!Adapter->ai_resetting) {
        // Submit the request.
        NdisRequest(&Status, Adapter->ai_handle, &Request.Request);

        // Wait for it to finish.
        if (Status == NDIS_STATUS_PENDING) {
            (void) KeWaitForSingleObject(&Request.Event, UserRequest,
                                         KernelMode, FALSE, NULL);
            Status = Request.Status;
        }
    } else
        Status = NDIS_STATUS_NOT_ACCEPTED;

    if (Needed != NULL)
        *Needed = Request.Request.DATA.QUERY_INFORMATION.BytesNeeded;

    return Status;
}


//* LanRequestComplete - Lan request complete handler.
//
//  This routine is called by the NDIS driver when a general request
//  completes.  Lan blocks on all requests, so we'll just wake up
//  whoever's blocked on this request.
//
void NDIS_API
LanRequestComplete(
    NDIS_HANDLE Handle,     // Binding handle (really our LanInterface).
    PNDIS_REQUEST Context,  // Request that completed.
    NDIS_STATUS Status)     // Final status of requested command.
{
    LanRequest *Request = (LanRequest *) Context;

    UNREFERENCED_PARAMETER(Handle);

    //
    // Signal the completion of a generic synchronous request.
    // See DoNDISRequest.
    //
    Request->Status = Status;
    KeSetEvent(&Request->Event, 0, FALSE);
}


//* LanTransmitComplete - Lan transmit complete handler.
//
//  This routine is called by the NDIS driver when a send completes.
//  This is a pretty time critical operation, we need to get through here
//  quickly.  We just take statistics and call the upper layer send
//  complete handler.
//
void NDIS_API
LanTransmitComplete(
    NDIS_HANDLE Handle,   // Binding handle (really LanInterface we sent on).
    PNDIS_PACKET Packet,  // Packet that was sent.
    NDIS_STATUS Status)   // Final status of send.
{
    LanInterface *Interface = (LanInterface *)Handle;

    Interface->ai_qlen--;

    //
    // Take statistics.
    //
    if (Status == NDIS_STATUS_SUCCESS) {
        UINT TotalLength;

        NdisQueryPacket(Packet, NULL, NULL, NULL, &TotalLength);
        Interface->ai_outoctets += TotalLength;
    } else {
        if (Status == NDIS_STATUS_RESOURCES)
            Interface->ai_outdiscards++;
        else
            Interface->ai_outerrors++;
    }

    UndoAdjustPacketBuffer(Packet);

    IPv6SendComplete(Interface->ai_context, Packet,
                     ((Status == NDIS_STATUS_SUCCESS) ?
                      IP_SUCCESS : IP_GENERAL_FAILURE));
}


//* LanTransmit - Send a frame.
//
//  The main Lan transmit routine, called by the upper layer.
//
void
LanTransmit(
    void *Context,              // A pointer to the LanInterface.
    PNDIS_PACKET Packet,        // Packet to send.
    uint Offset,                // Offset from start of packet to IP header.
    const void *LinkAddress)    // Link-level address of destination.
{
    LanInterface *Interface = (LanInterface *)Context;
    void *BufAddr;
    NDIS_STATUS Status;

    //
    // Loopback (for both unicast & multicast) happens in IPv6SendLL.
    // We never want the link layer to loopback.
    //
    Packet->Private.Flags = NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Obtain a pointer to space for the link-level header.
    //
    BufAddr = AdjustPacketBuffer(Packet, Offset, Interface->ai_hdrsize);

    switch (Interface->ai_media) {
    case NdisMedium802_3: {
        EtherHeader *Ether;

        // This is an Ethernet.
        Ether = (EtherHeader *)BufAddr;
        RtlCopyMemory(Ether->eh_daddr, LinkAddress, IEEE_802_ADDR_LENGTH);
        RtlCopyMemory(Ether->eh_saddr, Interface->ai_addr,
                      IEEE_802_ADDR_LENGTH);
        Ether->eh_type = net_short(ETYPE_IPv6);

#if 0
        //
        // See if we're using SNAP here.
        //
        if (Interface->ai_hdrsize != sizeof(EtherHeader)) {
                ...
        }
#endif
        break;
    }

    case NdisMediumFddi: {
        FDDIHeader *FDDI;
        SNAPHeader *SNAP;

        // This is a FDDI link.
        FDDI = (FDDIHeader *)BufAddr;
        FDDI->fh_pri = FDDI_PRI;  // Default frame code.
        RtlCopyMemory(FDDI->fh_daddr, LinkAddress, IEEE_802_ADDR_LENGTH);
        RtlCopyMemory(FDDI->fh_saddr, Interface->ai_addr,
                      IEEE_802_ADDR_LENGTH);

        // FDDI always uses SNAP.
        SNAP = (SNAPHeader *)(FDDI + 1);
        SNAP->sh_dsap = SNAP_SAP;
        SNAP->sh_ssap = SNAP_SAP;
        SNAP->sh_ctl = SNAP_UI;
        SNAP->sh_protid[0] = 0;
        SNAP->sh_protid[1] = 0;
        SNAP->sh_protid[2] = 0;
        SNAP->sh_etype = net_short(ETYPE_IPv6);

        break;
    }

    case NdisMediumTunnel: {
        
        //
        // There is no header to construct!
        //
        break;
    }    

    default:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "LanTransmit: Unknown media type\n"));
        break;
    }

    //
    // Send the packet down to NDIS.
    //

    (Interface->ai_outpcount[AI_UCAST_INDEX])++;
    Interface->ai_qlen++;

    if (!Interface->ai_resetting) {
        NdisSend(&Status, Interface->ai_handle, Packet);
    } else
        Status = NDIS_STATUS_NOT_ACCEPTED;

    if (Status != NDIS_STATUS_PENDING) {
        //
        // The send finished synchronously.
        // Call LanTransmitComplete, unifying our treatment
        // of the synchronous and asynchronous cases.
        //
        LanTransmitComplete((NDIS_HANDLE)Interface, Packet, Status);
    }
}


//* LanOpenAdapterComplete - LanOpen completion handler.
//
//  This routine is called by the NDIS driver when an open adapter
//  call completes.  Wakeup anyone who is waiting for this event.
//
void NDIS_API
LanOpenAdapterComplete(
    NDIS_HANDLE Handle,       // Binding handle (really our LanInterface).
    NDIS_STATUS Status,       // Final status of command.
    NDIS_STATUS ErrorStatus)  // Final error status.
{
    LanInterface *ai = (LanInterface *)Handle;

    UNREFERENCED_PARAMETER(ErrorStatus);

    //
    // Signal whoever is waiting and pass the final status.
    //
    ai->ai_status = Status;
    KeSetEvent(&ai->ai_event, 0, FALSE);
}


//* LanCloseAdapterComplete - Lan close adapter complete handler.
//
//  This routine is called by the NDIS driver when a close adapter
//  call completes.
//
//  At this point, NDIS guarantees that it has no other outstanding
//  calls to us.
//
void NDIS_API
LanCloseAdapterComplete(
    NDIS_HANDLE Handle,  // Binding handle (really our LanInterface).
    NDIS_STATUS Status)  // Final status of command.
{
    LanInterface *ai = (LanInterface *)Handle;

    //
    // Signal whoever is waiting and pass the final status.
    //
    ai->ai_status = Status;
    KeSetEvent(&ai->ai_event, 0, FALSE);
}


//* LanTDComplete - Lan transfer data complete handler.
//
//  This routine is called by the NDIS driver when a transfer data
//  call completes.  Hopefully we now have a complete packet we can
//  pass up to IP.  Recycle our TD packet descriptor in any event.
//
void NDIS_API
LanTDComplete(
    NDIS_HANDLE Handle,   // Binding handle (really our LanInterface).
    PNDIS_PACKET Packet,  // The packet used for the Transfer Data (TD).
    NDIS_STATUS Status,   // Final status of command.
    uint BytesCopied)     // Number of bytes copied.
{
    LanInterface *Interface = (LanInterface *)Handle;

    UNREFERENCED_PARAMETER(BytesCopied);

    //
    // If things went well, pass TD packet up to IP.
    //
    if (Status == NDIS_STATUS_SUCCESS) {
        PNDIS_BUFFER Buffer;
        IPv6Packet IPPacket;

        RtlZeroMemory(&IPPacket, sizeof IPPacket);

        NdisGetFirstBufferFromPacket(Packet, &Buffer, &IPPacket.FlatData,
                                     &IPPacket.ContigSize,
                                     &IPPacket.TotalSize);
        ASSERT(IPPacket.ContigSize == IPPacket.TotalSize);
        IPPacket.Data = IPPacket.FlatData;

        if (PC(Packet)->pc_nucast)
            IPPacket.Flags |= PACKET_NOT_LINK_UNICAST;

        IPPacket.NTEorIF = Interface->ai_context;
        (void) IPv6Receive(&IPPacket);
    }

    //
    // In any case, put the packet back on the list.
    //
    KeAcquireSpinLockAtDpcLevel(&Interface->ai_lock); 
    PC(Packet)->pc_link = Interface->ai_tdpacket;
    Interface->ai_tdpacket = Packet;
    KeReleaseSpinLockFromDpcLevel(&Interface->ai_lock);
}


//* LanResetComplete - Lan reset complete handler.
//
//  This routine is called by the NDIS driver when a reset completes.
//
void NDIS_API
LanResetComplete(
    NDIS_HANDLE Handle,  // Binding handle (really LanInterface which reset)
    NDIS_STATUS Status)  // Final status of command.
{
    UNREFERENCED_PARAMETER(Handle);
    UNREFERENCED_PARAMETER(Status);

    // REVIEW: Do anything here?  Axe this routine?
}


//* LanReceive - Lan receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//  Note that newer NDIS drivers are likely to call LanReceivePacket to
//  indicate data arrival instead of this routine.
//
NDIS_STATUS // Indication of whether or not we took the packet.
NDIS_API
LanReceive(
    NDIS_HANDLE Handle,   // The binding handle we gave NDIS earlier.
    NDIS_HANDLE Context,  // NDIS Context for TransferData operations.
    void *Header,         // Pointer to packet link-level header.
    uint HeaderSize,      // Size of above header (in bytes).
    void *Data,           // Pointer to look-ahead received data buffer.
    uint Size,            // Size of above data (in bytes).
    uint TotalSize)       // Total received data size (in bytes).
{
    LanInterface *Interface = Handle;  // Interface for this driver.
    ushort Type;                       // Protocol type.
    uint ProtOffset;                   // Offset in Data to non-media info.
    uint NUCast;                       // TRUE if the frame is not unicast.
    IPv6Packet IPPacket;

    if (Interface->ai_state != INTERFACE_UP) {
        // 
        // Interface is marked as down.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "IPv6 LanReceive: Interface down\n"));
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    Interface->ai_inoctets += TotalSize;

    switch (Interface->ai_media) {

    case NdisMedium802_3: {
        EtherHeader UNALIGNED *Ether = (EtherHeader UNALIGNED *)Header;

        if (HeaderSize < sizeof(*Ether)) {
            //
            // Header region too small to contain Ethernet header.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "IPv6 LanReceive: Bogus header size (%d bytes)\n",
                     HeaderSize));
            return NDIS_STATUS_NOT_RECOGNIZED;
        }
        if ((Type = net_short(Ether->eh_type)) >= ETYPE_MIN) {
            //
            // Classic Ethernet, no SNAP header.
            //
            ProtOffset = 0;
            break;
        }

        //
        // 802.3 Ethernet w/ SNAP header.  Protocol type is in
        // different spot.  This is handled the same as FDDI, so
        // just fall into that code...
        //
    }

    case NdisMediumFddi: {
        SNAPHeader UNALIGNED *SNAP = (SNAPHeader UNALIGNED *)Data;

        //
        // If we have a SNAP header that's all we need to look at.
        //
        if (Size >= sizeof(SNAPHeader) && SNAP->sh_dsap == SNAP_SAP &&
            SNAP->sh_ssap == SNAP_SAP && SNAP->sh_ctl == SNAP_UI) {
    
            Type = net_short(SNAP->sh_etype);
            ProtOffset = sizeof(SNAPHeader);
        } else {
            // handle XID/TEST here.
            Interface->ai_uknprotos++;
            return NDIS_STATUS_NOT_RECOGNIZED;
        }
        break;
    }

    case NdisMediumTunnel: {
        //
        // We accept everything over the tunnel.
        //
        Type = ETYPE_IPv6;
        ProtOffset = 0;
        break;
    }    

    default:
        // Should never happen.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "IPv6 LanReceive: Got a packet from an unknown media!?!\n"));
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    //
    // See if the packet is for a protocol we handle.
    //
    if (Type != ETYPE_IPv6) {
        Interface->ai_uknprotos++;
        return NDIS_STATUS_NOT_RECOGNIZED;
    }

    //
    // Notice if this packet wasn't received in a unicast frame.
    // REVIEW: Is this really a media independent solution?  Do we care?
    //
    NUCast = ((*((uchar UNALIGNED *)Header + Interface->ai_bcastoff) &
               Interface->ai_bcastmask) == Interface->ai_bcastval) ?
             AI_NONUCAST_INDEX : AI_UCAST_INDEX;

    (Interface->ai_inpcount[NUCast])++;

    //
    // Check to see if we have the entire packet.
    //
    if (Size < TotalSize) {
        uint Transferred;
        NDIS_STATUS Status;
        PNDIS_PACKET TdPacket;  // Packet used by NdisTransferData.

        //
        // We need to issue a Transfer Data request to get the
        // portion of the packet we're missing, so we might as well
        // get the whole packet this way and have it be contiguous.
        //

        //
        // Pull a packet to use for the Transfer Data off the queue.
        //
        KeAcquireSpinLockAtDpcLevel(&Interface->ai_lock); 
        TdPacket = Interface->ai_tdpacket;
        if (TdPacket == (PNDIS_PACKET)NULL) {
            // Don't have a packet to put it in.
            // Have to drop it, but let NDIS know we recognized it.
            KeReleaseSpinLockFromDpcLevel(&Interface->ai_lock);
            return NDIS_STATUS_SUCCESS;
        }
        Interface->ai_tdpacket = PC(TdPacket)->pc_link;
        KeReleaseSpinLockFromDpcLevel(&Interface->ai_lock);

        //
        // Remember NUCast in a handy field in the packet context.
        //
        PC(TdPacket)->pc_nucast = NUCast;

        //
        // Issue the TD.  Start transfer at the IP header.
        //
        NdisTransferData(&Status, Interface->ai_handle, Context,
                         ProtOffset, TotalSize - ProtOffset,
                         TdPacket, &Transferred);

        if (Status != NDIS_STATUS_PENDING) {
            //
            // TD completed synchronously,
            // so call the completion function directly.
            //
            LanTDComplete(Handle, TdPacket, Status, Transferred);
        }

        return NDIS_STATUS_SUCCESS;
    }

    //
    // We were given all the data directly.  Just need to skip
    // over any link level headers.
    //
    (uchar *)Data += ProtOffset;
    ASSERT(Size == TotalSize);
    TotalSize -= ProtOffset;

    //
    // Pass incoming data up to IPv6.
    //
    RtlZeroMemory(&IPPacket, sizeof IPPacket);

    IPPacket.FlatData = Data;
    IPPacket.Data = Data;
    IPPacket.ContigSize = TotalSize;
    IPPacket.TotalSize = TotalSize;

    if (NUCast)
        IPPacket.Flags |= PACKET_NOT_LINK_UNICAST;

    IPPacket.NTEorIF = Interface->ai_context;
    (void) IPv6Receive(&IPPacket);

    return NDIS_STATUS_SUCCESS;
}


//* LanReceiveComplete - Lan receive complete handler.
//
//  This routine is called by the NDIS driver after some number of
//  receives.  In some sense, it indicates 'idle time'.
//
void NDIS_API
LanReceiveComplete(
    NDIS_HANDLE Handle)  // Binding handle (really our LanInterface).
{
    UNREFERENCED_PARAMETER(Handle);

    IPv6ReceiveComplete();
}


//* LanReceivePacket - Lan receive data handler.
//
//  This routine is called when data arrives from the NDIS driver.
//  Note that older NDIS drivers are likely to call LanReceive to
//  indicate data arrival instead of this routine.
//
int  // Returns: number of references we hold to Packet upon return.
LanReceivePacket(
    NDIS_HANDLE Handle,   // The binding handle we gave NDIS earlier.
    PNDIS_PACKET Packet)  // Packet descriptor for incoming packet.
{
    LanInterface *Interface = Handle;  // Interface for this driver.
    PNDIS_BUFFER Buffer;               // Buffer in packet chain.
    void *Address;                     // Address of above Buffer.
    uint Length, TotalLength;          // Length of Buffer, Packet.
    EtherHeader UNALIGNED *Ether;      // Header for Ethernet media.
    ushort Type;                       // Protocol type.
    uint Position;                     // Offset to non-media info.
    uint NUCast;                       // TRUE if the frame is not unicast.
    IPv6Packet IPPacket;

    if (Interface->ai_state != INTERFACE_UP) {
        // Interface is marked as down.
        return 0;
    }

    //
    // Find out about the packet we've been handed.
    //
    NdisGetFirstBufferFromPacket(Packet, &Buffer, &Address, &Length,
                                 &TotalLength);

    Interface->ai_inoctets += TotalLength;  // Take statistic.

    //
    // Check for obviously bogus packets.
    //
    if (TotalLength < (uint)Interface->ai_hdrsize) {
        //
        // Packet too small to hold media header, drop it.
        //
        return 0;
    }        

    if (Length < (uint)Interface->ai_hdrsize) {
        //
        // First buffer in chain too small to hold header.
        // This shouldn't happen because of LanLookahead.
        //
        return 0;
    }

    //
    // Figure out what protocol type this packet is by looking in the
    // media-specific header field for this type of media.
    //
    switch (Interface->ai_media) {
        
    case NdisMedium802_3: {
        Ether = (EtherHeader UNALIGNED *)Address;

        if ((Type = net_short(Ether->eh_type)) >= ETYPE_MIN) {
            //
            // Classic Ethernet, no SNAP header.
            //
            Position = sizeof(EtherHeader);
        } else {
            //
            // 802.3 Ethernet w/ SNAP header.  Protocol type is in
            // different spot and we have to remember to skip over it.
            // The great thing about standards is that there are so
            // many to choose from.
            //
            SNAPHeader UNALIGNED *SNAP = (SNAPHeader UNALIGNED *)
                ((char *)Address + sizeof(EtherHeader));

            if (Length >= (sizeof(EtherHeader) + sizeof(SNAPHeader))
                && SNAP->sh_dsap == SNAP_SAP && SNAP->sh_ssap == SNAP_SAP
                && SNAP->sh_ctl == SNAP_UI) {

                Type = net_short(SNAP->sh_etype);
                Position = sizeof(EtherHeader) + sizeof(SNAPHeader);
            } else {
                // handle XID/TEST here.
                Interface->ai_uknprotos++;
                return 0;
            }
        }
        break;
    }

    case NdisMediumFddi: {
        SNAPHeader UNALIGNED *SNAP = (SNAPHeader UNALIGNED *)
            ((char *)Address + sizeof(FDDIHeader));

        if (Length >= (sizeof(FDDIHeader) + sizeof(SNAPHeader))
            && SNAP->sh_dsap == SNAP_SAP && SNAP->sh_ssap == SNAP_SAP
            && SNAP->sh_ctl == SNAP_UI) {

            Type = net_short(SNAP->sh_etype);
            Position = sizeof(FDDIHeader) + sizeof(SNAPHeader);
        } else {
            // handle XID/TEST here.
            Interface->ai_uknprotos++;
            return 0;
        }
        break;
    }

    case NdisMediumTunnel: {
        //
        // We accept everything over the tunnel.
        //
        Type = ETYPE_IPv6;
        Position = 0;
        break;
    }    

    default:
        // Should never happen.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "IPv6: Got a packet from an unknown media!?!\n"));
        return 0;
    }

    //
    // Notice if this packet wasn't received in a unicast frame.
    // REVIEW: Is this really a media independent solution?
    //
    NUCast = ((*((uchar UNALIGNED *)Address + Interface->ai_bcastoff) &
               Interface->ai_bcastmask) == Interface->ai_bcastval) ?
               AI_NONUCAST_INDEX : AI_UCAST_INDEX;

    //
    // See if the packet is for a protocol we handle.
    //
    if (Type == ETYPE_IPv6) {

        (Interface->ai_inpcount[NUCast])++;

        //
        // Skip over any link level headers.
        //
        (uchar *)Address += Position;
        Length -= Position;
        TotalLength -= Position;

        //
        // Pass incoming data up to IPv6.
        //
        RtlZeroMemory(&IPPacket, sizeof IPPacket);

        IPPacket.Position = Position;
        IPPacket.Data = Address;
        IPPacket.ContigSize = Length;
        IPPacket.TotalSize = TotalLength;
        IPPacket.NdisPacket = Packet;

        if (NUCast)
            IPPacket.Flags |= PACKET_NOT_LINK_UNICAST;

        IPPacket.NTEorIF = Interface->ai_context;
        return IPv6Receive(&IPPacket);

    } else {
        //
        // Not a protocol we handle.
        //
        Interface->ai_uknprotos++;
        return 0;
    }
}


//* LanSetInterfaceLinkStatus
//
//  Helper function for processing media connectivity indications.
//
void
LanSetInterfaceLinkStatus(
    LanInterface *Interface,
    int MediaConnected)
{
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "LanSetInterfaceLinkStatus(%p/%p) - %u %u\n",
               Interface, Interface->ai_context,
               Interface->ai_media_check, MediaConnected));

    KeAcquireSpinLockAtDpcLevel(&Interface->ai_lock);
    if (Interface->ai_media_check == MEDIA_CHECK_IDLE)
        SetInterfaceLinkStatus(Interface->ai_context, MediaConnected);
    else
        Interface->ai_media_check = MEDIA_CHECK_CONFLICT;
    KeReleaseSpinLockFromDpcLevel(&Interface->ai_lock);
}


//* LanStatus - Lan status handler.
//
//  Called by the NDIS driver when some sort of status change occurs.
//  We take action depending on the type of status.
//
//  Entry:
//      Handle - The binding handle we specified (really a pointer to an AI).
//      GStatus - General type of status that caused the call.
//      Status - Pointer to a buffer of status specific information.
//      StatusSize - Size of the status buffer.
//
//  Exit: Nothing.
//
void NDIS_API
LanStatus(
    NDIS_HANDLE Handle,   // Binding handle (really our LanInterface).
    NDIS_STATUS GStatus,  // General status type which caused the call.
    void *Status,         // Pointer to buffer of status specific info.
    uint StatusSize)      // Size of the above status buffer.
{
    LanInterface *Interface = Handle;  // Interface for this driver.
    uint Index;

    UNREFERENCED_PARAMETER(Status);

    switch (GStatus) {
    case NDIS_STATUS_RESET_START:
        //
        // While the interface is resetting, we must avoid calling
        // NdisSendPackets, NdisSend, and NdisRequest.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanStatus(%p) - start reset\n", Interface));
        Interface->ai_resetting = TRUE;
        break;
    case NDIS_STATUS_RESET_END:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanStatus(%p) - end reset\n", Interface));
        Interface->ai_resetting = FALSE;
        break;
    case NDIS_STATUS_MEDIA_CONNECT:
        LanSetInterfaceLinkStatus(Interface, TRUE);
        break;
    case NDIS_STATUS_MEDIA_DISCONNECT:
        LanSetInterfaceLinkStatus(Interface, FALSE);
        break;
    default:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "IPv6: LanStatus(%p) - status %x\n",
                   Interface, GStatus));
        for (Index = 0; Index < StatusSize/4; Index++)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       " status %08x\n", ((uint *)Status)[Index]));
        break;
    }
}


//* LanStatusComplete - Lan status complete handler.
//
//  A routine called by the NDIS driver so that we can do postprocessing
//  after a status event.
//
void NDIS_API
LanStatusComplete(
    NDIS_HANDLE Handle)  // Binding handle (really our LanInterface).
{
    UNREFERENCED_PARAMETER(Handle);

    // REVIEW: Do anything here?
}

extern void NDIS_API
LanBindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE BindContext,
               PNDIS_STRING AdapterName, PVOID SS1, PVOID SS2);

extern void NDIS_API
LanUnbindAdapter(PNDIS_STATUS RetStatus, NDIS_HANDLE ProtBindContext,
                 NDIS_HANDLE UnbindContext);

extern NDIS_STATUS NDIS_API
LanPnPEvent(NDIS_HANDLE ProtocolBindingContext,
            PNET_PNP_EVENT NetPnPEvent);

//
// Structure passed to NDIS to tell it how to call Lan Interfaces.
//
// This is carefully arranged so that it can build
// with either the NT 4 or NT 5 DDK, and then in either case
// run on NT 4 (registering with NDIS 4) and
// run on NT 5 (registering with NDIS 5).
//
NDIS50_PROTOCOL_CHARACTERISTICS LanCharacteristics = {
    0,  // NdisMajorVersion
    0,  // NdisMinorVersion
    // This field was added in NT 5. (Previously it was just a hole.)
#ifdef NDIS_FLAGS_DONT_LOOPBACK
    0,  // Filler
#endif
    0,  // Flags
    LanOpenAdapterComplete,
    LanCloseAdapterComplete,
    LanTransmitComplete,
    LanTDComplete,
    LanResetComplete,
    LanRequestComplete,
    LanReceive,
    LanReceiveComplete,
    LanStatus,
    LanStatusComplete,
    { 0, 0, 0 },        // Name
    LanReceivePacket,
    LanBindAdapter,
    LanUnbindAdapter,
    // The type of this field changed between NT 4 and NT 5.
#ifdef NDIS_FLAGS_DONT_LOOPBACK
    LanPnPEvent,
#else
    (TRANSLATE_HANDLER) LanPnPEvent,
#endif
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};



#pragma BEGIN_INIT
//* LanInit
//
//  This functions intializes the Lan module.
//  In particular, it registers with NDIS.
//
//  Returns FALSE to indicate failure to initialize.
//
int
LanInit(void)
{
    NDIS_STATUS Status;

    RtlInitUnicodeString(&LanCharacteristics.Name, LanName);

    //
    // We try to register with NDIS major version = 5.  If this fails we try
    // again for NDIS major version = 4.  If this also fails we exit without
    // any further attempts to register with NDIS.
    //
    LanCharacteristics.MajorNdisVersion = 5;
    NdisRegisterProtocol(&Status, &LanHandle,
                         (NDIS_PROTOCOL_CHARACTERISTICS *) &LanCharacteristics,
                         sizeof(NDIS50_PROTOCOL_CHARACTERISTICS));
    if (Status != NDIS_STATUS_SUCCESS) {
        LanCharacteristics.MajorNdisVersion = 4;
        //
        // NDIS 4 has a different semantics - it has TranslateHandler
        // instead of PnPEventHandler. So do not supply that handler.
        //
#ifdef NDIS_FLAGS_DONT_LOOPBACK
        LanCharacteristics.PnPEventHandler = NULL;
#else
        LanCharacteristics.TranslateHandler = NULL;
#endif
        NdisRegisterProtocol(&Status, &LanHandle,
                        (NDIS_PROTOCOL_CHARACTERISTICS *) &LanCharacteristics,
                        sizeof(NDIS40_PROTOCOL_CHARACTERISTICS));
        if (Status != NDIS_STATUS_SUCCESS) {
            //
            // Can't register at all. Just bail out...
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "LanInit: could not register -> %x\n", Status));
            return FALSE;
        }
    }

    //
    // We've registered OK using NDIS.
    //
    NdisVersion = LanCharacteristics.MajorNdisVersion;
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "LanInit: registered with NDIS %u.\n", NdisVersion));
    return TRUE;
}
#pragma END_INIT


//* LanUnload
//
//  Called when then IPv6 stack is unloading.
//  We need to disconnect from NDIS.
//
void
LanUnload(void)
{
    NDIS_STATUS Status;

    //
    // At this point, the adapters should already all be closed
    // because IPUnload is called first and does that.
    //

    NdisDeregisterProtocol(&Status, LanHandle);
}


//* LanFreeInterface - Free a Lan interface
//
//  Called in the event of some sort of initialization failure. We free all
//  the memory associated with an Lan interface.
//
void
LanFreeInterface(
    LanInterface *Interface)  // Interface structure to be freed.
{
    NDIS_STATUS Status;

    //
    // If we're bound to the adapter, close it now.
    //
    if (Interface->ai_handle != NULL) {
        KeInitializeEvent(&Interface->ai_event, SynchronizationEvent, FALSE);

        NdisCloseAdapter(&Status, Interface->ai_handle);

        if (Status == NDIS_STATUS_PENDING) {
            (void) KeWaitForSingleObject(&Interface->ai_event, UserRequest,
                                         KernelMode, FALSE, NULL);
            Status = Interface->ai_status;
        }
    }

    //
    // Free the Transfer Data Packet, if any, for this interface.
    //
    if (Interface->ai_tdpacket != NULL)
        IPv6FreePacket(Interface->ai_tdpacket);
    
    //
    // Free the interface structure itself.
    //
    ExFreePool(Interface);
}


//* LanAllocateTDPacket
//
//  Allocate a packet for NdisTransferData.
//  We always allocate contiguous space for a full MTU of data.
//
PNDIS_PACKET
LanAllocateTDPacket(
    LanInterface *Interface)  // Interface for which to allocate TD packet.
{
    PNDIS_PACKET Packet;
    void *Mem;
    NDIS_STATUS Status;

    Status = IPv6AllocatePacket(Interface->ai_mtu, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS)
        return NULL;

    return Packet;
}

extern uint UseEtherSNAP(PNDIS_STRING Name);


//* LanRegister - Register a protocol with the Lan module.
//
//  We register an adapter for Lan processing and create a LanInterface
//  structure to represent it.  We also open the NDIS adapter here.
//
//  REVIEW: Should we set the packet filter to NOT accept broadcast packets?
//  REVIEW: Broadcast isn't used in IPv6.  Junk bcast* stuff as well?  Switch
//  REVIEW: this to keeping track of multicasts?
//
int
LanRegister(
    PNDIS_STRING Adapter,             // Name of the adapter to bind to.
    struct LanInterface **Interface)  // Where to return new interace.
{
    LanInterface *ai;  // Pointer to interface struct for this interface.
    NDIS_STATUS Status, OpenStatus;     // Status values.
    uint i = 0;                         // Medium index.
    NDIS_MEDIUM MediaArray[2];
    uint instance;
    uint mss;
    uint speed;
    uchar bcastmask, bcastval, bcastoff, addrlen, hdrsize;
    NDIS_OID OID;
    uint PF;

    //
    // Allocate memory to hold new interface.
    //
    ai = (LanInterface *) ExAllocatePool(NonPagedPool, sizeof(LanInterface));
    if (ai == NULL)
        return FALSE;  // Couldn't allocate memory for this one.
    RtlZeroMemory(ai, sizeof(LanInterface));

    //
    // In actual practice, we've only tested Ethernet and FDDI.
    // So disallow other media for now.
    //
    MediaArray[0] = NdisMedium802_3;
    MediaArray[1] = NdisMediumFddi;
#if 0
    MediaArray[2] = NdisMedium802_5;
#endif

    // Initialize this adapter interface structure.
    ai->ai_state = INTERFACE_INIT;
    ai->ai_media_check = MEDIA_CHECK_QUERY;

    // Initialize the locks.
    KeInitializeSpinLock(&ai->ai_lock);

    KeInitializeEvent(&ai->ai_event, SynchronizationEvent, FALSE);

    // Open the NDIS adapter.
    NdisOpenAdapter(&Status, &OpenStatus, &ai->ai_handle,
                    &i, MediaArray, 2,
                    LanHandle, ai, Adapter, 0, NULL);

    // Block for open to complete.
    if (Status == NDIS_STATUS_PENDING) {
        (void) KeWaitForSingleObject(&ai->ai_event, UserRequest, KernelMode,
                                     FALSE, NULL);
        Status = ai->ai_status;
    }

    ai->ai_media = MediaArray[i];   // Fill in media type.

    //
    // Open adapter completed.  If it succeeded, we'll finish our
    // intialization.  If it failed, bail out now.
    //
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "LanRegister: Adapter failed to initialize."
                   " Status = 0x%x\n", Status));
        ai->ai_handle = NULL;
        goto ErrorReturn;
    }

    //
    // Read the maximum frame size.
    //
    Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                           OID_GEN_MAXIMUM_FRAME_SIZE, &mss,
                           sizeof(mss), NULL);

    if (Status != NDIS_STATUS_SUCCESS) {
        //
        // Failed to get maximum frame size.  Bail.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "LanRegister: Failed to get maximum frame size. "
                   "Status = 0x%x\n", Status));
        goto ErrorReturn;
    }

    //
    // Read the local link-level address from the adapter.
    //
    switch (ai->ai_media) {        
    case NdisMedium802_3:
        addrlen = IEEE_802_ADDR_LENGTH;
        bcastmask = ETHER_BCAST_MASK;
        bcastval = ETHER_BCAST_VAL;
        bcastoff = ETHER_BCAST_OFF;
        OID = OID_802_3_CURRENT_ADDRESS;
        hdrsize = sizeof(EtherHeader);
        if (UseEtherSNAP(Adapter)) {
            hdrsize += sizeof(SNAPHeader);
        }

        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED |
            NDIS_PACKET_TYPE_MULTICAST;
        break;

    case NdisMedium802_5:
        addrlen = IEEE_802_ADDR_LENGTH;
        bcastmask = TR_BCAST_MASK;
        bcastval = TR_BCAST_VAL;
        bcastoff = TR_BCAST_OFF;
        OID = OID_802_5_CURRENT_ADDRESS;
        hdrsize = sizeof(TRHeader) + sizeof(SNAPHeader);
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED;

        //
        // Figure out the RC len stuff now.
        //
        mss -= (sizeof(RC) + (MAX_RD * sizeof(ushort)));
        break;

    case NdisMediumFddi:
        addrlen = IEEE_802_ADDR_LENGTH;
        bcastmask = FDDI_BCAST_MASK;
        bcastval = FDDI_BCAST_VAL;
        bcastoff = FDDI_BCAST_OFF;
        OID = OID_FDDI_LONG_CURRENT_ADDR;
        hdrsize = sizeof(FDDIHeader) + sizeof(SNAPHeader);
        PF = NDIS_PACKET_TYPE_BROADCAST | NDIS_PACKET_TYPE_DIRECTED |
            NDIS_PACKET_TYPE_MULTICAST;
        mss = MIN(mss, FDDI_MSS);
        break;

    default:
        ASSERT(!"bad medium from Ndis");
        goto ErrorReturn;
    }

    //
    // NDIS exposes the tunnel interface as 802_3, but ensures that it's the
    // only interface for which OID_CUSTOM_TUNMP_INSTANCE_ID returns success.
    //
    if (DoNDISRequest(ai, NdisRequestQueryInformation,
                      OID_CUSTOM_TUNMP_INSTANCE_ID, &instance,
                      sizeof(instance), NULL) == NDIS_STATUS_SUCCESS) {
        ai->ai_media = NdisMediumTunnel;

        //
        // These values are chosen so NUCast returns FALSE.
        //
        bcastmask = 0;
        bcastval = 1;
        bcastoff = 0;

        hdrsize = 0;

        //
        // Since we do not construct an ethernet header on transmission, or
        // expect one on receive, we need to ensure that NDIS does not attempt
        // to parse frames on this interface.  On transmission this is achieved
        // by setting the NDIS_FLAGS_DONT_LOOPBACK flag.  Receives are made
        // NDIS-Safe by setting the interface in promiscuous mode.
        //
        PF |= NDIS_PACKET_TYPE_PROMISCUOUS;
        
        //
        // This is what NDIS should have provided us.
        //
        mss = IPv6_MINIMUM_MTU;
    }
    
    ai->ai_bcastmask = bcastmask;
    ai->ai_bcastval = bcastval;
    ai->ai_bcastoff = bcastoff;
    ai->ai_addrlen = addrlen;
    ai->ai_hdrsize = hdrsize;
    ai->ai_pfilter = PF;
    ai->ai_mtu = (ushort)mss;
    
    Status = DoNDISRequest(ai, NdisRequestQueryInformation, OID,
                           ai->ai_addr, addrlen, NULL);

    if (Status != NDIS_STATUS_SUCCESS) {
        //
        // Failed to get link-level address.  Bail.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "LanRegister: Failed to get link-level address. "
                   "Status = 0x%x\n", Status));
        goto ErrorReturn;
    }

    //
    // Read the speed for local purposes.
    // If we can't read the speed that's OK.
    //
    Status = DoNDISRequest(ai, NdisRequestQueryInformation,
                           OID_GEN_LINK_SPEED, &speed, sizeof(speed), NULL);

    if (Status == NDIS_STATUS_SUCCESS) {
        ai->ai_speed = speed * 100L;
    }

    //
    // Set the lookahead. This is the minimum amount of packet data
    // that we wish to see contiguously for every packet received.
    //
    Status = DoNDISRequest(ai, NdisRequestSetInformation,
                           OID_GEN_CURRENT_LOOKAHEAD,
                           &LanLookahead, sizeof LanLookahead, NULL);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "LanRegister: Failed to set lookahead. "
                   "Status = 0x%x\n", Status));
        goto ErrorReturn;
    }

    //
    // Allocate a Tranfer Data packet for this interface.
    //
    ai->ai_tdpacket = LanAllocateTDPacket(ai);

    *Interface = ai;
    return TRUE;

ErrorReturn:
    LanFreeInterface(ai);
    return FALSE;
}


//* LanCreateToken
//
//  Given a link-layer address, creates a 64-bit "interface identifier"
//  in the low eight bytes of an IPv6 address.
//  Does not modify the other bytes in the IPv6 address.
//
void
LanCreateToken(
    void *Context,      // Interface from which to take interface identifier.
    IPv6Addr *Address)  // IPv6 address to place token into.
{
    LanInterface *Interface = (LanInterface *)Context;
    uchar *IEEEAddress = Interface->ai_addr;

    //
    // This is formed the same way for Ethernet, FDDI and Tunnel.
    //
    Address->s6_bytes[8] = IEEEAddress[0] ^ 0x2;
    Address->s6_bytes[9] = IEEEAddress[1];
    Address->s6_bytes[10] = IEEEAddress[2];
    Address->s6_bytes[11] = 0xff;
    Address->s6_bytes[12] = 0xfe;
    Address->s6_bytes[13] = IEEEAddress[3];
    Address->s6_bytes[14] = IEEEAddress[4];
    Address->s6_bytes[15] = IEEEAddress[5];
}


//* LanTunnelCreateToken
//
//  Given a link-layer address, creates a 64-bit "interface identifier"
//  in the low eight bytes of an IPv6 address.
//  Does not modify the other bytes in the IPv6 address.
//
void
LanTunnelCreateToken(
    void *Context,      // Interface from which to take interface identifier.
    IPv6Addr *Address)  // IPv6 address to place token into.
{
    LanInterface *Interface = (LanInterface *)Context;

    //
    // Only called for tunnels configured with the default MAC address.
    //
    ASSERT((Interface->ai_media == NdisMediumTunnel) &&
           RtlEqualMemory(
               TUN_CARD_ADDRESS, Interface->ai_addr, Interface->ai_addrlen));

    //
    // Non link-local addresses still use the regular interface identifier.
    //
    if (!IsLinkLocal(Address)) {
        LanCreateToken(Context, Address);
        return;
    }

    //
    // Create a random interface identifier for the link-local address.
    //
    do {
        uint Identifier[2];
        
        Identifier[0] = Random();
        Identifier[1] = Random();
        RtlCopyMemory(&Address->s6_bytes[8], (uchar *)Identifier, 8);
        
        //
        // Clear the universal/local bit to indicate local significance.
        //
        Address->s6_bytes[8] &= ~0x2;
    } while (IsKnownAnycast(Address));
}


//* LanReadLinkLayerAddressOption - Parse a ND link-layer address option.
//
//  Parses a Neighbor Discovery link-layer address option
//  and if valid, returns a pointer to the link-layer address.
//
const void *
LanReadLinkLayerAddressOption(
    void *Context,              // Interface for which ND option applies.
    const uchar *OptionData)    // Option data to parse.
{
    LanInterface *Interface = (LanInterface *)Context;

    //
    // Check that the option length is correct,
    // allowing for the option type/length bytes
    // and rounding up to 8-byte units.
    //
    if (((Interface->ai_addrlen + 2 + 7)/8) != OptionData[1])
        return NULL;

    //
    // Skip over the option type and length bytes,
    // and return a pointer to the option data.
    //
    return OptionData + 2;
}


//* LanWriteLinkLayerAddressOption - Create a ND link-layer address option.
//
//  Creates a Neighbor Discovery link-layer address option.
//  Our caller takes care of the option type & length fields.
//  We handle the padding/alignment/placement of the link address
//  into the option data.
//
//  (Our caller allocates space for the option by adding 2 to the
//  link address length and rounding up to a multiple of 8.)
//
void
LanWriteLinkLayerAddressOption(
    void *Context,              // Interface to create option regarding.
    uchar *OptionData,          // Where the option data resides.
    const void *LinkAddress)    // Link-level address.
{
    LanInterface *Interface = (LanInterface *)Context;

    //
    // Place the address after the option type/length bytes.
    //
    RtlCopyMemory(OptionData + 2, LinkAddress, Interface->ai_addrlen);
}


//* LanTunnelConvertAddress
//
//  LanTunnel does not use Neighbor Discovery or link-layer addresses.
//
ushort
LanTunnelConvertAddress(
    void *Context,           // Unused (nominally, our LanInterface).
    const IPv6Addr *Address, // IPv6 multicast address.
    void *LinkAddress)       // Where link-level address to be filled resides.
{
    LanInterface *Interface = (LanInterface *)Context;    
    ASSERT(Interface->ai_media == NdisMediumTunnel);

    UNREFERENCED_PARAMETER(Address);

    RtlCopyMemory(LinkAddress, Interface->ai_addr, Interface->ai_addrlen);

    //
    // Make the neighbor link layer address different from our own.  This
    // ensures that IPv6SendLL does not loop back packets destined for them.
    // In fact, a link layer address on the tunnel interface is faked only
    // because IPv6SendLL does not handle zero length link layer addresses!
    //
    ASSERT(Interface->ai_addrlen != 0);
    ((PUCHAR) LinkAddress)[Interface->ai_addrlen - 1] =
        ~((PUCHAR) LinkAddress)[Interface->ai_addrlen - 1];
    
    return ND_STATE_PERMANENT;
}


//* LanConvertAddress
//
//  Converts an IPv6 multicast address to a link-layer address.
//  Generally this requires hashing the IPv6 address into a set
//  of link-layer addresses, in a link-layer-specific way.
//
ushort
LanConvertAddress(
    void *Context,           // Unused (nominally, our LanInterface).
    const IPv6Addr *Address, // IPv6 multicast address.
    void *LinkAddress)       // Where link-level address to be filled resides.
{
    UNREFERENCED_PARAMETER(Context);

    if (IsMulticast(Address)) {
        uchar *IEEEAddress = (uchar *)LinkAddress;

        //
        // This is formed the same way for Ethernet and FDDI.
        //
        IEEEAddress[0] = 0x33;
        IEEEAddress[1] = 0x33;
        IEEEAddress[2] = Address->s6_bytes[12];
        IEEEAddress[3] = Address->s6_bytes[13];
        IEEEAddress[4] = Address->s6_bytes[14];
        IEEEAddress[5] = Address->s6_bytes[15];
        return ND_STATE_PERMANENT;
    }
    else {
        //
        // We can't guess at the correct link-layer address.
        //
        return ND_STATE_INCOMPLETE;
    }
}


//* LanSetMulticastAddressList
//
//  Takes an array of link-layer multicast addresses
//  (from LanConvertMulticastAddress) from which we should
//  receive packets.  Passes them to NDIS.
//
NDIS_STATUS
LanSetMulticastAddressList(
    void *Context,
    const void *LinkAddresses,
    uint NumKeep,
    uint NumAdd,
    uint NumDel)
{
    LanInterface *Interface = (LanInterface *)Context;
    NDIS_STATUS Status;
    NDIS_OID OID;

    UNREFERENCED_PARAMETER(NumDel);

    //
    // Set the multicast address list to the current list.
    // The OID to do this depends upon the media type.
    //
    switch (Interface->ai_media) {
    case NdisMedium802_3:
        OID = OID_802_3_MULTICAST_LIST;
        break;
    case NdisMediumFddi:
        OID = OID_FDDI_LONG_MULTICAST_LIST;
        break;
    default:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "LanSetMulticastAddressList: Unknown media type\n"));
        return NDIS_STATUS_FAILURE;
    }
    Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                           OID, (char *)LinkAddresses,
                           (NumKeep + NumAdd) * Interface->ai_addrlen, NULL);

    //
    // If the above request was successful, then turn off the all-multicast 
    // or all-packets filter if we had previously set one of them.
    //
    if (Status == NDIS_STATUS_SUCCESS) {
        if (Interface->ai_pfilter & NDIS_PACKET_TYPE_ALL_MULTICAST ||
            Interface->ai_pfilter & NDIS_PACKET_TYPE_PROMISCUOUS) {
                
            Interface->ai_pfilter &= ~(NDIS_PACKET_TYPE_ALL_MULTICAST | 
                NDIS_PACKET_TYPE_PROMISCUOUS);
            DoNDISRequest(Interface, NdisRequestSetInformation,
                OID_GEN_CURRENT_PACKET_FILTER,  &Interface->ai_pfilter,
                sizeof(uint), NULL);
        }

        return Status;
    }

    // 
    // We get here only if the NDIS request to set the multicast list fails.
    // First we try to set the packet filter for all multicast packets, and if
    // this fails, we try to set the packet filter for all packets.
    //

    // This code was swiped from the V4 stack: arp.c
    Interface->ai_pfilter |= NDIS_PACKET_TYPE_ALL_MULTICAST;
    Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                      OID_GEN_CURRENT_PACKET_FILTER,  &Interface->ai_pfilter,
                      sizeof(uint), NULL);

    if (Status != NDIS_STATUS_SUCCESS) {
        // All multicast failed, try all packets.
        Interface->ai_pfilter &= ~(NDIS_PACKET_TYPE_ALL_MULTICAST);
        Interface->ai_pfilter |= NDIS_PACKET_TYPE_PROMISCUOUS;
        Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                      OID_GEN_CURRENT_PACKET_FILTER,  &Interface->ai_pfilter,
                      sizeof(uint), NULL);
    }

    return Status;
}


//* LanCloseAdapter
//
//  The IPv6 layer calls this function to close a connection to an adapter.
//
void
LanCloseAdapter(void *Context)
{
    LanInterface *Interface = (LanInterface *)Context;

    //
    // Mark adapter down.
    //
    Interface->ai_state = INTERFACE_DOWN;

    //
    // Shut adapter up, so we don't get any more frames.
    //
    Interface->ai_pfilter = 0;
    DoNDISRequest(Interface, NdisRequestSetInformation,
                  OID_GEN_CURRENT_PACKET_FILTER,
                  &Interface->ai_pfilter, sizeof(uint), NULL);

    //
    // Release our reference for the interface.
    //
    ReleaseInterface(Interface->ai_context);
}


//* LanCleanupAdapter
//
//  Perform final cleanup of the adapter.
//
void
LanCleanupAdapter(void *Context)
{
    LanInterface *Interface = (LanInterface *)Context;
    NDIS_STATUS Status;

    KeInitializeEvent(&Interface->ai_event, SynchronizationEvent, FALSE);

    //
    // Close the connection to NDIS.
    //
    NdisCloseAdapter(&Status, Interface->ai_handle);

    //
    // Block for close to complete.
    //
    if (Status == NDIS_STATUS_PENDING) {
        (void) KeWaitForSingleObject(&Interface->ai_event,
                                     UserRequest, KernelMode,
                                     FALSE, NULL);
        Status = Interface->ai_status;
    }

    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "LanCleanupAdapter(%p) - NdisCloseAdapter -> %x\n",
                   Interface, Status));
    }

    //
    // Tell NDIS that we are done.
    // NOTE: IOCTL_IPV6_DELETE_INTERFACE does not set ai_unbind, this
    // ensures that NdisCompleteUnbindAdapter is not invoked along its path.
    //
    if (Interface->ai_unbind != NULL)
        NdisCompleteUnbindAdapter(Interface->ai_unbind, NDIS_STATUS_SUCCESS);

    //
    // Free adapter memory.
    //
    IPv6FreePacket(Interface->ai_tdpacket);
    ExFreePool(Interface);
}


//* LanBindAdapter - Bind and initialize an adapter.
//
//  Called in a PNP environment to initialize and bind an adapter. We open
//  the adapter and get it running, and then we call up to IP to tell him
//  about it. IP will initialize, and if all goes well call us back to start
//  receiving.
//
void NDIS_API
LanBindAdapter(
    PNDIS_STATUS RetStatus,    // Where to return status of this call.
    NDIS_HANDLE BindContext,   // Handle for calling BindingAdapterComplete.
    PNDIS_STRING AdapterName,  // Name of adapter.
    PVOID SS1,                 // System specific parameter 1.
    PVOID SS2)                 // System specific parameter 2.
{
    LanInterface *Interface;  // Newly created interface.
    LLIPv6BindInfo BindInfo;  // Binding information for IP.
    GUID Guid;
    UNICODE_STRING GuidName;
    uint BindPrefixLength;
    uint MediaStatus;
    NDIS_STATUS Status;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(BindContext);
    UNREFERENCED_PARAMETER(SS1);
    UNREFERENCED_PARAMETER(SS2);

    //
    // Convert the NDIS AdapterName to a Guid.
    //
    BindPrefixLength = sizeof(IPV6_BIND_STRING_PREFIX) - sizeof(WCHAR);
    GuidName.Buffer = (PVOID)((char *)AdapterName->Buffer + BindPrefixLength);
    GuidName.Length = AdapterName->Length - BindPrefixLength;
    GuidName.MaximumLength = AdapterName->MaximumLength - BindPrefixLength;

    if (((int)GuidName.Length < 0) ||
        ! NT_SUCCESS(RtlGUIDFromString(&GuidName, &Guid))) {

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "LanBindAdapter(%.*ls) - bad guid\n",
                   AdapterName->Length / sizeof(WCHAR),
                   AdapterName->Buffer));
        *RetStatus = NDIS_STATUS_FAILURE;
        return;
    }

    //
    // Now open the adapter and get the info.
    //
    if (!LanRegister(AdapterName, &Interface)) {
        *RetStatus = NDIS_STATUS_FAILURE;
        return;
    }

    //
    // OK, we've opened the adapter.  Notify IP about it.
    //
    BindInfo.lip_context = Interface;
    BindInfo.lip_transmit = LanTransmit;
    BindInfo.lip_token = LanCreateToken;
    BindInfo.lip_close = LanCloseAdapter;
    BindInfo.lip_cleanup = LanCleanupAdapter;
    BindInfo.lip_defmtu = BindInfo.lip_maxmtu = Interface->ai_mtu;
    BindInfo.lip_hdrsize = Interface->ai_hdrsize;
    BindInfo.lip_addrlen = Interface->ai_addrlen;
    BindInfo.lip_addr = Interface->ai_addr;
    BindInfo.lip_setrtrlladdr = NULL;
    
    switch (Interface->ai_media) {
    case NdisMediumTunnel:
        BindInfo.lip_type = IF_TYPE_TUNNEL_TEREDO;

        BindInfo.lip_rdllopt = NULL;
        BindInfo.lip_wrllopt = NULL;
        BindInfo.lip_cvaddr = LanTunnelConvertAddress;
        BindInfo.lip_mclist = NULL;
        BindInfo.lip_flags = IF_FLAG_ROUTER_DISCOVERS;
        BindInfo.lip_dadxmit = 0;
        BindInfo.lip_pref = LAN_TUNNEL_DEFAULT_PREFERENCE;

        ASSERT(sizeof(TUN_CARD_ADDRESS) >= Interface->ai_addrlen);
        if (RtlEqualMemory(TUN_CARD_ADDRESS,
                           Interface->ai_addr,
                           Interface->ai_addrlen)) {
            //
            // Create random interface identifiers for link-local addresses to
            // secure them against attackers.  Only required when the adapter
            // is configured with the default MAC address.
            //
            BindInfo.lip_token = LanTunnelCreateToken;
        }
        break;

    case NdisMedium802_3:
        BindInfo.lip_type = IF_TYPE_ETHERNET;
        goto Default;

    case NdisMediumFddi:
        BindInfo.lip_type = IF_TYPE_FDDI;
        goto Default;
        
    default:
        ASSERT(! "unrecognized ai_media type");
        BindInfo.lip_type = 0;

      Default:  
        BindInfo.lip_rdllopt = LanReadLinkLayerAddressOption;
        BindInfo.lip_wrllopt = LanWriteLinkLayerAddressOption;
        BindInfo.lip_cvaddr = LanConvertAddress;
        BindInfo.lip_mclist = LanSetMulticastAddressList;
        BindInfo.lip_flags = IF_FLAG_NEIGHBOR_DISCOVERS | 
                             IF_FLAG_ROUTER_DISCOVERS | IF_FLAG_MULTICAST;
        BindInfo.lip_dadxmit = 1; // Per RFC 2462.
        BindInfo.lip_pref = 0; 
        break;
    }

    //
    // Should we create the interface in the disconnected state?
    //
    Status = DoNDISRequest(Interface, NdisRequestQueryInformation,
                           OID_GEN_MEDIA_CONNECT_STATUS,
                           &MediaStatus, sizeof MediaStatus, NULL);
    if (Status == NDIS_STATUS_SUCCESS) {
        if (MediaStatus == NdisMediaStateDisconnected) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "LanBindAdapter(%p) - media disconnect\n", Interface));
            BindInfo.lip_flags |= IF_FLAG_MEDIA_DISCONNECTED;
        }
    }

    if (CreateInterface(&Guid, &BindInfo, &Interface->ai_context) !=
                                                NDIS_STATUS_SUCCESS) {
        //
        // Attempt to create IP interface failed.  Need to close the binding.
        // LanFreeInterface will do that, as well as freeing resources.
        //
        LanFreeInterface(Interface);
        *RetStatus = NDIS_STATUS_FAILURE;
        return;
    }

    //
    // It's quite possible that during our initialization sequence,
    // LanStatus was called to indicate a media connectivity change.
    // Some adapters are bound in the non-connected state and then
    // shortly after indicate that they are connected.
    // The above connectivity query may have returned the wrong result.
    //
    // An intervening LanStatus indication will change ai_media_check
    // from MEDIA_CHECK_QUERY to MEDIA_CHECK_CONFLICT.
    //
    Status = NDIS_STATUS_FAILURE;
    KeAcquireSpinLock(&Interface->ai_lock, &OldIrql);
    while (Interface->ai_media_check == MEDIA_CHECK_CONFLICT) {
        Interface->ai_media_check = MEDIA_CHECK_QUERY;
        KeReleaseSpinLock(&Interface->ai_lock, OldIrql);

        Status = DoNDISRequest(Interface, NdisRequestQueryInformation,
                               OID_GEN_MEDIA_CONNECT_STATUS,
                               &MediaStatus, sizeof MediaStatus, NULL);

        KeAcquireSpinLock(&Interface->ai_lock, &OldIrql);
    }
    Interface->ai_media_check = MEDIA_CHECK_IDLE;
    if (Status == NDIS_STATUS_SUCCESS)
        SetInterfaceLinkStatus(Interface->ai_context,
                               MediaStatus != NdisMediaStateDisconnected);
    KeReleaseSpinLock(&Interface->ai_lock, OldIrql);

    Status = DoNDISRequest(Interface, NdisRequestSetInformation,
                           OID_GEN_CURRENT_PACKET_FILTER,
                           &Interface->ai_pfilter,
                           sizeof Interface->ai_pfilter,
                           NULL);
    if (Status == NDIS_STATUS_SUCCESS)
        Interface->ai_state = INTERFACE_UP;
    else
        Interface->ai_state = INTERFACE_DOWN;

    *RetStatus = NDIS_STATUS_SUCCESS;
}


//* LanUnbindAdapter - Unbind from an adapter.
//
//  Called when we need to unbind from an adapter.
//  We'll notify IP, then free our memory and return.
//
void NDIS_API  // Returns: Nothing.
LanUnbindAdapter(
    PNDIS_STATUS RetStatus,       // Where to return status from this call.
    NDIS_HANDLE ProtBindContext,  // Context we gave NDIS earlier.
    NDIS_HANDLE UnbindContext)    // Context for completing this request.
{
    LanInterface *Interface = (LanInterface *)ProtBindContext;

    Interface->ai_unbind = UnbindContext;

    //
    // Call IP to destroy the interface.
    // IP will call LanCloseAdapter then LanCleanupAdapter.
    //
    DestroyInterface(Interface->ai_context);

    //
    // We will call NdisCompleteUnbindAdapter later,
    // when NdisCloseAdapter completes.
    //
    *RetStatus = NDIS_STATUS_PENDING;
}


//* LanPnPEvent
//
//  Gets called for plug'n'play and power-management events.
//
NDIS_STATUS NDIS_API
LanPnPEvent(
    NDIS_HANDLE ProtocolBindingContext,
    PNET_PNP_EVENT NetPnPEvent)
{
    LanInterface *Interface = (LanInterface *) ProtocolBindingContext;

    switch (NetPnPEvent->NetEvent) {
    case NetEventSetPower: {
        NET_DEVICE_POWER_STATE PowerState;

        //
        // Get the power state of the interface.
        //
        ASSERT(NetPnPEvent->BufferLength >= sizeof PowerState);
        PowerState = * (NET_DEVICE_POWER_STATE *) NetPnPEvent->Buffer;

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - set power %u\n",
                   Interface, PowerState));

        //
        // We ignore the events that tell us about power going away.
        // But when power comes back, we query for connect status.
        // NDIS does not report connect/disconnect events that occur
        // while there is no power.
        //
        // Note that we may be redundantly setting the link status.
        // For example saying that it is disconnected when the
        // IPv6 interface status is already disconnected,
        // or vice-versa. The IPv6 code must deal with this.
        //
        if (PowerState == NetDeviceStateD0) {
            uint MediaStatus;
            NDIS_STATUS Status;
            KIRQL OldIrql;

            KeAcquireSpinLock(&Interface->ai_lock, &OldIrql);
            if (Interface->ai_media_check == MEDIA_CHECK_IDLE) {
                do {
                    Interface->ai_media_check = MEDIA_CHECK_QUERY;
                    KeReleaseSpinLock(&Interface->ai_lock, OldIrql);

                    Status = DoNDISRequest(Interface,
                                           NdisRequestQueryInformation,
                                           OID_GEN_MEDIA_CONNECT_STATUS,
                                           &MediaStatus,
                                           sizeof MediaStatus,
                                           NULL);

                    KeAcquireSpinLock(&Interface->ai_lock, &OldIrql);
                } while (Interface->ai_media_check == MEDIA_CHECK_CONFLICT);

                Interface->ai_media_check = MEDIA_CHECK_IDLE;
                if (Status == NDIS_STATUS_SUCCESS)
                    SetInterfaceLinkStatus(Interface->ai_context,
                                MediaStatus != NdisMediaStateDisconnected);
            }
            else
                Interface->ai_media_check = MEDIA_CHECK_CONFLICT;
            KeReleaseSpinLock(&Interface->ai_lock, OldIrql);
        }
        break;
    }

    case NetEventBindsComplete:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - binds complete\n", Interface));
        IPv6ProviderReady();
        break;

    case NetEventQueryPower:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - query power\n", Interface));
        break;

    case NetEventQueryRemoveDevice:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - query remove device\n", Interface));
        break;

    case NetEventCancelRemoveDevice:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - cancel remove device\n", Interface));
        break;

    case NetEventReconfigure:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - reconfigure\n", Interface));
        break;

    case NetEventBindList:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - bind list\n", Interface));
        break;

    case NetEventPnPCapabilities:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - pnp capabilities\n", Interface));
        break;

    default:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "LanPnPEvent(%p) - unknown code %u length %u\n",
                   Interface,
                   NetPnPEvent->NetEvent,
                   NetPnPEvent->BufferLength));
        break;
    }

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\init.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// General IPv6 initialization code lives here.
// Actually, this file is mostly interface/address management code.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "llip6if.h"
#include "route.h"
#include "select.h"
#include "icmp.h"
#include "neighbor.h"
#include <tdiinfo.h>
#include <tdi.h>
#include <tdikrnl.h>
#include "alloca.h"
#include "security.h"
#include "mld.h"
#include "md5.h"
#include "info.h"
#include <ntddip6.h>

extern void TCPRemoveIF(Interface *IF);
static void InterfaceStopForwarding(Interface *IF);

//
// Useful IPv6 Address Constants.
//
IPv6Addr UnspecifiedAddr = { 0 };
IPv6Addr LoopbackAddr = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
IPv6Addr AllNodesOnNodeAddr = {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
IPv6Addr AllNodesOnLinkAddr = {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
IPv6Addr AllRoutersOnLinkAddr = {0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
IPv6Addr LinkLocalPrefix = {0xfe, 0x80, };
IPv6Addr SiteLocalPrefix = {0xfe, 0xc0, };
IPv6Addr SixToFourPrefix = {0x20, 0x02, };
IPv6Addr V4MappedPrefix = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0xff, 0xff, };
IPv6Addr MulticastPrefix = {0xff, };


static uint MulticastScopes[] = {
    ADE_INTERFACE_LOCAL,
    ADE_LINK_LOCAL,
    ADE_SITE_LOCAL,
    ADE_ORG_LOCAL,
    ADE_GLOBAL
};

//
// These variables are initialized from the registry.
// See ConfigureGlobalParameters.
//
uint DefaultCurHopLimit;
uint MaxTempDADAttempts;
uint MaxTempPreferredLifetime;
uint MaxTempValidLifetime;
uint TempRegenerateTime;
uint UseTemporaryAddresses;
uint MaxTempRandomTime;
uint TempRandomTime;

#define TempPreferredLifetime     (MaxTempPreferredLifetime - TempRandomTime)

//
// Timer variables.
//
KTIMER IPv6Timer;
KDPC IPv6TimeoutDpc;
int IPv6TimerStarted = FALSE;

uint PacketPoolSize;

NDIS_HANDLE IPv6PacketPool, IPv6BufferPool;

//
// Statistics
//
IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];
CACHE_ALIGN IPSNMPInfo IPSInfo;
uint NumForwardingInterfaces;

//
// The NetTableListLock may be acquired while holding an interface lock.
//
NetTableEntry *NetTableList;  // Global list of NTEs.
KSPIN_LOCK NetTableListLock;  // Lock protecting this list.

//
// The IFListLock may be acquired while holding an interface lock
// or route lock.
//
KSPIN_LOCK IFListLock;     // Lock protecting this list.
Interface *IFList = NULL;  // List of interfaces active.

//
// The ZoneUpdateLock prevents concurrent updates
// of interface ZoneIndices.
//
KSPIN_LOCK ZoneUpdateLock;

//
// Used to assign indices to interfaces.
// See InterfaceIndex.
//
uint NextIFIndex = 0;


//* AddNTEToNetTableList
//
//  Called with the list already locked.
//
void
AddNTEToNetTableList(NetTableEntry *NTE)
{
    if (NetTableList != NULL)
        NetTableList->PrevOnNTL = &NTE->NextOnNTL;

    NTE->PrevOnNTL = &NetTableList;
    NTE->NextOnNTL = NetTableList;
    NetTableList = NTE;
    IPSInfo.ipsi_numaddr++;
}


//* RemoveNTEFromNetTableList
//
//  Called with the list already locked.
//
void
RemoveNTEFromNetTableList(NetTableEntry *NTE)
{
    NetTableEntry *NextNTE;

    NextNTE = NTE->NextOnNTL;
    *NTE->PrevOnNTL = NextNTE;
    if (NextNTE != NULL)
        NextNTE->PrevOnNTL = NTE->PrevOnNTL;
    IPSInfo.ipsi_numaddr--;
}


//* AddNTEToInterface
//
//  Adds an NTE to an Interface's list of ADEs.
//
//  Called with the interface already locked.
//
void
AddNTEToInterface(Interface *IF, NetTableEntry *NTE)
{
    //
    // The NTE holds a reference for the interface,
    // so anyone with a reference for the NTE
    // can safely dereference NTE->IF.
    //
    AddRefIF(IF);

    NTE->IF = IF;
    NTE->Next = IF->ADE;
    IF->ADE = (AddressEntry *)NTE;
}


//* RemoveNTEFromInterface
//
//  Removes a new NTE from the Interface's list of ADEs.
//
//  Called with the interface already locked.
//  The NTE must be first on the list.
//
void
RemoveNTEFromInterface(Interface *IF, NetTableEntry *NTE)
{
    ASSERT(IF->ADE == (AddressEntry *)NTE);
    IF->ADE = NTE->Next;
    ReleaseIF(IF);
}


typedef struct SynchronizeMulticastContext {
    WORK_QUEUE_ITEM WQItem;
    Interface *IF;
} SynchronizeMulticastContext;

//* SynchronizeMulticastAddresses
//
//  Synchronize the interface's list of link-layer multicast addresses
//  with the link's knowledge of those addresses.
//
//  Callable from thread context, not from DPC context.
//  Called with no locks held.
//
void
SynchronizeMulticastAddresses(void *Context)
{
    SynchronizeMulticastContext *smc = (SynchronizeMulticastContext *) Context;
    Interface *IF = smc->IF;
    void *LinkAddresses;
    LinkLayerMulticastAddress *MCastAddr;
    uint SizeofLLMA = SizeofLinkLayerMulticastAddress(IF);
    uint NumKeep, NumDeleted, NumAdded, Position;
    uint i;
    NDIS_STATUS Status;
    KIRQL OldIrql;

    ExFreePool(smc);

    //
    // First acquire the heavy-weight lock used to serialize
    // SetMCastAddrList operations.
    //
    KeWaitForSingleObject(&IF->WorkerLock, Executive, KernelMode,
                          FALSE, NULL);

    //
    // Second acquire the lock that protects the interface,
    // so we can examine IF->MCastAddresses et al.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    //
    // If this interface is going away, do nothing.
    //
    if (IsDisabledIF(IF)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "SynchronizeMulticastContext(IF %p)"
                   " - disabled (%u refs)\n", IF, IF->RefCnt));
        goto ErrorExit;
    }

    //
    // Allocate sufficient space for the link addresses
    // that we will pass to SetMCastAddrList.
    // This is actually an over-estimate.
    //
    LinkAddresses = ExAllocatePool(NonPagedPool,
                                   IF->MCastAddrNum * IF->LinkAddressLength);
    if (LinkAddresses == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "SynchronizeMulticastContext(IF %p) - no pool\n", IF));
        goto ErrorExit;
    }

    //
    // Make three passes through the address array,
    // constructing LinkAddresses.
    //

    NumKeep = 0;
    MCastAddr = IF->MCastAddresses;
    for (i = 0; i < IF->MCastAddrNum; i++) {

        if ((MCastAddr->RefCntAndFlags & LLMA_FLAG_REGISTERED) &&
            IsLLMAReferenced(MCastAddr)) {
            //
            // This address has already been registered,
            // and we are keeping it.
            //
            Position = NumKeep++;
            RtlCopyMemory(((uchar *)LinkAddresses +
                           Position * IF->LinkAddressLength),
                          MCastAddr->LinkAddress,
                          IF->LinkAddressLength);
        }

        MCastAddr = (LinkLayerMulticastAddress *)
            ((uchar *)MCastAddr + SizeofLLMA);
    }

    if (NumKeep == IF->MCastAddrNum) {
        //
        // Can happen if there are races between worker threads,
        // but should be rare.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "SynchronizeMulticastAddresses - noop?\n"));
        ExFreePool(LinkAddresses);
        goto ErrorExit;
    }

    NumAdded = 0;
    MCastAddr = IF->MCastAddresses;
    for (i = 0; i < IF->MCastAddrNum; i++) {

        if (!(MCastAddr->RefCntAndFlags & LLMA_FLAG_REGISTERED) &&
            IsLLMAReferenced(MCastAddr)) {
            //
            // This address has not been registered,
            // and we are adding it.
            // We set LLMA_FLAG_REGISTERED below,
            // after we are past all error cases.
            //
            Position = NumKeep + NumAdded++;
            RtlCopyMemory(((uchar *)LinkAddresses +
                           Position * IF->LinkAddressLength),
                          MCastAddr->LinkAddress,
                          IF->LinkAddressLength);
        }

        MCastAddr = (LinkLayerMulticastAddress *)
            ((uchar *)MCastAddr + SizeofLLMA);
    }

    NumDeleted = 0;
    MCastAddr = IF->MCastAddresses;
    for (i = 0; i < IF->MCastAddrNum; i++) {

        if ((MCastAddr->RefCntAndFlags & LLMA_FLAG_REGISTERED) &&
            !IsLLMAReferenced(MCastAddr)) {
            //
            // This address has already been registered,
            // and we are deleting it.
            //
            Position = NumKeep + NumAdded + NumDeleted++;
            RtlCopyMemory(((uchar *)LinkAddresses +
                           Position * IF->LinkAddressLength),
                          MCastAddr->LinkAddress,
                          IF->LinkAddressLength);
        }

        MCastAddr = (LinkLayerMulticastAddress *)
            ((uchar *)MCastAddr + SizeofLLMA);
    }

    //
    // Some addresses might have been added & removed
    // before being registered, so they have a zero RefCnt.
    // We do not want to notify the link-layer about them.
    //
    ASSERT(NumKeep + NumAdded + NumDeleted <= IF->MCastAddrNum);

    //
    // Remove any unreferenced addresses.
    //
    if (NumKeep + NumAdded != IF->MCastAddrNum) {
        LinkLayerMulticastAddress *NewMCastAddresses;
        LinkLayerMulticastAddress *NewMCastAddr;
        LinkLayerMulticastAddress *MCastAddrMark;
        LinkLayerMulticastAddress *NextMCastAddr;
        UINT_PTR Length;

        if (NumKeep + NumAdded == 0) {
            //
            // None left.
            //
            NewMCastAddresses = NULL;
        }
        else {
            NewMCastAddresses = ExAllocatePool(NonPagedPool,
                ((NumKeep + NumAdded) * SizeofLLMA));
            if (NewMCastAddresses == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "SynchronizeMulticastContext(IF %p)"
                           " - no pool\n", IF));
                ExFreePool(LinkAddresses);
                goto ErrorExit;
            }

            //
            // Copy the addresses that are still referenced
            // to the new array. Normally there will only be
            // one unreferenced address, so it's faster to search
            // for it and then copy the elements before and after.
            // Of course there might be multiple unreferenced addresses.
            //
            NewMCastAddr = NewMCastAddresses;
            MCastAddrMark = IF->MCastAddresses;
            for (i = 0, MCastAddr = IF->MCastAddresses;
                 i < IF->MCastAddrNum;
                 i++, MCastAddr = NextMCastAddr) {

                NextMCastAddr = (LinkLayerMulticastAddress *)
                    ((uchar *)MCastAddr + SizeofLLMA);

                if (!IsLLMAReferenced(MCastAddr)) {
                    //
                    // Remove this address because it has no references.
                    //
                    if (MCastAddrMark < MCastAddr) {
                        Length = (uchar *)MCastAddr - (uchar *)MCastAddrMark;
                        RtlCopyMemory(NewMCastAddr, MCastAddrMark, Length);
                        NewMCastAddr = (LinkLayerMulticastAddress *)
                            ((uchar *)NewMCastAddr + Length);
                    }
                    MCastAddrMark = NextMCastAddr;
                }
                else {
                    //
                    // Remember that we are registering this address.
                    //
                    MCastAddr->RefCntAndFlags |= LLMA_FLAG_REGISTERED;
                }
            }

            if (MCastAddrMark < MCastAddr) {
                Length = (uchar *)MCastAddr - (uchar *)MCastAddrMark;
                RtlCopyMemory(NewMCastAddr, MCastAddrMark, Length);
            }
        }

        ExFreePool(IF->MCastAddresses);
        IF->MCastAddresses = NewMCastAddresses;
        IF->MCastAddrNum = NumKeep + NumAdded;
    }
    else {
        //
        // We need to set LLMA_FLAG_REGISTERED.
        //
        MCastAddr = IF->MCastAddresses;
        for (i = 0; i < IF->MCastAddrNum; i++) {

            MCastAddr->RefCntAndFlags |= LLMA_FLAG_REGISTERED;

            MCastAddr = (LinkLayerMulticastAddress *)
                ((uchar *)MCastAddr + SizeofLLMA);
        }
    }

    //
    // We have constructed the LinkAddresses array from the interface.
    // Before we can call SetMCastAddrList, we must drop the interface lock.
    // We still hold the heavy-weight WorkerLock, so multiple SetMCastAddrList
    // calls are properly serialized.
    //
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    //
    // Pass the multicast link addresses down to the link layer,
    // if there's actually anything changed.
    //
    if (NumAdded + NumDeleted == 0) {
        //
        // Can happen if there are races between worker threads,
        // but should be very rare.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "SynchronizeMulticastAddresses - noop?\n"));
    }
    else {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "SynchronizeMulticastAddresses(IF %p) %u + %u + %u\n",
                   IF, NumKeep, NumAdded, NumDeleted));
        Status = (*IF->SetMCastAddrList)(IF->LinkContext, LinkAddresses,
                                         NumKeep, NumAdded, NumDeleted);
        if (Status != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "SynchronizeMulticastAddresses(%p) -> %x\n", IF, Status));
        }
    }

    KeReleaseMutex(&IF->WorkerLock, FALSE);
    ExFreePool(LinkAddresses);
    ReleaseIF(IF);
    return;

  ErrorExit:
    KeReleaseSpinLock(&IF->Lock, OldIrql);
    KeReleaseMutex(&IF->WorkerLock, FALSE);
    ReleaseIF(IF);
}

//* DeferSynchronizeMulticastAddresses
//
//  Because SynchronizeMulticastAddresses can only be called
//  from a thread context with no locks held, this function
//  provides a way to defer a call to SynchronizeMulticastAddresses
//  when running at DPC level.
//
//  In error cases (memory allocation failure),
//  we return with IF_FLAG_MCAST_SYNC still set,
//  so we will be called again later.
//
//  Called with the interface lock held.
//
void
DeferSynchronizeMulticastAddresses(Interface *IF)
{
    SynchronizeMulticastContext *smc;

    smc = ExAllocatePool(NonPagedPool, sizeof *smc);
    if (smc == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "DeferSynchronizeMulticastAddresses - no pool\n"));
        return;
    }

    ExInitializeWorkItem(&smc->WQItem, SynchronizeMulticastAddresses, smc);
    smc->IF = IF;
    AddRefIF(IF);
    IF->Flags &= ~IF_FLAG_MCAST_SYNC;

    ExQueueWorkItem(&smc->WQItem, CriticalWorkQueue);
}

//* CheckLinkLayerMulticastAddress
//
//  Is the interface receiving this link-layer multicast address?
//
//  Callable from thread or DPC context.
//  Called with no locks held.
//
int
CheckLinkLayerMulticastAddress(Interface *IF, const void *LinkAddress)
{
    if (IF->SetMCastAddrList == NULL) {
        //
        // The interface does not track multicast link-layer addresses.
        // For example, point-to-point or loopback interfaces.
        // We must assume that the interface wants to receive all
        // link-layer multicasts.
        //
        return TRUE;
    }
    else {
        KIRQL OldIrql;
        LinkLayerMulticastAddress *MCastAddr;
        uint SizeofLLMA = SizeofLinkLayerMulticastAddress(IF);
        uint i;
        int Found = FALSE;

        KeAcquireSpinLock(&IF->Lock, &OldIrql);
        MCastAddr = IF->MCastAddresses;
        for (i = 0; i < IF->MCastAddrNum; i++) {
            //
            // Have we found the link-layer address?
            //
            if (RtlCompareMemory(MCastAddr->LinkAddress, LinkAddress,
                                 IF->LinkAddressLength) ==
                                            IF->LinkAddressLength) {
                if (IsLLMAReferenced(MCastAddr))
                    Found = TRUE;
                break;
            }

            MCastAddr = (LinkLayerMulticastAddress *)
                ((uchar *)MCastAddr + SizeofLLMA);
        }
        KeReleaseSpinLock(&IF->Lock, OldIrql);

        return Found;
    }
}

//* AddLinkLayerMulticastAddress
//
//  Called to indicate interest in the link-layer multicast address
//  corresponding to the supplied IPv6 multicast address.
//
//  Called with the interface locked.
//
void
AddLinkLayerMulticastAddress(Interface *IF, const IPv6Addr *Address)
{
    //
    // If the interface doesn't keep track of link-layer multicast
    // addresses (e.g., if it's P2P), we don't need to do anything.
    //
    if (IF->SetMCastAddrList != NULL) {
        void *LinkAddress = alloca(IF->LinkAddressLength);
        LinkLayerMulticastAddress *MCastAddr;
        uint SizeofLLMA = SizeofLinkLayerMulticastAddress(IF);
        uint i;

        //
        // Create the link-layer multicast address
        // that corresponds to the IPv6 multicast address.
        //
        (*IF->ConvertAddr)(IF->LinkContext, Address, LinkAddress);
    
        //
        // Check if the link-layer multicast address is already present.
        //
    
        MCastAddr = IF->MCastAddresses;
        for (i = 0; i < IF->MCastAddrNum; i++) {
            //
            // Have we found the link-layer address?
            //
            if (RtlCompareMemory(MCastAddr->LinkAddress, LinkAddress,
                                 IF->LinkAddressLength) ==
                                            IF->LinkAddressLength)
                goto FoundMCastAddr;
    
            MCastAddr = (LinkLayerMulticastAddress *)
                ((uchar *)MCastAddr + SizeofLLMA);
        }
    
        //
        // We must add this link-layer multicast address.
        //
    
        MCastAddr = ExAllocatePool(NonPagedPool,
                                   (IF->MCastAddrNum + 1) * SizeofLLMA);
        if (MCastAddr == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "AddLinkLayerMulticastAddress - no pool\n"));
            return;
        }
    
        if (IF->MCastAddresses != NULL) {
            RtlCopyMemory(MCastAddr, IF->MCastAddresses,
                          IF->MCastAddrNum * SizeofLLMA);
            ExFreePool(IF->MCastAddresses);
        }

        IF->MCastAddresses = MCastAddr;

        MCastAddr = (LinkLayerMulticastAddress *)
            ((uchar *)MCastAddr + IF->MCastAddrNum * SizeofLLMA);
        MCastAddr->RefCntAndFlags = 0;
        RtlCopyMemory(MCastAddr->LinkAddress, LinkAddress, IF->LinkAddressLength);

        IF->MCastAddrNum++;
        IF->Flags |= IF_FLAG_MCAST_SYNC;

      FoundMCastAddr:
        AddRefLLMA(MCastAddr);
    }
}

//* DelLinkLayerMulticastAddress
//
//  Called to retract interest in the link-layer multicast address
//  corresponding to the supplied IPv6 multicast address.
//
//  Called with the interface locked.
//
void
DelLinkLayerMulticastAddress(Interface *IF, IPv6Addr *Address)
{
    //
    // If the interface doesn't keep track of link-layer multicast
    // addresses (e.g., if it's P2P), we don't need to do anything.
    //
    if (IF->SetMCastAddrList != NULL) {
        void *LinkAddress = alloca(IF->LinkAddressLength);
        LinkLayerMulticastAddress *MCastAddr;
        uint SizeofLLMA = SizeofLinkLayerMulticastAddress(IF);
        uint i;

        //
        // Create the link-layer multicast address
        // that corresponds to the IPv6 multicast address.
        //
        (*IF->ConvertAddr)(IF->LinkContext, Address, LinkAddress);

        //
        // Find the link-layer multicast address.
        // It must be present, but if it isn't, we avoid crashing.
        //

        MCastAddr = IF->MCastAddresses;
        for (i = 0; i < IF->MCastAddrNum; i++) {

            //
            // Have we found the link-layer address?
            //
            if (RtlCompareMemory(MCastAddr->LinkAddress, LinkAddress,
                                 IF->LinkAddressLength) ==
                                                IF->LinkAddressLength) {
                //
                // Decrement the address's refcount.
                // If it hits zero, indicate a need to synchronize.
                //
                ASSERT(IsLLMAReferenced(MCastAddr));
                ReleaseLLMA(MCastAddr);
                if (!IsLLMAReferenced(MCastAddr))
                    IF->Flags |= IF_FLAG_MCAST_SYNC;
                break;
            }

            MCastAddr = (LinkLayerMulticastAddress *)
                ((uchar *)MCastAddr + SizeofLLMA);
        }
        ASSERT(i != IF->MCastAddrNum);
    }
}

//* RestartLinkLayerMulticast
//
//  Resets the status of link-layer multicast addresses,
//  so that they are registered again with the link layer.
//  The ResetDone function is called under a lock that serializes
//  it with SetMCastAddrList calls.
//
//  Callable from thread context, not DPC context.
//
void
RestartLinkLayerMulticast(
    void *Context,
    void (*ResetDone)(void *Context))
{
    Interface *IF = (Interface *) Context;
    KIRQL OldIrql;

    ASSERT(IF->SetMCastAddrList != NULL);

    //
    // Serialize with SetMCastAddrList operations.
    //
    KeWaitForSingleObject(&IF->WorkerLock, Executive, KernelMode,
                          FALSE, NULL);

    //
    // So we can play with IF->MCastAddresses et al.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    //
    // If this interface is going away, do nothing.
    //
    if (IsDisabledIF(IF)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "RestartLinkLayerMulticast(IF %p)"
                   " - disabled (%u refs)\n", IF, IF->RefCnt));
        KeReleaseSpinLock(&IF->Lock, OldIrql);
    }
    else {
        LinkLayerMulticastAddress *MCastAddr;
        uint SizeofLLMA = SizeofLinkLayerMulticastAddress(IF);
        uint i;

        //
        // Reset the registered flag for all multicast addresses.
        //

        MCastAddr = IF->MCastAddresses;
        for (i = 0; i < IF->MCastAddrNum; i++) {
            if (IsLLMAReferenced(MCastAddr)) {
                MCastAddr->RefCntAndFlags &= ~LLMA_FLAG_REGISTERED;
                IF->Flags |= IF_FLAG_MCAST_SYNC;
            }

            MCastAddr = (LinkLayerMulticastAddress *)
                ((uchar *)MCastAddr + SizeofLLMA);
        }

        if (IsMCastSyncNeeded(IF))
            DeferSynchronizeMulticastAddresses(IF);
        KeReleaseSpinLock(&IF->Lock, OldIrql);

        //
        // Let the link-layer know that the reset is done.
        //
        (*ResetDone)(IF->LinkContext);
    }

    KeReleaseMutex(&IF->WorkerLock, FALSE);
}


typedef enum {
    CONTROL_LOOPBACK_DISABLED,
    CONTROL_LOOPBACK_ENABLED,
    CONTROL_LOOPBACK_DESTROY
} ControlLoopbackOp;

//* ControlLoopback
//
//  Controls loopback functionality for a unicast or anycast address.
//
//  This function is used in three ways, depending on Op:
//  create a disabled loopback route (or disable an existing route),
//  create an enabled loopback route (or enable an existing route),
//  destroy any existing loopback route.
//
//  It returns FALSE if there is a resource shortage.
//  In actual usage, it will only fail when an NTE/AAE
//  is first created, because subsequently the RTE and NCE
//  will already exist.
//
//  Called with the interface lock held.
//
int
ControlLoopback(Interface *IF, const IPv6Addr *Address,
                ControlLoopbackOp Op)
{
    NeighborCacheEntry *NCE;
    int Loopback;
    uint Lifetime;
    uint Type;
    int rc;
    NTSTATUS Status;

    switch (Op) {
    case CONTROL_LOOPBACK_DISABLED:
        Loopback = FALSE;
        Lifetime = 0;
        Type = RTE_TYPE_SYSTEM;
        break;

    case CONTROL_LOOPBACK_ENABLED:
        Loopback = TRUE;
        Lifetime = INFINITE_LIFETIME;
        Type = RTE_TYPE_SYSTEM;
        break;

    case CONTROL_LOOPBACK_DESTROY:
        Loopback = FALSE;
        Lifetime = 0;
        Type = 0; // Special value for destroying system routes.
        break;

    default:
        ABORTMSG("ControlLoopback bad op");
        return FALSE;
    }

    //
    // Get the NCE for this address.
    //
    NCE = FindOrCreateNeighbor(IF, Address);
    if (NCE == NULL)
        return FALSE;

    //
    // Update the loopback route for this address.
    //
    Status = RouteTableUpdate(NULL, // System update.
                              IF, NCE, Address, IPV6_ADDRESS_LENGTH, 0,
                              Lifetime, Lifetime,
                              ROUTE_PREF_LOOPBACK,
                              Type,
                              FALSE, FALSE);
    if (NT_SUCCESS(Status)) {
        //
        // Update the address's loopback status in the neighbor cache.
        //
        ControlNeighborLoopback(NCE, Loopback);
        rc = TRUE;
    }
    else {
        //
        // If RouteTableUpdate failed because the interface is
        // being destroyed, then we succeed without doing anything.
        //
        rc = (Status == STATUS_INVALID_PARAMETER_1);
    }

    ReleaseNCE(NCE);
    return rc;
}


//* DeleteMAE
//
//  Cleanup and delete an MAE because the multicast address
//  is no longer assigned to the interface.
//  It is already removed from the interface's list.
//  
//  Called with the interface already locked.
//
void
DeleteMAE(Interface *IF, MulticastAddressEntry *MAE)
{
    int SendDoneMsg;

    KeAcquireSpinLockAtDpcLevel(&QueryListLock);
    if (!IsDisabledIF(IF) && (MAE->MCastFlags & MAE_LAST_REPORTER)) {
        //
        // We need to send a Done message.
        // Put the MAE on the QueryList with a zero timer.
        //
        if (MAE->MCastTimer == 0)
            AddToQueryList(MAE);
        else
            MAE->MCastTimer = 0;
        AddRefIF(IF);
        MAE->IF = IF;

        SendDoneMsg = TRUE;
    }
    else {
        //
        // If the MLD timer is running, remove from the query list.
        //
        if (MAE->MCastTimer != 0)
            RemoveFromQueryList(MAE);

        SendDoneMsg = FALSE;
    }
    KeReleaseSpinLockFromDpcLevel(&QueryListLock);

    //
    // Retract our interest in the corresponding
    // link-layer multicast address.
    //
    DelLinkLayerMulticastAddress(IF, &MAE->Address);

    //
    // Delete the MAE, unless we left it on the QueryList
    // pending a Done message.
    //
    if (!SendDoneMsg)
        ExFreePool(MAE);
}


//* FindAndReleaseMAE
//
//  Finds the MAE for a multicast address and releases one reference
//  for the MAE. May result in the MAE disappearing.
//
//  If successful, returns the MAE.
//  Note that it may be an invalid pointer!
//  Returns NULL on failure.
//  
//  Called with the interface already locked.
//
MulticastAddressEntry *
FindAndReleaseMAE(Interface *IF, const IPv6Addr *Addr)
{
    AddressEntry **pADE;
    MulticastAddressEntry *MAE;

    pADE = FindADE(IF, Addr);
    MAE = (MulticastAddressEntry *) *pADE;
    if (MAE != NULL) {
        if (MAE->Type == ADE_MULTICAST) {
            ASSERT(MAE->MCastRefCount != 0);

            if (--MAE->MCastRefCount == 0) {
                //
                // The MAE has no more references.
                // Remove it from the Interface and delete it.
                //
                *pADE = MAE->Next;
                DeleteMAE(IF, MAE);
            }
        }
        else {
            //
            // Return NULL for error.
            //
            MAE = NULL;
        }
    }

    return MAE;
}


//* FindAndReleaseSolicitedNodeMAE
//
//  Finds the MAE for the corresponding solicited-node multicast address
//  and releases one reference for the MAE.
//  May result in the MAE disappearing.
//
//  Called with the interface already locked.
//
void
FindAndReleaseSolicitedNodeMAE(Interface *IF, const IPv6Addr *Addr)
{
    if (IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) {
        IPv6Addr MCastAddr;
        MulticastAddressEntry *MAE;

        //
        // Create the corresponding solicited-node multicast address.
        //
        CreateSolicitedNodeMulticastAddress(Addr, &MCastAddr);

        //
        // Release the MAE for the solicited-node address.
        // NB: This may fail during interface shutdown
        // if we remove the solicited-node MAE before the NTE or AAE.
        //
        MAE = FindAndReleaseMAE(IF, &MCastAddr);
        ASSERT((MAE != NULL) || IsDisabledIF(IF));
    }
}


//* FindOrCreateMAE
//
//  If an MAE for the multicast address already exists,
//  just bump the reference count. Otherwise create a new MAE.
//  Returns NULL for failure.
//
//  If an NTE is supplied and an MAE is created,
//  then the MAE is associated with the NTE.
//
//  Called with the interface already locked.
//
MulticastAddressEntry *
FindOrCreateMAE(
    Interface *IF,
    const IPv6Addr *Addr,
    NetTableEntry *NTE)
{
    AddressEntry **pADE;
    MulticastAddressEntry *MAE;

    //
    // Can not create a new MAE if the interface is shutting down.
    //
    if (IsDisabledIF(IF))
        return NULL;

    pADE = FindADE(IF, Addr);
    MAE = (MulticastAddressEntry *) *pADE;

    if (MAE == NULL) {
        //
        // Create a new MAE.
        //
        MAE = ExAllocatePool(NonPagedPool, sizeof(MulticastAddressEntry));
        if (MAE == NULL)
            return NULL;

        //
        // Initialize the new MAE.
        //
        if (NTE != NULL)
            MAE->NTE = NTE;
        else
            MAE->IF = IF;
        MAE->Address = *Addr;
        MAE->Type = ADE_MULTICAST;
        MAE->Scope = MulticastAddressScope(Addr);
        MAE->MCastRefCount = 0; // Incremented below.
        MAE->MCastTimer = 0;
        MAE->NextQL = NULL;

        //
        // With any luck the compiler will optimize these
        // field assignments...
        //
        if (IsMLDReportable(MAE)) {
            //
            // We should send MLD reports for this address.
            // Start by sending initial reports immediately.
            //
            MAE->MCastFlags = MAE_REPORTABLE;
            MAE->MCastCount = MLD_NUM_INITIAL_REPORTS;
            MAE->MCastTimer = 1; // Immediately.
            KeAcquireSpinLockAtDpcLevel(&QueryListLock);
            AddToQueryList(MAE);
            KeReleaseSpinLockFromDpcLevel(&QueryListLock);
        }
        else {
            MAE->MCastFlags = 0;
            MAE->MCastCount = 0;
            MAE->MCastTimer = 0;
        }

        //
        // Add the MAE to the interface's ADE list.
        //
        MAE->Next = NULL;
        *pADE = (AddressEntry *)MAE;

        //
        // Indicate our interest in the corresponding
        // link-layer multicast address.
        //
        AddLinkLayerMulticastAddress(IF, Addr);
    }
    else {
        ASSERT(MAE->Type == ADE_MULTICAST);
    }

    MAE->MCastRefCount++;
    return MAE;
}


//* FindOrCreateSolicitedNodeMAE
//
//  Called with a unicast or anycast address.
//
//  If an MAE for the solicited-node multicast address already exists,
//  just bump the reference count. Otherwise create a new MAE.
//  Returns TRUE for success.
//
//  Called with the interface already locked.
//
int
FindOrCreateSolicitedNodeMAE(Interface *IF, const IPv6Addr *Addr)
{
    if (IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) {
        IPv6Addr MCastAddr;

        //
        // Create the corresponding solicited-node multicast address.
        //
        CreateSolicitedNodeMulticastAddress(Addr, &MCastAddr);

        //
        // Find or create an MAE for the solicited-node multicast address.
        //
        return FindOrCreateMAE(IF, &MCastAddr, NULL) != NULL;
    }
    else {
        //
        // Only interfaces that support Neighbor Discovery
        // use solicited-node multicast addresses.
        //
        return TRUE;
    }
}


//* FindOrCreateAAE
//
//  Adds an anycast address to the interface,
//  associated with the NTE.
//
//  If the interface already has the anycast address assigned,
//  then this does nothing.
//
//  Returns TRUE for success.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
int
FindOrCreateAAE(Interface *IF, const IPv6Addr *Addr,
                NetTableEntryOrInterface *NTEorIF)
{
    AddressEntry **pADE;
    AnycastAddressEntry *AAE;
    KIRQL OldIrql;
    int rc;

    if (NTEorIF == NULL)
        NTEorIF = CastFromIF(IF);

    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    if (IsDisabledIF(IF)) {
        //
        // Can't create a new AAE if the interface is shutting down.
        //
        rc = FALSE;
    }
    else {
        pADE = FindADE(IF, Addr);
        AAE = (AnycastAddressEntry *) *pADE;
        if (AAE == NULL) {
            //
            // Create an AAE for the anycast address.
            //
            AAE = ExAllocatePool(NonPagedPool, sizeof(AnycastAddressEntry));
            if (AAE == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "FindOrCreateAAE: no pool\n"));
                rc = FALSE;
                goto ErrorReturn;
            }

            //
            // Initialize the new AAE.
            //
            AAE->NTEorIF = NTEorIF;
            AAE->Address = *Addr;
            AAE->Type = ADE_ANYCAST;
            AAE->Scope = UnicastAddressScope(Addr);

            //
            // Add the AAE to the interface's ADE list.
            // NB: FindOrCreateSolicitedNodeMAE may add an MAE at the end,
            // so we do this first.
            //
            AAE->Next = NULL;
            *pADE = (AddressEntry *)AAE;

            //
            // Create the corresponding solicited-node
            // multicast address MAE.
            //
            rc = FindOrCreateSolicitedNodeMAE(IF, Addr);
            if (! rc) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "FindOrCreateAAE: "
                           "FindOrCreateSolicitedNodeMAE failed\n"));
                goto ErrorReturnFreeAAE;
            }

            //
            // Create a loopback route for this address.
            //
            rc = ControlLoopback(IF, Addr, CONTROL_LOOPBACK_ENABLED);
            if (! rc) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                           "FindOrCreateAAE: "
                           "ControlLoopback failed\n"));
                FindAndReleaseSolicitedNodeMAE(IF, Addr);

            ErrorReturnFreeAAE:
                //
                // An MAE may have been added & removed above,
                // but at this point the AAE should be last.
                //
                ASSERT((*pADE == (AddressEntry *)AAE) && (AAE->Next == NULL));
                *pADE = NULL;
                ExFreePool(AAE);

            ErrorReturn:
                ;
            }
        }
        else {
            //
            // The ADE already exists -
            // just verify that it is anycast.
            //
            rc = (AAE->Type == ADE_ANYCAST);
        }

        if (IsMCastSyncNeeded(IF))
            DeferSynchronizeMulticastAddresses(IF);
    }
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return rc;
}


//* DeleteAAE
//
//  Cleanup and delete an AAE.
//  It is already removed from the interface's list.
//
//  Called with the interface lock held.
//
void
DeleteAAE(Interface *IF, AnycastAddressEntry *AAE)
{
    int rc;

    //
    // The corresponding solicited-node address is not needed.
    //
    FindAndReleaseSolicitedNodeMAE(IF, &AAE->Address);

    //
    // The loopback route is not needed.
    //
    rc = ControlLoopback(IF, &AAE->Address, CONTROL_LOOPBACK_DESTROY);
    ASSERT(rc);

    ExFreePool(AAE);
}


//* FindAndDeleteAAE
//
//  Deletes an anycast address from the interface.
//  Returns TRUE for success.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
int
FindAndDeleteAAE(Interface *IF, const IPv6Addr *Addr)
{
    AddressEntry **pADE;
    AnycastAddressEntry *AAE;
    KIRQL OldIrql;
    int rc;

    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    pADE = FindADE(IF, Addr);
    AAE = (AnycastAddressEntry *) *pADE;
    if (AAE != NULL) {
        if (AAE->Type == ADE_ANYCAST) {
            //
            // Delete the AAE.
            //
            *pADE = AAE->Next;
            DeleteAAE(IF, AAE);
            rc = TRUE;
        }
        else {
            //
            // This is an error - it should be anycast.
            //
            rc = FALSE;
        }
    }
    else {
        //
        // If the address already doesn't exist, then OK.
        //
        rc = TRUE;
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return rc;
}


//* LeaveGroupAtAllScopes
//
//  Leave a multicast group at all scopes.
//  Called with the interface already locked.
//
void
LeaveGroupAtAllScopes(Interface *IF, IPv6Addr *GroupAddr, uint MaxScope)
{
    IPv6Addr Address = *GroupAddr;
    MulticastAddressEntry *MAE;
    uint i;

    for (i = 0;
         ((i < sizeof MulticastScopes / sizeof MulticastScopes[0]) &&
          (MulticastScopes[i] <= MaxScope));
         i++) {

        Address.s6_bytes[1] = (UCHAR)((Address.s6_bytes[1] & 0xf0) |
                               MulticastScopes[i]);
        MAE = FindAndReleaseMAE(IF, &Address);
        ASSERT(MAE != NULL);
    }
}


//* JoinGroupAtAllScopes
//
//  Join a multicast group at all scopes up to the specified scope.
//  Returns TRUE for success.
//  Called with the interface already locked.
//
int
JoinGroupAtAllScopes(Interface *IF, IPv6Addr *GroupAddr, uint MaxScope)
{
    IPv6Addr Address = *GroupAddr;
    MulticastAddressEntry *MAE;
    uint i;

    for (i = 0;
         ((i < sizeof MulticastScopes / sizeof MulticastScopes[0]) &&
          (MulticastScopes[i] <= MaxScope));
         i++) {

        Address.s6_bytes[1] = (UCHAR)((Address.s6_bytes[1] & 0xf0) | 
                               MulticastScopes[i]);
        MAE = FindOrCreateMAE(IF, &Address, NULL);
        if (MAE == NULL) {
            //
            // Failure. Leave the groups that we did manage to join.
            //
            if (i != 0)
                LeaveGroupAtAllScopes(IF, GroupAddr, MulticastScopes[i-1]);
            return FALSE;
        }
    }

    return TRUE;
}


//* DestroyADEs
//
//  Destroy all AddressEntries that reference an NTE.
//
//  Called with the interface already locked.
//
//  (Actually, we are at DPC level because we hold the interface lock.)
//
void
DestroyADEs(Interface *IF, NetTableEntry *NTE)
{
    AddressEntry *AnycastList = NULL;
    AddressEntry *ADE, **PrevADE;

    PrevADE = &IF->ADE;
    while ((ADE = *PrevADE) != NULL) {
        if (ADE == (AddressEntry *)NTE) {
            //
            // Remove the NTE from the list but do not
            // free the memory - that happens later.
            //
            *PrevADE = ADE->Next;
        }
        else if (ADE->NTE == NTE) {
            //
            // Remove this ADE because it references the NTE.
            //
            *PrevADE = ADE->Next;

            switch (ADE->Type) {
            case ADE_UNICAST:
                ABORTMSG("DestroyADEs: unicast ADE?\n");
                break;

            case ADE_ANYCAST: {
                //
                // We can't call FindAndReleaseSolicitedNodeMAE here
                // because it could mess up our list traversal.
                // So put the ADE on our temporary list and do it later.
                //
                ADE->Next = AnycastList;
                AnycastList = ADE;
                break;
            }

            case ADE_MULTICAST: {
                MulticastAddressEntry *MAE = (MulticastAddressEntry *) ADE;

                DeleteMAE(IF, MAE);
                break;
            }
            }
        }
        else {
            if (ADE->Type == ADE_UNICAST) {
                TempNetTableEntry *TempNTE = (TempNetTableEntry *) ADE;

                if ((TempNTE->AddrConf == ADDR_CONF_TEMPORARY) &&
                    (TempNTE->Public == NTE)) {
                    //
                    // Break the public/temporary association
                    // and invalidate the temporary address.
                    // We can't use DestroyNTE directly here
                    // because it would mess up our traversal.
                    //
                    TempNTE->Public = NULL;
                    TempNTE->ValidLifetime = 0;
                    TempNTE->PreferredLifetime = 0;
                }
            }

            PrevADE = &ADE->Next;
        }
    }

    //
    // Now we can safely process the anycast ADEs.
    //
    while ((ADE = AnycastList) != NULL) {
        AnycastList = ADE->Next;
        DeleteAAE(IF, (AnycastAddressEntry *)ADE);
    }
}


//* FindADE - find an ADE entry for the given interface.
//
//  If the address is assigned to the interface,
//  returns the address of the link pointing to the ADE.
//  Otherwise returns a pointer to the link (currently NULL)
//  where a new ADE should be added to extend the list.
//
//  The caller must lock the IF before calling this function.
//
AddressEntry **
FindADE(
    Interface *IF,
    const IPv6Addr *Addr)
{
    AddressEntry **pADE, *ADE;

    //
    // Check if address is assigned to the interface using the
    // interface's ADE list.
    //
    // REVIEW: Change the ADE list to a more efficient data structure?
    //
    for (pADE = &IF->ADE; (ADE = *pADE) != NULL; pADE = &ADE->Next) {
        if (IP6_ADDR_EQUAL(Addr, &ADE->Address))
            break;
    }

    return pADE;
}


//* FindAddressOnInterface
//
//  Looks for an ADE on the interface.
//  If a unicast ADE is found, returns the ADE (an NTE) and ADE_UNICAST.
//  If a multicast/anycast ADE is found, returns ADE->NTEorIF and ADE->Type.
//  If an ADE is not found, returns the interface and ADE_NONE.
//  Whether the interface or an NTE is returned,
//  the return value (if non-NULL) holds a reference.
//
//  Returns NULL only if the interface is disabled.
//
//  In normal usage, callers should hold a reference
//  for the interface. (So if the interface is returned,
//  it is returned with a second reference.) But in some
//  paths (for example IPv6Receive/IPv6HeaderReceive),
//  the caller knows the interface exists but does not
//  hold a reference for it.
//
//  Callable from DPC context, not from thread context.
//
NetTableEntryOrInterface *
FindAddressOnInterface(
    Interface *IF,
    const IPv6Addr *Addr,
    ushort *AddrType)
{
    AddressEntry *ADE;
    NetTableEntryOrInterface *NTEorIF;

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    if (IsDisabledIF(IF)) {

        NTEorIF = NULL;
    }
    else if ((ADE = *FindADE(IF, Addr)) != NULL) {

        if ((*AddrType = ADE->Type) == ADE_UNICAST) {
            NTEorIF = CastFromNTE((NetTableEntry *)ADE);
            goto ReturnNTE;
        }
        else {
            NTEorIF = ADE->NTEorIF;
            if (IsNTE(NTEorIF))
            ReturnNTE:
                AddRefNTE(CastToNTE(NTEorIF));
            else
                goto ReturnIF;
        }
    }
    else {

        *AddrType = ADE_NONE;
        NTEorIF = CastFromIF(IF);

    ReturnIF:
        AddRefIF(CastToIF(NTEorIF));
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
    return NTEorIF;
}


//
// We keep track of the number of outstanding
// register-net-address work items.
// (Using InterlockedIncrement/InterlockedDecrement.)
// This way we can wait in the IPUnload
// until they are all done.
//
ULONG OutstandingRegisterNetAddressCount = 0;

//
// Note that this structure wouldn't be needed if IoQueueWorkItem
// had been designed to call the user's routine with the WorkItem
// as an additional argument along with the DeviceObject and Context.
// Sigh.
//
typedef struct RegisterNetAddressContext {
    PIO_WORKITEM WorkItem;
    NetTableEntry *NTE;
} RegisterNetAddressContext;

//* RegisterNetAddressWorker - De/Registers an address with TDI.
//
//  Worker function for calling TdiRegisterNetAddress.
//
//  Called to register or deregister an address with TDI when any one of
//  the following two events occur...
//
//  1. The corresponding NTE's DADState changes between valid/invalid
//  states while its interface's media state is connected.
//
//  2. The corresponding NTE's interface media state changes between
//  connected/disconnected while its DADState is DAD_STATE_PREFERRED.
//  For this case, DisconnectADEs queues a worker on the connect to
//  disconnect transition whereas on the reverse transition the worker
//  is queued at the completion the duplicate address detection.
//
//  Since TdiRegisterNetAddress must be called when running at
//  IRQL < DISPATCH_LEVEL, we use this function via a worker thread.
//
//  Called with a reference held on the NTE, which we release on exit.
//
void
RegisterNetAddressWorker(
    PDEVICE_OBJECT DevObj,  // Unused.  Wish they passed the WorkItem instead.
    PVOID Context)          // A RegisterNetAddressContext struct.
{
    RegisterNetAddressContext *MyContext = Context;
    NetTableEntry *NTE = MyContext->NTE;
    Interface *IF = NTE->IF;
    int ShouldBeRegistered;
    KIRQL OldIrql;
    NTSTATUS Status;
    uint ScopeId;

    UNREFERENCED_PARAMETER(DevObj);

    IoFreeWorkItem(MyContext->WorkItem);
    ExFreePool(MyContext);

    //
    // The heavy-weight WorkerLock protects this code against
    // multiple instantiations of itself without raising IRQL.
    //
    KeWaitForSingleObject(&IF->WorkerLock, Executive, KernelMode,
                          FALSE, NULL);

    //
    // Figure out what state we should be in.
    // Note that IF->Lock protects DADState and IF->Flags,
    // while IF->WorkerLock protects TdiRegistrationHandle.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    //
    // An address should be registered with TDI iff it is in the
    // preferred DAD state and its corresponding interface is
    // connected.
    //
    ShouldBeRegistered = ((NTE->DADState == DAD_STATE_PREFERRED) &&
                          !(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED));
    KeReleaseSpinLock(&IF->Lock, OldIrql);


    //
    // DetermineScopeId is correct, not IF->ZoneIndices[NTE->Scope] 
    // because we register "external" scopeids with TDI not internal 
    // scopeids.
    // 
    ScopeId = DetermineScopeId(&NTE->Address, IF);

    //
    // We need to deregister the existing address if it shouldn't be 
    // registered any longer, or if we need to register a new address 
    // due to a scope id change.
    //
    if ((NTE->TdiRegistrationHandle != NULL) &&
        (!ShouldBeRegistered ||
         (NTE->TdiRegistrationScopeId != ScopeId))) {

        Status = TdiDeregisterNetAddress(NTE->TdiRegistrationHandle);
        if (Status == STATUS_SUCCESS) {

            NTE->TdiRegistrationHandle = NULL;
        }
        else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "RegisterNetAddressWorker: "
                       "TdiDeregisterNetAddress(%d/%s): %x\n",
                       IF->Index, FormatV6Address(&NTE->Address), Status));

            //
            // REVIEW: Should we requeue ourselves for another attempt?
            //
        }
    }

    if (ShouldBeRegistered) {
        if (NTE->TdiRegistrationHandle == NULL) {
            char Buffer[sizeof(TA_ADDRESS) + TDI_ADDRESS_LENGTH_IP6 - 1];
            PTA_ADDRESS TAAddress = (PTA_ADDRESS) Buffer;
            PTDI_ADDRESS_IP6 TDIAddress =
                (PTDI_ADDRESS_IP6) &TAAddress->Address;

            //
            // Create TAAddress from NTE->Address.
            //
            TAAddress->AddressLength = TDI_ADDRESS_LENGTH_IP6;
            TAAddress->AddressType = TDI_ADDRESS_TYPE_IP6;
            TDIAddress->sin6_port = 0;
            TDIAddress->sin6_flowinfo = 0;
            *(IPv6Addr *)&TDIAddress->sin6_addr = NTE->Address;
            TDIAddress->sin6_scope_id = ScopeId;

            Status = TdiRegisterNetAddress(TAAddress, &IF->DeviceName, NULL,
                                           &NTE->TdiRegistrationHandle);
            if (Status == STATUS_SUCCESS) {
                NTE->TdiRegistrationScopeId = ScopeId;
            } else {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "RegisterNetAddressWorker: "
                           "TdiRegisterNetAddress(%d/%s): %x\n",
                           IF->Index, FormatV6Address(&NTE->Address), Status));

                //
                // Due to a bug in TdiRegisterNetAddress, we can't be
                // guaranteed the handle will be NULL on error.
                //
                NTE->TdiRegistrationHandle = NULL;

                //
                // REVIEW: Should we requeue ourselves for another attempt?
                //
            }
        } 
    }

    KeReleaseMutex(&IF->WorkerLock, FALSE);
    ReleaseNTE(NTE);

    InterlockedDecrement((PLONG)&OutstandingRegisterNetAddressCount);
}

//* DeferRegisterNetAddress
//
//  Queue a work item that will execute RegisterNetAddressWorker.
//
//  Callable from thread or DPC context.
//
void
DeferRegisterNetAddress(
    NetTableEntry *NTE)  // NTE that needs work.
{
    RegisterNetAddressContext *Context;
    PIO_WORKITEM WorkItem;

    Context = ExAllocatePool(NonPagedPool, sizeof *Context);
    if (Context == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "DeferRegisterNetAddress: ExAllocatePool failed\n"));
        return;
    }

    WorkItem = IoAllocateWorkItem(IPDeviceObject);
    if (WorkItem == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "DeferRegisterNetAddress: IoAllocateWorkItem failed\n"));
        ExFreePool(Context);
        return;
    }

    Context->WorkItem = WorkItem;
    AddRefNTE(NTE);
    Context->NTE = NTE;

    InterlockedIncrement((PLONG)&OutstandingRegisterNetAddressCount);

    IoQueueWorkItem(WorkItem, RegisterNetAddressWorker,
                    CriticalWorkQueue, Context);
}


//* AddrConfStartDAD
//
//  Starts duplicate address detection for the address,
//  unless DAD is disabled.
//
//  Called with the interface locked.
//
void
AddrConfStartDAD(Interface *IF, NetTableEntry *NTE)
{
    if ((IF->DupAddrDetectTransmits == 0) ||
        !(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) ||
        ((NTE->AddrConf == ADDR_CONF_TEMPORARY) &&
         (MaxTempDADAttempts == 0))) {

        //
        // Duplicate Address Detection is disabled,
        // so go straight to a valid state
        // if we aren't already valid.
        //
        AddrConfNotDuplicate(IF, NTE);
    }
    else if (IF->Flags & IF_FLAG_MEDIA_DISCONNECTED) {
        //
        // The interface is not connected,
        // so we can not perform DAD.
        // When the interface is connected,
        // ReconnectADEs will start DAD.
        //
    }
    else {
        //
        // Initialize for DAD.
        // Send first solicit at next IPv6Timeout.
        //
        NTE->DADCount = (ushort)IF->DupAddrDetectTransmits;
        NTE->DADTimer = 1;
    }
}


//* CreateNTE - Creates an NTE on an interface.
//
//  Returns one reference for the caller.
//
//  Callable from thread or DPC context.
//  Called with the interface locked.
//
//  (Actually, we are at DPC level because we hold the interface lock.)
//
NetTableEntry *
CreateNTE(Interface *IF, const IPv6Addr *Address, uint AddrConf,
          uint ValidLifetime, uint PreferredLifetime)
{
    uint Size;
    NetTableEntry *NTE = NULL;

    //
    // The address must not already be assigned.
    //
    ASSERT(*FindADE(IF, Address) == NULL);

    //
    // Can't create a new NTE if the interface is shutting down.
    //
    if (IsDisabledIF(IF))
        goto ErrorExit;

    //
    // Temporary addresses need extra fields,
    // which are initialized by our caller.
    //
    if (AddrConf == ADDR_CONF_TEMPORARY)
        Size = sizeof(TempNetTableEntry);
    else
        Size = sizeof(NetTableEntry);

    NTE = ExAllocatePool(NonPagedPool, Size);
    if (NTE == NULL)
        goto ErrorExit;

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "CreateNTE(IF %u/%p, Addr %s) -> NTE %p\n",
               IF->Index, IF, FormatV6Address(Address), NTE));

    //
    // Initialize the NTE with one reference for our caller.
    // (EnlivenNTE may add a second reference for the interface.)
    //
    RtlZeroMemory(NTE, Size);
    NTE->Address = *Address;
    NTE->Type = ADE_UNICAST;
    NTE->Scope = UnicastAddressScope(Address);
    AddNTEToInterface(IF, NTE);
    NTE->RefCnt = 1;
    NTE->AddrConf = (uchar)AddrConf;
    NTE->ValidLifetime = ValidLifetime;
    NTE->PreferredLifetime = PreferredLifetime;
    NTE->DADState = DAD_STATE_INVALID;

    //
    // Create a disabled loopback route.
    // We pre-allocate the loopback RTE and NCE now,
    // and then enable them later when the address is valid.
    //
    if (!ControlLoopback(IF, Address, CONTROL_LOOPBACK_DISABLED))
        goto ErrorExitCleanup;

    //
    // Add this NTE to the front of the NetTableList.
    // 
    KeAcquireSpinLockAtDpcLevel(&NetTableListLock);
    AddNTEToNetTableList(NTE);
    KeReleaseSpinLockFromDpcLevel(&NetTableListLock);

    //
    // If the NTE should be alive, make it so.
    //
    if (NTE->ValidLifetime != 0)
        EnlivenNTE(IF, NTE);
    return NTE;

ErrorExitCleanup:
    RemoveNTEFromInterface(IF, NTE);
    ASSERT(NTE->RefCnt == 1);
    ExFreePool(NTE);

ErrorExit:
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
               "CreateNTE(IF %u/%p, Addr %s) -> NTE %p failed\n",
               IF->Index, IF, FormatV6Address(Address), NTE));
    return NULL;
}

//* InterfaceIndex
//
//  Allocates the next interface index.
//
uint
InterfaceIndex(void)
{
    return (uint) InterlockedIncrement((PLONG) &NextIFIndex);
}

//* AddInterface
//
//  Add a new interface to the global list.
//
void
AddInterface(Interface *IF)
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&IFListLock, &OldIrql);
    IF->Next = IFList;
    IFList = IF;
    IPSInfo.ipsi_numif++;
    KeReleaseSpinLock(&IFListLock, OldIrql);
}


//* CreateGUIDFromName
//
//  Given the string name of an interface, creates a corresponding guid.
//  The guid is a hash of the string name.
//
void
CreateGUIDFromName(const char *Name, GUID *Guid)
{
    MD5_CTX Context;

    MD5Init(&Context);
    MD5Update(&Context, (uchar *)Name, (uint)strlen(Name));
    MD5Final(&Context);
    memcpy(Guid, Context.digest, MD5DIGESTLEN);
}


//* CreateInterface
//
//  Creates an IPv6 interface given some link-layer information.
//  If successful, returns a reference for the interface.
//
//  NB: With some NICs, NDIS will report that the adapter
//  is disconnected after enabling the adapter. Then a second or two
//  later, the adapter's status changes to connected.
//  Presumably this has something to do with the miniport initialization,
//  because the adapter is physically connected throughout.
//  NDIS drops any packets that we send while the adapter is disconnected.
//  So we must be careful that after the SetInterfaceLinkStatus, we (re)send
//  the correct sequence of initialization packets (MLD, DAD, RA/RSs).
//  To accomplish this, we postpone DAD while the interface is disconnected
//  and we postpone sending RA/RSs. ReconnectADEs restarts MLD correctly
//  for this situation so it does not need to be postponed.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_UNSUCCESSFUL
//      STATUS_SUCCESS
//
NTSTATUS
CreateInterface(const GUID *Guid, const LLIPv6BindInfo *BindInfo,
                void **Context)
{
    UNICODE_STRING GuidName;
    Interface *IF = NULL;                  // Interface being added.
    KIRQL OldIrql;
    uint IFSize;
    uint IFExportNamePrefixLen;
    NTSTATUS Status;

    ASSERT(KeGetCurrentIrql() == 0);
    ASSERT(BindInfo->lip_addrlen <= MAX_LINK_LAYER_ADDRESS_LENGTH);

    //
    // Prevent new interfaces from being created
    // while the stack is unloading.
    //
    if (Unloading)
        goto ErrorExit;

    //
    // Before doing the real work, take advantage of the link-layer
    // address passed up here to re-seed our random number generator.
    //
    SeedRandom(BindInfo->lip_addr, BindInfo->lip_addrlen);

    //
    // Convert the guid to string form.
    // It will be null-terminated.
    //
    Status = RtlStringFromGUID(Guid, &GuidName);
    if (! NT_SUCCESS(Status))
        goto ErrorExit;

    ASSERT(GuidName.MaximumLength == GuidName.Length + sizeof(WCHAR));
    ASSERT(((WCHAR *)GuidName.Buffer)[GuidName.Length/sizeof(WCHAR)] == UNICODE_NULL);

    //
    // Allocate memory to hold an interface.
    // We also allocate extra space to hold the device name string.
    //
    IFExportNamePrefixLen = sizeof IPV6_EXPORT_STRING_PREFIX - sizeof(WCHAR);
    IFSize = sizeof *IF + IFExportNamePrefixLen + GuidName.MaximumLength;
    IF = ExAllocatePool(NonPagedPool, IFSize);
    if (IF == NULL)
        goto ErrorExitCleanupGuidName;

    RtlZeroMemory(IF, sizeof *IF);
    IF->IF = IF;
    IF->Index = InterfaceIndex();
    IF->Guid = *Guid;

    //
    // Start with one reference because this is an active interface.
    // And one reference for our caller.
    //
    IF->RefCnt = 2;

    //
    // Create the null-terminated exported device name from the guid.
    //
    IF->DeviceName.Buffer = (PVOID) (IF + 1);
    IF->DeviceName.MaximumLength = (USHORT) (IFSize - sizeof *IF);
    IF->DeviceName.Length = IF->DeviceName.MaximumLength - sizeof(WCHAR);
    RtlCopyMemory(IF->DeviceName.Buffer,
                  IPV6_EXPORT_STRING_PREFIX,
                  IFExportNamePrefixLen);
    RtlCopyMemory((uchar *) IF->DeviceName.Buffer + IFExportNamePrefixLen,
                  GuidName.Buffer,
                  GuidName.MaximumLength);

    KeInitializeSpinLock(&IF->Lock);

    IF->Type = BindInfo->lip_type;
    IF->Flags = (BindInfo->lip_flags & IF_FLAGS_BINDINFO);

    if (BindInfo->lip_context == NULL)
        IF->LinkContext = IF;
    else
        IF->LinkContext = BindInfo->lip_context;
    IF->Transmit = BindInfo->lip_transmit;
    IF->CreateToken = BindInfo->lip_token;
    IF->ReadLLOpt = BindInfo->lip_rdllopt;
    IF->WriteLLOpt = BindInfo->lip_wrllopt;
    IF->ConvertAddr = BindInfo->lip_cvaddr;
    IF->SetRouterLLAddress = BindInfo->lip_setrtrlladdr;
    IF->SetMCastAddrList = BindInfo->lip_mclist;
    IF->Close = BindInfo->lip_close;
    IF->Cleanup = BindInfo->lip_cleanup;
    IF->LinkAddressLength = BindInfo->lip_addrlen;
    IF->LinkAddress = BindInfo->lip_addr;
    //
    // We round-up the link-layer header size to a multiple of 2.
    // This aligns the IPv6 header appropriately for IPv6Addr.
    // When NDIS is fixed so we don't need AdjustPacketBuffer,
    // we should align the IPv6 header to a multiple of 8.
    //
    IF->LinkHeaderSize = ALIGN_UP(BindInfo->lip_hdrsize, ushort);

    IF->TrueLinkMTU = BindInfo->lip_maxmtu;
    IF->DefaultLinkMTU = BindInfo->lip_defmtu;
    IF->LinkMTU = BindInfo->lip_defmtu;

    IF->DefaultPreference = BindInfo->lip_pref;
    IF->Preference = BindInfo->lip_pref;
    IF->BaseReachableTime = REACHABLE_TIME;
    IF->ReachableTime = CalcReachableTime(IF->BaseReachableTime);
    IF->RetransTimer = RETRANS_TIMER;
    IF->DefaultDupAddrDetectTransmits = BindInfo->lip_dadxmit;
    IF->DupAddrDetectTransmits = BindInfo->lip_dadxmit;
    IF->CurHopLimit = DefaultCurHopLimit;
    IF->DefSitePrefixLength = DEFAULT_SITE_PREFIX_LENGTH;

    //
    // Neighbor discovery requires multicast capability
    //
    ASSERT((IF->Flags & IF_FLAG_MULTICAST) ||
           !(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS));

    //
    // Router discovery requires either multicast capability,
    // or a SetRouterLLAddress handler, or a Teredo interface.
    //
    ASSERT((IF->Flags & IF_FLAG_MULTICAST) ||
           (IF->SetRouterLLAddress != NULL) ||
           (IF->Type == IF_TYPE_TUNNEL_TEREDO) ||
           !(IF->Flags & IF_FLAG_ROUTER_DISCOVERS));

    
    //
    // All interfaces are considered to be on different links
    // but in the same site, until configured otherwise.
    //
    InitZoneIndices(IF->ZoneIndices, IF->Index);

    NeighborCacheInit(IF);

    //
    // The worker lock serializes some heavy-weight
    // calls to upper & lower layers.
    //
    KeInitializeMutex(&IF->WorkerLock, 0);
    //
    // We need to get APCs while holding WorkerLock,
    // so that we can get IO completions
    // for our TDI calls on 6over4 interfaces.
    // This is not a security problem because
    // only kernel worker threads use WorkerLock
    // so they can't be suspended by the user.
    //
    IF->WorkerLock.ApcDisable = 0;

    //
    // Initialize some random state for temporary addresses.
    //
    *(uint UNALIGNED *)&IF->TempState = Random();

    //
    // Register this interface's device name with TDI.
    // We need to do this before assigning any unicast addresses to this IF,
    // and also before grabbing the lock (thus setting IRQL to DISPATCH_LEVEL).
    //
    Status = TdiRegisterDeviceObject(&IF->DeviceName,
                                     &IF->TdiRegistrationHandle);
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "CreateInterface(IF %u/%p): %ls -> %x\n",
               IF->Index, IF,
               IF->DeviceName.Buffer,
               Status));
    if (Status != STATUS_SUCCESS)
        goto ErrorExitCleanupIF;

    //
    // After this point, we either return successfully
    // or cleanup via ErrorExitDestroyIF.
    //
    RtlFreeUnicodeString(&GuidName);

    //
    // Return the new Interface to our caller now.
    // This makes it available to the link-layer when
    // we call CreateToken etc, before CreateInterface returns.
    //
    *Context = IF;

    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    if (IF->Flags & IF_FLAG_ROUTER_DISCOVERS) {
        //
        // Join the all-nodes multicast groups.
        //
        if (! JoinGroupAtAllScopes(IF, &AllNodesOnLinkAddr,
                                   ADE_LINK_LOCAL))
            goto ErrorExitDestroyIF;

        if (IF->Flags & IF_FLAG_ADVERTISES) {
            //
            // Join the all-routers multicast groups.
            //
            if (! JoinGroupAtAllScopes(IF, &AllRoutersOnLinkAddr,
                                       ADE_SITE_LOCAL))
                goto ErrorExitDestroyIF;

            //
            // Start sending Router Advertisements.
            //
            if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED))
                IF->RATimer = 1;
            IF->RACount = MAX_INITIAL_RTR_ADVERTISEMENTS;
        }
        else {
            //
            // Start sending Router Solicitations.
            // The first RS will have the required random delay,
            // because we randomize when IPv6Timeout first fires.
            //
            if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED))
                IF->RSTimer = 1;
        }
    }

    //
    // Initialize RALast to a value safely in the past,
    // so that when/if this interface first sends an RA
    // it is not inhibited due to rate-limiting.
    //
    IF->RALast = IPv6TickCount - MIN_DELAY_BETWEEN_RAS;

    if (IF->Flags & IF_FLAG_FORWARDS)
        InterlockedIncrement((PLONG)&NumForwardingInterfaces);

    if (IF->CreateToken != NULL) {
        IPv6Addr Address;
        NetTableEntry *NTE;

        //
        // Create a link-local address for this interface.
        // Other addresses will be created later via stateless
        // auto-configuration.
        //
        Address = LinkLocalPrefix;
        (*IF->CreateToken)(IF->LinkContext, &Address);

        NTE = CreateNTE(IF, &Address, ADDR_CONF_LINK,
                        INFINITE_LIFETIME, INFINITE_LIFETIME);
        if (NTE == NULL)
            goto ErrorExitDestroyIF;

        //
        // The LinkLocalNTE field does not hold a reference.
        //
        IF->LinkLocalNTE = NTE;
        ReleaseNTE(NTE);
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    //
    // Configure the interface from the registry.
    //
    ConfigureInterface(IF);

    //
    // Add ourselves to the front of the global interface list.
    // This is done last so the interface is fully initialized
    // when it shows up on the list.
    //
    AddInterface(IF);

    //
    // If the interface is multicast enabled, create a multicast route.
    //
    if (IF->Flags & IF_FLAG_MULTICAST) {
        RouteTableUpdate(NULL,  // System update.
                         IF, NULL,
                         &MulticastPrefix, 8, 0,
                         INFINITE_LIFETIME, INFINITE_LIFETIME,
                         ROUTE_PREF_ON_LINK,
                         RTE_TYPE_SYSTEM,
                         FALSE, FALSE);
    }
    
    return STATUS_SUCCESS;

ErrorExitDestroyIF:
    //
    // Prevent calls down to the link layer,
    // since our return code notifies the link layer
    // synchronously that it should clean up.
    //
    IF->Close = NULL;
    IF->Cleanup = NULL;
    IF->SetMCastAddrList = NULL;
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    //
    // Destroy the interface.
    // This will cleanup addresses and routes.
    // Then add the disabled interface to the list
    // so InterfaceCleanup can find it after
    // we release the last reference.
    //
    DestroyIF(IF);
    AddInterface(IF);
    ReleaseIF(IF);
    goto ErrorExit;

ErrorExitCleanupIF:
    //
    // The interface has not been registered with TDI
    // and there are no addresses, routes, etc.
    // So we can just free it.
    //
    ASSERT(IF->RefCnt == 2);
    ExFreePool(IF);

ErrorExitCleanupGuidName:
    RtlFreeUnicodeString(&GuidName);

ErrorExit:
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
               "CreateInterface(IF %p) failed\n", IF));
    return STATUS_UNSUCCESSFUL;
}

//
// We keep track of the number of outstanding
// deregister-interface work items.
// (Using InterlockedIncrement/InterlockedDecrement.)
// This way we can wait in the IPUnload
// until they are all done.
//
ULONG OutstandingDeregisterInterfaceCount = 0;

//
// Note that this structure wouldn't be needed if IoQueueWorkItem
// had been designed to call the user's routine with the WorkItem
// as an additional argument along with the DeviceObject and Context.
// Sigh.
//
typedef struct DeregisterInterfaceContext {
    PIO_WORKITEM WorkItem;
    Interface *IF;
} DeregisterInterfaceContext;

//* DeregisterInterfaceWorker - De/Registers an address with TDI.
//
//  Worker function for calling TdiDeregisterDeviceObject.
//  This is the last thing we do with the interface structure,
//  so this routine also frees the interface.
//  It has no references at this point.
//
void
DeregisterInterfaceWorker(
    PDEVICE_OBJECT DevObj,  // Unused.  Wish they passed the WorkItem instead.
    PVOID Context)          // A DeregisterInterfaceContext struct.
{
    DeregisterInterfaceContext *MyContext = Context;
    Interface *IF = MyContext->IF;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(DevObj);

    IoFreeWorkItem(MyContext->WorkItem);
    ExFreePool(MyContext);

    //
    // Deregister the interface with TDI, if it was registered.
    // The loopback interface is not registered.
    //
    if (IF->TdiRegistrationHandle != NULL) {
        Status = TdiDeregisterDeviceObject(IF->TdiRegistrationHandle);
        if (Status != STATUS_SUCCESS)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "DeregisterInterfaceContext: "
                       "TdiDeregisterDeviceObject: %x\n", Status));
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "DeregisterInterfaceWorker(IF %u/%p) -> freed\n", IF->Index, IF));

    //
    // Perform final cleanup of the link-layer data structures.
    //
    if (IF->Cleanup != NULL)
        (*IF->Cleanup)(IF->LinkContext);

    ExFreePool(IF);

    //
    // Note that we've finished our cleanup.
    //
    InterlockedDecrement((PLONG)&OutstandingDeregisterInterfaceCount);
}

//* DeferDeregisterInterface
//
//  Queue a work item that will execute DeregisterInterfaceWorker.
//
//  Callable from thread or DPC context.
//
void
DeferDeregisterInterface(
    Interface *IF)
{
    DeregisterInterfaceContext *Context;
    PIO_WORKITEM WorkItem;

    Context = ExAllocatePool(NonPagedPool, sizeof *Context);
    if (Context == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "DeferDeregisterInterface: ExAllocatePool failed\n"));
        return;
    }

    WorkItem = IoAllocateWorkItem(IPDeviceObject);
    if (WorkItem == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "DeferDeregisterInterface: IoAllocateWorkItem failed\n"));
        ExFreePool(Context);
        return;
    }

    Context->WorkItem = WorkItem;
    Context->IF = IF;

    InterlockedIncrement((PLONG)&OutstandingDeregisterInterfaceCount);

    IoQueueWorkItem(WorkItem, DeregisterInterfaceWorker,
                    CriticalWorkQueue, Context);
}


//* DestroyIF
//
//  Shuts down an interface, making the interface effectively disappear.
//  The interface will actually be freed when its last ref is gone.
//
//  Callable from thread context, not DPC context.
//  Called with NO locks held.
//
void
DestroyIF(Interface *IF)
{
    AddressEntry *ADE;
    int WasDisabled;
    KIRQL OldIrql;

    //
    // First things first: disable the interface.
    // If it's already disabled, we're done.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    ASSERT(OldIrql == 0);
    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    WasDisabled = IF->Flags & IF_FLAG_DISABLED;
    IF->Flags |= IF_FLAG_DISABLED;
    KeReleaseSpinLockFromDpcLevel(&IFListLock);

    if (WasDisabled) {
        KeReleaseSpinLock(&IF->Lock, OldIrql);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "DestroyIF(IF %u/%p) - already disabled?\n",
                   IF->Index, IF));
        return;
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "DestroyIF(IF %u/%p) -> disabled\n",
               IF->Index, IF));

    //
    // Stop generating Router Solicitations and Advertisements.
    //
    IF->RSTimer = IF->RATimer = 0;

    //
    // If the interface is currently forwarding,
    // disable forwarding.
    //
    InterfaceStopForwarding(IF);

    //
    // Destroy all the ADEs. Because the interface is disabled,
    // new ADEs will not subsequently be created.
    //
    while ((ADE = IF->ADE) != NULL) {
        //
        // First, remove this ADE from the interface.
        //
        IF->ADE = ADE->Next;

        switch (ADE->Type) {
        case ADE_UNICAST: {
            NetTableEntry *NTE = (NetTableEntry *) ADE;
            DestroyNTE(IF, NTE);
            break;
        }

        case ADE_ANYCAST: {
            AnycastAddressEntry *AAE = (AnycastAddressEntry *) ADE;
            DeleteAAE(IF, AAE);
            break;
        }

        case ADE_MULTICAST: {
            MulticastAddressEntry *MAE = (MulticastAddressEntry *) ADE;
            DeleteMAE(IF, MAE);
            break;
        }
        }
    }
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    //
    // Shutdown the link-layer.
    //
    if (IF->Close != NULL)
        (*IF->Close)(IF->LinkContext);

    //
    // Clean up routing associated with the interface.
    //
    RouteTableRemove(IF);

    //
    // Clean up reassembly buffers associated with the interface.
    //
    ReassemblyRemove(IF);

    //
    // Clean up upper-layer state associated with the interface.
    //
    TCPRemoveIF(IF);

    //
    // Release the reference that the interface
    // held for itself by virtue of being active.
    //
    ReleaseIF(IF);

    //
    // At this point, any NTEs still exist
    // and hold references for the interface.
    // The next calls to NetTableCleanup
    // and InterfaceCleanup will finish the cleanup.
    //
}


//* DestroyInterface
//
//  Called from a link layer to destroy an interface.
//
//  May be called when the interface has zero references
//  and is already being destroyed.
//
void
DestroyInterface(void *Context)
{
    Interface *IF = (Interface *) Context;

    DestroyIF(IF);
}


//* ReleaseInterface
//
//  Called from the link-layer to release its reference
//  for the interface.
//
void
ReleaseInterface(void *Context)
{
    Interface *IF = (Interface *) Context;

    ReleaseIF(IF);
}


//* UpdateLinkMTU
//
//  Update the link's MTU, either because of administrative configuration
//  or autoconfiguration from a Router Advertisement.
//
//  Callable from thread or DPC context.
//  Called with NO locks held.
//
void
UpdateLinkMTU(Interface *IF, uint MTU)
{
    KIRQL OldIrql;

    ASSERT((IPv6_MINIMUM_MTU <= MTU) && (MTU <= IF->TrueLinkMTU));

    //
    // If the interface is advertising, then it should
    // send a new RA promptly because the RAs contain the MTU option.
    // This is what really needs the lock and the IsDisabledIF check.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    if ((IF->LinkMTU != MTU) && !IsDisabledIF(IF)) {
        IF->LinkMTU = MTU;
        if (IF->Flags & IF_FLAG_ADVERTISES) {
            //
            // Send a Router Advertisement very soon.
            //
            IF->RATimer = 1;
        }
    }
    KeReleaseSpinLock(&IF->Lock, OldIrql);
}


//* FindInterfaceFromIndex
//
//  Given the index of an interface, finds the interface.
//  Returns a reference for the interface, or
//  returns NULL if no valid interface is found.
//
//  Callable from thread or DPC context.
//
Interface *
FindInterfaceFromIndex(uint Index)
{
    Interface *IF;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IFListLock, &OldIrql);
    for (IF = IFList; IF != NULL; IF = IF->Next) {

        if (IF->Index == Index) {
            //
            // Fail to find disabled interfaces.
            //
            if (IsDisabledIF(IF))
                IF = NULL;
            else
                AddRefIF(IF);
            break;
        }
    }
    KeReleaseSpinLock(&IFListLock, OldIrql);

    return IF;
}

//* FindInterfaceFromGuid
//
//  Given the guid of an interface, finds the interface.
//  Returns a reference for the interface, or
//  returns NULL if no valid interface is found.
//
//  Callable from thread or DPC context.
//
Interface *
FindInterfaceFromGuid(const GUID *Guid)
{
    Interface *IF;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IFListLock, &OldIrql);
    for (IF = IFList; IF != NULL; IF = IF->Next) {

        if (RtlCompareMemory(&IF->Guid, Guid, sizeof(GUID)) == sizeof(GUID)) {
            //
            // Fail to find disabled interfaces.
            //
            if (IsDisabledIF(IF))
                IF = NULL;
            else
                AddRefIF(IF);
            break;
        }
    }
    KeReleaseSpinLock(&IFListLock, OldIrql);

    return IF;
}

//* FindNextInterface
//
//  Returns the next valid (not disabled) interface.
//  If the argument is NULL, returns the first valid interface.
//  Returns NULL if there is no next valid interface.
//
//  Callable from thread or DPC context.
//
Interface *
FindNextInterface(Interface *IF)
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&IFListLock, &OldIrql);

    if (IF == NULL)
        IF = IFList;
    else
        IF = IF->Next;

    for (; IF != NULL; IF = IF->Next) {
        if (! IsDisabledIF(IF)) {
            AddRefIF(IF);
            break;
        }
    }

    KeReleaseSpinLock(&IFListLock, OldIrql);

    return IF;
}

//* FindInterfaceFromZone
//
//  Given a scope level and a zone index, finds an interface
//  belonging to the specified zone. The interface
//  must be different than the specified OrigIf.
//
//  Called with the global ZoneUpdateLock lock held.
//  (So we are at DPC level.)
//
Interface *
FindInterfaceFromZone(Interface *OrigIF, uint Scope, uint Index)
{
    Interface *IF;

    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    for (IF = IFList; IF != NULL; IF = IF->Next) {

        if ((IF != OrigIF) &&
            !IsDisabledIF(IF) &&
            (IF->ZoneIndices[Scope] == Index)) {

            AddRefIF(IF);
            break;
        }
    }
    KeReleaseSpinLockFromDpcLevel(&IFListLock);

    return IF;
}

//* FindNewZoneIndex
//
//  This is a helper function for CheckZoneIndices.
//
//  Given a scope level, finds an unused zone index
//  for use at that scope level.
//  We return the value one more than the largest
//  value currently in use.
//
//  Called with the global ZoneUpdateLock lock held.
//  Called from DPC context.
//
uint
FindNewZoneIndex(uint Scope)
{
    Interface *IF;
    uint ZoneIndex = 1;

    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    for (IF = IFList; IF != NULL; IF = IF->Next) {

        if (!IsDisabledIF(IF)) {
            if (ZoneIndex <= IF->ZoneIndices[Scope])
                ZoneIndex = IF->ZoneIndices[Scope] + 1;
        }
    }
    KeReleaseSpinLockFromDpcLevel(&IFListLock);

    return ZoneIndex;
}

//* InitZoneIndices
//
//  Initializes an array of zone indices to default values.
//
void
InitZoneIndices(
    uint *ZoneIndices,
    uint Index)
{
    ushort Scope;

    ZoneIndices[ADE_SMALLEST_SCOPE] = Index;
    ZoneIndices[ADE_INTERFACE_LOCAL] = Index;
    ZoneIndices[ADE_LINK_LOCAL] = Index;
    for (Scope = ADE_LINK_LOCAL + 1; Scope <= ADE_LARGEST_SCOPE; Scope++)
        ZoneIndices[Scope] = 1;
}

//* UpdateZoneIndices
//
// Helper function for updating zone indices on an interface.
//
// Called with the ZoneUpdateLock and the interface lock held.
//
void
UpdateZoneIndices(
    Interface *IF, 
    uint *ZoneIndices)
{
    int SiteIdChanged, LinkIdChanged;
    AddressEntry *ADE;
    NetTableEntry *NTE;

    LinkIdChanged = (ZoneIndices[ADE_LINK_LOCAL] != 
                     IF->ZoneIndices[ADE_LINK_LOCAL]);
    SiteIdChanged = (ZoneIndices[ADE_SITE_LOCAL] != 
                     IF->ZoneIndices[ADE_SITE_LOCAL]);

    RtlCopyMemory(IF->ZoneIndices, ZoneIndices, sizeof IF->ZoneIndices);

    // 
    // The following checks are just optimizations to avoid the for loop 
    // and to avoid unnecessarily calling RegisterNetAddressWorker.
    //
    if ((IF->Flags & IF_FLAG_MEDIA_DISCONNECTED) ||
        (!LinkIdChanged && !SiteIdChanged))
        return;

    //
    // Media is connected and the scope id has changed for unicast addresses.
    // We need to inform TDI clients of the change in any relevant addresses.
    //
    for (ADE = IF->ADE; ADE != NULL; ADE = ADE->Next) {
        //
        // Nothing to do for anycast or multicast addresses.
        //
        if (ADE->Type != ADE_UNICAST)
            continue;

        if (((ADE->Scope == ADE_LINK_LOCAL) && LinkIdChanged) ||
            ((ADE->Scope == ADE_SITE_LOCAL) && SiteIdChanged)) {
            NTE = (NetTableEntry *) ADE;

            if (NTE->DADState == DAD_STATE_PREFERRED) {
                //
                // Queue worker to tell TDI that this address has changed.
                //
                DeferRegisterNetAddress(NTE);
            }
        }
    }
}

//* FindDefaultInterfaceForZone
//
//  Given a scope level and a zone index, finds the default interface
//  belonging to the specified zone. The default interface
//  is the one that we assume destinations in the zone
//  are on-link to, if there are no routes matching the destination.
//
//  It is an error for the zone index to be zero, unless
//  all our interfaces are in the same zone at that scope level.
//  In which case zero (meaning unspecified) is actually not ambiguous.
//
//  The default interface is returned as NULL upon failure,
//  and with a reference upon success.
//
//  Called with the route cache lock held.
//  (So we are at DPC level.)
//
Interface *
FindDefaultInterfaceForZone(
    uint Scope,
    uint ScopeId)
{
    Interface *FirstIF = NULL;
    Interface *FoundIF = NULL;
    Interface *IF;

    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    for (IF = IFList; IF != NULL; IF = IF->Next) {

        if (!IsDisabledIF(IF)) {
            if (ScopeId == 0) {
                //
                // Do we have interfaces in two zones at this scope level?
                //
                if (FirstIF == NULL) {

                    FirstIF = IF;
                }
                else if (IF->ZoneIndices[Scope] !=
                                FirstIF->ZoneIndices[Scope]) {
                    //
                    // Stop now with an error.
                    //
                    ASSERT(FoundIF != NULL);
                    ReleaseIF(FoundIF);
                    FoundIF = NULL;
                    break;
                }
            }

            //
            // Can we potentially use this interface?
            //
            if ((ScopeId == 0) ||
                (IF->ZoneIndices[Scope] == ScopeId)) {

                if (FoundIF == NULL) {
                FoundInterface:
                    AddRefIF(IF);
                    FoundIF = IF;
                }
                else {
                    //
                    // Is this new interface better than the previous one?
                    //
                    if (IF->Preference < FoundIF->Preference) {
                        ReleaseIF(FoundIF);
                        goto FoundInterface;
                    }
                }
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&IFListLock);

    return FoundIF;
}

#pragma BEGIN_INIT

//* IPInit - Initialize ourselves.
//
//  This routine is called during initialization from the OS-specific
//  init code.
//
int  // Returns: 0 if initialization failed, non-zero if it succeeds.
IPInit(void)
{
    NDIS_STATUS Status;
    LARGE_INTEGER Time;
    uint InitialWakeUp;
    uchar InitialRandomBits[16];  // This size was arbitrarily chosen.

    ASSERT(ConvertSecondsToTicks(0) == 0);
    ASSERT(ConvertSecondsToTicks(INFINITE_LIFETIME) == INFINITE_LIFETIME);
    ASSERT(ConvertSecondsToTicks(1) == IPv6_TICKS_SECOND);

    ASSERT(ConvertTicksToSeconds(0) == 0);
    ASSERT(ConvertTicksToSeconds(IPv6_TICKS_SECOND) == 1);
    ASSERT(ConvertTicksToSeconds(INFINITE_LIFETIME) == INFINITE_LIFETIME);

    ASSERT(ConvertMillisToTicks(1000) == IPv6_TICKS_SECOND);
    ASSERT(ConvertMillisToTicks(1) > 0);

    KeInitializeSpinLock(&NetTableListLock);
    KeInitializeSpinLock(&IFListLock);
    KeInitializeSpinLock(&ZoneUpdateLock);

    //
    // Perform initial seed of our psuedo-random number generator using
    // 'random' bits from the KSecDD driver.  KSecDD reportedly seeds itself
    // with various system-unique values, which is exactly what we want
    // (in order to avoid synchronicity issues between machines).
    //
    if (!GetSystemRandomBits(InitialRandomBits, sizeof(InitialRandomBits))) {
        return FALSE;
    }
    SeedRandom(InitialRandomBits, sizeof(InitialRandomBits));

    //
    // Prepare our periodic timer and its associated DPC object.
    //
    // When the timer expires, the IPv6Timeout deferred procedure
    // call (DPC) is queued.  Everything we need to do at some
    // specific frequency is driven off of this routine.
    //
    // We wait to start the timer until all our datastructures have
    // been initialized below.
    //
    KeInitializeDpc(&IPv6TimeoutDpc, IPv6Timeout, NULL);  // No parameter.
    KeInitializeTimer(&IPv6Timer);

    // Initialize the ProtocolSwitchTable.
    ProtoTabInit();

    //
    // Create Packet and Buffer pools for IPv6.
    //

    switch (MmQuerySystemSize()) {
    case MmSmallSystem:
        PacketPoolSize = SMALL_POOL;
        break;
    case MmMediumSystem:
        PacketPoolSize = MEDIUM_POOL;
        break;
    case MmLargeSystem:
    default:
        PacketPoolSize = LARGE_POOL;
        break;
    }
    NdisAllocatePacketPool(&Status, &IPv6PacketPool,
                           PacketPoolSize, sizeof(Packet6Context));
    if (Status != NDIS_STATUS_SUCCESS)
        return FALSE;

    //
    // Currently, the size we pass to NdisAllocateBufferPool is ignored.
    //
    NdisAllocateBufferPool(&Status, &IPv6BufferPool, PacketPoolSize);
    if (Status != NDIS_STATUS_SUCCESS)
        return FALSE;

    ReassemblyInit();

    ICMPv6Init();

    if (!IPSecInit())
        return FALSE;

    //
    // Start the routing module.
    //
    InitRouting();
    InitSelect();

    //
    // Start the IPv6 timer.
    // Our data structures should all be initialized now.
    //
    // Start the timer with an initial relative expiration time and
    // also a recurring period.  The initial expiration time is
    // negative (to indicate a relative time), and in 100ns units, so
    // we first have to do some conversions.  The initial expiration
    // time is randomized to help prevent synchronization between
    // different machines.
    //
    InitialWakeUp = RandomNumber(0, IPv6_TIMEOUT * 10000);
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "IPv6: InitialWakeUp = %u\n", InitialWakeUp));
    Time.QuadPart = - (LONGLONG) InitialWakeUp;
    KeSetTimerEx(&IPv6Timer, Time, IPv6_TIMEOUT, &IPv6TimeoutDpc);

    //
    // First create the loopback interface,
    // so it will be interface 1.
    //
    if (!LoopbackInit())
        return FALSE;     // Couldn't initialize loopback.

    //
    // Second create the tunnel interface,
    // so it will be interface 2.
    // This can also result in 6over4 interfaces.
    //
    if (!TunnelInit())
        return FALSE;     // Couldn't initialize tunneling.

    //
    // Finally initialize with ndis,
    // so ethernet interfaces can be created.
    //
    if (!LanInit())
        return FALSE;     // Couldn't initialize with ndis.

    return TRUE;
}

#pragma END_INIT


//* IPUnload
//
//  Called to shutdown the IP module in preparation
//  for unloading the protocol stack.
//
void
IPUnload(void)
{
    Interface *IF;
    KIRQL OldIrql;

    TdiDeregisterProvider(IPv6ProviderHandle);

    //
    // Stop the periodic timer.
    //
    KeCancelTimer(&IPv6Timer);

    //
    // Call each interface's close function.
    // Note that interfaces might disappear while
    // the interface list is unlocked,
    // but new interfaces will not be created
    // and the list does not get reordered.
    //
    KeAcquireSpinLock(&IFListLock, &OldIrql);
    for (IF = IFList; IF != NULL; IF = IF->Next) {
        AddRefIF(IF);
        KeReleaseSpinLock(&IFListLock, OldIrql);

        DestroyIF(IF);

        KeAcquireSpinLock(&IFListLock, &OldIrql);
        ReleaseIF(IF);
    }
    KeReleaseSpinLock(&IFListLock, OldIrql);

    //
    // DestroyIF/DestroyNTE spawned RegisterNetAddressWorker threads.
    // Wait for them all to finish executing.
    // This needs to be done before NetTableCleanup.
    //
    while (OutstandingRegisterNetAddressCount != 0) {
        LARGE_INTEGER Interval;
        Interval.QuadPart = -1; // Shortest possible relative wait.
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    }

    //
    // TunnelUnload needs to be after calling DestroyIF
    // on all the interfaces and before InterfaceCleanup.
    //
    TunnelUnload();

    NetTableCleanup();
    InterfaceCleanup();
    UnloadSelect();
    UnloadRouting();
    IPSecUnload();
    ReassemblyUnload();

    ASSERT(NumForwardingInterfaces == 0);
    ASSERT(IPSInfo.ipsi_numif == 0);

    //
    // InterfaceCleanup spawned DeregisterInterfaceWorker threads.
    // Wait for them all to finish executing.
    // Unfortunately, there is no good builtin synchronization primitive
    // for this task. However, in practice because of the relative
    // priorities of the threads involved, we almost never actually
    // wait here. So this solution is quite efficient.
    //
    while (OutstandingDeregisterInterfaceCount != 0) {
        LARGE_INTEGER Interval;
        Interval.QuadPart = -1; // Shortest possible relative wait.
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);
    }

#if DBG
    {
        NetTableEntry *NTE;

        for (NTE = NetTableList; NTE != NULL; NTE = NTE->NextOnNTL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "Leaked NTE %p (IF %u/%p) Addr %s Refs %u\n",
                       NTE, NTE->IF->Index, NTE->IF,
                       FormatV6Address(&NTE->Address),
                       NTE->RefCnt));
        }

        for (IF = IFList; IF != NULL; IF = IF->Next) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "Leaked IF %u/%p Refs %u\n",
                       IF->Index, IF, IF->RefCnt));
        }
    }
#endif // DBG

    //
    // We must wait until all the interfaces are completely cleaned up
    // by DeregisterInterfaceWorker before freeing the packet pools.
    // This is because Lan interfaces hold onto a packet (ai_tdpacket)
    // that is freed in LanCleanupAdapter. NdisFreePacketPool
    // blows away any packets that are still allocated so we can't call
    // IPv6FreePacket after NdisFreePacketPool/NdisFreeBufferPool.
    //
    NdisFreePacketPool(IPv6PacketPool);
    NdisFreeBufferPool(IPv6BufferPool);
}


//* GetLinkLocalNTE
//
//  Returns the interface's link-local NTE (without a reference), or
//  returns NULL if the interface does not have a valid link-local address.
//
//  Called with the interface locked.
//  
NetTableEntry *
GetLinkLocalNTE(Interface *IF)
{
    NetTableEntry *NTE;

    NTE = IF->LinkLocalNTE;
    if ((NTE == NULL) || !IsValidNTE(NTE)) {
        //
        // If we didn't find a valid NTE in the LinkLocalNTE field,
        // search the ADE list and cache the first valid link-local NTE
        // we find (if any).
        //
        for (NTE = (NetTableEntry *) IF->ADE;
             NTE != NULL;
             NTE = (NetTableEntry *) NTE->Next) {

            if ((NTE->Type == ADE_UNICAST) &&
                IsValidNTE(NTE) &&
                IsLinkLocal(&NTE->Address)) {
                //
                // Cache this NTE for future reference.
                //
                IF->LinkLocalNTE = NTE;
                break;
            }
        }
    }

    return NTE;
}


//* GetLinkLocalAddress
//
//  Returns the interface's link-local address,
//  if it is valid. Otherwise, returns
//  the unspecified address.
//
//  Callable from thread or DPC context.
//
//  Returns FALSE if the link-local address is not valid.
//
int
GetLinkLocalAddress(
    Interface *IF,   // Interface for which to find an address.
    IPv6Addr *Addr)  // Where to return address found (or unspecified).
{
    KIRQL OldIrql;
    NetTableEntry *NTE;
    int Status;

    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    NTE = GetLinkLocalNTE(IF);
    Status = (NTE != NULL);
    if (Status)
        *Addr = NTE->Address;
    else
        *Addr = UnspecifiedAddr;

    KeReleaseSpinLock(&IF->Lock, OldIrql);
    return Status;
}


//* FindOrCreateNTE
//
//  Find the specified unicast address.
//  If it already exists, update it.
//  If it doesn't exist, create it if the lifetime is non-zero.
//
//  Returns TRUE for success.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
int
FindOrCreateNTE(
    Interface *IF,
    const IPv6Addr *Addr,
    uint AddrConf,
    uint ValidLifetime,
    uint PreferredLifetime)
{
    NetTableEntry *NTE;
    KIRQL OldIrql;
    int rc;

    ASSERT(!IsMulticast(Addr) && !IsUnspecified(Addr) &&
           (!IsLoopback(Addr) || (IF == LoopInterface)));
    ASSERT(PreferredLifetime <= ValidLifetime);
    ASSERT(AddrConf != ADDR_CONF_TEMPORARY);

    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    NTE = (NetTableEntry *) *FindADE(IF, Addr);
    if (NTE == NULL) {
        //
        // There is no such address, so create it.
        //
        NTE = CreateNTE(IF, Addr, AddrConf, ValidLifetime, PreferredLifetime);
        if (NTE == NULL) {
            rc = FALSE;
        }
        else {
            ReleaseNTE(NTE);
            rc = TRUE;
        }
    }
    else if ((NTE->Type == ADE_UNICAST) &&
             (NTE->AddrConf == AddrConf)) {
        //
        // Update the address lifetimes.
        // If we set the lifetime to zero, AddrConfTimeout will remove it.
        // NB: We do not allow NTE->AddrConf to change.
        //
        NTE->ValidLifetime = ValidLifetime;
        NTE->PreferredLifetime = PreferredLifetime;
        rc = TRUE;
    }
    else {
        //
        // We found the address, but we can't update it.
        //
        rc = FALSE;
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return rc;
}


//* CreateTemporaryAddress
//
//  Creates an temporary address for the interface.
//
//  Called with the interface locked.
//
void
CreateTemporaryAddress(Interface *IF, const IPv6Addr *Prefix, IPv6Addr *Addr)
{
    uint Now = IPv6TickCount;

    if (TempRandomTime == 0) {
        //
        // We delay initializing TempRandomTime until it is needed.
        // This way the random number generator has been initialized.
        //
        TempRandomTime = RandomNumber(0, MaxTempRandomTime);
    }

    //
    // First, update the state that we use if it is too old.
    //
    if ((IF->TempStateAge == 0) ||
        (UseTemporaryAddresses == USE_TEMP_ALWAYS) ||
        ((uint)(Now - IF->TempStateAge) >=
            (TempPreferredLifetime - TempRegenerateTime))) {

    TryAgain:
        IF->TempStateAge = Now;

        if (UseTemporaryAddresses == USE_TEMP_COUNTER) {
            //
            // When testing, it's convenient to use interface identifiers
            // that aren't actually random.
            //
            *(UINT UNALIGNED *)&IF->TempState.s6_bytes[12] =
                net_long(net_long(*(UINT UNALIGNED *)&IF->TempState.s6_bytes[12]) + 1);
        }
        else {
            MD5_CTX Context;
            //
            // The high half of IF->TempState is our history value.
            // The low half is the temporary interface identifier.
            //
            // Append the history value to the usual interface identifier,
            // and calculate the MD5 digest of the resulting quantity.
            // Note MD5 digests and IPv6 addresses are the both 16 bytes,
            // while our history value and the interface identifer are 8 bytes.
            //
            (*IF->CreateToken)(IF->LinkContext, &IF->TempState);
            MD5Init(&Context);
            MD5Update(&Context, (uchar *)&IF->TempState, sizeof IF->TempState);
            MD5Final(&Context);
            memcpy((uchar *)&IF->TempState, Context.digest, MD5DIGESTLEN);
        }

        //
        // Clear the universal/local bit to indicate local significance.
        //
        IF->TempState.s6_bytes[8] &= ~0x2;
    }

    RtlCopyMemory(&Addr->s6_bytes[0], Prefix, 8);
    RtlCopyMemory(&Addr->s6_bytes[8], &IF->TempState.s6_bytes[8], 8);

    //
    // Check that we haven't accidently generated
    // a known anycast address format,
    // or an existing address on the interface.
    //
    if (IsKnownAnycast(Addr) ||
        (*FindADE(IF, Addr) != NULL))
        goto TryAgain;
}


//* AddrConfUpdate - Perform address auto-configuration.
//
//  Called when we receive a valid Router Advertisement
//  with a Prefix Information option that has the A (autonomous) bit set.
//
//  Our caller is responsible for any sanity-checking of the prefix.
//
//  Our caller is responsible for checking that the preferred lifetime
//  is not greater than the valid lifetime.
//
//  Will also optionally return an NTE, with a reference for the caller.
//  This is done when a public address is created.
//
//  Called with NO locks held.
//  Callable from DPC context, not from thread context.
//
void
AddrConfUpdate(
    Interface *IF,
    const IPv6Addr *Prefix,
    uint ValidLifetime,
    uint PreferredLifetime,
    int Authenticated,
    NetTableEntry **pNTE)
{
    NetTableEntry *NTE;
    int Create = TRUE;

    ASSERT(PreferredLifetime <= ValidLifetime);

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);
    //
    // Scan the existing Net Table Entries.
    // Note that some of the list elements
    // are actually ADEs of other flavors.
    //
    for (NTE = (NetTableEntry *)IF->ADE;
         ;
         NTE = (NetTableEntry *)NTE->Next) {

        if (NTE == NULL) {
            //
            // No existing entry for this prefix.
            // Create an entry if the lifetime is non-zero.
            //
            if (Create && (ValidLifetime != 0)) {
                IPv6Addr Addr;

                //
                // Auto-configure a new public address.
                //
                Addr = *Prefix;
                (*IF->CreateToken)(IF->LinkContext, &Addr);

                NTE = (NetTableEntry *) *FindADE(IF, &Addr);
                if (NTE != NULL) {
                    if (NTE->Type == ADE_UNICAST) {
                        //
                        // Resurrect the address for our use.
                        //
                        ASSERT(NTE->DADState == DAD_STATE_INVALID);
                        NTE->ValidLifetime = ValidLifetime;
                        NTE->PreferredLifetime = PreferredLifetime;

                        //
                        // And return this NTE.
                        //
                        AddRefNTE(NTE);
                    }
                    else {
                        //
                        // We can not create the public address.
                        //
                        NTE = NULL;
                        break;
                    }
                }
                else {
                    //
                    // Create the public address, returning the new NTE.
                    //
                    NTE = CreateNTE(IF, &Addr, ADDR_CONF_PUBLIC,
                                    ValidLifetime, PreferredLifetime);
                }

                //
                // Auto-configure a new temporary address,
                // if appropriate.  Note that temporary addresses cannot
                // be used on interfaces that do not support ND, since
                // we have no way to resolve them to link-layer addresses.
                //
                if ((UseTemporaryAddresses != USE_TEMP_NO) &&
                    !IsSiteLocal(Prefix) &&
                    (IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) &&
                    (PreferredLifetime > TempRegenerateTime) &&
                    (NTE != NULL)) {

                    IPv6Addr TempAddr;
                    uint TempValidLife;
                    uint TempPreferredLife;
                    TempNetTableEntry *TempNTE;

                    CreateTemporaryAddress(IF, Prefix, &TempAddr);

                    TempValidLife = MIN(ValidLifetime,
                                        MaxTempValidLifetime);
                    TempPreferredLife = MIN(PreferredLifetime,
                                            TempPreferredLifetime);

                    TempNTE = (TempNetTableEntry *)
                        CreateNTE(IF, &TempAddr, ADDR_CONF_TEMPORARY,
                                  TempValidLife, TempPreferredLife);
                    if (TempNTE != NULL) {
                        //
                        // Create the association between
                        // the temporary & public address.
                        //
                        TempNTE->Public = NTE;

                        //
                        // Initialize the special temporary creation time.
                        // This limits the temporary address's lifetimes.
                        //
                        TempNTE->CreationTime = IPv6TickCount;

                        ReleaseNTE((NetTableEntry *)TempNTE);
                    }
                    else {
                        //
                        // Failure - destroy the public address.
                        //
                        DestroyNTE(IF, NTE);
                        ReleaseNTE(NTE);
                        NTE = NULL;
                    }
                }
            }
            break;
        }

        //
        // Is this a unicast address matching the prefix?
        //
        if ((NTE->Type == ADE_UNICAST) &&
            (NTE->DADState != DAD_STATE_INVALID) &&
            HasPrefix(&NTE->Address, Prefix,
                      IPV6_ADDRESS_LENGTH - IPV6_ID_LENGTH)) {
            //
            // Reset the lifetimes of auto-configured addresses.
            // NB: RFC 2462 says to reset DHCP addresses too,
            // but I think that's wrong.
            //
            // Note that to prevent denial of service,
            // we don't accept updates that lower the lifetime
            // to small values.
            //
            // AddrConfTimeout (called from IPv6Timeout) handles
            // the invalid & deprecated state transitions.
            //
            if (IsStatelessAutoConfNTE(NTE)) {

                if ((ValidLifetime > PREFIX_LIFETIME_SAFETY) ||
                    (ValidLifetime > NTE->ValidLifetime) ||
                    Authenticated)
                    NTE->ValidLifetime = ValidLifetime;
                else if (NTE->ValidLifetime <= PREFIX_LIFETIME_SAFETY)
                    ; // ignore
                else
                    NTE->ValidLifetime = PREFIX_LIFETIME_SAFETY;

                NTE->PreferredLifetime = PreferredLifetime;

                //
                // For temporary addresses, ensure that the lifetimes
                // are not extended indefinitely.
                //
                if (NTE->AddrConf == ADDR_CONF_TEMPORARY) {
                    TempNetTableEntry *TempNTE = (TempNetTableEntry *)NTE;
                    uint Now = IPv6TickCount;

                    //
                    // Must be careful of overflows in these comparisons.
                    // (Eg, TempNTE->ValidLifetime might be INFINITE_LIFETIME.)
                    //          N    Now
                    //          V    TempNTE->ValidLifetime
                    //          MV   MaxTempValidLifetime
                    //          C    TempNTE->CreationTime
                    // We want to check
                    //          N + V > C + MV
                    // Transform this to
                    //          N - C > MV - V
                    // Then underflow of MV - V must be checked but
                    // N - C is not a problem because the tick count wraps.
                    //

                    if ((TempNTE->ValidLifetime > MaxTempValidLifetime) ||
                        (Now - TempNTE->CreationTime >
                         MaxTempValidLifetime - TempNTE->ValidLifetime)) {
                        //
                        // This temporary address is showing its age.
                        // Must curtail its valid lifetime.
                        //
                        if (MaxTempValidLifetime > Now - TempNTE->CreationTime)
                            TempNTE->ValidLifetime =
                                TempNTE->CreationTime +
                                MaxTempValidLifetime - Now;
                        else
                            TempNTE->ValidLifetime = 0;
                    }

                    if ((TempNTE->PreferredLifetime > TempPreferredLifetime) ||
                        (Now - TempNTE->CreationTime >
                         TempPreferredLifetime - TempNTE->PreferredLifetime)) {
                        //
                        // This temporary address is showing its age.
                        // Must curtail its preferred lifetime.
                        //
                        if (TempPreferredLifetime > Now - TempNTE->CreationTime)
                            TempNTE->PreferredLifetime =
                                TempNTE->CreationTime +
                                TempPreferredLifetime - Now;
                        else
                            TempNTE->PreferredLifetime = 0;
                    }
                }

                //
                // Maintain our invariant that the preferred lifetime
                // is not larger than the valid lifetime.
                //
                if (NTE->ValidLifetime < NTE->PreferredLifetime)
                    NTE->PreferredLifetime = NTE->ValidLifetime;
            }

            if (NTE->ValidLifetime != 0) {
                //
                // We found an existing address that matches the prefix,
                // so inhibit auto-configuration of a new address.
                //
                Create = FALSE;
            }
        }
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    if (pNTE != NULL)
        *pNTE = NTE;
    else if (NTE != NULL)
        ReleaseNTE(NTE);
}

//* AddrConfDuplicate
//
//  Duplicate Address Detection has found
//  that the NTE conflicts with some other node.
//
//  Called with the interface locked.
//  Callable from thread or DPC context.
//
void
AddrConfDuplicate(Interface *IF, NetTableEntry *NTE)
{
    int rc;

    ASSERT(NTE->IF == IF);

    if ((NTE->DADState != DAD_STATE_INVALID) &&
        (NTE->DADState != DAD_STATE_DUPLICATE)) {
        IF->DupAddrDetects++;

        if (IsValidNTE(NTE)) {
            if (NTE->DADState == DAD_STATE_PREFERRED) {
                //
                // Queue worker to tell TDI that this address is going away.
                //
                if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
                    DeferRegisterNetAddress(NTE);
                }
            }

            //
            // This NTE is no longer available as a source address.
            //
            InvalidateRouteCache();

            //
            // Disable the loopback route for this address.
            //
            rc = ControlLoopback(IF, &NTE->Address, CONTROL_LOOPBACK_DISABLED);
            ASSERT(rc);
        }

        NTE->DADState = DAD_STATE_DUPLICATE;
        NTE->DADTimer = 0;

        if (NTE->AddrConf == ADDR_CONF_TEMPORARY) {
            NetTableEntry *Public;

            //
            // Make this address invalid so it will go away.
            // NB: We still have a ref for the NTE via our caller.
            //
            DestroyNTE(IF, NTE);

            //
            // Should we create a new temporary address?
            //
            if ((UseTemporaryAddresses != USE_TEMP_NO) &&
                ((Public = ((TempNetTableEntry *)NTE)->Public) != NULL) &&
                (Public->PreferredLifetime > TempRegenerateTime) &&
                (IF->DupAddrDetects < MaxTempDADAttempts)) {

                IPv6Addr TempAddr;
                TempNetTableEntry *NewNTE;
                uint TempValidLife;
                uint TempPreferredLife;

                //
                // Generate a new temporary address,
                // forcing the use of a new interface identifier.
                //
                IF->TempStateAge = 0;
                CreateTemporaryAddress(IF, &NTE->Address, &TempAddr);

                TempValidLife = MIN(Public->ValidLifetime,
                                    MaxTempValidLifetime);
                TempPreferredLife = MIN(Public->PreferredLifetime,
                                        TempPreferredLifetime);

                //
                // Configure the new address.
                //
                NewNTE = (TempNetTableEntry *)
                    CreateNTE(IF, &TempAddr, ADDR_CONF_TEMPORARY,
                              TempValidLife, TempPreferredLife);
                if (NewNTE == NULL) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                               "AddrConfDuplicate: CreateNTE failed\n"));
                }
                else {
                    NewNTE->Public = Public;
                    NewNTE->CreationTime = IPv6TickCount;
                    ReleaseNTE((NetTableEntry *)NewNTE);
                }
            }
        }
    }
}

//* AddrConfNotDuplicate
//
//  Duplicate Address Detection has NOT found
//  a conflict with another node.
//
//  Called with the interface locked.
//  Callable from thread or DPC context.
//
void
AddrConfNotDuplicate(Interface *IF, NetTableEntry *NTE)
{
    int rc;

    //
    // The address has passed Duplicate Address Detection.
    // Transition to a valid state.
    //
    if (! IsValidNTE(NTE)) {
        if (NTE->PreferredLifetime == 0)
            NTE->DADState = DAD_STATE_DEPRECATED;
        else
            NTE->DADState = DAD_STATE_PREFERRED;

        //
        // This NTE is now available as a source address.
        //
        InvalidateRouteCache();

        //
        // Enable the loopback route for this address.
        //
        rc = ControlLoopback(IF, &NTE->Address, CONTROL_LOOPBACK_ENABLED);
        ASSERT(rc);
    }

    //
    // DAD is also triggered through an interface disconnect to connect
    // transition in which case the address is not registered with TDI
    // even if it is in the preferred state.  Hence we queue a worker to
    // tell TDI about this address outside the "if (!IsValidNTE)" clause.
    //
    if ((NTE->DADState == DAD_STATE_PREFERRED) &&
        !(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
        DeferRegisterNetAddress(NTE);
    }
}

//* AddrConfResetAutoConfig
//
//  Resets the interface's auto-configured address lifetimes.
//
//  Called with the interface locked.
//  Callable from thread or DPC context.
//
void
AddrConfResetAutoConfig(Interface *IF, uint MaxLifetime)
{
    NetTableEntry *NTE;

    for (NTE = (NetTableEntry *) IF->ADE;
         NTE != NULL;
         NTE = (NetTableEntry *) NTE->Next) {

        //
        // Is this an auto-configured unicast address?
        //
        if ((NTE->Type == ADE_UNICAST) &&
            IsStatelessAutoConfNTE(NTE)) {

            //
            // Set the valid lifetime to a small value.
            // If we don't get an RA soon, the address will expire.
            //
            if (NTE->ValidLifetime > MaxLifetime)
                NTE->ValidLifetime = MaxLifetime;
            if (NTE->PreferredLifetime > NTE->ValidLifetime)
                NTE->PreferredLifetime = NTE->ValidLifetime;
        }
    }
}

//* ReconnectADEs
//
//  Callable from thread or DPC context.
//  Called with the interface locked.
//
//  (Actually, we are at DPC level because we hold the interface lock.)
//
void
ReconnectADEs(Interface *IF)
{
    AddressEntry *ADE;

    for (ADE = IF->ADE; ADE != NULL; ADE = ADE->Next) {
        switch (ADE->Type) {
        case ADE_UNICAST: {
            NetTableEntry *NTE = (NetTableEntry *) ADE;

            if (NTE->DADState != DAD_STATE_INVALID) {
                //
                // Restart Duplicate Address Detection,
                // if it is enabled for this interface.
                //
                AddrConfStartDAD(IF, NTE);
            }
            break;
        }

        case ADE_ANYCAST:
            //
            // Nothing to do for anycast addresses.
            //
            break;

        case ADE_MULTICAST: {
            MulticastAddressEntry *MAE = (MulticastAddressEntry *) ADE;

            //
            // Rejoin this multicast group,
            // if it is reportable.
            //
            KeAcquireSpinLockAtDpcLevel(&QueryListLock);
            if (MAE->MCastFlags & MAE_REPORTABLE) {
                MAE->MCastCount = MLD_NUM_INITIAL_REPORTS;
                if (MAE->MCastTimer == 0)
                    AddToQueryList(MAE);
                MAE->MCastTimer = 1;
            }
            KeReleaseSpinLockFromDpcLevel(&QueryListLock);
            break;
        }
        }
    }
}

//* DisconnectADEs
//
//  Callable from thread or DPC context.
//  Called with the interface locked.
//
//  (Actually, we are at DPC level because we hold the interface lock.)
//
void
DisconnectADEs(Interface *IF)
{
    AddressEntry *ADE;

    ASSERT(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED);

    for (ADE = IF->ADE; ADE != NULL; ADE = ADE->Next) {
        if (ADE->Type == ADE_UNICAST) {
            NetTableEntry *NTE = (NetTableEntry *) ADE;

            if (NTE->DADState == DAD_STATE_PREFERRED) {
                //
                // Queue worker to tell TDI that this address is going away.
                //
                DeferRegisterNetAddress(NTE);
            }
        }

        //
        // Nothing to do for anycast or multicast addresses.
        //        
    }
}

//* DestroyNTE
//
//  Make an NTE be invalid, resulting in its eventual destruction.
//
//  In the DestroyIF case, the NTE has already been removed
//  from the interface. In other situations, that doesn't happen
//  until later, when NetTableCleanup runs.
//
//  Callable from thread or DPC context.
//  Called with the interface locked.
//
//  (Actually, we are at DPC level because we hold the interface lock.)
//
void
DestroyNTE(Interface *IF, NetTableEntry *NTE)
{
    int rc;

    ASSERT(NTE->IF == IF);

    if (NTE->DADState != DAD_STATE_INVALID) {

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "DestroyNTE(NTE %p, Addr %s) -> invalid\n",
                   NTE, FormatV6Address(&NTE->Address)));

        if (IsValidNTE(NTE)) {
            if (NTE->DADState == DAD_STATE_PREFERRED) {
                //
                // Queue worker to tell TDI that this address is going away.
                //
                if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
                    DeferRegisterNetAddress(NTE);
                }
            }

            //
            // This NTE is no longer available as a source address.
            //
            InvalidateRouteCache();

            //
            // Disable the loopback route for this address.
            //
            rc = ControlLoopback(IF, &NTE->Address, CONTROL_LOOPBACK_DISABLED);
            ASSERT(rc);
        }

        //
        // Invalidate this address.
        //
        NTE->DADState = DAD_STATE_INVALID;
        NTE->DADTimer = 0;

        //
        // We have to set its lifetime to zero,
        // or else AddrConfTimeout will attempt
        // to resurrect this address.
        //
        NTE->ValidLifetime = 0;
        NTE->PreferredLifetime = 0;

        //
        // The corresponding solicited-node address is not needed.
        //
        FindAndReleaseSolicitedNodeMAE(IF, &NTE->Address);

        if (NTE == IF->LinkLocalNTE) {
            //
            // Unmark it as the primary link-local NTE.
            // GetLinkLocalAddress will update LinkLocalNTE lazily.
            //
            IF->LinkLocalNTE = NULL;
        }

        //
        // Release the interface's reference for the NTE.
        //
        ReleaseNTE(NTE);
    }
}


//* EnlivenNTE
//
//  Make an NTE come alive, transitioning out of DAD_STATE_INVALID.
//
//  Callable from thread or DPC context.
//  Called with the interface locked.
//
void
EnlivenNTE(Interface *IF, NetTableEntry *NTE)
{
    ASSERT(NTE->DADState == DAD_STATE_INVALID);
    ASSERT(NTE->ValidLifetime != 0);

    //
    // The NTE needs a corresponding solicited-node MAE.
    // If this fails, leave the address invalid and
    // try again later.
    //
    if (FindOrCreateSolicitedNodeMAE(IF, &NTE->Address)) {
        //
        // The interface needs a reference for the NTE,
        // because we are enlivening it.
        //
        AddRefNTE(NTE);

        //
        // Start the address in the tentative state.
        //
        NTE->DADState = DAD_STATE_TENTATIVE;

        //
        // Start duplicate address detection.
        //
        AddrConfStartDAD(IF, NTE);
    }
}


//* AddrConfTimeout - Perform valid/preferred lifetime expiration.
//
//  Called periodically from NetTableTimeout on every NTE.
//  As usual, caller must hold a reference for the NTE.
//
//  Called with NO locks held.
//  Callable from DPC context, not from thread context.
//
void
AddrConfTimeout(NetTableEntry *NTE)
{
    Interface *IF = NTE->IF;
    int QueueWorker = FALSE;
    NetTableEntry *Public;

    ASSERT(NTE->Type == ADE_UNICAST);

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    if (NTE->ValidLifetime == 0) {
        //
        // If the valid lifetime is zero, then the NTE should be invalid.
        //
        DestroyNTE(IF, NTE);
    }
    else {
        //
        // If the valid lifetime is non-zero, then the NTE should be alive.
        //
        if (NTE->DADState == DAD_STATE_INVALID)
            EnlivenNTE(IF, NTE);

        if (NTE->ValidLifetime != INFINITE_LIFETIME)
            NTE->ValidLifetime--;
    }

    //
    // Note that TempRegenerateTime might be zero.
    // In which case it's important to only do this
    // when transitioning from preferred to deprecated,
    // NOT every time the preferred lifetime is zero.
    //
    if ((NTE->AddrConf == ADDR_CONF_TEMPORARY) &&
        (NTE->DADState == DAD_STATE_PREFERRED) &&
        (NTE->PreferredLifetime == TempRegenerateTime) &&
        (IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) &&
        (UseTemporaryAddresses != USE_TEMP_NO) &&
        ((Public = ((TempNetTableEntry *)NTE)->Public) != NULL) &&
        (Public->PreferredLifetime > TempRegenerateTime)) {

        IPv6Addr TempAddr;
        TempNetTableEntry *NewNTE;
        uint TempValidLife;
        uint TempPreferredLife;

        //
        // We will soon deprecate this temporary address,
        // so create a new temporary address.
        //

        CreateTemporaryAddress(IF, &NTE->Address, &TempAddr);

        TempValidLife = MIN(Public->ValidLifetime,
                            MaxTempValidLifetime);
        TempPreferredLife = MIN(Public->PreferredLifetime,
                                TempPreferredLifetime);

        //
        // Configure the new address.
        //
        NewNTE = (TempNetTableEntry *)
            CreateNTE(IF, &TempAddr, ADDR_CONF_TEMPORARY,
                      TempValidLife, TempPreferredLife);
        if (NewNTE == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "AddrConfTimeout: CreateNTE failed\n"));
        }
        else {
            NewNTE->Public = Public;
            NewNTE->CreationTime = IPv6TickCount;
            ReleaseNTE((NetTableEntry *)NewNTE);
        }
    }

    //
    // If the preferred lifetime is zero, then the NTE should be deprecated.
    //
    if (NTE->PreferredLifetime == 0) {
        if (NTE->DADState == DAD_STATE_PREFERRED) {

            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "AddrConfTimeout(NTE %p, Addr %s) -> deprecated\n",
                       NTE, FormatV6Address(&NTE->Address)));

            //
            // Make this address be deprecated.
            //
            NTE->DADState = DAD_STATE_DEPRECATED;
            if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
                QueueWorker = TRUE;
            }
            InvalidateRouteCache();
        }
    } else {
        //
        // If the address was deprecated, then it should be preferred.
        // (AddrConfUpdate must have just increased the preferred lifetime.)
        //
        if (NTE->DADState == DAD_STATE_DEPRECATED) {
            NTE->DADState = DAD_STATE_PREFERRED;
            if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
                QueueWorker = TRUE;
            }
            InvalidateRouteCache();
        }

        if (NTE->PreferredLifetime != INFINITE_LIFETIME)
            NTE->PreferredLifetime--;
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    if (QueueWorker)
        DeferRegisterNetAddress(NTE);
}


//* NetTableCleanup
//
//  Cleans up any NetTableEntries with zero references.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
void
NetTableCleanup(void)
{
    NetTableEntry *DestroyList = NULL;
    NetTableEntry *NTE, *NextNTE;
    Interface *IF;
    KIRQL OldIrql;
    int rc;

    KeAcquireSpinLock(&NetTableListLock, &OldIrql);

    for (NTE = NetTableList; NTE != NULL; NTE = NextNTE) {
        NextNTE = NTE->NextOnNTL;

        if (NTE->RefCnt == 0) {
            ASSERT(NTE->DADState == DAD_STATE_INVALID);

            //
            // We want to destroy this NTE.
            // We have to release the list lock
            // before we can acquire the interface lock,
            // but we need references to hold the NTEs.
            //
            AddRefNTE(NTE);
            if (NextNTE != NULL)
                AddRefNTE(NextNTE);
            KeReleaseSpinLock(&NetTableListLock, OldIrql);

            IF = NTE->IF;
            KeAcquireSpinLock(&IF->Lock, &OldIrql);
            KeAcquireSpinLockAtDpcLevel(&NetTableListLock);

            //
            // Now that we have the appropriate locks.
            // Is no one else using this NTE?
            //
            ReleaseNTE(NTE);
            if (NTE->RefCnt == 0) {
                //
                // OK, we will destroy this NTE.
                // First remove from the list.
                //
                RemoveNTEFromNetTableList(NTE);

                //
                // It is now safe to release the list lock,
                // because the NTE is removed from the list.
                // We continue to hold the interface lock,
                // so nobody can find this NTE via the interface.
                //
                KeReleaseSpinLockFromDpcLevel(&NetTableListLock);

                //
                // Remove ADEs that reference this address.
                // Note that this also removes from the interface's list,
                // but does not free, the NTE itself.
                // NB: In the case of DestroyIF, the ADEs are already
                // removed from the interface and DestroyADEs does nothing.
                //
                DestroyADEs(IF, NTE);

                //
                // Release the loopback route.
                //
                rc = ControlLoopback(IF, &NTE->Address,
                                     CONTROL_LOOPBACK_DESTROY);
                ASSERT(rc);

                KeReleaseSpinLock(&IF->Lock, OldIrql);

                //
                // Put this NTE on the destroy list.
                //
                NTE->NextOnNTL = DestroyList;
                DestroyList = NTE;

                KeAcquireSpinLock(&NetTableListLock, &OldIrql);
            }
            else { // if (NTE->RefCnt != 0)
                //
                // We will not be destroying this NTE after all.
                // Release the interface lock but keep the list lock.
                //
                KeReleaseSpinLockFromDpcLevel(&IF->Lock);
            }

            //
            // At this point, we have the list lock again
            // so we can release our reference for NextNTE.
            //
            if (NextNTE != NULL)
                ReleaseNTE(NextNTE);
        }
    }

    KeReleaseSpinLock(&NetTableListLock, OldIrql);

    while (DestroyList != NULL) {
        NTE = DestroyList;
        DestroyList = NTE->NextOnNTL;

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "NetTableCleanup(NTE %p, Addr %s) -> destroyed\n",
                   NTE, FormatV6Address(&NTE->Address)));

        ReleaseIF(NTE->IF);
        ExFreePool(NTE);
    }
}


//* NetTableTimeout
//
//  Called periodically from IPv6Timeout.
//
//  Called with NO locks held.
//  Callable from DPC context, not from thread context.
//
void
NetTableTimeout(void)
{
    NetTableEntry *NTE;
    int SawZeroReferences = FALSE;

    //
    // Because new NTEs are only added at the head of the list,
    // we can unlock the list during our traversal
    // and know that the traversal will terminate properly.
    //

    KeAcquireSpinLockAtDpcLevel(&NetTableListLock);
    for (NTE = NetTableList; NTE != NULL; NTE = NTE->NextOnNTL) {
        AddRefNTE(NTE);
        KeReleaseSpinLockFromDpcLevel(&NetTableListLock);

        //
        // Check for Duplicate Address Detection timeout.
        // The timer check here is only an optimization,
        // because it is made without holding the appropriate lock.
        //
        if (NTE->DADTimer != 0)
            DADTimeout(NTE);

        //
        // Perform lifetime expiration.
        //
        AddrConfTimeout(NTE);

        KeAcquireSpinLockAtDpcLevel(&NetTableListLock);
        ReleaseNTE(NTE);

        //
        // We assume that loads of RefCnt are atomic.
        //
        if (NTE->RefCnt == 0)
            SawZeroReferences = TRUE;
    }
    KeReleaseSpinLockFromDpcLevel(&NetTableListLock);

    if (SawZeroReferences)
        NetTableCleanup();
}


//* InterfaceCleanup
//
//  Cleans up any Interfaces with zero references.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
void
InterfaceCleanup(void)
{
    Interface *DestroyList = NULL;
    Interface *IF, **PrevIF;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IFListLock, &OldIrql);

    PrevIF = &IFList;
    while ((IF = *PrevIF) != NULL) {

        if (IF->RefCnt == 0) {

            ASSERT(IsDisabledIF(IF));
            *PrevIF = IF->Next;
            IF->Next = DestroyList;
            DestroyList = IF;
            IPSInfo.ipsi_numif--;

        } else {
            PrevIF = &IF->Next;
        }
    }

    KeReleaseSpinLock(&IFListLock, OldIrql);

    while (DestroyList != NULL) {
        IF = DestroyList;
        DestroyList = IF->Next;

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "InterfaceCleanup(IF %u/%p) -> destroyed\n",
                   IF->Index, IF));

        //
        // ADEs should already be destroyed.
        // We just need to cleanup NCEs and free the interface.
        //
        ASSERT(IF->ADE == NULL);
        NeighborCacheDestroy(IF);
        if (IF->MCastAddresses != NULL)
            ExFreePool(IF->MCastAddresses);
        DeferDeregisterInterface(IF);
    }
}


//* InterfaceTimeout
//
//  Called periodically from IPv6Timeout.
//
//  Called with NO locks held.
//  Callable from DPC context, not from thread context.
//
void
InterfaceTimeout(void)
{
    static uint RecalcReachableTimer = 0;
    int RecalcReachable;
    int ForceRAs;
    Interface *IF;
    int SawZeroReferences = FALSE;

    //
    // Recalculate ReachableTime every few hours,
    // even if no Router Advertisements are received.
    //
    if (RecalcReachableTimer == 0) {
        RecalcReachable = TRUE;
        RecalcReachableTimer = RECALC_REACHABLE_INTERVAL;
    } else {
        RecalcReachable = FALSE;
        RecalcReachableTimer--;
    }

    //
    // Grab the value of ForceRouterAdvertisements.
    //
    ForceRAs = InterlockedExchange((PLONG)&ForceRouterAdvertisements, FALSE);

    //
    // Because new interfaces are only added at the head of the list,
    // we can unlock the list during our traversal
    // and know that the traversal will terminate properly.
    //

    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    for (IF = IFList; IF != NULL; IF = IF->Next) {
        //
        // We should not do any processing on an interface
        // that has zero references. As an even stronger condition,
        // we avoid doing any timeout processing if the interface
        // is being destroyed. Of course, the interface might be
        // destroyed after we drop the interface list lock.
        //
        if (! IsDisabledIF(IF)) {
            AddRefIF(IF);
            KeReleaseSpinLockFromDpcLevel(&IFListLock);

            //
            // Handle per-neighbor timeouts.
            //
            NeighborCacheTimeout(IF);

            //
            // Handle router solicitations.
            // The timer check here is only an optimization,
            // because it is made without holding the appropriate lock.
            //
            if (IF->RSTimer != 0)
                RouterSolicitTimeout(IF);

            //
            // Handle router advertisements.
            // The timer check here is only an optimization,
            // because it is made without holding the appropriate lock.
            //
            if (IF->RATimer != 0)
                RouterAdvertTimeout(IF, ForceRAs);

            //
            // Recalculate the reachable time.
            //
            if (RecalcReachable) {

                KeAcquireSpinLockAtDpcLevel(&IF->Lock);
                IF->ReachableTime = CalcReachableTime(IF->BaseReachableTime);
                KeReleaseSpinLockFromDpcLevel(&IF->Lock);
            }

            KeAcquireSpinLockAtDpcLevel(&IFListLock);
            ReleaseIF(IF);
        }

        //
        // We assume that loads of RefCnt are atomic.
        //
        if (IF->RefCnt == 0)
            SawZeroReferences = TRUE;
    }
    KeReleaseSpinLockFromDpcLevel(&IFListLock);

    if (SawZeroReferences)
        InterfaceCleanup();
}


//* InterfaceStartAdvertising
//
//  If the interface is not currently advertising,
//  makes it start advertising.
//
//  Called with the interface locked.
//  Caller must check whether the interface is disabled.
//
NTSTATUS
InterfaceStartAdvertising(Interface *IF)
{
    ASSERT(! IsDisabledIF(IF));
    ASSERT(IF->Flags & IF_FLAG_ROUTER_DISCOVERS);

    if (!(IF->Flags & IF_FLAG_ADVERTISES)) {
        //
        // Join the all-routers multicast groups.
        //
        if (! JoinGroupAtAllScopes(IF, &AllRoutersOnLinkAddr,
                                 ADE_SITE_LOCAL))
            return STATUS_INSUFFICIENT_RESOURCES;

        //
        // A non-advertising interface is now advertising.
        //
        IF->Flags |= IF_FLAG_ADVERTISES;

        //
        // The reconnecting state is not useful
        // for advertising interfaces because
        // the interface will not receive RAs.
        //
        IF->Flags &= ~IF_FLAG_MEDIA_RECONNECTED;

        //
        // Remove addresses & routes that were auto-configured
        // from Router Advertisements. Advertising interfaces
        // must be manually configured. Better to remove it
        // now than let it time-out at some random time.
        //
        AddrConfResetAutoConfig(IF, 0);
        RouteTableResetAutoConfig(IF, 0);
        InterfaceResetAutoConfig(IF);

        //
        // Start sending Router Advertisements.
        //
        IF->RATimer = 1; // Send first RA very quickly.
        IF->RACount = MAX_INITIAL_RTR_ADVERTISEMENTS;

        //
        // Stop sending Router Solicitations.
        //
        IF->RSTimer = 0;
    }

    return STATUS_SUCCESS;
}


//* InterfaceStopAdvertising
//
//  If the interface is currently advertising,
//  stops the advertising behavior.
//
//  Called with the interface locked.
//  Caller must check whether the interface is disabled.
//
void
InterfaceStopAdvertising(Interface *IF)
{
    ASSERT(! IsDisabledIF(IF));

    if (IF->Flags & IF_FLAG_ADVERTISES) {
        //
        // Leave the all-routers multicast group.
        //
        LeaveGroupAtAllScopes(IF, &AllRoutersOnLinkAddr,
                              ADE_SITE_LOCAL);

        //
        // Stop sending Router Advertisements.
        //
        IF->Flags &= ~IF_FLAG_ADVERTISES;
        IF->RATimer = 0;

        //
        // Remove addresses that were auto-configured
        // from our own Router Advertisements.
        // We will pick up new address lifetimes
        // from other router's Advertisements.
        // If some other router is not advertising
        // the prefixes that this router was advertising,
        // better to remove the addresses now than
        // let them time-out at some random time.
        //
        AddrConfResetAutoConfig(IF, 0);

        //
        // There shouldn't be any auto-configured routes,
        // but RouteTableResetAutoConfig also handles site prefixes.
        //
        RouteTableResetAutoConfig(IF, 0);

        //
        // Restore interface parameters.
        //
        InterfaceResetAutoConfig(IF);

        //
        // Send Router Solicitations again.
        //
        IF->RSCount = 0;
        IF->RSTimer = 1;
    }
}


//* InterfaceStartForwarding
//
//  If the interface is not currently forwarding,
//  makes it start forwarding.
//
//  Called with the interface locked.
//
void
InterfaceStartForwarding(Interface *IF)
{
    if (!(IF->Flags & IF_FLAG_FORWARDS)) {
        //
        // Any change in forwarding behavior requires InvalidRouteCache
        // because FindNextHop uses IF_FLAG_FORWARDS. Also force the next RA
        // for all advertising interfaces to be sent quickly,
        // because their content might depend on forwarding behavior.
        //
        IF->Flags |= IF_FLAG_FORWARDS;
        InterlockedIncrement((PLONG)&NumForwardingInterfaces);
        InvalidateRouteCache();
        ForceRouterAdvertisements = TRUE;
    }
}


//* InterfaceStopForwarding
//
//  If the interface is currently forwarding,
//  stops the forwarding behavior.
//
//  Called with the interface locked.
//
void
InterfaceStopForwarding(Interface *IF)
{
    if (IF->Flags & IF_FLAG_FORWARDS) {
        //
        // Any change in forwarding behavior requires InvalidRouteCache
        // because FindNextHop uses IF_FLAG_FORWARDS. Also force the next RA
        // for all advertising interfaces to be sent quickly,
        // because their content might depend on forwarding behavior.
        //
        IF->Flags &= ~IF_FLAG_FORWARDS;
        InterlockedDecrement((PLONG)&NumForwardingInterfaces);
        InvalidateRouteCache();
        ForceRouterAdvertisements = TRUE;
    }
}


//* AddrConfResetManualConfig
//
//  Removes manually-configured addresses from the interface.
//
//  Called with the interface already locked.
//
void
AddrConfResetManualConfig(Interface *IF)
{
    AddressEntry *AnycastList = NULL;
    AddressEntry *ADE, **PrevADE;

    //
    // We have to be careful about how we destroy addresses,
    // because FindAndReleaseSolicitedNodeMAE will mess up our traversal.
    //
    PrevADE = &IF->ADE;
    while ((ADE = *PrevADE) != NULL) {
        //
        // Is this a manually configured address?
        //
        switch (ADE->Type) {
        case ADE_UNICAST: {
            NetTableEntry *NTE = (NetTableEntry *) ADE;

            if (NTE->AddrConf == ADDR_CONF_MANUAL) {
                //
                // Let NetTableTimeout destroy the address.
                //
                NTE->ValidLifetime = 0;
                NTE->PreferredLifetime = 0;
            }
            break;
        }

        case ADE_ANYCAST:
            //
            // Most anycast addresses are manually configured.
            // Subnet anycast addresses are the only exception.
            // They are also the only anycast addresses
            // which point to an NTE instead of the interface.
            //
            if (ADE->IF == IF) {
                //
                // Remove the ADE from the interface list.
                //
                *PrevADE = ADE->Next;

                //
                // Put the ADE on our temporary list.
                //
                ADE->Next = AnycastList;
                AnycastList = ADE;
                continue;
            }
            break;
        }

        PrevADE = &ADE->Next;
    }

    //
    // Now we can safely process the anycast ADEs.
    //
    while ((ADE = AnycastList) != NULL) {
        AnycastList = ADE->Next;
        DeleteAAE(IF, (AnycastAddressEntry *)ADE);
    }
}


//* InterfaceResetAutoConfig
//
//  Resets interface parameters that are auto-configured
//  from Router Advertisements.
//
//  Called with the interface already locked.
//
void
InterfaceResetAutoConfig(Interface *IF)
{
    IF->LinkMTU = IF->DefaultLinkMTU;
    if (IF->BaseReachableTime != REACHABLE_TIME) {
        IF->BaseReachableTime = REACHABLE_TIME;
        IF->ReachableTime = CalcReachableTime(IF->BaseReachableTime);
    }
    IF->RetransTimer = RETRANS_TIMER;
    IF->CurHopLimit = DefaultCurHopLimit;
}


//* InterfaceResetManualConfig
//
//  Resets the manual configuration of the interface.
//  Does not remove manual routes on the interface.
//
//  Called with ZoneUpdateLock held.
//
void
InterfaceResetManualConfig(Interface *IF)
{
    KeAcquireSpinLockAtDpcLevel(&IF->Lock);
    if (! IsDisabledIF(IF)) {
        uint ZoneIndices[ADE_NUM_SCOPES];

        //
        // Reset manually-configured interface parameters.
        //
        IF->LinkMTU = IF->DefaultLinkMTU;
        IF->Preference = IF->DefaultPreference;
        if (IF->BaseReachableTime != REACHABLE_TIME) {
            IF->BaseReachableTime = REACHABLE_TIME;
            IF->ReachableTime = CalcReachableTime(IF->BaseReachableTime);
        }
        IF->RetransTimer = RETRANS_TIMER;
        IF->DupAddrDetectTransmits = IF->DefaultDupAddrDetectTransmits;
        IF->CurHopLimit = DefaultCurHopLimit;
        IF->DefSitePrefixLength = DEFAULT_SITE_PREFIX_LENGTH;

        //
        // ZoneUpdateLock is held by our caller.
        //
        InitZoneIndices(ZoneIndices, IF->Index);
        UpdateZoneIndices(IF, ZoneIndices);

        //
        // Remove manually-configured addresses.
        //
        AddrConfResetManualConfig(IF);

        //
        // Stop advertising and forwarding,
        // if either of those behaviors are enabled.
        //
        InterfaceStopAdvertising(IF);
        InterfaceStopForwarding(IF);

        //
        // Reset the firewall mode.
        //
        IF->Flags &= ~IF_FLAG_FIREWALL_ENABLED;
    }
    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
}


//* InterfaceReset
//
//  Resets manual configuration for all interfaces.
//  Tunnel interfaces are destroyed.
//  Other interfaces have their attributes reset to default values.
//  Manually-configured addresses are removed.
//
//  The end result should be the same as if the machine
//  had just booted without any persistent configuration.
//
//  Called with no locks held.
//
void
InterfaceReset(void)
{
    Interface *IF;
    KIRQL OldIrql;

    //
    // Because new interfaces are only added at the head of the list,
    // we can unlock the list during our traversals
    // and know that the traversal will terminate properly.
    //

    //
    // First destroy any manually configured tunnel interfaces.
    //
    KeAcquireSpinLock(&IFListLock, &OldIrql);
    for (IF = IFList; IF != NULL; IF = IF->Next) {
        //
        // We should not do any processing (even just AddRefIF) on an interface
        // that has zero references. As an even stronger condition,
        // we avoid doing any processing if the interface
        // is being destroyed. Of course, the interface might be
        // destroyed after we drop the interface list lock.
        //
        if (! IsDisabledIF(IF)) {
            AddRefIF(IF);
            KeReleaseSpinLock(&IFListLock, OldIrql);

            if ((IF->Type == IF_TYPE_TUNNEL_6OVER4) ||
                (IF->Type == IF_TYPE_TUNNEL_V6V4)) {
                //
                // Destroy the tunnel interface.
                //
                DestroyIF(IF);
            }

            KeAcquireSpinLock(&IFListLock, &OldIrql);
            ReleaseIF(IF);
        }
    }
    KeReleaseSpinLock(&IFListLock, OldIrql);

    //
    // Now reset the remaining interfaces,
    // while holding ZoneUpdateLock so
    // InterfaceResetManualConfig can reset
    // the zone indices consistently across the interfaces.
    //
    KeAcquireSpinLock(&ZoneUpdateLock, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(&IFListLock);
    for (IF = IFList; IF != NULL; IF = IF->Next) {
        if (! IsDisabledIF(IF)) {
            AddRefIF(IF);
            KeReleaseSpinLockFromDpcLevel(&IFListLock);

            //
            // Reset the interface.
            //
            InterfaceResetManualConfig(IF);

            KeAcquireSpinLockAtDpcLevel(&IFListLock);
            ReleaseIF(IF);
        }
    }
    KeReleaseSpinLockFromDpcLevel(&IFListLock);
    KeReleaseSpinLock(&ZoneUpdateLock, OldIrql);
}


//* UpdateInterface
//
//  Allows the forwarding & advertising attributes
//  of an interface to be changed.
//
//  Called with no locks held.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad Interface.
//      STATUS_INSUFFICIENT_RESOURCES
//      STATUS_SUCCESS
//
NTSTATUS
UpdateInterface(
    Interface *IF,
    int Advertises,
    int Forwards)
{
    KIRQL OldIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    if (IsDisabledIF(IF)) {
        //
        // Do not update an interface that is being destroyed.
        //
        Status = STATUS_INVALID_PARAMETER_1;
    }
    else if (Advertises == -1) {
        //
        // Do not change the Advertises attribute.
        //
    }
    else if (!(IF->Flags & IF_FLAG_ROUTER_DISCOVERS)) {
        //
        // The Advertises attribute can only be controlled
        // on interfaces that support Neighbor Discovery.
        //
        Status = STATUS_INVALID_PARAMETER_1;
    }
    else {
        //
        // Control the advertising behavior of the interface.
        //
        if (Advertises) {
            //
            // Become an advertising interfacing,
            // if it is not already.
            //
            Status = InterfaceStartAdvertising(IF);
        }
        else {
            //
            // Stop being an advertising interface,
            // if it is currently advertising.
            //
            InterfaceStopAdvertising(IF);
        }
    }

    //
    // Control the forwarding behavior, if we haven't had an error.
    //
    if ((Status == STATUS_SUCCESS) && (Forwards != -1)) {
        if (Forwards) {
            //
            // If the interface is not currently forwarding,
            // enable forwarding.
            //
            InterfaceStartForwarding(IF);
        }
        else {
            //
            // If the interface is currently forwarding,
            // disable forwarding.
            //
            InterfaceStopForwarding(IF);
        }
    }

    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return Status;
}

//* ReconnectInterface
//
//  Reconnect the interface.  Called when a media connect notification
//  is received (SetInterfaceLinkStatus) or when processing a renew
//  request by IOCTL_IPV6_UPDATE_INTERFACE (IoctlUpdateInterface).
//
//  Called with the interface already locked.
//
void
ReconnectInterface(
    Interface *IF)
{
    ASSERT(!IsDisabledIF(IF) && !(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED));

    //
    // Purge potentially obsolete link-layer information.
    // Things might have changed while we were unplugged.
    //
    NeighborCacheFlush(IF, NULL);
    
    //
    // Rejoin multicast groups and restart Duplicate Address Detection.
    //
    // Preferred unicast addresses are registered with TDI when
    // duplicate address detection completes (or is disabled).
    //
    ReconnectADEs(IF);

    if (IF->Flags & IF_FLAG_ROUTER_DISCOVERS) {
        if (IF->Flags & IF_FLAG_ADVERTISES) {
            //
            // Send a Router Advertisement very soon.
            //
            IF->RATimer = 1;
        }
        else {
            //
            // Start sending Router Solicitations.
            //
            IF->RSCount = 0;
            IF->RSTimer = 1;

            //
            // Remember that this interface was just reconnected,
            // so when we receive a Router Advertisement
            // we can take special action.
            //
            IF->Flags |= IF_FLAG_MEDIA_RECONNECTED;
        }
    }
    
    //
    // We might have moved to a new link.
    // Force the generation of a new temporary interface identifier.
    // This only really makes a difference if we generate
    // new addresses on this link - if it's the same link then
    // we continue to use our old addresses, both public & temporary.
    //
    IF->TempStateAge = 0;    
}


//* DisconnectInterface
//
//  Disconnect the interface.  Called when a media disconnect
//  notification is received (SetInterfaceLinkStatus) for a connected
//  interface.
//
//  Called with the interface already locked.
//
void
DisconnectInterface(
    Interface *IF)
{
    ASSERT(!IsDisabledIF(IF) && (IF->Flags & IF_FLAG_MEDIA_DISCONNECTED));

    //
    // Deregister any preferred unicast addresses from TDI.
    //
    DisconnectADEs(IF);
}


//* SetInterfaceLinkStatus
//
//  Change the interface's link status. In particular,
//  set whether the media is connected or disconnected.
//
//  May be called when the interface has zero references
//  and is already being destroyed.
//
void
SetInterfaceLinkStatus(
    void *Context,
    int MediaConnected)         // TRUE or FALSE.
{
    Interface *IF = (Interface *) Context;
    KIRQL OldIrql;

    //
    // Note that media-connect/disconnect events
    // can be "lost". We are not informed if the
    // cable is unplugged/replugged while we are
    // shutdown, hibernating, or on standby.
    //

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "SetInterfaceLinkStatus(IF %p) -> %s\n",
               IF, MediaConnected ? "connected" : "disconnected"));

    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    if (! IsDisabledIF(IF)) {
        if (MediaConnected) {
            if (IF->Flags & IF_FLAG_MEDIA_DISCONNECTED) {
                //
                // The cable was plugged back in.
                //
                IF->Flags &= ~IF_FLAG_MEDIA_DISCONNECTED;

                //
                // Changes in IF_FLAG_MEDIA_DISCONNECTED must
                // invalidate the route cache.
                //
                InvalidateRouteCache();
            }

            //
            // A connect event implies a change in the interface state
            // regardless of whether the interface is already connected.
            // Hence we process it outside the 'if' clause.
            //
            ReconnectInterface(IF);
        }
        else {
            if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)) {
                //
                // The cable was unplugged.
                //
                IF->Flags = (IF->Flags | IF_FLAG_MEDIA_DISCONNECTED) &~
                    IF_FLAG_MEDIA_RECONNECTED;

                //
                // Changes in IF_FLAG_MEDIA_DISCONNECTED must
                // invalidate the route cache.
                //
                InvalidateRouteCache();

                //
                // A disconnect event implies a change in the interface
                // state only if the interface is already connected.
                // Hence we process it inside the 'if' clause.
                //
                DisconnectInterface(IF);
            }
        }
    }

    KeReleaseSpinLock(&IF->Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\inc\udp.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// User Datagram Protocol definitions.
//


#include "datagram.h"

//
// UDP's IP protocol number.
//
#define IP_PROTOCOL_UDP 17

//
// Structure of a UDP header.
//
typedef struct UDPHeader {
    ushort Source;    // Source port.
    ushort Dest;      // Destination port.
    ushort Length;    // Length.
    ushort Checksum;  // Checksum.
} UDPHeader;


//
// External definition of exported functions.
//
extern ProtoRecvProc UDPReceive;
extern ProtoControlRecvProc UDPControlReceive;

extern void UDPSend(AddrObj *SrcAO, DGSendReq *SendReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\info.c ===
#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "ipexport.h"
#include "icmp.h"
#include "neighbor.h"
#include "route.h"
#include <tdiinfo.h>
#include <tdi.h>
#include <tdistat.h>
#include "info.h"
#include "fragment.h"

//* IPv6QueryInfo - IP query information handler.
//
//  Called by the upper layer when it wants to query information about us.
//  We take in an ID, a buffer and length, and a context value, and return
//  whatever information we can.
//
//  Input:  ID          - Pointer to ID structure.
//          Buffer      - Pointer to buffer chain.
//          Size        - Pointer to size in bytes of buffer. On return, filled
//                          in with bytes read.
//          Context     - Pointer to context value.
//
//  Returns: TDI_STATUS of attempt to read information.
//
TDI_STATUS
IPv6QueryInfo(
    TDIObjectID *ID,
    PNDIS_BUFFER Buffer,
    uint *Size,
    void *Context,
    uint ContextSize)
{
    uint BufferSize = *Size;
    uint BytesCopied;
    uint Entity;
    uint Instance;

    Entity = ID->toi_entity.tei_entity;
    Instance = ID->toi_entity.tei_instance;

    *Size = 0;                    // Set to 0 in case of an error.

    // See if it's something we might handle.
    if ((Entity != CL_NL_ENTITY) || (Instance != 0))
        return TDI_INVALID_REQUEST;

    // The request is for us.

    if ((ID->toi_class != INFO_CLASS_PROTOCOL) &&
        (ID->toi_type != INFO_TYPE_PROVIDER))
        return TDI_INVALID_PARAMETER;

    switch (ID->toi_id) {
    case IP6_MIB_STATS_ID: {
            uint Offset = 0;
            int fStatus;
            IPInternalPerCpuStats SumCpuStats;

            if (BufferSize < sizeof(IPSNMPInfo))
                return TDI_BUFFER_TOO_SMALL;
            IPSInfo.ipsi_defaultttl = DefaultCurHopLimit;
            IPSInfo.ipsi_reasmtimeout = DEFAULT_REASSEMBLY_TIMEOUT;
            IPSInfo.ipsi_forwarding = (NumForwardingInterfaces > 0)? 
                                      IP_FORWARDING : IP_NOT_FORWARDING;
            IPSGetTotalCounts(&SumCpuStats);
            IPSInfo.ipsi_inreceives = SumCpuStats.ics_inreceives;
            IPSInfo.ipsi_indelivers = SumCpuStats.ics_indelivers;
            IPSInfo.ipsi_outrequests = SumCpuStats.ics_outrequests;
            IPSInfo.ipsi_forwdatagrams = SumCpuStats.ics_forwdatagrams;

            fStatus = CopyToNdisSafe(Buffer, NULL, (PVOID)&IPSInfo, 
                                     sizeof(IPSNMPInfo), &Offset);
            if (!fStatus)
                return TDI_NO_RESOURCES;

            BytesCopied = sizeof(IPSNMPInfo);
        }
        break;

    case ICMP6_MIB_STATS_ID: {
            uint Offset = 0;
            int fStatus;

            if (BufferSize < sizeof(ICMPv6SNMPInfo))
                return TDI_BUFFER_TOO_SMALL;

            fStatus = CopyToNdisSafe(Buffer, &Buffer, (uchar *) &ICMPv6InStats, 
                                     sizeof(ICMPv6Stats), &Offset);
            if (!fStatus)
                return (TDI_NO_RESOURCES);

            fStatus = CopyToNdisSafe(Buffer, NULL, (uchar *) &ICMPv6OutStats,
                                     sizeof(ICMPv6Stats), &Offset);
            if (!fStatus)
                return (TDI_NO_RESOURCES);

            BytesCopied = sizeof(ICMPv6SNMPInfo);
        }
        break;

    case IP6_GET_BEST_ROUTE_ID: {
            TDI_ADDRESS_IP6 *In = (TDI_ADDRESS_IP6 *) Context;
            IP6RouteEntry Ire;
            uint Offset;
            IP_STATUS Status;
            int fStatus;

            if (ContextSize < sizeof(TDI_ADDRESS_IP6))
                return TDI_INVALID_PARAMETER;

            if (BufferSize < sizeof(IP6RouteEntry))
                return TDI_BUFFER_OVERFLOW;

            Status = GetBestRouteInfo((struct in6_addr *)In->sin6_addr, 
                                      In->sin6_scope_id, &Ire);
            if (Status != IP_SUCCESS)
                return TDI_DEST_HOST_UNREACH;

            Offset = 0;
            fStatus = CopyToNdisSafe(Buffer, &Buffer, (PVOID)&Ire, 
                                     Ire.ire_Length, &Offset);
            if (!fStatus)
                return TDI_NO_RESOURCES;

            BytesCopied = sizeof(IP6RouteEntry);
        }
        break;

    default:
        return TDI_INVALID_PARAMETER;
    } 

    *Size = BytesCopied;
    return TDI_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\info.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    info.h

Abstract:

    This module contains the definitions for maintaining IP statistics.

Author:

    Dave Thaler (dthaler) 10-Apr-2001

--*/

#pragma once

extern CACHE_ALIGN IPSNMPInfo  IPSInfo;
extern ICMPv6Stats             ICMPv6InStats;
extern ICMPv6Stats             ICMPv6OutStats;

typedef struct CACHE_ALIGN IPInternalPerCpuStats {
    ulong       ics_inreceives;
    ulong       ics_indelivers;
    ulong       ics_forwdatagrams;
    ulong       ics_outrequests;
} IPInternalPerCpuStats;

#define IPS_MAX_PROCESSOR_BUCKETS 8
extern IPInternalPerCpuStats IPPerCpuStats[IPS_MAX_PROCESSOR_BUCKETS];
extern uint NumForwardingInterfaces;

__forceinline
void IPSIncrementInReceiveCount(void)
{
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_inreceives++;
}

__forceinline
void IPSIncrementInDeliverCount(void)
{
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_indelivers++;
}

__forceinline
void IPSIncrementOutRequestCount(void)
{
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_outrequests++;
}

__forceinline
void IPSIncrementForwDatagramCount(void)
{
    const ulong Index = KeGetCurrentProcessorNumber() % IPS_MAX_PROCESSOR_BUCKETS;
    IPPerCpuStats[Index].ics_forwdatagrams++;
}

__inline
void IPSGetTotalCounts(IPInternalPerCpuStats* Stats)
{
    ulong Index;
    const ulong MaxIndex = MIN(KeNumberProcessors, IPS_MAX_PROCESSOR_BUCKETS);

    RtlZeroMemory(Stats, sizeof(IPInternalPerCpuStats));

    for (Index = 0; Index < MaxIndex; Index++) {
        Stats->ics_inreceives += IPPerCpuStats[Index].ics_inreceives;
        Stats->ics_indelivers += IPPerCpuStats[Index].ics_indelivers;
        Stats->ics_outrequests += IPPerCpuStats[Index].ics_outrequests;
        Stats->ics_forwdatagrams += IPPerCpuStats[Index].ics_forwdatagrams;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\icmp.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Internet Control Message Protocol for Internet Protocol Version 6.
// See RFC 1885 for details.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "route.h"
#include "icmp.h"
#include "ntddip6.h"
#include "neighbor.h"
#include "mld.h"
#include "security.h"

//
// Ping support.  We have a list of EchoControl blocks, one per outstanding
// echo request message.  Incoming echo replies are matched to requests via
// a unique sequence number.
//
KSPIN_LOCK ICMPv6EchoLock;
EchoControl *ICMPv6OutstandingEchos;
long ICMPv6EchoSeq;  // Protected with interlocked operations.

//
// Statistics kept for netstat and MIBs.
//
ICMPv6Stats ICMPv6InStats;
ICMPv6Stats ICMPv6OutStats;

//* ICMPv6Init - Initialize ICMPv6.
//
//  Set the starting values of various things.
//
void
ICMPv6Init(void)
{
    //
    // Initialize in-kernel ping support.
    //
    ICMPv6OutstandingEchos = NULL;
    ICMPv6EchoSeq = 0;
    KeInitializeSpinLock(&ICMPv6EchoLock);

    //
    // Initialize Multicast Listener Discovery protocol.
    //
    MLDInit();
}

//* ICMPv6Send - Low-level send routine for ICMPv6 packets.
//
//  Common ICMPv6 message transmission functionality is performed here.
//  The message is expected to be completely formed (with the exception
//  of the checksum) when this routine is called.
//
//  Used for all ICMP packets, except for Neighbor Discovery.
//
void
ICMPv6Send(
    RouteCacheEntry *RCE,               // RCE to send on
    PNDIS_PACKET Packet,                // Packet to send.
    uint IPv6Offset,                    // Offset to IPv6 header in packet.
    uint ICMPv6Offset,                  // Offset to ICMPv6 header in packet.
    IPv6Header UNALIGNED *IP,           // Pointer to IPv6 header.
    uint PayloadLength,                 // Length of IPv6 payload in bytes.
    ICMPv6Header UNALIGNED *ICMP)       // Pointer to ICMPv6 header.
{
    uint ChecksumDataLength;

    ICMPv6OutStats.icmps_msgs++;

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    // Recalculate the payload length to exclude any option headers.
    //
    ChecksumDataLength = PayloadLength - 
        (ICMPv6Offset - IPv6Offset) + sizeof(IPv6Header);

    ICMP->Checksum = 0;
    ICMP->Checksum = ChecksumPacket(Packet, ICMPv6Offset, NULL, 
                                    ChecksumDataLength,
                                    AlignAddr(&IP->Source),
                                    AlignAddr(&IP->Dest),
                                    IP_PROTOCOL_ICMPv6);
    if (ICMP->Checksum == 0) {
        //
        // ChecksumPacket failed, so abort the transmission.
        //
        ICMPv6OutStats.icmps_errors++;
        IPv6SendComplete(NULL, Packet, IP_NO_RESOURCES);
        return;
    }

    ICMPv6OutStats.icmps_typecount[ICMP->Type]++;

    //
    // Hand the packet down to IP for transmission.
    //
    IPv6Send(Packet, IPv6Offset, IP, PayloadLength, RCE, 0,
             IP_PROTOCOL_ICMPv6, 0, 0);
}


//* ICMPv6SendEchoReply - Send an Echo Reply message.
// 
//  Basically what we do here is slap an ICMPv6 header on the front
//  of the invoking packet and send it back where it came from.
//
void
ICMPv6SendEchoReply(
    IPv6Packet *Packet)         // Packet handed to us by ICMPv6Receive.
{
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET ReplyPacket;
    uint Offset;
    uchar *Mem;
    uint MemLen;
    uint ICMPLength;
    uint DataLength;
    IPv6Header UNALIGNED *ReplyIP;
    ICMPv6Header UNALIGNED *ReplyICMP;
    const IPv6Addr *Dest;
    IP_STATUS Status;
    RouteCacheEntry *RCE;

    //
    // Take our reply's destination address from the source address
    // of the incoming packet.
    //
    // Note that the specs specifically say that we're not to reverse
    // the path on source routed packets.  Just reply directly.
    //
    // IPv6HeaderReceive should protect us from replying to most forms
    // of bogus addresses.  We ASSERT this in checked builds.
    //
    Dest = Packet->SrcAddr;
    ASSERT(!IsInvalidSourceAddress(Dest));

    //
    // Get the reply route to the destination.
    // Under normal circumstances, the reply will go out
    // the incoming interface. RouteToDestination
    // will figure out the appropriate ScopeId.
    //
    Status = RouteToDestination(Dest, 0, Packet->NTEorIF,
                                RTD_FLAG_NORMAL, &RCE);
    if (Status != IP_SUCCESS) {
        //
        // No route - drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "ICMPv6SendEchoReply - no route: %x\n", Status));
        return;
    }

    //
    // Calculate the length of the ICMP header
    // and how much data we will include following the ICMP header.
    //
    ICMPLength = sizeof(ICMPv6Header);
    DataLength = Packet->TotalSize;
    Offset = RCE->NCE->IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + ICMPLength + DataLength;

    //
    // Allocate the reply packet.
    //
    NdisStatus = IPv6AllocatePacket(MemLen, &ReplyPacket, &Mem);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        ReleaseRCE(RCE);
        return;
    }

    //
    // Prepare IP header of reply packet.
    //
    ReplyIP = (IPv6Header UNALIGNED *)(Mem + Offset);
    ReplyIP->VersClassFlow = IP_VERSION;
    ReplyIP->NextHeader = IP_PROTOCOL_ICMPv6;
    ReplyIP->HopLimit = (uchar)RCE->NCE->IF->CurHopLimit;

    //
    // Take our reply's source address from the receiving NTE,
    // or use the best source address for this destination
    // if we don't have a receiving NTE.
    //
    ReplyIP->Source = (IsNTE(Packet->NTEorIF) ?
                       CastToNTE(Packet->NTEorIF) : RCE->NTE)
                                ->Address;
    ReplyIP->Dest = *Dest;

    //
    // Prepare ICMP header.
    //
    // REVIEW: Do this in ICMPv6Send?
    //
    ReplyICMP = (ICMPv6Header UNALIGNED *)(ReplyIP + 1);
    ReplyICMP->Type = ICMPv6_ECHO_REPLY;
    ReplyICMP->Code = 0;
    // ReplyICMP->Checksum - ICMPv6Send will calculate. 

    //
    // Copy incoming packet data to outgoing.
    //
    CopyPacketToBuffer((uchar *)(ReplyICMP + 1), Packet, DataLength,
                       Packet->Position);

    ICMPv6Send(RCE, ReplyPacket, Offset,
                Offset + sizeof(IPv6Header), ReplyIP,
                ICMPLength + DataLength, ReplyICMP);
    ReleaseRCE(RCE);
}


//* ICMPv6CheckError
//
//  Check if a packet is an ICMP error message.
//  This is a "best effort" check, given that
//  the packet may well have syntactical errors.
//
//  We return FALSE if we can't tell.
//
int
ICMPv6CheckError(IPv6Packet *Packet, uint NextHeader)
{
    for (;;) {
        uint HdrLen;

        switch (NextHeader) {
        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS:
        case IP_PROTOCOL_ROUTING: {
            ExtensionHeader *Hdr;

            if (! PacketPullup(Packet, sizeof *Hdr,
                               __builtin_alignof(ExtensionHeader), 0)) {
                //
                // Pullup failed. We can't continue parsing.
                //
                return FALSE;
            }

            Hdr = (ExtensionHeader *) Packet->Data;
            HdrLen = (Hdr->HeaderExtLength + 1) * EXT_LEN_UNIT;

            //
            // REVIEW - We don't actually want to look at the remaining
            // data in the extension header. Perhaps use PositionPacketAt?
            //
            if (! PacketPullup(Packet, HdrLen, 1, 0)) {
                //
                // Pullup failed. We can't continue parsing.
                //
                return FALSE;
            }

            NextHeader = Hdr->NextHeader;
            break;
        }

        case IP_PROTOCOL_FRAGMENT: {
            FragmentHeader UNALIGNED *Hdr;

            if (! PacketPullup(Packet, sizeof *Hdr, 1, 0)) {
                //
                // Pullup failed. We can't continue parsing.
                //
                return FALSE;
            }

            Hdr = (FragmentHeader UNALIGNED *) Packet->Data;

            //
            // We can only continue parsing if this is the first fragment.
            //
            if ((Hdr->OffsetFlag & FRAGMENT_OFFSET_MASK) != 0)
                return FALSE;

            HdrLen = sizeof *Hdr;
            NextHeader = Hdr->NextHeader;
            break;
        }

        case IP_PROTOCOL_ICMPv6: {
            ICMPv6Header *Hdr;

            if (! PacketPullup(Packet, sizeof *Hdr,
                               __builtin_alignof(ICMPv6Header), 0)) {
                //
                // Pullup failed. We can't continue parsing.
                //
                return FALSE;
            }

            //
            // This is an ICMPv6 message, so we can check
            // to see if it is an error message.
            // We treat Redirects as errors here.
            //
            Hdr = (ICMPv6Header *) Packet->Data;
            return (ICMPv6_ERROR_TYPE(Hdr->Type) ||
                    (Hdr->Type == ICMPv6_REDIRECT));
        }

        default:
            return FALSE;
        }

        //
        // Move past this extension header.
        //
        AdjustPacketParams(Packet, HdrLen);
    }
}


//* ICMPv6RateLimit
//
//  Returns TRUE if an ICMP error should NOT be sent to this destination
//  because of rate-limiting.
//
int
ICMPv6RateLimit(RouteCacheEntry *RCE)
{
    uint Now = IPv6TickCount;

    //
    // This arithmetic will handle wraps of the IPv6 tick counter.
    //
    if ((uint)(Now - RCE->LastError) < ICMP_MIN_ERROR_INTERVAL)
        return TRUE;

    RCE->LastError = Now;
    return FALSE;
}


//* ICMPv6SendError - Generate an error in response to an incoming packet.
// 
//  Send an ICMPv6 message of the given Type and Code to the source of the
//  offending/invoking packet.  The reply includes as much of the incoming
//  packet as will fit inside the minimal IPv6 MTU.
//
//  Basically what we do here is slap an ICMPv6 header on the front
//  of the invoking packet and send it back where it came from.
//
//  REVIEW - Much of the code looks like ICMPv6SendEchoReply.
//  Could it be shared?
//
//  The current position in the Packet must be at a header boundary.
//  The NextHeader parameter specifies the type of header following.
//  This information is used to parse the remainder of the invoking Packet,
//  to see if it is an ICMP error.  We MUST avoid sending an error
//  in response to an error.  NextHeader may be IP_PROTOCOL_NONE.
//
//  The MulticastOverride parameter allows override of another check.
//  Normally we MUST avoid sending an error in response to a packet
//  sent to a multicast destination.  But there are a couple exceptions.
//
void
ICMPv6SendError(
    IPv6Packet *Packet,                     // Offending/Invoking packet.
    uchar ICMPType,                         // ICMP error type.
    uchar ICMPCode,                         // ICMP error code.
    ulong ErrorParameter,                   // Parameter for error message.
    uint NextHeader,                        // Type of hdr following in Packet.
    int MulticastOverride)                  // Allow replies to mcast packets?
{
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET ReplyPacket;
    uint Offset;
    uchar *Mem;
    uint MemLen;
    uint ICMPLength;
    uint DataLength;
    IPv6Header UNALIGNED *ReplyIP;
    ICMPv6Header UNALIGNED *ReplyICMP;
    const IPv6Addr *Dest;
    IP_STATUS Status;
    RouteCacheEntry *RCE;

    //
    // We must not send an ICMP error message
    // as a result of an ICMP error.
    //
    if ((Packet->Flags & PACKET_ICMP_ERROR) ||
        ICMPv6CheckError(Packet, NextHeader)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ICMPv6SendError: no reply to error\n"));
        return;
    }

    //
    // We must not send an ICMP error message as a result
    // of receiving any kind of multicast or broadcast.
    // There are a couple exceptions so we have MulticastOverride.
    //
    if (IsMulticast(AlignAddr(&Packet->IP->Dest)) ||
        (Packet->Flags & PACKET_NOT_LINK_UNICAST)) {

        if (!MulticastOverride) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "ICMPv6SendError: no reply to broadcast/multicast\n"));
            return;
        }
    }

    //
    // Take our reply's destination address from the source address
    // of the incoming packet.
    //
    // Note that the specs specifically say that we're not to reverse
    // the path on source routed packets.  Just reply directly.
    //
    // IPv6HeaderReceive should protect us from replying to most forms
    // of bogus addresses.  We ASSERT this in checked builds.
    //
    Dest = Packet->SrcAddr;
    ASSERT(!IsInvalidSourceAddress(Dest));

    //
    // Get the reply route to the destination.
    // Under normal circumstances, the reply will go out
    // the incoming interface. RouteToDestination
    // will figure out the appropriate ScopeId.
    //
    Status = RouteToDestination(Dest, 0, Packet->NTEorIF,
                                RTD_FLAG_NORMAL, &RCE);
    if (Status != IP_SUCCESS) {
        //
        // No route - drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "ICMPv6SendError - no route: %x\n", Status));
        return;
    }

    //
    // We must rate-limit ICMP error messages.
    //
    if (ICMPv6RateLimit(RCE)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ICMPv6SendError - rate limit %s\n",
                   FormatV6Address(&RCE->Destination)));
        ReleaseRCE(RCE);
        return;
    }

    //
    // Calculate the length of the ICMP header
    // and how much data we will include following the ICMP header.
    // Include space for an error value after the header proper.
    //
    ICMPLength = sizeof(ICMPv6Header) + sizeof(uint);

    //
    // We want to include data from the IP header on.
    //
    DataLength = Packet->TotalSize +
        (Packet->Position - Packet->IPPosition);

    //
    // But limit the error packet size.
    //
    if (DataLength > ICMPv6_ERROR_MAX_DATA_LEN)
        DataLength = ICMPv6_ERROR_MAX_DATA_LEN;

    //
    // Calculate buffer length.
    //
    Offset = RCE->NCE->IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + ICMPLength + DataLength;
    ASSERT(MemLen - Offset <= IPv6_MINIMUM_MTU);

    //
    // Allocate the reply packet.
    //
    NdisStatus = IPv6AllocatePacket(MemLen, &ReplyPacket, &Mem);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        ReleaseRCE(RCE);
        return;
    }

    //
    // Prepare IP header of reply packet.
    //
    ReplyIP = (IPv6Header UNALIGNED *)(Mem + Offset);
    ReplyIP->VersClassFlow = IP_VERSION;
    ReplyIP->NextHeader = IP_PROTOCOL_ICMPv6;
    ReplyIP->HopLimit = (uchar)RCE->NCE->IF->CurHopLimit;

    //
    // Take our reply's source address from the receiving NTE,
    // or use the best source address for this destination
    // if we don't have a receiving NTE.
    //
    ReplyIP->Source = (IsNTE(Packet->NTEorIF) ?
                       CastToNTE(Packet->NTEorIF) : RCE->NTE)
                                ->Address;
    ReplyIP->Dest = *Dest;

    //
    // Prepare ICMP header.
    //
    // REVIEW: Do this in ICMPv6Send?
    //
    ReplyICMP = (ICMPv6Header UNALIGNED *)(ReplyIP + 1);
    ReplyICMP->Type = ICMPType;
    ReplyICMP->Code = ICMPCode;
    // ReplyICMP->Checksum - ICMPv6Send will calculate.

    //
    // ICMP Error Messages have a 32-bit field (content of which
    // varies depending upon the error type) following the ICMP header.
    //
    *(ulong UNALIGNED *)(ReplyICMP + 1) = net_long(ErrorParameter);

    //
    // Copy invoking packet (from IPv6 header onward) to outgoing.
    //
    CopyPacketToBuffer((uchar *)(ReplyICMP + 1) + sizeof(ErrorParameter),
                       Packet, DataLength, Packet->IPPosition);

    ICMPv6Send(RCE, ReplyPacket, Offset,
                Offset + sizeof(IPv6Header), ReplyIP,
                ICMPLength + DataLength, ReplyICMP);
    ReleaseRCE(RCE);
}


//* ICMPv6ProcessTunnelError
//
//  Called when we receive an ICMPv4 error and there is insufficient
//  information to translate to an ICMPv6 error. We make a best effort
//  to complete outstanding echo requests that were sent to the IPv4
//  address that was the original IPv4 tunnel destination.
//
void
ICMPv6ProcessTunnelError(
    IPAddr V4Dest,              // Destination of our tunneled packet.
    IPv6Addr *V6Src,            // Address to use as the source of the error.
    uint ScopeId,               // Scope-id of V6Src.
    IP_STATUS Status)           // Status of the response.
{
    EchoControl *This, **PrevPtr;
    EchoControl *List = NULL;
    KIRQL OldIrql;

    //
    // Find the EchoControl blocks on our list of outstanding echoes that
    // have a matching IPv4 destination and call their completion function.
    // We do not have sufficient information to identify a unique request.
    //
    KeAcquireSpinLock(&ICMPv6EchoLock, &OldIrql);
    PrevPtr = &ICMPv6OutstandingEchos;
    while ((This = *PrevPtr) != NULL) {
        if (This->V4Dest == V4Dest) {
            //
            // Found matching control block. Extract it from the list
            // and put it on our own list.
            //
            *PrevPtr = This->Next;
            This->Next = List;
            List = This;
        }
        else
            PrevPtr = &This->Next;
    }
    KeReleaseSpinLock(&ICMPv6EchoLock, OldIrql);

    while ((This = List) != NULL) {
        //
        // Remove this request from our list.
        //
        List = This->Next;

        //
        // Call OS-specific completion routine.
        //
        (*This->CompleteRoutine)(This, Status,
                                 V6Src, ScopeId,
                                 NULL, 0);
    }
}


//* ICMPv6ProcessEchoReply
//
//  Called either when an echo reply arrives, or
//  a hop-count-exceeded error responding to an echo request arrives.
//
//  Looks up the echo request structure and completes
//  the echo request operation.
//
//  Note that the echo reply payload data must be contiguous.
//  Callers should use PacketPullup if necessary.
//
void
ICMPv6ProcessEchoReply(
    ulong Seq,                  // Echo sequence number.
    IP_STATUS Status,           // Status of the response.
    IPv6Packet *Packet,         // Echo reply packet.
    void *Current,              // Pointer to the buffered data area.
    uint PayloadLength)         // Size of remaining payload data.
{
    EchoControl *This, **PrevPtr;
    KIRQL OldIrql;
    uint ICMPPosition;

    //
    // Find the EchoControl block on our list of outstanding echoes that
    // has a matching sequence number and call it's completion function.
    //
    KeAcquireSpinLock(&ICMPv6EchoLock, &OldIrql);
    PrevPtr = &ICMPv6OutstandingEchos;
    while ((This = *PrevPtr) != NULL) {
        if (This->Seq == Seq) {
            //
            // Found matching control block.  Extract it from list.
            //
            *PrevPtr = This->Next;
            break;
        }
        PrevPtr = &This->Next;
    }
    KeReleaseSpinLock(&ICMPv6EchoLock, OldIrql);

    //
    // Check to see if we ran off the end of the outstanding echoes list.
    //
    if (This == NULL) {
        //
        // We received a response with a sequence number that doesn't match
        // one of the echo requests we still have outstanding.  Drop it.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "ICMPv6ProcessEchoReply: Received echo response "
                   "with bogus/expired sequence number 0x%x\n", Seq));

        if (Current != NULL) {
            //
            // If this is a normal Echo Reply (not a error message sent in
            // response to one of our Echo Replies) first see if any raw 
            // receivers want to look at it.
            //
            ICMPPosition = Packet->Position - sizeof(ICMPv6Header)
                - sizeof(Seq);
            PositionPacketAt(Packet, ICMPPosition);
            (void) RawReceive(Packet, IP_PROTOCOL_ICMPv6);
        }
        return;
    }

    //
    // Call OS-specific completion routine.
    //
    (*This->CompleteRoutine)(This, Status,
                             Packet->SrcAddr, 
                             DetermineScopeId(Packet->SrcAddr,
                                              Packet->NTEorIF->IF),
                             Current, PayloadLength);
}


//* ICMPv6EchoReplyReceive - Receive a reply to an earlier echo of our's.
//
//  Called by ICMPv6Receive when an echo reply message arrives.
//
//  REVIEW: Should we also verify the receiving NTE is the same as the one
//  REVIEW: we sent on?
//
void
ICMPv6EchoReplyReceive(IPv6Packet *Packet)
{
    ulong Seq;

    //
    // The next four bytes should consist of a two byte Identifier field
    // and a two byte Sequence Number.  We just treat the whole thing as
    // a four byte sequence number.  Make sure these bytes are contiguous.
    //
    if (! PacketPullup(Packet, sizeof Seq, 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(Seq)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6: Received small Echo Reply %u\n",
                       Packet->TotalSize));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return;  // Drop packet.
    }

    //
    // We're received a reply message to one of our echo requests.
    // Extract its sequence number so that we can identify it.
    //
    Seq = net_long(*(ulong UNALIGNED *)Packet->Data);
    AdjustPacketParams(Packet, sizeof Seq);
      
    //
    // REVIEW: The ICMPv6ProcessEchoReply interface expects a contiguous data
    // REVIEW: region for the rest of the packet.  This requires us to
    // REVIEW: pullup the remainder of the packet here.  Fix this someday.
    //
    if (! PacketPullup(Packet, Packet->TotalSize, 1, 0)) {
        // Pullup failed.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "ICMPv6: Couldn't pullup echo data\n"));
        return;  // Drop packet.
    }

    ICMPv6ProcessEchoReply(Seq, IP_SUCCESS, Packet,
                           Packet->Data, Packet->TotalSize);
}


//* ICMPv6ErrorReceive - Generic ICMPv6 error processing.
//
//  Called by ICMPv6Receive when an error message arrives.
//  Returns FALSE if we were unable to process it for some reason.
//
int
ICMPv6ErrorReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP Header.
{
    ulong Parameter;
    IP_STATUS Status;
    StatusArg StatArg;
    IPv6Header UNALIGNED *InvokingIP;
    ProtoControlRecvProc *Handler = NULL;
    uchar NextHeader;
    int Handled = TRUE;

    //
    // First mark the packet as an ICMP error.
    // This will inhibit any generation of ICMP errors
    // as a result of this packet.
    //
    Packet->Flags |= PACKET_ICMP_ERROR;

    //
    // All ICMPv6 error messages consist of the base ICMPv6 header,
    // followed by a 32 bit type-specific field, followed by as much
    // of the invoking packet as fit without causing this ICMPv6 packet
    // to exceed 576 octets.
    //
    // We already consumed the base ICMPv6 header back in ICMPv6Receive.
    // Pull out the 32 bit type-specific field in case the upper layer's
    // ControlReceive routine cares about it.
    //
    if (! PacketPullup(Packet, sizeof Parameter, 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof Parameter)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6ErrorReceive: "
                       "Packet too small to contain error field\n"));
        return FALSE;  // Drop packet.
    }
    Parameter = *(ulong UNALIGNED *)Packet->Data;
    AdjustPacketParams(Packet, sizeof Parameter);

    //
    // Next up should be the IPv6 header of the invoking packet.
    //
    if (! PacketPullup(Packet, sizeof *InvokingIP,
                       __builtin_alignof(IPv6Addr), 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof *InvokingIP)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6ErrorReceive (from %s): "
                       "Packet too small to contain IPv6 "
                       "header from invoking packet\n",
                       FormatV6Address(AlignAddr(&Packet->IP->Source))));
        return FALSE;  // Drop packet.
    }
    InvokingIP = (IPv6Header UNALIGNED *)Packet->Data;
    AdjustPacketParams(Packet, sizeof *InvokingIP);

    //
    // First we perform any specific processing of the error,
    // and convert the error type/code to a status value.
    //
    switch (ICMP->Type) {
    case ICMPv6_DESTINATION_UNREACHABLE:
        switch (ICMP->Code) {
        case ICMPv6_NO_ROUTE_TO_DESTINATION:
            Status = IP_DEST_NO_ROUTE;
            break;
        case ICMPv6_COMMUNICATION_PROHIBITED:
            Status = IP_DEST_PROHIBITED;
            break;
        case ICMPv6_SCOPE_MISMATCH:
            Status = IP_DEST_SCOPE_MISMATCH;
            break;
        case ICMPv6_ADDRESS_UNREACHABLE:
            Status = IP_DEST_ADDR_UNREACHABLE;
            break;
        case ICMPv6_PORT_UNREACHABLE:
            Status = IP_DEST_PORT_UNREACHABLE;
            break;
        default:
            Status = IP_DEST_UNREACHABLE;
            break;
        }
        break;

    case ICMPv6_PACKET_TOO_BIG: {
        uint PMTU;

        //
        // Packet Too Big messages contain the bottleneck MTU value.
        // Update the path MTU in the route cache.
        // Change Parameter value to indicate whether PMTU changed.
        //
        PMTU = net_long(Parameter);
        Parameter = UpdatePathMTU(Packet->NTEorIF->IF,
                                  AlignAddr(&InvokingIP->Dest), PMTU);
        Status = IP_PACKET_TOO_BIG;
        break;
    }

    case ICMPv6_TIME_EXCEEDED:
        switch (ICMP->Code) {
        case ICMPv6_HOP_LIMIT_EXCEEDED:
            Status = IP_HOP_LIMIT_EXCEEDED;
            break;
        case ICMPv6_REASSEMBLY_TIME_EXCEEDED:
            Status = IP_REASSEMBLY_TIME_EXCEEDED;
            break;
        default:
            Status = IP_TIME_EXCEEDED;
            break;
        }
        break;

    case ICMPv6_PARAMETER_PROBLEM:
        switch (ICMP->Code) {
        case ICMPv6_ERRONEOUS_HEADER_FIELD:
            Status = IP_BAD_HEADER;
            break;
        case ICMPv6_UNRECOGNIZED_NEXT_HEADER:
            Status = IP_UNRECOGNIZED_NEXT_HEADER;
            break;
        case ICMPv6_UNRECOGNIZED_OPTION:
            Status = IP_BAD_OPTION;
            break;
        default:
            Status = IP_PARAMETER_PROBLEM;
            break;
        }
        break;
            
    default:
        //
        // We don't understand this error type.
        //
        Status = IP_ICMP_ERROR;
        Handled = FALSE;
        break;
    }

    //
    // Deliver ICMP Error to higher layers.  This is a MUST, even if we
    // don't recognize the specific error message.
    //
    // Iteratively switch out to the handler for each successive next header
    // until we reach a handler that reports no more headers follow it.
    //
    NextHeader = InvokingIP->NextHeader;
    while (NextHeader != IP_PROTOCOL_NONE) {
        //
        // Current header indicates that another header follows.
        // See if we have a handler for it.
        //
        Handler = ProtocolSwitchTable[NextHeader].ControlReceive;
        if (Handler == NULL) {
            //
            // If we don't have a handler for this header type,
            // we just drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "IPv6ErrorReceive: No handler for NextHeader type %u.\n",
                       NextHeader));
            break;
        }

        StatArg.Status = Status;
        StatArg.Arg = Parameter;
        StatArg.IP = InvokingIP;
        NextHeader = (*Handler)(Packet, &StatArg);
    }

    return Handled;
}


//* ICMPv6ControlReceive - handler for ICMPv6 control messages.
//
//  This routine is called if we receive an ICMPv6 error message that
//  was generated by some remote site as a result of receiving an ICMPv6
//  packet from us.
//  
uchar
ICMPv6ControlReceive(
    IPv6Packet *Packet,         // Packet handed to us by ICMPv6Receive.
    StatusArg *StatArg)         // ICMP Error Code, etc.
{
    ICMPv6Header *InvokingICMP;
    ulong Seq;

    //
    // The next thing in the packet should be the ICMP header of the
    // original packet which invoked this error.
    //
    if (! PacketPullup(Packet, sizeof *InvokingICMP,
                       __builtin_alignof(ICMPv6Header), 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof *InvokingICMP)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6: Packet too small to contain ICMPv6 header "
                       "from invoking packet\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    InvokingICMP = (ICMPv6Header *)Packet->Data;
    AdjustPacketParams(Packet, sizeof *InvokingICMP);

    //
    // All we currently handle is errors caused by echo requests.
    //
    if ((InvokingICMP->Type != ICMPv6_ECHO_REQUEST) ||
        (InvokingICMP->Code != 0))
        return IP_PROTOCOL_NONE;  // Drop packet.

    //
    // The next four bytes should consist of a two byte Identifier field
    // and a two byte Sequence Number.  We just treat the whole thing as
    // a four byte sequence number.  Make sure these bytes are contiguous.
    //
    if (! PacketPullup(Packet, sizeof Seq, 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof Seq)
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6: Packet too small to contain ICMPv6 header "
                       "from invoking packet\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Extract the sequence number so that we can identify
    // the matching echo request.
    //
    Seq = net_long(*(ulong UNALIGNED *)Packet->Data);
    AdjustPacketParams(Packet, sizeof Seq);

    //
    // Complete the corresponding echo request with an error.
    //
    ICMPv6ProcessEchoReply(Seq, StatArg->Status, Packet,
                           NULL, 0);
    return IP_PROTOCOL_NONE;  // Done with packet.
}


//* ICMPv6Receive - Receive an incoming ICMPv6 packet.
// 
//  This is the routine called by IPv6 when it receives a complete IPv6
//  packet with a Next Header value of 58.
//
uchar
ICMPv6Receive(
    IPv6Packet *Packet)  // Packet handed to us by IPv6Receive.
{
    ICMPv6Header *ICMP;
    ushort Checksum;
    uint ICMPPosition;

    ICMPv6InStats.icmps_msgs++;

    //
    // Verify IPSec was performed.
    //
    if (InboundSecurityCheck(Packet, IP_PROTOCOL_ICMPv6, 0, 0, 
                             Packet->NTEorIF->IF) != TRUE) {
        // 
        // No policy was found or the policy indicated to drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ICMPv6: IPSec lookup failed\n"));        
        ICMPv6InStats.icmps_errors++;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Verify that we have enough contiguous data to overlay a ICMPv6Header
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof *ICMP,
                       __builtin_alignof(ICMPv6Header), 0)) {
        // Pullup failed.
        ICMPv6InStats.icmps_errors++;
        if (Packet->TotalSize < sizeof *ICMP) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6: Packet too small to contain ICMP header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    ICMP = (ICMPv6Header *)Packet->Data;
    ICMPPosition = Packet->Position;

    //
    // Verify checksum.
    //
    Checksum = ChecksumPacket(Packet->NdisPacket, Packet->Position,
                              Packet->FlatData, Packet->TotalSize,
                              Packet->SrcAddr, AlignAddr(&Packet->IP->Dest),
                              IP_PROTOCOL_ICMPv6);
    if (Checksum != 0xffff) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ICMPv6: Checksum failed %0x\n", Checksum));
        ICMPv6InStats.icmps_errors++;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Skip over base ICMP header.
    //
    AdjustPacketParams(Packet, sizeof *ICMP);

    //
    // Ignore Neighbor Discovery packets
    // if the interface is so configured.
    // (Pseudo-interfaces don't do Neighbor Discovery.)
    //
    if (!(Packet->NTEorIF->IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS)) {
        if ((ICMP->Type == ICMPv6_NEIGHBOR_SOLICIT) ||
            (ICMP->Type == ICMPv6_NEIGHBOR_ADVERT)) {

            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6Receive: ND on pseudo-interface\n"));
            ICMPv6InStats.icmps_errors++;
            return IP_PROTOCOL_NONE;  // Drop packet.
        }
    }

    //
    // Ignore Router Discovery packets
    // if the interface is so configured.
    //
    if (!(Packet->NTEorIF->IF->Flags & IF_FLAG_ROUTER_DISCOVERS)) {
        if ((ICMP->Type == ICMPv6_ROUTER_SOLICIT) ||
            (ICMP->Type == ICMPv6_ROUTER_ADVERT) ||
            (ICMP->Type == ICMPv6_REDIRECT)) {

            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ICMPv6Receive: RD on pseudo-interface\n"));
            ICMPv6InStats.icmps_errors++;
            return IP_PROTOCOL_NONE;  // Drop packet.
        }
    }

    ICMPv6InStats.icmps_typecount[ICMP->Type]++;

    //
    // We have a separate routine to handle error messages.
    //
    if (ICMPv6_ERROR_TYPE(ICMP->Type)) {
        if (!ICMPv6ErrorReceive(Packet, ICMP))
            goto unrecognized;
        return IP_PROTOCOL_NONE;
    }

    //
    // Handle specific informational message types.
    // Just use a switch statement for now.  If this is later deemed to be
    // too inefficient, we can change it to use a type switch table instead.
    //
    switch(ICMP->Type) {
    case ICMPv6_ECHO_REQUEST:
        ICMPv6SendEchoReply(Packet);
        break;

    case ICMPv6_ECHO_REPLY:
        ICMPv6EchoReplyReceive(Packet);
        break;

    case ICMPv6_MULTICAST_LISTENER_QUERY:
        MLDQueryReceive(Packet);
        break;

    case ICMPv6_MULTICAST_LISTENER_REPORT:
        MLDReportReceive(Packet);
        break;

    case ICMPv6_MULTICAST_LISTENER_DONE:
        break;

    // Following are all Neighbor Discovery messages.
    case ICMPv6_ROUTER_SOLICIT:
        RouterSolicitReceive(Packet, ICMP);
        break;

    case ICMPv6_ROUTER_ADVERT:
        RouterAdvertReceive(Packet, ICMP);
        break;

    case ICMPv6_NEIGHBOR_SOLICIT:
        NeighborSolicitReceive(Packet, ICMP);
        break;

    case ICMPv6_NEIGHBOR_ADVERT:
        NeighborAdvertReceive(Packet, ICMP);
        break;

    case ICMPv6_REDIRECT:
        RedirectReceive(Packet, ICMP);
        break;

    default:
        //
        // Don't recognize the specific message type.
        // This is an unknown informational message.
        // We MUST silently discard it.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "ICMPv6: Received unknown informational message"
                   "(%u/%u) from %s\n", ICMP->Type, ICMP->Code,
                   FormatV6Address(AlignAddr(&Packet->IP->Source))));

        //
        // But first see if any raw receivers want to look at it.
        // NOTE: We don't get any feedback from raw receivers,
        // NOTE: so we can't tell if any of them knew this type.
        //
      unrecognized:
        PositionPacketAt(Packet, ICMPPosition);
        (void) RawReceive(Packet, IP_PROTOCOL_ICMPv6);

        break;
    }

    return IP_PROTOCOL_NONE;
}


//* ICMPv6EchoRequest - Common dispatch routine for echo requests.
//
//  This is the routine called by the OS-specific code on behalf of a user
//  to issue an echo request.  Validate the request, place control block
//  on list of outstanding echo requests, and send echo request message.
//
void
ICMPv6EchoRequest(
    void *InputBuffer,          // Pointer to an ICMPV6_ECHO_REQUEST structure.
    uint InputBufferLength,     // Size in bytes of the InputBuffer.
    EchoControl *ControlBlock,  // Pointer to an EchoControl structure.
    EchoRtn Callback)           // Called when request responds or times out.
{
    NetTableEntry *NTE = NULL;
    PICMPV6_ECHO_REQUEST RequestBuffer;
    KIRQL OldIrql;
    IP_STATUS Status;
    ulong Seq;
    NDIS_STATUS NdisStatus;
    PNDIS_PACKET Packet;
    uint Offset;
    uchar *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    void *Data;
    uint DataSize;
    uint RtHdrSize;
    RouteCacheEntry *RCE = NULL;
    const IPv6Addr *FinalDest, *FirstDest;
    const IPv6Addr *DstAddress, *SrcAddress;
    uint DstScopeId, SrcScopeId;

    
    ICMPv6OutStats.icmps_msgs++;

    RequestBuffer = (PICMPV6_ECHO_REQUEST) InputBuffer;

    //
    // Validate the request. 
    //
    if (InputBufferLength < sizeof *RequestBuffer) {
        Status = IP_BUF_TOO_SMALL;
        goto common_echo_exit;
    }

    //
    // If InputBufferLength is too big, it could cause a
    // buffer overflow later on in the computation for
    // MemLen. Cap the value to MAXLONG.
    //
    if (InputBufferLength > (uint) MAXLONG) {
        Status = IP_PARAM_PROBLEM;
        goto common_echo_exit;
    }
    
    Data = RequestBuffer + 1;
    DataSize = InputBufferLength - sizeof *RequestBuffer;

    //
    // Extract address information from the TDI addresses
    // in the request.
    //
    DstAddress = (const IPv6Addr *) RequestBuffer->DstAddress.sin6_addr;
    DstScopeId = RequestBuffer->DstAddress.sin6_scope_id;
    SrcAddress = (const IPv6Addr *) RequestBuffer->SrcAddress.sin6_addr;
    SrcScopeId = RequestBuffer->SrcAddress.sin6_scope_id;

    //
    // Determine which NTE will send the request,
    // if the user has specified a source address.
    //
    if (! IsUnspecified(SrcAddress)) {
        //
        // Convert the source address to an NTE.
        //
        NTE = FindNetworkWithAddress(SrcAddress, SrcScopeId);
        if (NTE == NULL) {
            Status = IP_BAD_ROUTE;
            goto common_echo_exit;
        }

        Status = RouteToDestination(DstAddress, DstScopeId,
                                    CastFromNTE(NTE),
                                    RTD_FLAG_NORMAL, &RCE);
        if (Status != IP_SUCCESS)
            goto common_echo_exit;

    } else {
        //
        // Get the source address from the outgoing interface.
        //
        Status = RouteToDestination(DstAddress, DstScopeId,
                                    NULL,
                                    RTD_FLAG_NORMAL, &RCE);
        if (Status != IP_SUCCESS)
            goto common_echo_exit;

        NTE = RCE->NTE;
        AddRefNTE(NTE);
    }

    //
    // Should we use a routing header to send
    // a "round-trip" echo request to ourself?
    //
    if (RequestBuffer->Flags & ICMPV6_ECHO_REQUEST_FLAG_REVERSE) {
        //
        // Use a routing header.
        //
        FinalDest = &NTE->Address;
        FirstDest = DstAddress;
        RtHdrSize = sizeof(IPv6RoutingHeader) + sizeof(IPv6Addr);
    }
    else {
        //
        // No routing header.
        //
        FinalDest = FirstDest = DstAddress;
        RtHdrSize = 0;
    }

    //
    // Allocate the Echo Request packet.
    //
    Offset = RCE->NCE->IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + RtHdrSize + sizeof(ICMPv6Header) +
        sizeof Seq + DataSize;

    NdisStatus = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        Status = IP_NO_RESOURCES;
        goto common_echo_exit;
    }

    //
    // Prepare IP header of Echo Request packet.
    //
    IP = (IPv6Header UNALIGNED *)(Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_ICMPv6;
    IP->Source = NTE->Address;
    IP->Dest = *FirstDest;
    IP->HopLimit = RequestBuffer->TTL;
    if (IP->HopLimit == 0)
        IP->HopLimit = (uchar)RCE->NCE->IF->CurHopLimit;

    //
    // Prepare the routing header.
    // The packet will travel to the destination and then
    // be routed back to the source.
    //
    if (RtHdrSize != 0) {
        IPv6RoutingHeader *RtHdr = (IPv6RoutingHeader *)(IP + 1);

        IP->NextHeader = IP_PROTOCOL_ROUTING;
        RtHdr->NextHeader = IP_PROTOCOL_ICMPv6;
        RtHdr->HeaderExtLength = 2;
        RtHdr->RoutingType = 0;
        RtHdr->SegmentsLeft = 1;
        RtlZeroMemory(&RtHdr->Reserved, sizeof RtHdr->Reserved);
        ((IPv6Addr *)(RtHdr + 1))[0] = *FinalDest;
    }

    //
    // Prepare ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)
        ((uchar *)IP + sizeof(IPv6Header) + RtHdrSize);
    ICMP->Type = ICMPv6_ECHO_REQUEST;
    ICMP->Code = 0;
    ICMP->Checksum = 0; // Calculated below.

    //
    // Insert Echo sequence number.  Technically, this is 16 bits of
    // "Identifier" and 16 bits of "Sequence Number", but we just treat
    // the whole thing as one 32 bit sequence number field.
    //
    Seq = InterlockedIncrement(&ICMPv6EchoSeq);
    Mem = (uchar *)(ICMP + 1);
    *(ulong UNALIGNED *)Mem = net_long(Seq);
    Mem += sizeof(ulong);

    //
    // Copy the user data into the packet.
    //
    RtlCopyMemory(Mem, Data, DataSize);

    //
    // We calculate the checksum here, because
    // of routing header complications -
    // we need to use the final destination.
    //
    ICMP->Checksum = ChecksumPacket(
        NULL, 0, (uchar *)ICMP, sizeof(ICMPv6Header) + sizeof Seq + DataSize,
        AlignAddr(&IP->Source), FinalDest, IP_PROTOCOL_ICMPv6);
    if (ICMP->Checksum == 0) {
        //
        // ChecksumPacket failed, so abort the transmission.
        //
        IPv6FreePacket(Packet);
        Status = IP_NO_RESOURCES;
        goto common_echo_exit;
    }

    //
    // If this Echo Request is being tunneled to an IPv4 destination,
    // remember the IPv4 destination address. We use this later
    // if we receive an ICMPv4 error with insufficient information
    // to translate to an ICMPv6 error.
    //
    ControlBlock->V4Dest = GetV4Destination(RCE);

    //
    // Prepare the control block and link it onto the list.
    // Once we've unlocked the list, the control block might
    // be completed at any time.  Hence it's very important
    // that we not access RequestBuffer after this point.
    // Also we can not return a failure code. To clean up the
    // outstanding request properly, we must use ICMPv6ProcessEchoReply.
    //
    ControlBlock->TimeoutTimer = ConvertMillisToTicks(RequestBuffer->Timeout);
    ControlBlock->CompleteRoutine = Callback;
    ControlBlock->Seq = Seq;

    if (ControlBlock->TimeoutTimer == 0) {
        IPv6FreePacket(Packet);
        Status = IP_REQ_TIMED_OUT;
        goto common_echo_exit;
    }

    KeAcquireSpinLock(&ICMPv6EchoLock, &OldIrql);
    ControlBlock->Next = ICMPv6OutstandingEchos;
    ICMPv6OutstandingEchos = ControlBlock;
    KeReleaseSpinLock(&ICMPv6EchoLock, OldIrql);

    ICMPv6OutStats.icmps_typecount[ICMPv6_ECHO_REQUEST]++;

    //
    // Hand the packet down to IP for transmission.
    // We can't use ICMPv6Send
    // because of routing header complications.
    //
    IPv6Send(Packet, Offset, IP,
             RtHdrSize + sizeof(ICMPv6Header) + sizeof Seq + DataSize,
             RCE, 0, IP_PROTOCOL_ICMPv6, 0, 0);

common_echo_cleanup:
    if (RCE != NULL)
        ReleaseRCE(RCE);
    if (NTE != NULL)
        ReleaseNTE(NTE);
    return;

common_echo_exit:
    //
    // Complete the echo request with an error,
    // before it has been placed on our outstanding echoes list.
    //
    ICMPv6OutStats.icmps_errors++;
    (*Callback)(ControlBlock, Status, &UnspecifiedAddr, 0, NULL, 0);
    goto common_echo_cleanup;
 
} // ICMPv6EchoRequest


//* ICMPv6EchoComplete - Common completion routine for echo requests.
//
//  This is the routine is called by the OS-specific code to process an
//  ICMP echo response.
//
NTSTATUS
ICMPv6EchoComplete(
    EchoControl *ControlBlock,  // ControlBlock of completed request.
    IP_STATUS Status,           // Status of the reply.
    const IPv6Addr *Address,    // Source of the reply.
    uint ScopeId,               // Scope of the reply.
    void *Data,                 // Reply data (may be NULL).
    uint DataSize,              // Amount of reply data.
    ULONG_PTR *BytesReturned)   // Total user bytes returned.
{
    PICMPV6_ECHO_REPLY ReplyBuffer;
    LARGE_INTEGER Now, Freq;

    //
    // Sanity check our reply buffer length.
    //
    if (ControlBlock->ReplyBufLen < sizeof *ReplyBuffer) {
        *BytesReturned = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    ReplyBuffer = (PICMPV6_ECHO_REPLY) ControlBlock->ReplyBuf;

    //
    // Fill in fields to return.
    //
    ReplyBuffer->Address.sin6_port = 0;
    ReplyBuffer->Address.sin6_flowinfo = 0;
    RtlCopyMemory(ReplyBuffer->Address.sin6_addr, Address, sizeof *Address);
    ReplyBuffer->Address.sin6_scope_id = ScopeId;
    ReplyBuffer->Status = Status;

    //
    // Return the elapsed time in milliseconds.
    //
    Now = KeQueryPerformanceCounter(&Freq);
    ReplyBuffer->RoundTripTime = (uint)
        ((1000 * (Now.QuadPart - ControlBlock->WhenIssued.QuadPart)) /
         Freq.QuadPart);

    //
    // Verify we have enough space in the reply buffer for the reply data.
    //
    if (ControlBlock->ReplyBufLen < sizeof *ReplyBuffer + DataSize) {
        *BytesReturned = sizeof *ReplyBuffer;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Copy the reply data to follow the reply buffer.
    //
    RtlCopyMemory(ReplyBuffer + 1, Data, DataSize);

    *BytesReturned = sizeof *ReplyBuffer + DataSize;
    return STATUS_SUCCESS;

}  // ICMPv6EchoComplete


//* ICMPv6EchoTimeout - expire aging unanswered echo requests.
//
//  IPv6Timeout calls this routine whenever it thinks we might have
//  echo requests outstanding.
//
//  Callable from DPC context, not from thread context.
//  Called with no locks held.
//
void
ICMPv6EchoTimeout(void)
{
    EchoControl *This, **PrevPtr, *TimedOut;

    TimedOut = NULL;

    //
    // Grab the outstanding echo list lock and run through the list looking
    // for requests that have timed out.
    //
    KeAcquireSpinLockAtDpcLevel(&ICMPv6EchoLock);
    PrevPtr = &ICMPv6OutstandingEchos;
    while ((This = *PrevPtr) != NULL) {
        if (This->TimeoutTimer != 0) {
            //
            // Timer is running.  Decrement and check for expiration.
            //
            if (--This->TimeoutTimer == 0) {
                //
                // This echo request has been sent and timed out without
                // being answered.  Move it to our timed out list.
                //
                *PrevPtr = This->Next;
                This->Next = TimedOut;
                TimedOut = This;
            } else {
                PrevPtr = &This->Next;
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&ICMPv6EchoLock);

    //
    // Run through the list of timed out echoes, calling the completion
    // routine on each.  The completion routine is responsible for
    // freeing the EchoControl block structure.
    //
    while (TimedOut != NULL) {
        
        This = TimedOut;
        TimedOut = This->Next;

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ICMPv6EchoTimeout: seq number 0x%x timed out\n", This->Seq));

        (*This->CompleteRoutine)(This, IP_REQ_TIMED_OUT,
                                 &UnspecifiedAddr, 0, NULL, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\mobile.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Mobility routines for Internet Protocol Version 6.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "mobile.h"
#include "route.h"
#include "security.h"
#include "ipsec.h"

int MobilitySecurity;
uint MobileIPv6Mode;


//* IPv6SendBindingAck
//
//  Sends a Binding Acknowledgement using an explicit routing header.
//
void
IPv6SendBindingAck(
    const IPv6Addr *DestAddr,
    NetTableEntryOrInterface *NTEorIF,
    const IPv6Addr *HomeAddr,
    BindingUpdateDisposition StatusCode,
    ushort SeqNumber,   // Network byte order.
    uint Lifetime)      // Network byte order, seconds.
{
    NDIS_STATUS Status;
    PNDIS_PACKET Packet;
    uint Offset, PayloadLength;
    uchar *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *IP;
    MobileAcknowledgementOption UNALIGNED *MA;
    IPv6RoutingHeader UNALIGNED *Routing;
    IP_STATUS IPStatus;
    RouteCacheEntry *RCE;

    IPStatus = RouteToDestination(DestAddr, 0, NTEorIF,
                                  RTD_FLAG_NORMAL, &RCE);
    if (IPStatus != IP_SUCCESS) {
        //
        // No route - drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "IPv6SendBindingNack - no route: %x\n", IPStatus));
        return;
    }

    // Determine size of memory buffer needed.
    Offset = RCE->NCE->IF->LinkHeaderSize;
    PayloadLength = sizeof(IPv6RoutingHeader) + sizeof(IPv6Addr) +
        sizeof(MobileAcknowledgementOption);
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;

    // Allocate the packet.
    Status = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6SendBindingNack: Couldn't allocate packet header!?!\n"));
        return;
    }

    // Prepare IP header of reply packet.
    IP = (IPv6Header UNALIGNED *)(Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_ROUTING;
    IP->HopLimit = (uchar)RCE->NCE->IF->CurHopLimit;
    IP->Dest = *DestAddr;
    IP->Source = (IsNTE(NTEorIF) ? CastToNTE(NTEorIF) : RCE->NTE)->Address;

    // Prepare the routing header.
    Routing = (IPv6RoutingHeader UNALIGNED *)(IP + 1);
    Routing->NextHeader = IP_PROTOCOL_DEST_OPTS;
    Routing->HeaderExtLength = 2;
    Routing->RoutingType = 0;
    RtlZeroMemory(&Routing->Reserved, sizeof Routing->Reserved);
    Routing->SegmentsLeft = 1;
    RtlCopyMemory(Routing + 1, HomeAddr, sizeof(IPv6Addr));

    // Prepare the binding acknowledgement option.
    MA = (MobileAcknowledgementOption UNALIGNED *)((uchar *)(Routing + 1) +
                                                   sizeof(IPv6Addr));
    MA->Header.NextHeader = IP_PROTOCOL_NONE;
    MA->Header.HeaderExtLength = 1;
    MA->Pad1 = 0;
    MA->Option.Type = OPT6_BINDING_ACK;
    MA->Option.Length = 11;
    MA->Option.Status = StatusCode;
    MA->Option.SeqNumber = SeqNumber;
    MA->Option.Lifetime = Lifetime;
    MA->Option.Refresh = Lifetime;

    IPv6Send(Packet, Offset, IP, PayloadLength, RCE,
             SEND_FLAG_BYPASS_BINDING_CACHE, 0, 0, 0);

    //
    // Release the route.
    //
    ReleaseRCE(RCE);
}


//* ParseSubOptions - Routine for mobile ip sub-option parsing.
//
//  Mobile IPv6 destination options may themselves have options, see
//  section 5.5 of the draft.  This routine parses these sub-options.
//
//  We do not return any values to our caller;
//  we merely check that the sub-options are well-formed.
//
//  Returns TRUE if the sub-options were successfully parsed.
//  Returns FALSE if the packet should be discarded.
//
int
ParseSubOptions(
    uchar *SubOptPtr,           // Start of the sub-option data.
    uint SubOptSizeLeft)        // Length remaining in the parent option.
{
    SubOptionHeader UNALIGNED *SubOptHdr;
    uint SubOptLen;

    while (SubOptSizeLeft != 0) {
        //
        // First we check the option length and ensure that it fits.
        // We move OptPtr past this option while leaving OptHdr
        // for use by the option processing code below.
        //

        SubOptHdr = (SubOptionHeader UNALIGNED *) SubOptPtr;

        if ((sizeof *SubOptHdr > SubOptSizeLeft) ||
            ((SubOptLen = sizeof *SubOptHdr + SubOptHdr->DataLength) >
             SubOptSizeLeft)) {
            //
            // Bad length.  REVIEW: Should we discard the packet or continue
            // processing it?  For now, discard it.
            //
            return FALSE;
        }

        SubOptPtr += SubOptLen;
        SubOptSizeLeft -= SubOptLen;
    }

    return TRUE;
}


//* IPv6RecvBindingUpdate - handle an incoming binding update.
//
//  Process the receipt of a binding update destination option
//  from a mobile node.
//
int
IPv6RecvBindingUpdate(
    IPv6Packet *Packet,                      // Packet received.
    IPv6BindingUpdateOption UNALIGNED *BindingUpdate)
{
    const IPv6Addr *CareOfAddr;
    const IPv6Addr *HomeAddr;
    BindingUpdateDisposition Status;
    uint OptBytesLeft;

    //
    // If a home address option is not also present
    // then we MUST silently drop this packet.
    //
    if ((Packet->Flags & PACKET_SAW_HA_OPT) == 0)
        return 1;  // Drop packet.

    HomeAddr = Packet->SrcAddr;

    //
    // Check to make sure we have a reasonable home address.
    // Not required by spec but seems like a good idea.
    // Most of what we want to protect against has already been checked
    // by the time we get here, we ASSERT this is checked builds.
    // REVIEW: Final spec may allow/disallow a different set of addresses.
    //
    ASSERT(!IsInvalidSourceAddress(HomeAddr));
    ASSERT(!IsUnspecified(HomeAddr));
    ASSERT(!IsLoopback(HomeAddr));
    if (IsLinkLocal(HomeAddr) ||
        IsSiteLocal(HomeAddr)) {

        //
        // Since the home address is suspect, do not send binding ack.
        //
        return 1;
    }

    //
    // While the mobility spec requires that packets containing binding
    // update options be authenticated, we currently allow this to be
    // turned off for interoperability testing with mobility implementations
    // that don't support IPSec yet.
    //
    if (MobilitySecurity) {
        //
        // Check if the packet went through some security.
        // If the security check fails we MUST silently drop the packet.
        //
        // REVIEW: This doesn't check that use of this security association
        // REVIEW: actually falls within a security policy.
        //
        if (Packet->SAPerformed == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "IPv6RecvBindingUpdate: IPSec required "
                       "for binding update\n"));
            return 1;
        }
    }

    CareOfAddr = AlignAddr(&Packet->IP->Source);
    ASSERT(!IsInvalidSourceAddress(CareOfAddr));

    //
    // Sub-options may follow the fixed portion of the header.
    //
    OptBytesLeft = sizeof(OptionHeader) + BindingUpdate->Length
        - sizeof(IPv6BindingUpdateOption);
    if (OptBytesLeft != 0) {
        //
        // Sub-options are present.  Parse them.
        //
        if (!ParseSubOptions((uchar *) (BindingUpdate + 1), OptBytesLeft)) {
            //
            // Sub-options are malformed.  Spec doesn't explicitly say
            // what to do, but the implication is to silently drop.
            //
            return 1;
        }
    }

    //
    // Check to make sure we have a reasonable care-of address.
    // Not required by spec but seems like a good idea.
    // REVIEW: Aren't link-local addresses o.k. as care-of addresses?
    //
    if (IsUnspecified(CareOfAddr) ||
        IsLoopback(CareOfAddr) ||
        IsLinkLocal(CareOfAddr)) {

        //
        // Since the care-of address is suspect, do not send binding ack.
        //
        return 1;
    }

    //
    // We don't support home agent functionality (yet).
    // The spec says we SHOULD send a rejecting acknowledgement in this case.
    //
    if (BindingUpdate->Flags & IPV6_BINDING_HOME_REG) {
        IPv6SendBindingAck(CareOfAddr, Packet->NTEorIF, HomeAddr,
                           IPV6_BINDING_HOME_REG_NOT_SUPPORTED,
                           BindingUpdate->SeqNumber, 0);
        return 1;
    }

    //
    // Update our binding cache to reflect this binding update.
    //
    Status = CacheBindingUpdate(BindingUpdate, CareOfAddr, Packet->NTEorIF,
                                HomeAddr);
    if (Status != IPV6_BINDING_ACCEPTED) {
        //
        // Failed to update our binding cache.  If this failure was due to 
        // an old sequence number being present in the packet, we MUST
        // silently ignore it.  Otherwise we send a rejecting acknowledgement.
        //
        if (Status != IPV6_BINDING_SEQ_NO_TOO_SMALL)
            IPv6SendBindingAck(CareOfAddr, Packet->NTEorIF, HomeAddr,
                               Status, BindingUpdate->SeqNumber, 0);
        return 1;
    }

    if (BindingUpdate->Flags & IPV6_BINDING_ACK) {
        //
        // The mobile node has requested an acknowledgement. In some cases
        // this could be delayed until the next packet is sent
        // to the mobile node, but for now we always send one immediately.
        // We MUST always use a routing header for binding acks.
        // If we deleted a binding, we ack with a zero lifetime.
        //
        IPv6SendBindingAck(CareOfAddr, Packet->NTEorIF, HomeAddr,
                           Status, BindingUpdate->SeqNumber,
                           (IP6_ADDR_EQUAL(HomeAddr, CareOfAddr) ?
                            0 : BindingUpdate->Lifetime));
    }

    return 0;
}


//* IPv6RecvHomeAddress - handle an incoming home address option.
//
//  Process the receipt of a Home Address destination option.  
//
int
IPv6RecvHomeAddress(
    IPv6Packet *Packet,                  // Packet received.
    IPv6HomeAddressOption UNALIGNED *HomeAddress)
{
    uint OptBytesLeft, OptsLen;

    //
    // If any mobile sub-options exist, then find out which ones.
    // For now we don't do anything with them.
    //
    OptsLen = HomeAddress->Length + sizeof(OptionHeader);
    OptBytesLeft = OptsLen - sizeof(IPv6HomeAddressOption);

    if (OptBytesLeft != 0) {
        if (!ParseSubOptions((uchar *) HomeAddress + OptsLen - OptBytesLeft,
                             OptBytesLeft))
            return 1;
    }

    //
    // Save the home address for use by upper layers.
    //
    Packet->SrcAddr = AlignAddr(&HomeAddress->HomeAddress);
    Packet->Flags |= PACKET_SAW_HA_OPT;

    // Done.
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\mld.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Multicast Listener Discovery for Internet Protocol Version 6.
// See draft-ietf-ipngwg-mld-00.txt for details.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "icmp.h"
#include "mld.h"
#include "ntddip6.h"
#include "route.h"
#include "alloca.h"
#include "info.h"


//
// The QueryListLock may be taken while holding an Interface lock.
//
KSPIN_LOCK QueryListLock;
MulticastAddressEntry *QueryList;


//* AddToQueryList
//
//  Add an MAE to the front of the QueryList. 
//  The caller should already have the QueryList and the IF locked.
//
void
AddToQueryList(MulticastAddressEntry *MAE)
{
    MAE->NextQL = QueryList;
    QueryList = MAE;
}


//* RemoveFromQueryList
//
//  Remove an MAE from the QueryList.
//  The caller should already have the QueryList and the IF locked.
//
void
RemoveFromQueryList(MulticastAddressEntry *MAE)
{
    MulticastAddressEntry **PrevMAE, *ThisMAE;

    for (PrevMAE = &QueryList; ; PrevMAE = &ThisMAE->NextQL) {
        ThisMAE = *PrevMAE;
        ASSERT(ThisMAE != NULL);

        if (ThisMAE == MAE) {
            //
            // Remove the entry.
            //
            *PrevMAE = ThisMAE->NextQL;
            break;
        }
    }
}


//* MLDQueryReceive - Process the receipt of a Group Query MLD message. 
//
//  Queries for a specific group should be sent to the group address
//  in question.  General queries are sent to the all nodes address, and 
//  have the group address set to zero.
//  Here we need to add the group to the list of groups waiting to send 
//  membership reports.  Then set the timer value in the ADE entry to a
//  random value determines by the incoming query.
//
void
MLDQueryReceive(IPv6Packet *Packet)
{
    Interface *IF = Packet->NTEorIF->IF;
    MLDMessage *Message;
    MulticastAddressEntry *MAE;
    uint MaxResponseDelay;

    //
    // Verify that the packet has a link-local source address.
    //
    if (!IsLinkLocal(AlignAddr(&Packet->IP->Source))) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "MLDQueryReceive: non-link-local source\n"));
        return;
    }

    //
    // Verify that we have enough contiguous data to overlay a MLDMessage
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof(MLDMessage),
                       __builtin_alignof(MLDMessage), 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(MLDMessage))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "MLDQueryReceive: too small to contain MLD message\n"));
        return;
    }
    Message = (MLDMessage *)Packet->Data;

    //
    // Get the maximum response value from the received MLD message.
    //
    MaxResponseDelay = net_short(Message->MaxResponseDelay);  // Milliseconds.
    MaxResponseDelay = ConvertMillisToTicks(MaxResponseDelay);

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    //
    // Loop through the ADE list and update the timer for the desired
    // groups.  Note that a general query uses the unspecified address, and
    // sets the timer for all groups.
    //
    for (MAE = (MulticastAddressEntry *)IF->ADE;
         MAE != NULL;
         MAE = (MulticastAddressEntry *)MAE->Next) {

        if ((MAE->Type == ADE_MULTICAST) &&
            (MAE->MCastFlags & MAE_REPORTABLE) &&
            (IP6_ADDR_EQUAL(AlignAddr(&Message->GroupAddr),
                            &UnspecifiedAddr) ||
             IP6_ADDR_EQUAL(AlignAddr(&Message->GroupAddr),
                            &MAE->Address))) {

            //
            // If the timer is currently off or if the maximum requested
            // response delay is less than the current timer value, draw a
            // random value on the interval(0, MaxResponseDelay) and update
            // the timer to reflect this value.
            //
            KeAcquireSpinLockAtDpcLevel(&QueryListLock);

            //
            // Add this MAE to the QueryList, if not already present.
            //
            if (MAE->MCastTimer == 0) {
                AddToQueryList(MAE);
                goto UpdateTimerValue;
            }

            if (MaxResponseDelay <= MAE->MCastTimer) {
            UpdateTimerValue:
                //
                // Update the timer value.
                //
                if (MaxResponseDelay == 0)
                    MAE->MCastTimer = 0;
                else
                    MAE->MCastTimer = (ushort)
                        RandomNumber(0, MaxResponseDelay);

                //
                // We add 1 because MLDTimeout predecrements.
                // We must maintain the invariant that ADEs on
                // the query list have a non-zero timer value.
                //
                MAE->MCastTimer += 1;
            }

            KeReleaseSpinLockFromDpcLevel(&QueryListLock);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
}


//* MLDReportReceive - Process the receipt of a Group Report MLD message. 
//
//  When another host on the local link sends a group report, we receive
//  a copy if we also belong to the group.  If we have a timer running for
//  this group, we can turn it off now.
//
//  Callable from DPC context, not from thread context.
//
void
MLDReportReceive(IPv6Packet *Packet)
{
    Interface *IF = Packet->NTEorIF->IF;
    MLDMessage *Message;
    MulticastAddressEntry *MAE;

    //
    // Verify that the packet has a link-local source address.
    // An unspecified source address can also happen during initialization.
    //
    if (!(IsLinkLocal(AlignAddr(&Packet->IP->Source)) ||
          IsUnspecified(AlignAddr(&Packet->IP->Source)))) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "MLDReportReceive: non-link-local source\n"));
        return;
    }

    //
    // Verify that we have enough contiguous data to overlay a MLDMessage
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof(MLDMessage),
                       __builtin_alignof(MLDMessage), 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(MLDMessage))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "MLDReportReceive: too small to contain MLD message\n"));
        return;
    }
    Message = (MLDMessage *)Packet->Data;

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    //
    // Search for the MAE for this group address.
    //
    MAE = (MulticastAddressEntry *)
        *FindADE(IF, AlignAddr(&Message->GroupAddr));
    if ((MAE != NULL) && (MAE->Type == ADE_MULTICAST)) {

        KeAcquireSpinLockAtDpcLevel(&QueryListLock);
        //
        // We ignore the report unless
        // we are in the "Delaying Listener" state.
        //
        if (MAE->MCastTimer != 0) {
            //
            // Stop our timer and clear the last-reporter flag.
            // Note that we only clear the last-reporter flag
            // if our timer is running, as called for in the spec.
            // Although it would make sense to clear the flag
            // when we do not have a timer running.
            //
            MAE->MCastTimer = 0;
            MAE->MCastFlags &= ~MAE_LAST_REPORTER;
            RemoveFromQueryList(MAE);
        }
        KeReleaseSpinLockFromDpcLevel(&QueryListLock);
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
}


//* MLDMessageSend
//
//  Primitive function for sending MLD messages.
//
//  Note that we can not use RouteToDestination to get an RCE.
//  There might be no valid source addresses on the sending interface.
//  We could use IPv6SendND, but it doesn't make sense because
//  we can't pass in a valid DiscoveryAddress. And it's not needed.
//
void
MLDMessageSend(
    Interface *IF,
    const IPv6Addr *GroupAddr,
    const IPv6Addr *Dest,
    uchar Type)
{
    PNDIS_PACKET Packet;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    MLDMessage UNALIGNED *MLD;
    MLDRouterAlertOption UNALIGNED *RA;
    uint Offset;
    uint PayloadLength;
    uint MemLen;
    uchar *Mem;
    void *LLDest;
    IP_STATUS Status;

    ICMPv6OutStats.icmps_msgs++;

    ASSERT(IsMulticast(Dest));

    //
    // Calculate the packet size.
    //
    Offset = IF->LinkHeaderSize;
    PayloadLength = sizeof(MLDRouterAlertOption) + sizeof(ICMPv6Header)
        + sizeof(MLDMessage);
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;

    //
    // Allocate the packet.
    //
    Status = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    //
    // Prepare the IP header.
    //
    IP = (IPv6Header UNALIGNED *)(Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->PayloadLength = net_short((ushort)PayloadLength);
    IP->NextHeader = IP_PROTOCOL_HOP_BY_HOP;
    IP->HopLimit = 1; 
    IP->Dest = *Dest;
    //
    // This will give us the unspecified address
    // if our link-local address is not valid.
    // (For example if it is still tentative pending DAD.)
    //
    (void) GetLinkLocalAddress(IF, AlignAddr(&IP->Source));

    //
    // Prepare the router alert option.
    //
    RA = (MLDRouterAlertOption UNALIGNED *)(IP + 1);
    RA->Header.NextHeader = IP_PROTOCOL_ICMPv6;
    RA->Header.HeaderExtLength = 0;
    RA->Option.Type = OPT6_ROUTER_ALERT;
    RA->Option.Length = 2;
    RA->Option.Value = MLD_ROUTER_ALERT_OPTION_TYPE;
    RA->Pad.Type = 1;
    RA->Pad.DataLength = 0;

    //
    // Prepare the ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)(RA + 1);
    ICMP->Type = Type;
    ICMP->Code = 0;
    ICMP->Checksum = 0; // Calculated below.

    //
    // Prepare the MLD message.
    //
    MLD = (MLDMessage UNALIGNED *)(ICMP + 1);
    MLD->MaxResponseDelay = 0;
    MLD->Unused = 0;
    MLD->GroupAddr = *GroupAddr;

    //
    // Calculate the ICMP checksum.
    //
    ICMP->Checksum = ChecksumPacket(Packet,
                Offset + sizeof(IPv6Header) + sizeof(MLDRouterAlertOption),
                NULL,
                sizeof(ICMPv6Header) + sizeof(MLDMessage),
                AlignAddr(&IP->Source), AlignAddr(&IP->Dest),
                IP_PROTOCOL_ICMPv6);

    //
    // Convert the IP-level multicast destination address
    // to a link-layer multicast address.
    //
    LLDest = alloca(IF->LinkAddressLength);
    (*IF->ConvertAddr)(IF->LinkContext, Dest, LLDest);
    PC(Packet)->Flags = NDIS_FLAGS_MULTICAST_PACKET | NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Transmit the packet.
    //
    ICMPv6OutStats.icmps_typecount[Type]++;
    IPv6SendLL(IF, Packet, Offset, LLDest);
}


//* MLDReportSend - Send an MLD membership report.
//
//  This function is called either when a host first joins a multicast group or
//  at some point after a membership query message was received, and the timer
//  for this host has expired.
//
void
MLDReportSend(Interface *IF, const IPv6Addr *GroupAddr)
{
    MLDMessageSend(IF, GroupAddr, GroupAddr,
                   ICMPv6_MULTICAST_LISTENER_REPORT);
}


//* MLDDoneSend - Send an MLD done message.
//
//  This function is called when a host quits a multicast group AND this was
//  the last host on the local link to report interest in the group.  A host 
//  quits when either the upper layer explicitly quits or when the interface
//  is deleted.
//
void
MLDDoneSend(Interface *IF, const IPv6Addr *GroupAddr)
{
    MLDMessageSend(IF, GroupAddr, &AllRoutersOnLinkAddr,
                   ICMPv6_MULTICAST_LISTENER_DONE);
}


//* MLDAddMCastAddr - Add a multicast group to the specified interface.
//
//  This function is called when a user level program has asked to join a 
//  multicast group.
//
//  The Interface number can be supplied as zero,
//  in which we try to pick a reasonable interface
//  and then return the interface number that we picked.
//
//  Callable from thread context, not from DPC context.
//  Called with no locks held.
//
IP_STATUS
MLDAddMCastAddr(uint *pInterfaceNo, const IPv6Addr *Addr)
{
    uint InterfaceNo = *pInterfaceNo;
    Interface *IF;
    MulticastAddressEntry *MAE;
    IP_STATUS status;
    KIRQL OldIrql;

    if (!IsMulticast(Addr)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "MLDAddMCastAddr: Not mcast addr\n"));
        return IP_PARAMETER_PROBLEM;
    }

    if (InterfaceNo == 0) {
        RouteCacheEntry *RCE;

        //
        // We must pick an interface to use for this multicast address.
        // Look for a multicast route in the routing table.
        //
        status = RouteToDestination(Addr, 0, NULL, RTD_FLAG_NORMAL, &RCE);
        if (status != IP_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "MLDAddMCastAddr - no route\n"));
            return status;
        }

        //
        // Use the interface associated with the RCE.
        //
        IF = RCE->NTE->IF;
        *pInterfaceNo = IF->Index;
        AddRefIF(IF);
        ReleaseRCE(RCE);
    }
    else {
        //
        // Use the interface requested by the application.
        //
        IF = FindInterfaceFromIndex(InterfaceNo);
        if (IF == NULL)
            return IP_PARAMETER_PROBLEM; 
    }

    //
    // Will this interface support multicast addresses?
    //
    if (!(IF->Flags & IF_FLAG_MULTICAST)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "MLDAddMCastAddr: IF cannot add a mcast addr\n"));
        ReleaseIF(IF);
        return IP_PARAMETER_PROBLEM;
    }

    //
    // The real work is all in FindOrCreateMAE.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    MAE = FindOrCreateMAE(IF, Addr, NULL);
    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    ReleaseIF(IF);
    return (MAE == NULL) ? IP_NO_RESOURCES : IP_SUCCESS;
}


//* MLDDropMCastAddr - remove a multicast address from an interface.
//
//  This function is called when a user has indicated that they are no
//  longer interested in a multicast group.
//
//  Callable from thread context, not from DPC context.
//  Called with no locks held.
//
IP_STATUS
MLDDropMCastAddr(uint InterfaceNo, const IPv6Addr *Addr)
{
    Interface *IF;
    MulticastAddressEntry *MAE;
    IP_STATUS status;
    KIRQL OldIrql;

    //
    // Unlike MLDAddMCastAddr, no need to check
    // if the address is multicast. If it is not,
    // FindAndReleaseMAE will fail to find it.
    //

    if (InterfaceNo == 0) {
        RouteCacheEntry *RCE;

        //
        // We must pick an interface to use for this multicast address.
        // Look for a multicast route in the routing table.
        //
        status = RouteToDestination(Addr, 0, NULL, RTD_FLAG_NORMAL, &RCE);
        if (status != IP_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "MLDDropMCastAddr - no route\n"));
            return status;
        }

        //
        // Use the interface associated with the RCE.
        //
        IF = RCE->NTE->IF;
        AddRefIF(IF);
        ReleaseRCE(RCE);
    }
    else {
        //
        // Use the interface requested by the application.
        //
        IF = FindInterfaceFromIndex(InterfaceNo);
        if (IF == NULL)
            return IP_PARAMETER_PROBLEM; 
    }

    //
    // Unlike MLDAddMCastAddr, no need to check IF_FLAG_MULTICAST.
    // If the interface does not support multicast addresses,
    // FindAndReleaseMAE will fail to find the address.
    //

    //
    // All the real work is in FindAndReleaseMAE.
    //
    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    MAE = FindAndReleaseMAE(IF, Addr);
    if (IsMCastSyncNeeded(IF))
        DeferSynchronizeMulticastAddresses(IF);
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    ReleaseIF(IF);
    return (MAE == NULL) ? IP_PARAMETER_PROBLEM : IP_SUCCESS;
}


//* MLDTimeout - Handle MLD timer events.
//
//  This function is called periodically by IPv6Timeout.
//  We decrement the timer value in each MAE on the query list.
//  If the timer reaches zero, we send a group membership report.
//  If the timer is already zero, that means we should send
//  a Done message and then free the MAE. In this case, the MAE
//  holds an interface reference. See DeleteMAE.
//
void
MLDTimeout(void)
{
    typedef struct MLDReportRequest {
        struct MLDReportRequest *Next;
        Interface *IF;
        IPv6Addr GroupAddr;
    } MLDReportRequest;

    MulticastAddressEntry **PrevMAE, *MAE;
    MLDReportRequest *ReportList = NULL;
    MLDReportRequest *Request;
    MulticastAddressEntry *DoneList = NULL;

    //
    // Lock the QueryList so we can traverse it and decrement timers.
    // But we avoid sending messages while holding any locks
    // by building a list of requested reports.
    //
    KeAcquireSpinLockAtDpcLevel(&QueryListLock);

    PrevMAE = &QueryList;
    while ((MAE = *PrevMAE) != NULL) {

        ASSERT(MAE->Type == ADE_MULTICAST);

        if (MAE->MCastTimer == 0) {
            //
            // We need to send a Done message.
            // Remove this MAE from the QueryList
            // and put it on a temporary list.
            //
            *PrevMAE = MAE->NextQL;
            MAE->NextQL = DoneList;
            DoneList = MAE;
            continue;
        }
        else if (--MAE->MCastTimer == 0) {
            //
            // This entry has expired, we need to send a Report.
            //
            Request = ExAllocatePool(NonPagedPool, sizeof *Request);
            if (Request != NULL) {
                Request->Next = ReportList;
                ReportList = Request;

                Request->IF = MAE->NTEorIF->IF;
                AddRefIF(Request->IF);
                Request->GroupAddr = MAE->Address;

                //
                // Set the flag indicating we sent the last report
                // on the link.
                //
                MAE->MCastFlags |= MAE_LAST_REPORTER;
            }

            if (MAE->MCastCount != 0) {
                if (MAE->NTEorIF->IF->Flags & IF_FLAG_PERIODICMLD) {
                    // 
                    // On tunnels to 6to4 relays, we continue to generate 
                    // periodic reports since queries cannot be sent over
                    // an NBMA interface.
                    // 
                    MAE->MCastTimer = MLD_QUERY_INTERVAL;
                }
                else {
                    //
                    // If we are sending unsolicited reports,
                    // then leave the MAE on the query list
                    // and set a new timer value.
                    //
                    if (--MAE->MCastCount == 0)
                        goto Remove;
    
                    MAE->MCastTimer = (ushort)
                        RandomNumber(0, MLD_UNSOLICITED_REPORT_INTERVAL) + 1;
                }
            }
            else {
            Remove:
                //
                // Remove the MAE from the query list.
                //
                *PrevMAE = MAE->NextQL;
                continue;
            }
        }

        //
        // Go on to the next MAE.
        //
        PrevMAE = &MAE->NextQL;
    }
    KeReleaseSpinLockFromDpcLevel(&QueryListLock);

    //
    // Send MLD Report messages.
    //
    while ((Request = ReportList) != NULL) {
        ReportList = Request->Next;

        //
        // Send the MLD Report message.
        //
        MLDReportSend(Request->IF, &Request->GroupAddr);

        //
        // Free this structure.
        //
        ReleaseIF(Request->IF);
        ExFreePool(Request);
    }

    //
    // Send MLD Done messages.
    //
    while ((MAE = DoneList) != NULL) {
        Interface *IF = MAE->IF;

        DoneList = MAE->NextQL;

        //
        // Send the MLD Done message.
        //
        MLDDoneSend(IF, &MAE->Address);

        //
        // Free this structure.
        //
        ExFreePool(MAE);
        ReleaseIF(IF);
    }
}


//* MLDInit - Initialize MLD.
//
//  Initialize MLD global data structures.
//
void
MLDInit(void)
{
    KeInitializeSpinLock(&QueryListLock);
    QueryList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\mobile.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Mobile IPv6.
// See Mobility Support in IPv6 draft (Mobile IP working group) for details. 
//


#ifndef MOBILE_INCLUDED
#define MOBILE_INCLUDED 1

//
// Mobile IPv6 Mode definitions.
// ntddip6.h also defines these values.
//
extern uint MobileIPv6Mode;
#define MOBILE_CORRESPONDENT    0x01
#define MOBILE_MOBILE_NODE      0x02
#define MOBILE_HOME_AGENT       0x04

//
// For security reasons, we disable correspondent mode by default.
//
#define MIPV6_DEFAULT_MODE      0


//
// Combined structure used for inserting Binding Acknowledgements
// into mobile IPv6 messages.
//
#pragma pack(1)
typedef struct MobileAcknowledgementOption {
    IPv6OptionsHeader Header;
    uchar Pad1;
    IPv6BindingAcknowledgementOption Option;
} MobileAcknowledgementOption;
#pragma pack()

//
// Mobile external functions.
//
extern int
IPv6RecvBindingUpdate(
    IPv6Packet *Packet,
    IPv6BindingUpdateOption UNALIGNED *BindingUpdate);

extern int
IPv6RecvHomeAddress(
    IPv6Packet *Packet,
    IPv6HomeAddressOption UNALIGNED *HomeAddress);

#endif  // MOBILE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\ntip.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// NT specific routines for loading and configuring the IP driver.
//


#define _CTYPE_DISABLE_MACROS  // REVIEW: does this do anything?

#include <oscfg.h>
#include <ndis.h>
#include <ip6imp.h>
#include "ip6def.h"
#include <tdiinfo.h>
#include <tdikrnl.h>
#include <ntddip6.h>
#include <ip6.h>
#include <icmp6.h>
#include "neighbor.h"
#include "route.h"

//
// Global variables.
//
PDRIVER_OBJECT IPDriverObject;
PDEVICE_OBJECT IPDeviceObject;
HANDLE IPv6ProviderHandle;
int IPv6IndicatedProviderReady;
uint UseEtherSnap = FALSE;

#ifdef DEBUG_OBJECTS
extern LIST_ENTRY FileObjectList;
extern KSPIN_LOCK FileObjectLock;
#endif

//
// Local function prototypes
//
NTSTATUS
IPDriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);

uint
UseEtherSNAP(PNDIS_STRING Name);


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, IPDriverEntry)
#pragma alloc_text(PAGE, UseEtherSNAP)

#endif // ALLOC_PRAGMA


//
// Function definitions
//

//* IPDriverEntry
//
// This is the IPv6 protocol initialization entry point, called from
// the common DriverEntry routine upon loading.
//
NTSTATUS                              // Status of initialization operation.
IPDriverEntry(
    IN PDRIVER_OBJECT DriverObject,   // Common TCP/IP driver object.
    IN PUNICODE_STRING RegistryPath)  // Path to our info in the registry.
{
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    UNICODE_STRING WinDeviceName;

    UNREFERENCED_PARAMETER(RegistryPath);

    IPDriverObject = DriverObject;

#ifdef DEBUG_OBJECTS
    InitializeListHead(&FileObjectList);
    KeInitializeSpinLock(&FileObjectLock);
#endif

    //
    // Create the device object.  IoCreateDevice zeroes the memory
    // occupied by the object.
    //
    RtlInitUnicodeString(&DeviceName, DD_IPV6_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject, 0, &DeviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE, &IPDeviceObject);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IP init failed: "
                   "Unable to create device object %ws, Status %lx.",
                   DD_IPV6_DEVICE_NAME, Status));

        return(Status);
    }

    //
    // Create a Win32-accessible link for the device.
    // This will allow Windows programs to make IOCTLs.
    //
    RtlInitUnicodeString(&WinDeviceName, L"\\??\\" WIN_IPV6_BASE_DEVICE_NAME);

    Status = IoCreateSymbolicLink(&WinDeviceName, &DeviceName);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6: IoCreateSymbolicLink failed\n"));

        IoDeleteDevice(IPDeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Register as a TDI provider.
    //
    Status = TdiRegisterProvider(&DeviceName, &IPv6ProviderHandle);
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6: TdiRegisterProvider failed\n"));

        IoDeleteDevice(IPDeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the device object.
    //
    IPDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the list of pending echo request IRPs.
    //
    InitializeListHead(&PendingEchoList);

    //
    // Read configuration parameters from the registry
    // and then initialize.
    //
    ConfigureGlobalParameters();
    if (!IPInit()) {
        //
        // REVIEW: Write an error log entry here?
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "IP initialization failed.\n"));

        TdiDeregisterProvider(IPv6ProviderHandle);
        IoDeleteDevice(IPDeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

//* IPv6ProviderReady
//
//  Indicate that we are ready to operate as a TDI provider.
//
void
IPv6ProviderReady(void)
{
    int DidIndicateProviderReady;
    NTSTATUS Status;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Ensure that we only indicate provider ready once.
    //
    DidIndicateProviderReady = InterlockedExchange(
                                    (PLONG)&IPv6IndicatedProviderReady, TRUE);
    if (! DidIndicateProviderReady) {
        //
        // Create persistent interfaces after any NDIS interfaces.
        //
        ConfigurePersistentInterfaces();

        //
        // Now indicate to TDI that we are ready.
        //
        Status = TdiProviderReady(IPv6ProviderHandle);
        if (!NT_SUCCESS(Status))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "IPv6: TdiProviderReady failed: %x\n", Status));
    }
}

//* UseEtherSNAP
//
//  Determines whether the EtherSNAP protocol should be used on an interface.
//
uint  // Returns: Nonzero if SNAP is to be used on the I/F.  Zero otherwise.
UseEtherSNAP(
    PNDIS_STRING Name)  // Device name of the interface in question.
{
    UNREFERENCED_PARAMETER(Name);

    //
    // We currently set this on a global basis.
    //
    return(UseEtherSnap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\neighbor.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Exported Neighbor Discovery definitions and declarations.
//


#ifndef NEIGHBOR_INCLUDED
#define NEIGHBOR_INCLUDED

extern uint NeighborCacheLimit;

extern uint
CalcReachableTime(uint BaseReachableTime);

extern void
NeighborCacheInit(Interface *IF);

extern void
NeighborCacheDestroy(Interface *IF);

extern void
NeighborCacheTimeout(Interface *IF);

extern void
NeighborCacheFlush(Interface *IF, const IPv6Addr *Addr);

extern NeighborCacheEntry *
FindOrCreateNeighbor(Interface *IF, const IPv6Addr *Addr);

extern void
NeighborCacheCleanup(Interface *IF);

extern void
NeighborCacheCompletePackets(Interface *IF, NDIS_PACKET *PacketList);

extern void
ControlNeighborLoopback(NeighborCacheEntry *NCE, int Loopback);

typedef enum {
    NeighborRoundRobin = -1,            // Time to round-robin.
    NeighborInterfaceDisconnected = 0,  // Interface is disconnected -
                                        // definitely not reachable.
    NeighborUnreachable = 1,            // ND failed - probably not reachable.
    NeighborMayBeReachable = 2          // ND succeeded, or has not concluded.
} NeighborReachability;

extern NeighborReachability
GetReachability(NeighborCacheEntry *NCE);

extern void
NeighborCacheReachabilityConfirmation(NeighborCacheEntry *NCE);

extern void
NeighborCacheReachabilityInDoubt(NeighborCacheEntry *NCE);

extern void
NeighborCacheProbeUnreachability(NeighborCacheEntry *NCE);

extern void
DADTimeout(NetTableEntry *NTE);

extern void
RouterSolicitSend(Interface *IF);

extern void
RouterSolicitTimeout(Interface *IF);

extern void
RouterAdvertTimeout(Interface *IF, int Force);

extern void
RouterSolicitReceive(IPv6Packet *Packet, ICMPv6Header UNALIGNED *ICMP);

extern void
RouterAdvertReceive(IPv6Packet *Packet, ICMPv6Header UNALIGNED *ICMP);

extern void
NeighborSolicitReceive(IPv6Packet *Packet, ICMPv6Header UNALIGNED *ICMP);

extern void
NeighborAdvertReceive(IPv6Packet *Packet, ICMPv6Header UNALIGNED *ICMP);

extern void
RedirectReceive(IPv6Packet *Packet, ICMPv6Header UNALIGNED *ICMP);

extern void
RedirectSend(
    NeighborCacheEntry *NCE,               // Neighbor getting the Redirect.
    NeighborCacheEntry *TargetNCE,         // Better first-hop to use
    const IPv6Addr *Destination,           // for this Destination address.
    NetTableEntryOrInterface *NTEorIF,     // Source of the Redirect.
    PNDIS_PACKET FwdPacket,                // Packet triggering the redirect.
    uint FwdOffset,
    uint FwdPayloadLength);

extern void
NeighborSolicitSend(NeighborCacheEntry *NCE, const IPv6Addr *Source);

#endif  // NEIGHBOR_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\neighbor.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Neighbor Discovery (ND) Protocol for Internet Protocol Version 6.
// Logically a part of ICMPv6, but put in a separate file for clarity.
// See RFC 2461 for details.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "icmp.h"
#include "neighbor.h"
#include "route.h"
#include "select.h"
#include "alloca.h"
#include "info.h"

//
//
//  NeighborCacheLimit is an upper-bound on IF->NCENumUnused.
//  NCENumUnused is the number of NCEs that have zero references.
//  We do not keep track of the total number of NCEs,
//  since NCEs with references are not available for reuse.
//
//  REVIEW: What is a reasonable value for NeighborCacheLimit?
//  Should probably be sized relative to physical memory
//  and link characteristics.
//
//  We cache & reclaim NCEs on a per-interface basis.
//  Theoretically it would be better to use a global LRU list.
//  However this would introduce added overhead (making NCEs bigger)
//  and locking. At this point I believe that it isn't worth it.
//
//  Another thought - it's much more important to support many RCEs
//  than it is to support many NCEs.
//
uint NeighborCacheLimit;        // Initialized in ConfigureGlobalParameters.

//* NeighborCacheInit
//
//  Initialize the neighbor cache for an interface.
//
void
NeighborCacheInit(Interface *IF)
{
    KeInitializeSpinLock(&IF->LockNC);
    IF->FirstNCE = IF->LastNCE = SentinelNCE(IF);
    ASSERT(IF->NCENumUnused == 0);
    ASSERT(IF->PacketList == NULL);
}

//* NeighborCacheDestroy
//
//  Cleanup and deallocate the NCEs in the neighbor cache.
//
//  This is done when the interface is being destroyed
//  and no one else has access to it, so it does not need to be locked.
//
void
NeighborCacheDestroy(Interface *IF)
{
    NeighborCacheEntry *NCE;
    PNDIS_PACKET Packet;

    ASSERT(IsDisabledIF(IF));
    ASSERT(IF->RefCnt == 0);

    while ((NCE = IF->FirstNCE) != SentinelNCE(IF)) {
        ASSERT(NCE->IF == IF);
        ASSERT(NCE->RefCnt == 0);

        //
        // Unlink the NCE.
        //
        NCE->Next->Prev = NCE->Prev;
        NCE->Prev->Next = NCE->Next;
        InterlockedDecrement((long *)&IF->NCENumUnused);

        //
        // If there's a packet waiting, destroy it too.
        //
        Packet = NCE->WaitQueue;
        if (Packet != NULL)
            IPv6SendComplete(NULL, Packet, IP_GENERAL_FAILURE);

        ExFreePool(NCE);
    }

    ASSERT(IF->NCENumUnused == 0);
}


//* NeighborCacheInitialize
//
//  (Re)initialize a Neighbor Cache Entry.
//
//  Our caller is responsible for using InvalidateRouteCache
//  when appropriate.
//
//  Called with the neighbor cache lock held.
//  (So we are at DPC level.)
//
void
NeighborCacheInitialize(
    Interface *IF,
    NeighborCacheEntry *NCE,
    ushort NDState,
    const void *LinkAddress)
{
    //
    // Forget everything we know about this neighbor.
    //

    NCE->IsRouter = FALSE;
    NCE->IsUnreachable = FALSE;
    NCE->DoRoundRobin = FALSE;

    //
    // Initialize this timestamp to a value in the past,
    // so comparisons against it do not cause problems.
    //
    NCE->LastReachability = IPv6TickCount - IF->ReachableTime;

    if (NDState == ND_STATE_INCOMPLETE) {
        //
        // Let the link-layer create an initial link-layer address
        // and set the appropriate ND state.
        //
        NCE->NDState = (*IF->ConvertAddr)(IF->LinkContext,
                                          &NCE->NeighborAddress,
                                          NCE->LinkAddress);
    }
    else {
        //
        // Our caller supplied an ND state and a link-layer address.
        //
        NCE->NDState = NDState;
        RtlCopyMemory(NCE->LinkAddress, LinkAddress, IF->LinkAddressLength);
    }

    if (NCE->NDState == ND_STATE_DELAY) {
        //
        // Internally we use the PROBE state with zero NSCount instead.
        // If there is a packet waiting, we opt to send it immediately
        // instead of waiting the usual delay.
        //
        NCE->NDState = ND_STATE_PROBE;
        if (NCE->WaitQueue != NULL)
            NCE->NSTimer = 1;
        else
            NCE->NSTimer = DELAY_FIRST_PROBE_TIME;
        NCE->NSLimit = MAX_UNICAST_SOLICIT;
    }
    else if ((NCE->WaitQueue != NULL) ||
             (NCE->NDState == ND_STATE_PROBE)) {
        //
        // Get NeighborCacheTimeout to do our dirty work.
        // It will either send a solicitation (if the NCE is INCOMPLETE)
        // or send the waiting packet directly.
        // This is not a common case - not worth having code
        // here using IPv6SendLater etc.
        //
        NCE->NSTimer = 1;
        if (NCE->NDState == ND_STATE_INCOMPLETE)
            NCE->NSLimit = MAX_MULTICAST_SOLICIT;
        else if (NCE->NDState == ND_STATE_PROBE)
            NCE->NSLimit = MAX_UNICAST_SOLICIT;
        else
            NCE->NSLimit = 0;
    }
    else {
        //
        // Cancel any pending timeout.
        //
        NCE->NSTimer = 0;
        NCE->NSLimit = 0;
    }
    NCE->NSCount = 0;
}


//
//* AddRefNCEInCache
//
//  Increments the reference count on an NCE
//  in the interface's neighbor cache.
//  The NCE's current reference count may be zero.
//
//  Called with the neighbor cache lock held.
//  (So we are at DPC level.)
//
void
AddRefNCEInCache(NeighborCacheEntry *NCE)
{
    //
    // If the NCE previously had no references,
    // increment the interface's reference count.
    //
    if (InterlockedIncrement(&NCE->RefCnt) == 1) {
        Interface *IF = NCE->IF;

        AddRefIF(IF);
        InterlockedDecrement((long *)&IF->NCENumUnused);
    }
}

//* ReleaseNCE
//
//  Releases a reference for an NCE.
//  May result in deallocation of the NCE.
//
//  Callable from thread or DPC context.
//
void
ReleaseNCE(NeighborCacheEntry *NCE)
{
    //
    // If the NCE has no more references,
    // release its reference for the interface.
    // This may cause the interface (and hence the NCE)
    // to be deallocated.
    //
    if (InterlockedDecrement(&NCE->RefCnt) == 0) {
        Interface *IF = NCE->IF;

        InterlockedIncrement((long *)&IF->NCENumUnused);
        ReleaseIF(IF);
    }
}

//* CreateOrReuseNeighbor
//
//  Creates a new NCE for an interface.
//  Attempts to reuse an existing NCE if the interface
//  already has too many NCEs.
//
//  Called with the neighbor cache lock held.
//  (So we are at DPC level.)
//
//  Returns NULL if a new NCE could not be created.
//  Returns the NCE with RefCnt, IF, LinkAddress, WaitQueue
//  fields initialized. The NCE is last on the list
//  and IF->NCENumUnused is incremented.
//
NeighborCacheEntry *
CreateOrReuseNeighbor(Interface *IF)
{
    NeighborCacheEntry *NCE;

    //
    // If the cache is full, first try to free unused NCEs.
    //
    NeighborCacheCleanup(IF);

    //
    // FindNextHop tends to create NCEs that end up not getting used.
    // We reuse these unused NCEs even when the cache is not full.
    //
    if (((NCE = IF->LastNCE) != SentinelNCE(IF)) &&
        (NCE->RefCnt == 0) &&
        (NCE->WaitQueue == NULL) &&
        (((NCE->NDState == ND_STATE_INCOMPLETE) && !NCE->IsUnreachable) ||
         (NCE->NDState == ND_STATE_PERMANENT)))
        return NCE;

    //
    // Allocate a new NCE.
    //
    NCE = (NeighborCacheEntry *) ExAllocatePool(NonPagedPool, sizeof *NCE +
                                                IF->LinkAddressLength);
    if (NCE == NULL)
        return NULL;

    NCE->RefCnt = 0;
    NCE->LinkAddress = (void *)(NCE + 1);
    NCE->IF = IF;
    NCE->WaitQueue = NULL;

    //
    // Link new entry into chain of NCEs on this interface.
    // Put the new entry at the end, because until it is
    // used to send a packet it has not proven itself valuable.
    //
    NCE->Prev = IF->LastNCE;
    NCE->Prev->Next = NCE;
    NCE->Next = SentinelNCE(IF);
    NCE->Next->Prev = NCE;
    InterlockedIncrement((long *)&IF->NCENumUnused);

    return NCE;
}

//* NeighborCacheCleanup
//
//  Removes unused NCEs if necessary to shrink the cache.
//  Pushes unsent packets (that were waiting for address resolution)
//  onto the interface's PacketList. Later NeighborCacheCompletePackets
//  will be called to complete the packets.
//
//  Called with the neighbor cache lock held.
//
void
NeighborCacheCleanup(Interface *IF)
{
    NDIS_PACKET *Packet;
    NeighborCacheEntry *NCE;
    NeighborCacheEntry *PrevNCE;

    //
    // We traverse the cache from back to front so that
    // if we have to free unused NCEs, we free the LRU ones first.
    //
    for (NCE = IF->LastNCE;
         (NCE != SentinelNCE(IF)) && (IF->NCENumUnused > NeighborCacheLimit);
         NCE = PrevNCE) {
        PrevNCE = NCE->Prev;

        //
        // Free the NCE if it is not being used.
        //
        if (NCE->RefCnt == 0) {
            //
            // If this NCE has a waiting packet,
            // queue it for later completion.
            //
            Packet = NCE->WaitQueue;
            if (Packet != NULL) {
                PC(Packet)->pc_drop = TRUE;
                PC(Packet)->pc_link = IF->PacketList;
                IF->PacketList = Packet;
            }

            //
            // Remove and release the unused NCE.
            // It does not hold a reference for the interface.
            //
            NCE->Next->Prev = NCE->Prev;
            NCE->Prev->Next = NCE->Next;
            InterlockedDecrement((long *)&IF->NCENumUnused);
            ExFreePool(NCE);
        }
    }
}

//* NeighborCacheCompletePackets
//
//  Completes a list of packets that had been waiting for address resolution.
//
//  Called with no locks held.
//
void
NeighborCacheCompletePackets(
    Interface *IF,
    NDIS_PACKET *PacketList)
{
    NDIS_PACKET *Packet;

    while ((Packet = PacketList) != NULL) {
        PacketList = PC(Packet)->pc_link;

        if (PC(Packet)->pc_drop) {
            //
            // Drop the packet because of resource shortage.
            //
            IPv6SendComplete(NULL, Packet, IP_NO_RESOURCES);
        }
        else {
            //
            // Abort the packet because address resolution failed.
            //
            IPv6SendAbort(CastFromIF(IF),
                          Packet, PC(Packet)->pc_offset,
                          ICMPv6_DESTINATION_UNREACHABLE,
                          ICMPv6_ADDRESS_UNREACHABLE,
                          0, FALSE);
        }
    }
}

//
//* FindOrCreateNeighbor
//
//  Searches an interface's neighbor cache for an entry.
//  Creates the entry (but does NOT send initial solicit)
//  if an existing entry is not found.
//
//  May be called with route cache lock or interface lock held.
//  Callable from thread or DPC context.
//
//  We avoid sending a solicit here, because this function
//  is called while holding locks that make that a bad idea.
//
//  Returns NULL only if an NCE could not be created.
//
NeighborCacheEntry *
FindOrCreateNeighbor(Interface *IF, const IPv6Addr *Addr)
{
    KIRQL OldIrql;
    NeighborCacheEntry *NCE;

    KeAcquireSpinLock(&IF->LockNC, &OldIrql);

    for (NCE = IF->FirstNCE; NCE != SentinelNCE(IF); NCE = NCE->Next) {

        if (IP6_ADDR_EQUAL(Addr, &NCE->NeighborAddress)) {
            //
            // Found matching entry.
            //
            goto ReturnNCE;
        }
    }

    //
    // Get a new entry for this neighbor.
    //
    NCE = CreateOrReuseNeighbor(IF);
    if (NCE == NULL) {
        KeReleaseSpinLock(&IF->LockNC, OldIrql);
        return NULL;
    }

    ASSERT(IF->LastNCE == NCE);
    ASSERT(NCE->RefCnt == 0);

    //
    // Initialize the neighbor cache entry.
    // The RefCnt, IF, LinkAddress, WaitQueue fields are already initialized.
    //
    NCE->NeighborAddress = *Addr;
#if DBG
    RtlZeroMemory(NCE->LinkAddress, IF->LinkAddressLength);
#endif

    //
    // Initialize this NCE normally.
    // Loopback initialization happens in ControlNeighborLoopback.
    //
    NCE->IsLoopback = FALSE;
    NeighborCacheInitialize(IF, NCE, ND_STATE_INCOMPLETE, NULL);

  ReturnNCE:
    AddRefNCEInCache(NCE);
    KeReleaseSpinLock(&IF->LockNC, OldIrql);
    return NCE;
}


//* ControlNeighborLoopback
//
//  Sets the Neighbor Discovery state of an NCE
//  to control loopback behavior.
//
//  Called with the interface locked.
//  (So we are at DPC level.)
//
void
ControlNeighborLoopback(
    NeighborCacheEntry *NCE,
    int Loopback)
{
    Interface *IF = NCE->IF;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);

    if (Loopback) {
        //
        // Initialize this NCE for loopback.
        //
        NCE->IsLoopback = TRUE;
        NeighborCacheInitialize(IF, NCE, ND_STATE_PERMANENT, IF->LinkAddress);
    }
    else {
        //
        // Initialize this NCE normally.
        //
        NCE->IsLoopback = FALSE;
        NeighborCacheInitialize(IF, NCE, ND_STATE_INCOMPLETE, NULL);
    }

    //
    // We changed state that affects routing.
    //
    InvalidateRouteCache();

    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);
}

//* GetReachability
//
//  Returns reachability information for a neighbor.
//
//  Because FindNextHop uses GetReachability, any state change
//  that changes GetReachability's return value
//  must invalidate the route cache.
//
//  The NeighborRoundRobin return value is special - it indicates
//  that FindNextHop should round-robin and use a different route.
//  It is not persistent - a subsequent call to GetReachability
//  will return NeighborUnreachable.
//
//  Callable from DPC context (or with the route lock held),
//  not from thread context.
//
int
GetReachability(NeighborCacheEntry *NCE)
{
    Interface *IF = NCE->IF;
    NeighborReachability Reachable;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);
    if (IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)
        Reachable = NeighborInterfaceDisconnected;
    else if (NCE->IsUnreachable) {
        if (NCE->DoRoundRobin) {
            NCE->DoRoundRobin = FALSE;
            Reachable = NeighborRoundRobin;
        } else
            Reachable = NeighborUnreachable;
    } else
        Reachable = NeighborMayBeReachable;
    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);

    return Reachable;
}

//* NeighborCacheUpdate - Update link address information about a neighbor.
//
//  Called when we've received possibly new information about one of our
//  neighbors, the source of a Neighbor Solicitation, Router Advertisement,
//  or Router Solicitation.
//
//  Note that our receipt of this packet DOES NOT imply forward reachability
//  to this neighbor, so we do not update our LastReachability timer.
//
//  Callable from DPC context, not from thread context.
//
//  The LinkAddress might be NULL, which means we can only process IsRouter.
//
//  If IsRouter is FALSE, then we don't know whether the neighbor
//  is a router or not.  If it's TRUE, then we know it is a router.
//
void
NeighborCacheUpdate(NeighborCacheEntry *NCE, // The neighbor.
                    const void *LinkAddress, // Corresponding media address.
                    int IsRouter)            // Do we know it's a router.
{
    Interface *IF = NCE->IF;
    PNDIS_PACKET Packet = NULL;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);

    if (NCE->NDState != ND_STATE_PERMANENT) {
        //
        // Check to see if the link address changed.
        //
        if ((LinkAddress != NULL) &&
            ((NCE->NDState == ND_STATE_INCOMPLETE) ||
             RtlCompareMemory(LinkAddress, NCE->LinkAddress,
                        IF->LinkAddressLength) != IF->LinkAddressLength)) {
            //
            // Link-level address changed.  Update cache entry with the
            // new one and change state to STALE as we haven't verified
            // forward reachability with the new address yet.
            //
            RtlCopyMemory(NCE->LinkAddress, LinkAddress,
                          IF->LinkAddressLength);
            NCE->NSTimer = 0; // Cancel any outstanding timeout.
            NCE->NDState = ND_STATE_STALE;

            //
            // Flush the queue of waiting packets.
            // (Only relevant if we were in the INCOMPLETE state.)
            //
            if (NCE->WaitQueue != NULL) {

                Packet = NCE->WaitQueue;
                NCE->WaitQueue = NULL;
            }
        }

        //
        // If we know that the neighbor is a router,
        // remember that fact.
        //
        if (IsRouter)
            NCE->IsRouter = TRUE;

    } // end if (NCE->NDState != ND_STATE_PERMANENT)

    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);

    //
    // If we can now send a packet, do so.
    // (Without holding a lock.)
    //
    if (Packet != NULL) {
        uint Offset;

        Offset = PC(Packet)->pc_offset;
        IPv6SendND(Packet, Offset, NCE, &(PC(Packet)->DiscoveryAddress));
    }
}

//* NeighborCacheSearch
//
//  Searches the neighbor cache for an entry that matches
//  the neighbor IPv6 address. If found, returns the link-level address.
//  Returns FALSE to indicate failure.
//
//  Callable from DPC context, not from thread context.
//
int
NeighborCacheSearch(
    Interface *IF,
    const IPv6Addr *Neighbor,
    void *LinkAddress)
{
    NeighborCacheEntry *NCE;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);

    for (NCE = IF->FirstNCE; NCE != SentinelNCE(IF); NCE = NCE->Next) {

        if (IP6_ADDR_EQUAL(Neighbor, &NCE->NeighborAddress)) {
            //
            // Entry found. Return it's cached link-address,
            // if it's valid.
            //
            if (NCE->NDState == ND_STATE_INCOMPLETE) {
                //
                // No valid link address.
                //
                break;
            }

            //
            // The entry has a link-level address.
            // Must copy it with the lock held.
            //
            RtlCopyMemory(LinkAddress, NCE->LinkAddress,
                          IF->LinkAddressLength);
            KeReleaseSpinLockFromDpcLevel(&IF->LockNC);
            return TRUE;
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);
    return FALSE;
}

//* NeighborCacheAdvert
//
//  Updates the neighbor cache in response to an advertisement.
//  If no matching entry is found, ignores the advertisement.
//  (See RFC 1970 section 7.2.5.)
//
//  Callable from DPC context, not from thread context.
//
void
NeighborCacheAdvert(
    Interface *IF,
    const IPv6Addr *TargetAddress,
    const void *LinkAddress,
    ulong Flags)
{
    NeighborCacheEntry *NCE;
    PNDIS_PACKET Packet = NULL;
    int PurgeRouting = FALSE;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);

    for (NCE = IF->FirstNCE; NCE != SentinelNCE(IF); NCE = NCE->Next) {
        if (IP6_ADDR_EQUAL(TargetAddress, &NCE->NeighborAddress)) {

            if (NCE->NDState != ND_STATE_PERMANENT) {
                //
                // Pick up link-level address from the advertisement,
                // if we don't have one yet or if override is set.
                //
                if ((LinkAddress != NULL) &&
                    ((NCE->NDState == ND_STATE_INCOMPLETE) ||
                     ((Flags & ND_NA_FLAG_OVERRIDE) &&
                      RtlCompareMemory(LinkAddress, NCE->LinkAddress,
                       IF->LinkAddressLength) != IF->LinkAddressLength))) {

                    RtlCopyMemory(NCE->LinkAddress, LinkAddress,
                                  IF->LinkAddressLength);

                    NCE->NSTimer = 0; // Cancel any outstanding timeout.
                    NCE->NDState = ND_STATE_STALE;

                    //
                    // Flush the queue of waiting packets.
                    //
                    if (NCE->WaitQueue != NULL) {

                        Packet = NCE->WaitQueue;
                        NCE->WaitQueue = NULL;

                        //
                        // Need to keep ref on NCE after we unlock.
                        //
                        AddRefNCEInCache(NCE);
                    }

                    goto AdvertisementMatchesCachedAddress;
                }

                if ((NCE->NDState != ND_STATE_INCOMPLETE) &&
                    ((LinkAddress == NULL) ||
                     RtlCompareMemory(LinkAddress, NCE->LinkAddress,
                      IF->LinkAddressLength) == IF->LinkAddressLength)) {
                    ushort WasRouter;

                AdvertisementMatchesCachedAddress:

                    //
                    // If this is a solicited advertisement
                    // for our cached link-layer address,
                    // then we have confirmed reachability.
                    //
                    if (Flags & ND_NA_FLAG_SOLICITED) {
                        NCE->NSTimer = 0;  // Cancel any outstanding timeout.
                        NCE->NSCount = 0;
                        NCE->LastReachability = IPv6TickCount; // Timestamp it.
                        NCE->NDState = ND_STATE_REACHABLE;

                        if (NCE->IsUnreachable) {
                            //
                            // We had previously concluded that this neighbor
                            // is unreachable. Now we know otherwise.
                            //
                            NCE->IsUnreachable = FALSE;
                            InvalidateRouteCache();
                        }
                    }

                    //
                    // If this is an advertisement
                    // for our cached link-layer address,
                    // then update IsRouter.
                    //
                    WasRouter = NCE->IsRouter;
                    NCE->IsRouter = ((Flags & ND_NA_FLAG_ROUTER) != 0);
                    if (WasRouter && !NCE->IsRouter) {
                        //
                        // This neighbor used to be a router, but is no longer.
                        //
                        PurgeRouting = TRUE;

                        //
                        // Need to keep ref on NCE after we unlock.
                        //
                        AddRefNCEInCache(NCE);
                    }
                }
                else {
                    //
                    // This is not an advertisement
                    // for our cached link-layer address.
                    // If the advertisement was unsolicited,
                    // give NUD a little nudge.
                    //
                    if (Flags & ND_NA_FLAG_SOLICITED) {
                        //
                        // This is probably a second NA in response
                        // to our multicast NS for an anycast address.
                        //
                    }
                    else {
                        if (NCE->NDState == ND_STATE_REACHABLE)
                            NCE->NDState = ND_STATE_STALE;
                    }
                }
            } // end if (NCE->NDState != ND_STATE_PERMANENT)

            //
            // Only one NCE should match.
            //
            break;
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);

    //
    // If we can now send a packet, do so.
    // (Without holding a lock.)
    //
    // It is possible that this neighbor is no longer a router,
    // and the waiting packet wants to use the neighbor as a router.
    // In this situation the ND spec requires that we still send
    // the waiting packet to the neighbor. Narten/Nordmark confirmed
    // this interpretation in private email.
    //
    if (Packet != NULL) {
        uint Offset = PC(Packet)->pc_offset;
        IPv6SendND(Packet, Offset, NCE, &(PC(Packet)->DiscoveryAddress));
        ReleaseNCE(NCE);
    }

    //
    // If need be, purge the routing data structures.
    //
    if (PurgeRouting) {
        InvalidateRouter(NCE);
        ReleaseNCE(NCE);
    }
}

//* NeighborCacheProbeUnreachability
//
//  Initiates an active probe of an unreachable neighbor,
//  to determine if the neighbor is still unreachable.
//
//  To prevent ourselves from probing too frequently,
//  the first probe is scheduled after waiting at least
//  UNREACH_SOLICIT_INTERVAL from when we last determined
//  this neighbor to be unreachable. If called again in this
//  interval, we do nothing.
//
//  Callable from DPC context (or with the route lock held),
//  not from thread context.
//
void
NeighborCacheProbeUnreachability(NeighborCacheEntry *NCE)
{
    Interface *IF = NCE->IF;
    uint Elapsed;
    ushort Delay;

    if (!(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS)) {
        //
        // We cannot probe on interfaces that do not support ND.
        //
        return;
    }
    
    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);
    if (!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED) && NCE->IsUnreachable) {
        //
        // Because the NCE is unreachable, we can not be in
        // the REACHABLE or PERMANENT states. The non-INCOMPLETE
        // states are possible if the NCE is unreachable/INCOMPLETE
        // and then we receive passive information in NeighborCacheUpdate.
        //
        ASSERT((NCE->NDState == ND_STATE_INCOMPLETE) ||
               (NCE->NDState == ND_STATE_PROBE) ||
               (NCE->NDState == ND_STATE_STALE));

        //
        // Calculate the appropriate delay until we can probe
        // unreachability. We do not want to determine unreachability
        // more frequently than UNREACH_SOLICIT_INTERVAL.
        //
        Elapsed = IPv6TickCount - NCE->LastReachability;
        if (Elapsed < UNREACH_SOLICIT_INTERVAL)
            Delay = (ushort) (UNREACH_SOLICIT_INTERVAL - Elapsed);
        else
            Delay = 1;

        //
        // If we are not already soliciting this neighbor,
        // probe the neighbor to check if it's still unreachable.
        //
        if (NCE->NDState == ND_STATE_STALE) {
            //
            // We need to be in the PROBE state to actively probe reachability.
            //
            NCE->NDState = ND_STATE_PROBE;
            ASSERT(NCE->NSTimer == 0);
            goto ProbeReachability;
        }
        else if ((NCE->NDState == ND_STATE_INCOMPLETE) &&
                 (NCE->NSTimer == 0)) {
        ProbeReachability:
            //
            // NeighborCacheEntryTimeout will send the first probe.
            //
            NCE->NSLimit = MAX_UNREACH_SOLICIT;
            NCE->NSTimer = Delay;
        }
        else {
            //
            // We are already in the PROBE or active INCOMPLETE states.
            // First, check NSLimit. It might be MAX_UNICAST_SOLICIT or
            // MAX_MULTICAST_SOLICIT. Ensure it's at least MAX_UNICAST_SOLICIT.
            //
            if (NCE->NSLimit < MAX_UNREACH_SOLICIT)
                NCE->NSLimit = MAX_UNREACH_SOLICIT;
            //
            // Second, if we have not started actively probing yet, ensure
            // we do not wait longer than Delay to start.
            //
            if ((NCE->NSCount == 0) && (NCE->NSTimer > Delay))
                NCE->NSTimer = Delay;
        }
    }
    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);
}

//* NeighborCacheReachabilityConfirmation
//
//  Updates the neighbor cache entry in response to an indication
//  of forward reachability. This indication is from an upper layer
//  (for example, receipt of a reply to a request).
//
//  Callable from thread or DPC context.
//
void
NeighborCacheReachabilityConfirmation(NeighborCacheEntry *NCE)
{
    Interface *IF = NCE->IF;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IF->LockNC, &OldIrql);

    switch (NCE->NDState) {
    case ND_STATE_INCOMPLETE:
        //
        // This is strange. Perhaps the reachability confirmation is
        // arriving very late and ND has already decided the neighbor
        // is unreachable? Or perhaps the upper-layer protocol is just
        // mistaken? In any case ignore the confirmation.
        //
        break;

    case ND_STATE_PROBE:
        //
        // Stop sending solicitations.
        //
        NCE->NSCount = 0;
        NCE->NSTimer = 0;
        // fall-through

    case ND_STATE_STALE:
        //
        // We have forward reachability.
        //
        NCE->NDState = ND_STATE_REACHABLE;

        if (NCE->IsUnreachable) {
            //
            // We can get here if an NCE is reachable but goes INCOMPLETE.
            // Then we later receive passive information and the state
            // changes to STALE. Then we receive upper-layer confirmation
            // that the neighbor is reachable again.
            //
            // We had previously concluded that this neighbor
            // is unreachable. Now we know otherwise.
            //
            NCE->IsUnreachable = FALSE;
            InvalidateRouteCache();
        }
        // fall-through

    case ND_STATE_REACHABLE:
        //
        // Timestamp this reachability confirmation.
        //
        NCE->LastReachability = IPv6TickCount;
        // fall-through

    case ND_STATE_PERMANENT:
        //
        // Ignore the confirmation.
        //
        ASSERT(! NCE->IsUnreachable);
        break;

    default:
        ABORTMSG("Invalid ND state?");
        break;
    }
    KeReleaseSpinLock(&IF->LockNC, OldIrql);
}

//* NeighborCacheReachabilityInDoubt
//
//  Updates the neighbor cache entry in response to an indication
//  from an upper-layer protocol that the neighbor may not be reachable.
//  (For example, a reply to a request was not received.)
//
//  Callable from thread or DPC context.
//
void
NeighborCacheReachabilityInDoubt(NeighborCacheEntry *NCE)
{
    Interface *IF = NCE->IF;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IF->LockNC, &OldIrql);

    if (NCE->NDState == ND_STATE_REACHABLE)
        NCE->NDState = ND_STATE_STALE;

    KeReleaseSpinLock(&IF->LockNC, OldIrql);
}

typedef struct NeighborCacheEntrySolicitInfo {
    struct NeighborCacheEntrySolicitInfo *Next;
    NeighborCacheEntry *NCE;            // Holds a reference.
    const IPv6Addr *DiscoveryAddress;   // NULL or points to AddrBuf.
    IPv6Addr AddrBuf;
} NeighborCacheEntrySolicitInfo;

//* NeighborCacheEntrySendSolicitHelper
//
//  Helper function for sending a solicit for an NCE
//  when NeighborSolicitSend can not be used.
//  Allocates an info structure (which holds an NCE reference)
//  and pushes the structure on the list.
//  The list holds information about deferred solicits.
//  Later the list is processed and solicitations sent.
//
//  Called with the neighbor cache lock held.
//  (So we are at DPC level.)
//
void
NeighborCacheEntrySendSolicitHelper(
    NeighborCacheEntry *NCE,
    NeighborCacheEntrySolicitInfo **pInfoList)
{
    NeighborCacheEntrySolicitInfo *Info;

    //
    // If this allocation fails we just skip this solicitation.
    //
    Info = ExAllocatePool(NonPagedPool, sizeof *Info);
    if (Info != NULL) {
        NDIS_PACKET *WaitPacket;

        AddRefNCEInCache(NCE);
        Info->NCE = NCE;

        //
        // If we have a packet waiting for address resolution,
        // then take the source address for the solicit
        // from the waiting packet.
        //
        WaitPacket = NCE->WaitQueue;
        if (WaitPacket != NULL) {
            Info->DiscoveryAddress = &Info->AddrBuf;
            Info->AddrBuf = PC(WaitPacket)->DiscoveryAddress;
        } else {
            Info->DiscoveryAddress = NULL;
        }

        Info->Next = *pInfoList;
        *pInfoList = Info;
    }
}

//* NeighborCacheEntryTimeout - handle an event timeout on an NCE.
//
//  NeighborCacheTimeout calls this routine when
//  an NCE's NSTimer expires.
//
//  Called with the neighbor cache lock held.
//  (So we are at DPC level.)
//
//  We can not call NeighborSolicitSend or IPv6SendAbort
//  directly, because we hold the neighbor cache lock.
//  For NeighborSolicitSend we use NeighborCacheEntrySendSolicitHelper
//  to defer the solicit until later, and for IPv6SendAbort
//  we push the packet on the interface's PacketList and
//  NeighborCacheCompletePackets handles it later.
//  However we make all the NCE state transitions directly here,
//  so they will happen in a timely fashion.
//
//  NB: We do not want to punt NeighborSolicitSend to a worker thread,
//  because DPC activity preempts worker threads. Prolonged activity
//  at DPC level (for example a DoS attack) would prevent solicits
//  from being sent, and more importantly, would prevent NCEs from
//  being recycled because the work items would hold NCE references.
//
void
NeighborCacheEntryTimeout(
    NeighborCacheEntry *NCE,
    NeighborCacheEntrySolicitInfo **pInfoList)
{
    Interface *IF = NCE->IF;
    NDIS_PACKET *Packet;
    NDIS_STATUS Status;

    //
    // Neighbor Discovery has timeouts for initial neighbor
    // solicitation retransmissions, the delay state, and probe
    // neighbor solicitation retransmissions.  All of these share
    // the same NSTimer, and are distinguished from each other
    // by the NDState.
    //
    switch (NCE->NDState) {
    case ND_STATE_INCOMPLETE:
        //
        // Retransmission timer expired.  Check to see if
        // sending another solicit would exceed the maximum.
        //
        if (NCE->NSCount >= NCE->NSLimit) {
            //
            // Failed to initiate connectivity to neighbor.
            // Reset to dormant INCOMPLETE state.
            //
            NCE->NSCount = 0;
            if (NCE->WaitQueue != NULL) {
                //
                // Remove the waiting packet from the NCE
                // and let NeighborCacheTimeout handle it.
                // We can't call IPv6SendAbort directly
                // because we hold the neighbor cache lock.
                //
                Packet = NCE->WaitQueue;
                NCE->WaitQueue = NULL;
                PC(Packet)->pc_drop = FALSE;
                PC(Packet)->pc_link = IF->PacketList;
                IF->PacketList = Packet;
            }

            //
            // This neighbor is not reachable.
            // IsUnreachable may already be TRUE.
            // But we need to give FindNextHop an opportunity to round-robin.
            //
            NCE->IsUnreachable = TRUE;
            NCE->LastReachability = IPv6TickCount; // Timestamp it.
            NCE->DoRoundRobin = TRUE;
            InvalidateRouteCache();
        }
        else {
            //
            // Retransmit initial solicit, taking source address
            // from the waiting packet.
            //
            NCE->NSCount++;
            NeighborCacheEntrySendSolicitHelper(NCE, pInfoList);

            //
            // Re-arm timer for the next solicitation.
            //
            NCE->NSTimer = (ushort)IF->RetransTimer;
        }
        break;

    case ND_STATE_PROBE:
        //
        // Retransmission timer expired.  Check to see if
        // sending another solicit would exceed the maximum.
        //
        if (NCE->NSCount >= NCE->NSLimit) {
            //
            // Failed to initiate connectivity to neighbor.
            // Reset to dormant INCOMPLETE state.
            //
            NCE->NDState = ND_STATE_INCOMPLETE;
            NCE->NSCount = 0;

            //
            // This neighbor is not reachable.
            // IsUnreachable may already be TRUE.
            // But we need to give FindNextHop an opportunity to round-robin.
            //
            NCE->IsUnreachable = TRUE;
            NCE->LastReachability = IPv6TickCount; // Timestamp it.
            NCE->DoRoundRobin = TRUE;
            InvalidateRouteCache();
        }
        else {
            //
            // Retransmit probe solicitation. We can not call
            // NeighborSolicitSend directly because we have
            // the neighbor cache locked, so punt to a worker thread.
            //
            NCE->NSCount++;
            NeighborCacheEntrySendSolicitHelper(NCE, pInfoList);

            //
            // Re-arm timer for the next solicitation.
            //
            NCE->NSTimer = (ushort)IF->RetransTimer;
        }

        // Fall-through to check for a waiting packet.

    default:
        //
        // In rare cases (eg, see NeighborCacheInitialize)
        // we can have a waiting packet when the state is not INCOMPLETE.
        //
        if (NCE->WaitQueue != NULL) {
            LARGE_INTEGER Immediately;

            Packet = NCE->WaitQueue;
            NCE->WaitQueue = NULL;

            //
            // We use IPv6SendLater because we hold the neighbor cache lock.
            //
            Immediately.QuadPart = 0;
            Status = IPv6SendLater(Immediately, // Send asap.
                                   IF, Packet, PC(Packet)->pc_offset,
                                   NCE->LinkAddress);
            if (Status != NDIS_STATUS_SUCCESS) {
                //
                // We can't complete the packet here,
                // because we hold the neighbor cache lock.
                // So let NeighborCacheTimeout complete it.
                //
                PC(Packet)->pc_drop = TRUE;
                PC(Packet)->pc_link = IF->PacketList;
                IF->PacketList = Packet;
            }
        }
        break;
    }
}

//* NeighborCacheTimeout
//
//  Called periodically from IPv6Timeout/InterfaceTimeout
//  to handle timeouts in the interface's neighbor cache.
//
//  Callable from DPC context, not from thread context.
//
//  Note that NeighborCacheTimeout performs an unbounded
//  (more precisely - bounded by the size of the cache)
//  amount of work while holding the neighbor cache lock.
//  (It does not however send packets.)
//
//  One possible strategy that would help, if this is a problem,
//  would be to have a second singly-linked list of NCEs
//  that require action.  With one traversal we reference NCEs
//  and create the action list.  Then we could traverse the action
//  list at our leisure, taking/dropping the neighbor cache lock.
//
//  On the other hand, this is all moot on a uniprocessor
//  because our locks are spinlocks and we are already at DPC level.
//  That is, on a uniprocessor KeAcquireSpinLockAtDpcLevel is a no-op.
//
void
NeighborCacheTimeout(Interface *IF)
{
    NeighborCacheEntrySolicitInfo *InfoList = NULL;
    NeighborCacheEntrySolicitInfo *Info;
    NDIS_PACKET *PacketList;
    NeighborCacheEntry *NCE;

    KeAcquireSpinLockAtDpcLevel(&IF->LockNC);
    for (NCE = IF->FirstNCE; NCE != SentinelNCE(IF); NCE = NCE->Next) {
#if DBG
        //
        // If there is packet waiting, we must be doing something.
        //
        ASSERT((NCE->WaitQueue == NULL) || (NCE->NSTimer != 0));

        //
        // If we are sending solicitations, we must have a timer running.
        //
        ASSERT((NCE->NSCount == 0) || (NCE->NSTimer != 0));

        //
        // If the neighbor is unreachable, the interface must support ND or
        // the neighbor must be in the INCOMPLETE state.
        //
        ASSERT(! NCE->IsUnreachable ||
               ((IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) ||
                (NCE->NDState == ND_STATE_INCOMPLETE)));

        switch (NCE->NDState) {
        case ND_STATE_INCOMPLETE:
            //
            // In the INCOMPLETE state, we can either be passive
            // (no timer running, not sending solicitations)
            // or active (timer running, sending solicitations).
            //
            ASSERT((NCE->NSTimer == 0) ||
                   ((NCE->NSLimit == MAX_MULTICAST_SOLICIT) ||
                    (NCE->NSLimit == MAX_UNREACH_SOLICIT)));
            break;

        case ND_STATE_PROBE:
            //
            // In the PROBE state, we are actively sending solicitations.
            //
            ASSERT((NCE->NSTimer != 0) &&
                   ((NCE->NSLimit == MAX_UNICAST_SOLICIT) ||
                    (NCE->NSLimit == MAX_UNREACH_SOLICIT)));
            break;

        case ND_STATE_REACHABLE:
        case ND_STATE_PERMANENT:
            //
            // In the REACHABLE and PERMANENT states.
            // the neighbor can not be considered unreachable.
            //
            ASSERT(! NCE->IsUnreachable);
            // fall-through

        case ND_STATE_STALE:
            //
            // In the STALE, REACHABLE, and PERMANENT states,
            // we are not sending solicitations and there is no timer running,
            // unless there is a packet waiting.
            //
            ASSERT((NCE->NSCount == 0) &&
                   ((NCE->NSTimer == 0) ||
                    ((NCE->WaitQueue != NULL) && (NCE->NSTimer == 1))));
            break;

        default:
            ABORTMSG("bad ND state");
        }
#endif // DBG

        if (NCE->NSTimer != 0) {
            //
            // Timer is running.  Decrement and check for expiration.
            //
            if (--NCE->NSTimer == 0) {
                //
                // Timer went off. NeighborCacheEntryTimeout may add
                // items to our packet list and info list.
                //
                NeighborCacheEntryTimeout(NCE, &InfoList);
            }
        }
    }

    PacketList = IF->PacketList;
    IF->PacketList = NULL;
    KeReleaseSpinLockFromDpcLevel(&IF->LockNC);

    //
    // Now that we've unlocked, send neighbor solicitations.
    //
    while ((Info = InfoList) != NULL) {
        InfoList = Info->Next;
        NeighborSolicitSend(Info->NCE, Info->DiscoveryAddress);
        ReleaseNCE(Info->NCE);
        ExFreePool(Info);
    }

    //
    // And complete the packets that we will not be sending.
    //
    NeighborCacheCompletePackets(IF, PacketList);
}


//* NeighborCacheFlush
//
//  Flushes unused neighbor cache entries.
//  If an address is supplied, flushes the NCE (at most one) for that address.
//  Otherwise, flushes all unused NCEs on the interface.
//
//  May be called with the interface lock held.
//  Callable from thread or DPC context.
//
void
NeighborCacheFlush(Interface *IF, const IPv6Addr *Addr)
{
    NeighborCacheEntry *Delete = NULL;
    NeighborCacheEntry *NCE, *NextNCE;
    KIRQL OldIrql;

    KeAcquireSpinLock(&IF->LockNC, &OldIrql);
    for (NCE = IF->FirstNCE; NCE != SentinelNCE(IF); NCE = NextNCE) {

        NextNCE = NCE->Next;
        if (Addr == NULL)
            ; // Examine this NCE then keep looking.
        else if (IP6_ADDR_EQUAL(Addr, &NCE->NeighborAddress))
            NextNCE = SentinelNCE(IF); // Can terminate loop after this NCE.
        else
            continue; // Skip this NCE.

        //
        // Can we flush this NCE?
        //
        if ((NCE->RefCnt == 0) &&
            (NCE->WaitQueue == NULL)) {
            //
            // Just need to unlink it.
            //
            NCE->Next->Prev = NCE->Prev;
            NCE->Prev->Next = NCE->Next;
            InterlockedDecrement((long *)&IF->NCENumUnused);

            //
            // And put it on our Delete list.
            //
            NCE->Next = Delete;
            Delete = NCE;
        }
        else {
            if (NCE->NDState != ND_STATE_PERMANENT) {
                //
                // Forget everything that we know about this NCE.
                //
                NeighborCacheInitialize(IF, NCE, ND_STATE_INCOMPLETE, NULL);
            }
        }
    }
    KeReleaseSpinLock(&IF->LockNC, OldIrql);

    //
    // We may have changed state that affects routing.
    //
    InvalidateRouteCache();

    //
    // Finish by actually deleting the flushed NCEs.
    //
    while (Delete != NULL) {
        NCE = Delete;
        Delete = NCE->Next;
        ExFreePool(NCE);
    }
}


//* RouterSolicitReceive - Handle Router Solicitation messages.
//
//  See section 6.2.6 of the ND spec.
//
void
RouterSolicitReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP header.
{
    Interface *IF = Packet->NTEorIF->IF;
    const void *SourceLinkAddress;

    //
    // Ignore the solicitation unless this is an advertising interface.
    //
    if (!(IF->Flags & IF_FLAG_ADVERTISES))
        return;

    //
    // Validate the solicitation.
    // By the time we get here, any IPv6 Authentication Header will have
    // already been checked, as will have the ICMPv6 checksum.  Still need
    // to check the length, source address, hop limit, and ICMP code.
    //
    if ((Packet->IP->HopLimit != 255) ||
        (Packet->Flags & PACKET_TUNNELED)) {
        //
        // Packet was forwarded by a router, therefore it cannot be
        // from a legitimate neighbor.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterSolicitReceive: "
                   "Received a routed router solicitation\n"));
        return;
    }
    if (ICMP->Code != 0) {
        //
        // Bogus/corrupted router solicitation.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterSolicitReceive: "
                   "Received a corrupted router solicitation\n"));
        return;
    }

    //
    // We should have a 4-byte reserved field.
    //
    if (Packet->TotalSize < 4) {
        //
        // Packet too short to contain minimal solicitation.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterSolicitReceive: "
                   "Received a too short solicitation\n"));
        return;
    }

    //
    // The code below assumes a contiguous buffer for all the options
    // (the remainder of the packet).  If that isn't currently the
    // case, do a pullup for the whole thing.
    //
    if (! PacketPullup(Packet, Packet->TotalSize, 1, 0)) {
        // Can only fail if we run out of memory.
        return;
    }

    ASSERT(Packet->ContigSize == Packet->TotalSize);

    //
    // Skip over 4 byte "Reserved" field, ignoring whatever may be in it.
    //
    AdjustPacketParams(Packet, 4);

    //
    // We may have a source link-layer address option present.
    // Check for it and silently ignore all others.
    //
    SourceLinkAddress = NULL;
    while (Packet->ContigSize) {
        uint OptionLength;

        //
        // Validate the option length.
        //
        if ((Packet->ContigSize < 8) ||
            ((OptionLength = *((uchar *)Packet->Data + 1) << 3) == 0) ||
            (OptionLength > Packet->ContigSize)) {
            //
            // Invalid option length.  We MUST silently drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RouterSolicitReceive: "
                       "Received option with bogus length\n"));
            return;
        }

        if (*((uchar *)Packet->Data) == ND_OPTION_SOURCE_LINK_LAYER_ADDRESS) {
            //
            // Some interfaces do not use SLLA and TLLA options.
            // For example, see RFC 2893 section 3.8.
            //
            if (IF->ReadLLOpt != NULL) {
                //
                // Parse the link-layer address option.
                //
                SourceLinkAddress = (*IF->ReadLLOpt)(IF->LinkContext,
                                                     (uchar *)Packet->Data);
                if (SourceLinkAddress == NULL) {
                    //
                    // Invalid option format. Drop the packet.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "RouterSolicitReceive: "
                               "Received bogus ll option\n"));
                    return;
                }
            }
            //
            // Note that if there are multiple options for some bogus reason,
            // we use the last one. We must sanity-check all option lengths.
            //
        }

        //
        // Move forward to next option.
        //
        AdjustPacketParams(Packet, OptionLength);
    }

    //
    // We've received and parsed a valid router solicitation.
    //

    if (IsUnspecified(AlignAddr(&Packet->IP->Source))) {
        //
        // This is a new check, introduced post-RFC 1970.
        //
        if (SourceLinkAddress != NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RouterSolicitReceive: "
                       "Received SLA with unspecified Source?\n"));
            return;
        }
    }
    else {
        //
        // Only bother with this if SourceLinkAddress is present;
        // if it's not, NeighborCacheUpdate won't do anything.
        //
        if (SourceLinkAddress != NULL) {
            NeighborCacheEntry *NCE;
            //
            // Get the Neighbor Cache Entry for the source of this RS.
            //
            NCE = FindOrCreateNeighbor(IF, AlignAddr(&Packet->IP->Source));
            if (NCE != NULL) {
                //
                // Update the Neighbor Cache Entry for the source of this RS.
                //
                // REVIEW: We deviate from the spec here. The spec says
                // that if you receive an RS from a Source, then you MUST
                // set the IsRouter flag for that Source to FALSE.
                // However consider a node which is not advertising
                // but it is forwarding. Such a node might send an RS
                // but IsRouter should be TRUE for that node.
                //
                NeighborCacheUpdate(NCE, SourceLinkAddress, FALSE);
                ReleaseNCE(NCE);
            }
        }
    }

    if (!(IF->Flags & IF_FLAG_MULTICAST)) {
        NetTableEntry *NTE;
        int GotSource;
        IPv6Addr Source;

        //
        // What source address should we use for the RA?
        //
        if (IsNTE(Packet->NTEorIF) &&
            ((NTE = CastToNTE(Packet->NTEorIF))->Scope == ADE_LINK_LOCAL)) {
            //
            // The RS was received on a link-local NTE, so use that address.
            // IPv6HeaderReceive checks that the NTE is valid.
            //
            Source = NTE->Address;
            GotSource = TRUE;
        }
        else {
            //
            // Try to get a valid link-local address.
            //
            GotSource = GetLinkLocalAddress(IF, &Source);
        }

        if (GotSource) {
            //
            // The interface doesn't support multicast, so instead,
            // immediately send a unicast reply.  This allows router
            // discovery to work on NBMA interfaces such as for ISATAP.
            //
            RouterAdvertSend(IF, &Source, AlignAddr(&Packet->IP->Source));
        }
    }
    else {
        //
        // Send a Router Advertisement very soon.
        // The randomization in IPv6Timeout initialization
        // provides the randomization required when sending
        // a RA in response to an RS.
        // NB: Although we checked IF_FLAG_ADVERTISES above,
        // the situation could be different now.
        //
        KeAcquireSpinLockAtDpcLevel(&IF->Lock);
        if (IF->RATimer != 0) {
            //
            // If MAX_RA_DELAY_TIME is not 1, then should use
            // RandomNumber to generate the number of ticks.
            //
            C_ASSERT(MAX_RA_DELAY_TIME == 1);
            IF->RATimer = 1;
        }
        KeReleaseSpinLockFromDpcLevel(&IF->Lock);
    }
}


//* RouterAdvertReceive - Handle Router Advertisement messages.
//
//  Validate message, update Default Router list, On-Link Prefix list,
//  perform address auto-configuration.
//  See sections 6.1.2, 6.3.4 of RFC 2461.
//
void
RouterAdvertReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP header.
{
    Interface *IF = Packet->NTEorIF->IF;
    uint CurHopLimit, RouterLifetime, MinLifetime;
    uchar Flags;
    uint AdvReachableTime, RetransTimer;
    const void *SourceLinkAddress;
    NeighborCacheEntry *NCE;
    NDRouterAdvertisement UNALIGNED *RA;

    //
    // Ignore the advertisement if this is an advertising interface.
    //
    if (IF->Flags & IF_FLAG_ADVERTISES)
        return;

    //
    // Validate the advertisement.
    // By the time we get here, any IPv6 Authentication Header will have
    // already been checked, as will have the ICMPv6 checksum.  Still need
    // to check the length, source address, hop limit, and ICMP code.
    //
    if ((Packet->IP->HopLimit != 255) ||
        (Packet->Flags & PACKET_TUNNELED)) {
        //
        // Packet was forwarded by a router, therefore it cannot be
        // from a legitimate neighbor.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterAdvertReceive: "
                   "Received a routed router advertisement\n"));
        return;
    }
    if (ICMP->Code != 0) {
        //
        // Bogus/corrupted router advertisement.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterAdvertReceive: "
                   "Received a corrupted router advertisement\n"));
        return;
    }
    if (!IsLinkLocal(AlignAddr(&Packet->IP->Source))) {
        //
        // Source address should always be link-local. Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RouterAdvertReceive: "
                   "Non-link-local source in router advertisement\n"));
        return;
    }

    //
    // Pull CurHopLimit, Flags, RouterLifetime,
    // AdvReachableTime, RetransTimer out of the packet.
    //
    if (! PacketPullup(Packet, sizeof *RA, 1, 0)) {
        if (Packet->TotalSize < sizeof *RA) {
            //
            // Packet too short to contain minimal RA.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RouterAdvertReceive: "
                       "Received a too short router advertisement\n"));
        }
        return;
    }

    RA = (NDRouterAdvertisement UNALIGNED *) Packet->Data;
    CurHopLimit = RA->CurHopLimit;
    Flags = RA->Flags;
    RouterLifetime = net_short(RA->RouterLifetime);
    AdvReachableTime = net_long(RA->ReachableTime);
    RetransTimer = net_long(RA->RetransTimer);
    AdjustPacketParams(Packet, sizeof *RA);

    //
    // The code below assumes a contiguous buffer for all the options
    // (the remainder of the packet).  If that isn't currently the
    // case, do a pullup for the whole thing. We need alignment for
    // IPv6Addr because of the options that we look at.
    //
    if (! PacketPullup(Packet, Packet->TotalSize,
                       __builtin_alignof(IPv6Addr), 0)) {
        // Can only fail if we run out of memory.
        return;
    }

    ASSERT(Packet->ContigSize == Packet->TotalSize);

    //
    // Look for a source link-layer address option.
    // Also sanity-check the options before doing anything permanent.
    //
    SourceLinkAddress = NULL;
    while (Packet->ContigSize) {
        uint OptionLength;

        //
        // Validate the option length.
        //
        if ((Packet->ContigSize < 8) ||
            ((OptionLength = *((uchar *)Packet->Data + 1) << 3) == 0) ||
            (OptionLength > Packet->ContigSize)) {
            //
            // Invalid option length.  We MUST silently drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RouterAdvertReceive: "
                       "Received RA option with with bogus length\n"));
            return;
        }

        switch (*(uchar *)Packet->Data) {
        case ND_OPTION_SOURCE_LINK_LAYER_ADDRESS:
            //
            // Some interfaces do not use SLLA and TLLA options.
            // For example, see RFC 2893 section 3.8.
            //
            if (IF->ReadLLOpt != NULL) {
                //
                // Parse the link-layer address option.
                //
                SourceLinkAddress = (*IF->ReadLLOpt)(IF->LinkContext,
                                                     (uchar *)Packet->Data);
                if (SourceLinkAddress == NULL) {
                    //
                    // Invalid option format.  Drop the packet.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "RouterAdvertReceive: "
                               "Received RA with bogus ll option\n"));
                    return;
                }
                //
                // Note that if there are multiple options for some bogus 
                // reason, we use the last one.  We sanity-check all the 
                // options.
                //
            }
            break;

        case ND_OPTION_MTU:
            //
            // Sanity-check the option.
            //
            if (OptionLength != 8) {
                //
                // Invalid option format.  Drop the packet.
                //
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "RouterAdvertReceive: "
                           "Received RA with bogus mtu option\n"));
                return;
            }
            break;

        case ND_OPTION_PREFIX_INFORMATION: {
            NDOptionPrefixInformation UNALIGNED *option =
                (NDOptionPrefixInformation *)Packet->Data;

            //
            // Sanity-check the option.
            //
            if ((OptionLength != 32) ||
                (option->PrefixLength > IPV6_ADDRESS_LENGTH)) {
                //
                // Invalid option format.  Drop the packet.
                //
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "RouterAdvertReceive: "
                           "Received RA with bogus prefix option\n"));
                return;
            }
            break;
        }

        case ND_OPTION_ROUTE_INFORMATION: {
            NDOptionRouteInformation UNALIGNED *option =
                (NDOptionRouteInformation *)Packet->Data;

            //
            // Sanity-check the option.
            // Depending on PrefixLength, the option may be 8, 16, 24 bytes.
            // At this point, we know it is a multiple of 8 greater than zero.
            //
            if ((OptionLength > 24) ||
                (option->PrefixLength > IPV6_ADDRESS_LENGTH) ||
                ((option->PrefixLength > 64) && (OptionLength < 24)) ||
                ((option->PrefixLength > 0) && (OptionLength < 16))) {
                //
                // Invalid option format.  Drop the packet.
                //
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "RouterAdvertReceive: "
                           "Received RA with bogus route option\n"));
                return;
            }
            break;
        }
        }

        //
        // Move forward to next option.
        // Note that we are not updating TotalSize here,
        // so we can use it below to back up.
        //
        (uchar *)Packet->Data += OptionLength;
        Packet->ContigSize -= OptionLength;
    }

    //
    // Reset Data pointer & ContigSize.
    //
    (uchar *)Packet->Data -= Packet->TotalSize;
    Packet->ContigSize += Packet->TotalSize;

    //
    // Get the Neighbor Cache Entry for the source of this RA.
    //
    NCE = FindOrCreateNeighbor(IF, AlignAddr(&Packet->IP->Source));
    if (NCE == NULL) {
        //
        // Couldn't find or create NCE.  Drop the packet.
        //
        return;
    }

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    //
    // Cache the parity of the "other stateful config" flag.
    //
    if (Flags & ND_RA_FLAG_OTHER) {
        IF->Flags |= IF_FLAG_OTHER_STATEFUL_CONFIG;
    } else {
        IF->Flags &= ~IF_FLAG_OTHER_STATEFUL_CONFIG;
    }

    //
    // If we just reconnected this interface,
    // then give all state learned from auto-configuration
    // a small "accelerated" lifetime.
    // The processing below might extend accelerated lifetimes.
    //
    if (IF->Flags & IF_FLAG_MEDIA_RECONNECTED) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "RouterAdvertReceive(IF %p) - reconnecting\n", IF));

        IF->Flags &= ~IF_FLAG_MEDIA_RECONNECTED;

        //
        // Reset auto-configured address lifetimes.
        //
        AddrConfResetAutoConfig(IF,
                2 * MAX_RA_DELAY_TIME + MIN_DELAY_BETWEEN_RAS);

        //
        // Similarly, reset auto-configured routes.
        //
        RouteTableResetAutoConfig(IF,
                2 * MAX_RA_DELAY_TIME + MIN_DELAY_BETWEEN_RAS);

        //
        // Reset parameters that are learned from RAs.
        //
        InterfaceResetAutoConfig(IF);
    }

    //
    // A host MUST stop sending router solicitations for an interface upon
    // receiving a valid router advertisement with a non-zero router lifetime.
    // We go a step further and, on a non-multicast interface, stop after the
    // first valid response - presumably that's all we are going to receive.
    // Note that we should always send at least one router solicitation,
    // even if we receive an unsolicited router advertisement first.
    //
    if ((RouterLifetime != 0) || !(IF->Flags & IF_FLAG_MULTICAST)) {
        if (IF->RSCount > 0)
            IF->RSTimer = 0;
    }

    //
    // Update the BaseReachableTime and ReachableTime.
    // NB: We use a lock for coordinated updates, but other code
    // reads the ReachableTime field without a lock.
    //
    if ((AdvReachableTime != 0) &&
        (AdvReachableTime != IF->BaseReachableTime)) {

        IF->BaseReachableTime = AdvReachableTime;
        IF->ReachableTime = CalcReachableTime(AdvReachableTime);
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    //
    // Update the Neighbor Cache Entry for the source of this RA.
    //
    NeighborCacheUpdate(NCE, SourceLinkAddress, TRUE);

    //
    // Update the Default Router List.
    // Note that router lifetimes on the wire,
    // unlike prefix lifetimes, can not be infinite.
    //
    ASSERT(RouterLifetime != INFINITE_LIFETIME); // Because it's 16 bits.
    MinLifetime = RouterLifetime = ConvertSecondsToTicks(RouterLifetime);

    RouteTableUpdate(NULL, // System update.
                     IF, NCE,
                     &UnspecifiedAddr, 0, 0,
                     RouterLifetime, RouterLifetime,
                     ExtractRoutePreference(Flags),
                     RTE_TYPE_AUTOCONF,
                     FALSE, FALSE);

    //
    // Update the hop limit for the interface.
    // NB: We rely on loads/stores of the CurHopLimit field being atomic.
    //
    if (CurHopLimit != 0) {
        IF->CurHopLimit = CurHopLimit;
    }

    //
    // Update the RetransTimer field.
    // NB: We rely on loads/stores of this field being atomic.
    //
    if (RetransTimer != 0)
        IF->RetransTimer = ConvertMillisToTicks(RetransTimer);

    //
    // Process any LinkMTU, PrefixInformation options.
    //

    while (Packet->ContigSize) {
        uint OptionLength;

        //
        // The option length was validated in the first pass
        // over the options, above.
        //
        OptionLength = *((uchar *)Packet->Data + 1) << 3;

        switch (*(uchar *)Packet->Data) {
        case ND_OPTION_MTU: {
            NDOptionMTU UNALIGNED *option =
                (NDOptionMTU UNALIGNED *)Packet->Data;
            uint LinkMTU = net_long(option->MTU);

            if ((IPv6_MINIMUM_MTU <= LinkMTU) &&
                (LinkMTU <= IF->TrueLinkMTU))
                UpdateLinkMTU(IF, LinkMTU);
            break;
        }

        case ND_OPTION_PREFIX_INFORMATION: {
            NDOptionPrefixInformation UNALIGNED *option =
                (NDOptionPrefixInformation UNALIGNED *)Packet->Data;
            uint PrefixLength, ValidLifetime, PreferredLifetime;
            IPv6Addr Prefix;

            //
            // Extract the prefix length and prefix from option.  We
            // MUST ignore any bits in the prefix after the prefix length.
            // RouteTableUpdate and SitePrefixUpdate do that also,
            // but we look at the prefix directly here.
            //
            PrefixLength = option->PrefixLength;  // In bits.
            CopyPrefix(&Prefix, AlignAddr(&option->Prefix), PrefixLength);

            ValidLifetime = net_long(option->ValidLifetime);
            ValidLifetime = ConvertSecondsToTicks(ValidLifetime);
            PreferredLifetime = net_long(option->PreferredLifetime);
            PreferredLifetime = ConvertSecondsToTicks(PreferredLifetime);
            if (MinLifetime > PreferredLifetime)
                MinLifetime = PreferredLifetime; 

            //
            // Silently ignore link-local and multicast prefixes.
            // REVIEW - Is this actually the required check?
            //
            if (IsLinkLocal(&Prefix) || IsMulticast(&Prefix))
                break;

            //
            // Generally at least one flag bit is set,
            // but we must process them independently.
            //

            if (option->Flags & ND_PREFIX_FLAG_ON_LINK)
                RouteTableUpdate(NULL, // System update.
                                 IF, NULL,
                                 &Prefix, PrefixLength, 0,
                                 ValidLifetime, ValidLifetime,
                                 ROUTE_PREF_ON_LINK,
                                 RTE_TYPE_AUTOCONF,
                                 FALSE, FALSE);

            if (option->Flags & ND_PREFIX_FLAG_ROUTE)
                RouteTableUpdate(NULL, // System update.
                                 IF, NCE,
                                 &Prefix, PrefixLength, 0,
                                 ValidLifetime, ValidLifetime,
                                 ROUTE_PREF_MEDIUM,
                                 RTE_TYPE_AUTOCONF,
                                 FALSE, FALSE);

            //
            // We ignore site-local prefixes here. Above check
            // filters out link-local and multicast prefixes.
            //
            if (! IsSiteLocal(&Prefix)) {
                uint SitePrefixLength;

                //
                // If the S bit is clear, then we check the A bit
                // and use the interface's default site prefix length.
                // This lets us infer site prefixes when routers
                // do not support the S bit.
                //
                if (option->Flags & ND_PREFIX_FLAG_SITE_PREFIX)
                    SitePrefixLength = option->SitePrefixLength;
                else if (option->Flags & ND_PREFIX_FLAG_AUTONOMOUS)
                    SitePrefixLength = IF->DefSitePrefixLength;
                else
                    SitePrefixLength = 0;

                //
                // Ignore if the Site Prefix Length is zero.
                //
                if (SitePrefixLength != 0)
                    SitePrefixUpdate(IF,
                                     &Prefix, SitePrefixLength,
                                     ValidLifetime);
            }

            if (option->Flags & ND_PREFIX_FLAG_AUTONOMOUS) {
                //
                // Attempt autonomous address-configuration.
                //
                if (PreferredLifetime > ValidLifetime) {
                    //
                    // MAY log a system management error.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "RouterAdvertReceive: "
                               "Bogus valid/preferred lifetimes\n"));
                }
                else if ((PrefixLength + IPV6_ID_LENGTH) !=
                                                IPV6_ADDRESS_LENGTH) {
                    //
                    // If the sum of the prefix length and the interface
                    // identifier (always 64 bits in our implementation)
                    // is not 128 bits, we MUST ignore the prefix option.
                    // MAY log a system management error.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "RouterAdvertReceive: Got prefix length of %u, "
                               "must be 64 for auto-config\n", PrefixLength));
                }
                else if (IF->CreateToken != NULL) {
                    AddrConfUpdate(IF, &Prefix,
                                   ValidLifetime, PreferredLifetime,
                                   FALSE, // Not authenticated.
                                   NULL); // Do not return NTE.
                }
            }
            break;
        }

        case ND_OPTION_ROUTE_INFORMATION: {
            NDOptionRouteInformation UNALIGNED *option =
                (NDOptionRouteInformation UNALIGNED *)Packet->Data;
            uint PrefixLength, RouteLifetime;
            IPv6Addr *Prefix;

            //
            // Extract the prefix length and prefix from option.  We
            // MUST ignore any bits in the prefix after the prefix length.
            // RouteTableUpdate does that for us.
            //
            PrefixLength = option->PrefixLength;  // In bits.
            Prefix = AlignAddr(&option->Prefix);

            RouteLifetime = net_long(option->RouteLifetime);
            RouteLifetime = ConvertSecondsToTicks(RouteLifetime);
            if (MinLifetime > RouteLifetime)
                MinLifetime = RouteLifetime;

            RouteTableUpdate(NULL, // System update.
                             IF, NCE,
                             Prefix, PrefixLength, 0,
                             RouteLifetime, RouteLifetime,
                             ExtractRoutePreference(option->Flags),
                             RTE_TYPE_AUTOCONF,
                             FALSE, FALSE);
            break;
        }
        }

        //
        // Move forward to next option.
        //
        AdjustPacketParams(Packet, OptionLength);
    }

    if (!(IF->Flags & IF_FLAG_MULTICAST) && (IF->RSTimer == 0)) {
        //
        // On non-multicast interfaces such as the ISATAP interface,
        // we need to send periodic Router Solicitations.  We want
        // to do so as infrequently as possible and still be reasonably
        // robust.  We'll try to refresh it halfway through the lowest
        // lifetime in the RA we saw.  However, if a renumbering event
        // is going on, and a lifetime is low, we don't want to send
        // too often, so we put on a minimum cap equal to what we'd
        // use if we never got an RA.
        //
        if (MinLifetime < SLOW_RTR_SOLICITATION_INTERVAL * 2)
            IF->RSTimer = SLOW_RTR_SOLICITATION_INTERVAL;
        else
            IF->RSTimer = MinLifetime / 2;
        IF->RSCount = MAX_RTR_SOLICITATIONS;
    }

    //
    // Done with packet.
    //
    ReleaseNCE(NCE);
}


//* NeighborSolicitReceive - Handle Neighbor Solicitation messages.
//
//  Validate message, update ND cache, and reply with Neighbor Advertisement.
//  See section 7.2.4 of RFC 1970.
//
void
NeighborSolicitReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP header.
{
    Interface *IF = Packet->NTEorIF->IF;
    const IPv6Addr *TargetAddress;
    const void *SourceLinkAddress;
    NDIS_STATUS Status;
    NDIS_PACKET *AdvertPacket;
    uint Offset;
    uint PayloadLength;
    void *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *AdvertIP;
    ICMPv6Header UNALIGNED *AdvertICMP;
    ulong Flags;
    void *AdvertTargetOption;
    IPv6Addr *AdvertTargetAddress;
    void *DestLinkAddress;
    NetTableEntryOrInterface *TargetNTEorIF;
    ushort TargetType;

    //
    // Validate the solicitation.
    // By the time we get here, any IPv6 Authentication Header will have
    // already been checked, as will have the ICMPv6 checksum.  Still need
    // to check the IP Hop Limit, and the ICMP code and length.
    //
    if ((Packet->IP->HopLimit != 255) ||
        (Packet->Flags & PACKET_TUNNELED)) {
        //
        // Packet was forwarded by a router, therefore it cannot be
        // from a legitimate neighbor.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborSolicitReceive: "
                   "Received a routed neighbor solicitation\n"));
        return;
    }
    if (ICMP->Code != 0) {
        //
        // Bogus/corrupted neighbor solicitation message.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborSolicitReceive: "
                   "Received a corrupted neighbor solicitation\n"));
        return;
    }

    //
    // Next we have a 4 byte reserved field, then an IPv6 address.
    //
    if (! PacketPullup(Packet, 4 + sizeof(IPv6Addr),
                       __builtin_alignof(IPv6Addr), 0)) {
        if (Packet->TotalSize < 4 + sizeof(IPv6Addr)) {
            //
            // Packet too short to contain minimal solicitation.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborSolicitReceive: "
                       "Received a too short solicitation\n"));
        }
        return;
    }

    //
    // Skip over 4 byte "Reserved" field, ignoring whatever may be in it.
    // Get a pointer to the target address which follows, then skip over that.
    //
    TargetAddress = AlignAddr((IPv6Addr UNALIGNED *)
                              ((uchar *)Packet->Data + 4));
    AdjustPacketParams(Packet, 4 + sizeof(IPv6Addr));

    //
    // See if we're the target of the solicitation.  If the target address is
    // not a unicast or anycast address assigned to receiving interface,
    // then we must silently drop the packet.
    //
    TargetNTEorIF = FindAddressOnInterface(IF, TargetAddress, &TargetType);
    if (TargetNTEorIF == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "NeighborSolicitReceive: disabled IF\n"));
        return;
    }
    else if (TargetType == ADE_NONE) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "NeighborSolicitReceive: Did not find target address\n"));
        goto Return;
    }
    else if (TargetType == ADE_MULTICAST) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborSolicitReceive: "
                   "Target address not uni/anycast\n"));
        goto Return;
    }

    ASSERT(((TargetType == ADE_UNICAST) &&
            IsNTE(TargetNTEorIF) &&
            IP6_ADDR_EQUAL(&CastToNTE(TargetNTEorIF)->Address,
                           TargetAddress)) ||
           (TargetType == ADE_ANYCAST));

    //
    // The code below assumes a contiguous buffer for all the options
    // (the remainder of the packet).  If that isn't currently the
    // case, do a pullup for the whole thing.
    //
    if (! PacketPullup(Packet, Packet->TotalSize, 1, 0)) {
        // Can only fail if we run out of memory.
        goto Return;
    }

    ASSERT(Packet->ContigSize == Packet->TotalSize);

    //
    // We may have a source link-layer address option present.
    // Check for it and silently ignore all others.
    //
    SourceLinkAddress = NULL;
    while (Packet->ContigSize) {
        uint OptionLength;

        //
        // Validate the option length.
        //
        if ((Packet->ContigSize < 8) ||
            ((OptionLength = *((uchar *)Packet->Data + 1) << 3) == 0) ||
            (OptionLength > Packet->ContigSize)) {
            //
            // Invalid option length.  We MUST silently drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborSolicitReceive: "
                       "Received option with bogus length\n"));
            goto Return;
        }

        if (*((uchar *)Packet->Data) == ND_OPTION_SOURCE_LINK_LAYER_ADDRESS) {
            //
            // Some interfaces do not use SLLA and TLLA options.
            // For example, see RFC 2893 section 3.8.
            //
            if (IF->ReadLLOpt != NULL) {
                //
                // Parse the link-layer address option.
                //
                SourceLinkAddress = (*IF->ReadLLOpt)(IF->LinkContext,
                                                     (uchar *)Packet->Data);
                if (SourceLinkAddress == NULL) {
                    //
                    // Invalid option format. Drop the packet.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "NeighborSolicitReceive: "
                               "Received bogus ll option\n"));
                    goto Return;
                }
                //
                // Note that if there are multiple options for some bogus 
                // reason, we use the last one.  We sanity-check all the 
                // options.
                //
            }
        }

        //
        // Move forward to next option.
        //
        AdjustPacketParams(Packet, OptionLength);
    }

    if (IsUnspecified(AlignAddr(&Packet->IP->Source))) {
        //
        // Checks that were added post-RFC 1970.
        //

        if (!IsSolicitedNodeMulticast(AlignAddr(&Packet->IP->Dest))) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborSolicitReceive: NS with null src, bad dst\n"));
            goto Return;
        }

        if (SourceLinkAddress != NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborSolicitReceive: NS with null src and SLA\n"));
            goto Return;
        }
    }

    //
    // We've received and parsed a valid neighbor solicitation.
    //
    // First, we check our Duplicate Address Detection state.
    // (See RFC 2461 section 5.4.3.)
    //
    if (TargetType == ADE_UNICAST) {
        NetTableEntry *TargetNTE = CastToNTE(TargetNTEorIF);
        int DefendAddress = TRUE;

        // 
        // As an optimization, we perform this check without holding a lock.
        // This results in one less lock acquire/release for the common case.
        //
        if (!IsValidNTE(TargetNTE)) {            
            KeAcquireSpinLockAtDpcLevel(&IF->Lock);
            //
            // If the source address of the solicitation is the unspecified
            // address, it came from a node performing DAD on the address.
            // If our address is tentative, then we make it duplicate.
            //
            if (IsUnspecified(AlignAddr(&Packet->IP->Source)) &&
                IsTentativeNTE(TargetNTE)) {
                
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "NeighborSolicitReceive: DAD found duplicate\n"));
                AddrConfDuplicate(IF, TargetNTE);
            }
            
            if (!IsValidNTE(TargetNTE)) {
                //
                // Do not advertise/defend our invalid address.
                //
                DefendAddress = FALSE;
            }
            KeReleaseSpinLockFromDpcLevel(&IF->Lock);
        }

        if (! DefendAddress) {
            //
            // We should not respond to the solicit.
            //
            goto Return;
        }
    }

    //
    // Update the Neighbor Cache Entry for the source of this solicit.
    // In this case, only bother if the SourceLinkAddress is present;
    // if it's not, NeighborCacheUpdate won't do anything.
    //
    if (!IsUnspecified(AlignAddr(&Packet->IP->Source)) &&
        (SourceLinkAddress != NULL)) {
        NeighborCacheEntry *NCE;

        NCE = FindOrCreateNeighbor(IF, AlignAddr(&Packet->IP->Source));
        if (NCE != NULL) {
            NeighborCacheUpdate(NCE, SourceLinkAddress, FALSE);
            ReleaseNCE(NCE);
        }
    }

    //
    // Send a solicited neighbor advertisement back to the source.
    //
    // Interface to send on is 'IF' (I/F solicitation received on).
    //
    ICMPv6OutStats.icmps_msgs++;

    //
    // Allocate a packet for advertisement.
    // In addition to the 24 bytes for the solicit proper, leave space
    // for target link-layer address option (round option length up to
    // 8-byte multiple).
    //
    PayloadLength = 24;
    if (IF->WriteLLOpt != NULL)
        PayloadLength += (IF->LinkAddressLength + 2 + 7) & ~7;
    Offset = IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;

    Status = IPv6AllocatePacket(MemLen, &AdvertPacket, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        ICMPv6OutStats.icmps_errors++;
        goto Return;
    }

    //
    // Prepare IP header of advertisement.
    //
    AdvertIP = (IPv6Header UNALIGNED *)((uchar *)Mem + Offset);
    AdvertIP->VersClassFlow = IP_VERSION;
    AdvertIP->PayloadLength = net_short((ushort)PayloadLength);
    AdvertIP->NextHeader = IP_PROTOCOL_ICMPv6;
    AdvertIP->HopLimit = 255;

    //
    // Prepare ICMP header.
    //
    AdvertICMP = (ICMPv6Header UNALIGNED *)(AdvertIP + 1);
    AdvertICMP->Type = ICMPv6_NEIGHBOR_ADVERT;
    AdvertICMP->Code = 0;
    AdvertICMP->Checksum = 0;
    Flags = 0;
    if (IF->Flags & IF_FLAG_FORWARDS)
        Flags |= ND_NA_FLAG_ROUTER;

    //
    // We prevent loopback of all ND packets.
    //
    PC(AdvertPacket)->Flags = NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Check source of solicitation to see where we should direct our
    // advertisement (and determine what type of advertisement to send).
    //
    if (IsUnspecified(AlignAddr(&Packet->IP->Source))) {
        //
        // Solicitation came from an unspecified address (presumably a node
        // undergoing initialization), so we need to multicast our response.
        // We also don't set the solicited flag since we can't specify the
        // specific node our advertisement is directed at.
        //
        AdvertIP->Dest = AllNodesOnLinkAddr;
        PC(AdvertPacket)->Flags |= NDIS_FLAGS_MULTICAST_PACKET;

        DestLinkAddress = alloca(IF->LinkAddressLength);
        (*IF->ConvertAddr)(IF->LinkContext, &AllNodesOnLinkAddr,
                           DestLinkAddress);

    } else {
        //
        // We know who sent the solicitation, so we can respond by unicasting
        // our solicited advertisement back to the soliciter.
        //
        AdvertIP->Dest = Packet->IP->Source;
        Flags |= ND_NA_FLAG_SOLICITED;

        //
        // Find link-level address for above.  We should have it cached (note
        // that it will be cached if it just came in on this solicitation).
        //
        if (SourceLinkAddress != NULL) {
            //
            // This is faster than checking the ND cache and
            // it should be the common case. In fact, the RFC
            // requires that senders include the SLLA option,
            // except for point-to-point interfaces.
            //
            DestLinkAddress = (void *)SourceLinkAddress;
        } else if (IF->Flags & IF_FLAG_P2P) {
            //
            // Use the link-layer address of the other endpoint,
            // which follows our link-layer address in memory.
            //
            DestLinkAddress = IF->LinkAddress + IF->LinkAddressLength;
        } else {
            //
            // We shouldn't get here, because senders MUST
            // include the SLLA option. But make a best effort
            // to reply anyway.
            //
            DestLinkAddress = alloca(IF->LinkAddressLength);

            if (!NeighborCacheSearch(IF, AlignAddr(&Packet->IP->Source),
                                     DestLinkAddress)) {
                //
                // No entry found in ND cache.
                // Queuing for ND does not seem correct -
                // just drop the solicit.
                //
                ICMPv6OutStats.icmps_errors++;
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "NeighborSolicitReceive: Didn't find NCE!?!\n"));
                IPv6FreePacket(AdvertPacket);
                goto Return;
            }
        }
    }

    if (IsNTE(TargetNTEorIF)) {
        //
        // Take our source address from the target NTE.
        //
        AdvertIP->Source = CastToNTE(TargetNTEorIF)->Address;
    }
    else {
        NetTableEntry *BestNTE;

        //
        // Find the best source address for the destination.
        //
        BestNTE = FindBestSourceAddress(IF, AlignAddr(&AdvertIP->Dest));
        if (BestNTE == NULL) {
            ICMPv6OutStats.icmps_errors++;
            goto Return;
        }
        AdvertIP->Source = BestNTE->Address;
        ReleaseNTE(BestNTE);
    }

    //
    // Take the target address from the solicitation.
    //
    AdvertTargetAddress = (IPv6Addr *)
        ((char *)AdvertICMP + sizeof(ICMPv6Header) + sizeof(ulong));
    *AdvertTargetAddress = *TargetAddress;

    if (PayloadLength != 24) {
        //
        // Include target link-layer address option.
        //
        AdvertTargetOption = (void *)((char *)AdvertTargetAddress +
                                      sizeof(IPv6Addr));

        ((uchar *)AdvertTargetOption)[0] = ND_OPTION_TARGET_LINK_LAYER_ADDRESS;
        ((uchar *)AdvertTargetOption)[1] = (uchar)((IF->LinkAddressLength + 2 + 7) >> 3);

        (*IF->WriteLLOpt)(IF->LinkContext, AdvertTargetOption, IF->LinkAddress);
        //
        // We set the override flag when including the TLLA option,
        // unless the target is an anycast address.
        //
        if (TargetType != ADE_ANYCAST)
            Flags |= ND_NA_FLAG_OVERRIDE;
    }

    //
    // Fill in Flags field in advertisement.
    //
    *(ulong UNALIGNED *)((char *)AdvertICMP + sizeof(ICMPv6Header)) =
                                                        net_long(Flags);

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    AdvertICMP->Checksum = ChecksumPacket(
        AdvertPacket, Offset + sizeof *AdvertIP, NULL, PayloadLength,
        AlignAddr(&AdvertIP->Source), AlignAddr(&AdvertIP->Dest),
        IP_PROTOCOL_ICMPv6);
    ASSERT(AdvertICMP->Checksum != 0);

    ICMPv6OutStats.icmps_typecount[ICMPv6_NEIGHBOR_ADVERT]++;
    if (TargetType == ADE_ANYCAST) {
        LARGE_INTEGER Delay;
        //
        // Delay randomly before sending the Neighbor Advertisement.
        //
        Delay.QuadPart = - (LONGLONG)
            RandomNumber(0, MAX_ANYCAST_DELAY_TIME * 10000000);
        Status = IPv6SendLater(Delay,
                               IF, AdvertPacket, Offset, DestLinkAddress);
        if (Status != NDIS_STATUS_SUCCESS)
            IPv6SendComplete(NULL, AdvertPacket, IP_NO_RESOURCES);
    }
    else {
        //
        // Transmit the Neighbor Advertisement immediately.
        //
        IPv6SendLL(IF, AdvertPacket, Offset, DestLinkAddress);
    }

  Return:
    if (IsNTE(TargetNTEorIF))
        ReleaseNTE(CastToNTE(TargetNTEorIF));
    else
        ReleaseIF(CastToIF(TargetNTEorIF));
}


//* NeighborAdvertReceive - Handle Neighbor Advertisement messages.
//
// Validate message and update neighbor cache if necessary.
//
void
NeighborAdvertReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP header.
{
    Interface *IF = Packet->NTEorIF->IF;
    ulong Flags;
    const IPv6Addr *TargetAddress;
    const void *TargetLinkAddress;
    NetTableEntryOrInterface *TargetNTEorIF;
    ushort TargetType;

    //
    // Validate the advertisement.
    // By the time we get here, any IPv6 Authentication Header will have
    // already been checked, as will have the ICMPv6 checksum.  Still need
    // to check the IP Hop Limit, and the ICMP code and length.
    //
    if ((Packet->IP->HopLimit != 255) ||
        (Packet->Flags & PACKET_TUNNELED)) {
        //
        // Packet was forwarded by a router, therefore it cannot be
        // from a legitimate neighbor.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborAdvertReceive: "
                   "Received a routed neighbor advertisement\n"));
        return;
    }
    if (ICMP->Code != 0) {
        //
        // Bogus/corrupted neighbor advertisement message.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborAdvertReceive: "
                   "Received a corrupted neighbor advertisement\n"));
        return;
    }

    //
    // Next we have a 4 byte field, then an IPv6 address.
    //
    if (! PacketPullup(Packet, 4 + sizeof(IPv6Addr),
                       __builtin_alignof(IPv6Addr), 0)) {
        if (Packet->TotalSize < 4 + sizeof(IPv6Addr)) {
            //
            // Packet too short to contain minimal advertisement.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborAdvertReceive: "
                       "Received a too short advertisement\n"));
        }
        return;
    }

    //
    // Next 4 bytes contains 3 bits of flags and 29 bits of "Reserved".
    // Pull this out as a 32 bit long, we're required to ignore the "Reserved"
    // bits.  Get a pointer to the target address which follows, then skip
    // over that.
    //
    Flags = net_long(*(ulong UNALIGNED *)Packet->Data);
    TargetAddress = AlignAddr((IPv6Addr UNALIGNED *)
                              ((ulong *)Packet->Data + 1));
    AdjustPacketParams(Packet, sizeof(ulong) + sizeof(IPv6Addr));

    //
    // Check that the target address is not a multicast address.
    //
    if (IsMulticast(TargetAddress)) {
        //
        // Nodes are not supposed to send neighbor advertisements for
        // multicast addresses.  We're required to drop any such advertisements
        // we receive.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborAdvertReceive: "
                   "Received advertisement for a multicast address\n"));
        return;
    }

    //
    // Check that Solicited flag is zero
    // if the destination address is multicast.
    //
    if ((Flags & ND_NA_FLAG_SOLICITED) &&
        IsMulticast(AlignAddr(&Packet->IP->Dest))) {
        //
        // We're required to drop the advertisement.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "NeighborAdvertReceive: "
                   "Received solicited advertisement to a multicast address\n"));
        return;
    }

    //
    // The code below assumes a contiguous buffer for all the options
    // (the remainder of the packet).  If that isn't currently the
    // case, do a pullup for the whole thing.
    //
    if (! PacketPullup(Packet, Packet->TotalSize, 1, 0)) {
        // Can only fail if we run out of memory.
        return;
    }

    ASSERT(Packet->ContigSize == Packet->TotalSize);

    //
    // Look for a target link-layer address option.
    //
    TargetLinkAddress = NULL;
    while (Packet->ContigSize) {
        uint OptionLength;

        //
        // Validate the option length.
        //
        if ((Packet->ContigSize < 8) ||
            ((OptionLength = *((uchar *)Packet->Data + 1) << 3) == 0) ||
            (OptionLength > Packet->ContigSize)) {
            //
            // Invalid option length.  We MUST silently drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "NeighborAdvertReceive: "
                       "Received option with bogus length\n"));
            return;
        }

        if (*((uchar *)Packet->Data) == ND_OPTION_TARGET_LINK_LAYER_ADDRESS) {
            //
            // Some interfaces do not use SLLA and TLLA options.
            // For example, see RFC 2893 section 3.8.
            //
            if (IF->ReadLLOpt != NULL) {
                //
                // Parse the link-layer address option.
                //
                TargetLinkAddress = (*IF->ReadLLOpt)(IF->LinkContext,
                                                     (uchar *)Packet->Data);
                if (TargetLinkAddress == NULL) {
                    //
                    // Invalid option format. Drop the packet.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "NeighborAdvertReceive: "
                               "Received bogus ll option\n"));
                    return;
                }
                //
                // Note that if there are multiple options for some bogus 
                // reason, we use the last one.  We sanity-check all the 
                // options.
                //
            }
        }

        //
        // Move forward to next option.
        //
        AdjustPacketParams(Packet, OptionLength);
    }

    //
    // We've received and parsed a valid neighbor advertisement.
    //
    // First, we check our Duplicate Address Detection state.
    // (See RFC 2461 section 5.4.4.)
    //
    TargetNTEorIF = FindAddressOnInterface(IF, TargetAddress, &TargetType);
    if (TargetNTEorIF == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "NeighborAdvertReceive: disabled IF\n"));
        return;
    }

    if (IsNTE(TargetNTEorIF)) {
        NetTableEntry *TargetNTE = CastToNTE(TargetNTEorIF);

        if (TargetType == ADE_UNICAST) {
            ASSERT(IP6_ADDR_EQUAL(TargetAddress, &TargetNTE->Address));

            //
            // Someone out there appears to be using our address;
            // they responded to our DAD solicit.
            //
            // The RFC says to declare a duplicate only if our address is
            // tentative, whereas we also make our address duplicate whenever
            // the override bit in the advertisement is set. This is because
            // we redo DAD for existing addresses upon reconnection.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "NeighborAdvertReceive: DAD found duplicate\n"));
            KeAcquireSpinLockAtDpcLevel(&IF->Lock);
            if (IsTentativeNTE(TargetNTE) || (Flags & ND_NA_FLAG_OVERRIDE))
                AddrConfDuplicate(IF, TargetNTE);
            KeReleaseSpinLockFromDpcLevel(&IF->Lock);

            //
            // We continue with normal processing.
            // For example, we may have an invalid NTE for the address
            // and we are trying to communicate with the address,
            // which is currently assigned to another node.
            //
        }

        ReleaseNTE(TargetNTE);
    }
    else {
        Interface *TargetIF = CastToIF(TargetNTEorIF);

        ASSERT(TargetType != ADE_UNICAST);
        ASSERT(TargetIF == IF);
        ReleaseIF(TargetIF);
    }

    //
    // If this is a point-to-point interface,
    // then we know the target link-layer address.
    //
    if ((TargetLinkAddress == NULL) &&
        (IF->Flags & IF_FLAG_P2P)) {
        //
        // Use the link-layer address of the other endpoint,
        // which follows our link-layer address in memory.
        //
        TargetLinkAddress = IF->LinkAddress + IF->LinkAddressLength;
    }

    //
    // Process the advertisement.
    //
    NeighborCacheAdvert(IF, TargetAddress, TargetLinkAddress, Flags);
}


//* RedirectReceive - Handle Redirect messages.
//
//  See RFC 1970, sections 8.1 and 8.3.
//
void
RedirectReceive(
    IPv6Packet *Packet,             // Packet handed to us by ICMPv6Receive.
    ICMPv6Header UNALIGNED *ICMP)   // ICMP header.
{
    Interface *IF = Packet->NTEorIF->IF;
    const IPv6Addr *TargetAddress;
    const void *TargetLinkAddress;
    const IPv6Addr *DestinationAddress;
    NeighborCacheEntry *TargetNCE;
    IP_STATUS Status;

    //
    // Ignore the redirect if this is a forwarding interface.
    //
    if (IF->Flags & IF_FLAG_FORWARDS)
        return;

    //
    // Validate the redirect.
    // By the time we get here, any IPv6 Authentication Header will have
    // already been checked, as will have the ICMPv6 checksum.  Still need
    // to check the IP Hop Limit, and the ICMP code and length.
    //
    if ((Packet->IP->HopLimit != 255) ||
        (Packet->Flags & PACKET_TUNNELED)) {
        //
        // Packet was forwarded by a router, therefore it cannot be
        // from a legitimate neighbor.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RedirectReceive: Received a routed redirect\n"));
        return;
    }
    if (ICMP->Code != 0) {
        //
        // Bogus/corrupted redirect message.  Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RedirectReceive: Received a corrupted redirect\n"));
        return;
    }

    //
    // Check that the source address is a link-local address.
    // We need a link-local source address to identify the router
    // that sent the redirect.
    //
    if (!IsLinkLocal(AlignAddr(&Packet->IP->Source))) {
        //
        // Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RedirectReceive: "
                   "Received redirect from non-link-local source\n"));
        return;
    }

    //
    // Next we have a 4 byte reserved field, then two IPv6 addresses.
    //
    if (! PacketPullup(Packet, 4 + 2 * sizeof(IPv6Addr),
                       __builtin_alignof(IPv6Addr), 0)) {
        if (Packet->TotalSize < 4 + 2 * sizeof(IPv6Addr)) {
            //
            // Packet too short to contain minimal redirect.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RedirectReceive: Received a too short redirect\n"));
        }
        return;
    }

    //
    // Skip over the 4 byte reserved field.
    // Pick up the Target and Destination addresses.
    //
    AdjustPacketParams(Packet, 4);
    TargetAddress = AlignAddr((IPv6Addr UNALIGNED *)Packet->Data);
    DestinationAddress = TargetAddress + 1;
    AdjustPacketParams(Packet, 2 * sizeof(IPv6Addr));

    //
    // Check that the destination address is not a multicast address.
    //
    if (IsMulticast(DestinationAddress)) {
        //
        // Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RedirectReceive: "
                   "Received redirect for multicast address\n"));
        return;
    }

    //
    // Check that either the target address is link-local
    // (redirecting to a router) or the target and the destination
    // are the same (redirecting to an on-link destination).
    //
    if (!IsLinkLocal(TargetAddress) &&
        !IP6_ADDR_EQUAL(TargetAddress, DestinationAddress)) {
        //
        // Drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RedirectReceive: "
                   "Received redirect with non-link-local target\n"));
        return;
    }

    //
    // The code below assumes a contiguous buffer for all the options
    // (the remainder of the packet).  If that isn't currently the
    // case, do a pullup for the whole thing.
    //
    if (! PacketPullup(Packet, Packet->TotalSize, 1, 0)) {
        // Can only fail if we run out of memory.
        return;
    }

    ASSERT(Packet->ContigSize == Packet->TotalSize);

    //
    // Look for a target link-layer address option,
    // checking that all included options have a valid length.
    //
    TargetLinkAddress = NULL;
    while (Packet->ContigSize) {
        uint OptionLength = 0;

        //
        // Validate the option length.
        //
        if ((Packet->ContigSize < 8) ||
            ((OptionLength = *((uchar *)Packet->Data + 1) << 3) == 0) ||
            (OptionLength > Packet->ContigSize)) {
            //
            // Invalid option length.  We MUST silently drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RedirectReceive: Received option with length %u "
                       "while we only have %u data\n", OptionLength,
                       Packet->ContigSize));
            return;
        }

        if (*(uchar *)Packet->Data == ND_OPTION_TARGET_LINK_LAYER_ADDRESS) {
            //
            // Some interfaces do not use SLLA and TLLA options.
            // For example, see RFC 2893 section 3.8.
            //
            if (IF->ReadLLOpt != NULL) {
                //
                // Parse the link-layer address option.
                //
                TargetLinkAddress = (*IF->ReadLLOpt)(IF->LinkContext,
                                                     (uchar *)Packet->Data);
                if (TargetLinkAddress == NULL) {
                    //
                    // Invalid option format. Drop the packet.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "RedirectReceive: Received bogus ll option\n"));
                    return;
                }
                //
                // Note that if there are multiple options for some bogus 
                // reason, we use the last one. We must sanity-check all 
                // option lengths.
                //
            }
        }

        //
        // Move forward to next option.
        //
        AdjustPacketParams(Packet, OptionLength);
    }

    //
    // We have a valid redirect message (except for checking that the
    // source of the redirect is the current first-hop neighbor
    // for the destination - RedirectRouteCache does that).
    //
    // First we get an NCE for the target of the redirect.  Then we
    // update the route cache.  If RedirectRouteCache doesn't invalidate
    // the redirect, then we update the neighbor cache.
    //

    //
    // Get the Neighbor Cache Entry for the target.
    //
    TargetNCE = FindOrCreateNeighbor(IF, TargetAddress);
    if (TargetNCE == NULL) {
        //
        // Couldn't find or create NCE.  Drop the packet.
        //
        return;
    }

    //
    // Update the route cache to reflect this redirect.
    //
    Status = RedirectRouteCache(AlignAddr(&Packet->IP->Source),
                                DestinationAddress,
                                IF, TargetNCE);

    if (Status == IP_SUCCESS) {
        //
        // Update the Neighbor Cache Entry for the target.
        // We know the target is a router if the target address
        // is not the same as the destination address.
        //
        NeighborCacheUpdate(TargetNCE, TargetLinkAddress,
                            !IP6_ADDR_EQUAL(TargetAddress,
                                            DestinationAddress));
    }

    ReleaseNCE(TargetNCE);
}


//* RouterSolicitSend
//
//  Sends a Router Solicitation.
//  The solicit is always sent to the all-routers multicast address.
//  Chooses a valid source address for the interface.
//
//  Called with no locks held.
//
void
RouterSolicitSend(Interface *IF)
{
    NDIS_STATUS Status;
    NDIS_PACKET *Packet;
    int PayloadLength;
    uint Offset;
    void *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    void *SourceOption;
    void *LLDest;
    IPv6Addr Source;

    //
    // Calculate the link-level destination address.
    // (The IPv6 destination is a multicast address.)
    // This can potentially fail, such as with ISATAP when
    // no router is known.
    //
    LLDest = alloca(IF->LinkAddressLength);
    if ((*IF->ConvertAddr)(IF->LinkContext, &AllRoutersOnLinkAddr, LLDest) == 
        ND_STATE_INCOMPLETE) {

        //
        // Don't count this as an attempt or a failure.  Just pretend
        // that router discovery is disabled.  This way, if you aren't
        // using ISATAP, you don't see a high ICMP error count.
        //
        return;
    }

    ICMPv6OutStats.icmps_msgs++;

    //
    // Allocate a packet for solicitation.
    // In addition to the 8 bytes for the solicit proper, leave space
    // for source link-layer address option (round option length up to
    // 8-byte multiple) IF we have a valid source address and ND is
    // enabled.  If ND is disabled, the router can presumably
    // derive our link-layer address itself.
    //
    PayloadLength = 8;
    if (GetLinkLocalAddress(IF, &Source) && (IF->WriteLLOpt != NULL)) {

        PayloadLength += (IF->LinkAddressLength + 2 + 7) &~ 7;
    }
    Offset = IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;

    Status = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    //
    // Prepare IP header of solicitation.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->PayloadLength = net_short((ushort)PayloadLength);
    IP->NextHeader = IP_PROTOCOL_ICMPv6;
    IP->HopLimit = 255;
    IP->Source = Source;
    IP->Dest = AllRoutersOnLinkAddr;

    //
    // Prepare ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)(IP + 1);
    ICMP->Type = ICMPv6_ROUTER_SOLICIT;
    ICMP->Code = 0;
    ICMP->Checksum = 0;

    //
    // Must zero the reserved field.
    //
    *(ulong UNALIGNED *)(ICMP + 1) = 0;

    if (PayloadLength != 8) {
        //
        // Include source link-layer address option.
        //
        SourceOption = (void *)((ulong *)(ICMP + 1) + 1);

        ((uchar *)SourceOption)[0] = ND_OPTION_SOURCE_LINK_LAYER_ADDRESS;
        ((uchar *)SourceOption)[1] = (uchar)((IF->LinkAddressLength + 2 + 7) >> 3);

        (*IF->WriteLLOpt)(IF->LinkContext, SourceOption, IF->LinkAddress);
    }

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    ICMP->Checksum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest),
        IP_PROTOCOL_ICMPv6);
    ASSERT(ICMP->Checksum != 0);

    //
    // We prevent loopback of all ND packets.
    //
    PC(Packet)->Flags = NDIS_FLAGS_MULTICAST_PACKET | NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Transmit the packet.
    //
    ICMPv6OutStats.icmps_typecount[ICMPv6_ROUTER_SOLICIT]++;
    IPv6SendLL(IF, Packet, Offset, LLDest);
}

//* RouterSolicitTimeout
//
//  Called periodically from IPv6Timeout to handle timeouts
//  for sending router solicitations for an interface.
//
//  Callable from DPC context, not from thread context.
//
void
RouterSolicitTimeout(Interface *IF)
{
    int SendRouterSolicit = FALSE;

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    if (IF->RSTimer != 0) {
        ASSERT(!IsDisabledIF(IF));

        //
        // Timer is running.  Decrement and check for expiration.
        //
        if (--IF->RSTimer == 0) {
            if (IF->RSCount < MAX_RTR_SOLICITATIONS) {
                //
                // Re-arm the timer and generate a router solicitation.
                //
                IF->RSTimer = RTR_SOLICITATION_INTERVAL;
                IF->RSCount++;
                SendRouterSolicit = TRUE;
            }
            else {
                //
                // If we are still in the reconnecting state,
                // meaning we have not received an RA
                // since reconnecting to the link,
                // remove stale auto-configured state.
                //
                if (IF->Flags & IF_FLAG_MEDIA_RECONNECTED) {
                    IF->Flags &= ~IF_FLAG_MEDIA_RECONNECTED;

                    //
                    // Remove auto-configured addresses.
                    //
                    AddrConfResetAutoConfig(IF, 0);

                    //
                    // Similarly, remove auto-configured routes.
                    //
                    RouteTableResetAutoConfig(IF, 0);

                    //
                    // Restore interface parameters.
                    //
                    InterfaceResetAutoConfig(IF);
                }

                //
                // On a non-multicast capable interface, we'll
                // never get multicast RA's so change to infrequent
                // RS polling.
                //
                if (!(IF->Flags & IF_FLAG_MULTICAST)) {
                    IF->RSTimer = SLOW_RTR_SOLICITATION_INTERVAL;
                    IF->RSCount++;
                    SendRouterSolicit = TRUE;
                }
            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    if (SendRouterSolicit)
        RouterSolicitSend(IF);
}

//* NeighborSolicitSend0
//
//  Low-level version of NeighborSolicitSend -
//  uses explicit source/destination/target addresses
//  instead of an NCE.
//
void
NeighborSolicitSend0(
    Interface *IF,              // Interface for the solicit
    void *LLDest,               // Link-level destination
    const IPv6Addr *Source,     // IP-level source
    const IPv6Addr *Dest,       // IP-level destination
    const IPv6Addr *Target)     // IP-level target of the solicit
{
    NDIS_STATUS Status;
    NDIS_PACKET *Packet;
    int PayloadLength;
    uint Offset;
    void *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    IPv6Addr *TargetAddress;
    void *SourceOption;

    ICMPv6OutStats.icmps_msgs++;

    //
    // Allocate a packet for solicitation.
    // In addition to the 24 bytes for the solicit proper, leave space
    // for source link-layer address option (round option length up to
    // 8-byte multiple) IF we have a valid source address.
    //
    PayloadLength = 24;
    if (!IsUnspecified(Source) && (IF->WriteLLOpt != NULL))
        PayloadLength += (IF->LinkAddressLength + 2 + 7) &~ 7;
    Offset = IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;

    Status = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    //
    // Prepare IP header of solicitation.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->PayloadLength = net_short((ushort)PayloadLength);
    IP->NextHeader = IP_PROTOCOL_ICMPv6;
    IP->HopLimit = 255;
    IP->Source = *Source;
    IP->Dest = *Dest;

    //
    // Prepare ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)(IP + 1);
    ICMP->Type = ICMPv6_NEIGHBOR_SOLICIT;
    ICMP->Code = 0;
    ICMP->Checksum = 0;

    //
    // Must zero the reserved field.
    //
    *(ulong UNALIGNED *)(ICMP + 1) = 0;

    //
    // Initialize the target address.
    //
    TargetAddress = (IPv6Addr *)((ulong *)(ICMP + 1) + 1);
    *TargetAddress = *Target;

    if (PayloadLength != 24) {
        //
        // Include source link-layer address option.
        //
        SourceOption = (void *)(TargetAddress + 1);

        ((uchar *)SourceOption)[0] = ND_OPTION_SOURCE_LINK_LAYER_ADDRESS;
        ((uchar *)SourceOption)[1] = (uchar)((IF->LinkAddressLength + 2 + 7) >> 3);

        (*IF->WriteLLOpt)(IF->LinkContext, SourceOption, IF->LinkAddress);
    }

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    ICMP->Checksum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest),
        IP_PROTOCOL_ICMPv6);
    ASSERT(ICMP->Checksum != 0);

    //
    // Is this a multicast packet?
    // But we inhibit loopback of unicast packets too -
    // this prevents rare races in which we receive
    // our own ND packets.
    //
    PC(Packet)->Flags = NDIS_FLAGS_DONT_LOOPBACK;
    if (IsMulticast(Dest))
        PC(Packet)->Flags |= NDIS_FLAGS_MULTICAST_PACKET;

    //
    // Transmit the packet.
    //
    ICMPv6OutStats.icmps_typecount[ICMPv6_NEIGHBOR_SOLICIT]++;
    IPv6SendLL(IF, Packet, Offset, LLDest);
}

//* NeighborSolicitSend - Send a Neighbor Solicitation message.
//
//  Chooses source/destination/target addresses depending
//  on the NCE state and sends the solicit packet.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
void
NeighborSolicitSend(
    NeighborCacheEntry *NCE,  // Neighbor to solicit.
    const IPv6Addr *Source)   // Source address to send from (optional).
{
    Interface *IF = NCE->IF;
    IPv6Addr Dest;
    void *LLDest;
    IPv6Addr LinkLocal;

    //
    // Check Neighbor Discovery protocol state of our neighbor in order to
    // determine whether we should multicast or unicast our solicitation.
    //
    // Note that we do not take the neighbor cache lock to make this check.
    // The worst that can happen is that we'll think the NDState is not
    // incomplete and then use a bogus/changing LinkAddress.
    // This is rare enough and benign enough to be OK.
    // Similar reasoning in IPv6SendND.
    //
    if (NCE->NDState == ND_STATE_INCOMPLETE) {
        //
        // This is our initial solicitation to this neighbor, so we don't
        // have a link-layer address cached.  Multicast our solicitation
        // to the solicited-node multicast address corresponding to our
        // neighbor's address.
        //
        CreateSolicitedNodeMulticastAddress(&NCE->NeighborAddress, &Dest);

        LLDest = alloca(IF->LinkAddressLength);
        (*IF->ConvertAddr)(IF->LinkContext, &Dest, LLDest);
    } else {
        //
        // We have a cached link-layer address that has gone stale.
        // Probe this address via a unicast solicitation.
        //
        Dest = NCE->NeighborAddress;

        LLDest = NCE->LinkAddress;
    }

    //
    // If we were given a specific source address to use then do so (normal
    // case for our initial multicasted solicit), otherwise use the outgoing
    // interface's link-local address.  If there is no valid link-local
    // address, then we give up.
    //
    if (Source == NULL) {
        if (!GetLinkLocalAddress(IF, &LinkLocal)) {
            return;
        }
        Source = &LinkLocal;
    }

    //
    // Now that we've determined the source/destination/target addresses,
    // we can actually send the solicit.
    //
    NeighborSolicitSend0(IF, LLDest, Source, &Dest, &NCE->NeighborAddress);
}


//* DADSolicitSend - Sends a DAD Neighbor Solicit.
//
//  Like NeighborSolicitSend, but specialized for DAD.
//
void
DADSolicitSend(NetTableEntry *NTE)
{
    Interface *IF = NTE->IF;
    IPv6Addr Dest;
    void *LLDest;

    //
    // Multicast our solicitation to the solicited-node multicast
    // address corresponding to our own address.
    //
    CreateSolicitedNodeMulticastAddress(&NTE->Address, &Dest);

    //
    // Convert the IP-level multicast destination address
    // to a link-level multicast address.
    //
    LLDest = alloca(IF->LinkAddressLength);
    (*IF->ConvertAddr)(IF->LinkContext, &Dest, LLDest);

    //
    // Now that we've created the destination addresses,
    // we can actually send the solicit.
    //
    NeighborSolicitSend0(IF, LLDest, &UnspecifiedAddr,
                         &Dest, &NTE->Address);
}


//* DADTimeout - handle a Duplicate Address Detection timeout.
//
//  Called from IPv6Timeout to handle DAD timeouts on an NTE.
//
void
DADTimeout(NetTableEntry *NTE)
{
    Interface *IF = NTE->IF;
    int SendDADSolicit = FALSE;

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    if (NTE->DADTimer != 0) {
        ASSERT(NTE->DADState != DAD_STATE_INVALID);

        //
        // Timer is running.  Decrement and check for expiration.
        //
        if (--NTE->DADTimer == 0) {
            //
            // Timer went off.
            //

            if (NTE->DADCount == 0) {
                //
                // The address has passed Duplicate Address Detection.
                // Because we have passed DAD, reset the failure count.
                //
                IF->DupAddrDetects = 0;
                AddrConfNotDuplicate(IF, NTE);
            }
            else {
                //
                // Time to send another solicit.
                //
                NTE->DADCount--;
                NTE->DADTimer = (ushort)IF->RetransTimer;
                SendDADSolicit = TRUE;
            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    if (SendDADSolicit)
        DADSolicitSend(NTE);
}

//* CalcReachableTime
//
//  Calculate a pseudo-random ReachableTime from BaseReachableTime
//  (this prevents synchronization of Neighbor Unreachability Detection
//  messages from different hosts), and convert it to units of IPv6
//  timer ticks (cheaper to do once here than at every packet send).
//
uint                         // IPv6 timer ticks
CalcReachableTime(
    uint BaseReachableTime)  // Learned from Router Advertisements (in ms).
{
    uint Factor;
    uint ReachableTime;

    //
    // Calculate a uniformly-distributed random value between
    // MIN_RANDOM_FACTOR and MAX_RANDOM_FACTOR of the BaseReachableTime.
    // To keep the arithmetic integer, *_RANDOM_FACTOR (and thus the
    // 'Factor' variable) are defined as percentage values.
    //
    Factor = RandomNumber(MIN_RANDOM_FACTOR, MAX_RANDOM_FACTOR);

    //
    // Now that we have a random value picked out of our percentage spread,
    // take that percentage of the BaseReachableTime.
    //
    // BaseReachableTime has a maximum value of 3,600,000 milliseconds
    // (see RFC 1970, section 6.2.1), so Factor would have to exeed 1100 %
    // in order to overflow a 32-bit unsigned integer.
    //
    ReachableTime = (BaseReachableTime * Factor) / 100;

    //
    // Convert from milliseconds (which is what BaseReachableTime is in) to
    // IPv6 timer ticks (which is what we keep ReachableTime in).
    //
    return ConvertMillisToTicks(ReachableTime);
}

//* RedirectSend
//
//  Send a Redirect message to a neighbor,
//  telling it to use a better first-hop neighbor
//  in the future for the specified destination.
//
//  RecvNTEorIF (optionally) specifies a source address
//  to use in the Redirect message.
//
//  Packet (optionally) specifies data to include
//  in a Redirected Header option.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
void
RedirectSend(
    NeighborCacheEntry *NCE,               // Neighbor getting the Redirect.
    NeighborCacheEntry *TargetNCE,         // Better first-hop to use
    const IPv6Addr *Destination,           // for this Destination address.
    NetTableEntryOrInterface *NTEorIF,     // Source of the Redirect.
    PNDIS_PACKET FwdPacket,                // Packet triggering the redirect.
    uint FwdOffset,
    uint FwdPayloadLength)
{
    PNDIS_BUFFER FwdBuffer;
    Interface *IF = NCE->IF;
    NDIS_STATUS Status;
    NDIS_PACKET *Packet;
    uint PayloadLength;
    uint TargetOptionLength;
    uint RedirectOptionData;
    uint RedirectOptionLength;
    uint Offset;
    void *Mem;
    uint MemLen;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    void *TargetLinkAddress;
    KIRQL OldIrql;
    const IPv6Addr *Source;
    IPv6Addr LinkLocal;
    int Ok;

    ASSERT((IF == TargetNCE->IF) && (IF == NTEorIF->IF));

    //
    // If our caller specified a source address, use it.
    // Otherwise (common case) we use our link-local address.
    //
    if (IsNTE(NTEorIF)) {
        Source = &CastToNTE(NTEorIF)->Address;
    }
    else {
        //
        // We need a valid link-local address to send a redirect.
        //
        if (! GetLinkLocalAddress(IF, &LinkLocal))
            return;
        Source = &LinkLocal;
    }

    //
    // Do we know the Target neighbor's link address?
    //
    KeAcquireSpinLock(&IF->LockNC, &OldIrql);
    if (TargetNCE->NDState == ND_STATE_INCOMPLETE) {
        TargetLinkAddress = NULL;
        TargetOptionLength = 0;
    }
    else {
        TargetLinkAddress = alloca(IF->LinkAddressLength);
        RtlCopyMemory(TargetLinkAddress, TargetNCE->LinkAddress,
                      IF->LinkAddressLength);
        TargetOptionLength = (IF->LinkAddressLength + 2 + 7) &~ 7;
    }
    KeReleaseSpinLock(&IF->LockNC, OldIrql);

    //
    // Calculate the Redirect's payload size,
    // with space for a Target Link-Layer Address option.
    //
    PayloadLength = 40 + TargetOptionLength;

    //
    // Allow space for the Redirected Header option,
    // without exceeding the MTU.
    // Note that RFC 2461 4.6.3 explicitly specifies
    // the IPv6 minimum MTU, not the link MTU.
    // We can always include at least the option header and
    // the IPv6 header from FwdPacket.
    //
    RedirectOptionLength = 8 + sizeof(IPv6Header);
    if (sizeof(IPv6Header) + PayloadLength +
                RedirectOptionLength + FwdPayloadLength > IPv6_MINIMUM_MTU) {
        //
        // Truncate FwdPacket to make it fit.
        //
        RedirectOptionLength = IPv6_MINIMUM_MTU -
                                        (sizeof(IPv6Header) + PayloadLength);
        RedirectOptionData = RedirectOptionLength - 8;
    }
    else {
        //
        // Include all of FwdPacket, plus possible padding.
        //
        RedirectOptionLength += (FwdPayloadLength + 7) &~ 7;
        RedirectOptionData = sizeof(IPv6Header) + FwdPayloadLength;
    }
    PayloadLength += RedirectOptionLength;

    //
    // Allocate a packet for the Redirect.
    //
    Offset = IF->LinkHeaderSize;
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength;
    Status = IPv6AllocatePacket(MemLen, &Packet, &Mem);
    if (Status != NDIS_STATUS_SUCCESS) {
        return;
    }

    //
    // Prepare IP header of solicitation.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->PayloadLength = net_short((ushort)PayloadLength);
    IP->NextHeader = IP_PROTOCOL_ICMPv6;
    IP->HopLimit = 255;
    IP->Dest = NCE->NeighborAddress;
    IP->Source = *Source;

    //
    // Prepare ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)(IP + 1);
    ICMP->Type = ICMPv6_REDIRECT;
    ICMP->Code = 0;
    ICMP->Checksum = 0;
    Mem = (void *)(ICMP + 1);

    //
    // Must zero the reserved field.
    //
    *(ulong UNALIGNED *)Mem = 0;
    (ulong *)Mem += 1;

    //
    // Initialize the target and destination addresses.
    //
    ((IPv6Addr *)Mem)[0] = TargetNCE->NeighborAddress;
    ((IPv6Addr *)Mem)[1] = *Destination;
    (IPv6Addr *)Mem += 2;

    if ((TargetLinkAddress != NULL) && (IF->WriteLLOpt != NULL)) {
        void *TargetOption = Mem;

        //
        // Include a Target Link-Layer Address option.
        //
        ((uchar *)TargetOption)[0] = ND_OPTION_TARGET_LINK_LAYER_ADDRESS;
        ((uchar *)TargetOption)[1] = TargetOptionLength >> 3;

        (*IF->WriteLLOpt)(IF->LinkContext, TargetOption, TargetLinkAddress);
        (uchar *)Mem += TargetOptionLength;
    }

    //
    // Include a Redirected Header option.
    //
    ((uchar *)Mem)[0] = ND_OPTION_REDIRECTED_HEADER;
    ((uchar *)Mem)[1] = RedirectOptionLength >> 3;
    RtlZeroMemory(&((uchar *)Mem)[2], 6);
    (uchar *)Mem += 8;

    //
    // Include as much of FwdPacket as will fit,
    // zeroing any padding bytes.
    //
    NdisQueryPacket(FwdPacket, NULL, NULL, &FwdBuffer, NULL);
    Ok = CopyNdisToFlat(Mem, FwdBuffer, FwdOffset, RedirectOptionData,
                        &FwdBuffer, &FwdOffset);
    ASSERT(Ok);
    (uchar *)Mem += RedirectOptionData;
    RtlZeroMemory(Mem, RedirectOptionLength - (8 + RedirectOptionData));

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    ICMP->Checksum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest),
        IP_PROTOCOL_ICMPv6);
    ASSERT(ICMP->Checksum != 0);

    //
    // We prevent loopback of all ND packets.
    //
    PC(Packet)->Flags = NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Send the Redirect packet.
    //
    IPv6SendND(Packet, Offset, NCE, Source);
}

//* RouterAdvertTimeout
//
//  Called periodically from IPv6Timeout to handle timeouts
//  for sending router advertisements for an interface.
//  Our caller checks IF->RATimer and only calls us
//  if there is a high probability that we need to send an RA.
//
//  Callable from DPC context, not from thread context.
//
void
RouterAdvertTimeout(Interface *IF, int Force)
{
    uint Now;
    int SendRouterAdvert = FALSE;
    NetTableEntry *NTE;
    IPv6Addr Source;

    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    if (IF->RATimer != 0) {
        ASSERT(!IsDisabledIF(IF));
        ASSERT(IF->Flags & IF_FLAG_ADVERTISES);

        if (Force) {
            //
            // Enter "fast" mode if this is a forced RA.
            //
            IF->RACount = MAX_INITIAL_RTR_ADVERTISEMENTS;
            goto GenerateRA;
        }

        //
        // Timer is running.  Decrement and check for expiration.
        //
        if (--IF->RATimer == 0) {
          GenerateRA:
            //
            // Timer went off. Check if rate-limiting
            // prevents us from sending an RA right now.
            //
            Now = IPv6TickCount;
            if ((uint)(Now - IF->RALast) < MIN_DELAY_BETWEEN_RAS) {
                //
                // We can not send an RA quite yet.
                // Re-arm the timer.
                //
                IF->RATimer = MIN_DELAY_BETWEEN_RAS - (uint)(Now - IF->RALast);
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                           "RouterAdvertTimeout(IF %p): "
                           "rate limit\n", IF));
            }
            else {
                //
                // Re-arm the timer.
                //
                IF->RATimer = RandomNumber(MinRtrAdvInterval,
                                           MaxRtrAdvInterval);

                //
                // Do we have an appropriate source address?
                // During boot, the link-local address
                // might still be tentative in which case we delay.
                //
                NTE = GetLinkLocalNTE(IF);
                if (NTE == NULL) {
                    NTE = IF->LinkLocalNTE;

                    if ((NTE != NULL) && IsTentativeNTE(NTE)) {
                        //
                        // Try again when DAD finishes.
                        //
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                                   "RouterAdvertTimeout(IF %p): "
                                   "wait for source\n", IF));
                        IF->RATimer = ((IF->RetransTimer * NTE->DADCount) +
                                       NTE->DADTimer);
                    }
                    else {
                        //
                        // Skip this opportunity to send an RA.
                        //
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                                   "RouterAdvertTimeout(IF %p): "
                                   "no source\n", IF));
                    }
                }
                else {
                    //
                    // Generate a router advertisement.
                    //
                    SendRouterAdvert = TRUE;
                    Source = NTE->Address;
                    IF->RALast = Now;

                    //
                    // If we are in "fast" mode, then ensure
                    // that the next RA is sent quickly.
                    //
                    if (IF->RACount != 0) {
                        IF->RACount--;
                        if (IF->RATimer > MAX_INITIAL_RTR_ADVERT_INTERVAL)
                            IF->RATimer = MAX_INITIAL_RTR_ADVERT_INTERVAL;
                    }
                }
            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&IF->Lock);

    if (SendRouterAdvert)
        RouterAdvertSend(IF, &Source, &AllNodesOnLinkAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\loopback.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IPv6 loopback interface pseudo-driver.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "llip6if.h"
#include "route.h"
#include "icmp.h"
#include "neighbor.h"
#include "security.h"
#include <ntddip6.h>

//
// We set the default loopback MTU to be smaller than the maximum,
// to avoid the use of jumbograms. In fact, we use the ethernet MTU
// because it appears TCP behaves poorly with large MTUs.
//
#define DEFAULT_LOOPBACK_MTU    1500            // Same as ethernet.
#define MAX_LOOPBACK_MTU        ((uint)-1)      // Effectively infinite.

KSPIN_LOCK LoopLock;
PNDIS_PACKET LoopTransmitHead = (PNDIS_PACKET)NULL;
PNDIS_PACKET LoopTransmitTail = (PNDIS_PACKET)NULL;
WORK_QUEUE_ITEM LoopWorkItem;
int LoopTransmitRunning = 0;

Interface *LoopInterface;     // Loopback interface.

//* LoopTransmit
//
//  This is the work item routine called for a loopback transmit.
//  Pull packets off the transmit queue and "send" them to ourselves
//  by the expedient of receiving them locally.
//
void
LoopTransmit(void *Context)    // Unused.
{
    KIRQL OriginalIrql;
    PNDIS_PACKET Packet;
    IPv6Packet IPPacket;
    int Rcvd = FALSE;
    int PktRefs;  // Packet references

    UNREFERENCED_PARAMETER(Context);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // All receive processing normally happens at DPC level,
    // so we must pretend to be a DPC, so we raise IRQL.
    // (System worker threads typically run at PASSIVE_LEVEL).
    //
    // Also block APCs while we're here, to make sure previous I/O requests
    // issued from this thread don't block the work-item queue.
    //
    KeEnterCriticalRegion();
    KeAcquireSpinLock(&LoopLock, &OriginalIrql);
    ASSERT(LoopTransmitRunning);

    for (;;) {
        //
        // Get the next packet from the queue.
        //
        Packet = LoopTransmitHead;
        if (Packet == NULL)
            break;

        LoopTransmitHead = *(PNDIS_PACKET *)Packet->MacReserved;
        KeReleaseSpinLockFromDpcLevel(&LoopLock);

        Rcvd = TRUE;

        //
        // Prepare IPv6Packet notification info from NDIS packet.
        //

        InitializePacketFromNdis(&IPPacket, Packet, PC(Packet)->pc_offset);
        IPPacket.NTEorIF = CastFromIF(PC(Packet)->IF);
        IPPacket.Flags |= PACKET_LOOPED_BACK;

        PktRefs = IPv6Receive(&IPPacket);

        ASSERT(PktRefs == 0);

        //
        // Prevent the packet from being sent again via loopback
        // from IPv6SendComplete.
        //
        PC(Packet)->Flags |= NDIS_FLAGS_DONT_LOOPBACK;
        IPv6SendComplete(PC(Packet)->IF, Packet, IP_SUCCESS);

        //
        // Give other threads a chance to run.
        //
        KeLowerIrql(OriginalIrql);
        KeAcquireSpinLock(&LoopLock, &OriginalIrql);
    }

    LoopTransmitRunning = FALSE;
    KeReleaseSpinLockFromDpcLevel(&LoopLock);

    if (Rcvd)
        IPv6ReceiveComplete();

    KeLowerIrql(OriginalIrql);
    KeLeaveCriticalRegion();
}


//* LoopQueueTransmit
//
//  This is the routine called when we need to transmit a packet to ourselves.
//  We put the packet on our loopback queue, and schedule an event to deal
//  with it.  All the real work is done in LoopTransmit.
//
//  LoopQueueTransmit is called directly from IPv6SendLL.
//  It is never called via LoopInterface->Transmit.
//
void
LoopQueueTransmit(PNDIS_PACKET Packet)
{
    PNDIS_PACKET *PacketPtr;
    KIRQL OldIrql;

    PacketPtr = (PNDIS_PACKET *)Packet->MacReserved;
    *PacketPtr = (PNDIS_PACKET)NULL;

    KeAcquireSpinLock(&LoopLock, &OldIrql);

    //
    // Add the packet to the end of the transmit queue.
    //
    if (LoopTransmitHead == (PNDIS_PACKET)NULL) {
        // Transmit queue is empty.
        LoopTransmitHead = Packet;
    } else {
        // Transmit queue is not empty.
        PacketPtr = (PNDIS_PACKET *)LoopTransmitTail->MacReserved;
        *PacketPtr = Packet;
    }
    LoopTransmitTail = Packet;

    //
    // If LoopTransmit is not already running, schedule it.
    //
    if (!LoopTransmitRunning) {
        ExQueueWorkItem(&LoopWorkItem, DelayedWorkQueue);
        LoopTransmitRunning = TRUE;
    }
    KeReleaseSpinLock(&LoopLock, OldIrql);
}


//* LoopbackTransmit
//
//  LoopbackTransmit can be called when a multicast packet is sent
//  on the loopback interface. It does nothing, because
//  loopback processing actually happens in LoopTransmit.
//
void
LoopbackTransmit(
    void *Context,              // Pointer to loopback interface.
    PNDIS_PACKET Packet,        // Pointer to packet to be transmitted.
    uint Offset,                // Offset from start of packet to IPv6 header.
    const void *LinkAddress)    // Link-level address.
{
    Interface *IF = (Interface *) Context;

    UNREFERENCED_PARAMETER(Offset);
    UNREFERENCED_PARAMETER(LinkAddress);

    IPv6SendComplete(IF, Packet, IP_SUCCESS);
}


//* LoopbackConvertAddr
//
//  Loopback does not use Neighbor Discovery or link-layer addresses.
//
ushort
LoopbackConvertAddr(
    void *Context,
    const IPv6Addr *Address,
    void *LinkAddress)
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Address);
    UNREFERENCED_PARAMETER(LinkAddress);

    return ND_STATE_PERMANENT;
}


//* LoopbackCreateToken
//
//  Initializes the interface identifer in the address.
//  For loopback, we use the interface index.
//
void
LoopbackCreateToken(void *Context, IPv6Addr *Address)
{
    Interface *IF = (Interface *)Context;

    *(ULONG UNALIGNED *)&Address->s6_bytes[8] = 0;
    *(ULONG UNALIGNED *)&Address->s6_bytes[12] = net_long(IF->Index);
}


#pragma BEGIN_INIT

//* CreateLoopbackInterface
//
//  Create a loopback interface.
//
Interface *
CreateLoopbackInterface(const char *InterfaceName)
{
    GUID Guid;
    LLIPv6BindInfo BindInfo;
    Interface *IF;
    NDIS_STATUS Status;

    //
    // A NULL lip_context indicates that we want to use
    // the IPv6 Interface structure instead.
    //
    BindInfo.lip_context = NULL;
    BindInfo.lip_maxmtu = MAX_LOOPBACK_MTU;
    BindInfo.lip_defmtu = DEFAULT_LOOPBACK_MTU;
    BindInfo.lip_flags = IF_FLAG_MULTICAST;
    BindInfo.lip_type = IF_TYPE_LOOPBACK;
    BindInfo.lip_hdrsize = 0;
    BindInfo.lip_addrlen = 0;
    BindInfo.lip_dadxmit = 0;
    BindInfo.lip_pref = 0;
    BindInfo.lip_addr = (uchar *)&LoopbackAddr;
    BindInfo.lip_token = LoopbackCreateToken;
    BindInfo.lip_rdllopt = NULL;
    BindInfo.lip_wrllopt = NULL;
    BindInfo.lip_cvaddr = LoopbackConvertAddr;
    BindInfo.lip_setrtrlladdr = NULL;
    BindInfo.lip_transmit = LoopbackTransmit;
    BindInfo.lip_mclist = NULL;
    BindInfo.lip_close = NULL;
    BindInfo.lip_cleanup = NULL;

    CreateGUIDFromName(InterfaceName, &Guid);

    Status = CreateInterface(&Guid, &BindInfo, (void **)&IF);
    if (Status != NDIS_STATUS_SUCCESS)
        return NULL;
    else
        return IF;
}


//* LoopbackInit
//
//  This function initializes the loopback interface.
//
//  Returns FALSE if we fail to init properly.
//
int
LoopbackInit(void)
{
    int rc;

    //
    // Prepare a work item that we will later enqueue when we want
    // to execute LoopTransmit.
    // 
    ExInitializeWorkItem(&LoopWorkItem, LoopTransmit, NULL);
    KeInitializeSpinLock(&LoopLock);

    //
    // Create the loopback interface.
    //
    LoopInterface = CreateLoopbackInterface("Loopback Pseudo-Interface");
    if (LoopInterface == NULL)
        return FALSE;

    //
    // Create the usual loopback address.
    //
    rc = FindOrCreateNTE(LoopInterface, &LoopbackAddr,
                         ADDR_CONF_WELLKNOWN,
                         INFINITE_LIFETIME,
                         INFINITE_LIFETIME);

    //
    // Release the reference from CreateInterface.
    // The interface still has a reference for itself
    // by virtue of being active.
    //
    ReleaseIF(LoopInterface);

    return rc;
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\ntirp.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// NT specific routines for dispatching and handling IRPs.
//


#include <oscfg.h>
#include <ndis.h>
#include <ip6imp.h>
#include "ip6def.h"
#include "icmp.h"
#include "ipsec.h"
#include "security.h"
#include "route.h"
#include "select.h"
#include "neighbor.h"
#include <ntddip6.h>
#include "ntreg.h"
#include <string.h>
#include <wchar.h>
#include "fragment.h"
#include "mobile.h"

//
// Local structures.
//
typedef struct pending_irp {
    LIST_ENTRY Linkage;
    PIRP Irp;
    PFILE_OBJECT FileObject;
    PVOID Context;
} PENDING_IRP, *PPENDING_IRP;


//
// Global variables.
//
LIST_ENTRY PendingEchoList;


//
// Local prototypes.
//
BOOLEAN
IsRunningOnWorkstation(VOID);

NTSTATUS
IPDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
IPDispatchDeviceControl(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IPCreate(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IPCleanup(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IPClose(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
DispatchEchoRequest(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

void
CompleteEchoRequest(void *Context, IP_STATUS Status,
                    const IPv6Addr *Address, uint ScopeId,
                    void *Data, uint DataSize);

NTSTATUS
IoctlQueryInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlPersistentQueryInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQueryAddress(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlPersistentQueryAddress(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQueryNeighborCache(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQueryRouteCache(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlCreateSecurityPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQuerySecurityPolicyList(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlDeleteSecurityPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlCreateSecurityAssociation(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQuerySecurityAssociationList(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlDeleteSecurityAssociation(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQueryRouteTable(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlPersistentQueryRouteTable(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlUpdateRouteTable(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                      IN int Persistent);

NTSTATUS
IoctlUpdateAddress(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                   IN int Persistent);

NTSTATUS
IoctlQueryBindingCache(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlCreateInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                     IN int Persistent);

NTSTATUS
IoctlUpdateInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                     IN int Persistent);

NTSTATUS
IoctlDeleteInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                     IN int Persistent);

NTSTATUS
IoctlFlushNeighborCache(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlFlushRouteCache(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlSortDestAddrs(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQuerySitePrefix(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlUpdateSitePrefix(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlRtChangeNotifyRequest(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlQueryGlobalParameters(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                           IN int Persistent);

NTSTATUS
IoctlUpdateGlobalParameters(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                            IN int Persistent);

NTSTATUS
IoctlQueryPrefixPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlPersistentQueryPrefixPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlUpdatePrefixPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                        IN int Persistent);

NTSTATUS
IoctlDeletePrefixPolicy(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                        IN int Persistent);

NTSTATUS
IoctlUpdateRouterLLAddress(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

NTSTATUS
IoctlResetManualConfig(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp,
                       IN int Persistent);

NTSTATUS
IoctlRenewInterface(IN PIRP Irp, IN PIO_STACK_LOCATION IrpSp);

//
// All of this code is pageable.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IPDispatch)
#pragma alloc_text(PAGE, IPDispatchDeviceControl)
#pragma alloc_text(PAGE, IPCreate)
#pragma alloc_text(PAGE, IPClose)
#pragma alloc_text(PAGE, DispatchEchoRequest)

#endif // ALLOC_PRAGMA


//
// Dispatch function definitions.
//

//* IPDispatch
//
//  This is the dispatch routine for IP.
//
NTSTATUS  // Returns: whether the request was successfully queued.
IPDispatch(
    IN PDEVICE_OBJECT DeviceObject,  // Device object for target device.
    IN PIRP Irp)                     // I/O request packet.
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);
    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->MajorFunction) {

    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        return IPDispatchDeviceControl(Irp, irpSp);

    case IRP_MJ_CREATE:
        status = IPCreate(Irp, irpSp);
        break;

    case IRP_MJ_CLEANUP:
        status = IPCleanup(Irp, irpSp);
        break;

    case IRP_MJ_CLOSE:
        status = IPClose(Irp, irpSp);
        break;

    default:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "IPDispatch: Invalid major function %d\n",
                   irpSp->MajorFunction));
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

} // IPDispatch


//* IPDispatchDeviceControl
//
NTSTATUS  // Returns: whether the request was successfully queued.
IPDispatchDeviceControl(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    ULONG code;

    PAGED_CODE();

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch (code) {

    case IOCTL_ICMPV6_ECHO_REQUEST:
        return DispatchEchoRequest(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_INTERFACE:
        return IoctlQueryInterface(Irp, IrpSp);

    case IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE:
        return IoctlPersistentQueryInterface(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_ADDRESS:
        return IoctlQueryAddress(Irp, IrpSp);

    case IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS:
        return IoctlPersistentQueryAddress(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_NEIGHBOR_CACHE:
        return IoctlQueryNeighborCache(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_ROUTE_CACHE:
        return IoctlQueryRouteCache(Irp, IrpSp);

    case IOCTL_IPV6_CREATE_SECURITY_POLICY:
        return IoctlCreateSecurityPolicy(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_SECURITY_POLICY_LIST:
        return IoctlQuerySecurityPolicyList(Irp, IrpSp);

    case IOCTL_IPV6_DELETE_SECURITY_POLICY:
        return IoctlDeleteSecurityPolicy(Irp, IrpSp);

    case IOCTL_IPV6_CREATE_SECURITY_ASSOCIATION:
        return IoctlCreateSecurityAssociation(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_SECURITY_ASSOCIATION_LIST:
        return IoctlQuerySecurityAssociationList(Irp, IrpSp);

    case IOCTL_IPV6_DELETE_SECURITY_ASSOCIATION:
        return IoctlDeleteSecurityAssociation(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_ROUTE_TABLE:
        return IoctlQueryRouteTable(Irp, IrpSp);

    case IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE:
        return IoctlPersistentQueryRouteTable(Irp, IrpSp);

    case IOCTL_IPV6_UPDATE_ROUTE_TABLE:
        return IoctlUpdateRouteTable(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_UPDATE_ROUTE_TABLE:
        return IoctlUpdateRouteTable(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_UPDATE_ADDRESS:
        return IoctlUpdateAddress(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_UPDATE_ADDRESS:
        return IoctlUpdateAddress(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_QUERY_BINDING_CACHE:
        return IoctlQueryBindingCache(Irp, IrpSp);

    case IOCTL_IPV6_CREATE_INTERFACE:
        return IoctlCreateInterface(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_CREATE_INTERFACE:
        return IoctlCreateInterface(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_UPDATE_INTERFACE:
        return IoctlUpdateInterface(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_UPDATE_INTERFACE:
        return IoctlUpdateInterface(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_DELETE_INTERFACE:
        return IoctlDeleteInterface(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_DELETE_INTERFACE:
        return IoctlDeleteInterface(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE:
        return IoctlFlushNeighborCache(Irp, IrpSp);

    case IOCTL_IPV6_FLUSH_ROUTE_CACHE:
        return IoctlFlushRouteCache(Irp, IrpSp);

    case IOCTL_IPV6_SORT_DEST_ADDRS:
        return IoctlSortDestAddrs(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_SITE_PREFIX:
        return IoctlQuerySitePrefix(Irp, IrpSp);

    case IOCTL_IPV6_UPDATE_SITE_PREFIX:
        return IoctlUpdateSitePrefix(Irp, IrpSp);

    case IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST:
        return IoctlRtChangeNotifyRequest(Irp, IrpSp);

    case IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS:
        return IoctlQueryGlobalParameters(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_QUERY_GLOBAL_PARAMETERS:
        return IoctlQueryGlobalParameters(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS:
        return IoctlUpdateGlobalParameters(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_UPDATE_GLOBAL_PARAMETERS:
        return IoctlUpdateGlobalParameters(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_QUERY_PREFIX_POLICY:
        return IoctlQueryPrefixPolicy(Irp, IrpSp);

    case IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY:
        return IoctlPersistentQueryPrefixPolicy(Irp, IrpSp);

    case IOCTL_IPV6_UPDATE_PREFIX_POLICY:
        return IoctlUpdatePrefixPolicy(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_UPDATE_PREFIX_POLICY:
        return IoctlUpdatePrefixPolicy(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_DELETE_PREFIX_POLICY:
        return IoctlDeletePrefixPolicy(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_DELETE_PREFIX_POLICY:
        return IoctlDeletePrefixPolicy(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS:
        return IoctlUpdateRouterLLAddress(Irp, IrpSp);

    case IOCTL_IPV6_RESET:
        return IoctlResetManualConfig(Irp, IrpSp, FALSE);

    case IOCTL_IPV6_PERSISTENT_RESET:
        return IoctlResetManualConfig(Irp, IrpSp, TRUE);

    case IOCTL_IPV6_RENEW_INTERFACE:
        return IoctlRenewInterface(Irp, IrpSp);

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return status;

} // IPDispatchDeviceControl

#ifdef DEBUG_OBJECTS
LIST_ENTRY FileObjectList;
KSPIN_LOCK FileObjectLock;

typedef struct _FILE_OBJECT_ENTRY {
    LIST_ENTRY Link;
    PFILE_OBJECT FileObject;
} FILE_OBJECT_ENTRY, *PFILE_OBJECT_ENTRY;
#endif


//* IPCreate
//
NTSTATUS  // Returns: whether the request was successfully queued.
IPCreate(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
#ifdef DEBUG_OBJECTS
    PFILE_OBJECT_ENTRY Foe;
    KIRQL OldIrql;

    Foe = ExAllocatePool(NonPagedPool, sizeof(FILE_OBJECT_ENTRY));
    if (Foe == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Foe->FileObject = IrpSp->FileObject;

    KeAcquireSpinLock(&FileObjectLock, &OldIrql);
    InsertTailList(&FileObjectList, &Foe->Link);
    KeReleaseSpinLock(&FileObjectLock, OldIrql);
#else
    UNREFERENCED_PARAMETER(IrpSp);
#endif

    UNREFERENCED_PARAMETER(Irp);

    PAGED_CODE();

    return(STATUS_SUCCESS);

} // IPCreate


//* IPCleanup
//
NTSTATUS  // Returns: whether the request was successfully queued.
IPCleanup(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    PPENDING_IRP pendingIrp;
    PLIST_ENTRY entry, nextEntry;
    KIRQL oldIrql;
    LIST_ENTRY completeList;
    PIRP cancelledIrp;

    UNREFERENCED_PARAMETER(Irp);

    InitializeListHead(&completeList);

    //
    // Collect all of the pending IRPs on this file object.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    entry = PendingEchoList.Flink;

    while ( entry != &PendingEchoList ) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);

        if (pendingIrp->FileObject == IrpSp->FileObject) {
            nextEntry = entry->Flink;
            RemoveEntryList(entry);
            IoSetCancelRoutine(pendingIrp->Irp, NULL);
            InsertTailList(&completeList, &(pendingIrp->Linkage));
            entry = nextEntry;
        }
        else {
            entry = entry->Flink;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    //
    // Complete them.
    //
    entry = completeList.Flink;

    while ( entry != &completeList ) {
        pendingIrp = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        cancelledIrp = pendingIrp->Irp;
        entry = entry->Flink;

        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        ExFreePool(pendingIrp);

        //
        // Complete the IRP.
        //
        cancelledIrp->IoStatus.Information = 0;
        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(cancelledIrp, IO_NETWORK_INCREMENT);
    }

    return(STATUS_SUCCESS);

} // IPCleanup


//* IPClose
//
NTSTATUS  // Returns: whether the request was successfully queued.
IPClose(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
#ifdef DEBUG_OBJECTS
    PFILE_OBJECT_ENTRY Foe = NULL;
    KIRQL OldIrql;
    PLIST_ENTRY ple;

    KeAcquireSpinLock(&FileObjectLock, &OldIrql);

    for (ple = FileObjectList.Flink;
         ple != &FileObjectList;
         ple = ple->Flink) {
        Foe = CONTAINING_RECORD(ple, FILE_OBJECT_ENTRY, Link);
        if (Foe->FileObject == IrpSp->FileObject) {
            break;
        }
    }
    ASSERT(ple != &FileObjectList);

    if (Foe != NULL) {
        RemoveEntryList(&Foe->Link);
        ExFreePool(Foe);
    }

    KeReleaseSpinLock(&FileObjectLock, OldIrql);
#else
    UNREFERENCED_PARAMETER(IrpSp);
#endif

    UNREFERENCED_PARAMETER(Irp);

    PAGED_CODE();

    return(STATUS_SUCCESS);

} // IPClose


//
// ICMP Echo function definitions
//

//* CancelEchoRequest
//
//  This function is called with cancel spinlock held.  It must be
//  released before the function returns.
//
//  The echo control block associated with this request cannot be
//  freed until the request completes.  The completion routine will
//  free it.
//
VOID
CancelEchoRequest(
    IN PDEVICE_OBJECT Device,  // Device on which the request was issued.
    IN PIRP Irp)               // I/O request packet to cancel.
{
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    UNREFERENCED_PARAMETER(Device);

    for ( entry = PendingEchoList.Flink;
          entry != &PendingEchoList;
          entry = entry->Flink
        ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Irp == Irp) {
            pendingIrp = item;
            RemoveEntryList(entry);
            IoSetCancelRoutine(pendingIrp->Irp, NULL);
            break;
        }
    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (pendingIrp != NULL) {
        //
        // Free the PENDING_IRP structure. The control block will be freed
        // when the request completes.
        //
        ExFreePool(pendingIrp);

        //
        // Complete the IRP.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }

    return;

} // CancelEchoRequest


//* CompleteEchoRequest
//
//  Handles the completion of an ICMP Echo request.
//
void
CompleteEchoRequest(
    void *Context,     // EchoControl structure for this request.
    IP_STATUS Status,  // Status of the transmission.
    const IPv6Addr *Address, // Source of the echo reply.
    uint ScopeId,      // Scope of the echo reply source.
    void *Data,        // Pointer to data returned in the echo reply.
    uint DataSize)     // Lengh of the returned data.
{
    KIRQL oldIrql;
    PIRP irp = NULL;
    EchoControl *controlBlock;
    PPENDING_IRP pendingIrp = NULL;
    PPENDING_IRP item;
    PLIST_ENTRY entry;

    controlBlock = (EchoControl *) Context;

    //
    // Find the echo request IRP on the pending list.
    //
    IoAcquireCancelSpinLock(&oldIrql);

    for ( entry = PendingEchoList.Flink;
          entry != &PendingEchoList;
          entry = entry->Flink
        ) {
        item = CONTAINING_RECORD(entry, PENDING_IRP, Linkage);
        if (item->Context == controlBlock) {
            pendingIrp = item;
            irp = pendingIrp->Irp;
            IoSetCancelRoutine(irp, NULL);
            RemoveEntryList(entry);
            break;
        }
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (pendingIrp == NULL) {
        //
        // IRP must have been cancelled. PENDING_IRP struct
        // was freed by cancel routine. Free control block.
        //
        ExFreePool(controlBlock);
        return;
    }

    irp->IoStatus.Status = ICMPv6EchoComplete(
        controlBlock,
        Status,
        Address,
        ScopeId,
        Data,
        DataSize,
        &irp->IoStatus.Information
        );

    ExFreePool(pendingIrp);
    ExFreePool(controlBlock);

    //
    // Complete the IRP.
    //
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

} // CompleteEchoRequest


//* PrepareEchoIrpForCancel
//
//  Prepares an Echo IRP for cancellation.
//
BOOLEAN  // Returns: TRUE if IRP was already cancelled, FALSE otherwise.
PrepareEchoIrpForCancel(
    PIRP Irp,                 // I/O request packet to init for cancellation.
    PPENDING_IRP PendingIrp)  // PENDING_IRP structure for this IRP.
{
    BOOLEAN cancelled = TRUE;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {
        IoSetCancelRoutine(Irp, CancelEchoRequest);
        InsertTailList(&PendingEchoList, &(PendingIrp->Linkage));
        cancelled = FALSE;
    }

    IoReleaseCancelSpinLock(oldIrql);

    return(cancelled);

} // PrepareEchoIrpForCancel


//* DispatchEchoRequest
//
//  Processes an ICMP request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful. The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
DispatchEchoRequest(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPENDING_IRP pendingIrp;
    EchoControl *controlBlock;
    BOOLEAN cancelled;

    PAGED_CODE();

    pendingIrp = ExAllocatePool(NonPagedPool, sizeof(PENDING_IRP));

    if (pendingIrp == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto echo_error;
    }

    controlBlock = ExAllocatePool(NonPagedPool, sizeof(EchoControl));

    if (controlBlock == NULL) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto echo_error_free_pending;
    }

    pendingIrp->Irp = Irp;
    pendingIrp->FileObject = IrpSp->FileObject;
    pendingIrp->Context = controlBlock;

    controlBlock->WhenIssued = KeQueryPerformanceCounter(NULL);
    controlBlock->ReplyBuf = Irp->AssociatedIrp.SystemBuffer;
    controlBlock->ReplyBufLen =
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    IoMarkIrpPending(Irp);

    cancelled = PrepareEchoIrpForCancel(Irp, pendingIrp);

    if (!cancelled) {
        ICMPv6EchoRequest(
            Irp->AssociatedIrp.SystemBuffer,                     // request buf
            IrpSp->Parameters.DeviceIoControl.InputBufferLength, // request len
            controlBlock,                                        // echo ctrl
            CompleteEchoRequest                                  // cmplt rtn
            );

        return STATUS_PENDING;
    }

    //
    // Irp has already been cancelled.
    //
    ntStatus = STATUS_CANCELLED;
    ExFreePool(controlBlock);
  echo_error_free_pending:
    ExFreePool(pendingIrp);

  echo_error:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(ntStatus);

} // DispatchEchoRequest

//* FindInterfaceFromQuery
//
//  Given an IPV6_QUERY_INTERFACE structure,
//  finds the specified interface.
//  The interface (if found) is returned with a reference.
//
Interface *
FindInterfaceFromQuery(
    IPV6_QUERY_INTERFACE *Query)
{
    Interface *IF;

    if (Query->Index == 0)
        IF = FindInterfaceFromGuid(&Query->Guid);
    else
        IF = FindInterfaceFromIndex(Query->Index);

    return IF;
}

//* ReturnQueryInterface
//
//  Initializes a returned IPV6_QUERY_INTERFACE structure
//  with query information for the specified interface.
//
void
ReturnQueryInterface(
    Interface *IF,
    IPV6_QUERY_INTERFACE *Query)
{
    if (IF == NULL) {
        Query->Index = (uint)-1;
        RtlZeroMemory(&Query->Guid, sizeof Query->Guid);
    }
    else {
        Query->Index = IF->Index;
        Query->Guid = IF->Guid;
    }
}

//* ReturnQueryInterfaceNext
//
//  Initializes a returned IPV6_QUERY_INTERFACE structure
//  with query information for the next interface
//  after the specified interface. (Or the first interface,
//  if the specified interface is NULL.)
//
void
ReturnQueryInterfaceNext(
    Interface *IF,
    IPV6_QUERY_INTERFACE *Query)
{
    IF = FindNextInterface(IF);
    ReturnQueryInterface(IF, Query);
    if (IF != NULL)
        ReleaseIF(IF);
}

//* IoctlQueryInterface
//
//  Processes an IOCTL_IPV6_QUERY_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful. The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_INTERFACE *Query;
    IPV6_INFO_INTERFACE *Info;
    Interface *IF;
    NTSTATUS Status;
    uint LinkLayerAddressesLength;
    uchar *LinkLayerAddress;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;

    if (Query->Index == (uint)-1) {
        //
        // Return query information for the first interface.
        //
        ReturnQueryInterfaceNext(NULL, &Info->Next);
        Irp->IoStatus.Information = sizeof Info->Next;

    } else {
        //
        // Return information about the specified interface.
        //
        IF = FindInterfaceFromQuery(Query);
        if (IF == NULL) {
            Status = STATUS_INVALID_PARAMETER_1;
            goto Return;
        }

        Irp->IoStatus.Information = sizeof *Info;
        Info->Length = sizeof *Info;

        //
        // Return query information for the next interface.
        //
        ReturnQueryInterfaceNext(IF, &Info->Next);

        //
        // Return miscellaneous information about the interface.
        //
        ReturnQueryInterface(IF, &Info->This);
        RtlCopyMemory(Info->ZoneIndices, IF->ZoneIndices,
                      sizeof Info->ZoneIndices);
        Info->TrueLinkMTU = IF->TrueLinkMTU;
        Info->LinkMTU = IF->LinkMTU;
        Info->CurHopLimit = IF->CurHopLimit;
        Info->BaseReachableTime = IF->BaseReachableTime;
        Info->ReachableTime = ConvertTicksToMillis(IF->ReachableTime);
        Info->RetransTimer = ConvertTicksToMillis(IF->RetransTimer);
        Info->DupAddrDetectTransmits = IF->DupAddrDetectTransmits;

        Info->Type = IF->Type;
        Info->RouterDiscovers = !!(IF->Flags & IF_FLAG_ROUTER_DISCOVERS);
        Info->NeighborDiscovers = !!(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS);
        Info->PeriodicMLD = !!(IF->Flags & IF_FLAG_PERIODICMLD);
        Info->Advertises = !!(IF->Flags & IF_FLAG_ADVERTISES);
        Info->Forwards = !!(IF->Flags & IF_FLAG_FORWARDS);
        Info->OtherStatefulConfig = !!(IF->Flags & IF_FLAG_OTHER_STATEFUL_CONFIG);
        if (IF->Flags & IF_FLAG_MEDIA_DISCONNECTED)
            Info->MediaStatus = IPV6_IF_MEDIA_STATUS_DISCONNECTED;
        else if (IF->Flags & IF_FLAG_MEDIA_RECONNECTED)
            Info->MediaStatus = IPV6_IF_MEDIA_STATUS_RECONNECTED;
        else
            Info->MediaStatus = IPV6_IF_MEDIA_STATUS_CONNECTED;
        Info->Preference = IF->Preference;
        Info->FirewallEnabled = !!(IF->Flags & IF_FLAG_FIREWALL_ENABLED);
        Info->DefSitePrefixLength = IF->DefSitePrefixLength;

        //
        // Return the interface's link-layer addresses,
        // if there is room in the user's buffer.
        //
        Info->LinkLayerAddressLength = IF->LinkAddressLength;
        Info->LocalLinkLayerAddress = 0;
        Info->RemoteLinkLayerAddress = 0;

        if (IF->Type == IF_TYPE_TUNNEL_AUTO) {
            LinkLayerAddressesLength = 2 * IF->LinkAddressLength;
        }
        else {
            LinkLayerAddressesLength = 0;
            if (!(IF->Flags & IF_FLAG_PSEUDO))
                LinkLayerAddressesLength += IF->LinkAddressLength;
            if (IF->Flags & IF_FLAG_P2P)
                LinkLayerAddressesLength += IF->LinkAddressLength;
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof *Info + LinkLayerAddressesLength) {

            //
            // Return the fixed-size portion of the structure.
            //
            Status = STATUS_BUFFER_OVERFLOW;
            ReleaseIF(IF);
            goto Return;
        }

        LinkLayerAddress = (uchar *)(Info + 1);
        if (IF->Type == IF_TYPE_TUNNEL_AUTO) {
            //
            // For ISATAP (automatic tunnels), TokenAddr corresponds to
            // LocalLinkLayerAddress and DstAddr to RemoteLinkLayerAddress.
            //
            RtlCopyMemory(LinkLayerAddress,
                          IF->LinkAddress + IF->LinkAddressLength,
                          2 * IF->LinkAddressLength);
            Info->RemoteLinkLayerAddress = (uint)
                (LinkLayerAddress - (uchar *)Info);
            Info->LocalLinkLayerAddress = Info->RemoteLinkLayerAddress +
                IF->LinkAddressLength;
        }
        else {
            if (!(IF->Flags & IF_FLAG_PSEUDO)) {
                RtlCopyMemory(LinkLayerAddress, IF->LinkAddress,
                              IF->LinkAddressLength);
                Info->LocalLinkLayerAddress = (uint)
                    (LinkLayerAddress - (uchar *)Info);
                LinkLayerAddress += IF->LinkAddressLength;
            }
            if (IF->Flags & IF_FLAG_P2P) {
                RtlCopyMemory(LinkLayerAddress,
                              IF->LinkAddress + IF->LinkAddressLength,
                              IF->LinkAddressLength);
                Info->RemoteLinkLayerAddress = (uint)
                    (LinkLayerAddress - (uchar *)Info);
                LinkLayerAddress += IF->LinkAddressLength;
            }
        }
        Irp->IoStatus.Information += LinkLayerAddressesLength;

        ReleaseIF(IF);
    }

    Status = STATUS_SUCCESS;
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryInterface

//* OpenInterfaceRegKey
//
//  Given an interface guid, opens the registry key that holds
//  persistent configuration information for the interface.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
OpenInterfaceRegKey(
    const GUID *Guid,
    HANDLE *RegKey,
    OpenRegKeyAction Action)
{
    UNICODE_STRING GuidName;
    HANDLE InterfacesKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenTopLevelRegKey(L"Interfaces", &InterfacesKey,
                                ((Action == OpenRegKeyCreate) ?
                                 OpenRegKeyCreate : OpenRegKeyRead));
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Convert the guid to string form.
    // It will be null-terminated.
    //
    Status = RtlStringFromGUID(Guid, &GuidName);
    if (! NT_SUCCESS(Status))
        goto ReturnCloseKey;

    ASSERT(GuidName.MaximumLength == GuidName.Length + sizeof(WCHAR));
    ASSERT(((WCHAR *)GuidName.Buffer)[GuidName.Length/sizeof(WCHAR)] == UNICODE_NULL);

    Status = OpenRegKey(RegKey, InterfacesKey,
                        (WCHAR *)GuidName.Buffer, Action);

    RtlFreeUnicodeString(&GuidName);
ReturnCloseKey:
    ZwClose(InterfacesKey);
    return Status;
}

//* ReadPersistentInterface
//
//  Reads interface attributes from the registry key.
//  Initializes all the fields except This and Next.
//
//  On input, the Length field should contain the remaining space
//  for link-layer addresses. On output, it contains the amount
//  of space for link-layer addresses that was actually used.
//
//  Returns:
//      STATUS_INVALID_PARAMETER        Could not read the interface.
//      STATUS_BUFFER_OVERFLOW          No room for link-layer addresses.
//      STATUS_SUCCESS
//
NTSTATUS
ReadPersistentInterface(
    HANDLE IFKey,
    IPV6_INFO_INTERFACE *Info)
{
    uint LinkLayerAddressSpace;
    NTSTATUS Status;

    InitRegDWORDParameter(IFKey, L"Type",
                          (uint *)&Info->Type, (uint)-1);
    InitRegDWORDParameter(IFKey, L"RouterDiscovers",
                          (uint *)&Info->RouterDiscovers, (uint)-1);
    InitRegDWORDParameter(IFKey, L"NeighborDiscovers",
                          (uint *)&Info->NeighborDiscovers, (uint)-1);
    InitRegDWORDParameter(IFKey, L"PeriodicMLD",
                          (uint *)&Info->PeriodicMLD, (uint)-1);
    InitRegDWORDParameter(IFKey, L"Advertises",
                          (uint *)&Info->Advertises, (uint)-1);
    InitRegDWORDParameter(IFKey, L"Forwards",
                          (uint *)&Info->Forwards, (uint)-1);
    Info->MediaStatus = (uint)-1;
    memset(Info->ZoneIndices, 0, sizeof Info->ZoneIndices);
    Info->TrueLinkMTU = 0;
    InitRegDWORDParameter(IFKey, L"LinkMTU",
                          &Info->LinkMTU, 0);
    InitRegDWORDParameter(IFKey, L"CurHopLimit",
                          &Info->CurHopLimit, (uint)-1);
    InitRegDWORDParameter(IFKey, L"BaseReachableTime",
                          &Info->BaseReachableTime, 0);
    Info->ReachableTime = 0;
    InitRegDWORDParameter(IFKey, L"RetransTimer",
                          &Info->RetransTimer, 0);
    InitRegDWORDParameter(IFKey, L"DupAddrDetectTransmits",
                          &Info->DupAddrDetectTransmits, (uint)-1);
    InitRegDWORDParameter(IFKey, L"Preference",
                          &Info->Preference, (uint)-1);
    InitRegDWORDParameter(IFKey, L"FirewallEnabled",
                          (uint *)&Info->FirewallEnabled, (uint)-1);
    InitRegDWORDParameter(IFKey, L"DefSitePrefixLength",
                          &Info->DefSitePrefixLength, (uint)-1);

    //
    // Start by assuming we will not return link-layer addresses.
    //
    Info->LocalLinkLayerAddress = 0;
    Info->RemoteLinkLayerAddress = 0;

    //
    // But depending on the interface type they may be in the registry.
    //
    switch (Info->Type) {
    case IF_TYPE_TUNNEL_6OVER4: {
        IPAddr *SrcAddr;

        Info->LinkLayerAddressLength = sizeof(IPAddr);
        LinkLayerAddressSpace = Info->LinkLayerAddressLength;
        if (Info->Length < LinkLayerAddressSpace)
            return STATUS_BUFFER_OVERFLOW;
        Info->Length = LinkLayerAddressSpace;

        //
        // Read the source address.
        //
        SrcAddr = (IPAddr *)(Info + 1);
        Status = GetRegIPAddrValue(IFKey, L"SrcAddr", SrcAddr);
        if (! NT_SUCCESS(Status))
            return STATUS_NO_MORE_ENTRIES;
        Info->LocalLinkLayerAddress = (uint)
            ((uchar *)SrcAddr - (uchar *)Info);
        break;
    }

    case IF_TYPE_TUNNEL_V6V4: {
        IPAddr *SrcAddr, *DstAddr;

        Info->LinkLayerAddressLength = sizeof(IPAddr);
        LinkLayerAddressSpace = 2 * Info->LinkLayerAddressLength;
        if (Info->Length < LinkLayerAddressSpace)
            return STATUS_BUFFER_OVERFLOW;
        Info->Length = LinkLayerAddressSpace;

        //
        // Read the source address.
        //
        SrcAddr = (IPAddr *)(Info + 1);
        Status = GetRegIPAddrValue(IFKey, L"SrcAddr", SrcAddr);
        if (! NT_SUCCESS(Status))
            return STATUS_INVALID_PARAMETER;
        Info->LocalLinkLayerAddress = (uint)
            ((uchar *)SrcAddr - (uchar *)Info);

        //
        // Read the destination address.
        //
        DstAddr = SrcAddr + 1;
        Status = GetRegIPAddrValue(IFKey, L"DstAddr", DstAddr);
        if (! NT_SUCCESS(Status))
            return STATUS_INVALID_PARAMETER;
        Info->RemoteLinkLayerAddress = (uint)
            ((uchar *)DstAddr - (uchar *)Info);
        break;
    }

    default:
        Info->LinkLayerAddressLength = (uint) -1;
        Info->Length = 0;
        break;
    }

    return STATUS_SUCCESS;
}

//* OpenPersistentInterface
//
//  Parses an interface key name into a guid
//  and opens the interface key.
//
NTSTATUS
OpenPersistentInterface(
    HANDLE ParentKey,
    WCHAR *SubKeyName,
    GUID *Guid,
    HANDLE *IFKey,
    OpenRegKeyAction Action)
{
    UNICODE_STRING UGuid;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First, parse the interface guid.
    //
    RtlInitUnicodeString(&UGuid, SubKeyName);
    Status = RtlGUIDFromString(&UGuid, Guid);
    if (! NT_SUCCESS(Status)) {
        //
        // Not a valid guid.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentInterface: bad syntax %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Open the interface key.
    //
    Status = OpenRegKey(IFKey, ParentKey, SubKeyName, Action);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the interface key.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentInterface: bad key %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    return STATUS_SUCCESS;
}

//* EnumPersistentInterface
//
//  Helper function for FindPersistentInterfaceFromQuery,
//  wrapping OpenPersistentInterface for EnumRegKeyIndex.
//
NTSTATUS
EnumPersistentInterface(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    struct {
        GUID *Guid;
        HANDLE *IFKey;
        OpenRegKeyAction Action;
    } *Args = Context;

    PAGED_CODE();

    return OpenPersistentInterface(ParentKey, SubKeyName,
                                   Args->Guid,
                                   Args->IFKey,
                                   Args->Action);
}

//* FindPersistentInterfaceFromQuery
//
//  Given an IPV6_PERSISTENT_QUERY_INTERFACE structure,
//  finds the specified interface key in the registry.
//  If the interface key is found, then Query->Guid is returned.
//
NTSTATUS
FindPersistentInterfaceFromQuery(
    IPV6_PERSISTENT_QUERY_INTERFACE *Query,
    HANDLE *IFKey)
{
    NTSTATUS Status;

    if (Query->RegistryIndex == (uint)-1) {
        //
        // Persistent query via guid.
        //
        return OpenInterfaceRegKey(&Query->Guid, IFKey, OpenRegKeyRead);
    }
    else {
        HANDLE InterfacesKey;
        struct {
            GUID *Guid;
            HANDLE *IFKey;
            OpenRegKeyAction Action;
        } Args;

        //
        // Persistent query via registry index.
        //

        Status = OpenTopLevelRegKey(L"Interfaces", &InterfacesKey,
                                    OpenRegKeyRead);
        if (! NT_SUCCESS(Status)) {
            //
            // If the Interfaces subkey is not present,
            // then the index is not present.
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                Status = STATUS_NO_MORE_ENTRIES;
            return Status;
        }

        Args.Guid = &Query->Guid;
        Args.IFKey = IFKey;
        Args.Action = OpenRegKeyRead;

        Status = EnumRegKeyIndex(InterfacesKey,
                                 Query->RegistryIndex,
                                 EnumPersistentInterface,
                                 &Args);
        ZwClose(InterfacesKey);
        return Status;
    }
}

//* IoctlPersistentQueryInterface
//
//  Processes an IOCTL_IPV6_PERSISTENT_QUERY_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful. The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlPersistentQueryInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_PERSISTENT_QUERY_INTERFACE *Query;
    IPV6_INFO_INTERFACE *Info;
    HANDLE IFKey;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_PERSISTENT_QUERY_INTERFACE *)
        Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_INTERFACE *)
        Irp->AssociatedIrp.SystemBuffer;

    Status = FindPersistentInterfaceFromQuery(Query, &IFKey);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // Let ReadPersistentInterface know how much space is available
    // for link-layer addresses. It will use this field to return
    // how much space it actually used.
    //
    Info->Length = (IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
                    sizeof *Info);

    //
    // The interface index is not returned for persistent queries.
    //
    Info->This.Index = 0;
    Info->This.Guid = Query->Guid;

    Status = ReadPersistentInterface(IFKey, Info);
    ZwClose(IFKey);
    if (NT_SUCCESS(Status)) {
        //
        // Return link-layer addresses too.
        //
        Irp->IoStatus.Information = sizeof *Info + Info->Length;
        Status = STATUS_SUCCESS;
    }
    else if (Status == STATUS_BUFFER_OVERFLOW) {
        //
        // Return the fixed-size structure.
        //
        Irp->IoStatus.Information = sizeof *Info;
    }
    else
        goto Return;

    //
    // Do not return query information for the next interface,
    // since persistent iteration uses RegistryIndex.
    //
    ReturnQueryInterface(NULL, &Info->Next);
    Info->Length = sizeof *Info;

Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlPersistentQueryInterface

//* ReturnQueryAddress
//
//  Initializes a returned IPV6_QUERY_ADDRESS structure
//  with query information for the specified address.
//  Does NOT initialize Query->IF.
//
void
ReturnQueryAddress(
    AddressEntry *ADE,
    IPV6_QUERY_ADDRESS *Query)
{
    if (ADE == NULL)
        Query->Address = UnspecifiedAddr;
    else
        Query->Address = ADE->Address;
}

//* IoctlQueryAddress
//
//  Processes an IOCTL_IPV6_QUERY_ADDRESS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_ADDRESS *Query;
    IPV6_INFO_ADDRESS *Info;
    Interface *IF = NULL;
    AddressEntry *ADE;
    KIRQL OldIrql;
    NTSTATUS Status;

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Next structures overlap!
    //
    Query = (IPV6_QUERY_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Return information about the specified interface.
    //
    IF = FindInterfaceFromQuery(&Query->IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    if (IsUnspecified(&Query->Address)) {
        //
        // Return the address of the first ADE.
        //
        KeAcquireSpinLock(&IF->Lock, &OldIrql);
        ReturnQueryAddress(IF->ADE, &Info->Next);
        KeReleaseSpinLock(&IF->Lock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Next;
    } else {
        //
        // Find the specified ADE.
        //
        KeAcquireSpinLock(&IF->Lock, &OldIrql);
        for (ADE = IF->ADE; ; ADE = ADE->Next) {
            if (ADE == NULL) {
                KeReleaseSpinLock(&IF->Lock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto ReturnReleaseIF;
            }

            if (IP6_ADDR_EQUAL(&Query->Address, &ADE->Address))
                break;
        }

        //
        // Return misc. information about the ADE.
        //
        Info->This = *Query;
        Info->Type = ADE->Type;
        Info->Scope = ADE->Scope;
        Info->ScopeId = DetermineScopeId(&ADE->Address, IF);

        switch (ADE->Type) {
        case ADE_UNICAST: {
            NetTableEntry *NTE = (NetTableEntry *)ADE;
            struct AddrConfEntry AddrConf;

            Info->DADState = NTE->DADState;
            AddrConf.Value = NTE->AddrConf;
            Info->PrefixConf = AddrConf.PrefixConf;
            Info->InterfaceIdConf = AddrConf.InterfaceIdConf;
            Info->ValidLifetime = ConvertTicksToSeconds(NTE->ValidLifetime);
            Info->PreferredLifetime = ConvertTicksToSeconds(NTE->PreferredLifetime);
            break;
        }
        case ADE_MULTICAST: {
            MulticastAddressEntry *MAE = (MulticastAddressEntry *)ADE;

            Info->MCastRefCount = MAE->MCastRefCount;
            Info->MCastFlags = MAE->MCastFlags;
            Info->MCastTimer = ConvertTicksToSeconds(MAE->MCastTimer);
            break;
        }
        }

        //
        // Return address of the next ADE.
        //
        ReturnQueryAddress(ADE->Next, &Info->Next);
        KeReleaseSpinLock(&IF->Lock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    ReturnQueryInterface(IF, &Info->Next.IF);
    Status = STATUS_SUCCESS;
ReturnReleaseIF:
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryAddress

//* OpenAddressRegKey
//
//  Given an interface's registry key and an IPv6 address,
//  opens the registry key with configuration info for the address.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
OpenAddressRegKey(HANDLE IFKey, const IPv6Addr *Addr,
                  OUT HANDLE *RegKey, OpenRegKeyAction Action)
{
    WCHAR AddressName[64];
    HANDLE AddressesKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenRegKey(&AddressesKey, IFKey, L"Addresses",
                        ((Action == OpenRegKeyCreate) ?
                         OpenRegKeyCreate : OpenRegKeyRead));
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // The output of RtlIpv6AddressToString may change
    // over time with improvements/changes in the pretty-printing,
    // and we need a consistent mapping.
    // It doesn't need to be pretty.
    //
    swprintf(AddressName,
             L"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
             net_short(Addr->s6_words[0]), net_short(Addr->s6_words[1]),
             net_short(Addr->s6_words[2]), net_short(Addr->s6_words[3]),
             net_short(Addr->s6_words[4]), net_short(Addr->s6_words[5]),
             net_short(Addr->s6_words[6]), net_short(Addr->s6_words[7]));

    Status = OpenRegKey(RegKey, AddressesKey, AddressName, Action);
    ZwClose(AddressesKey);
    return Status;
}

//* OpenPersistentAddress
//
//  Parses an address key name into an address
//  and opens the address key.
//
NTSTATUS
OpenPersistentAddress(
    HANDLE ParentKey,
    WCHAR *SubKeyName,
    IPv6Addr *Address,
    HANDLE *AddrKey,
    OpenRegKeyAction Action)
{
    WCHAR *Terminator;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First, parse the address.
    //
    if (! ParseV6Address(SubKeyName, &Terminator, Address) ||
        (*Terminator != UNICODE_NULL)) {
        //
        // Not a valid address.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentAddress: bad syntax %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Open the address key.
    //
    Status = OpenRegKey(AddrKey, ParentKey, SubKeyName, Action);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the address key.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentAddress: bad key %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    return STATUS_SUCCESS;
}

//* EnumPersistentAddress
//
//  Helper function for FindPersistentAddressFromQuery,
//  wrapping OpenPersistentAddress for EnumRegKeyIndex.
//
NTSTATUS
EnumPersistentAddress(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    struct {
        IPv6Addr *Address;
        HANDLE *AddrKey;
        OpenRegKeyAction Action;
    } *Args = Context;

    PAGED_CODE();

    return OpenPersistentAddress(ParentKey, SubKeyName,
                                 Args->Address,
                                 Args->AddrKey,
                                 Args->Action);
}

//* FindPersistentAddressFromQuery
//
//  Given an IPV6_PERSISTENT_QUERY_ADDRESS structure,
//  finds the specified address key in the registry.
//  If the address key is found, then Query->IF.Guid and
//  Query->Address are returned.
//
NTSTATUS
FindPersistentAddressFromQuery(
    IPV6_PERSISTENT_QUERY_ADDRESS *Query,
    HANDLE *AddrKey)
{
    HANDLE IFKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First get the interface key.
    //
    Status = FindPersistentInterfaceFromQuery(&Query->IF, &IFKey);
    if (! NT_SUCCESS(Status))
        return STATUS_INVALID_PARAMETER_1;

    if (Query->RegistryIndex == (uint)-1) {
        //
        // Persistent query via address.
        //
        Status = OpenAddressRegKey(IFKey, &Query->Address,
                                   AddrKey, OpenRegKeyRead);
    }
    else {
        HANDLE AddressesKey;

        //
        // Open the Addresses subkey.
        //
        Status = OpenRegKey(&AddressesKey, IFKey,
                            L"Addresses", OpenRegKeyRead);
        if (NT_SUCCESS(Status)) {
            struct {
                IPv6Addr *Address;
                HANDLE *AddrKey;
                OpenRegKeyAction Action;
            } Args;

            //
            // Persistent query via registry index.
            //
            Args.Address = &Query->Address;
            Args.AddrKey = AddrKey;
            Args.Action = OpenRegKeyRead;

            Status = EnumRegKeyIndex(AddressesKey,
                                     Query->RegistryIndex,
                                     EnumPersistentAddress,
                                     &Args);
            ZwClose(AddressesKey);
        }
        else {
            //
            // If the Addresses subkey is not present,
            // then the index is not present.
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                Status = STATUS_NO_MORE_ENTRIES;
        }
    }

    ZwClose(IFKey);
    return Status;
}

//* GetPersistentLifetimes
//
//  Read valid and preferred lifetimes from the registry key.
//
void
GetPersistentLifetimes(
    HANDLE RegKey,
    int Immortal,
    uint *ValidLifetime,
    uint *PreferredLifetime)
{
    LARGE_INTEGER ValidLifetime64;
    LARGE_INTEGER PreferredLifetime64;

    //
    // Read the 64-bit lifetimes.
    //
    ValidLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
    InitRegQUADParameter(RegKey, L"ValidLifetime", &ValidLifetime64);
    PreferredLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
    InitRegQUADParameter(RegKey, L"PreferredLifetime", &PreferredLifetime64);

    //
    // Convert the lifetimes from 64-bit times to seconds.
    // If the lifetimes are Immortal, then the persisted values
    // are relative lifetimes. Otherwise they are absolute lifetimes.
    //
    if (Immortal) {
        if (ValidLifetime64.QuadPart == (LONGLONG) (LONG)INFINITE_LIFETIME)
            *ValidLifetime = INFINITE_LIFETIME;
        else
            *ValidLifetime = (uint)
                (ValidLifetime64.QuadPart / (10*1000*1000));
        if (PreferredLifetime64.QuadPart == (LONGLONG) (LONG)INFINITE_LIFETIME)
            *PreferredLifetime = INFINITE_LIFETIME;
        else
            *PreferredLifetime = (uint)
                (PreferredLifetime64.QuadPart / (10*1000*1000));
    }
    else {
        LARGE_INTEGER Now64;

        KeQuerySystemTime(&Now64);
        if (ValidLifetime64.QuadPart == (LONGLONG) (LONG)INFINITE_LIFETIME)
            *ValidLifetime = INFINITE_LIFETIME;
        else if (ValidLifetime64.QuadPart < Now64.QuadPart)
            *ValidLifetime = 0;
        else
            *ValidLifetime = (uint)
                ((ValidLifetime64.QuadPart - Now64.QuadPart) / (10*1000*1000));
        if (PreferredLifetime64.QuadPart == (LONGLONG) (LONG)INFINITE_LIFETIME)
            *PreferredLifetime = INFINITE_LIFETIME;
        else if (PreferredLifetime64.QuadPart < Now64.QuadPart)
            *PreferredLifetime = 0;
        else
            *PreferredLifetime = (uint)
                ((PreferredLifetime64.QuadPart - Now64.QuadPart) / (10*1000*1000));
    }
}

//* SetPersistentLifetimes
//
//  Write valid and preferred lifetimes to the registry key.
//
NTSTATUS
SetPersistentLifetimes(
    HANDLE RegKey,
    int Immortal,
    uint ValidLifetime,
    uint PreferredLifetime)
{
    LARGE_INTEGER ValidLifetime64;
    LARGE_INTEGER PreferredLifetime64;
    NTSTATUS Status;

    //
    // Persist the lifetimes as 64-bit times.
    // If the lifetimes are Immortal, then we persist
    // relative lifetimes. Otherwise we persist
    // absolute lifetimes.
    //
    if (Immortal) {
        if (ValidLifetime == INFINITE_LIFETIME)
            ValidLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
        else
            ValidLifetime64.QuadPart = (10*1000*1000) *
                (LONGLONG) ValidLifetime;
        if (PreferredLifetime == INFINITE_LIFETIME)
            PreferredLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
        else
            PreferredLifetime64.QuadPart = (10*1000*1000) *
                (LONGLONG) PreferredLifetime;
    }
    else {
        LARGE_INTEGER Now64;

        KeQuerySystemTime(&Now64);
        if (ValidLifetime == INFINITE_LIFETIME)
            ValidLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
        else
            ValidLifetime64.QuadPart = Now64.QuadPart + (10*1000*1000) *
                (LONGLONG) ValidLifetime;
        if (PreferredLifetime == INFINITE_LIFETIME)
            PreferredLifetime64.QuadPart = (LONGLONG) (LONG)INFINITE_LIFETIME;
        else
            PreferredLifetime64.QuadPart = Now64.QuadPart + (10*1000*1000) *
                (LONGLONG) PreferredLifetime;
    }

    //
    // Persist the valid lifetime.
    //
    Status = SetRegQUADValue(RegKey, L"ValidLifetime",
                             &ValidLifetime64);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Persist the preferred lifetime.
    //
    Status = SetRegQUADValue(RegKey, L"PreferredLifetime",
                             &PreferredLifetime64);
    return Status;
}

//* ReadPersistentAddress
//
//  Reads address attributes from the registry key.
//  Initializes all the fields except This.
//
void
ReadPersistentAddress(
    HANDLE AddrKey,
    IPV6_UPDATE_ADDRESS *Info)
{
    InitRegDWORDParameter(AddrKey, L"Type",
                          (uint *)&Info->Type, ADE_UNICAST);

    Info->PrefixConf = PREFIX_CONF_MANUAL;
    Info->InterfaceIdConf = IID_CONF_MANUAL;

    GetPersistentLifetimes(AddrKey, FALSE,
                           &Info->ValidLifetime,
                           &Info->PreferredLifetime);
}

//* IoctlPersistentQueryAddress
//
//  Processes an IOCTL_IPV6_PERSISTENT_QUERY_ADDRESS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlPersistentQueryAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_PERSISTENT_QUERY_ADDRESS *Query;
    IPV6_UPDATE_ADDRESS *Info;
    IPV6_QUERY_ADDRESS This;
    HANDLE AddrKey;
    NTSTATUS Status;

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->This structures overlap!
    //
    Query = (IPV6_PERSISTENT_QUERY_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_UPDATE_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Get the registry key for the specified address.
    //
    Status = FindPersistentAddressFromQuery(Query, &AddrKey);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // The interface index is not returned for persistent queries.
    //
    This.IF.Index = 0;
    This.IF.Guid = Query->IF.Guid;
    This.Address = Query->Address;
    Info->This = This;

    //
    // Read address information from the registry key.
    //
    ReadPersistentAddress(AddrKey, Info);
    ZwClose(AddrKey);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof *Info;
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlPersistentQueryAddress


//* IoctlQueryNeighborCache
//
//  Processes an IOCTL_IPV6_QUERY_NEIGHBOR_CACHE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryNeighborCache(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_NEIGHBOR_CACHE *Query;
    IPV6_INFO_NEIGHBOR_CACHE *Info;
    Interface *IF = NULL;
    NeighborCacheEntry *NCE;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Query structures overlap!
    //
    Query = (IPV6_QUERY_NEIGHBOR_CACHE *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_NEIGHBOR_CACHE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Return information about the specified interface.
    //
    IF = FindInterfaceFromQuery(&Query->IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    if (IsUnspecified(&Query->Address)) {
        //
        // Return the address of the first NCE.
        //
        KeAcquireSpinLock(&IF->LockNC, &OldIrql);
        if (IF->FirstNCE != SentinelNCE(IF))
            Info->Query.Address = IF->FirstNCE->NeighborAddress;
        KeReleaseSpinLock(&IF->LockNC, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Query;

    } else {
        uint Now = IPv6TickCount;

        //
        // Find the specified NCE.
        //
        KeAcquireSpinLock(&IF->LockNC, &OldIrql);
        for (NCE = IF->FirstNCE; ; NCE = NCE->Next) {
            if (NCE == SentinelNCE(IF)) {
                KeReleaseSpinLock(&IF->LockNC, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->Address, &NCE->NeighborAddress))
                break;
        }

        Irp->IoStatus.Information = sizeof *Info;

        //
        // Return the neighbor's link-layer address,
        // if there is room in the user's buffer.
        //
        Info->LinkLayerAddressLength = IF->LinkAddressLength;
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
            sizeof *Info + IF->LinkAddressLength) {

            RtlCopyMemory(Info + 1, NCE->LinkAddress, IF->LinkAddressLength);
            Irp->IoStatus.Information += IF->LinkAddressLength;
        }

        //
        // Return miscellaneous information about the NCE.
        //
        Info->IsRouter = NCE->IsRouter;
        Info->IsUnreachable = NCE->IsUnreachable;
        if ((NCE->NDState == ND_STATE_REACHABLE) &&
            ((uint)(Now - NCE->LastReachability) > IF->ReachableTime))
            Info->NDState = ND_STATE_STALE;
        else if ((NCE->NDState == ND_STATE_PROBE) &&
                 (NCE->NSCount == 0))
            Info->NDState = ND_STATE_DELAY;
        else
            Info->NDState = NCE->NDState;
        Info->ReachableTimer = ConvertTicksToMillis(IF->ReachableTime -
                                   (Now - NCE->LastReachability));

        //
        // Return address of the next NCE (or zero).
        //
        if (NCE->Next == SentinelNCE(IF))
            Info->Query.Address = UnspecifiedAddr;
        else
            Info->Query.Address = NCE->Next->NeighborAddress;

        KeReleaseSpinLock(&IF->LockNC, OldIrql);
    }

    Status = STATUS_SUCCESS;
  Return:
    if (IF != NULL)
        ReleaseIF(IF);

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryNeighborCache


//* IoctlQueryRouteCache
//
//  Processes an IOCTL_IPV6_QUERY_ROUTE_CACHE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryRouteCache(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_ROUTE_CACHE *Query;
    IPV6_INFO_ROUTE_CACHE *Info;
    RouteCacheEntry *RCE;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Query structures overlap!
    //
    Query = (IPV6_QUERY_ROUTE_CACHE *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_ROUTE_CACHE *) Irp->AssociatedIrp.SystemBuffer;

    if (Query->IF.Index == 0) {
        //
        // Return the index and address of the first RCE.
        //
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        if (RouteCache.First != SentinelRCE) {
            Info->Query.IF.Index = RouteCache.First->NTE->IF->Index;
            Info->Query.Address = RouteCache.First->Destination;
        }
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Query;

    } else {
        uint Now = IPv6TickCount;

        //
        // Find the specified RCE.
        //
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        for (RCE = RouteCache.First; ; RCE = RCE->Next) {
            if (RCE == SentinelRCE) {
                KeReleaseSpinLock(&RouteCacheLock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->Address, &RCE->Destination) &&
                (Query->IF.Index == RCE->NTE->IF->Index))
                break;
        }

        //
        // Return misc. information about the RCE.
        //
        Info->Type = RCE->Type;
        Info->Flags = RCE->Flags;
        Info->Valid = (RCE->Valid == RouteCacheValidationCounter);
        Info->SourceAddress = RCE->NTE->Address;
        Info->NextHopAddress = RCE->NCE->NeighborAddress;
        Info->NextHopInterface = RCE->NCE->IF->Index;
        Info->PathMTU = RCE->PathMTU;
        if (RCE->PMTULastSet != 0) {
            uint SinceLastSet = Now - RCE->PMTULastSet;
            ASSERT((int)SinceLastSet >= 0);
            if (SinceLastSet < PATH_MTU_RETRY_TIME)
                Info->PMTUProbeTimer =
                    ConvertTicksToMillis(PATH_MTU_RETRY_TIME - SinceLastSet);
            else
                Info->PMTUProbeTimer = 0; // Fires on next packet.
        } else
            Info->PMTUProbeTimer = INFINITE_LIFETIME; // Not set.
        if (RCE->LastError != 0)
            Info->ICMPLastError = ConvertTicksToMillis(Now - RCE->LastError);
        else
            Info->ICMPLastError = 0;
        if (RCE->BCE != NULL) {
            Info->CareOfAddress = RCE->BCE->CareOfRCE->Destination;
            Info->BindingSeqNumber = RCE->BCE->BindingSeqNumber;
            Info->BindingLifetime = ConvertTicksToSeconds(RCE->BCE->BindingLifetime);
        } else {
            Info->CareOfAddress = UnspecifiedAddr;
            Info->BindingSeqNumber = 0;
            Info->BindingLifetime = 0;
        }

        //
        // Return index and address of the next RCE (or zero).
        //
        if (RCE->Next == SentinelRCE) {
            Info->Query.IF.Index = 0;
        } else {
            Info->Query.IF.Index = RCE->Next->NTE->IF->Index;
            Info->Query.Address = RCE->Next->Destination;
        }

        KeReleaseSpinLock(&RouteCacheLock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryRouteCache


//* IoctlCreateSecurityPolicy
//
NTSTATUS
IoctlCreateSecurityPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_CREATE_SECURITY_POLICY *CreateSP;
    SecurityPolicy *SP, *BundledSP;
    NTSTATUS Status;
    KIRQL OldIrql;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *CreateSP) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    CreateSP = (IPV6_CREATE_SECURITY_POLICY *)Irp->AssociatedIrp.SystemBuffer;

    //
    // Sanity check the user-supplied input values.
    //

    if ((CreateSP->RemoteAddrField != WILDCARD_VALUE) &&
        (CreateSP->RemoteAddrField != SINGLE_VALUE) &&
        (CreateSP->RemoteAddrField != RANGE_VALUE)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    if ((CreateSP->LocalAddrField != WILDCARD_VALUE) &&
        (CreateSP->LocalAddrField != SINGLE_VALUE) &&
        (CreateSP->LocalAddrField != RANGE_VALUE)) {
        Status = STATUS_INVALID_PARAMETER_2;
        goto Return;
    }

    // TransportProto can be anything.
    // Port values can be anything.

    //
    // We do not support IPSEC_APPCHOICE.
    //
    if ((CreateSP->IPSecAction != IPSEC_DISCARD) &&
        (CreateSP->IPSecAction != IPSEC_APPLY) &&
        (CreateSP->IPSecAction != IPSEC_BYPASS)) {
        Status = STATUS_INVALID_PARAMETER_3;
        goto Return;
    }

    if ((CreateSP->IPSecProtocol != IP_PROTOCOL_AH) &&
        (CreateSP->IPSecProtocol != IP_PROTOCOL_ESP) &&
        (CreateSP->IPSecProtocol != NONE)) {
        Status = STATUS_INVALID_PARAMETER_4;
        goto Return;
    }

    if ((CreateSP->IPSecMode != TRANSPORT) &&
        (CreateSP->IPSecMode != TUNNEL) &&
        (CreateSP->IPSecMode != NONE)) {
        Status = STATUS_INVALID_PARAMETER_5;
        goto Return;
    }

    if (CreateSP->IPSecAction == IPSEC_APPLY) {
        if ((CreateSP->IPSecProtocol == NONE) ||
            (CreateSP->IPSecMode == NONE)) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto Return;
        }
    }

    if ((CreateSP->Direction != INBOUND) &&
        (CreateSP->Direction != OUTBOUND) &&
        (CreateSP->Direction != BIDIRECTIONAL)) {
        Status = STATUS_INVALID_PARAMETER_6;
        goto Return;
    }

    if (((CreateSP->RemoteAddrSelector != PACKET_SELECTOR) &&
         (CreateSP->RemoteAddrSelector != POLICY_SELECTOR)) ||
        ((CreateSP->LocalAddrSelector != PACKET_SELECTOR) &&
         (CreateSP->LocalAddrSelector != POLICY_SELECTOR)) ||
        ((CreateSP->RemotePortSelector != PACKET_SELECTOR) &&
         (CreateSP->RemotePortSelector != POLICY_SELECTOR)) ||
        ((CreateSP->LocalPortSelector != PACKET_SELECTOR) &&
         (CreateSP->LocalPortSelector != POLICY_SELECTOR)) ||
        ((CreateSP->TransportProtoSelector != PACKET_SELECTOR) &&
         (CreateSP->TransportProtoSelector != POLICY_SELECTOR))) {
        Status = STATUS_INVALID_PARAMETER_7;
        goto Return;
    }

    // Get Security Lock.
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // REVIEW: This considers a non-existent interface an error.  Should it?
    //
    if (CreateSP->SPInterface != 0) {
        Interface *IF;

        IF = FindInterfaceFromIndex(CreateSP->SPInterface);
        if (IF == NULL) {
            //
            // Unknown interface.
            //
            Status = STATUS_NOT_FOUND;
            goto ReturnUnlock;
        }
        ReleaseIF(IF);
    }

    //
    // Allocate memory for Security Policy.
    //
    SP = ExAllocatePool(NonPagedPool, sizeof *SP);
    if (SP == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReturnUnlock;
    }

    //
    // Copy CreateSP to SP.
    //
    SP->Index = CreateSP->SPIndex;
    SP->RemoteAddr = CreateSP->RemoteAddr;
    SP->RemoteAddrData = CreateSP->RemoteAddrData;
    SP->RemoteAddrSelector = CreateSP->RemoteAddrSelector;
    SP->RemoteAddrField = CreateSP->RemoteAddrField;

    SP->LocalAddr = CreateSP->LocalAddr;
    SP->LocalAddrData = CreateSP->LocalAddrData;
    SP->LocalAddrSelector = CreateSP->LocalAddrSelector;
    SP->LocalAddrField = CreateSP->LocalAddrField;

    SP->TransportProto = CreateSP->TransportProto;
    SP->TransportProtoSelector = CreateSP->TransportProtoSelector;

    SP->RemotePort = CreateSP->RemotePort;
    SP->RemotePortData = CreateSP->RemotePortData;
    SP->RemotePortSelector = CreateSP->RemotePortSelector;
    SP->RemotePortField = CreateSP->RemotePortField;

    SP->LocalPort = CreateSP->LocalPort;
    SP->LocalPortData = CreateSP->LocalPortData;
    SP->LocalPortSelector = CreateSP->LocalPortSelector;
    SP->LocalPortField = CreateSP->LocalPortField;

    SP->SecPolicyFlag = CreateSP->IPSecAction;
    SP->IPSecSpec.Protocol = CreateSP->IPSecProtocol;
    SP->IPSecSpec.Mode = CreateSP->IPSecMode;
    SP->IPSecSpec.RemoteSecGWIPAddr = CreateSP->RemoteSecurityGWAddr;
    SP->DirectionFlag = CreateSP->Direction;
    SP->OutboundSA = NULL;
    SP->InboundSA = NULL;
    SP->PrevSABundle = NULL;
    SP->RefCnt = 0;
    SP->NestCount = 1;
    SP->IFIndex = CreateSP->SPInterface;

    //
    // Insert SP into the global list.
    //
    if (!InsertSecurityPolicy(SP)) {
        //
        // Couldn't insert, free up failed SP memory.
        //
        ExFreePool(SP);
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto ReturnUnlock;
    }

    //
    // Convert SABundleIndex to the SABundle pointer.
    //
    if (CreateSP->SABundleIndex == 0) {
        SP->SABundle = NULL;
    } else {
        // Search the SP List starting at the first SP.
        BundledSP = FindSecurityPolicyMatch(SecurityPolicyList, 0,
                                            CreateSP->SABundleIndex);
        if (BundledSP == NULL) {
            //
            // Policy with which this new one was supposed to bundle
            // does not exist.  Abort creation of this new policy.
            //
            RemoveSecurityPolicy(SP);
            ExFreePool(SP);
            Status = STATUS_INVALID_PARAMETER;
            goto ReturnUnlock;
        } else {
            SP->SABundle = BundledSP;
            BundledSP->RefCnt++;
            SP->NestCount = BundledSP->NestCount + 1;
            //
            // The bundle entry list is doubly linked to facilitate
            // ease of entry deletion.
            //
            BundledSP->PrevSABundle = SP;
            SP->RefCnt++;
        }
    }

    Status = STATUS_SUCCESS;

  ReturnUnlock:
    // Release lock.
    KeReleaseSpinLock(&IPSecLock, OldIrql);

  Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
} // IoctlCreateSecurityPolicy


//* IoctlCreateSecurityAssociation
//
NTSTATUS
IoctlCreateSecurityAssociation(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_CREATE_SECURITY_ASSOCIATION *CreateSA;
    SecurityAssociation *SA;
    SecurityPolicy *SP;
    uint KeySize;
    uchar *RawKey;
    NTSTATUS Status;
    KIRQL OldIrql;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof *CreateSA) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    CreateSA = (IPV6_CREATE_SECURITY_ASSOCIATION *)Irp->AssociatedIrp.SystemBuffer;

    //
    // Sanity check the user-supplied input values.
    //

    if ((CreateSA->Direction != INBOUND) &&
        (CreateSA->Direction != OUTBOUND)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    if (CreateSA->AlgorithmId >= NUM_ALGORITHMS) {
        Status = STATUS_INVALID_PARAMETER_2;
        goto Return;
    }

    KeySize = AlgorithmTable[CreateSA->AlgorithmId].KeySize;
    if (CreateSA->RawKeySize > MAX_KEY_SIZE) {
        //
        // We cap the RawKeySize at something rational.
        //
        Status = STATUS_INVALID_PARAMETER_3;
        goto Return;
    }

    //
    // RawKey should be passed in the Ioctl immediately after CreateSA.
    //
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
        (sizeof(*CreateSA) + CreateSA->RawKeySize)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }
    RawKey = (uchar *)(CreateSA + 1);

    //
    // Allocate memory for Security Association and the Key.
    // The Key will immediately follow the SA in memory.
    //
#ifdef IPSEC_DEBUG
    SA = ExAllocatePool(NonPagedPool,
                        sizeof(*SA) + KeySize + CreateSA->RawKeySize);
#else
    SA = ExAllocatePool(NonPagedPool, sizeof(*SA) + KeySize);
#endif
    if (SA == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Return;
    }
    SA->Key = (uchar *)(SA + 1);

    //
    // Copy CreateSA to SA.
    //
    SA->Index = CreateSA->SAIndex;
    SA->SPI = CreateSA->SPI;
    SA->SequenceNum = 0;
    SA->SADestAddr = CreateSA->SADestAddr;
    SA->DestAddr = CreateSA->DestAddr;
    SA->SrcAddr = CreateSA->SrcAddr;
    SA->TransportProto = CreateSA->TransportProto;
    SA->DestPort = CreateSA->DestPort;
    SA->SrcPort = CreateSA->SrcPort;
    SA->DirectionFlag = CreateSA->Direction;
    SA->RefCnt = 0;
    SA->AlgorithmId = CreateSA->AlgorithmId;
    SA->KeyLength = KeySize;

#ifdef IPSEC_DEBUG
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
               "SA %d prepped KeySize is %d\n",
               CreateSA->SAIndex, KeySize));
    SA->RawKey = (uchar *)(SA->Key + KeySize);
    SA->RawKeyLength = CreateSA->RawKeySize;

    //
    // Copy raw key to SA.
    //
    memcpy(SA->RawKey, RawKey, SA->RawKeyLength);

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
               "SA %d RawKey (%d bytes): ",
               CreateSA->SAIndex, SA->RawKeyLength));
    DumpKey(SA->RawKey, SA->RawKeyLength);
#endif

    //
    // Prepare the manual key.
    //
    (*AlgorithmTable[SA->AlgorithmId].PrepareKey)
        (RawKey, CreateSA->RawKeySize, SA->Key);

    //
    // Get Security Lock.
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Find policy which this association instantiates.
    //
    SP = FindSecurityPolicyMatch(SecurityPolicyList, 0,
                                 CreateSA->SecPolicyIndex);
    if (SP == NULL) {
        //
        // No matching policy exists.
        //
        Status = STATUS_INVALID_PARAMETER_4;
        ExFreePool(SA);
        goto ReturnUnlock;
    }

    // Set the SA's IPSecProto to match that of the SP.
    SA->IPSecProto = SP->IPSecSpec.Protocol;

    //
    // Check that direction of SA is legitimate for this SP.
    //
    if ((SA->DirectionFlag & SP->DirectionFlag) == 0) {
        //
        // Direction of SA is incompatible with SP's.
        // Abort creation of this new association.
        //
        Status = STATUS_INVALID_PARAMETER_MIX;
        ExFreePool(SA);
        goto ReturnUnlock;
    }

    //
    // Add this association to the global list.
    //
    if (!InsertSecurityAssociation(SA)) {
        //
        // Couldn't insert, free up failed SP memory.
        //
        Status = STATUS_OBJECT_NAME_COLLISION;
        ExFreePool(SA);
        goto ReturnUnlock;
    }

    //
    // Add this association to policy's instantiated associations list.
    //
    if (SA->DirectionFlag == INBOUND) {
        // Add the SA to the policy's inbound list.
        SA->ChainedSecAssoc = SP->InboundSA;
        SP->InboundSA = SA;
        AddRefSA(SA);

        // The SA keeps a pointer to the SP it instantiates.
        SA->SecPolicy = SP;
        SA->SecPolicy->RefCnt++;
    } else {
        // Add the SA to the policy's outbound list.
        SA->ChainedSecAssoc = SP->OutboundSA;
        SP->OutboundSA = SA;
        AddRefSA(SA);

        // Add the SP to the SA SecPolicy pointer.
        SA->SecPolicy = SP;
        SA->SecPolicy->RefCnt++;
    }

    SA->Valid = SA_VALID;
    Status = STATUS_SUCCESS;

  ReturnUnlock:
    // Release lock.
    KeReleaseSpinLock(&IPSecLock, OldIrql);

  Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
} // IoctlCreateSecurityAssociation


//* IoctlQuerySecurityPolicyList
//
NTSTATUS
IoctlQuerySecurityPolicyList(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_SECURITY_POLICY_LIST *Query;
    IPV6_INFO_SECURITY_POLICY_LIST *Info;
    SecurityPolicy *SP, *NextSP;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_SECURITY_POLICY_LIST *)Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_SECURITY_POLICY_LIST *)Irp->AssociatedIrp.SystemBuffer;

    //
    // REVIEW: This considers a non-existent interface an error.  Should it?
    //
    if (Query->SPInterface != 0) {
        Interface *IF;

        IF = FindInterfaceFromIndex(Query->SPInterface);
        if (IF == NULL) {
            //
            // Unknown interface.
            //
            Status = STATUS_NOT_FOUND;
            goto Return;
        }
        ReleaseIF(IF);
    }

    //
    // Get Security Lock.
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Find matching policy.
    //
    SP = FindSecurityPolicyMatch(SecurityPolicyList, Query->SPInterface,
                                 Query->Index);
    if (SP == NULL) {
        //
        // No matching policy exists.
        //
        Status = STATUS_NO_MATCH;
        goto ReturnUnlock;
    }

    //
    // Get the next index to query.
    //
    NextSP = FindSecurityPolicyMatch(SP->Next, Query->SPInterface, 0);
    if (NextSP == NULL) {
        Info->NextSPIndex = 0;
    } else {
        Info->NextSPIndex = NextSP->Index;
    }

    //
    // Copy SP to Info.
    //
    Info->SPIndex = SP->Index;

    Info->RemoteAddr = SP->RemoteAddr;
    Info->RemoteAddrData = SP->RemoteAddrData;
    Info->RemoteAddrSelector = SP->RemoteAddrSelector;
    Info->RemoteAddrField = SP->RemoteAddrField;

    Info->LocalAddr = SP->LocalAddr;
    Info->LocalAddrData = SP->LocalAddrData;
    Info->LocalAddrSelector = SP->LocalAddrSelector;
    Info->LocalAddrField = SP->LocalAddrField;

    Info->TransportProto = SP->TransportProto;
    Info->TransportProtoSelector = SP->TransportProtoSelector;

    Info->RemotePort = SP->RemotePort;
    Info->RemotePortData = SP->RemotePortData;
    Info->RemotePortSelector = SP->RemotePortSelector;
    Info->RemotePortField = SP->RemotePortField;

    Info->LocalPort = SP->LocalPort;
    Info->LocalPortData = SP->LocalPortData;
    Info->LocalPortSelector = SP->LocalPortSelector;
    Info->LocalPortField = SP->LocalPortField;

    Info->IPSecProtocol = SP->IPSecSpec.Protocol;
    Info->IPSecMode = SP->IPSecSpec.Mode;
    Info->RemoteSecurityGWAddr = SP->IPSecSpec.RemoteSecGWIPAddr;
    Info->Direction = SP->DirectionFlag;
    Info->IPSecAction = SP->SecPolicyFlag;
    Info->SABundleIndex = GetSecurityPolicyIndex(SP->SABundle);
    Info->SPInterface = SP->IFIndex;

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof *Info;

  ReturnUnlock:
    KeReleaseSpinLock(&IPSecLock, OldIrql);

  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
} // IoctlQuerySecurityPolicyList

//* IoctlDeleteSecurityPolicy
//
NTSTATUS
IoctlDeleteSecurityPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_SECURITY_POLICY_LIST *Query;
    SecurityPolicy *SP;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_SECURITY_POLICY_LIST *)Irp->AssociatedIrp.SystemBuffer;

    //
    // Get Security Lock.
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Find the policy in question.
    //
    SP = FindSecurityPolicyMatch(SecurityPolicyList, 0, Query->Index);
    if (SP == NULL) {
        //
        // The policy does not exist.
        //
        Status = STATUS_NO_MATCH;
        goto ReturnUnlock;
    }

    //
    // Remove the SP.
    //
    if (DeleteSP(SP)) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

ReturnUnlock:
    KeReleaseSpinLock(&IPSecLock, OldIrql);

Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}


//* IoctlQuerySecurityAssociationList
//
NTSTATUS
IoctlQuerySecurityAssociationList(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST *Query;
    IPV6_INFO_SECURITY_ASSOCIATION_LIST *Info;
    SecurityAssociation *SA;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_SECURITY_ASSOCIATION_LIST *)Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_SECURITY_ASSOCIATION_LIST *)Irp->AssociatedIrp.SystemBuffer;

    //
    // Get Security Lock.
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Find matching association.
    //
    SA = FindSecurityAssociationMatch(Query->Index);
    if (SA == NULL) {
        //
        // No matching association exists.
        //
        Status = STATUS_NO_MATCH;
        goto ReturnUnlock;
    }

    //
    // Get the next index to query.
    //
    if (SA->Next == NULL) {
        // No more SAs after this one.
        Info->NextSAIndex = 0;
    } else {
        // Return the next SA.
        Info->NextSAIndex = SA->Next->Index;
    }

    //
    // Copy SA to Info.
    //
    Info->SAIndex = SA->Index;
    Info->SPI = SA->SPI;
    Info->SADestAddr = SA->SADestAddr;
    Info->DestAddr = SA->DestAddr;
    Info->SrcAddr = SA->SrcAddr;
    Info->TransportProto = SA->TransportProto;
    Info->DestPort = SA->DestPort;
    Info->SrcPort = SA->SrcPort;
    Info->Direction = SA->DirectionFlag;
    Info->SecPolicyIndex = GetSecurityPolicyIndex(SA->SecPolicy);
    Info->AlgorithmId = SA->AlgorithmId;

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof *Info;

  ReturnUnlock:
    KeReleaseSpinLock(&IPSecLock, OldIrql);

  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
} // IoctlQuerySecurityAssociationList

//* IoctlDeleteSecurityAssociation
//
NTSTATUS
IoctlDeleteSecurityAssociation(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_SECURITY_ASSOCIATION_LIST *Query;
    SecurityAssociation *SA;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_SECURITY_ASSOCIATION_LIST *)Irp->AssociatedIrp.SystemBuffer;

    //
    // Get Security Lock.
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Find the association in question.
    //
    SA = FindSecurityAssociationMatch(Query->Index);
    if (SA == NULL) {
        //
        // The association does not exist.
        //
        Status = STATUS_NO_MATCH;
        goto ReturnUnlock;
    }

    //
    // Remove the SA.
    //
    if (DeleteSA(SA)) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

ReturnUnlock:
    KeReleaseSpinLock(&IPSecLock, OldIrql);

Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

//* RouteTableInfo
//
//  Return information about a route.
//
//  We allow Info->This to be filled in from a different RTE
//  than the other fields.
//
void
RouteTableInfo(RouteTableEntry *ThisRTE, RouteTableEntry *InfoRTE,
               IPV6_INFO_ROUTE_TABLE *Info)
{
    if (ThisRTE == NULL) {
        Info->This.Neighbor.IF.Index = 0;
    } else {
        Info->This.Prefix = ThisRTE->Prefix;
        Info->This.PrefixLength = ThisRTE->PrefixLength;
        Info->This.Neighbor.IF.Index = ThisRTE->IF->Index;
        if (!IsOnLinkRTE(ThisRTE))
            Info->This.Neighbor.Address = ThisRTE->NCE->NeighborAddress;
        else
            Info->This.Neighbor.Address = UnspecifiedAddr;
    }

    if (InfoRTE != NULL) {
        Info->SitePrefixLength = InfoRTE->SitePrefixLength;;
        Info->ValidLifetime =
            ConvertTicksToSeconds(InfoRTE->ValidLifetime);
        Info->PreferredLifetime =
            ConvertTicksToSeconds(InfoRTE->PreferredLifetime);
        Info->Preference = InfoRTE->Preference;
        Info->Publish = !!(InfoRTE->Flags & RTE_FLAG_PUBLISH);
        Info->Immortal = !!(InfoRTE->Flags & RTE_FLAG_IMMORTAL);
        Info->Type = InfoRTE->Type;
    }
}

//* IoctlQueryRouteTable
//
//  Processes an IOCTL_IPV6_QUERY_ROUTE_TABLE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryRouteTable(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_ROUTE_TABLE *Query;
    IPV6_INFO_ROUTE_TABLE *Info;
    RouteTableEntry *RTE;
    KIRQL OldIrql;
    NTSTATUS Status;

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->This structures overlap!
    //
    Query = (IPV6_QUERY_ROUTE_TABLE *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_ROUTE_TABLE *) Irp->AssociatedIrp.SystemBuffer;

    if (Query->Neighbor.IF.Index == 0) {
        //
        // Return the prefix and neighbor of the first RTE.
        //
        KeAcquireSpinLock(&RouteTableLock, &OldIrql);
        RouteTableInfo(RouteTable.First, NULL, Info);
        KeReleaseSpinLock(&RouteTableLock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->This;

    } else {
        //
        // Find the specified RTE.
        //
        KeAcquireSpinLock(&RouteTableLock, &OldIrql);
        for (RTE = RouteTable.First; ; RTE = RTE->Next) {
            if (RTE == NULL) {
                KeReleaseSpinLock(&RouteTableLock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->Prefix, &RTE->Prefix) &&
                (Query->PrefixLength == RTE->PrefixLength) &&
                (Query->Neighbor.IF.Index == RTE->IF->Index) &&
                IP6_ADDR_EQUAL(&Query->Neighbor.Address,
                               (IsOnLinkRTE(RTE) ?
                                &UnspecifiedAddr :
                                &RTE->NCE->NeighborAddress)))
                break;
        }

        //
        // Return misc. information about the RTE.
        //
        RouteTableInfo(RTE->Next, RTE, Info);

        KeReleaseSpinLock(&RouteTableLock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    Status = STATUS_SUCCESS;
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryRouteTable

//* OpenRouteRegKey
//
//  Given an interface's registry key and route information
//  opens the registry key with configuration info for the route.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
OpenRouteRegKey(
    HANDLE IFKey,
    const IPv6Addr *Prefix,
    uint PrefixLength,
    const IPv6Addr *Neighbor,
    OUT HANDLE *RegKey,
    OpenRegKeyAction Action)
{
    WCHAR RouteName[128];
    HANDLE RoutesKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenRegKey(&RoutesKey, IFKey, L"Routes",
                        ((Action == OpenRegKeyCreate) ?
                         OpenRegKeyCreate : OpenRegKeyRead));
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // The output of RtlIpv6AddressToString may change
    // over time with improvements/changes in the pretty-printing,
    // and we need a consistent mapping.
    // It doesn't need to be pretty.
    //
    swprintf(RouteName,
        L"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x/%u->"
        L"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
        net_short(Prefix->s6_words[0]), net_short(Prefix->s6_words[1]),
        net_short(Prefix->s6_words[2]), net_short(Prefix->s6_words[3]),
        net_short(Prefix->s6_words[4]), net_short(Prefix->s6_words[5]),
        net_short(Prefix->s6_words[6]), net_short(Prefix->s6_words[7]),
        PrefixLength,
        net_short(Neighbor->s6_words[0]), net_short(Neighbor->s6_words[1]),
        net_short(Neighbor->s6_words[2]), net_short(Neighbor->s6_words[3]),
        net_short(Neighbor->s6_words[4]), net_short(Neighbor->s6_words[5]),
        net_short(Neighbor->s6_words[6]), net_short(Neighbor->s6_words[7]));

    Status = OpenRegKey(RegKey, RoutesKey, RouteName, Action);
    ZwClose(RoutesKey);
    return Status;
}

//* OpenPersistentRoute
//
//  Parses a route key name into a prefix and prefix length plus
//  a next-hop neighbor address and opens the route key.
//
NTSTATUS
OpenPersistentRoute(
    HANDLE ParentKey,
    WCHAR *SubKeyName,
    IPv6Addr *Prefix,
    uint *PrefixLength,
    IPv6Addr *Neighbor,
    HANDLE *RouteKey,
    OpenRegKeyAction Action)
{
    WCHAR *Terminator;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First, parse the prefix.
    //
    if (! ParseV6Address(SubKeyName, &Terminator, Prefix) ||
        (*Terminator != L'/')) {
        //
        // Not a valid prefix.
        //
    SyntaxError:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentRoute: bad syntax %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Next, parse the prefix length.
    //
    Terminator++; // Move past the L'/'.
    *PrefixLength = 0;
    for (;;) {
        WCHAR Char = *Terminator++;

        if (Char == L'-') {
            Char = *Terminator++;
            if (Char == L'>')
                break;
            else
                goto SyntaxError;
        }
        else if ((L'0' <= Char) && (Char <= L'9')) {
            *PrefixLength *= 10;
            *PrefixLength += Char - L'0';
            if (*PrefixLength > IPV6_ADDRESS_LENGTH)
                goto SyntaxError;
        }
        else
            goto SyntaxError;
    }

    //
    // Finally, parse the neighbor address.
    //
    if (! ParseV6Address(Terminator, &Terminator, Neighbor) ||
        (*Terminator != UNICODE_NULL))
        goto SyntaxError;

    //
    // Open the route key.
    //
    Status = OpenRegKey(RouteKey, ParentKey, SubKeyName, Action);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the route key.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "OpenPersistentRoute: bad key %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    return STATUS_SUCCESS;
}

//* EnumPersistentRoute
//
//  Helper function for FindPersistentRouteFromQuery,
//  wrapping OpenPersistentRoute for EnumRegKeyIndex.
//
NTSTATUS
EnumPersistentRoute(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    struct {
        IPv6Addr *Prefix;
        uint *PrefixLength;
        IPv6Addr *Neighbor;
        HANDLE *RouteKey;
        OpenRegKeyAction Action;
    } *Args = Context;

    PAGED_CODE();

    return OpenPersistentRoute(ParentKey, SubKeyName,
                               Args->Prefix,
                               Args->PrefixLength,
                               Args->Neighbor,
                               Args->RouteKey,
                               Args->Action);
}

//* FindPersistentRouteFromQuery
//
//  Given an IPV6_PERSISTENT_QUERY_ROUTE_TABLE structure,
//  finds the specified route key in the registry.
//  If the route key is found, then Query->IF.Guid and
//  Query->Address are returned.
//
NTSTATUS
FindPersistentRouteFromQuery(
    IPV6_PERSISTENT_QUERY_ROUTE_TABLE *Query,
    HANDLE *RouteKey)
{
    HANDLE IFKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First get the interface key.
    //
    Status = FindPersistentInterfaceFromQuery(&Query->IF, &IFKey);
    if (! NT_SUCCESS(Status))
        return STATUS_INVALID_PARAMETER_1;

    if (Query->RegistryIndex == (uint)-1) {
        //
        // Persistent query via prefix & next-hop.
        //
        Status = OpenRouteRegKey(IFKey,
                                 &Query->Prefix, Query->PrefixLength,
                                 &Query->Neighbor,
                                 RouteKey, OpenRegKeyRead);
    }
    else {
        HANDLE RoutesKey;

        //
        // Open the Routes subkey.
        //
        Status = OpenRegKey(&RoutesKey, IFKey,
                            L"Routes", OpenRegKeyRead);
        if (NT_SUCCESS(Status)) {
            struct {
                IPv6Addr *Prefix;
                uint *PrefixLength;
                IPv6Addr *Neighbor;
                HANDLE *RouteKey;
                OpenRegKeyAction Action;
            } Args;

            //
            // Persistent query via registry index.
            //
            Args.Prefix = &Query->Prefix;
            Args.PrefixLength = &Query->PrefixLength;
            Args.Neighbor = &Query->Neighbor;
            Args.RouteKey = RouteKey;
            Args.Action = OpenRegKeyRead;

            Status = EnumRegKeyIndex(RoutesKey,
                                     Query->RegistryIndex,
                                     EnumPersistentRoute,
                                     &Args);
            ZwClose(RoutesKey);
        }
        else {
            //
            // If the Routes subkey is not present,
            // then the index is not present.
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                Status = STATUS_NO_MORE_ENTRIES;
        }
    }

    ZwClose(IFKey);
    return Status;
}

//* ReadPersistentRoute
//
//  Reads route attributes from the registry key.
//  Initializes all the fields except This.
//
void
ReadPersistentRoute(
    HANDLE RouteKey,
    IPV6_INFO_ROUTE_TABLE *Info)
{
    //
    // Read the route preference.
    //
    InitRegDWORDParameter(RouteKey, L"Preference",
                          &Info->Preference, ROUTE_PREF_HIGHEST);

    //
    // Read the site prefix length.
    //
    InitRegDWORDParameter(RouteKey, L"SitePrefixLength",
                          &Info->SitePrefixLength, 0);

    //
    // Read the Publish flag.
    //
    InitRegDWORDParameter(RouteKey, L"Publish",
                          (uint *)&Info->Publish, FALSE);

    //
    // Read the Immortal flag.
    //
    InitRegDWORDParameter(RouteKey, L"Immortal",
                          (uint *)&Info->Immortal, FALSE);

    //
    // Read the lifetimes.
    //
    GetPersistentLifetimes(RouteKey, Info->Immortal,
                           &Info->ValidLifetime, &Info->PreferredLifetime);

    //
    // The route type is not persisted.
    //
    Info->Type = RTE_TYPE_MANUAL;
}

//* IoctlPersistentQueryRouteTable
//
//  Processes an IOCTL_IPV6_PERSISTENT_QUERY_ROUTE_TABLE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlPersistentQueryRouteTable(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_PERSISTENT_QUERY_ROUTE_TABLE *Query;
    IPV6_INFO_ROUTE_TABLE *Info;
    IPV6_QUERY_ROUTE_TABLE This;
    HANDLE RouteKey;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->This structures overlap!
    //
    Query = (IPV6_PERSISTENT_QUERY_ROUTE_TABLE *)
        Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_ROUTE_TABLE *)
        Irp->AssociatedIrp.SystemBuffer;

    //
    // Get the registry key for the specified route.
    //
    Status = FindPersistentRouteFromQuery(Query, &RouteKey);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // The interface index is not returned for persistent queries.
    //
    This.Neighbor.IF.Index = 0;
    This.Neighbor.IF.Guid = Query->IF.Guid;
    This.Neighbor.Address = Query->Neighbor;
    This.Prefix = Query->Prefix;
    This.PrefixLength = Query->PrefixLength;
    Info->This = This;

    //
    // Read route information from the registry key.
    //
    ReadPersistentRoute(RouteKey, Info);
    ZwClose(RouteKey);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof *Info;
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlPersistentQueryRouteTable

//* InternalUpdateRouteTable
//
//  Common helper function for IoctlUpdateRouteTable
//  and CreatePersistentRoute, consolidating
//  parameter validation in one place.
//
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad Interface.
//      STATUS_INVALID_PARAMETER_2      Bad Neighbor.
//      STATUS_INVALID_PARAMETER_3      Bad PrefixLength.
//      STATUS_INVALID_PARAMETER_4      Bad PreferredLifetime.
//      STATUS_INVALID_PARAMETER_5      Bad Preference.
//      STATUS_INVALID_PARAMETER_6      Bad Type.
//      STATUS_INVALID_PARAMETER_7      Bad Prefix.
//      STATUS_INSUFFICIENT_RESOURCES   No pool.
//      STATUS_ACCESS_DENIED            Invalid system route update.
//
NTSTATUS
InternalUpdateRouteTable(
    FILE_OBJECT *FileObject,
    Interface *IF,
    IPV6_INFO_ROUTE_TABLE *Info)
{
    NeighborCacheEntry *NCE;
    uint ValidLifetime;
    uint PreferredLifetime;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Convert the lifetime from seconds to ticks.
    //
    ValidLifetime = ConvertSecondsToTicks(Info->ValidLifetime);
    PreferredLifetime = ConvertSecondsToTicks(Info->PreferredLifetime);

    //
    // Sanity check the arguments.
    //

    if ((Info->This.PrefixLength > IPV6_ADDRESS_LENGTH) ||
        (Info->SitePrefixLength > Info->This.PrefixLength))
        return STATUS_INVALID_PARAMETER_3;

    if (PreferredLifetime > ValidLifetime)
        return STATUS_INVALID_PARAMETER_4;

    if (! IsValidPreference(Info->Preference))
        return STATUS_INVALID_PARAMETER_5;

    if (! IsValidRouteTableType(Info->Type))
        return STATUS_INVALID_PARAMETER_6;

    if ((IsLinkLocal(&Info->This.Prefix) && Info->Publish) ||
        (IsMulticast(&Info->This.Prefix) && Info->Publish) ||
        (IsSiteLocal(&Info->This.Prefix) && (Info->SitePrefixLength != 0)))
        return STATUS_INVALID_PARAMETER_7;

    if (IsUnspecified(&Info->This.Neighbor.Address)) {
        //
        // The prefix is on-link.
        //
        NCE = NULL;
    }
    else {
        //
        // REVIEW - Sanity check that the specified neighbor address
        // is reasonably on-link to the specified interface?
        // Perhaps only allow link-local next-hop addresses,
        // and other next-hops would imply recursive routing lookups?
        //
        if (IsInvalidSourceAddress(&Info->This.Neighbor.Address) ||
            IsLoopback(&Info->This.Neighbor.Address)) {
            return STATUS_INVALID_PARAMETER_2;
        }

        //
        // Find or create the specified neighbor.
        //
        NCE = FindOrCreateNeighbor(IF, &Info->This.Neighbor.Address);
        if (NCE == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create/update the specified route.
    //
    Status = RouteTableUpdate(FileObject,
                              IF, NCE,
                              &Info->This.Prefix,
                              Info->This.PrefixLength,
                              Info->SitePrefixLength,
                              ValidLifetime, PreferredLifetime,
                              Info->Preference,
                              Info->Type,
                              Info->Publish, Info->Immortal);
    if (NCE != NULL)
        ReleaseNCE(NCE);

    return Status;
}

//* CreatePersistentRoute
//
//  Creates a persistent route on an interface.
//
//  SubKeyName has the following syntax:
//      prefix/length->neighbor
//  where prefix and neighbor are literal IPv6 addresses.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
CreatePersistentRoute(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    Interface *IF = (Interface *) Context;
    IPV6_INFO_ROUTE_TABLE Info;
    HANDLE RouteKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the route key. We might want to delete it.
    //
    Status = OpenPersistentRoute(ParentKey, SubKeyName,
                                 &Info.This.Prefix,
                                 &Info.This.PrefixLength,
                                 &Info.This.Neighbor.Address,
                                 &RouteKey,
                                 OpenRegKeyDeleting);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the route key.
        // But we return success so the enumeration continues.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "CreatePersistentRoute(IF %u/%p %ls): bad key %ls\n",
                   IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
        return STATUS_SUCCESS;
    }

    //
    // Read route attributes.
    //
    ReadPersistentRoute(RouteKey, &Info);

    //
    // Create the route.
    //
    Status = InternalUpdateRouteTable(NULL, IF, &Info);
    if (! NT_SUCCESS(Status)) {
        if ((STATUS_INVALID_PARAMETER_1 <= Status) &&
            (Status <= STATUS_INVALID_PARAMETER_12)) {
            //
            // Invalid parameter.
            // But we return success so the enumeration continues.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "CreatePersistentRoute(IF %u/%p %ls): bad param %ls\n",
                       IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
            Status = STATUS_SUCCESS;
        }
        else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "CreatePersistentRoute(IF %u/%p %ls): error %ls\n",
                       IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
        }
    }
    else {
        //
        // If the route lifetime in the registry has expired,
        // so that the persistent route is now stale,
        // remove it from the registry.
        //
        if ((Info.ValidLifetime == 0) && !Info.Publish)
            (void) ZwDeleteKey(RouteKey);
    }

    ZwClose(RouteKey);
    return Status;
}

//* PersistUpdateRouteTable
//
//  Helper function for persisting route information in the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistUpdateRouteTable(
    Interface *IF,
    IPV6_INFO_ROUTE_TABLE *Info)
{
    HANDLE IFKey;
    HANDLE RouteKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // For persistent routes, we have some extra restrictions.
    //
    if (Info->Type != RTE_TYPE_MANUAL)
        return STATUS_CANNOT_MAKE;

    //
    // Open/create the interface key.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey,
                                 OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Open/create the route key.
    //
    Status = OpenRouteRegKey(IFKey,
                             &Info->This.Prefix,
                             Info->This.PrefixLength,
                             &Info->This.Neighbor.Address,
                             &RouteKey, OpenRegKeyCreate);
    ZwClose(IFKey);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Persist the route preference.
    //
    Status = SetRegDWORDValue(RouteKey, L"Preference",
                              Info->Preference);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseRouteKey;

    //
    // Persist the site prefix length.
    //
    Status = SetRegDWORDValue(RouteKey, L"SitePrefixLength",
                              Info->SitePrefixLength);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseRouteKey;

    //
    // Persist the Publish flag.
    //
    Status = SetRegDWORDValue(RouteKey, L"Publish", Info->Publish);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseRouteKey;

    //
    // Persist the Immortal flag.
    //
    Status = SetRegDWORDValue(RouteKey, L"Immortal", Info->Immortal);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseRouteKey;

    //
    // Persist the lifetimes.
    //
    Status = SetPersistentLifetimes(RouteKey, Info->Immortal,
                                    Info->ValidLifetime,
                                    Info->PreferredLifetime);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseRouteKey;

    Status = STATUS_SUCCESS;
ReturnReleaseRouteKey:
    ZwClose(RouteKey);
    return Status;
}

//* PersistDeleteRouteTable
//
//  Helper function for deleting route information from the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistDeleteRouteTable(
    Interface *IF,
    IPV6_INFO_ROUTE_TABLE *Info)
{
    HANDLE IFKey;
    HANDLE RouteKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the interface key. It's OK if it doesn't exist.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey,
                                 OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Open the route key. It's OK if it doesn't exist.
    //
    Status = OpenRouteRegKey(IFKey,
                             &Info->This.Prefix,
                             Info->This.PrefixLength,
                             &Info->This.Neighbor.Address,
                             &RouteKey, OpenRegKeyDeleting);
    ZwClose(IFKey);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Delete the route key.
    //
    Status = ZwDeleteKey(RouteKey);
    ZwClose(RouteKey);
    return Status;
}

//* IoctlUpdateRouteTable
//
//  Processes an IOCTL_IPV6_UPDATE_ROUTE_TABLE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateRouteTable(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_INFO_ROUTE_TABLE *Info;
    Interface *IF = NULL;
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_INFO_ROUTE_TABLE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(&Info->This.Neighbor.IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Update the routing table.
    //
    Status = InternalUpdateRouteTable(IrpSp->FileObject, IF, Info);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseIF;

    //
    // Make the change persistent?
    // This needs to happen after updating the running data structures,
    // to ensure that the change is correct before persisting it.
    //
    if (Persistent) {
        //
        // If the lifetime is zero and the route is not published,
        // then the route should be deleted. Otherwise we create the key.
        //
        if ((Info->ValidLifetime == 0) && !Info->Publish)
            Status = PersistDeleteRouteTable(IF, Info);
        else
            Status = PersistUpdateRouteTable(IF, Info);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseIF;
    }

    Status = STATUS_SUCCESS;
ReturnReleaseIF:
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdateRouteTable

//* InternalUpdateAddress
//
//  Common helper function for IoctlUpdateAddress
//  and CreatePersistentAddr, consolidating
//  parameter validation in one place.
//
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_2      Bad lifetime.
//      STATUS_INVALID_PARAMETER_3      Bad address.
//      STATUS_INVALID_PARAMETER_4      Bad type.
//      STATUS_INVALID_PARAMETER_5      Bad prefix origin.
//      STATUS_INVALID_PARAMETER_6      Bad interface id origin.
//      STATUS_UNSUCCESSFUL             Failure.
//
NTSTATUS
InternalUpdateAddress(
    Interface *IF,
    IPV6_UPDATE_ADDRESS *Info)
{
    uint ValidLifetime;
    uint PreferredLifetime;
    struct AddrConfEntry AddrConf;
    int rc;

    //
    // Convert the lifetime from seconds to ticks.
    //
    ValidLifetime = ConvertSecondsToTicks(Info->ValidLifetime);
    PreferredLifetime = ConvertSecondsToTicks(Info->PreferredLifetime);

    if (PreferredLifetime > ValidLifetime)
        return STATUS_INVALID_PARAMETER_2;

    //
    // Sanity check the address.
    //
    if (IsNotManualAddress(&Info->This.Address))
        return STATUS_INVALID_PARAMETER_3;

    AddrConf.PrefixConf = (uchar)Info->PrefixConf;
    AddrConf.InterfaceIdConf = (uchar)Info->InterfaceIdConf;

    //
    // We only support unicast and anycast addresses here.
    // Use the socket apis to join a multicast address.
    //
    if (Info->Type == ADE_UNICAST) {
        if (IsKnownAnycast(&Info->This.Address))
            return STATUS_INVALID_PARAMETER_3;

        if (! IsValidPrefixConfValue(Info->PrefixConf))
            return STATUS_INVALID_PARAMETER_5;

        if (! IsValidInterfaceIdConfValue(Info->InterfaceIdConf))
            return STATUS_INVALID_PARAMETER_6;

        if (AddrConf.Value == ADDR_CONF_TEMPORARY)
            return STATUS_INVALID_PARAMETER_6;
    }
    else if (Info->Type == ADE_ANYCAST) {
        if ((ValidLifetime != PreferredLifetime) ||
            ((ValidLifetime != 0) &&
             (ValidLifetime != INFINITE_LIFETIME)))
            return STATUS_INVALID_PARAMETER_2;

        if (Info->PrefixConf != PREFIX_CONF_MANUAL)
            return STATUS_INVALID_PARAMETER_5;

        if (Info->InterfaceIdConf != IID_CONF_MANUAL)
            return STATUS_INVALID_PARAMETER_6;
    }
    else {
        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Create/update/delete the address.
    //
    if (Info->Type == ADE_ANYCAST) {
        if (Info->ValidLifetime == 0)
            rc = FindAndDeleteAAE(IF, &Info->This.Address);
        else
            rc = FindOrCreateAAE(IF, &Info->This.Address, NULL);
    }
    else {
        rc = FindOrCreateNTE(IF, &Info->This.Address, AddrConf.Value,
                             ValidLifetime, PreferredLifetime);
    }
    if (rc)
        return STATUS_SUCCESS;
    else
        return STATUS_UNSUCCESSFUL;
}

//* CreatePersistentAddr
//
//  Given the name of a persistent address,
//  creates the address on an interface.
//
//  SubKeyName is a literal IPv6 address.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
CreatePersistentAddr(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    Interface *IF = (Interface *) Context;
    IPV6_UPDATE_ADDRESS Info;
    HANDLE AddrKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the address key. We might want to delete it.
    //
    Status = OpenPersistentAddress(ParentKey, SubKeyName,
                                   &Info.This.Address,
                                   &AddrKey,
                                   OpenRegKeyDeleting);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the address key.
        // But we return success so the enumeration continues.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "CreatePersistentAddr(IF %u/%p %ls): bad key %ls\n",
                   IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
        return STATUS_SUCCESS;
    }

    //
    // Read address attributes.
    //
    ReadPersistentAddress(AddrKey, &Info);

    //
    // Create the address.
    //
    Status = InternalUpdateAddress(IF, &Info);
    if (! NT_SUCCESS(Status)) {
        if ((STATUS_INVALID_PARAMETER_1 <= Status) &&
            (Status <= STATUS_INVALID_PARAMETER_12)) {
            //
            // Invalid parameter.
            // But we return success so the enumeration continues.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "CreatePersistentAddr(IF %u/%p %ls): bad param %ls\n",
                       IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
            Status = STATUS_SUCCESS;
        }
        else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "CreatePersistentAddr(IF %u/%p %ls): error %ls\n",
                       IF->Index, IF, IF->DeviceName.Buffer, SubKeyName));
        }
    }
    else {
        //
        // If the address lifetime in the registry has expired,
        // so that the persistent address is now stale,
        // remove it from the registry.
        //
        if (Info.ValidLifetime == 0)
            (void) ZwDeleteKey(AddrKey);
    }

    ZwClose(AddrKey);
    return Status;
}

//* PersistUpdateAddress
//
//  Helper function for persisting an address in the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistUpdateAddress(
    Interface *IF,
    IPV6_UPDATE_ADDRESS *Info)
{
    HANDLE IFKey;
    HANDLE AddrKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // For persistent addresses, we have extra restrictions.
    //
    if ((Info->PrefixConf != PREFIX_CONF_MANUAL) ||
        (Info->InterfaceIdConf != IID_CONF_MANUAL))
        return STATUS_CANNOT_MAKE;

    //
    // Open/create the interface key.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey,
                                 OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Open/create the address key.
    //
    Status = OpenAddressRegKey(IFKey, &Info->This.Address,
                               &AddrKey, OpenRegKeyCreate);
    ZwClose(IFKey);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Persist the address type.
    //
    Status = SetRegDWORDValue(AddrKey, L"Type", Info->Type);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseAddrKey;

    //
    // Persist the address lifetimes.
    //
    Status = SetPersistentLifetimes(AddrKey, FALSE,
                                    Info->ValidLifetime,
                                    Info->PreferredLifetime);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseAddrKey;

    Status = STATUS_SUCCESS;
ReturnReleaseAddrKey:
    ZwClose(AddrKey);
    return Status;
}

//* PersistDeleteAddress
//
//  Helper function for deleting an address from the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistDeleteAddress(
    Interface *IF,
    IPV6_UPDATE_ADDRESS *Info)
{
    HANDLE IFKey;
    HANDLE AddrKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the interface key. It's OK if it doesn't exist.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey,
                                 OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Open the address key. It's OK if it doesn't exist.
    //
    Status = OpenAddressRegKey(IFKey, &Info->This.Address,
                               &AddrKey, OpenRegKeyDeleting);
    ZwClose(IFKey);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Delete the address key.
    //
    Status = ZwDeleteKey(AddrKey);
    ZwClose(AddrKey);
    return Status;
}

//* IoctlUpdateAddress
//
//  Processes an IOCTL_IPV6_UPDATE_ADDRESS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_UPDATE_ADDRESS *Info;
    Interface *IF;
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_UPDATE_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(&Info->This.IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Update the address on the interface.
    //
    Status = InternalUpdateAddress(IF, Info);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseIF;

    //
    // Make the change persistent?
    // This needs to happen after updating the running data structures,
    // to ensure that the change is correct before persisting it.
    //
    if (Persistent) {
        //
        // If the lifetime is zero, we delete the address's key.
        // Otherwise the lifetime is infinite and we create the key.
        //
        if (Info->ValidLifetime == 0)
            Status = PersistDeleteAddress(IF, Info);
        else
            Status = PersistUpdateAddress(IF, Info);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseIF;
    }

    Status = STATUS_SUCCESS;
ReturnReleaseIF:
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdateAddress

//* IoctlQueryBindingCache
//
//  Processes an IOCTL_IPV6_QUERY_BINDING_CACHE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryBindingCache(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_BINDING_CACHE *Query;
    IPV6_INFO_BINDING_CACHE *Info;
    BindingCacheEntry *BCE;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Query structures overlap!
    //
    Query = (IPV6_QUERY_BINDING_CACHE *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_BINDING_CACHE *) Irp->AssociatedIrp.SystemBuffer;

    if (IsUnspecified(&Query->HomeAddress)) {
        //
        // Return the home address of the first BCE.
        //
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        if (BindingCache.First != SentinelBCE) {
            Info->Query.HomeAddress = BindingCache.First->HomeAddr;
        }
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Query;

    } else {
        //
        // Find the specified BCE.
        //
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        for (BCE = BindingCache.First; ; BCE = BCE->Next) {
            if (BCE == SentinelBCE) {
                KeReleaseSpinLock(&RouteCacheLock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->HomeAddress, &BCE->HomeAddr))
                break;
        }

        //
        // Return misc. information about the BCE.
        //
        Info->HomeAddress = BCE->HomeAddr;
        Info->CareOfAddress = BCE->CareOfRCE->Destination;
        Info->BindingSeqNumber = BCE->BindingSeqNumber;
        Info->BindingLifetime = ConvertTicksToSeconds(BCE->BindingLifetime);

        //
        // Return home address of the next BCE (or Unspecified).
        //
        if (BCE->Next == SentinelBCE) {
            Info->Query.HomeAddress = UnspecifiedAddr;
        } else {
            Info->Query.HomeAddress = BCE->Next->HomeAddr;
        }

        KeReleaseSpinLock(&RouteCacheLock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryBindingCache

//* InternalCreateInterface
//
//  Common helper function for IoctlCreateInterface
//  and CreatePersistentInterface, consolidating
//  parameter validation in one place.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad Type.
//      STATUS_INVALID_PARAMETER_2      Bad Flags.
//      STATUS_INVALID_PARAMETER_3      Bad SrcAddr.
//      STATUS_INVALID_PARAMETER_4      Bad DstAddr.
//      STATUS_ADDRESS_ALREADY_EXISTS   The interface already exists.
//      STATUS_INSUFFICIENT_RESOURCES
//      STATUS_UNSUCCESSFUL
//      STATUS_SUCCESS
//
NTSTATUS
InternalCreateInterface(
    IPV6_INFO_INTERFACE *Info,
    Interface **ReturnIF)
{
    IPAddr SrcAddr, DstAddr;
    int RouterDiscovers = Info->RouterDiscovers;
    int NeighborDiscovers = Info->NeighborDiscovers;
    int PeriodicMLD = Info->PeriodicMLD;
    int FirewallEnabled = Info->FirewallEnabled;
    uint Flags;

    if (Info->LinkLayerAddressLength != sizeof(IPAddr))
        return STATUS_INVALID_PARAMETER_1;

    switch (Info->Type) {
    case IF_TYPE_TUNNEL_V6V4:
        //
        // Set default values.
        //
        if (RouterDiscovers == -1)
            RouterDiscovers = FALSE;
        if (NeighborDiscovers == -1)
            NeighborDiscovers = FALSE;
        if (PeriodicMLD == -1)
            PeriodicMLD = FALSE;
        if (FirewallEnabled == -1)
            FirewallEnabled = FALSE;

        //
        // For now, require the ND and RD flags to be set the same.
        // Setting them differently should work, but it's not an important
        // scenario at the moment, and it would be more work to test.
        // This check can be removed in the future if desired.
        //
        if (NeighborDiscovers != RouterDiscovers)
            return STATUS_INVALID_PARAMETER_2;

        if (Info->LocalLinkLayerAddress == 0)
            return STATUS_INVALID_PARAMETER_3;

        if (Info->RemoteLinkLayerAddress == 0)
            return STATUS_INVALID_PARAMETER_4;

        SrcAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->LocalLinkLayerAddress);
        DstAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->RemoteLinkLayerAddress);
        break;

    case IF_TYPE_TUNNEL_6OVER4:
        //
        // Set default values.
        //
        if (RouterDiscovers == -1)
            RouterDiscovers = TRUE;
        if (NeighborDiscovers == -1)
            NeighborDiscovers = TRUE;
        if (PeriodicMLD == -1)
            PeriodicMLD = FALSE;
        if (FirewallEnabled == -1)
            FirewallEnabled = FALSE;

        //
        // For now, require the RD flag to be set in addition to ND.
        // PeriodicMLD is not allowed.
        //
        if (!RouterDiscovers || !NeighborDiscovers || PeriodicMLD)
            return STATUS_INVALID_PARAMETER_2;

        if (Info->LocalLinkLayerAddress == 0)
            return STATUS_INVALID_PARAMETER_3;

        if (Info->RemoteLinkLayerAddress != 0)
            return STATUS_INVALID_PARAMETER_4;

        SrcAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->LocalLinkLayerAddress);
        DstAddr = 0;
        break;

    default:
        return STATUS_INVALID_PARAMETER_1;
    }

    Flags = ((RouterDiscovers ? IF_FLAG_ROUTER_DISCOVERS : 0) |
             (NeighborDiscovers ? IF_FLAG_NEIGHBOR_DISCOVERS : 0) |
             (PeriodicMLD ? IF_FLAG_PERIODICMLD : 0) |
             (FirewallEnabled ? IF_FLAG_FIREWALL_ENABLED : 0));

    return TunnelCreateTunnel(SrcAddr, DstAddr, Flags, ReturnIF);
}

//* CreatePersistentInterface
//
//  Creates a persistent interface.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
CreatePersistentInterface(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    struct {
        IPV6_INFO_INTERFACE Info;
        IPAddr SrcAddr;
        IPAddr DstAddr;
    } Create;
    HANDLE IFKey;
    Interface *IF;
    WCHAR *InterfaceName;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Context);
    PAGED_CODE();

    //
    // Open the interface key.
    //
    Status = OpenPersistentInterface(ParentKey, SubKeyName,
                                     &Create.Info.This.Guid,
                                     &IFKey, OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the interface key.
        // But we return success so the enumeration continues.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "CreatePersistentInterface: bad key %ls\n",
                   SubKeyName));
        return STATUS_SUCCESS;
    }

    //
    // Let ReadPersistentInterface know how much space is available
    // for link-layer addresses.
    //
    Create.Info.Length = sizeof Create - sizeof Create.Info;

    //
    // Read interface attributes.
    //
    Status = ReadPersistentInterface(IFKey, &Create.Info);


    ZwClose(IFKey);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not read the interface key.
        // But we return success so the enumeration continues.
        //
        goto InvalidParameter;
    }

    //
    // Should we create an interface?
    //
    if (Create.Info.Type == (uint)-1)
        return STATUS_SUCCESS;

    //
    // Create the persistent interface.
    //
    Status = InternalCreateInterface(&Create.Info, &IF);
    if (! NT_SUCCESS(Status)) {
        if (((STATUS_INVALID_PARAMETER_1 <= Status) &&
             (Status <= STATUS_INVALID_PARAMETER_12)) ||
            (Status == STATUS_ADDRESS_ALREADY_EXISTS)) {
            //
            // Invalid parameter.
            // But we return success so the enumeration continues.
            //
        InvalidParameter:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "CreatePersistentInterface: bad param %ls\n",
                       SubKeyName));
            return STATUS_SUCCESS;
        }

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "CreatePersistentInterface: error %ls\n",
                   SubKeyName));
        return Status;
    }

    //
    // Consistency check. This is not an assertion because
    // someone editing the registry can make this fail.
    //
    InterfaceName = (WCHAR *)IF->DeviceName.Buffer +
           (sizeof IPV6_EXPORT_STRING_PREFIX / sizeof(WCHAR)) - 1;
    if (wcscmp(SubKeyName, InterfaceName) != 0) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "CreatePersistentInterface: inconsistency %ls IF %u/%p\n",
                   SubKeyName, IF->Index, IF));
    }


    ReleaseIF(IF);
    return STATUS_SUCCESS;
}

//* ConfigurePersistentInterfaces
//
//  Configures persistent interfaces from the registry.
//
//  Callable from thread context, not DPC context.
//
void
ConfigurePersistentInterfaces(void)
{
    HANDLE RegKey;
    NTSTATUS Status;

    //
    // Create persistent interfaces.
    //
    Status = OpenTopLevelRegKey(L"Interfaces", &RegKey, OpenRegKeyRead);
    if (NT_SUCCESS(Status)) {
        (void) EnumRegKeys(RegKey, CreatePersistentInterface, NULL);
        ZwClose(RegKey);
    }
}

//* PersistCreateInterface
//
//  Helper function for persisting an interface in the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistCreateInterface(
    Interface *IF,
    IPV6_INFO_INTERFACE *Info)
{
    HANDLE IFKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open/create the interface key.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey,
                                 OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Persist the interface type.
    //
    Status = SetRegDWORDValue(IFKey, L"Type", Info->Type);
    if (! NT_SUCCESS(Status))
        goto ReturnReleaseKey;

    //
    // Persist the interface flags.
    //

    if (Info->RouterDiscovers != -1) {
        Status = SetRegDWORDValue(IFKey, L"RouterDiscovers",
                                  Info->RouterDiscovers);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->NeighborDiscovers != -1) {
        Status = SetRegDWORDValue(IFKey, L"NeighborDiscovers",
                                  Info->NeighborDiscovers);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->PeriodicMLD != -1) {
        Status = SetRegDWORDValue(IFKey, L"PeriodicMLD",
                                  Info->PeriodicMLD);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->FirewallEnabled != -1) {
        Status = SetRegDWORDValue(IFKey, L"FirewallEnabled",
                                  Info->FirewallEnabled);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    switch (Info->Type) {
    case IF_TYPE_TUNNEL_6OVER4: {
        IPAddr SrcAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->LocalLinkLayerAddress);

        //
        // Persist the source address.
        //
        Status = SetRegIPAddrValue(IFKey, L"SrcAddr", SrcAddr);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
        break;
    }

    case IF_TYPE_TUNNEL_V6V4: {
        IPAddr SrcAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->LocalLinkLayerAddress);
        IPAddr DstAddr = * (IPAddr UNALIGNED *)
            ((char *)Info + Info->RemoteLinkLayerAddress);

        //
        // Persist the source address.
        //
        Status = SetRegIPAddrValue(IFKey, L"SrcAddr", SrcAddr);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;

        //
        // Persist the destination address.
        //
        Status = SetRegIPAddrValue(IFKey, L"DstAddr", DstAddr);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
        break;
    }
    }

    Status = STATUS_SUCCESS;
ReturnReleaseKey:
    ZwClose(IFKey);
    return Status;
}

//* IoctlCreateInterface
//
//  Processes an IOCTL_IPV6_CREATE_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlCreateInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_INFO_INTERFACE *Info;
    IPV6_QUERY_INTERFACE *Result;
    Interface *IF;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Initialize now for error paths.
    //
    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof *Info) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Result)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_INFO_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;
    Result = (IPV6_QUERY_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Check that the structure and link-layer addresses, if supplied,
    // fit in the buffer. Watch out for addition overflow.
    //
    if ((Info->Length < sizeof *Info) ||
        (Info->Length > IrpSp->Parameters.DeviceIoControl.InputBufferLength) ||
        ((Info->LocalLinkLayerAddress != 0) &&
         (((Info->LocalLinkLayerAddress + Info->LinkLayerAddressLength) >
           IrpSp->Parameters.DeviceIoControl.InputBufferLength) ||
          ((Info->LocalLinkLayerAddress + Info->LinkLayerAddressLength) <
           Info->LocalLinkLayerAddress))) ||
        ((Info->RemoteLinkLayerAddress != 0) &&
         (((Info->RemoteLinkLayerAddress + Info->LinkLayerAddressLength) >
           IrpSp->Parameters.DeviceIoControl.InputBufferLength) ||
          ((Info->RemoteLinkLayerAddress + Info->LinkLayerAddressLength) <
           Info->RemoteLinkLayerAddress)))) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Create the interface.
    //
    Status = InternalCreateInterface(Info, &IF);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // Make the change persistent?
    // This needs to happen after updating the running data structures,
    // to ensure that the change is correct before persisting it.
    //
    if (Persistent) {
        Status = PersistCreateInterface(IF, Info);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseIF;
    }

    //
    // Return query information for the new interface.
    //
    ReturnQueryInterface(IF, Result);
    Irp->IoStatus.Information = sizeof *Result;

    Status = STATUS_SUCCESS;
ReturnReleaseIF:
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlCreateInterface


//* AreIndicesSpecified
//
//  Are there any non-zero zone indices in the array?
//
int
AreIndicesSpecified(uint ZoneIndices[ADE_NUM_SCOPES])
{
    ushort Scope;

    for (Scope = ADE_SMALLEST_SCOPE; Scope <= ADE_LARGEST_SCOPE; Scope++)
        if (ZoneIndices[Scope] != 0)
            return TRUE;

    return FALSE;
}

//* CheckZoneIndices
//
//  Checks consistency of a zone update,
//  and fills in unspecified values.
//  Returns FALSE if there is an inconsistency.
//
//  The logic for filling in unspecified values makes it
//  more convenient for a user to change zone indices.
//  For example, an user can change an interface's site index
//  and the subnet & admin indices will be automatically changed.
//
//  Called with the global ZoneUpdateLock held.
//
int
CheckZoneIndices(Interface *IF, uint ZoneIndices[ADE_NUM_SCOPES])
{
    Interface *OtherIF;
    uint Scope, i;

    //
    // Zone indices 0 (ADE_SMALLEST_SCOPE) and 1 (ADE_INTERFACE_LOCAL)
    // are special and must have the value IF->Index.
    //
    if (ZoneIndices[ADE_SMALLEST_SCOPE] == 0)
        ZoneIndices[ADE_SMALLEST_SCOPE] = IF->Index;
    else if (ZoneIndices[ADE_SMALLEST_SCOPE] != IF->Index)
        return FALSE;

    if (ZoneIndices[ADE_INTERFACE_LOCAL] == 0)
        ZoneIndices[ADE_INTERFACE_LOCAL] = IF->Index;
    else if (ZoneIndices[ADE_INTERFACE_LOCAL] != IF->Index)
        return FALSE;

    //
    // Zone indices 14 (ADE_GLOBAL) and 15 (ADE_LARGEST_SCOPE) are special
    // and must have the value one.
    //
    if (ZoneIndices[ADE_GLOBAL] == 0)
        ZoneIndices[ADE_GLOBAL] = 1;
    else if (ZoneIndices[ADE_GLOBAL] != 1)
        return FALSE;

    if (ZoneIndices[ADE_LARGEST_SCOPE] == 0)
        ZoneIndices[ADE_LARGEST_SCOPE] = 1;
    else if (ZoneIndices[ADE_LARGEST_SCOPE] != 1)
        return FALSE;

    for (Scope = ADE_LINK_LOCAL; Scope < ADE_GLOBAL; Scope++) {
        if (ZoneIndices[Scope] == 0) {
            //
            // The user did not specify the zone index for this scope.
            // If leaving the current zone index unchanged works,
            // then we prefer to do that. However, the user may be changing
            // the zone index for a larger scope. If necessary
            // for consistency, then we use a new zone index at this scope.
            //
            for (i = Scope+1; i < ADE_GLOBAL; i++) {
                if (ZoneIndices[i] != 0) {
                    //
                    // If we use the current value at level Scope,
                    // would it cause an inconsistency at level i?
                    //
                    OtherIF = FindInterfaceFromZone(IF,
                                        Scope, IF->ZoneIndices[Scope]);
                    if (OtherIF != NULL) {
                        if (OtherIF->ZoneIndices[i] != ZoneIndices[i]) {
                            Interface *ExistingIF;

                            //
                            // Yes. We need a different zone index.
                            // Is there an existing one that we can reuse?
                            //
                            ExistingIF = FindInterfaceFromZone(IF,
                                        i, ZoneIndices[i]);
                            if (ExistingIF != NULL) {
                                //
                                // Yes, reuse the existing zone index.
                                //
                                ZoneIndices[Scope] = ExistingIF->ZoneIndices[Scope];
                                ReleaseIF(ExistingIF);
                            }
                            else {
                                //
                                // No, we need a new zone index.
                                //
                                ZoneIndices[Scope] = FindNewZoneIndex(Scope);
                            }
                        }
                        ReleaseIF(OtherIF);
                    }
                    break;
                }
            }

            if (ZoneIndices[Scope] == 0) {
                //
                // Use the current value from the interface.
                //
                ZoneIndices[Scope] = IF->ZoneIndices[Scope];
            }
        }

        OtherIF = FindInterfaceFromZone(IF, Scope, ZoneIndices[Scope]);
        if (OtherIF != NULL) {
            //
            // Enforce the zone containment invariant.
            //
            while (++Scope < ADE_GLOBAL) {
                if (ZoneIndices[Scope] == 0)
                    ZoneIndices[Scope] = OtherIF->ZoneIndices[Scope];
                else if (ZoneIndices[Scope] != OtherIF->ZoneIndices[Scope]) {
                    ReleaseIF(OtherIF);
                    return FALSE;
                }
            }
            ReleaseIF(OtherIF);
            return TRUE;
        }
    }

    return TRUE;
}

//* InternalUpdateInterface
//
//  Common helper function for IoctlUpdateInterface
//  and ConfigureInterface, consolidating
//  parameter validation in one place.
//
//  The IF argument supercedes Info->This.IF.
//  Does not implement Info->Renew.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad Interface.
//      STATUS_INVALID_PARAMETER_2      Bad Preference.
//      STATUS_INVALID_PARAMETER_3      Bad LinkMTU.
//      STATUS_INVALID_PARAMETER_4      Bad BaseReachableTime.
//      STATUS_INVALID_PARAMETER_5      Bad CurHopLimit.
//      STATUS_INVALID_PARAMETER_6      Bad DefSitePrefixLength.
//      STATUS_INSUFFICIENT_RESOURCES
//      STATUS_SUCCESS
//
NTSTATUS
InternalUpdateInterface(
    Interface *IF,
    IPV6_INFO_INTERFACE *Info)
{
    KIRQL OldIrql;
    NTSTATUS Status;

    if ((Info->Preference != (uint)-1) &&
        ! IsValidPreference(Info->Preference))
        return STATUS_INVALID_PARAMETER_2;

    if ((Info->LinkMTU != 0) &&
        ! ((IPv6_MINIMUM_MTU <= Info->LinkMTU) &&
           (Info->LinkMTU <= IF->TrueLinkMTU)))
        return STATUS_INVALID_PARAMETER_3;

    if ((Info->BaseReachableTime != 0) &&
        (Info->BaseReachableTime > MAX_REACHABLE_TIME))
        return STATUS_INVALID_PARAMETER_4;

    if ((Info->CurHopLimit != (uint)-1) &&
        (Info->CurHopLimit >= 256))
        return STATUS_INVALID_PARAMETER_5;

    if ((Info->DefSitePrefixLength != (uint)-1) &&
        (Info->DefSitePrefixLength > IPV6_ADDRESS_LENGTH))
        return STATUS_INVALID_PARAMETER_6;

    if (AreIndicesSpecified(Info->ZoneIndices)) {
        //
        // Fill in unspecified values in the ZoneIndices array
        // and check for illegal values.
        // The global lock ensures consistency across interfaces.
        //
        KeAcquireSpinLock(&ZoneUpdateLock, &OldIrql);
        if (! CheckZoneIndices(IF, Info->ZoneIndices)) {
            KeReleaseSpinLock(&ZoneUpdateLock, OldIrql);
            return STATUS_INVALID_PARAMETER_3;
        }

        //
        // Update the ZoneIndices.
        //
        KeAcquireSpinLockAtDpcLevel(&IF->Lock);
        UpdateZoneIndices(IF, Info->ZoneIndices);
        KeReleaseSpinLockFromDpcLevel(&IF->Lock);
        InvalidateRouteCache();
        KeReleaseSpinLock(&ZoneUpdateLock, OldIrql);
    }

    //
    // Update the forwarding and advertising attributes.
    // We must update the advertising attribute before
    // any auto-configured attributes, because
    // InterfaceResetAutoConfig will reset them.
    //
    Status = UpdateInterface(IF, Info->Advertises, Info->Forwards);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Update the link MTU.
    //
    if (Info->LinkMTU != 0)
        UpdateLinkMTU(IF, Info->LinkMTU);

    //
    // Update the interface's routing preference.
    //
    if (Info->Preference != (uint)-1) {
        //
        // No lock needed.
        //
        IF->Preference = Info->Preference;
        InvalidateRouteCache();
    }

    //
    // Update the base reachable time.
    //
    if (Info->BaseReachableTime != 0) {
        KeAcquireSpinLock(&IF->Lock, &OldIrql);
        IF->BaseReachableTime = Info->BaseReachableTime;
        IF->ReachableTime = CalcReachableTime(Info->BaseReachableTime);
        KeReleaseSpinLock(&IF->Lock, OldIrql);
    }

    //
    // Update the ND retransmission timer.
    //
    if (Info->RetransTimer != 0) {
        //
        // No lock needed.
        //
        IF->RetransTimer = ConvertMillisToTicks(Info->RetransTimer);
    }

    //
    // Update the number of DAD transmissions.
    //
    if (Info->DupAddrDetectTransmits != (uint)-1) {
        //
        // No lock needed.
        //
        IF->DupAddrDetectTransmits = Info->DupAddrDetectTransmits;
    }

    //
    // Update the default hop limit.
    //
    if (Info->CurHopLimit != (uint)-1) {
        //
        // No lock needed.
        //
        IF->CurHopLimit = Info->CurHopLimit;
    }

    //
    // Update the firewall mode.
    //
    if (Info->FirewallEnabled != -1) {
        KeAcquireSpinLock(&IF->Lock, &OldIrql);
        if (Info->FirewallEnabled)
            IF->Flags |= IF_FLAG_FIREWALL_ENABLED;
        else
            IF->Flags &= ~IF_FLAG_FIREWALL_ENABLED;
        KeReleaseSpinLock(&IF->Lock, OldIrql);
    }

    //
    // Update the default site prefix length.
    //
    if (Info->DefSitePrefixLength != (uint)-1) {
        //
        // No lock needed.
        //
        IF->DefSitePrefixLength = Info->DefSitePrefixLength;
    }

    return STATUS_SUCCESS;
}

//* ConfigureInterface
//
//  Configures a newly-created interface from the registry.
//  The interface has not yet been added to the global list,
//  but it is otherwise fully initialized.
//
//  Callable from thread context, not DPC context.
//
void
ConfigureInterface(Interface *IF)
{
    IPV6_INFO_INTERFACE Info;
    HANDLE IFKey;
    HANDLE RegKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the interface key.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey, OpenRegKeyRead);
    if (! NT_SUCCESS(Status))
        return;

    //
    // Read interface attributes.
    //
    Info.Length = 0;
    Status = ReadPersistentInterface(IFKey, &Info);
    ASSERT(NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW));

    //
    // Update the interface.
    //
    Status = InternalUpdateInterface(IF, &Info);
    if (! NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "ConfigureInterface: bad params %x\n", Status));
    }

    //
    // Create persistent addresses.
    //
    Status = OpenRegKey(&RegKey, IFKey, L"Addresses", OpenRegKeyRead);
    if (NT_SUCCESS(Status)) {
        (void) EnumRegKeys(RegKey, CreatePersistentAddr, IF);
        ZwClose(RegKey);
    }

    //
    // Create persistent routes.
    //
    Status = OpenRegKey(&RegKey, IFKey, L"Routes", OpenRegKeyRead);
    if (NT_SUCCESS(Status)) {
        (void) EnumRegKeys(RegKey, CreatePersistentRoute, IF);
        ZwClose(RegKey);
    }


    InitRegDWORDParameter(IFKey, L"TcpInitialRTT",
                          &IF->TcpInitialRTT, 0);

    ZwClose(IFKey);
}

//* PersistUpdateInterface
//
//  Helper function for persisting interface attributes in the registry.
//  The IF argument supercedes Info->This.IF.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistUpdateInterface(
    Interface *IF,
    IPV6_INFO_INTERFACE *Info)
{
    HANDLE RegKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenInterfaceRegKey(&IF->Guid, &RegKey,
                                 OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    if (Info->Advertises != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"Advertises",
                                  Info->Advertises);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->Forwards != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"Forwards",
                                  Info->Forwards);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->FirewallEnabled != -1) {
        Status = SetRegDWORDValue(RegKey, L"FirewallEnabled",
                                  Info->FirewallEnabled);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->LinkMTU != 0) {
        Status = SetRegDWORDValue(RegKey, L"LinkMTU",
                                  Info->LinkMTU);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->Preference != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"Preference",
                                  Info->Preference);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->BaseReachableTime != 0) {
        Status = SetRegDWORDValue(RegKey, L"BaseReachableTime",
                                  Info->BaseReachableTime);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->RetransTimer != 0) {
        Status = SetRegDWORDValue(RegKey, L"RetransTimer",
                                  Info->RetransTimer);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->DupAddrDetectTransmits != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"DupAddrDetectTransmits",
                                  Info->DupAddrDetectTransmits);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->CurHopLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"CurHopLimit",
                                  Info->CurHopLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Info->DefSitePrefixLength != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"DefSitePrefixLength",
                                  Info->DefSitePrefixLength);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    Status = STATUS_SUCCESS;
ReturnReleaseKey:
    ZwClose(RegKey);
    return Status;
}

//* IoctlUpdateInterface
//
//  Processes an IOCTL_IPV6_UPDATE_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_INFO_INTERFACE *Info;
    Interface *IF;
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    Info = (IPV6_INFO_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(&Info->This);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto ErrorReturn;
    }

    //
    // Validate parameters and update the interface.
    //
    Status = InternalUpdateInterface(IF, Info);
    if (! NT_SUCCESS(Status))
        goto ErrorReturnReleaseIF;

    //
    // Make the changes persistent?
    //
    if (Persistent) {
        Status = PersistUpdateInterface(IF, Info);
        if (! NT_SUCCESS(Status))
            goto ErrorReturnReleaseIF;
    }

    Status = STATUS_SUCCESS;
ErrorReturnReleaseIF:
    ReleaseIF(IF);
ErrorReturn:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdateInterface

//* PersistDeleteInterface
//
//  Helper function for deleting an interface in the registry.
//  We do not delete the interface key.
//  Instead we just delete the Type value.
//  This way persistent interface attributes (if any) remain.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistDeleteInterface(
    Interface *IF)
{
    HANDLE IFKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the interface key.
    //
    Status = OpenInterfaceRegKey(&IF->Guid, &IFKey, OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Delete the Type value.
    //
    Status = RegDeleteValue(IFKey, L"Type");
    ZwClose(IFKey);
    return Status;
}

//* IoctlDeleteInterface
//
//  Processes an IOCTL_IPV6_DELETE_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlDeleteInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_QUERY_INTERFACE *Info;
    Interface *IF;
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_QUERY_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Can not delete some predefined interfaces.
    // 6to4svc and other user-level things depend
    // on these standard interfaces.
    //
    if (Info->Index <= 3) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(Info);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // This will disable the interface, so it will effectively
    // disappear. When the last ref is gone it will be freed.
    //
    DestroyIF(IF);

    //
    // Make the changes persistent?
    //
    if (Persistent) {
        Status = PersistDeleteInterface(IF);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseIF;
    }

    Status = STATUS_SUCCESS;
ReturnReleaseIF:
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlDeleteInterface


//* IoctlRenewInterface
//
//  Processes an IOCTL_IPV6_RENEW_INTERFACE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlRenewInterface(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_INTERFACE *Query;
    Interface *IF;
    KIRQL OldIrql;
    NTSTATUS Status;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_INTERFACE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(Query);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Pretend as if the interface received a media reconnect
    // event, but only if the interface is already connected.
    //
    // This IOCTL is used by 802.1x to indicate successful data link
    // authentication of this interface.  Any data packets already sent
    // on this interface would have been dropped by the authenticator,
    // and hence IPv6 needs to restart its protocol mechanisms, i.e.
    // resend Router Solicitation|Advertisement, Multicast Listener
    // Discovery, and Duplicate Address Detection messages.
    //

    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    if (!IsDisabledIF(IF) && !(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED))
        ReconnectInterface(IF);
    KeReleaseSpinLock(&IF->Lock, OldIrql);

    Status = STATUS_SUCCESS;
    ReleaseIF(IF);
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlRenewInterface


//* IoctlFlushNeighborCache
//
//  Processes an IOCTL_IPV6_FLUSH_NEIGHBOR_CACHE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlFlushNeighborCache(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_NEIGHBOR_CACHE *Query;
    Interface *IF;
    const IPv6Addr *Address;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_NEIGHBOR_CACHE *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(&Query->IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    if (IsUnspecified(&Query->Address))
        Address = NULL;
    else
        Address = &Query->Address;

    NeighborCacheFlush(IF, Address);
    ReleaseIF(IF);
    Status = STATUS_SUCCESS;

  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlFlushNeighborCache


//* IoctlFlushRouteCache
//
//  Processes an IOCTL_IPV6_FLUSH_ROUTE_CACHE request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlFlushRouteCache(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_ROUTE_CACHE *Query;
    Interface *IF;
    const IPv6Addr *Address;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_ROUTE_CACHE *) Irp->AssociatedIrp.SystemBuffer;

    if (Query->IF.Index == (uint)-1) {
        IF = NULL;
    }
    else {
        //
        // Find the specified interface.
        //
        IF = FindInterfaceFromQuery(&Query->IF);
        if (IF == NULL) {
            Status = STATUS_INVALID_PARAMETER_1;
            goto Return;
        }
    }

    if (IsUnspecified(&Query->Address))
        Address = NULL;
    else
        Address = &Query->Address;

    FlushRouteCache(IF, Address);
    if (IF != NULL)
        ReleaseIF(IF);
    Status = STATUS_SUCCESS;

  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlFlushRouteCache

//* IoctlSortDestAddrs
//
//  Processes an IOCTL_IPV6_SORT_DEST_ADDRS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlSortDestAddrs(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_ADDRESS_IP6 *Addrs;
    uint *Key;
    uint NumAddrsIn, NumAddrsOut;
    uint i;
    NTSTATUS Status;
    SIZE_T GapSize;
    
    PAGED_CODE();

    
    NumAddrsIn = IrpSp->Parameters.DeviceIoControl.InputBufferLength /
                                                sizeof(TDI_ADDRESS_IP6);
    NumAddrsOut = NumAddrsIn;       
    

    //
    // The addition in the 3rd part of the if statement can overflow,
    // to prevent this, we limit the InputBufferLength to MAXLONG.
    //
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength > (ULONG) MAXLONG) ||
        (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
                NumAddrsIn * sizeof(TDI_ADDRESS_IP6)) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                ALIGN_UP(NumAddrsIn * sizeof(TDI_ADDRESS_IP6), uint) +
                NumAddrsOut * sizeof(uint))) {
        Irp->IoStatus.Information = 0;
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Addrs = Irp->AssociatedIrp.SystemBuffer;
    Key = (uint *)ALIGN_UP_POINTER(Addrs + NumAddrsIn, uint);

    //
    // Zero the unitialized portion of the output buffer.
    //
    GapSize = (ULONG_PTR) Key - (ULONG_PTR) (Addrs + NumAddrsIn);
    
    if (GapSize > 0) {
        RtlZeroMemory(Addrs + NumAddrsIn, GapSize);
    }
    
    //
    // Initialize key array.
    //
    for (i = 0; i < NumAddrsIn; i++)
        Key[i] = i;

    if (NumAddrsOut > 1) {
        //
        // Remove inappropriate site-local addresses
        // and set the scope-id of site-local addresses.
        //
        ProcessSiteLocalAddresses(Addrs, Key, &NumAddrsOut);

        //
        // Sort the remaining addresses.
        //
        if (NumAddrsOut > 1)
            SortDestAddresses(Addrs, Key, NumAddrsOut);
    }

    Irp->IoStatus.Information = ALIGN_UP(NumAddrsIn * sizeof(TDI_ADDRESS_IP6), uint)
                              + (NumAddrsOut * sizeof(uint));
    Status = STATUS_SUCCESS;

  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
} // IoctlSortDestAddrs.

//* IoctlQuerySitePrefix
//
//  Processes an IOCTL_IPV6_QUERY_SITE_PREFIX request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQuerySitePrefix(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_SITE_PREFIX *Query;
    IPV6_INFO_SITE_PREFIX *Info;
    SitePrefixEntry *SPE;
    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Query structures overlap!
    //
    Query = (IPV6_QUERY_SITE_PREFIX *) Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_SITE_PREFIX *) Irp->AssociatedIrp.SystemBuffer;

    if (Query->IF.Index == 0) {
        //
        // Return query parameters of the first SPE.
        //
        KeAcquireSpinLock(&RouteTableLock, &OldIrql);
        if ((SPE = SitePrefixTable) != NULL) {
            Info->Query.Prefix = SPE->Prefix;
            Info->Query.PrefixLength = SPE->SitePrefixLength;
            Info->Query.IF.Index = SPE->IF->Index;
        }
        KeReleaseSpinLock(&RouteTableLock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Query;

    } else {
        //
        // Find the specified SPE.
        //
        KeAcquireSpinLock(&RouteTableLock, &OldIrql);
        for (SPE = SitePrefixTable; ; SPE = SPE->Next) {
            if (SPE == NULL) {
                KeReleaseSpinLock(&RouteTableLock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->Prefix, &SPE->Prefix) &&
                (Query->PrefixLength == SPE->SitePrefixLength) &&
                (Query->IF.Index == SPE->IF->Index))
                break;
        }

        //
        // Return misc. information about the SPE.
        //
        Info->ValidLifetime = ConvertTicksToSeconds(SPE->ValidLifetime);

        //
        // Return query parameters of the next SPE (or zero).
        //
        if ((SPE = SPE->Next) == NULL) {
            Info->Query.IF.Index = 0;
        } else {
            Info->Query.Prefix = SPE->Prefix;
            Info->Query.PrefixLength = SPE->SitePrefixLength;
            Info->Query.IF.Index = SPE->IF->Index;
        }

        KeReleaseSpinLock(&RouteTableLock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQuerySitePrefix


//* IoctlUpdateSitePrefix
//
//  Processes an IOCTL_IPV6_UPDATE_SITE_PREFIX request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateSitePrefix(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_INFO_SITE_PREFIX *Info;
    Interface *IF = NULL;
    uint ValidLifetime;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_INFO_SITE_PREFIX *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Sanity check the arguments.
    //
    if (Info->Query.PrefixLength > IPV6_ADDRESS_LENGTH) {
        Status = STATUS_INVALID_PARAMETER_3;
        goto Return;
    }

    //
    // Find the specified interface.
    //
    IF = FindInterfaceFromQuery(&Info->Query.IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Convert the lifetime from seconds to ticks.
    //
    ValidLifetime = ConvertSecondsToTicks(Info->ValidLifetime);

    //
    // Create/update the specified site prefix.
    //
    SitePrefixUpdate(IF,
                     &Info->Query.Prefix,
                     Info->Query.PrefixLength,
                     ValidLifetime);

    Irp->IoStatus.Information = 0;
    Status = STATUS_SUCCESS;
  Return:
    if (IF != NULL)
        ReleaseIF(IF);
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdateSitePrefix


//* CancelRtChangeNotifyRequest
//
//  The IO manager calls this function when a route change
//  notification request is cancelled.
//
//  Called with the cancel spinlock held.
//
void
CancelRtChangeNotifyRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    int ShouldComplete;

    UNREFERENCED_PARAMETER(DeviceObject);

    ASSERT(Irp->Cancel);
    ASSERT(Irp->CancelRoutine == NULL);

    //
    // The route lock protects the queue.
    //
    KeAcquireSpinLockAtDpcLevel(&RouteTableLock);

    ShouldComplete = (Irp->Tail.Overlay.ListEntry.Flink != NULL);
    if (ShouldComplete) {
        //
        // CheckRtChangeNotifyRequests has not removed
        // this request from the queue. So we remove the request
        // and complete it below.
        //
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    }
    else {
        //
        // CheckRtChangeNotifyRequests has removed
        // this request from the queue. We must not
        // touch the Irp after unlocking because
        // CompleteRtChangeNotifyRequests could complete it.
        //
    }

    KeReleaseSpinLockFromDpcLevel(&RouteTableLock);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    if (ShouldComplete) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
}

//* CheckFileObjectInIrpList
//
//  Looks to see if an Irp in the list has the given file object.
//
int
CheckFileObjectInIrpList(PFILE_OBJECT FileObject, PIRP Irp)
{
    PIO_STACK_LOCATION IrpSp;

    while (Irp != NULL) {
        IrpSp = IoGetCurrentIrpStackLocation(Irp);
        if (IrpSp->FileObject == FileObject)
            return TRUE;

        Irp = (PIRP) Irp->Tail.Overlay.ListEntry.Blink;
    }

    return FALSE;
}

//* CheckRtChangeNotifyRequests
//
//  Searches the queue of route change notification requests.
//  Moves any matching requests (that should be completed)
//  to a temporary list kept in the context structure.
//
//  Called with the route lock held.
//
void
CheckRtChangeNotifyRequests(
    CheckRtChangeContext *Context,
    PFILE_OBJECT FileObject,
    RouteTableEntry *RTE)
{
    LIST_ENTRY *ListEntry;
    LIST_ENTRY *NextListEntry;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    IPV6_RTCHANGE_NOTIFY_REQUEST *Request;
    PIRP *ThisChangeList;

    //
    // *ThisChangeList is the tail of Context->RequestList
    // that was added as a result of this change.
    //
    ThisChangeList = Context->LastRequest;

    for (ListEntry = RouteNotifyQueue.Flink;
         ListEntry != &RouteNotifyQueue;
         ListEntry = NextListEntry) {
        NextListEntry = ListEntry->Flink;

        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                                                        sizeof *Request)
            Request = (IPV6_RTCHANGE_NOTIFY_REQUEST *)
                Irp->AssociatedIrp.SystemBuffer;
        else
            Request = NULL;

        if ((Request == NULL) ||
            (IntersectPrefix(&RTE->Prefix, RTE->PrefixLength,
                             &Request->Prefix, Request->PrefixLength) &&
             ((Request->ScopeId == 0) ||
              (Request->ScopeId == DetermineScopeId(&Request->Prefix,
                                                    RTE->IF))))) {

            //
            // This request matches the route change.
            // But we might still suppress notification.
            //

            if ((Request != NULL) &&
                (((Request->Flags &
                        IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SUPPRESS_MINE) &&
                  (IrpSp->FileObject == FileObject)) ||
                 ((Request->Flags &
                        IPV6_RTCHANGE_NOTIFY_REQUEST_FLAG_SYNCHRONIZE) &&
                  CheckFileObjectInIrpList(IrpSp->FileObject,
                                           *ThisChangeList)))) {
                //
                // The request matches, but suppress notification.
                //
            }
            else {
                //
                // Before we remove the Irp from RouteNotifyQueue,
                // may need to allocate a work item & work context.
                // If the allocation fails, we can bail without doing anything.
                //
                if ((Context->OldIrql >= DISPATCH_LEVEL) &&
                    (Context->Context == NULL)) {
                    CompleteRtChangeContext *MyContext;

                    MyContext = ExAllocatePool(NonPagedPool,
                                               sizeof *MyContext);
                    if (MyContext == NULL)
                        return;

                    MyContext->WorkItem = IoAllocateWorkItem(IPDeviceObject);
                    if (MyContext->WorkItem == NULL) {
                        ExFreePool(MyContext);
                        return;
                    }

                    Context->Context = MyContext;
                }

                //
                // We will complete this pending notification,
                // so remove it from RouteNotifyQueue and
                // put it on our private list.
                //
                RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

                Irp->Tail.Overlay.ListEntry.Flink = NULL;
                Irp->Tail.Overlay.ListEntry.Blink = NULL;

                *Context->LastRequest = Irp;
                Context->LastRequest = (PIRP *)
                    &Irp->Tail.Overlay.ListEntry.Blink;

                //
                // Return output information, if requested.
                //
                if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >=
                                              sizeof(IPV6_INFO_ROUTE_TABLE)) {
                    IPV6_INFO_ROUTE_TABLE *Info = (IPV6_INFO_ROUTE_TABLE *)
                        Irp->AssociatedIrp.SystemBuffer;

                    //
                    // Return misc. information about the RTE.
                    //
                    RouteTableInfo(RTE, RTE, Info);
                    Irp->IoStatus.Information = sizeof *Info;
                }
                else
                    Irp->IoStatus.Information = 0;
            }
        }
    }
}

//* CompleteRtChangeNotifyRequestsHelper
//
//  Completes a list of route change notification requests.
//
//  Callable from thread context, not DPC context.
//  May NOT be called with the route lock held.
//
void
CompleteRtChangeNotifyRequestsHelper(PIRP RequestList)
{
    PIRP Irp;
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // RequestList is singly-linked through the Blink field.
    // The Flink field is NULL; CancelRtChangeNotifyRequest
    // looks at this.
    //
    while ((Irp = RequestList) != NULL) {
        ASSERT(Irp->Tail.Overlay.ListEntry.Flink == NULL);
        RequestList = (PIRP) Irp->Tail.Overlay.ListEntry.Blink;

        IoAcquireCancelSpinLock(&OldIrql);
        if (Irp->Cancel) {
            //
            // The Irp is being cancelled.
            //
            ASSERT(Irp->CancelRoutine == NULL);

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_CANCELLED;
        }
        else {
            //
            // The Irp is not yet cancelled.
            // We must prevent CancelRtChangeNotifyRequest
            // from being called after we release the cancel lock.
            //
            ASSERT(Irp->CancelRoutine == CancelRtChangeNotifyRequest);
            IoSetCancelRoutine(Irp, NULL);

            //
            // Irp->IoStatus.Information and the output structure
            // are already initialized.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        IoReleaseCancelSpinLock(OldIrql);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
}

//* CompleteRtChangeNotifyRequestsWorker
//
//  Worker thread function - cleans up the work item
//  and calls CompleteRtChangeNotifyRequestsHelper.
//
void
CompleteRtChangeNotifyRequestsWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context)
{
    CompleteRtChangeContext *MyContext = Context;

    UNREFERENCED_PARAMETER(DeviceObject);

    CompleteRtChangeNotifyRequestsHelper(MyContext->RequestList);

    IoFreeWorkItem(MyContext->WorkItem);
    ExFreePool(MyContext);
}

//* CompleteRtChangeNotifyRequests
//
//  Completes a list of route change notification requests.
//
//  Callable from a thread or DPC context.
//  May NOT be called with the route lock held.
//
void
CompleteRtChangeNotifyRequests(CheckRtChangeContext *Context)
{
    ASSERT(Context->OldIrql == KeGetCurrentIrql());
    if (Context->OldIrql >= DISPATCH_LEVEL) {
        CompleteRtChangeContext *MyContext = Context->Context;

        //
        // We can't complete Irps at dispatch level,
        // so punt to a worker thread.
        // The work item was already allocated.
        //

        MyContext->RequestList = Context->RequestList;
        IoQueueWorkItem(MyContext->WorkItem,
                        CompleteRtChangeNotifyRequestsWorker,
                        CriticalWorkQueue,
                        MyContext);
    }
    else {
        //
        // We can complete the Irps directly.
        //
        ASSERT(Context->Context == NULL);
        CompleteRtChangeNotifyRequestsHelper(Context->RequestList);
    }
}

//* IoctlRtChangeNotifyRequest
//
//  Processes an IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlRtChangeNotifyRequest(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS Status;
    KIRQL OldIrql;

    PAGED_CODE();

    if (((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(IPV6_RTCHANGE_NOTIFY_REQUEST)) &&
         (IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0)) ||
        ((IrpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IPV6_INFO_ROUTE_TABLE)) &&
         (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0))) {
        Status = STATUS_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength == sizeof(IPV6_RTCHANGE_NOTIFY_REQUEST)) {
        IPV6_RTCHANGE_NOTIFY_REQUEST *Request;

        Request = (IPV6_RTCHANGE_NOTIFY_REQUEST *)
            Irp->AssociatedIrp.SystemBuffer;

        //
        // Sanity check the arguments.
        //

        if (Request->PrefixLength > IPV6_ADDRESS_LENGTH) {
            Status = STATUS_INVALID_PARAMETER_1;
            goto ErrorReturn;
        }

        if (Request->ScopeId != 0) {
            //
            // If a ScopeId is specified, it must be
            // unambiguously a link-local or site-local prefix.
            //
            if ((Request->PrefixLength < 10) ||
                !(IsLinkLocal(&Request->Prefix) ||
                  IsSiteLocal(&Request->Prefix))) {
                Status = STATUS_INVALID_PARAMETER_2;
                goto ErrorReturn;
            }
        }
    }

    IoAcquireCancelSpinLock(&OldIrql);
    ASSERT(Irp->CancelRoutine == NULL);
    if (Irp->Cancel) {
        IoReleaseCancelSpinLock(OldIrql);
        Status = STATUS_CANCELLED;
        goto ErrorReturn;
    }

    //
    // Add this Irp to the queue of notification requests.
    // Acquire route lock, which protects the queue.
    //
    KeAcquireSpinLockAtDpcLevel(&RouteTableLock);
    InsertTailList(&RouteNotifyQueue, &Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLockFromDpcLevel(&RouteTableLock);

    //
    // We return pending to indicate that we've queued the Irp
    // and it will be completed later.
    // Must mark the Irp before unlocking, because once unlocked
    // the Irp might be completed and deallocated.
    //
    IoMarkIrpPending(Irp);
    IoSetCancelRoutine(Irp, CancelRtChangeNotifyRequest);
    IoReleaseCancelSpinLock(OldIrql);

    return STATUS_PENDING;

  ErrorReturn:
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlRtChangeNotifyRequest

//* ReadPersistentGlobalParameters
//
//  Reads global parameters from the registry.
//
void
ReadPersistentGlobalParameters(IPV6_GLOBAL_PARAMETERS *Params)
{
    HANDLE RegKey = NULL;
    NTSTATUS Status;

    Status = OpenTopLevelRegKey(L"GlobalParams", &RegKey, OpenRegKeyRead);
    ASSERT(NT_SUCCESS(Status) || (RegKey == NULL));

    //
    // Read global parameters from the registry.
    //

    InitRegDWORDParameter(RegKey,
                          L"DefaultCurHopLimit",
                          &Params->DefaultCurHopLimit,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"UseTemporaryAddresses",
                          &Params->UseTemporaryAddresses,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MaxTempDADAttempts",
                          &Params->MaxTempDADAttempts,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MaxTempValidLifetime",
                          &Params->MaxTempValidLifetime,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MaxTempPreferredLifetime",
                          &Params->MaxTempPreferredLifetime,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"TempRegenerateTime",
                          &Params->TempRegenerateTime,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MaxTempRandomTime",
                          &Params->MaxTempRandomTime,
                          (uint)-1);

    Params->TempRandomTime = 0;

    InitRegDWORDParameter(RegKey,
                          L"NeighborCacheLimit",
                          &Params->NeighborCacheLimit,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"RouteCacheLimit",
                          &Params->RouteCacheLimit,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"BindingCacheLimit",
                          &Params->BindingCacheLimit,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"ReassemblyLimit",
                          &Params->ReassemblyLimit,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MobilitySecurity",
                          (uint *)&Params->MobilitySecurity,
                          (uint)-1);

    InitRegDWORDParameter(RegKey,
                          L"MobileIPv6Mode",
                          (uint *)&Params->MobileIPv6Mode,
                          (uint)-1);

    if (RegKey != NULL)
        ZwClose(RegKey);
}

//* IoctlQueryGlobalParameters
//
//  Processes an IOCTL_IPV6_QUERY_GLOBAL_PARAMETERS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryGlobalParameters(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_GLOBAL_PARAMETERS *Params;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof *Params)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Params = (IPV6_GLOBAL_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;

    if (Persistent) {
        //
        // Read global parameters from the registry.
        //
        ReadPersistentGlobalParameters(Params);
    }
    else {
        //
        // Return the current values of the parameters.
        //
        Params->DefaultCurHopLimit = DefaultCurHopLimit;
        Params->UseTemporaryAddresses = UseTemporaryAddresses;
        Params->MaxTempDADAttempts = MaxTempDADAttempts;
        Params->MaxTempValidLifetime = ConvertTicksToSeconds(MaxTempValidLifetime);
        Params->MaxTempPreferredLifetime = ConvertTicksToSeconds(MaxTempPreferredLifetime);
        Params->TempRegenerateTime = ConvertTicksToSeconds(TempRegenerateTime);
        Params->MaxTempRandomTime = ConvertTicksToSeconds(MaxTempRandomTime);
        Params->TempRandomTime = ConvertTicksToSeconds(TempRandomTime);
        Params->NeighborCacheLimit = NeighborCacheLimit;
        Params->RouteCacheLimit = RouteCache.Limit;
        Params->BindingCacheLimit = BindingCache.Limit;
        Params->ReassemblyLimit = ReassemblyList.Limit;
        Params->MobilitySecurity = MobilitySecurity;
        Params->MobileIPv6Mode = MobileIPv6Mode;
    }

    Irp->IoStatus.Information = sizeof *Params;
    Status = STATUS_SUCCESS;

Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
} // IoctlQueryGlobalParameters.

//* InternalUpdateGlobalParameters
//
//  Common helper function for IoctlUpdateGlobalParameters
//  and ConfigureGlobalParameters, consolidating
//  parameter validation in one place.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad DefaultCurHopLimit.
//      STATUS_INVALID_PARAMETER_2      Bad UseTemporaryAddresses.
//      STATUS_INVALID_PARAMETER_3      Bad temporary times.
//      STATUS_INVALID_PARAMETER_4      Bad MobileIPv6Mode.
//      STATUS_SUCCESS
//
NTSTATUS
InternalUpdateGlobalParameters(IPV6_GLOBAL_PARAMETERS *Params)
{
    uint NewMaxTempValidLifetime;
    uint NewMaxTempPreferredLifetime;
    uint NewTempRegenerateTime;
    uint NewMaxTempRandomTime;
    uint NewTempRandomTime;

    PAGED_CODE();

    //
    // Sanity check the new parameters.
    //

    if (Params->DefaultCurHopLimit != (uint)-1) {
        if ((Params->DefaultCurHopLimit == 0) ||
            (Params->DefaultCurHopLimit > 0xff))
            return STATUS_INVALID_PARAMETER_1;
    }

    if (Params->UseTemporaryAddresses != (uint)-1) {
        if (Params->UseTemporaryAddresses > USE_TEMP_COUNTER)
            return STATUS_INVALID_PARAMETER_2;
    }

    if (Params->MaxTempValidLifetime != (uint)-1)
        NewMaxTempValidLifetime =
            ConvertSecondsToTicks(Params->MaxTempValidLifetime);
    else
        NewMaxTempValidLifetime = MaxTempValidLifetime;

    if (Params->MaxTempPreferredLifetime != (uint)-1)
        NewMaxTempPreferredLifetime =
            ConvertSecondsToTicks(Params->MaxTempPreferredLifetime);
    else
        NewMaxTempPreferredLifetime = MaxTempPreferredLifetime;

    if (Params->TempRegenerateTime != (uint)-1)
        NewTempRegenerateTime =
            ConvertSecondsToTicks(Params->TempRegenerateTime);
    else
        NewTempRegenerateTime = TempRegenerateTime;

    if (Params->MaxTempRandomTime != (uint)-1)
        NewMaxTempRandomTime =
            ConvertSecondsToTicks(Params->MaxTempRandomTime);
    else
        NewMaxTempRandomTime = MaxTempRandomTime;

    if (Params->TempRandomTime == 0)
        NewTempRandomTime = RandomNumber(0, NewMaxTempRandomTime);
    else if (Params->TempRandomTime == (uint)-1)
        NewTempRandomTime = TempRandomTime;
    else
        NewTempRandomTime = ConvertSecondsToTicks(Params->TempRandomTime);

    if (!(NewTempRandomTime <= NewMaxTempRandomTime) ||
        !(NewTempRegenerateTime + NewMaxTempRandomTime <
                                        NewMaxTempPreferredLifetime) ||
        !(NewMaxTempPreferredLifetime <= NewMaxTempValidLifetime))
        return STATUS_INVALID_PARAMETER_3;

    if (Params->MobileIPv6Mode != (uint)-1) {
        //
        // For now, we only support correspondent operation.
        //
        if (Params->MobileIPv6Mode &~ MOBILE_CORRESPONDENT)
            return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Set the new values.
    //

    if (Params->DefaultCurHopLimit != (uint)-1)
        DefaultCurHopLimit = Params->DefaultCurHopLimit;

    if (Params->UseTemporaryAddresses != (uint)-1)
        UseTemporaryAddresses = Params->UseTemporaryAddresses;

    if (Params->MaxTempDADAttempts != (uint)-1)
        MaxTempDADAttempts = Params->MaxTempDADAttempts;

    MaxTempValidLifetime = NewMaxTempValidLifetime;
    MaxTempPreferredLifetime = NewMaxTempPreferredLifetime;
    TempRegenerateTime = NewTempRegenerateTime;
    MaxTempRandomTime = NewMaxTempRandomTime;
    TempRandomTime = NewTempRandomTime;

    if (Params->NeighborCacheLimit != (uint)-1)
        NeighborCacheLimit = Params->NeighborCacheLimit;

    if (Params->RouteCacheLimit != (uint)-1)
        RouteCache.Limit = Params->RouteCacheLimit;

    if (Params->BindingCacheLimit != (uint)-1)
        BindingCache.Limit = Params->BindingCacheLimit;

    if (Params->ReassemblyLimit != (uint)-1)
        ReassemblyList.Limit = Params->ReassemblyLimit;

    if (Params->MobilitySecurity != -1)
        MobilitySecurity = Params->MobilitySecurity;

    if (Params->MobileIPv6Mode != (uint)-1)
        MobileIPv6Mode = Params->MobileIPv6Mode;

    return STATUS_SUCCESS;
}

//* DefaultReassemblyLimit
//
//  Computes the default memory limit for reassembly buffers, based
//  on the amount of physical memory in the system.
//
uint
DefaultReassemblyLimit(void)
{
    SYSTEM_BASIC_INFORMATION Info;
    NTSTATUS Status;

    Status = ZwQuerySystemInformation(SystemBasicInformation,
                                      &Info,
                                      sizeof(Info),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        //
        // If this failed, then we're probably really resource constrained,
        // so use only 256K.
        //
        return (256 * 1024);
    }

    //
    // By default, limit the reassembly buffers to a maximum size equal
    // to 1/128th of the physical memory.  On a machine with only 128M of
    // memory, this is 1M of memory maximum (enough to reassemble
    // 16 64K packets, or 128 8K packets, for example).  In contrast,
    // the IPv4 stack currently allows reassembling a fixed maximum of
    // 100 packets, regardless of packet size or available memory.
    //
    return (uint)(Info.NumberOfPhysicalPages * (Info.PageSize / 128));
}

//* GlobalParametersReset
//
//  Resets global parameters to their default values.
//  Also used to initialize them at boot.
//
void
GlobalParametersReset(void)
{
    IPV6_GLOBAL_PARAMETERS Params;
    NTSTATUS Status;

    Params.DefaultCurHopLimit = DEFAULT_CUR_HOP_LIMIT;
    Params.UseTemporaryAddresses = (IsRunningOnWorkstation() ?
                                    USE_TEMP_YES : USE_TEMP_NO);
    Params.MaxTempDADAttempts = MAX_TEMP_DAD_ATTEMPTS;
    Params.MaxTempValidLifetime = MAX_TEMP_VALID_LIFETIME;
    Params.MaxTempPreferredLifetime = MAX_TEMP_PREFERRED_LIFETIME;
    Params.TempRegenerateTime = TEMP_REGENERATE_TIME;
    Params.MaxTempRandomTime = MAX_TEMP_RANDOM_TIME;
    Params.TempRandomTime = 0;
    Params.NeighborCacheLimit = NEIGHBOR_CACHE_LIMIT;
    Params.RouteCacheLimit = ROUTE_CACHE_LIMIT;
    Params.BindingCacheLimit = BINDING_CACHE_LIMIT;
    Params.ReassemblyLimit = DefaultReassemblyLimit();
    Params.MobilitySecurity = TRUE;
    Params.MobileIPv6Mode = MIPV6_DEFAULT_MODE;

    Status = InternalUpdateGlobalParameters(&Params);
    ASSERT(NT_SUCCESS(Status));
}

//* ConfigureGlobalParameters
//
//  Configures global parameters from the registry.
//
//  Callable from thread context, not DPC context.
//
void
ConfigureGlobalParameters(void)
{
    IPV6_GLOBAL_PARAMETERS Params;
    NTSTATUS Status;

    //
    // First initialize global parameters to default values.
    //
    GlobalParametersReset();

    //
    // Read global parameters from the registry.
    //
    ReadPersistentGlobalParameters(&Params);

    Status = InternalUpdateGlobalParameters(&Params);
    if (! NT_SUCCESS(Status)) {
        //
        // This should only happen if someone played with the registry.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "ConfigureGlobalParameters: bad params %x\n", Status));
    }
}

//* PersistUpdateGlobalParameters
//
//  Helper function for persisting global parameters in the registry.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistUpdateGlobalParameters(IPV6_GLOBAL_PARAMETERS *Params)
{
    HANDLE RegKey;
    NTSTATUS Status;

    Status = OpenTopLevelRegKey(L"GlobalParams", &RegKey, OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    if (Params->DefaultCurHopLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"DefaultCurHopLimit",
                                  Params->DefaultCurHopLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->UseTemporaryAddresses != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"UseTemporaryAddresses",
                                  Params->UseTemporaryAddresses);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MaxTempDADAttempts != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"MaxTempDADAttempts",
                                  Params->MaxTempDADAttempts);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MaxTempValidLifetime != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"MaxTempValidLifetime",
                                  Params->MaxTempValidLifetime);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MaxTempPreferredLifetime != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"MaxTempPreferredLifetime",
                                  Params->MaxTempPreferredLifetime);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->TempRegenerateTime != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"TempRegenerateTime",
                                  Params->TempRegenerateTime);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MaxTempRandomTime != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"MaxTempRandomTime",
                                  Params->MaxTempRandomTime);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->NeighborCacheLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"NeighborCacheLimit",
                                  Params->NeighborCacheLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->RouteCacheLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"RouteCacheLimit",
                                  Params->RouteCacheLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->BindingCacheLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"BindingCacheLimit",
                                  Params->BindingCacheLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->ReassemblyLimit != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"ReassemblyLimit",
                                  Params->ReassemblyLimit);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MobilitySecurity != -1) {
        Status = SetRegDWORDValue(RegKey, L"MobilitySecurity",
                                  Params->MobilitySecurity);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    if (Params->MobileIPv6Mode != (uint)-1) {
        Status = SetRegDWORDValue(RegKey, L"MobileIPv6Mode",
                                  Params->MobileIPv6Mode);
        if (! NT_SUCCESS(Status))
            goto ReturnReleaseKey;
    }

    Status = STATUS_SUCCESS;
ReturnReleaseKey:
    ZwClose(RegKey);
    return Status;
}

//* IoctlUpdateGlobalParameters
//
//  Processes an IOCTL_IPV6_UPDATE_GLOBAL_PARAMETERS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateGlobalParameters(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_GLOBAL_PARAMETERS *Params;
    NTSTATUS Status;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Params) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Params = (IPV6_GLOBAL_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;

    Status = InternalUpdateGlobalParameters(Params);
    if (! NT_SUCCESS(Status))
        goto Return;

    if (Persistent) {
        Status = PersistUpdateGlobalParameters(Params);
        if (! NT_SUCCESS(Status))
            goto Return;
    }

    Status = STATUS_SUCCESS;
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;

} // IoctlUpdateGlobalParameters.

//* ReturnQueryPrefixPolicy
//
//  Initializes a returned IPV6_QUERY_PREFIX_POLICY structure
//  with query information for the specified prefix policy.
//
void
ReturnQueryPrefixPolicy(
    PrefixPolicyEntry *PPE,
    IPV6_QUERY_PREFIX_POLICY *Query)
{
    if (PPE == NULL) {
        Query->Prefix = UnspecifiedAddr;
        Query->PrefixLength = (uint)-1;
    }
    else {
        Query->Prefix = PPE->Prefix;
        Query->PrefixLength = PPE->PrefixLength;
    }
}

//* IoctlQueryPrefixPolicy
//
//  Processes an IOCTL_IPV6_QUERY_PREFIX_POLICY request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlQueryPrefixPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_QUERY_PREFIX_POLICY *Query;
    IPV6_INFO_PREFIX_POLICY *Info;
    PrefixPolicyEntry *PPE;
    KIRQL OldIrql;
    NTSTATUS Status;

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Next structures overlap!
    //
    Query = (IPV6_QUERY_PREFIX_POLICY *)Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_PREFIX_POLICY *)Irp->AssociatedIrp.SystemBuffer;

    if (Query->PrefixLength == (uint)-1) {
        //
        // Return query information for the first PPE.
        //
        KeAcquireSpinLock(&SelectLock, &OldIrql);
        ReturnQueryPrefixPolicy(PrefixPolicyTable, &Info->Next);
        KeReleaseSpinLock(&SelectLock, OldIrql);

        Irp->IoStatus.Information = sizeof Info->Next;

    } else {
        //
        // Find the specified PPE.
        //
        KeAcquireSpinLock(&SelectLock, &OldIrql);
        for (PPE = PrefixPolicyTable; ; PPE = PPE->Next) {
            if (PPE == NULL) {
                KeReleaseSpinLock(&SelectLock, OldIrql);
                Status = STATUS_INVALID_PARAMETER_2;
                goto Return;
            }

            if (IP6_ADDR_EQUAL(&Query->Prefix, &PPE->Prefix) &&
                (Query->PrefixLength == PPE->PrefixLength))
                break;
        }

        //
        // Return misc. information about the PPE.
        //
        Info->This = *Query;
        Info->Precedence = PPE->Precedence;
        Info->SrcLabel = PPE->SrcLabel;
        Info->DstLabel = PPE->DstLabel;

        //
        // Return query information for the next PPE.
        //
        ReturnQueryPrefixPolicy(PPE->Next, &Info->Next);
        KeReleaseSpinLock(&SelectLock, OldIrql);

        Irp->IoStatus.Information = sizeof *Info;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlQueryPrefixPolicy

//* ReadPersistentPrefixPolicy
//
//  Reads a prefix policy from the registry.
//
//  Returns:
//      STATUS_NO_MORE_ENTRIES          Could not read the prefix policy.
//      STATUS_SUCCESS
//
NTSTATUS
ReadPersistentPrefixPolicy(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    IPV6_INFO_PREFIX_POLICY *Info = (IPV6_INFO_PREFIX_POLICY *) Context;
    WCHAR *Terminator;
    HANDLE PolicyKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // First, parse the prefix.
    //
    if (! ParseV6Address(SubKeyName, &Terminator, &Info->This.Prefix) ||
        (*Terminator != L'/')) {
        //
        // Not a valid prefix.
        //
    SyntaxError:
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "ReadPersistentPrefixPolicy: bad syntax %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Next, parse the prefix length.
    //
    Terminator++; // Move past the L'/'.
    Info->This.PrefixLength = 0;
    for (;;) {
        WCHAR Char = *Terminator++;

        if (Char == UNICODE_NULL)
            break;
        else if ((L'0' <= Char) && (Char <= L'9')) {
            Info->This.PrefixLength *= 10;
            Info->This.PrefixLength += Char - L'0';
            if (Info->This.PrefixLength > IPV6_ADDRESS_LENGTH)
                goto SyntaxError;
        }
        else
            goto SyntaxError;
    }

    //
    // Open the policy key.
    //
    Status = OpenRegKey(&PolicyKey, ParentKey, SubKeyName, OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        //
        // Could not open the policy key.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "ReadPersistentPrefixPolicy: bad key %ls\n",
                   SubKeyName));
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Read prefix policy attributes.
    //
    InitRegDWORDParameter(PolicyKey, L"Precedence",
                          (uint *)&Info->Precedence, 0);
    InitRegDWORDParameter(PolicyKey, L"SrcLabel",
                          (uint *)&Info->SrcLabel, 0);
    InitRegDWORDParameter(PolicyKey, L"DstLabel",
                          (uint *)&Info->DstLabel, 0);

    //
    // Done reading the policy attributes.
    //
    ZwClose(PolicyKey);
    return STATUS_SUCCESS;
}

//* IoctlPersistentQueryPrefixPolicy
//
//  Processes an IOCTL_IPV6_PERSISTENT_QUERY_PREFIX_POLICY request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlPersistentQueryPrefixPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_PERSISTENT_QUERY_PREFIX_POLICY *Query;
    IPV6_INFO_PREFIX_POLICY *Info;
    HANDLE RegKey;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof *Info)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Note that the Query and Info->Next structures overlap!
    //
    Query = (IPV6_PERSISTENT_QUERY_PREFIX_POLICY *)
        Irp->AssociatedIrp.SystemBuffer;
    Info = (IPV6_INFO_PREFIX_POLICY *)
        Irp->AssociatedIrp.SystemBuffer;

    Status = OpenTopLevelRegKey(L"PrefixPolicies", &RegKey, OpenRegKeyRead);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            Status = STATUS_NO_MORE_ENTRIES;
        goto Return;
    }

    Status = EnumRegKeyIndex(RegKey, Query->RegistryIndex,
                             ReadPersistentPrefixPolicy, Info);
    ZwClose(RegKey);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // Do not return query information for a next policy,
    // since an iteration uses RegistryIndex.
    //
    ReturnQueryPrefixPolicy(NULL, &Info->Next);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof *Info;
Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlPersistentQueryPrefixPolicy

struct PrefixPolicyDefault {
    IPv6Addr *Prefix;
    uint PrefixLength;
    uint Precedence;
    uint SrcLabel;
    uint DstLabel;
} PrefixPolicyDefault[] = {
    { &LoopbackAddr, 128, 50, 0, 0 },   // ::1/128 (loopback)
    { &UnspecifiedAddr, 0, 40, 1, 1 },  // ::/0
    { &SixToFourPrefix, 16, 30, 2, 2 }, // 2002::/16 (6to4)
    { &UnspecifiedAddr, 96, 20, 3, 3 }, // ::/96 (v4-compatible)
    { &V4MappedPrefix, 96, 10, 4, 4 },  // ::ffff:0.0.0.0/96 (v4-mapped)
};

int UsingDefaultPrefixPolicies;

#define NUM_DEFAULT_PREFIX_POLICIES     \
                (sizeof PrefixPolicyDefault / sizeof PrefixPolicyDefault[0])

//* ConfigureDefaultPrefixPolicies
//
//  Installs the default prefix policies.
//
void
ConfigureDefaultPrefixPolicies(void)
{
    uint i;

    for (i = 0; i < NUM_DEFAULT_PREFIX_POLICIES; i++) {
        struct PrefixPolicyDefault *Policy = &PrefixPolicyDefault[i];

        PrefixPolicyUpdate(Policy->Prefix,
                           Policy->PrefixLength,
                           Policy->Precedence,
                           Policy->SrcLabel,
                           Policy->DstLabel);
    }

    UsingDefaultPrefixPolicies = TRUE;
}

//* InternalUpdatePrefixPolicy
//
//  Common helper function for IoctlUpdatePrefixPolicy
//  and CreatePersistentPrefixPolicy, consolidating
//  parameter validation in one place.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INVALID_PARAMETER_1      Bad PrefixLength.
//      STATUS_INVALID_PARAMETER_2      Bad Precedence.
//      STATUS_INVALID_PARAMETER_3      Bad SrcLabel.
//      STATUS_INVALID_PARAMETER_4      Bad DstLabel.
//
NTSTATUS
InternalUpdatePrefixPolicy(IPV6_INFO_PREFIX_POLICY *Info)
{
    if (Info->This.PrefixLength > IPV6_ADDRESS_LENGTH)
        return STATUS_INVALID_PARAMETER_1;

    //
    // Disallow the value -1. It's used internally.
    //

    if (Info->Precedence == (uint)-1)
        return STATUS_INVALID_PARAMETER_2;

    if (Info->SrcLabel == (uint)-1)
        return STATUS_INVALID_PARAMETER_3;

    if (Info->DstLabel == (uint)-1)
        return STATUS_INVALID_PARAMETER_4;

    if (UsingDefaultPrefixPolicies) {
        //
        // The user is changing the default policies for the first time.
        // Remove the default policies.
        //
        UsingDefaultPrefixPolicies = FALSE;
        PrefixPolicyReset();
    }

    //
    // Create/update the specified prefix policy.
    //
    PrefixPolicyUpdate(&Info->This.Prefix,
                       Info->This.PrefixLength,
                       Info->Precedence,
                       Info->SrcLabel,
                       Info->DstLabel);

    return STATUS_SUCCESS;
}

//* CreatePersistentPrefixPolicy
//
//  Creates a persistent prefix policy.
//
//  SubKeyName has the following syntax:
//      prefix/length
//  where prefix is a literal IPv6 address.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
CreatePersistentPrefixPolicy(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    IPV6_INFO_PREFIX_POLICY Info;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Context);
    PAGED_CODE();

    //
    // Read the prefix policy from the registry.
    //
    Status = ReadPersistentPrefixPolicy(&Info, ParentKey, SubKeyName);
    if (! NT_SUCCESS(Status)) {
        //
        // If there was an error reading this policy,
        // continue the enumeration.
        //
        if (Status == STATUS_NO_MORE_ENTRIES)
            Status = STATUS_SUCCESS;
        return Status;
    }

    //
    // Create the prefix policy.
    //
    Status = InternalUpdatePrefixPolicy(&Info);
    if (! NT_SUCCESS(Status)) {
        if ((STATUS_INVALID_PARAMETER_1 <= Status) &&
            (Status <= STATUS_INVALID_PARAMETER_12)) {
            //
            // Invalid parameter.
            // But we return success so the enumeration continues.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "CreatePersistentPrefixPolicy: bad param %ls\n",
                       SubKeyName));
            return STATUS_SUCCESS;
        }

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "CreatePersistentPrefixPolicy: error %ls\n",
                   SubKeyName));
    }
    return Status;
}

//* ConfigurePrefixPolicies
//
//  Configures prefix policies from the registry.
//
//  Callable from thread context, not DPC context.
//
void
ConfigurePrefixPolicies(void)
{
    HANDLE RegKey;
    NTSTATUS Status;

    Status = OpenTopLevelRegKey(L"PrefixPolicies", &RegKey, OpenRegKeyRead);
    if (NT_SUCCESS(Status)) {
        //
        // Create persistent policies.
        //
        (void) EnumRegKeys(RegKey, CreatePersistentPrefixPolicy, NULL);
        ZwClose(RegKey);
    }
    else {
        //
        // There are no persistent policies,
        // so install the default policies.
        //
        ConfigureDefaultPrefixPolicies();
    }
}

//* OpenPrefixPolicyRegKey
//
//  Given a prefix with prefix length,
//  opens the registry key with configuration info
//  for the prefix policy.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
OpenPrefixPolicyRegKey(const IPv6Addr *Prefix, uint PrefixLength,
                       OUT HANDLE *RegKey, OpenRegKeyAction Action)
{
    WCHAR PrefixPolicyName[64];
    HANDLE PrefixPoliciesKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Note that if we are deleting a prefix policy,
    // then we must create the top-level key if it
    // doesn't exist yet. This is for ConfigurePrefixPolicies.
    //
    Status = OpenTopLevelRegKey(L"PrefixPolicies", &PrefixPoliciesKey,
                                ((Action != OpenRegKeyRead) ?
                                 OpenRegKeyCreate : OpenRegKeyRead));
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // The output of RtlIpv6AddressToString may change
    // over time with improvements/changes in the pretty-printing,
    // and we need a consistent mapping.
    // It doesn't need to be pretty.
    //
    swprintf(PrefixPolicyName,
             L"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x/%u",
             net_short(Prefix->s6_words[0]), net_short(Prefix->s6_words[1]),
             net_short(Prefix->s6_words[2]), net_short(Prefix->s6_words[3]),
             net_short(Prefix->s6_words[4]), net_short(Prefix->s6_words[5]),
             net_short(Prefix->s6_words[6]), net_short(Prefix->s6_words[7]),
             PrefixLength);

    Status = OpenRegKey(RegKey, PrefixPoliciesKey, PrefixPolicyName, Action);
    ZwClose(PrefixPoliciesKey);
    return Status;
}

//* PersistUpdatePrefixPolicy
//
//  Helper function for persisting a prefix policy in the registry.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistUpdatePrefixPolicy(IPV6_INFO_PREFIX_POLICY *Info)
{
    HANDLE PolicyKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open/create the policy key.
    //
    Status = OpenPrefixPolicyRegKey(&Info->This.Prefix,
                                    Info->This.PrefixLength,
                                    &PolicyKey, OpenRegKeyCreate);
    if (! NT_SUCCESS(Status))
        return Status;

    //
    // Persist the prefix policy precedence.
    //
    Status = SetRegDWORDValue(PolicyKey, L"Precedence", Info->Precedence);
    if (! NT_SUCCESS(Status))
        goto ReturnReleasePolicyKey;

    //
    // Persist the prefix policy source label.
    //
    Status = SetRegDWORDValue(PolicyKey, L"SrcLabel", Info->SrcLabel);
    if (! NT_SUCCESS(Status))
        goto ReturnReleasePolicyKey;

    //
    // Persist the prefix policy destination label.
    //
    Status = SetRegDWORDValue(PolicyKey, L"DstLabel", Info->DstLabel);
    if (! NT_SUCCESS(Status))
        goto ReturnReleasePolicyKey;

    Status = STATUS_SUCCESS;
ReturnReleasePolicyKey:
    ZwClose(PolicyKey);
    return Status;
}

//* IoctlUpdatePrefixPolicy
//
//  Processes an IOCTL_IPV6_UPDATE_PREFIX_POLICY request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdatePrefixPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_INFO_PREFIX_POLICY *Info;
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Info) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_INFO_PREFIX_POLICY *) Irp->AssociatedIrp.SystemBuffer;

    //
    // Update the prefix policy.
    //
    Status = InternalUpdatePrefixPolicy(Info);
    if (! NT_SUCCESS(Status))
        goto Return;

    //
    // Make the change persistent?
    //
    if (Persistent) {
        Status = PersistUpdatePrefixPolicy(Info);
        if (! NT_SUCCESS(Status))
            goto Return;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdatePrefixPolicy

//* PersistDeletePrefixPolicy
//
//  Helper function for deleting a prefix policy from the registry.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
PersistDeletePrefixPolicy(IPV6_QUERY_PREFIX_POLICY *Query)
{
    HANDLE PolicyKey;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Open the policy key. It's OK if it doesn't exist.
    //
    Status = OpenPrefixPolicyRegKey(&Query->Prefix, Query->PrefixLength,
                                    &PolicyKey, OpenRegKeyDeleting);
    if (! NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        else
            return Status;
    }

    //
    // Delete the policy key.
    //
    Status = ZwDeleteKey(PolicyKey);
    ZwClose(PolicyKey);
    return Status;
}

//* IoctlDeletePrefixPolicy
//
//  Processes an IOCTL_IPV6_DELETE_PREFIX_POLICY request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlDeletePrefixPolicy(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    IPV6_QUERY_PREFIX_POLICY *Query;
    NTSTATUS Status;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof *Query) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Query = (IPV6_QUERY_PREFIX_POLICY *) Irp->AssociatedIrp.SystemBuffer;

    if (UsingDefaultPrefixPolicies) {
        //
        // The user is changing the default policies for the first time.
        // Remove the default policies.
        //
        UsingDefaultPrefixPolicies = FALSE;
        PrefixPolicyReset();
    }

    //
    // Delete the specified prefix policy.
    //
    PrefixPolicyDelete(&Query->Prefix, Query->PrefixLength);

    //
    // Make the change persistent?
    //
    if (Persistent) {
        Status = PersistDeletePrefixPolicy(Query);
        if (! NT_SUCCESS(Status))
            goto Return;
    }

    Status = STATUS_SUCCESS;
  Return:
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlDeletePrefixPolicy

//* IoctlUpdateRouterLLAddress
//
//  Processes an IOCTL_IPV6_UPDATE_ROUTER_LL_ADDRESS request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlUpdateRouterLLAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    IPV6_UPDATE_ROUTER_LL_ADDRESS *Info;
    NTSTATUS Status;
    Interface *IF;
    char *LinkAddress;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof *Info) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    Info = (IPV6_UPDATE_ROUTER_LL_ADDRESS *) Irp->AssociatedIrp.SystemBuffer;

    IF = FindInterfaceFromQuery(&Info->IF);
    if (IF == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Return;
    }

    //
    // Verify that this ioctl is legal on the interface.
    //
    if (IF->SetRouterLLAddress == NULL) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Verify link-layer address length matches interface's.
    //
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength !=
        sizeof *Info + 2 * IF->LinkAddressLength) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    LinkAddress = (char *)(Info + 1);
    Status = (*IF->SetRouterLLAddress)(IF->LinkContext, LinkAddress,
                                       LinkAddress + IF->LinkAddressLength);

  Cleanup:
    ReleaseIF(IF);

  Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlUpdateRouterLLAddress

//* IoctlResetManualConfig
//
//  Processes an IOCTL_IPV6_RESET request.
//
//  Note: Return value indicates whether NT-specific processing of the
//  request was successful.  The status of the actual request is returned
//  in the request buffers.
//
NTSTATUS
IoctlResetManualConfig(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp,  // Current stack location in the Irp.
    IN int Persistent)
{
    NTSTATUS Status;

    PAGED_CODE();

    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Return;
    }

    //
    // Reset the running data structures.
    //
    GlobalParametersReset();
    InterfaceReset();
    RouteTableReset();
    PrefixPolicyReset();
    ConfigureDefaultPrefixPolicies();

    if (Persistent) {
        //
        // Delete all persistent configuration information.
        //

        Status = DeleteTopLevelRegKey(L"GlobalParams");
        if (! NT_SUCCESS(Status))
            goto Return;

        Status = DeleteTopLevelRegKey(L"Interfaces");
        if (! NT_SUCCESS(Status))
            goto Return;

        Status = DeleteTopLevelRegKey(L"PrefixPolicies");
        if (! NT_SUCCESS(Status))
            goto Return;
    }

    Status = STATUS_SUCCESS;
Return:
    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;

} // IoctlPersistentReset
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\route.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Routing routines for Internet Protocol Version 6.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "route.h"
#include "select.h"
#include "icmp.h"
#include "neighbor.h"
#include "alloca.h"
#include "ipinfo.h"
#include "info.h"

//
// Forward declarations of internal functions.
//

extern void
DestroyBCE(BindingCacheEntry *BCE);

KSPIN_LOCK RouteCacheLock;
KSPIN_LOCK RouteTableLock;
struct RouteCache RouteCache;
struct RouteTable RouteTable;
ulong RouteCacheValidationCounter;
struct BindingCache BindingCache;
SitePrefixEntry *SitePrefixTable = NULL;
LIST_ENTRY RouteNotifyQueue;

int ForceRouterAdvertisements = FALSE;

//* RemoveRTE
//
//  Remove the RTE from the route table.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
RemoveRTE(RouteTableEntry **PrevRTE, RouteTableEntry *RTE)
{
    ASSERT(*RouteTable.Last == NULL);
    ASSERT(*PrevRTE == RTE);
    *PrevRTE = RTE->Next;
    if (RouteTable.Last == &RTE->Next)
        RouteTable.Last = PrevRTE;
}

//* InsertRTEAtFront
//
//  Insert the RTE at the front of the route table.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
InsertRTEAtFront(RouteTableEntry *RTE)
{
    ASSERT(*RouteTable.Last == NULL);
    RTE->Next = RouteTable.First;
    RouteTable.First = RTE;
    if (RouteTable.Last == &RouteTable.First)
        RouteTable.Last = &RTE->Next;
}

//* InsertRTEAtBack
//
//  Insert the RTE at the back of the route table.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
InsertRTEAtBack(RouteTableEntry *RTE)
{
    ASSERT(*RouteTable.Last == NULL);
    RTE->Next = NULL;
    *RouteTable.Last = RTE;
    RouteTable.Last = &RTE->Next;
    if (RouteTable.First == NULL)
        RouteTable.First = RTE;
}

//* InsertRCE
//
//  Insert the RCE in the route cache.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
InsertRCE(RouteCacheEntry *RCE)
{
    RouteCacheEntry *AfterRCE = SentinelRCE;

    RCE->Prev = AfterRCE;
    (RCE->Next = AfterRCE->Next)->Prev = RCE;
    AfterRCE->Next = RCE;
    RouteCache.Count++;
}

//* RemoveRCE
//
//  Remove the RCE from the route cache.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
RemoveRCE(RouteCacheEntry *RCE)
{
    RCE->Prev->Next = RCE->Next;
    RCE->Next->Prev = RCE->Prev;
    RouteCache.Count--;

    //
    // We must ensure that an RCE not in the route cache
    // has a null BCE. This is because DestroyBCE only
    // updates RCEs in the route cache.
    //
    RCE->BCE = NULL;
}

//* MoveToFrontRCE
//
//  Move an RCE to the front of the list.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
MoveToFrontRCE(RouteCacheEntry *RCE)
{
    if (RCE->Prev != SentinelRCE) {
        RouteCacheEntry *AfterRCE = SentinelRCE;

        //
        // Remove the RCE from its current location.
        //
        RCE->Prev->Next = RCE->Next;
        RCE->Next->Prev = RCE->Prev;

        //
        // And put it at the front.
        //
        RCE->Prev = AfterRCE;
        (RCE->Next = AfterRCE->Next)->Prev = RCE;
        AfterRCE->Next = RCE;
    }
}


//* GetCareOfRCE
//
//  Get the CareOfRCE, if any, for the specified RCE.
//
//  Note that a reference is obtained for the CareOfRCE
//  and donated to the caller.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
RouteCacheEntry *
GetCareOfRCE(RouteCacheEntry *RCE)
{
    KIRQL OldIrql;
    RouteCacheEntry *CareOfRCE = NULL;

    if (RCE->BCE != NULL) {
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        if (RCE->BCE != NULL) {
            CareOfRCE = RCE->BCE->CareOfRCE;
            AddRefRCE(CareOfRCE);
        }
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    }

    return CareOfRCE;
}


//* IsLoopbackRCE
//
//  Does the effective RCE correspond to a loopback path?
//
//  Called with NO locks held.
//
int
IsLoopbackRCE(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE;
    int IsLoopback;

    CareOfRCE = GetCareOfRCE(RCE);
    if (CareOfRCE != NULL)
        RCE = CareOfRCE;        // Update with the effective RCE.

    IsLoopback = RCE->NCE->IsLoopback;

    if (CareOfRCE != NULL)
        ReleaseRCE(CareOfRCE);

    return IsLoopback;
}


//* GetInitialRTTFromRCE
//  Helper routine to get interface specific RTT.
//
//  Called with NO locks held.
uint
GetInitialRTTFromRCE(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE;
    NeighborCacheEntry *NCE;
    uint RTT;

    CareOfRCE = GetCareOfRCE(RCE);
    NCE = (CareOfRCE ? CareOfRCE : RCE)->NCE;
    RTT = NCE->IF->TcpInitialRTT;

    if (CareOfRCE)
        ReleaseRCE(CareOfRCE);

    return RTT;
}


//* IsDisconnectedAndNotLoopbackRCE
//
//  Does the effective RCE have a disconnected outgoing interface
//  and not correspond to a loopback path?
//
//  Called with NO locks held.
//
int
IsDisconnectedAndNotLoopbackRCE(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE;
    int IsDisconnectedAndNotLoopback;

    CareOfRCE = GetCareOfRCE(RCE);
    if (CareOfRCE != NULL)
        RCE = CareOfRCE;        // Update with the effective RCE.

    IsDisconnectedAndNotLoopback = !RCE->NCE->IsLoopback &&
        (RCE->NCE->IF->Flags & IF_FLAG_MEDIA_DISCONNECTED);

    if (CareOfRCE != NULL)
        ReleaseRCE(CareOfRCE);

    return IsDisconnectedAndNotLoopback;
}


//* GetV4Destination
//
//  If sending via the RCE will result in tunneling a packet
//  to an IPv4 destination, returns the IPv4 destination address.
//  Otherwise returns INADDR_ANY.
//
IPAddr
GetV4Destination(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE;
    NeighborCacheEntry *NCE;
    Interface *IF;
    IPAddr V4Dest;
    KIRQL OldIrql;

    CareOfRCE = GetCareOfRCE(RCE);
    if (CareOfRCE != NULL)
        RCE = CareOfRCE;        // Update with the effective RCE.

    NCE = RCE->NCE;
    IF = NCE->IF;

    if (IsIPv4TunnelIF(IF)) {
        ASSERT(IF->LinkAddressLength == sizeof(IPAddr));

        KeAcquireSpinLock(&IF->LockNC, &OldIrql);
        if (NCE->NDState != ND_STATE_INCOMPLETE)
            V4Dest = * (IPAddr UNALIGNED *) NCE->LinkAddress;
        else
            V4Dest = INADDR_ANY;
        KeReleaseSpinLock(&IF->LockNC, OldIrql);
    }
    else {
        V4Dest = INADDR_ANY;
    }

    if (CareOfRCE != NULL)
        ReleaseRCE(CareOfRCE);

    return V4Dest;
}


//* ValidateCareOfRCE
//
//  Helper function for ValidateRCE and RouteToDestination.
//
//  Checks that the CareOfRCE (RCE->BCE->CareOfRCE) is still valid, and
//  if not, releases the existing CareOfRCE and updates RCE->BCE with a
//  new RCE.
//
//  If the attempt to get a new RCE fails, the BCE is destroyed.
//
//  Called with the route cache locked.
//
void
ValidateCareOfRCE(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE;
    IPv6Addr *CareOfAddr;
    ushort CareOfScope;
    uint CareOfScopeId;
    RouteCacheEntry *NewRCE;
    IP_STATUS Status;

    ASSERT(RCE->BCE != NULL);
    CareOfRCE = RCE->BCE->CareOfRCE;

    if (CareOfRCE->Valid != RouteCacheValidationCounter) {
        //
        // Note that since we already hold the RouteCacheLock we
        // call FindOrCreateRoute instead of RouteToDestination.
        // Also, we assume the care-of address is scoped to the
        // same interface as before.
        //
        CareOfAddr = &(CareOfRCE->Destination);
        CareOfScope = AddressScope(CareOfAddr);
        CareOfScopeId = CareOfRCE->NTE->IF->ZoneIndices[CareOfScope];
        Status = FindOrCreateRoute(CareOfAddr, CareOfScopeId, NULL, &NewRCE);
        if (Status == IP_SUCCESS) {
            //
            // Update the binding cache entry.
            //
            ReleaseRCE(CareOfRCE);
            RCE->BCE->CareOfRCE = NewRCE;
        }
        else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "ValidateCareOfRCE(%p): FindOrCreateRoute failed: %x\n",
                       CareOfRCE, Status));

            //
            // Because we could not update the BCE, destroy it.
            //
            DestroyBCE(RCE->BCE);

            //
            // Destroy BCE should have removed our reference too.
            //
            ASSERT(RCE->BCE == NULL);
        }
    }
}


//* ValidateRCE
//
//  Checks that an RCE is still valid, and if not, releases
//  the RCE and returns a reference for a new RCE.
//  In any case, returns a pointer to an RCE.
//
//  Called with NO locks held.
//
RouteCacheEntry *
ValidateRCE(
    RouteCacheEntry *RCE,  // Cached route.
    NetTableEntry *NTE)    // Source address being used.
{
    if (RCE->Valid != RouteCacheValidationCounter) {
        RouteCacheEntry *NewRCE;
        IP_STATUS Status;

        //
        // Get a new RCE to replace the current RCE.
        // RouteToDestination will calculate ScopeId.
        // REVIEW: If this fails, then continue to use the current RCE.
        // This way our callers don't have to check for errors.
        //
        Status = RouteToDestination(&RCE->Destination, 0,
                                    CastFromNTE(NTE), RTD_FLAG_NORMAL,
                                    &NewRCE);
        if (Status == IP_SUCCESS) {
            ReleaseRCE(RCE);
            RCE = NewRCE;
        } else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "ValidateRCE(%p): RouteToDestination failed: %x\n",
                       RCE, Status));
        }
    }

    //
    // Validate and update the CareOfRCE before we return.
    //
    if (RCE->BCE != NULL) {
        KIRQL OldIrql;

        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        if (RCE->BCE != NULL)
            ValidateCareOfRCE(RCE);
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    }

    return RCE;
}


//* CreateOrReuseRoute
//
//  Creates a new RCE. Attempts to reuse an existing RCE.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
//  Returns NULL if a new RCE can not be allocated.
//  The RefCnt field in the returned RCE is initialized to one.
//
//  REVIEW: Currently we have an upper-bound on the number of RCEs.
//  Probably a better scheme would take into account the time
//  since last use.
//
RouteCacheEntry *
CreateOrReuseRoute(void)
{
    RouteCacheEntry *RCE;
    RouteCacheEntry *PrevRCE, *UnusedRCE;

    if (RouteCache.Count >= RouteCache.Limit) {
        //
        // First search backwards for an unused RCE.
        //
        for (RCE = RouteCache.Last; RCE != SentinelRCE; RCE = RCE->Prev) {

            if (RCE->RefCnt == 1) {
                //
                // We can reuse this RCE.
                //
                PrevRCE = RCE->Prev;
                RemoveRCE(RCE);
                ReleaseNCE(RCE->NCE);
                ReleaseNTE(RCE->NTE);

                //
                // If the cache is too large, then try to free entries
                // to bring it back under the limit. This will happen
                // when a burst of activity (perhaps a DoS attack) forces
                // us to grow the cache beyond the limit and
                // then the activity subsides.
                //
                while ((RouteCache.Count > RouteCache.Limit) &&
                       (PrevRCE != SentinelRCE)) {
                    UnusedRCE = PrevRCE;
                    PrevRCE = PrevRCE->Prev;
                    if (UnusedRCE->RefCnt == 1) {
                        RemoveRCE(UnusedRCE);
                        ReleaseRCE(UnusedRCE);
                    }
                }

                return RCE;
            }
        }
    }

    //
    // Create a new RCE.
    //
    RCE = ExAllocatePool(NonPagedPool, sizeof *RCE);
    if (RCE == NULL)
        return NULL;

    RCE->RefCnt = 1;
    return RCE;
}


//* RouteCacheCheck
//
//  Check the route cache's consistency. Ensure that
//  a) There is only one RCE for an interface/destination pair, and
//  b) There is at most one valid unconstrained RCE for the destination.
//
//  Called with the route cache locked.
//
#if DBG
void
RouteCacheCheck(RouteCacheEntry *CheckRCE, ulong CurrentValidationCounter)
{
    const IPv6Addr *Dest = &CheckRCE->Destination;
    Interface *IF = CheckRCE->NTE->IF;
    ushort Scope = AddressScope(Dest);
    uint ScopeId = IF->ZoneIndices[Scope];
    uint NumTotal = 0;
    uint NumUnconstrainedIF = 0;
    uint NumUnconstrained = 0;
    RouteCacheEntry *RCE;

    //
    // Scan the route cache looking for problems.
    //
    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = RCE->Next) {
        NumTotal++;

        if (IP6_ADDR_EQUAL(&RCE->Destination, Dest)) {
            if (RCE->NTE->IF == IF) {
                //
                // There should only be one RCE in the cache
                // for an interface/destination pair.
                // (There may be other, invalid RCEs not in the cache.)
                //
                ASSERT(RCE == CheckRCE);
            }

            //
            // RCE_FLAG_CONSTRAINED_IF implies RCE_FLAG_CONSTRAINED_SCOPEID.
            //
            ASSERT(!(RCE->Flags & RCE_FLAG_CONSTRAINED_IF) ||
                   (RCE->Flags & RCE_FLAG_CONSTRAINED_SCOPEID));

            if (RCE->Valid == CurrentValidationCounter) {

                if ((RCE->NTE->IF->ZoneIndices[Scope] == ScopeId) &&
                    !(RCE->Flags & RCE_FLAG_CONSTRAINED_IF))
                    NumUnconstrainedIF++;

                if (!(RCE->Flags & RCE_FLAG_CONSTRAINED))
                    NumUnconstrained++;
            }
        }
    }

    //
    // There should be at most one valid unconstrained RCE
    // for this scope-id/destination.
    //
    ASSERT(NumUnconstrainedIF <= 1);

    //
    // There should be at most one valid unconstrained RCE
    // for this destination.
    //
    ASSERT(NumUnconstrained <= 1);

    //
    // The total should be correct.
    //
    ASSERT(NumTotal == RouteCache.Count);
}
#else // DBG
__inline void
RouteCacheCheck(RouteCacheEntry *CheckRCE, ulong CurrentValidationCounter)
{
    UNREFERENCED_PARAMETER(CheckRCE);
    UNREFERENCED_PARAMETER(CurrentValidationCounter);
}
#endif // DBG


//* CanonicalizeScopeId
//
//  Given an address and ScopeId, converts the ScopeId for internal usage.
//  Also returns the address scope.
//
//  Returns FALSE if the ScopeId is invalid.
//
__inline int    // Encourage the compiler to inline if it wishes.
CanonicalizeScopeId(
    const IPv6Addr *Addr,
    uint *ScopeId,
    ushort *Scope)
{
    //
    // The loopback address and global-scope addresses are special:
    // callers can supply a zero ScopeId without ambiguity.
    // See also DetermineScopeId and RouteToDestination.
    // For the moment, we enforce a zero ScopeId for those addresses
    // lest we confuse TCP & UDP by having two legal ScopeId values
    // for a single address which should be considered the same and
    // for which DetermineScopeId returns zero.
    //

    *Scope = AddressScope(Addr);
    if (IsLoopback(Addr)) {
        if (*ScopeId == 0)
            *ScopeId = LoopInterface->ZoneIndices[*Scope];
        else
            return FALSE;
    }
    else if (*Scope == ADE_GLOBAL) {
        if (*ScopeId == 0)
            *ScopeId = 1;
        else
            return FALSE;
    }

    return TRUE;
}


//* RouteToDestination - Find a route to a particular destination.
//
//  Finds an existing, or creates a new, route cache entry for
//  a particular destination.  Note the destination address may
//  only be valid in a particular scope.
//
//  The optional NTEorIF argument specifies the interface
//  and/or the source address that should be used to reach the destination.
//  The Flags argument affects the interpretation of NTEorIF.
//  If RTD_FLAG_STRICT, then NTEorIF constrains whether or not it specifies
//  a forwarding interface. If RTD_FLAG_LOOSE, then NTEorIF is only used
//  for determining/checking ScopeId and otherwise does not constrain.
//
//  Called with NO locks held.
//
//  Return codes:
//      IP_NO_RESOURCES         Couldn't allocate memory.
//      IP_PARAMETER_PROBLEM    Illegal Dest/ScopeId.
//      IP_BAD_ROUTE            Bad NTEorIF for this destination,
//                              or could not find an NTE.
//      IP_DEST_NO_ROUTE        No way to reach the destination.
//
//  IP_DEST_NO_ROUTE can only be returned if NTEorIF is NULL.
//
//  NB: The return code values and situations in which they are used
//  in RouteToDestination and its helper functions must be carefully
//  considered, both for RouteToDestination's own correctness
//  and for the correctness of callers.
//
IP_STATUS  // Returns: whether call was successful and/or why not.
RouteToDestination(
    const IPv6Addr *Dest,               // Destination address to route to.
    uint ScopeId,                       // Scope id for Dest (may be 0).
    NetTableEntryOrInterface *NTEorIF,  // IF to send from (may be NULL).
    uint Flags,                         // Control optional behaviors.
    RouteCacheEntry **ReturnRCE)        // Returns pointer to cached route.
{
    Interface *IF;
    KIRQL OldIrql;
    IP_STATUS ReturnValue;
    ushort Scope;

    //
    // Pre-calculate Scope for scoped addresses (saves time in the loop).
    // Note that callers can supply ScopeId == 0 for a scoped address,
    // meaning that they are not constraining the scoped address
    // to a particular zone.
    //
    if (! CanonicalizeScopeId(Dest, &ScopeId, &Scope))
        return IP_PARAMETER_PROBLEM;

    if (NTEorIF != NULL) {
        //
        // Our caller is constraining the originating interface.
        //
        IF = NTEorIF->IF;

        //
        // First, check this against ScopeId.
        //
        if (ScopeId == 0)
            ScopeId = IF->ZoneIndices[Scope];
        else if (ScopeId != IF->ZoneIndices[Scope])
            return IP_BAD_ROUTE;

        //
        // Depending on Flags and whether this is forwarding interface,
        // we may ignore this specification and look at all interfaces.
        // Logically, the packet is originated by the specified interface
        // but then internally forwarded to the outgoing interface.
        // (Although we will not decrement the Hop Count.)
        // As when forwarding, we check after finding the best route
        // if the route will cause the packet to leave
        // the scope of the source address.
        //
        // It is critical that the route cache lookup and FindNextHop
        // computation use only IF and not NTEorIF. This is necessary
        // for the maintenance of the cache invariants. Once we have
        // an RCE (or an error), then we can check against NTEorIF.
        //
        switch (Flags) {
        case RTD_FLAG_LOOSE:
            IF = NULL;
            break;

        case RTD_FLAG_NORMAL:
            //
            // Multicast datagrams are sent over the originating interface
            // regardless of the forwarding attribute of the interface.
            //
            if ((IF->Flags & IF_FLAG_FORWARDS) && !IsMulticast(Dest))
                IF = NULL;
            break;

        case RTD_FLAG_STRICT:
            break;

        default:
            ABORTMSG("bad RouteToDestination Flags");
            break;
        }
    }
    else {
        //
        // Our caller is not constraining the originating interface.
        //
        IF = NULL;
    }

    KeAcquireSpinLock(&RouteCacheLock, &OldIrql);

    ReturnValue = FindOrCreateRoute(Dest, ScopeId, IF, ReturnRCE);

    if ((NTEorIF != NULL) && (IF == NULL) && (Flags == RTD_FLAG_NORMAL)) {
        //
        // Our caller specified a forwarding interface,
        // and we ignored the interface constraint.
        // There are a couple cases in which we should
        // retry, preserving the interface constraint.
        // NB: In the IPv6Forward paths, NTEorIF is NULL.
        // So this check only applies to originating packets.
        //

        if (ReturnValue == IP_SUCCESS) {
            if (IsNTE(NTEorIF)) {
                RouteCacheEntry *RCE = *ReturnRCE;
                NetTableEntry *NTE = CastToNTE(NTEorIF);
                Interface *OriginatingIF = NTE->IF;
                Interface *OutgoingIF = RCE->NTE->IF;

                //
                // Does this route carry the packet outside
                // the scope of the specified source address?
                //
                if (OutgoingIF->ZoneIndices[NTE->Scope] !=
                    OriginatingIF->ZoneIndices[NTE->Scope]) {

                    ReleaseRCE(RCE);
                    goto Retry;
                }
            }
        }
        else if (ReturnValue == IP_DEST_NO_ROUTE) {
            //
            // Retry, allowing the destination
            // to be considered on-link to the specified interface.
            //
        Retry:
            IF = NTEorIF->IF;
            ReturnValue = FindOrCreateRoute(Dest, ScopeId, IF, ReturnRCE);
        }
    }

    //
    // Validate and update the CareOfRCE before we return.
    //
    if ((ReturnValue == IP_SUCCESS) && ((*ReturnRCE)->BCE != NULL))
        ValidateCareOfRCE(*ReturnRCE);

    KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    return ReturnValue;
}


//* FindOrCreateRoute
//
//  Helper function for RouteToDestination and RedirectRouteCache.
//
//  See the RouteToDestination description of return codes.
//  IP_DEST_NO_ROUTE can only be returned if IF is NULL.
//  RouteToDestination may retry FindOrCreateRoute with a non-null IF
//  when it gets IP_DEST_NO_ROUTE.
//
//  Called with the route cache locked.
//
IP_STATUS
FindOrCreateRoute(
    const IPv6Addr *Dest,               // Destination address to route to.
    uint ScopeId,                       // Scope id for Dest (0 if non-scoped).
    Interface *IF,                      // IF to send from (may be NULL).
    RouteCacheEntry **ReturnRCE)        // Returns pointer to cached route.
{
    ulong CurrentValidationCounter;
    RouteCacheEntry *SaveRCE = NULL;
    RouteCacheEntry *RCE;
    RouteCacheEntry *NextRCE;
    Interface *TmpIF;
    NeighborCacheEntry *NCE;
    NetTableEntry *NTE;
    ushort Constrained;
    IP_STATUS ReturnValue;
    ushort Scope;

    //
    // Precompute and save some time in the loop.
    //
    Scope = AddressScope(Dest);
    ASSERT((IF == NULL) ||
           ((ScopeId != 0) && (ScopeId == IF->ZoneIndices[Scope])));

    //
    // For consistency, snapshot RouteCacheValidationCounter.
    //
    CurrentValidationCounter = RouteCacheValidationCounter;

    //
    // Check for an existing route cache entry.
    // There are two main cases.
    //
    // If IF is not NULL, then there is at most one matching RCE
    // in the cache. If this RCE does not validate, then we can use
    // the results of FindNextHop/FindBestSourceAddress when creating
    // the new RCE.
    //
    // If IF is NULL, then there may be more than one matching RCE.
    // We can only reuse the results of the validating FindNextHop/
    // FindBestSourceAddress iff FindNextHop returned Constrained == 0.
    //

    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = NextRCE) {
        NextRCE = RCE->Next;

        //
        // We want a route to the requested destination, obviously.
        //
        if (!IP6_ADDR_EQUAL(Dest, &RCE->Destination))
            continue;

        TmpIF = RCE->NTE->IF;

        //
        // Check for a caller-imposed interface constraint.
        //
        if (IF == NULL) {
            //
            // We're not constrained to a particular interface, so
            // there may be multiple routes to this destination in
            // the cache to choose from.  Don't pick a constrained RCE.
            //
            if (RCE->Flags & RCE_FLAG_CONSTRAINED_IF) {
                //
                // If this RCE is invalid, then RCE_FLAG_CONSTRAINED_IF
                // might be stale information. We do not want to pass
                // by this RCE and then later create another RCE
                // for the same interface/destination pair.
                //
                if (RCE->Valid != CurrentValidationCounter)
                    goto AttemptValidation;
                continue;
            }

            //
            // Check for a ScopeId constraint.
            //
            if (ScopeId == 0) {
                //
                // We're not constrained to a particular zone, so
                // there may be multiple routes to this destination in
                // the cache to choose from.  Don't pick a constrained RCE.
                //
                if (RCE->Flags & RCE_FLAG_CONSTRAINED_SCOPEID) {
                    //
                    // If this RCE is invalid, RCE_FLAG_CONSTRAINED_SCOPEID
                    // might be stale information. We do not want to pass
                    // by this RCE and then later create another RCE
                    // for the same interface/destination pair.
                    //
                    if (RCE->Valid != CurrentValidationCounter)
                        goto AttemptValidation;
                    continue;
                }
            } else {
                //
                // We're constrained to a particular zone.
                // If this route uses a different one, keep looking.
                //
                if (ScopeId != TmpIF->ZoneIndices[Scope])
                    continue;
            }
        } else {
            //
            // We're constrained to a particular interface.
            // If this route uses a different one, keep looking.
            //
            if (IF != TmpIF)
                continue;

            ASSERT((ScopeId != 0) && (ScopeId == TmpIF->ZoneIndices[Scope]));
        }

        //
        // At this point, we have a RCE that matches our criteria.
        // As long as the RCE is still valid, we're done.
        //
        if (RCE->Valid == CurrentValidationCounter) {
            IF = TmpIF;
            goto ReturnRCE;
        }

    AttemptValidation:

        //
        // Something has changed in the routing state since the last
        // time this RCE was validated.  Attempt to revalidate it.
        // We calculate a new NTE and NCE for this destination,
        // restricting ourselves to sending from the same interface.
        // Note that because we are validating an RCE,
        // the arguments to FindNextHop are completely dependent on
        // the contents of the RCE, not the arguments to FindOrCreateRoute.
        //
        ReturnValue = FindNextHop(TmpIF, Dest, TmpIF->ZoneIndices[Scope],
                                  &NCE, &Constrained);
        if (ReturnValue != IP_SUCCESS)
            goto RemoveAndContinue;

        ASSERT((IF == NULL) || (IF == TmpIF));
        ASSERT(TmpIF == RCE->NTE->IF);
        ASSERT(TmpIF == RCE->NCE->IF);

        NTE = FindBestSourceAddress(TmpIF, Dest);
        if (NTE == NULL) {
            ReleaseNCE(NCE);
        RemoveAndContinue:
            //
            // Bad news for this RCE.
            // We must remove it from the cache
            // before we continue searching,
            // lest we inadvertently create a second RCE
            // for the same interface/destination pair.
            //
            RemoveRCE(RCE);
            ReleaseRCE(RCE);
            continue;
        }

        //
        // If our new calculations yield the same NTE and NCE that
        // are present in the existing RCE, then we can just validate it.
        // Note that we check the NCE even if this is a Redirect RCE.
        // If the routing table changes, we want to start over with
        // a new first-hop, which might just redirect us again. Or might not.
        //
        if ((RCE->NTE == NTE) &&
            (RCE->NCE == NCE) &&
            (RCE->Flags == Constrained)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "FindOrCreateRoute - validating RCE %p\n", RCE));

            RCE->Valid = CurrentValidationCounter;
            ReleaseNCE(NCE);
            ReleaseNTE(NTE);

            //
            // We need to check again that the RCE meets the criteria.
            // We may have checked the RCE validity because the RCE
            // appeared to be constrained and we need an unconstrained RCE.
            // So in that case, if the RCE validated we can't actually use it.
            // NB: ScopeId == 0 implies IF == NULL.
            //
            if ((ScopeId == 0) ?
                (Constrained & RCE_FLAG_CONSTRAINED) :
                ((IF == NULL) && (Constrained & RCE_FLAG_CONSTRAINED_IF)))
                continue;

            IF = TmpIF;
            goto ReturnRCE;
        }

        //
        // We can't just validate the existing RCE, we need to update
        // it.  If the RCE has exactly one reference, we could update it
        // in place (this wouldn't work if it has more than one reference
        // since there is no way to signal the RCE's other users that the
        // NCE and/or NTE it caches has changed).  But this wouldn't help
        // the case where we are called from ValidateRCE.  And it would
        // require some care as to which information in the RCE is still
        // valid.  So we ignore this optimization opportunity and will
        // create a new RCE instead.
        //
        // However, we can take advantage of another optimization.  As
        // long as we're still limiting our interface choice to the one
        // that is present in the existing (invalid) RCE, and there isn't
        // a better route available, then we can use the NCE and NTE we
        // got from FindNextHop and FindBestSourceAddress above to create
        // our new RCE since we aren't going to find a better one.
        // NB: ScopeId == 0 implies IF == NULL.
        //
        if ((ScopeId == 0) ?
            !(Constrained & RCE_FLAG_CONSTRAINED) :
            ((IF != NULL) || !(Constrained & RCE_FLAG_CONSTRAINED_IF))) {
            //
            // Since some of the state information in the existing RCE
            // is still valid, we hang onto it so we can use it later
            // when creating the new RCE. We assume ownership of the
            // cache's reference for the invalid RCE.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "FindOrCreateRoute - saving RCE %p\n", RCE));
            RemoveRCE(RCE);
            SaveRCE = RCE;
            IF = TmpIF;
            goto HaveNCEandNTE;
        }

        ReleaseNTE(NTE);
        ReleaseNCE(NCE);

        //
        // Not valid, we keep looking for a valid matching RCE.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "FindOrCreateRoute - invalid RCE %p\n", RCE));
    }

    //
    // No existing RCE found. Before creating a new RCE,
    // we determine a next-hop neighbor (NCE) and
    // a best source address (NTE) for this destination.
    // The order is important: we want to avoid churning
    // the cache via CreateOrReuseRoute if we will just
    // get an error anyway.
    // This prevents a denial-of-service attack.
    //

    ReturnValue = FindNextHop(IF, Dest, ScopeId,
                              &NCE, &Constrained);
    if (ReturnValue != IP_SUCCESS)
        goto ReturnError;

    ASSERT((IF == NULL) || (IF == NCE->IF));
    IF = NCE->IF;

    //
    // Find the best source address for this destination.
    // (The NTE from our caller might not be the best.)
    // By restricting ourselves to the interface returned
    // by FindNextHop above, we know we haven't left our
    // particular scope.
    //
    NTE = FindBestSourceAddress(IF, Dest);
    if (NTE == NULL) {
        //
        // We have no valid source address to use!
        //
        ReturnValue = IP_BAD_ROUTE;
        ReleaseNCE(NCE);
        goto ReturnError;
    }

  HaveNCEandNTE:

    //
    // Get a new route cache entry.
    // Because SaveRCE was just removed from the cache,
    // CreateOrReuseRoute will not find it.
    //
    RCE = CreateOrReuseRoute();
    if (RCE == NULL) {
        ReturnValue = IP_NO_RESOURCES;
        ReleaseNTE(NTE);
        ReleaseNCE(NCE);
        goto ReturnError;
    }

    //
    // FindOrCreateNeighbor/FindNextHop gave us a reference for the NCE.
    // We donate that reference to the RCE.
    // Similarly, FindBestSourceAddress gave us a reference
    // for the NTE and we donate the reference to the RCE.
    //
    RCE->NCE = NCE;
    RCE->NTE = NTE;
    RCE->PathMTU = IF->LinkMTU;
    RCE->PMTULastSet = 0;  // PMTU timer not running.
    RCE->Destination = *Dest;
    RCE->Type = RCE_TYPE_COMPUTED;
    RCE->Flags = Constrained;
    // Start with a value safely in the past.
    RCE->LastError = IPv6TickCount - ICMP_MIN_ERROR_INTERVAL;
    RCE->BCE = FindBindingCacheEntry(Dest);
    RCE->Valid = CurrentValidationCounter;

    //
    // Copy state from a previous RCE for this destination,
    // if we have it and the state is relevant.
    //
    if (SaveRCE != NULL) {
        ASSERT(SaveRCE->NTE->IF == RCE->NTE->IF);

        //
        // PathMTU is relevant if the next-hop neighbor is unchanged.
        //
        if (RCE->NCE == SaveRCE->NCE) {
            RCE->PathMTU = SaveRCE->PathMTU;
            RCE->PMTULastSet = SaveRCE->PMTULastSet;
        }

        //
        // ICMP rate-limiting information is always relevant.
        //
        RCE->LastError = SaveRCE->LastError;
    }

    //
    // Add the new route cache entry to the cache.
    //
    InsertRCE(RCE);

  ReturnRCE:
    //
    // If the RCE is not at the front of the cache, move it there.
    //
    MoveToFrontRCE(RCE);

    ASSERT(IF == RCE->NTE->IF);

    //
    // Check route cache consistency.
    //
    RouteCacheCheck(RCE, CurrentValidationCounter);

    AddRefRCE(RCE);
    ASSERT(RCE->RefCnt >= 2); // One held by the cache, one for our caller.
    *ReturnRCE = RCE;
    ReturnValue = IP_SUCCESS;
  ReturnError:
    if (SaveRCE != NULL)
        ReleaseRCE(SaveRCE);
    return ReturnValue;
}


//* CompareRoutes
//
//  Compares the desirability of two routes.
//  >0 means A is preferred,
//  0 means no preference,
//  <0 means B is preferred.
//
//  It is very important that the comparison relation be transitive,
//  to achieve predictable route selection.
//
//  Called with the route table locked.
//
int
CompareRoutes(
    RouteTableEntry *A,
    int Areachable,
    RouteTableEntry *B,
    int Breachable)
{
    uint Apref, Bpref;

    //
    // Compare reachability.
    //
    if (Areachable > Breachable)
        return 1;   // Prefer A.
    else if (Breachable > Areachable)
        return -1;  // Prefer B.

    //
    // Compare prefix length.
    //
    if (A->PrefixLength > B->PrefixLength)
        return 1;       // Prefer A.
    else if (B->PrefixLength > A->PrefixLength)
        return -1;      // Prefer B.

    //
    // Compare preference.
    // Route & interface preference values are restricted
    // so that these additions do not overflow.
    //
    Apref = A->IF->Preference + A->Preference;
    Bpref = B->IF->Preference + B->Preference;

    if (Apref < Bpref)
        return 1;       // Prefer A.
    else if (Bpref < Apref)
        return -1;      // Prefer B.

    return 0;           // No preference.
}


//* FindNextHop
//
//  Given a destination address, checks the list of routes
//  using the longest-matching-prefix algorithm
//  to decide if we have a route to this address.
//  If so, returns the neighbor through which we should route.
//
//  If the optional IF is supplied, then this constrains the lookup
//  to only use routes via the specified outgoing interface.
//  If IF is specified then ScopeId should be specified.
//
//  If the optional ScopeId is supplied, then this constraints the lookup
//  to only use routes via interfaces in the correct zone for the
//  scope of the destination address.
//
//  The ReturnConstrained parameter returns an indication of whether the
//  IF and ScopeId parameters constrained the returned NCE.
//  That is, if IF is NULL and ScopeId is non-zero (for scoped destinations)
//  then Constrained is always returned as zero. If IF is non-NULL and
//  a different NCE is returned than would have been returned if IF were
//  NULL, then Constrained is returned with RCE_FLAG_CONSTRAINED_IF set.
//  Similarly, if ScopeId is non-zero and a different NCE is returned
//  than would have been returned if ScopeId were zero, then Constrained
//  is returned with RCE_FLAG_CONSTRAINED_SCOPEID set.
//
//  NOTE: Any code path that changes any state used by FindNextHop
//  must use InvalidateRouteCache.
//
//  Callable from DPC context, not from thread context.
//  May be called with the RouteCacheLock held.
//
IP_STATUS
FindNextHop(
    Interface *IF,
    const IPv6Addr *Dest,
    uint ScopeId,
    NeighborCacheEntry **ReturnNCE,
    ushort *ReturnConstrained)
{
    RouteTableEntry *RTE, **PrevRTE;
    NeighborCacheEntry *NCE;
    uint MinPrefixLength;
    NeighborReachability Reachable;
    ushort Scope;

    //
    // These variables track the best route that we can actually return,
    // subject to the IF and ScopeId constraints.
    //
    NeighborCacheEntry *BestNCE = NULL;     // Holds a reference.
    RouteTableEntry *BestRTE = NULL;        // Used when BestNCE is non-NULL.
    NeighborReachability BestReachable = 0; // Used when BestNCE is non-NULL.

    //
    // These variables track the best route in the right zone.
    // They are only used if IF != NULL.
    //
    NeighborCacheEntry *BzoneNCE = NULL;     // Holds a reference.
    RouteTableEntry *BzoneRTE = NULL;        // Used when BzoneNCE is non-NULL.
    NeighborReachability BzoneReachable = 0; // Used when BzoneNCE is non-NULL.

    //
    // These variables track the best unconstrained route.
    // They are only used if IF != NULL or ScopeId != 0:
    // in other words, if there is some constraint.
    //
    NeighborCacheEntry *BallNCE = NULL;     // Holds a reference.
    RouteTableEntry *BallRTE = NULL;        // Used when BallNCE is non-NULL.
    NeighborReachability BallReachable = 0; // Used when BallNCE is non-NULL.

    //
    // These variables remember whether there could be a better route
    // than the one we are tracking, if a neighbor that is
    // currently unreachable were reachable instead.
    //    
    int BestCouldBeBetterReachable = FALSE;
    int BzoneCouldBeBetterReachable = FALSE;
    int BallCouldBeBetterReachable = FALSE;
    
    //
    // Keep track of whether the destination could be on-link
    // to an interface.
    //
    int CouldBeBetterOnLink = FALSE;

    //
    // An unspecified destination is never legal here.
    //
    if (IsUnspecified(Dest)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "FindNextHop - inappropriate dest?\n"));
        return IP_PARAMETER_PROBLEM;
    }

    //
    // We enforce a minimum prefix length for "on-link" addresses.
    // If we match a route that is shorter than the minimum prefix length,
    // we treat the route as if it were on-link. The net effect is
    // that a default route implies a default interface for multicast
    // and link-local destinations. This may of course be overridden
    // with the appropriate more-specific /8 or /10 route.
    //
    if (IsMulticast(Dest))
        MinPrefixLength = 8;
    else if (IsLinkLocal(Dest))
        MinPrefixLength = 10;
    else
        MinPrefixLength = 0;

    //
    // Calculate the scope of the destination address.
    //
    Scope = AddressScope(Dest);
    ASSERT((IF == NULL) ||
           ((ScopeId != 0) && (ScopeId == IF->ZoneIndices[Scope])));

    KeAcquireSpinLockAtDpcLevel(&RouteTableLock);

    PrevRTE = &RouteTable.First;
    while ((RTE = *PrevRTE) != NULL) {

        //
        // Does this route's prefix match that of our destination address?
        //
        if ((RTE->ValidLifetime != 0) &&
            (RTE->PrefixLength >= MinPrefixLength) &&
            HasPrefix(Dest, &RTE->Prefix, RTE->PrefixLength)) {

            //
            // We have a match against a potential route.
            // Get a pointer to the next hop.
            //
            if (IsOnLinkRTE(RTE)) {
                //
                // Note that in some situations we will create an NCE
                // that we will end up not using. That's OK.
                //
                NCE = FindOrCreateNeighbor(RTE->IF, Dest);
                if (NCE == NULL) {
                    //
                    // Couldn't create a new neighbor.
                    // Just bail out now.
                    //
                    KeReleaseSpinLockFromDpcLevel(&RouteTableLock);
                ReturnNoResources:
                    if (BallNCE != NULL)
                        ReleaseNCE(BallNCE);
                    if (BzoneNCE != NULL)
                        ReleaseNCE(BzoneNCE);
                    if (BestNCE != NULL)
                        ReleaseNCE(BestNCE);
                    return IP_NO_RESOURCES;
                }
            } else {
                NCE = RTE->NCE;
                AddRefNCE(NCE);
            }

            //
            // Note that reachability state transitions
            // must invalidate the route cache.
            // A negative return value indicates
            // that the neighbor was just found to be unreachable
            // so we should round-robin.
            //
            Reachable = GetReachability(NCE);
            if (Reachable < 0) {
                //
                // Time for round-robin. Move this route to the end
                // and continue. The next time we get to this route,
                // GetReachability will return a non-negative value.
                //
                // Because round-robin perturbs route table state,
                // it "should" invalidate the route cache. However,
                // this isn't necessary. The route cache is invalidated
                // when NCE->DoRoundRobin is set to TRUE, and the
                // round-robin is actually performed by FindNextHop before
                // returning any result that could depend on this
                // route's position in the route table.
                //
                ReleaseNCE(NCE);
                RemoveRTE(PrevRTE, RTE);
                InsertRTEAtBack(RTE);
                continue;
            }

            //
            // Track the best route that we can actually return,
            // subject to the IF and ScopeId constraints.
            //
            if ((IF == NULL) ?
                ((ScopeId == 0) || (ScopeId == RTE->IF->ZoneIndices[Scope])) :
                (IF == RTE->IF)) {

                if (IsOnLinkRTE(RTE))
                    CouldBeBetterOnLink = TRUE;

                if (BestNCE == NULL) {
                    //
                    // This is the first suitable next hop,
                    // so remember it.
                    //
                RememberBest:
                    AddRefNCE(NCE);
                    BestNCE = NCE;
                    BestRTE = RTE;
                    BestReachable = Reachable;
                }
                else {
                    int Better;

                    Better = CompareRoutes(RTE, Reachable,
                                           BestRTE, BestReachable);

                    //
                    // If this is a route via a currently-unreachable neighbor,
                    // check if it appears that it might be a better route
                    // if the neighbor were reachable.
                    //
                    if (!BestCouldBeBetterReachable &&
                        (Reachable == NeighborUnreachable) &&
                        (CompareRoutes(RTE, NeighborMayBeReachable,
                                       BestRTE, BestReachable) > Better))
                        BestCouldBeBetterReachable = TRUE;

                    if (Better > 0) {
                        //
                        // This next hop looks better.
                        //
                        ReleaseNCE(BestNCE);
                        goto RememberBest;
                    }
                }
            }

            //
            // Track the best route in the right zone.
            // This ignores the IF constraint.
            //
            if ((ScopeId == 0) ||
                (ScopeId == RTE->IF->ZoneIndices[Scope])) {

                if (BzoneNCE == NULL) {
                    //
                    // This is the first suitable next hop,
                    // so remember it.
                    //
                RememberBzone:
                    AddRefNCE(NCE);
                    BzoneNCE = NCE;
                    BzoneRTE = RTE;
                    BzoneReachable = Reachable;
                }
                else {
                    int Better;

                    Better = CompareRoutes(RTE, Reachable,
                                           BzoneRTE, BzoneReachable);

                    //
                    // If this is a route via a currently-unreachable neighbor,
                    // check if it appears that it might be a better route
                    // if the neighbor were reachable.
                    //
                    if (!BzoneCouldBeBetterReachable &&
                        (Reachable == NeighborUnreachable) &&
                        (CompareRoutes(RTE, NeighborMayBeReachable,
                                       BzoneRTE, BzoneReachable) > Better))
                        BzoneCouldBeBetterReachable = TRUE;

                    if (Better > 0) {
                        //
                        // This next hop looks better.
                        //
                        ReleaseNCE(BzoneNCE);
                        goto RememberBzone;
                    }
                }
            }

            //
            // Track the best route matching the destination.
            // This ignores both IF and ScopeId constraints.
            //
            if (BallNCE == NULL) {
                //
                // This is the first suitable next hop,
                // so remember it.
                //
            RememberBall:
                AddRefNCE(NCE);
                BallNCE = NCE;
                BallRTE = RTE;
                BallReachable = Reachable;
            }
            else {
                int Better;

                Better = CompareRoutes(RTE, Reachable,
                                       BallRTE, BallReachable);

                //
                // If this is a route via a currently-unreachable neighbor,
                // check if it appears that it might be a better route
                // if the neighbor were reachable.
                //
                if (!BallCouldBeBetterReachable &&
                    (Reachable == NeighborUnreachable) &&
                    (CompareRoutes(RTE, NeighborMayBeReachable,
                                   BallRTE, BallReachable) > Better))
                    BallCouldBeBetterReachable = TRUE;

                if (Better > 0) {
                    //
                    // This next hop looks better.
                    //
                    ReleaseNCE(BallNCE);
                    goto RememberBall;
                }
            }
            
            ReleaseNCE(NCE);
        }

        //
        // Move on to the next route.
        //
        PrevRTE = &RTE->Next;
    }
    ASSERT(PrevRTE == RouteTable.Last);

    //
    // If the destination could be on-link and we actually selected
    // an on-link route, then we are OK. Otherwise, we need to check
    // if the destination could be on-link to the interface
    // that we selected. This implements one aspect of RFC 2461's
    // conceptual sending algorithm - the Prefix List is consulted
    // before the Default Router List. Note that RFC 2461 does not
    // consider multi-interface hosts and we only enforce a preference for
    // on-link routes within the context of a single interface.
    // If we choose a router on an interface when we could have chosen
    // on-link to the interface, the router would presumably just
    // Redirect us, so it's better to just send on-link even if the
    // destination is not reachable on-link. If the destination
    // is on-link but not reachable via one interface,
    // then we are happy to send off-link via another interface.
    // This may or may not succeed in reaching the destination,
    // but at least it has a chance of succeeding.
    // The CouldBeBetterReachable code will periodically probe
    // the destination's on-link reachability.
    //
    if (CouldBeBetterOnLink && IsOnLinkRTE(BestRTE))
        CouldBeBetterOnLink = FALSE;

    if (BestCouldBeBetterReachable ||
        BzoneCouldBeBetterReachable ||
        BallCouldBeBetterReachable ||
        CouldBeBetterOnLink) {
        ASSERT((BestNCE != NULL) && (BzoneNCE != NULL) && (BallNCE != NULL));

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "FindNextHop: 2nd pass: Dest %s CBBOnLink %d "
                   "BestCBBReachable %d BestRTE %p BestNCE %p "
                   "BzoneCBBReachable %d BzoneRTE %p BzoneNCE %p "
                   "BallCBBReachable %d BallRTE %p BallNCE %p\n",
                   FormatV6Address(Dest), CouldBeBetterOnLink,
                   BestCouldBeBetterReachable, BestRTE, BestNCE,
                   BzoneCouldBeBetterReachable, BzoneRTE, BzoneNCE,
                   BallCouldBeBetterReachable, BallRTE, BallNCE));

        //
        // Make a second pass over the routes.
        //
        for (RTE = RouteTable.First; RTE != NULL; RTE = RTE->Next) {
            //
            // Does this route's prefix match that of our destination address?
            //
            if ((RTE->ValidLifetime != 0) &&
                (RTE->PrefixLength >= MinPrefixLength) &&
                HasPrefix(Dest, &RTE->Prefix, RTE->PrefixLength)) {
                //
                // Would this be a better route
                // than the one we are tracking
                // if the neighbor were reachable?
                //                
                if ((BallCouldBeBetterReachable &&
                     CompareRoutes(RTE, NeighborMayBeReachable,
                                   BallRTE, BallReachable) > 0) ||

                    (((ScopeId == 0) ||
                      (ScopeId == RTE->IF->ZoneIndices[Scope])) &&
                     BzoneCouldBeBetterReachable &&
                     CompareRoutes(RTE, NeighborMayBeReachable,
                                   BzoneRTE, BzoneReachable) > 0) ||

                    (((IF == NULL) ?
                      ((ScopeId == 0) ||
                       (ScopeId == RTE->IF->ZoneIndices[Scope])) :
                      (IF == RTE->IF)) &&
                     BestCouldBeBetterReachable &&
                     CompareRoutes(RTE, NeighborMayBeReachable,
                                   BestRTE, BestReachable) > 0)) {
                    //
                    // OK, we want to know if this neighbor becomes reachable,
                    // because if it does we should change our routing.
                    //
                    if (IsOnLinkRTE(RTE))
                        NCE = FindOrCreateNeighbor(RTE->IF, Dest);
                    else
                        AddRefNCE(NCE = RTE->NCE);
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                               "FindNextHop: CBBReachable: RTE %p NCE %p\n",
                               RTE, NCE));
                    if (NCE != NULL) {
                        NeighborCacheProbeUnreachability(NCE);
                        ReleaseNCE(NCE);
                    }
                }
                
                //
                // Is this an on-link route on the same interface
                // that we have chosen to use off-link?
                //
                if (((IF == NULL) ?
                     ((ScopeId == 0) ||
                      (ScopeId == RTE->IF->ZoneIndices[Scope])) :
                     (IF == RTE->IF)) &&
                    CouldBeBetterOnLink &&
                    IsOnLinkRTE(RTE) && (RTE->IF == BestRTE->IF)) {
                    //
                    // OK, we want to send directly to this destination.
                    // Switch to the on-link NCE.
                    //
                    NCE = FindOrCreateNeighbor(RTE->IF, Dest);
                    if (NCE == NULL) {
                        KeReleaseSpinLockFromDpcLevel(&RouteTableLock);
                        goto ReturnNoResources;
                    }

                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                               "FindNextHop: CBBOnLink: "
                               "BestRTE %p BestNCE %p RTE %p NCE %p\n",
                               BestRTE, BestNCE, RTE, NCE));

                    if (BallNCE == BestNCE) {
                        ReleaseNCE(BallNCE);
                        AddRefNCE(NCE);
                        BallNCE = NCE;
                    }

                    if (BzoneNCE == BestNCE) {
                        ReleaseNCE(BzoneNCE);
                        AddRefNCE(NCE);
                        BzoneNCE = NCE;
                    }

                    ReleaseNCE(BestNCE);
                    BestNCE = NCE;
                    CouldBeBetterOnLink = FALSE;
                }
            }
        }
    }

    KeReleaseSpinLockFromDpcLevel(&RouteTableLock);

    ASSERT((BallNCE != NULL) || (BzoneNCE == NULL));
    ASSERT((ScopeId != 0) || (BallNCE == BzoneNCE));
    ASSERT((BzoneNCE != NULL) || (BestNCE == NULL));
    ASSERT((IF != NULL) || (BzoneNCE == BestNCE));

    //
    // OK, we've consulted the routing table.
    // But what if we didn't find a route?
    // RFC 2461 Section 5.2 specifies "If the Default Router List
    // is empty, the sender assumes that the destination is on-link."
    // The question is, on-link to which interface?
    //

    if (BallNCE == NULL) {
        Interface *ScopeIF;

        //
        // Check if there is a default interface for this scope.
        //
        ScopeIF = FindDefaultInterfaceForZone(Scope, 0);
        if (ScopeIF != NULL) {
            BallNCE = FindOrCreateNeighbor(ScopeIF, Dest);
            ReleaseIF(ScopeIF);
            if (BallNCE == NULL)
                goto ReturnNoResources;
        }
    }

    if (BzoneNCE == NULL) {
        if (ScopeId != 0) {
            Interface *ScopeIF;

            //
            // Check if there is a default interface for the zone.
            //
            ScopeIF = FindDefaultInterfaceForZone(Scope, ScopeId);
            if (ScopeIF != NULL) {
                BzoneNCE = FindOrCreateNeighbor(ScopeIF, Dest);
                ReleaseIF(ScopeIF);
                if (BzoneNCE == NULL)
                    goto ReturnNoResources;
            }
        }
        else if (BallNCE != NULL) {
            //
            // Use the default interface for the scope.
            //
            AddRefNCE(BallNCE);
            BzoneNCE = BallNCE;
        }
    }

    if (BestNCE == NULL) {
        if (IF != NULL) {
            //
            // Use the constraining interface.
            //
            BestNCE = FindOrCreateNeighbor(IF, Dest);
            if (BestNCE == NULL)
                goto ReturnNoResources;
        }
        else if (BzoneNCE != NULL) {
            //
            // Use the default interface for the zone.
            //
            AddRefNCE(BzoneNCE);
            BestNCE = BzoneNCE;
        }
    }

    //
    // We can release BzoneNCE and BallNCE and still compare against them.
    //
    if (BallNCE != NULL)
        ReleaseNCE(BallNCE);
    if (BzoneNCE != NULL)
        ReleaseNCE(BzoneNCE);

    if (BestNCE != NULL) {
        *ReturnNCE = BestNCE;

        if (BestNCE == BallNCE) {
            //
            // The IF and ScopeId arguments did not
            // affect our BestNCE choice.
            //
            *ReturnConstrained = 0;
        }
        else if (BestNCE == BzoneNCE) {
            //
            // The IF argument did not affect our BestNCE choice, but
            // the ScopeId argument did because BzoneNCE != BallNCE.
            //
            *ReturnConstrained = RCE_FLAG_CONSTRAINED_SCOPEID;
        }
        else {
            //
            // The IF argument affected our BestNCE choice.
            //
            *ReturnConstrained = RCE_FLAG_CONSTRAINED;
        }

        return IP_SUCCESS;
    }
    else if ((ScopeId != 0) && (BzoneNCE == NULL)) {
        //
        // The ScopeId was invalid.
        //
        return IP_PARAMETER_PROBLEM;
    }
    else {
        //
        // Didn't find a suitable next hop.
        //
        return IP_DEST_NO_ROUTE;
    }
}


//* FlushRouteCache
//
//  Flushes entries from the route cache.
//  The Interface or the Address can be left unspecified.
//  in which case all relevant entries are flushed.
//
//  Note that even if an RCE has references,
//  we can still remove it from the route cache.
//  It will continue to exist until its ref count falls to zero,
//  but subsequent calls to RouteToDestination will not find it.
//
//  Called with NO locks held.
//  Callable from thread or DPC context.
//
void
FlushRouteCache(Interface *IF, const IPv6Addr *Addr)
{
    RouteCacheEntry *Delete = NULL;
    RouteCacheEntry *RCE, *NextRCE;
    KIRQL OldIrql;

    //
    // REVIEW: If both IF and Addr are specified,
    // we can bail out of the loop early.
    //

    KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = NextRCE) {
        NextRCE = RCE->Next;

        if (((IF == NULL) ||
             (IF == RCE->NTE->IF)) &&
            ((Addr == NULL) ||
             IP6_ADDR_EQUAL(Addr, &RCE->Destination))) {
            //
            // We can remove this RCE from the cache.
            //
            RemoveRCE(RCE);

            //
            // Put it on our delete list.
            //
            RCE->Next = Delete;
            Delete = RCE;
        }
    }
    KeReleaseSpinLock(&RouteCacheLock, OldIrql);

    //
    // Release the RCE references that were held by the route cache.
    //
    while (Delete != NULL) {
        RCE = Delete;
        Delete = RCE->Next;

        //
        // Prevent use of this RCE by anyone who has it cached.
        //
        InvalidateRCE(RCE);
        ReleaseRCE(RCE);
    }
}


//* ReleaseRCE
//
//  Releases a reference to an RCE.
//  Sometimes called with the route cache lock held.
//
void
ReleaseRCE(RouteCacheEntry *RCE)
{
    if (InterlockedDecrement(&RCE->RefCnt) == 0) {
        //
        // This RCE should be deallocated.
        // It has already been removed from the cache.
        //
        ReleaseNTE(RCE->NTE);
        ReleaseNCE(RCE->NCE);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "Freeing RCE: %p\n",RCE));
        ExFreePool(RCE);
    }
}


//* FindNetworkWithAddress - Locate NTE with corresponding address and scope.
//
//  Convert a source address to an NTE by scanning the list of NTEs,
//  looking for an NTE with this address.  If the address is scope
//  specific, the ScopeId provided should identify the scope.
//
//  Returns NULL if no matching NTE is found.
//  If found, returns a reference for the NTE.
//
NetTableEntry *
FindNetworkWithAddress(const IPv6Addr *Source, uint ScopeId)
{
    ushort Scope;
    NetTableEntry *NTE;
    KIRQL OldIrql;

    //
    // Canonicalize ScopeId and get Scope.
    //
    if (! CanonicalizeScopeId(Source, &ScopeId, &Scope))
        return NULL;

    KeAcquireSpinLock(&NetTableListLock, &OldIrql);

    //
    // Loop through all the NTEs on the NetTableList.
    //
    for (NTE = NetTableList; ; NTE = NTE->NextOnNTL) {
        if (NTE == NULL)
            goto Return;

        //
        // Have we found an NTE with matching address and ScopeId?
        //
        if (IP6_ADDR_EQUAL(&NTE->Address, Source) &&
            (ScopeId == NTE->IF->ZoneIndices[Scope])) {

            //
            // Check that this NTE is valid.
            // (For example, an NTE still doing DAD is invalid.)
            //
            if (!IsValidNTE(NTE)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                           "FindNetworkWithAddress: invalid NTE\n"));
                NTE = NULL;
                goto Return;
            }

            break;
        }
    }

    AddRefNTE(NTE);
  Return:
    KeReleaseSpinLock(&NetTableListLock, OldIrql);
    return NTE;
}


//* InvalidateRouter
//
//  Called when we know a neighbor is no longer a router.
//  This function implements RFC 2461 section 7.3.3 -
//  when a node detects that a router has changed to a host,
//  the node MUST remove it from the Default Router List.
//  For our implementation, this means removing autoconfigured
//  routes from the routing table.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
void
InvalidateRouter(NeighborCacheEntry *NCE)
{
    CheckRtChangeContext Context;
    RouteTableEntry *RTE, **PrevRTE;

    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "Invalidating routes with NCE=%p\n", NCE));

    PrevRTE = &RouteTable.First;
    while((RTE = *PrevRTE) != NULL) {

        if ((RTE->NCE == NCE) &&
            (RTE->Type == RTE_TYPE_AUTOCONF)) {
            //
            // Remove the RTE from the list.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "InvalidateRouter: removed RTE %p\n", RTE));
            RemoveRTE(PrevRTE, RTE);

            //
            // Check for matching route change notification requests.
            //
            CheckRtChangeNotifyRequests(&Context, NULL, RTE);

            //
            // Release the RTE.
            //
            ReleaseNCE(NCE);
            ExFreePool(RTE);
        }
        else {
            PrevRTE = &RTE->Next;
        }
    }
    ASSERT(PrevRTE == RouteTable.Last);

    //
    // Invalidate the route cache, even if the routing table has not changed.
    // We must invalidate any RCEs that are using this NCE,
    // perhaps because of a Redirect.
    //
    InvalidateRouteCache();

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }
}


//* RouteTableUpdate - Update the route table.
//
//  Updates the route table by creating a new route
//  or modifying the lifetime of an existing route.
//
//  If the NCE is null, then the prefix is on-link.
//  Otherwise the NCE specifies the next hop.
//
//  REVIEW - Should we do anything special when we get identical
//  routes with different next hops? Currently they both end up
//  in the table, and FindNextHop tries to pick the best one.
//
//  Note that the ValidLifetime may be INFINITE_LIFETIME,
//  whereas Neighbor Discovery does not allow an infinite value
//  for router lifetimes on the wire.
//
//  The Publish and Immortal boolean arguments control
//  the respective flag bits in the RTE.
//
//  The FileObject identifies the requestor of this update.
//  It is used to suppress some route change notifications.
//  It should be NULL for updates originating in the stack.
//
//  The Type argument specifies the origin of the route (RTE_TYPE_* values).
//  The stack itself doesn't care about most of the values.
//  The exceptions are RTE_TYPE_SYSTEM, RTE_TYPE_MANUAL, RTE_TYPE_AUTOCONF.
//  System routes (used for loopback) can not be created/deleted by users.
//  Manual routes are affected by RouteTableReset.
//  Auto-configured routes are affected by RouteTableResetAutoConfig.
//  The Type of a route can not be updated after it is created.
//
//  System routes and published routes survive in the route table
//  even when their lifetime is zero. (Then they do not affect routing.)
//  To delete a system route, specify a lifetime and type of zero.
//
//  Error return values:
//      STATUS_INSUFFICIENT_RESOURCES - Failed to allocate pool.
//      STATUS_ACCESS_DENIED - Caller can not create/delete system route.
//      STATUS_INVALID_PARAMETER_1 - Interface is disabled.
//      STATUS_INVALID_PARAMETER_6 - Can not create route with zero Type.
//  These values are chosen for the convenience of IoctlUpdateRouteTable,
//  because our other callers only care about success/failure.
//
//  Callable from a thread or DPC context.
//  May be called with an interface lock held.
//
NTSTATUS
RouteTableUpdate(
    PFILE_OBJECT FileObject,
    Interface *IF,
    NeighborCacheEntry *NCE,
    const IPv6Addr *RoutePrefix,
    uint PrefixLength,
    uint SitePrefixLength,
    uint ValidLifetime,
    uint PreferredLifetime,
    uint Pref,
    uint Type,
    int Publish,
    int Immortal)
{
    CheckRtChangeContext Context;
    IPv6Addr Prefix;
    RouteTableEntry *RTE = NULL, **PrevRTE;
    int Delete;
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT((NCE == NULL) || (NCE->IF == IF));
    ASSERT(SitePrefixLength <= PrefixLength);
    ASSERT(PreferredLifetime <= ValidLifetime);
    ASSERT(IsValidRouteTableType(Type));

    //
    // Ensure that the unused prefix bits are zero.
    // This makes the prefix comparisons below safe.
    //
    CopyPrefix(&Prefix, RoutePrefix, PrefixLength);

    Delete = FALSE;
    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    if (IsDisabledIF(IF)) {
        //
        // Do not create routes on disabled interfaces.
        // This check must be made after locking the route table,
        // to prevent races with DestroyIF/RouteTableRemove.
        //
        Status = STATUS_INVALID_PARAMETER_1;
    }
    else {
        //
        // Search for an existing Route Table Entry.
        //
        for (PrevRTE = &RouteTable.First; ; PrevRTE = &RTE->Next) {
            RTE = *PrevRTE;

            if (RTE == NULL) {
                ASSERT(PrevRTE == RouteTable.Last);

                //
                // No existing entry for this prefix.
                // Create an entry if the lifetime is non-zero
                // or this is a published route or a system route.
                //
                if ((ValidLifetime != 0) ||
                    Publish || (Type == RTE_TYPE_SYSTEM)) {

                    if ((Type == RTE_TYPE_SYSTEM) && (FileObject != NULL)) {
                        //
                        // Users can not create system routes.
                        //
                        Status = STATUS_ACCESS_DENIED;
                        break;
                    }

                    if (Type == 0) {
                        //
                        // The zero Type value can only be used
                        // for updating and deleting routes.
                        //
                        Status = STATUS_INVALID_PARAMETER_6;
                        break;
                    }

                    RTE = ExAllocatePool(NonPagedPool, sizeof *RTE);
                    if (RTE == NULL) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                                   "RouteTableUpdate: out of pool\n"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    RTE->Type = (ushort)Type;
                    RTE->Flags = 0;
                    RTE->IF = IF;
                    if (NCE != NULL)
                        AddRefNCE(NCE);
                    RTE->NCE = NCE;
                    RTE->Prefix = Prefix;
                    RTE->PrefixLength = PrefixLength;
                    RTE->SitePrefixLength = SitePrefixLength;
                    RTE->ValidLifetime = ValidLifetime;
                    RTE->PreferredLifetime = PreferredLifetime;
                    RTE->Preference = Pref;
                    if (Publish) {
                        RTE->Flags |= RTE_FLAG_PUBLISH;
                        ForceRouterAdvertisements = TRUE;
                    }
                    if (Immortal)
                        RTE->Flags |= RTE_FLAG_IMMORTAL;

                    //
                    // Add the new entry to the route table.
                    //
                    InsertRTEAtFront(RTE);

                    if (ValidLifetime != 0) {
                        //
                        // Invalidate the route cache, so the new route
                        // actually gets used.
                        //
                        InvalidateRouteCache();
                    }
                    else {
                        //
                        // Don't notify about this route,
                        // since it is being created as invalid.
                        //
                        RTE = NULL;
                    }
                }
                break;
            }

            if ((RTE->IF == IF) && (RTE->NCE == NCE) &&
                IP6_ADDR_EQUAL(&RTE->Prefix, &Prefix) &&
                (RTE->PrefixLength == PrefixLength)) {
                //
                // We have an existing route.
                //
                if ((RTE->Type == RTE_TYPE_MANUAL) &&
                    (Type != RTE_TYPE_MANUAL)) {
                    //
                    // Manual routes can only be modified by manual updates.
                    //
                    Status = STATUS_ACCESS_DENIED;
                    RTE = NULL;
                    break;
                }

                //
                // Remove the route if the new lifetime is zero
                // (and the route is not published or a system route)
                // otherwise update the route.
                // The Type == 0 clause allows system routes to be deleted.
                //
                if ((ValidLifetime == 0) &&
                    !Publish &&
                    ((RTE->Type != RTE_TYPE_SYSTEM) || (Type == 0))) {

                    if ((RTE->Type == RTE_TYPE_SYSTEM) &&
                        (FileObject != NULL)) {
                        //
                        // Users can not delete system routes.
                        //
                        Status = STATUS_ACCESS_DENIED;
                        RTE = NULL;
                        break;
                    }

                    //
                    // Remove the RTE from the list.
                    // See similar code in RouteTableTimeout.
                    //
                    RemoveRTE(PrevRTE, RTE);

                    if (IsOnLinkRTE(RTE)) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                                   "Route RTE %p %s/%u -> IF %p removed\n",
                                   RTE,
                                   FormatV6Address(&RTE->Prefix),
                                   RTE->PrefixLength,
                                   RTE->IF));
                    }
                    else {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                                   "Route RTE %p %s/%u -> NCE %p removed\n",
                                   RTE,
                                   FormatV6Address(&RTE->Prefix),
                                   RTE->PrefixLength,
                                   RTE->NCE));

                        //
                        // Although we release the RTE's reference for the NTE,
                        // our caller still holds a reference so RTE->NCE
                        // is still valid for CheckRtChangeNotifyRequests.
                        //
                        ReleaseNCE(RTE->NCE);
                    }

                    //
                    // If we are removing a published route,
                    // resend Router Advertisements promptly.
                    //
                    if (RTE->Flags & RTE_FLAG_PUBLISH)
                        ForceRouterAdvertisements = TRUE;

                    if (RTE->ValidLifetime == 0) {
                        //
                        // This route was already invalid.
                        // Delete the route structure now.
                        //
                        ExFreePool(RTE);

                        //
                        // Don't notify a route change;
                        // that was done when the route became invalid.
                        //
                        RTE = NULL;
                    }
                    else {
                        //
                        // Invalidate all cached routes,
                        // since we are removing a valid route.
                        //
                        InvalidateRouteCache();

                        //
                        // Delete the route structure after checking
                        // for route change notifications below.
                        //
                        Delete = TRUE;

                        //
                        // Update the route lifetimes, so the route info
                        // returned in the notification shows zero lifetime.
                        // But preserve the other route attributes.
                        //
                        RTE->ValidLifetime = RTE->PreferredLifetime = 0;
                    }
                }
                else {
                    uint OldLifetime = RTE->PreferredLifetime;

                    //
                    // If we are changing a published attribute of a route,
                    // or if we are changing the publishing status of a route,
                    // then resend Router Advertisements promptly.
                    //
                    if ((Publish &&
                         ((RTE->ValidLifetime != ValidLifetime) ||
                          (RTE->PreferredLifetime != PreferredLifetime) ||
                          (RTE->SitePrefixLength != SitePrefixLength))) ||
                        (!Publish != !(RTE->Flags & RTE_FLAG_PUBLISH)))
                        ForceRouterAdvertisements = TRUE;

                    //
                    // Pick up new attributes.
                    // We do NOT update RTE->Type.
                    //
                    RTE->SitePrefixLength = SitePrefixLength;
                    RTE->ValidLifetime = ValidLifetime;
                    RTE->PreferredLifetime = PreferredLifetime;
                    RTE->Flags = ((Publish ? RTE_FLAG_PUBLISH : 0) |
                                  (Immortal ? RTE_FLAG_IMMORTAL : 0));
                    if (RTE->Preference != Pref) {
                        RTE->Preference = Pref;
                        InvalidateRouteCache();
                    }

                    if ((OldLifetime == 0) && (ValidLifetime != 0)) {
                        //
                        // This route was invalid but is now valid.
                        //
                        InvalidateRouteCache();
                    }
                    else {
                        //
                        // Do not check for route change notifications below.
                        //
                        RTE = NULL;
                    }
                }
                break;
            }
        } // end for

        if (RTE != NULL) {
            //
            // This update resulted in adding or deleting a route,
            // so check for matching route change notifications.
            //
            CheckRtChangeNotifyRequests(&Context, FileObject, RTE);
        }
    } // end if (! IsDisabledIF(IF))

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Delete)
        ExFreePool(RTE);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }

    return Status;
}


//* RouteTableResetAutoConfig
//
//  Reset the lifetimes of all auto-configured routes for an interface.
//  Also resets prefixes in the Site Prefix Table.
//
//  Callable from a thread or DPC context.
//  May be called with an interface lock held.
//
void
RouteTableResetAutoConfig(Interface *IF, uint MaxLifetime)
{
    CheckRtChangeContext Context;
    RouteTableEntry *RTE, **PrevRTE;
    SitePrefixEntry *SPE;

    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    //
    // Reset all routes for this interface.
    //
    PrevRTE = &RouteTable.First;
    while ((RTE = *PrevRTE) != NULL) {

        if (RTE->IF == IF) {
            //
            // Is this an auto-configured route?
            //
            if (RTE->Type == RTE_TYPE_AUTOCONF) {

                if (MaxLifetime == 0) {
                    //
                    // Invalidate all cached routes.
                    //
                    InvalidateRouteCache();

                    //
                    // Remove the RTE from the list.
                    //
                    RemoveRTE(PrevRTE, RTE);

                    //
                    // Check for matching route change notification requests.
                    //
                    CheckRtChangeNotifyRequests(&Context, NULL, RTE);

                    if (IsOnLinkRTE(RTE)) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                                   "Route RTE %p %s/%u -> IF %p released\n",
                                   RTE,
                                   FormatV6Address(&RTE->Prefix),
                                   RTE->PrefixLength,
                                   RTE->IF));
                    }
                    else {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                                   "Route RTE %p %s/%u -> NCE %p released\n",
                                   RTE,
                                   FormatV6Address(&RTE->Prefix),
                                   RTE->PrefixLength,
                                   RTE->NCE));

                        ReleaseNCE(RTE->NCE);
                    }

                    //
                    // Free the RTE.
                    //
                    ExFreePool(RTE);
                    continue;
                }

                if (RTE->ValidLifetime > MaxLifetime) {
                    //
                    // Reset the lifetime to a small value.
                    //
                    RTE->ValidLifetime = MaxLifetime;
                }
            }
        }

        //
        // Move to the next RTE.
        //
        PrevRTE = &RTE->Next;
    }
    ASSERT(PrevRTE == RouteTable.Last);

    //
    // Reset all site prefixes for this interface.
    //
    for (SPE = SitePrefixTable; SPE != NULL; SPE = SPE->Next) {
        if (SPE->IF == IF) {
            //
            // Is this an auto-configured site prefix?
            //
            if (SPE->ValidLifetime != INFINITE_LIFETIME) {
                //
                // Reset the lifetime to a small value.
                //
                if (SPE->ValidLifetime > MaxLifetime)
                    SPE->ValidLifetime = MaxLifetime;
            }
        }
    }

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }
}


//* RouteTableReset
//
//  Removes all manually-configured routing state.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
void
RouteTableReset(void)
{
    CheckRtChangeContext Context;
    RouteTableEntry *RTE, **PrevRTE;

    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    //
    // Remove all manually-configured routes.
    //
    PrevRTE = &RouteTable.First;
    while ((RTE = *PrevRTE) != NULL) {

        //
        // Is this a manual route?
        //
        if (RTE->Type == RTE_TYPE_MANUAL) {

            //
            // Invalidate all cached routes.
            //
            InvalidateRouteCache();

            //
            // Remove the RTE from the list.
            //
            RemoveRTE(PrevRTE, RTE);

            //
            // Check for matching route change notification requests.
            //
            CheckRtChangeNotifyRequests(&Context, NULL, RTE);

            if (IsOnLinkRTE(RTE)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "Route RTE %p %s/%u -> IF %p released\n",
                           RTE,
                           FormatV6Address(&RTE->Prefix),
                           RTE->PrefixLength,
                           RTE->IF));
            }
            else {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "Route RTE %p %s/%u -> NCE %p released\n",
                           RTE,
                           FormatV6Address(&RTE->Prefix),
                           RTE->PrefixLength,
                           RTE->NCE));

                ReleaseNCE(RTE->NCE);
            }

            //
            // Free the RTE.
            //
            ExFreePool(RTE);
            continue;
        }

        //
        // Move to the next RTE.
        //
        PrevRTE = &RTE->Next;
    }
    ASSERT(PrevRTE == RouteTable.Last);

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }
}


//* RouteTableRemove
//
//  Releases all routing state associated with the interface.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
void
RouteTableRemove(Interface *IF)
{
    CheckRtChangeContext Context;
    RouteTableEntry *RTE, **PrevRTE;
    RouteCacheEntry *RCE, *NextRCE;
    SitePrefixEntry *SPE, **PrevSPE;
    BindingCacheEntry *BCE, *NextBCE;
    KIRQL OldIrql;

    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    //
    // Remove routes for this interface.
    //
    PrevRTE = &RouteTable.First;
    while ((RTE = *PrevRTE) != NULL) {

        if (RTE->IF == IF) {
            //
            // Remove the RTE from the list.
            //
            RemoveRTE(PrevRTE, RTE);

            //
            // Check for matching route change notification requests.
            //
            CheckRtChangeNotifyRequests(&Context, NULL, RTE);

            if (IsOnLinkRTE(RTE)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "Route RTE %p %s/%u -> IF %p released\n", RTE,
                           FormatV6Address(&RTE->Prefix), RTE->PrefixLength,
                           RTE->IF));
            }
            else {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "Route RTE %p %s/%u -> NCE %p released\n", RTE,
                           FormatV6Address(&RTE->Prefix), RTE->PrefixLength,
                           RTE->NCE));

                ReleaseNCE(RTE->NCE);
            }

            //
            // Free the RTE.
            //
            ExFreePool(RTE);
        }
        else {
            //
            // Move to the next RTE.
            //
            PrevRTE = &RTE->Next;
        }
    }
    ASSERT(PrevRTE == RouteTable.Last);

    //
    // Invalidate all cached routes.
    //
    InvalidateRouteCache();

    //
    // Remove all site prefixes for this interface.
    //
    PrevSPE = &SitePrefixTable;
    while ((SPE = *PrevSPE) != NULL) {

        if (SPE->IF == IF) {
            //
            // Remove the SPE from the list.
            //
            *PrevSPE = SPE->Next;

            //
            // Release the SPE.
            //
            ExFreePool(SPE);
        }
        else {
            //
            // Move to the next SPE.
            //
            PrevSPE = &SPE->Next;
        }
    }

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }

    KeAcquireSpinLock(&RouteCacheLock, &OldIrql);

    //
    // Remove cached routes for this interface.
    //
    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = NextRCE) {
        NextRCE = RCE->Next;
        if (RCE->NTE->IF == IF) {
            RemoveRCE(RCE);
            ReleaseRCE(RCE);
        }
    }

    //
    // Remove binding cache entries for this interface.
    //
    for (BCE = BindingCache.First; BCE != SentinelBCE; BCE = NextBCE) {
        NextBCE = BCE->Next;
        if (BCE->CareOfRCE->NTE->IF == IF)
            DestroyBCE(BCE);
    }

    KeReleaseSpinLock(&RouteCacheLock, OldIrql);
}


//* RouteTableTimeout
//
//  Called periodically from IPv6Timeout.
//  Handles lifetime expiration of routing table entries.
//
void
RouteTableTimeout(void)
{
    CheckRtChangeContext Context;
    RouteTableEntry *RTE, **PrevRTE;

    InitCheckRtChangeContext(&Context);
    KeAcquireSpinLock(&RouteTableLock, &Context.OldIrql);

    PrevRTE = &RouteTable.First;
    while ((RTE = *PrevRTE) != NULL) {

        //
        // First decrement the preferred lifetime.
        //
        if (!(RTE->Flags & RTE_FLAG_IMMORTAL) &&
            (RTE->PreferredLifetime != 0) &&
            (RTE->PreferredLifetime != INFINITE_LIFETIME))
            RTE->PreferredLifetime--;

        //
        // Now check the valid lifetime.
        // If the valid lifetime is zero, then
        // the route is not valid and is not used.
        // We delete invalid routes, unless they are published.
        //
        if (RTE->ValidLifetime == 0) {
            //
            // This is an invalid route, only kept around
            // for purposes of generating Router Advertisements
            // or because it is a system route.
            //
            ASSERT((RTE->Flags & RTE_FLAG_PUBLISH) ||
                   (RTE->Type == RTE_TYPE_SYSTEM));
        }
        else if (!(RTE->Flags & RTE_FLAG_IMMORTAL) &&
                 (RTE->ValidLifetime != INFINITE_LIFETIME) &&
                 (--RTE->ValidLifetime == 0)) {
            //
            // The route is now invalid.
            // Invalidate all cached routes.
            //
            InvalidateRouteCache();

            //
            // Check for matching route change notification requests.
            //
            CheckRtChangeNotifyRequests(&Context, NULL, RTE);

            if (!(RTE->Flags & RTE_FLAG_PUBLISH) &&
                (RTE->Type != RTE_TYPE_SYSTEM)) {
                //
                // Remove the RTE from the list.
                // See similar code in RouteTableUpdate.
                //
                RemoveRTE(PrevRTE, RTE);

                if (IsOnLinkRTE(RTE)) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                               "Route RTE %p %s/%u -> IF %p timed out\n", RTE,
                               FormatV6Address(&RTE->Prefix),
                               RTE->PrefixLength,
                               RTE->IF));
                }
                else {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                               "Route RTE %p %s/%u -> NCE %p timed out\n", RTE,
                               FormatV6Address(&RTE->Prefix),
                               RTE->PrefixLength,
                               RTE->NCE));

                    ReleaseNCE(RTE->NCE);
                }

                //
                // Release the RTE and continue to the next RTE.
                //
                ExFreePool(RTE);
                continue;
            }
        }

        //
        // Continue to the next RTE.
        //
        PrevRTE = &RTE->Next;
    }
    ASSERT(PrevRTE == RouteTable.Last);

    KeReleaseSpinLock(&RouteTableLock, Context.OldIrql);

    if (Context.RequestList != NULL) {
        //
        // Complete the pending route change notifications.
        //
        CompleteRtChangeNotifyRequests(&Context);
    }
}


//* SitePrefixUpdate
//
//  Updates the site prefix table by creating a new site prefix
//  or modifying the lifetime of an existing site prefix.
//
//  Callable from a thread or DPC context.
//  May be called with an interface lock held.
//
void
SitePrefixUpdate(
    Interface *IF,
    const IPv6Addr *SitePrefix,
    uint SitePrefixLength,
    uint ValidLifetime)
{
    IPv6Addr Prefix;
    SitePrefixEntry *SPE, **PrevSPE;
    KIRQL OldIrql;

    //
    // Ensure that the unused prefix bits are zero.
    // This makes the prefix comparisons below safe.
    //
    CopyPrefix(&Prefix, SitePrefix, SitePrefixLength);

    KeAcquireSpinLock(&RouteTableLock, &OldIrql);

    //
    // Search for an existing Site Prefix Entry.
    //
    for (PrevSPE = &SitePrefixTable; ; PrevSPE = &SPE->Next) {
        SPE = *PrevSPE;

        if (SPE == NULL) {
            //
            // No existing entry for this prefix.
            // Create an entry if the lifetime is non-zero.
            //
            if (ValidLifetime != 0) {

                SPE = ExAllocatePool(NonPagedPool, sizeof *SPE);
                if (SPE == NULL)
                    break;

                SPE->IF = IF;
                SPE->Prefix = Prefix;
                SPE->SitePrefixLength = SitePrefixLength;
                SPE->ValidLifetime = ValidLifetime;

                //
                // Add the new entry to the table.
                //
                SPE->Next = SitePrefixTable;
                SitePrefixTable = SPE;
            }
            break;
        }

        if ((SPE->IF == IF) &&
            IP6_ADDR_EQUAL(&SPE->Prefix, &Prefix) &&
            (SPE->SitePrefixLength == SitePrefixLength)) {
            //
            // We have an existing site prefix.
            // Remove the prefix if the new lifetime is zero,
            // otherwise update the prefix.
            //
            if (ValidLifetime == 0) {
                //
                // Remove the SPE from the list.
                // See similar code in SitePrefixTimeout.
                //
                *PrevSPE = SPE->Next;

                //
                // Release the SPE.
                //
                ExFreePool(SPE);
            }
            else {
                //
                // Pick up new attributes.
                //
                SPE->ValidLifetime = ValidLifetime;
            }
            break;
        }
    }

    KeReleaseSpinLock(&RouteTableLock, OldIrql);
}


//* SitePrefixMatch
//
//  Checks the destination address against
//  the prefixes in the Site Prefix Table.
//  If there is a match, returns the site identifier
//  associated with the matching prefix.
//  If there is no match, returns zero.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
uint
SitePrefixMatch(const IPv6Addr *Destination)
{
    SitePrefixEntry *SPE;
    KIRQL OldIrql;
    uint MatchingSite = 0;

    KeAcquireSpinLock(&RouteTableLock, &OldIrql);
    for (SPE = SitePrefixTable; SPE != NULL; SPE = SPE->Next) {
        //
        // Does this site prefix match the destination address?
        //
        if (HasPrefix(Destination, &SPE->Prefix, SPE->SitePrefixLength)) {
            //
            // We have found a matching site prefix.
            // No need to look further.
            //
            MatchingSite = SPE->IF->ZoneIndices[ADE_SITE_LOCAL];
            break;
        }
    }
    KeReleaseSpinLock(&RouteTableLock, OldIrql);

    return MatchingSite;
}


//* SitePrefixTimeout
//
//  Called periodically from IPv6Timeout.
//  Handles lifetime expiration of site prefixes.
//
void
SitePrefixTimeout(void)
{
    SitePrefixEntry *SPE, **PrevSPE;

    KeAcquireSpinLockAtDpcLevel(&RouteTableLock);

    PrevSPE = &SitePrefixTable;
    while ((SPE = *PrevSPE) != NULL) {

        if (SPE->ValidLifetime == 0) {
            //
            // Remove the SPE from the list.
            //
            *PrevSPE = SPE->Next;

            //
            // Release the SPE.
            //
            ExFreePool(SPE);
        }
        else {
            if (SPE->ValidLifetime != INFINITE_LIFETIME)
                SPE->ValidLifetime--;

            PrevSPE = &SPE->Next;
        }
    }

    KeReleaseSpinLockFromDpcLevel(&RouteTableLock);
}


//* ConfirmForwardReachability - tell ND that packets are getting through.
//
//  Upper layers call this routine upon receiving acknowledgements that
//  data sent by this node has arrived recently at the peer represented
//  by this RCE.  Such acknowledgements are considered to be proof of
//  forward reachability for the purposes of Neighbor Discovery.
//
//  Caller should be holding a reference on the RCE.
//  Callable from a thread or DPC context.
//
void
ConfirmForwardReachability(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE; // CareOfRCE, if any, for this route.
    NeighborCacheEntry *NCE;  // First-hop neighbor for this route.

    CareOfRCE = GetCareOfRCE(RCE);
    NCE = (CareOfRCE ? CareOfRCE : RCE)->NCE;

    NeighborCacheReachabilityConfirmation(NCE);

    if (CareOfRCE != NULL)
        ReleaseRCE(CareOfRCE);
}


//* ForwardReachabilityInDoubt - tell ND we're dubious.
//
//  Upper layers call this routine when they don't receive acknowledgements
//  which they'd otherwise expect if the peer represented by this RCE was
//  still reachable.  This calls into question whether the first-hop
//  might be the problem, so we tell ND that we're suspicious of its
//  reachable status.
//
//  Caller should be holding a reference on the RCE.
//  Callable from a thread or DPC context.
//
void
ForwardReachabilityInDoubt(RouteCacheEntry *RCE)
{
    RouteCacheEntry *CareOfRCE; // CareOfRCE, if any, for this route.
    NeighborCacheEntry *NCE;  // First-hop neighbor for this route.

    CareOfRCE = GetCareOfRCE(RCE);
    NCE = (CareOfRCE ? CareOfRCE : RCE)->NCE;

    NeighborCacheReachabilityInDoubt(NCE);

    if (CareOfRCE != NULL)
        ReleaseRCE(CareOfRCE);
}


//* GetPathMTUFromRCE - lookup MTU to use in sending on this route.
//
//  Get the PathMTU from an RCE.
//
//  Note that PathMTU is volatile unless the RouteCacheLock
//  is held. Furthermore the Interface's LinkMTU may have changed
//  since the RCE was created, due to a Router Advertisement.
//  (LinkMTU is always volatile.)
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
uint
GetPathMTUFromRCE(RouteCacheEntry *RCE)
{
    uint PathMTU, LinkMTU;
    KIRQL OldIrql;

    LinkMTU = RCE->NCE->IF->LinkMTU;
    PathMTU = RCE->PathMTU;

    //
    // We lazily check to see if it's time to probe for an increased Path
    // MTU as this is perceived to be cheaper than routinely running through
    // all our RCEs looking for one whose PMTU timer has expired.
    //
    if ((RCE->PMTULastSet != 0) &&
        ((uint)(IPv6TickCount - RCE->PMTULastSet) >= PATH_MTU_RETRY_TIME)) {
        //
        // It's been at least 10 minutes since we last lowered our PMTU
        // as the result of receiving a Path Too Big message.  Bump it
        // back up to the Link MTU to see if the path is larger now.
        //
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        PathMTU = RCE->PathMTU = LinkMTU;
        RCE->PMTULastSet = 0;
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    }

    //
    // We lazily check to see if our Link MTU has shrunk below our Path MTU,
    // as this is perceived to be cheaper than running through all our RCEs
    // looking for a too big Path MTU when a Link MTU shrinks.
    //
    // REVIEW: A contrarian might point out that Link MTUs rarely (if ever)
    // REVIEW: shrink, whereas we do this check on every packet sent.
    //
    if (PathMTU > LinkMTU) {
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        LinkMTU = RCE->NCE->IF->LinkMTU;
        PathMTU = RCE->PathMTU;
        if (PathMTU > LinkMTU) {
            PathMTU = RCE->PathMTU = LinkMTU;
            RCE->PMTULastSet = 0;
        }
        KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    }

    return PathMTU;
}


//* GetEffectivePathMTUFromRCE
//
//  Adjust the true path MTU to account for mobility and fragment headers.
//  Determines PMTU available to upper layer protocols.
//
//  Callable from a thread or DPC context.
//  Called with NO locks held.
//
uint
GetEffectivePathMTUFromRCE(RouteCacheEntry *RCE)
{
    uint PathMTU;
    RouteCacheEntry *CareOfRCE;

    CareOfRCE = GetCareOfRCE(RCE);
    PathMTU = GetPathMTUFromRCE(CareOfRCE ? CareOfRCE : RCE);

    if (PathMTU == 0) {
        //
        // We need to leave space for a fragment header in all
        // packets we send to this destination.
        //
        PathMTU = IPv6_MINIMUM_MTU - sizeof(FragmentHeader);
    }

    if (CareOfRCE != NULL) {
        //
        // Mobility is in effect for this destination.
        // Leave space for routing header.
        //
        PathMTU -= sizeof(IPv6RoutingHeader) + sizeof(IPv6Addr);
        ReleaseRCE(CareOfRCE);
    }

    return PathMTU;
}


//* UpdatePathMTU
//
//  Update the route cache with a new MTU obtained
//  from a Packet Too Big message.  Returns TRUE if this
//  update modified a PMTU value we had cached previously.
//
//  Callable from DPC context, not from thread context.
//  Called with NO locks held.
//
int
UpdatePathMTU(
    Interface *IF,
    const IPv6Addr *Dest,
    uint MTU)
{
    RouteCacheEntry *RCE;
    uint Now;
    int Changed = FALSE;

    KeAcquireSpinLockAtDpcLevel(&RouteCacheLock);

    //
    // Search the route cache for the appropriate RCE.
    // There will be at most one.
    //

    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = RCE->Next) {

        if (IP6_ADDR_EQUAL(&RCE->Destination, Dest) &&
            (RCE->NTE->IF == IF)) {

            //
            // Update the path MTU.
            // We never actually lower the path MTU below IPv6_MINIMUM_MTU.
            // If this is requested, we instead start including fragment
            // headers in all packets but we still use IPv6_MINIMUM_MTU.
            //
            if (MTU < RCE->PathMTU) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "UpdatePathMTU(RCE %p): new MTU %u for %s\n",
                           RCE, MTU, FormatV6Address(Dest)));
                if (MTU < IPv6_MINIMUM_MTU)
                    RCE->PathMTU = 0; // Always include fragment header.
                else
                    RCE->PathMTU = MTU;

                Changed = TRUE;

                //
                // Timestamp it (starting the timer).
                // A zero value means no timer, so don't use it.
                //
                Now = IPv6TickCount;
                if (Now == 0)
                    Now = 1;
                RCE->PMTULastSet = Now;
            }
            break;
        }
    }

    KeReleaseSpinLockFromDpcLevel(&RouteCacheLock);
    return Changed;
}


//* RedirectRouteCache
//
//  Update the route cache to reflect a Redirect message.
//
//  Callable from DPC context, not from thread context.
//  Called with NO locks held.
//
IP_STATUS  // Returns: IP_SUCCESS if redirect was legit, otherwise failure.
RedirectRouteCache(
    const IPv6Addr *Source,     // Source of the redirect.
    const IPv6Addr *Dest,       // Destination that is being redirected.
    Interface *IF,              // Interface that this all applies to.
    NeighborCacheEntry *NCE)    // New router for the destination.
{
    RouteCacheEntry *RCE;
    ushort DestScope;
    uint DestScopeId;
    IP_STATUS ReturnValue;
#if DBG
    char Buffer1[INET6_ADDRSTRLEN], Buffer2[INET6_ADDRSTRLEN];

    FormatV6AddressWorker(Buffer1, Dest);
    FormatV6AddressWorker(Buffer2, &NCE->NeighborAddress);
#endif

    //
    // Our caller guarantees this.
    //
    ASSERT(IF == NCE->IF);

    DestScope = AddressScope(Dest);
    DestScopeId = IF->ZoneIndices[DestScope];

    KeAcquireSpinLockAtDpcLevel(&RouteCacheLock);

    //
    // Get the current RCE for this destination.
    //
    ReturnValue = FindOrCreateRoute(Dest, DestScopeId, IF, &RCE);
    if (ReturnValue == IP_SUCCESS) {

        //
        // We must check that the source of the redirect
        // is the current next-hop neighbor.
        // (This is a simple sanity check - it does not
        // prevent clever neighbors from hijacking.)
        //
        if (!IP6_ADDR_EQUAL(&RCE->NCE->NeighborAddress, Source)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "RedirectRouteCache(dest %s -> %s): hijack from %s\n",
                       Buffer1, Buffer2, FormatV6Address(Source)));
            ReturnValue = IP_GENERAL_FAILURE;
        }
        else if (RCE->RefCnt == 2) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "RedirectRouteCache(dest %s -> %s): inplace %p\n",
                       Buffer1, Buffer2, RCE));
            //
            // There are no references to this RCE outside
            // of the cache, so we can update it in place.
            //
            ReleaseNCE(RCE->NCE);
            //
            // It's still OK to compare against RCE->NCE.
            //
            goto UpdateRCE;
        }
        else {
            RouteCacheEntry *NewRCE;

            //
            // Create a new route cache entry for the redirect.
            // CreateOrReuseRoute will not return RCE,
            // because we have an extra reference for it.
            //
            NewRCE = CreateOrReuseRoute();
            if (NewRCE != NULL) {
                ASSERT(NewRCE != RCE);
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                           "RedirectRouteCache(dest %s -> %s): old %p new %p\n",
                           Buffer1, Buffer2, RCE, NewRCE));

                //
                // Copy the RCE and fix up references.
                // We must copy the correct validation counter value.
                //
                *NewRCE = *RCE;
                NewRCE->RefCnt = 2; // One for the cache, one to release below.
                // We do not AddRefNCE(NewRCE->NCE), see below.
                AddRefNTE(NewRCE->NTE);

                //
                // Cause anyone who is using/caching the old RCE to notice
                // that it is no longer valid, so they will find the new RCE.
                // Then remove the old RCE from the cache.
                //
                RCE->Valid--; // RouteCacheValidationCounter increases.
                RemoveRCE(RCE);
                ReleaseRCE(RCE); // The cache's reference.
                ReleaseRCE(RCE); // Reference from FindOrCreateRoute.

                //
                // Add the new route cache entry to the cache.
                //
                InsertRCE(NewRCE);
                RCE = NewRCE;

              UpdateRCE:
                RCE->Type = RCE_TYPE_REDIRECT;

                if (RCE->NCE != NCE) {
                    //
                    // Reset PMTU discovery.
                    //
                    RCE->PathMTU = IF->LinkMTU;
                    RCE->PMTULastSet = 0;
                }

                //
                // At this point, RCE->NCE does NOT hold a reference.
                //
                AddRefNCE(NCE);
                RCE->NCE = NCE;
            }
            else {
                //
                // Could not allocate a new RCE.
                // REVIEW - Remove the old RCE from the cache?
                //
                ReturnValue = IP_NO_RESOURCES;
            }
        }

        //
        // Release our references.
        //
        ReleaseRCE(RCE);
    }

    KeReleaseSpinLockFromDpcLevel(&RouteCacheLock);
    return ReturnValue;
}


//* InitRouting - Initialize the routing module.
//
void
InitRouting(void)
{
    KeInitializeSpinLock(&RouteCacheLock);
    KeInitializeSpinLock(&RouteTableLock);

//  RouteCache.Limit initialized in ConfigureGlobalParameters.
    RouteCache.First = RouteCache.Last = SentinelRCE;

    RouteTable.First = NULL;
    RouteTable.Last = &RouteTable.First;

//  BindingCache.Limit initialized in ConfigureGlobalParameters.
    BindingCache.First = BindingCache.Last = SentinelBCE;

    InitializeListHead(&RouteNotifyQueue);
}


//* UnloadRouting
//
//  Called when IPv6 stack is unloading.
//
void
UnloadRouting(void)
{
    //
    // With all the interfaces destroyed,
    // there should be no routes left.
    //
    ASSERT(RouteTable.First == NULL);
    ASSERT(RouteTable.Last == &RouteTable.First);
    ASSERT(RouteCache.First == SentinelRCE);
    ASSERT(RouteCache.Last == SentinelRCE);
    ASSERT(BindingCache.First == SentinelBCE);
    ASSERT(BindingCache.Last == SentinelBCE);

    //
    // Irps hold references for our device object,
    // so pending notification requests prevent
    // us from unloading.
    //
    ASSERT(RouteNotifyQueue.Flink == RouteNotifyQueue.Blink);
}


//* InsertBCE
//
//  Insert the BCE in the binding cache.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
InsertBCE(BindingCacheEntry *BCE)
{
    BindingCacheEntry *AfterBCE = SentinelBCE;
    RouteCacheEntry *RCE;

    BCE->Prev = AfterBCE;
    (BCE->Next = AfterBCE->Next)->Prev = BCE;
    AfterBCE->Next = BCE;
    BindingCache.Count++;

    //
    // Update any existing RCEs to point to this BCE.
    //
    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = RCE->Next) {
        if (IP6_ADDR_EQUAL(&RCE->Destination, &BCE->HomeAddr))
            RCE->BCE = BCE;
    }
}


//* RemoveBCE
//
//  Remove the BCE from the binding cache.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
RemoveBCE(BindingCacheEntry *BCE)
{
    RouteCacheEntry *RCE;

    BCE->Prev->Next = BCE->Next;
    BCE->Next->Prev = BCE->Prev;
    BindingCache.Count--;

    //
    // Remove any references to this BCE from the route cache.
    //
    for (RCE = RouteCache.First; RCE != SentinelRCE; RCE = RCE->Next) {
        if (RCE->BCE == BCE)
            RCE->BCE = NULL;
    }
}


//* MoveToFrontBCE
//
//  Move an BCE to the front of the list.
//
//  Called with the route cache lock held.
//  Callable from a thread or DPC context.
//
void
MoveToFrontBCE(BindingCacheEntry *BCE)
{
    if (BCE->Prev != SentinelBCE) {
        BindingCacheEntry *AfterBCE = SentinelBCE;

        //
        // Remove the BCE from its current location.
        //
        BCE->Prev->Next = BCE->Next;
        BCE->Next->Prev = BCE->Prev;

        //
        // And put it at the front.
        //
        BCE->Prev = AfterBCE;
        (BCE->Next = AfterBCE->Next)->Prev = BCE;
        AfterBCE->Next = BCE;
    }
}


//* CreateBindingCacheEntry - create new BCE.
//
//  Allocates a new Binding Cache entry.
//  Returns NULL if a new BCE can not be allocated.
//
//  Must be called with the RouteCache lock held.
//
BindingCacheEntry *
CreateOrReuseBindingCacheEntry()
{
    BindingCacheEntry *BCE;

    if (BindingCache.Count >= BindingCache.Limit) {
        //
        // Reuse the BCE at the end of the list.
        //
        BCE = BindingCache.Last;
        RemoveBCE(BCE);
        ReleaseRCE(BCE->CareOfRCE);
    }
    else {
        //
        // Allocate a new BCE.
        //
        BCE = ExAllocatePool(NonPagedPool, sizeof *BCE);
    }

    return BCE;
}


//* DestroyBCE - remove an entry from the BindingCache.
//
//  Must be called with the RouteCache lock held.
//
void
DestroyBCE(BindingCacheEntry *BCE)
{
    //
    // Unchain the given BCE and destroy it.
    //
    RemoveBCE(BCE);
    ReleaseRCE(BCE->CareOfRCE);
    ExFreePool(BCE);
}


//* FindBindingCacheEntry
//
//  Looks for a binding cache entry with the specified care-of address.
//  Must be called with the route cache lock held.
//
BindingCacheEntry *
FindBindingCacheEntry(const IPv6Addr *HomeAddr)
{
    BindingCacheEntry *BCE;

    for (BCE = BindingCache.First; ; BCE = BCE->Next) {
        if (BCE == SentinelBCE) {
            //
            // Did not find a matching entry.
            //
            BCE = NULL;
            break;
        }

        if (IP6_ADDR_EQUAL(&BCE->HomeAddr, HomeAddr)) {
            //
            // Found a matching entry.
            //
            break;
        }
    }

    return BCE;
}


//* CacheBindingUpdate - update the binding cache entry for an address.
//
//  Find or Create (if necessary) an RCE to the CareOfAddress.  This routine
//  is called in response to a Binding Cache Update.
//
//  Callable from DPC context, not from thread context.
//  Called with NO locks held.
//
BindingUpdateDisposition  // Returns: Binding Ack Status code.
CacheBindingUpdate(
    IPv6BindingUpdateOption UNALIGNED *BindingUpdate,
    const IPv6Addr *CareOfAddr,              // Address to use for mobile node.
    NetTableEntryOrInterface *NTEorIF,       // NTE or IF receiving the BU.
    const IPv6Addr *HomeAddr)                // Mobile node's home address.
{
    BindingCacheEntry *BCE;
    BindingUpdateDisposition ReturnValue = IPV6_BINDING_ACCEPTED;
    IP_STATUS Status;
    int DeleteRequest;          // Request is to delete an existing binding?
    ushort SeqNo;
    RouteCacheEntry *CareOfRCE;
    ushort CareOfScope;
    uint CareOfScopeId;

    //
    // Note that we assume the care-of address is scoped
    // to the receiving interface, even when
    // the care-of address is present in a suboption
    // instead of the IPv6 source address field.
    //
    CareOfScope = AddressScope(CareOfAddr);
    CareOfScopeId = NTEorIF->IF->ZoneIndices[CareOfScope];

    //
    // Is this Binding Update a request to remove entries
    // from our binding cache?
    //
    DeleteRequest = ((BindingUpdate->Lifetime == 0) ||
                     IP6_ADDR_EQUAL(HomeAddr, CareOfAddr));

    SeqNo = net_short(BindingUpdate->SeqNumber);

    KeAcquireSpinLockAtDpcLevel(&RouteCacheLock);

    //
    // Search the binding cache for the home address.
    //
    for (BCE = BindingCache.First; BCE != SentinelBCE; BCE = BCE->Next) {

        if (!IP6_ADDR_EQUAL(&BCE->HomeAddr, HomeAddr))
            continue;

        //
        // We've found an existing entry for this home address.
        // Verify the sequence number is greater than the cached binding's
        // sequence number if there is one.
        //
        if ((short)(SeqNo - BCE->BindingSeqNumber) <= 0) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "CacheBindingUpdate: New sequence number too small "
                       "(old seqnum = %d, new seqnum = %d)\n",
                       BCE->BindingSeqNumber, SeqNo));
            ReturnValue = IPV6_BINDING_SEQ_NO_TOO_SMALL;
            goto Return;
        }

        //
        // If the request is to delete the entry, do so and return.
        //
        if (DeleteRequest) {
            DestroyBCE(BCE);
            goto Return;
        }

        //
        // Update the binding.
        //
        BCE->BindingLifetime =
            ConvertSecondsToTicks(net_long(BindingUpdate->Lifetime));
        BCE->BindingSeqNumber = SeqNo;

        CareOfRCE = BCE->CareOfRCE;

        //
        // If the care-of address or scope-id has changed,
        // then we need to create a new care-of RCE.
        //
        if (!IP6_ADDR_EQUAL(&CareOfRCE->Destination, CareOfAddr) ||
            (CareOfScopeId != CareOfRCE->NTE->IF->ZoneIndices[CareOfScope])) {
            RouteCacheEntry *NewRCE;

            //
            // Note that since we already hold the RouteCacheLock we
            // call FindOrCreateRoute here instead of RouteToDestination.
            //
            Status = FindOrCreateRoute(CareOfAddr, CareOfScopeId, NULL,
                                       &NewRCE);
            if (Status == IP_SUCCESS) {
                //
                // Update the binding cache entry.
                //
                ReleaseRCE(CareOfRCE);
                BCE->CareOfRCE = NewRCE;
            }
            else {
                //
                // Because we could not update the BCE,
                // destroy it.
                //
                DestroyBCE(BCE);
                if (Status == IP_NO_RESOURCES)
                    ReturnValue = IPV6_BINDING_NO_RESOURCES;
                else
                    ReturnValue = IPV6_BINDING_REJECTED;
            }
        }
        goto Return;
    }

    if (DeleteRequest) {
        //
        // We're done.
        //
        goto Return;
    }


    //
    // We want to cache a binding and did not find an existing binding
    // for the home address above.  So we create a new binding cache entry.
    //
    BCE = CreateOrReuseBindingCacheEntry();
    if (BCE == NULL) {
        ReturnValue = IPV6_BINDING_NO_RESOURCES;
        goto Return;
    }
    BCE->HomeAddr = *HomeAddr;
    BCE->BindingLifetime =
            ConvertSecondsToTicks(net_long(BindingUpdate->Lifetime));
    BCE->BindingSeqNumber = SeqNo;

    //
    // Now create a new RCE for the care-of address.
    // Note that since we already hold the RouteCacheLock we
    // call FindOrCreateRoute here instead of RouteToDestination.
    //
    Status = FindOrCreateRoute(CareOfAddr, CareOfScopeId, NULL,
                               &BCE->CareOfRCE);
    if (Status != IP_SUCCESS) {
        //
        // Couldn't get a route.
        //
        ExFreePool(BCE);
        if (Status == IP_NO_RESOURCES)
            ReturnValue = IPV6_BINDING_NO_RESOURCES;
        else
            ReturnValue = IPV6_BINDING_REJECTED;
    } else {
        //
        // Now that the BCE is fully initialized,
        // add it to the cache. This also updates existing RCEs.
        //
        InsertBCE(BCE);
    }

  Return:
    KeReleaseSpinLockFromDpcLevel(&RouteCacheLock);
    return ReturnValue;
}


//* BindingCacheTimeout
//
//  Check for and handle binding cache lifetime expirations.
//
//  Callable from DPC context, not from thread context.
//  Called with NO locks held.
//
void
BindingCacheTimeout(void)
{
    BindingCacheEntry *BCE, *NextBCE;

    KeAcquireSpinLockAtDpcLevel(&RouteCacheLock);

    //
    // Search the route cache for all binding cache entries. Update
    // their lifetimes, and remove if expired.
    //
    for (BCE = BindingCache.First; BCE != SentinelBCE; BCE = NextBCE) {
        NextBCE = BCE->Next;

        //
        // REVIEW: The mobile IPv6 spec allows correspondent nodes to
        // REVIEW: send a Binding Request when the current binding's
        // REVIEW: lifetime is "close to expiration" in order to prevent
        // REVIEW: the overhead of establishing a new binding after the
        // REVIEW: current one expires.  For now, we just let the binding
        // REVIEW: expire.
        //

        if (--BCE->BindingLifetime == 0) {
            //
            // This binding cache entry has expired.
            // Remove it from the Binding Cache.
            //
            DestroyBCE(BCE);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&RouteCacheLock);
}

//* RouterAdvertSend
//
//  Sends a Router Advertisement.
//  The advert is always sent to the all-nodes multicast address.
//  Chooses a valid source address for the interface.
//
//  Called with NO locks held.
//  Callable from DPC context, not from thread context.
//
//  REVIEW - Should this function be in route.c or neighbor.c? Or split up?
//
void
RouterAdvertSend(
    Interface *IF,              // Interface on which to send.
    const IPv6Addr *Source,     // Source address to use.
    const IPv6Addr *Dest)       // Destination address to use.
{
    NDIS_STATUS Status;
    NDIS_PACKET *Packet;
    NDIS_BUFFER *Buffer;
    uint PayloadLength;
    uint Offset;
    void *Mem, *MemLeft;
    uint MemLen, MemLenLeft;
    uint SourceOptionLength;
    IPv6Header UNALIGNED *IP;
    ICMPv6Header UNALIGNED *ICMP;
    NDRouterAdvertisement UNALIGNED *RA;
    void *SourceOption;
    NDOptionMTU UNALIGNED *MTUOption;
    void *LLDest;
    KIRQL OldIrql;
    int Forwards;
    uint LinkMTU;
    uint RouterLifetime;
    uint DefaultRoutePreference;
    RouteTableEntry *RTE;

    ICMPv6OutStats.icmps_msgs++;

    //
    // For consistency, capture some volatile
    // information in locals.
    //
    Forwards = IF->Flags & IF_FLAG_FORWARDS;
    LinkMTU = IF->LinkMTU;
    Offset = IF->LinkHeaderSize;

    //
    // Allocate a buffer for the advertisement.
    // We typically do not use the entire buffer,
    // but briefly allocating a large buffer is OK.
    //
    MemLen = Offset + LinkMTU;
    Mem = ExAllocatePool(NonPagedPool, MemLen);
    if (Mem == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "RouterAdvertSend - no memory?\n"));
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    //
    // Prepare IP header of the advertisement.
    // We fill in the PayloadLength later.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Mem + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_ICMPv6;
    IP->HopLimit = 255;
    IP->Source = *Source;
    IP->Dest = *Dest;

    //
    // Prepare ICMP header.
    //
    ICMP = (ICMPv6Header UNALIGNED *)(IP + 1);
    ICMP->Type = ICMPv6_ROUTER_ADVERT;
    ICMP->Code = 0;
    ICMP->Checksum = 0;

    //
    // Prepare the Router Advertisement header.
    // We fill in RouterLifetime and DefaultRoutePreference later.
    //
    RA = (NDRouterAdvertisement UNALIGNED *)(ICMP + 1);
    RtlZeroMemory(RA, sizeof *RA);
    MemLeft = (void *)(RA + 1);

    if (IF->WriteLLOpt != NULL) {
        //
        // Include source link-layer address option if ND is enabled.
        //
        SourceOption = MemLeft;
        SourceOptionLength = (IF->LinkAddressLength + 2 + 7) &~ 7;
        ((uchar *)SourceOption)[0] = ND_OPTION_SOURCE_LINK_LAYER_ADDRESS;
        ((uchar *)SourceOption)[1] = SourceOptionLength >> 3;
        (*IF->WriteLLOpt)(IF->LinkContext, SourceOption, IF->LinkAddress);
        MemLeft = (uchar *)SourceOption + SourceOptionLength;
    }

    //
    // Always include MTU option.
    //
    MTUOption = (NDOptionMTU UNALIGNED *)MemLeft;
    MTUOption->Type = ND_OPTION_MTU;
    MTUOption->Length = 1;
    MTUOption->Reserved = 0;
    MTUOption->MTU = net_long(LinkMTU);

    //
    // OK, how much space is left?
    //
    MemLeft = (void *)(MTUOption + 1);
    MemLenLeft = MemLen - (uint)((uchar *)MemLeft - (uchar *)Mem);

    //
    // Now we scan the routing table looking for published routes.
    // We incrementally add Prefix Information and Route Information options,
    // and we determine RouterLifetime and DefaultRoutePreference.
    //
    RouterLifetime = 0;
    DefaultRoutePreference = (uint) -1;

    KeAcquireSpinLock(&RouteTableLock, &OldIrql);
    for (RTE = RouteTable.First; RTE != NULL; RTE = RTE->Next) {
        //
        // We only advertise published routes.
        //
        if (RTE->Flags & RTE_FLAG_PUBLISH) {
            uint Life;  // In seconds.
            ushort PrefixScope = AddressScope(&RTE->Prefix);

            //
            // IoctlUpdateRouteTable guarantees this.
            //
            ASSERT(! IsLinkLocal(&RTE->Prefix));

            if (IsOnLinkRTE(RTE) && (RTE->IF == IF)) {
                NDOptionPrefixInformation UNALIGNED *Prefix;

                //
                // We generate a prefix-information option
                // with the L and possibly the A bits set.
                //

                if (MemLenLeft < sizeof *Prefix)
                    break; // No room for more options.
                Prefix = (NDOptionPrefixInformation *)MemLeft;
                (uchar *)MemLeft += sizeof *Prefix;
                MemLenLeft -= sizeof *Prefix;

                Prefix->Type = ND_OPTION_PREFIX_INFORMATION;
                Prefix->Length = 4;
                Prefix->PrefixLength = (uchar)RTE->PrefixLength;
                Prefix->Flags = ND_PREFIX_FLAG_ON_LINK;
                if (RTE->PrefixLength == 64)
                    Prefix->Flags |= ND_PREFIX_FLAG_AUTONOMOUS;
                Prefix->Reserved2 = 0;
                Prefix->Prefix = RTE->Prefix;

                //
                // Is this also a site prefix?
                // NB: The SitePrefixLength field overlaps Reserved2.
                //
                if (RTE->SitePrefixLength != 0) {
                    Prefix->Flags |= ND_PREFIX_FLAG_SITE_PREFIX;
                    Prefix->SitePrefixLength = (uchar)RTE->SitePrefixLength;
                }

                //
                // ConvertTicksToSeconds preserves the infinite value.
                //
                Life = net_long(ConvertTicksToSeconds(RTE->ValidLifetime));
                Prefix->ValidLifetime = Life;
                Life = net_long(ConvertTicksToSeconds(RTE->PreferredLifetime));
                Prefix->PreferredLifetime = Life;
            }
            else if (Forwards && (RTE->IF != IF) &&
                     (IF->ZoneIndices[PrefixScope] ==
                      RTE->IF->ZoneIndices[PrefixScope])) {
                //
                // We only advertise routes if we are forwarding
                // and if we won't forward out the same interface:
                // if such a router were published and used,
                // we'd generate a Redirect, but better to avoid
                // in the first place.
                // Also, we keep scoped routes within their zone.
                //
                if (RTE->PrefixLength == 0) {
                    //
                    // We don't explicitly advertise zero-length prefixes.
                    // Instead we advertise a non-zero router lifetime.
                    //
                    if (RTE->ValidLifetime > RouterLifetime)
                        RouterLifetime = RTE->ValidLifetime;
                    if (RTE->Preference < DefaultRoutePreference)
                        DefaultRoutePreference = RTE->Preference;
                }
                else {
                    NDOptionRouteInformation UNALIGNED *Route;
                    uint OptionSize;

                    //
                    // We generate a route-information option.
                    //

                    if (RTE->PrefixLength <= 64)
                        OptionSize = 16;
                    else
                        OptionSize = 24;

                    if (MemLenLeft < OptionSize)
                        break; // No room for more options.
                    Route = (NDOptionRouteInformation *)MemLeft;
                    (uchar *)MemLeft += OptionSize;
                    MemLenLeft -= OptionSize;

                    Route->Type = ND_OPTION_ROUTE_INFORMATION;
                    Route->Length = OptionSize >> 3;
                    Route->PrefixLength = (uchar)RTE->PrefixLength;
                    Route->Flags = EncodeRoutePreference(RTE->Preference);

                    RtlCopyMemory(&Route->Prefix, &RTE->Prefix,
                                  OptionSize - 8);

                    //
                    // ConvertTicksToSeconds preserves the infinite value.
                    //
                    Life = net_long(ConvertTicksToSeconds(RTE->ValidLifetime));
                    Route->RouteLifetime = Life;
                }
            }
        }
    }
    KeReleaseSpinLock(&RouteTableLock, OldIrql);

    if (RouterLifetime != 0) {
        //
        // We will be a default router. Calculate the 16-bit lifetime.
        // Note that there is no infinite value on the wire.
        //
        RouterLifetime = ConvertTicksToSeconds(RouterLifetime);
        if (RouterLifetime > 0xffff)
            RouterLifetime = 0xffff;
        RA->RouterLifetime = net_short((ushort)RouterLifetime);

        RA->Flags = EncodeRoutePreference(DefaultRoutePreference);
    }

    //
    // Calculate a payload length for the advertisement.
    //
    PayloadLength = (uint)((uchar *)MemLeft - (uchar *)ICMP);
    IP->PayloadLength = net_short((ushort)PayloadLength);

    //
    // Now allocate and initialize an NDIS packet and buffer.
    // This is much like IPv6AllocatePacket,
    // except we already have the memory.
    //

    NdisAllocatePacket(&Status, &Packet, IPv6PacketPool);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "RouterAdvertSend - couldn't allocate header!?!\n"));
        ExFreePool(Mem);
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    NdisAllocateBuffer(&Status, &Buffer, IPv6BufferPool,
                       Mem, Offset + sizeof(IPv6Header) + PayloadLength);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "RouterAdvertSend - couldn't allocate buffer!?!\n"));
        NdisFreePacket(Packet);
        ExFreePool(Mem);
        ICMPv6OutStats.icmps_errors++;
        return;
    }

    InitializeNdisPacket(Packet);
    PC(Packet)->CompletionHandler = IPv6PacketComplete;
    NdisChainBufferAtFront(Packet, Buffer);

    //
    // Calculate the ICMPv6 checksum.  It covers the entire ICMPv6 message
    // starting with the ICMPv6 header, plus the IPv6 pseudo-header.
    //
    ICMP->Checksum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest),
        IP_PROTOCOL_ICMPv6);
    ASSERT(ICMP->Checksum != 0);

    //
    // Calculate the link-layer destination address.
    // (The IPv6 destination is a multicast address.)
    // We prevent loopback of all ND packets.
    //
    LLDest = alloca(IF->LinkAddressLength);
    (*IF->ConvertAddr)(IF->LinkContext, AlignAddr(&IP->Dest), LLDest);
    PC(Packet)->Flags = NDIS_FLAGS_MULTICAST_PACKET | NDIS_FLAGS_DONT_LOOPBACK;

    //
    // Before we transmit the packet (and lose ownership of the memory),
    // make a pass over the packet, processing the options ourselves.
    // This is like receiving our own RA, except we do not create routes.
    // The options are well-formed of course.
    //
    Mem = (void *)(MTUOption + 1);
    while (Mem < MemLeft) {
        if (((uchar *)Mem)[0] == ND_OPTION_PREFIX_INFORMATION) {
            NDOptionPrefixInformation UNALIGNED *Prefix =
                (NDOptionPrefixInformation UNALIGNED *)Mem;
            uint ValidLifetime, PreferredLifetime;

            //
            // Because we just constructed the prefix-information options,
            // we know they are syntactically valid.
            //
            ValidLifetime = net_long(Prefix->ValidLifetime);
            ValidLifetime = ConvertSecondsToTicks(ValidLifetime);
            PreferredLifetime = net_long(Prefix->PreferredLifetime);
            PreferredLifetime = ConvertSecondsToTicks(PreferredLifetime);

            if ((IF->CreateToken != NULL) &&
                (Prefix->Flags & ND_PREFIX_FLAG_AUTONOMOUS)) {

                NetTableEntry *NTE;

                //
                // IoctlUpdateRouteTable only allows "proper" prefixes
                // to be published.
                //
                ASSERT(!IsLinkLocal(AlignAddr(&Prefix->Prefix)));
                ASSERT(!IsMulticast(AlignAddr(&Prefix->Prefix)));
                ASSERT(Prefix->PrefixLength == 64);

                //
                // Perform stateless address autoconfiguration for this prefix.
                //
                AddrConfUpdate(IF, AlignAddr(&Prefix->Prefix),
                               ValidLifetime, PreferredLifetime,
                               TRUE, // Authenticated.
                               &NTE);
                if (NTE != NULL) {
                    IPv6Addr NewAddr;
                    //
                    // Create the subnet anycast address for this prefix,
                    // if we created a corresponding unicast address.
                    //
                    CopyPrefix(&NewAddr, AlignAddr(&Prefix->Prefix), 64);
                    (void) FindOrCreateAAE(IF, &NewAddr, CastFromNTE(NTE));
                    ReleaseNTE(NTE);
                }
            }

            if (Prefix->Flags & ND_PREFIX_FLAG_SITE_PREFIX) {
                //
                // Again, IoctlUpdateRouteTable enforces sanity checks.
                //
                ASSERT(!IsSiteLocal(AlignAddr(&Prefix->Prefix)));
                ASSERT(Prefix->SitePrefixLength <= Prefix->PrefixLength);
                ASSERT(Prefix->SitePrefixLength != 0);

                SitePrefixUpdate(IF, AlignAddr(&Prefix->Prefix),
                                 Prefix->SitePrefixLength, ValidLifetime);
            }
        }

        (uchar *)Mem += ((uchar *)Mem)[1] << 3;
    }

    //
    // Transmit the packet.
    //
    ICMPv6OutStats.icmps_typecount[ICMPv6_ROUTER_ADVERT]++;
    IPv6SendLL(IF, Packet, Offset, LLDest);
}

//* GetBestRouteInfo
//
//  Calculates the best source address and outgoing interface
//  for the specified destination address.
//
IP_STATUS
GetBestRouteInfo(
    const IPv6Addr  *Addr,
    ulong            ScopeId,
    IP6RouteEntry   *Ire)
{
    IP_STATUS Status;
    RouteCacheEntry *RCE;
    Status = RouteToDestination(Addr, ScopeId,
                                NULL, 0, &RCE);
    if (Status != IP_SUCCESS) {
        return Status;
    }

    
    Ire->ire_Length    = sizeof(IP6RouteEntry);
    Ire->ire_Source    = RCE->NTE->Address;
    Ire->ire_ScopeId   = DetermineScopeId(&RCE->NTE->Address, RCE->NTE->IF);
    Ire->ire_IfIndex   = RCE->NTE->IF->Index;

    ReleaseRCE(RCE);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\prototab.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Protocol switch table for Internet Protocol Version 6.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"

//
// The Protocol Switch Table is an array of handlers, one for
// each possible value of the IPv6 Next Header field.
//
ProtocolSwitch ProtocolSwitchTable[MAX_IP_PROTOCOL + 1];


//* ProtoTabInit - Initialize the Protocol Switch Table.
//
//  Called during IPv6 initialization.
//
void
ProtoTabInit(void)
{
    //
    // Null entries will cause ICMP error messages to be sent for
    // the unknown header types.
    //
    RtlZeroMemory(ProtocolSwitchTable, sizeof(ProtocolSwitchTable));

    //
    // Define the fixed entries required by the IPv6 specification.
    // Other protocols must register with us via IPv6RegisterULProtocol.
    //
    // Note that HopByHopOptionsReceive is not here because
    // it gets special treatment in IPv6Receive.
    //
    ProtocolSwitchTable[IP_PROTOCOL_HOP_BY_HOP].ControlReceive =
        ExtHdrControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_V6].DataReceive = IPv6HeaderReceive;

    ProtocolSwitchTable[IP_PROTOCOL_ICMPv6].DataReceive = ICMPv6Receive;
    ProtocolSwitchTable[IP_PROTOCOL_ICMPv6].ControlReceive =
        ICMPv6ControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_FRAGMENT].DataReceive = FragmentReceive;
    ProtocolSwitchTable[IP_PROTOCOL_FRAGMENT].ControlReceive = 
        ExtHdrControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_DEST_OPTS].DataReceive = 
        DestinationOptionsReceive;
    ProtocolSwitchTable[IP_PROTOCOL_DEST_OPTS].ControlReceive = 
        ExtHdrControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_ROUTING].DataReceive = RoutingReceive;
    ProtocolSwitchTable[IP_PROTOCOL_ROUTING].ControlReceive = 
        ExtHdrControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_AH].DataReceive = 
        AuthenticationHeaderReceive;
    ProtocolSwitchTable[IP_PROTOCOL_AH].ControlReceive = ExtHdrControlReceive;

    ProtocolSwitchTable[IP_PROTOCOL_ESP].DataReceive = 
        EncapsulatingSecurityPayloadReceive;
    ProtocolSwitchTable[IP_PROTOCOL_ESP].ControlReceive = ExtHdrControlReceive;
}


//* IPv6RegisterULProtocol - Register an upper layer protocol with IPv6.
//
//  Higher protocols (e.g. TCP) call this to let IP know they're there.
//
//  This routine does not check whether or not a given protocol is already
//  registered, therefore it can also be used to unregister a protocol by
//  overwriting its entry.  This is considered a feature.
//
//  REVIEW: decide exactly what this should look like.
//
void
IPv6RegisterULProtocol(
    uchar Protocol,                     // Protocol below handlers refer to.
    ProtoRecvProc *RecvHandler,         // Routine to receive incoming packets.
    ProtoControlRecvProc *CtrlHandler)  // Routine to receive control packets.
{
    ASSERT(Protocol <= MAX_IP_PROTOCOL);

    ProtocolSwitchTable[Protocol].DataReceive = RecvHandler;
    ProtocolSwitchTable[Protocol].ControlReceive = CtrlHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\ntreg.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// NT registry helper function declarations.
//


#ifndef NTREG_INCLUDED
#define NTREG_INCLUDED 1

typedef enum {
    OpenRegKeyRead,
    OpenRegKeyCreate,
    OpenRegKeyDeleting
} OpenRegKeyAction;

NTSTATUS
OpenRegKey(PHANDLE HandlePtr, HANDLE Parent, const WCHAR *KeyName,
           OpenRegKeyAction Action);

NTSTATUS
RegDeleteValue(HANDLE KeyHandle, const WCHAR *ValueName);

NTSTATUS
GetRegDWORDValue(HANDLE KeyHandle, const WCHAR *ValueName, PULONG ValueData);

NTSTATUS
SetRegDWORDValue(HANDLE KeyHandle, const WCHAR *ValueName, ULONG ValueData);

NTSTATUS
SetRegQUADValue(HANDLE KeyHandle, const WCHAR *ValueName,
                const LARGE_INTEGER *ValueData);

NTSTATUS
GetRegIPAddrValue(HANDLE KeyHandle, const WCHAR *ValueName, IPAddr *Addr);

NTSTATUS
SetRegIPAddrValue(HANDLE KeyHandle, const WCHAR *ValueName, IPAddr Addr);

#if 0

NTSTATUS
GetRegStringValue(HANDLE KeyHandle, const WCHAR *ValueName,
                  PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
                  PUSHORT ValueSize);

NTSTATUS
GetRegSZValue(HANDLE KeyHandle, const WCHAR *ValueName,
              PUNICODE_STRING ValueData, PULONG ValueType);

NTSTATUS
GetRegMultiSZValue(HANDLE KeyHandle, const WCHAR *ValueName,
                   PUNICODE_STRING ValueData);

const WCHAR *
EnumRegMultiSz(IN const WCHAR *MszString, IN ULONG MszStringLength,
               IN ULONG StringIndex);

#endif // 0

VOID
InitRegDWORDParameter(HANDLE RegKey, const WCHAR *ValueName,
                      UINT *Value, UINT DefaultValue);

VOID
InitRegQUADParameter(HANDLE RegKey, const WCHAR *ValueName,
                     LARGE_INTEGER *Value);

extern NTSTATUS
OpenTopLevelRegKey(const WCHAR *Name,
                   OUT HANDLE *RegKey, OpenRegKeyAction Action);

extern NTSTATUS
DeleteTopLevelRegKey(const WCHAR *Name);

typedef NTSTATUS
(*EnumRegKeysCallback)(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName);

extern NTSTATUS
EnumRegKeyIndex(HANDLE RegKey, uint Index,
                EnumRegKeysCallback Callback, void *Context);

extern NTSTATUS
EnumRegKeys(HANDLE RegKey, EnumRegKeysCallback Callback, void *Context);

extern NTSTATUS
DeleteRegKey(HANDLE RegKey);

#endif  // NTREG_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\ntreg.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This source file contains the routines to access the NT Registry for
// configuration info.
//


#include <oscfg.h>
#include <ndis.h>
#include <ip6imp.h>
#include "ip6def.h"
#include <ntddip6.h>
#include <string.h>
#include <wchar.h>
#include "ntreg.h"

#define WORK_BUFFER_SIZE  512


#ifdef ALLOC_PRAGMA
//
// This code is pagable.
//
#pragma alloc_text(PAGE, GetRegDWORDValue)
#pragma alloc_text(PAGE, SetRegDWORDValue)
#pragma alloc_text(PAGE, InitRegDWORDParameter)
#pragma alloc_text(PAGE, OpenRegKey)
#if 0
#pragma alloc_text(PAGE, GetRegStringValue)
#pragma alloc_text(PAGE, GetRegSZValue)
#pragma alloc_text(PAGE, GetRegMultiSZValue)
#endif

#endif // ALLOC_PRAGMA

WCHAR Tcpip6Parameters[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" TCPIPV6_NAME L"\\Parameters";

//* OpenRegKey
//
//  Opens a Registry key and returns a handle to it.
//
//  Returns (plus other failure codes):
//      STATUS_OBJECT_NAME_NOT_FOUND
//      STATUS_SUCCESS
//
NTSTATUS
OpenRegKey(
    PHANDLE HandlePtr,  // Where to write the opened handle.
    HANDLE Parent,
    const WCHAR *KeyName,     // Name of Registry key to open.
    OpenRegKeyAction Action)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes, &UKeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               Parent, NULL);

    switch (Action) {
    case OpenRegKeyRead:
        Status = ZwOpenKey(HandlePtr, KEY_READ, &ObjectAttributes);
        break;

    case OpenRegKeyCreate:
        Status = ZwCreateKey(HandlePtr, KEY_WRITE, &ObjectAttributes,
                             0,         // TitleIndex
                             NULL,      // Class
                             REG_OPTION_NON_VOLATILE,
                             NULL);     // Disposition
        break;

    case OpenRegKeyDeleting:
        Status = ZwOpenKey(HandlePtr, KEY_ALL_ACCESS, &ObjectAttributes);
        break;

    default:
        ABORT();
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;
}


//* RegDeleteValue
//
//  Deletes a value from the key.
//
NTSTATUS
RegDeleteValue(
    HANDLE KeyHandle,
    const WCHAR *ValueName)
{
    NTSTATUS status;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);
    status = ZwDeleteValueKey(KeyHandle, &UValueName);
    return status;
}


//* GetRegDWORDValue
//
//  Reads a REG_DWORD value from the registry into the supplied variable.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
GetRegDWORDValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,  // Name of the value to read.
    PULONG ValueData)  // Variable into which to read the data.
{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));

    status = ZwQueryValueKey(KeyHandle, &UValueName, KeyValueFullInformation,
                             keyValueFullInformation, WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)
                           ((PCHAR)keyValueFullInformation +
                            keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


//* SetRegDWORDValue
//
//  Writes the contents of a variable to a REG_DWORD value.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
SetRegDWORDValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to write.
    const WCHAR *ValueName,  // Name of the value to write.
    ULONG ValueData)  // Variable from which to write the data.
{
    NTSTATUS status;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwSetValueKey(KeyHandle, &UValueName, 0, REG_DWORD,
                           &ValueData, sizeof ValueData);

    return status;
}


//* SetRegQUADValue
//
//  Writes the contents of a variable to a REG_BINARY value.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
SetRegQUADValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to write.
    const WCHAR *ValueName,  // Name of the value to write.
    const LARGE_INTEGER *ValueData)  // Variable from which to write the data.
{
    NTSTATUS status;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwSetValueKey(KeyHandle, &UValueName, 0, REG_BINARY,
                           (void *)ValueData, sizeof *ValueData);

    return status;
}


//* GetRegIPAddrValue
//
//  Reads a REG_SZ value from the registry into the supplied variable.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
GetRegIPAddrValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,  // Name of the value to read.
    IPAddr *Addr)  // Variable into which to read the data.
{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION info;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING UValueName;
    WCHAR *string;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    info = (PKEY_VALUE_PARTIAL_INFORMATION)keybuf;

    status = ZwQueryValueKey(KeyHandle, &UValueName,
                             KeyValuePartialInformation,
                             info, WORK_BUFFER_SIZE,
                             &resultLength);
    if (! NT_SUCCESS(status))
        return status;

    if (info->Type != REG_SZ)
        return STATUS_INVALID_PARAMETER_MIX;

    string = (WCHAR *)info->Data;

    if ((info->DataLength < sizeof(WCHAR)) ||
        (string[(info->DataLength/sizeof(WCHAR)) - 1] != UNICODE_NULL))
        return STATUS_INVALID_PARAMETER_MIX;

    if (! ParseV4Address(string, &string, Addr) ||
        (*string != UNICODE_NULL))
        return STATUS_INVALID_PARAMETER;

    return STATUS_SUCCESS;
}


//* SetRegIPAddrValue
//
//  Writes the contents of a variable to a REG_SZ value.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
SetRegIPAddrValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to write.
    const WCHAR *ValueName,  // Name of the value to write.
    IPAddr Addr)  // Variable from which to write the data.
{
    NTSTATUS status;
    UNICODE_STRING UValueName;
    char AddrStr[16];
    WCHAR ValueData[16];
    uint len;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    FormatV4AddressWorker(AddrStr, Addr);
    for (len = 0;; len++) {
        if ((ValueData[len] = (WCHAR)AddrStr[len]) == UNICODE_NULL)
            break;
    }

    status = ZwSetValueKey(KeyHandle, &UValueName, 0, REG_SZ,
                           ValueData, (len + 1) * sizeof(WCHAR));

    return status;
}


#if 0
//* GetRegStringValue
//
//  Reads a REG_*_SZ string value from the Registry into the supplied
//  key value buffer.  If the buffer string buffer is not large enough,
//  it is reallocated.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
GetRegStringValue(
    HANDLE KeyHandle,   // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,   // Name of the value to read.
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,  // Destination of read data.
    PUSHORT ValueSize)  // Size of the ValueData buffer.  Updated on output.
{
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(KeyHandle, &UValueName,
                             KeyValuePartialInformation, *ValueData,
                             (ULONG) *ValueSize, &resultLength);

    if ((status == STATUS_BUFFER_OVERFLOW) ||
        (status == STATUS_BUFFER_TOO_SMALL)) {
        PVOID temp;

        //
        // Free the old buffer and allocate a new one of the
        // appropriate size.
        //

        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {

            temp = ExAllocatePool(NonPagedPool, resultLength);

            if (temp != NULL) {

                if (*ValueData != NULL) {
                    ExFreePool(*ValueData);
                }

                *ValueData = temp;
                *ValueSize = (USHORT) resultLength;

                status = ZwQueryValueKey(KeyHandle, &UValueName,
                                         KeyValuePartialInformation,
                                         *ValueData, *ValueSize,
                                         &resultLength);

                ASSERT((status != STATUS_BUFFER_OVERFLOW) &&
                       (status != STATUS_BUFFER_TOO_SMALL));
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return status;
}
#endif // 0


#if 0
//* GetRegMultiSZValue
//
//  Reads a REG_MULTI_SZ string value from the Registry into the supplied
//  Unicode string.  If the Unicode string buffer is not large enough,
//  it is reallocated.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
GetRegMultiSZValue(
    HANDLE KeyHandle,           // Open handle to parent key of value to read.
    const WCHAR *ValueName,     // Name of value to read.
    PUNICODE_STRING ValueData)  // Destination string for the value data.
{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(KeyHandle, ValueName,
                               (PKEY_VALUE_PARTIAL_INFORMATION *)
                               &(ValueData->Buffer),
                               &(ValueData->MaximumLength));

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION) ValueData->Buffer;

        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {

            ValueData->Length = (USHORT)
                keyValuePartialInformation->DataLength;

            RtlCopyMemory(ValueData->Buffer,
                          &(keyValuePartialInformation->Data),
                          ValueData->Length);
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;

} // GetRegMultiSZValue
#endif // 0


#if 0
//* GetRegSZValue
//
//  Reads a REG_SZ string value from the Registry into the supplied
//  Unicode string.  If the Unicode string buffer is not large enough,
//  it is reallocated.
//
NTSTATUS  // Returns: STATUS_SUCCESS or an appropriate failure code.
GetRegSZValue(
    HANDLE KeyHandle,  // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,  // Name of the value to read.
    PUNICODE_STRING ValueData,  // Destination string for the value data.
    PULONG ValueType)  // On return, contains Registry type of value read.
{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = GetRegStringValue(KeyHandle, ValueName,
                               (PKEY_VALUE_PARTIAL_INFORMATION *)
                               &(ValueData->Buffer),
                               &(ValueData->MaximumLength));

    if (NT_SUCCESS(status)) {

        keyValuePartialInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueData->Buffer;

        if ((keyValuePartialInformation->Type == REG_SZ) ||
            (keyValuePartialInformation->Type == REG_EXPAND_SZ)) {
            WCHAR *src;
            WCHAR *dst;
            ULONG dataLength;

            *ValueType = keyValuePartialInformation->Type;
            dataLength = keyValuePartialInformation->DataLength;

            ASSERT(dataLength <= ValueData->MaximumLength);

            dst = ValueData->Buffer;
            src = (PWCHAR) &(keyValuePartialInformation->Data);

            while (ValueData->Length <= dataLength) {

                if ((*dst++ = *src++) == UNICODE_NULL) {
                    break;
                }

                ValueData->Length += sizeof(WCHAR);
            }

            if (ValueData->Length < (ValueData->MaximumLength - 1)) {
                ValueData->Buffer[ValueData->Length/sizeof(WCHAR)] =
                    UNICODE_NULL;
            }
        } else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;
}
#endif // 0


//* InitRegDWORDParameter
//
//  Reads a REG_DWORD parameter from the Registry into a variable.  If the
//  read fails, the variable is initialized to a default.
//
VOID
InitRegDWORDParameter(
    HANDLE RegKey,       // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,    // The name of the value to read.
    UINT *Value,         // Destination variable into which to read the data.
    UINT DefaultValue)   // Default to assign if the read fails.
{
    PAGED_CODE();

    if ((RegKey == NULL) ||
        !NT_SUCCESS(GetRegDWORDValue(RegKey, ValueName, (PULONG)Value))) {
        //
        // These registry parameters override the defaults, so their
        // absence is not an error.
        //
        *Value = DefaultValue;
    }
}


//* InitRegQUADParameter
//
//  Reads a REG_BINARY value from the registry into the supplied variable.
//
//  Upon failure, the variable is left untouched.
//
VOID
InitRegQUADParameter(
    HANDLE RegKey, // Open handle to the parent key of the value to read.
    const WCHAR *ValueName,  // Name of the value to read.
    LARGE_INTEGER *Value)    // Variable into which to read the data.
{
    NTSTATUS status;
    ULONG resultLength;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION value =
        (PKEY_VALUE_PARTIAL_INFORMATION) keybuf;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    if (RegKey == NULL)
        return;

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(RegKey, &UValueName,
                             KeyValuePartialInformation,
                             value, WORK_BUFFER_SIZE,
                             &resultLength);

    if (NT_SUCCESS(status) &&
        (value->Type == REG_BINARY) &&
        (value->DataLength == sizeof *Value)) {

        RtlCopyMemory(Value, value->Data, sizeof *Value);
    }
}


#if 0
//* EnumRegMultiSz
//
//  Parses a REG_MULTI_SZ string and returns the specified substring.
//
//  Note: This code is called at raised IRQL.  It is not pageable.
//    
const WCHAR *
EnumRegMultiSz(
    IN const WCHAR *MszString, // Pointer to the REG_MULTI_SZ string.
    IN ULONG MszStringLength,  // Length of above, including terminating null.
    IN ULONG StringIndex)      // Index number of substring to return.
{
    const WCHAR *string = MszString;

    if (MszStringLength < (2 * sizeof(WCHAR))) {
        return NULL;
    }

    //
    // Find the start of the desired string.
    //
    while (StringIndex) {

        while (MszStringLength >= sizeof(WCHAR)) {
            MszStringLength -= sizeof(WCHAR);

            if (*string++ == UNICODE_NULL) {
                break;
            }
        }

        //
        // Check for index out of range.
        //
        if (MszStringLength < (2 * sizeof(UNICODE_NULL))) {
            return NULL;
        }

        StringIndex--;
    }

    if (MszStringLength < (2 * sizeof(UNICODE_NULL))) {
        return NULL;
    }

    return string;
}
#endif // 0


//* OpenTopLevelRegKey
//
//  Given the name of a top-level registry key (under Parameters),
//  opens the registry key.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
OpenTopLevelRegKey(const WCHAR *Name,
                   OUT HANDLE *RegKey, OpenRegKeyAction Action)
{
    HANDLE ParametersKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenRegKey(&ParametersKey, NULL, Tcpip6Parameters,
                        OpenRegKeyRead);
    if (! NT_SUCCESS(Status))
        return Status;

    Status = OpenRegKey(RegKey, ParametersKey, Name, Action);
    ZwClose(ParametersKey);
    return Status;
}

//* DeleteTopLevelRegKey
//
//  Given the name of a top-level registry key (under Parameters),
//  deletes the registry key and all subkeys and values.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
DeleteTopLevelRegKey(const WCHAR *Name)
{
    HANDLE RegKey;
    NTSTATUS Status;

    Status = OpenTopLevelRegKey(Name, &RegKey, OpenRegKeyDeleting);
    if (! NT_SUCCESS(Status)) {
        //
        // If the registry key does not exist, that's OK.
        //
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            Status = STATUS_SUCCESS;
    }
    else {
        //
        // DeleteRegKey always closes the key.
        //
        Status = DeleteRegKey(RegKey);
    }

    return Status;
}


//* EnumRegKeyIndex
//
//  Enumerates the specified subkey of the registry key.
//  Calls the callback function on the subkey.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
EnumRegKeyIndex(
    HANDLE RegKey,
    uint Index,
    EnumRegKeysCallback Callback,
    void *Context)
{
    KEY_BASIC_INFORMATION *Info;
    uint InfoLength;
    uint ResultLength;
    NTSTATUS Status;

    PAGED_CODE();

#if DBG
    //
    // Start with no buffer, to exercise the retry code.
    //
    Info = NULL;
    InfoLength = 0;
#else
    //
    // Start with a decent-sized buffer.
    //
    ResultLength = WORK_BUFFER_SIZE;
    goto AllocBuffer;
#endif

    //
    // Get basic information about the subkey.
    //
    for (;;) {
        //
        // The documentation for ZwEnumerateKey says
        // that it returns STATUS_BUFFER_TOO_SMALL
        // to indicate that the buffer is too small
        // but it can also return STATUS_BUFFER_OVERFLOW.
        //
        Status = ZwEnumerateKey(RegKey, Index, KeyBasicInformation,
                                Info, InfoLength, (PULONG)&ResultLength);
        if (NT_SUCCESS(Status)) {
            break;
        }
        else if ((Status == STATUS_BUFFER_TOO_SMALL) ||
                 (Status == STATUS_BUFFER_OVERFLOW)) {
            //
            // We need a larger buffer.
            // Leave space for a null character at the end.
            //
#if DBG
            if (Info != NULL)
                ExFreePool(Info);
#else
            ExFreePool(Info);
        AllocBuffer:
#endif
            Info = ExAllocatePool(PagedPool, ResultLength+sizeof(WCHAR));
            if (Info == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto ErrorReturn;
            }
            InfoLength = ResultLength;
        }
        else
            goto ErrorReturn;
    }

    //
    // Null-terminate the name and call the callback function.
    //
    Info->Name[Info->NameLength/sizeof(WCHAR)] = UNICODE_NULL;
    Status = (*Callback)(Context, RegKey, Info->Name);

ErrorReturn:
    if (Info != NULL)
        ExFreePool(Info);
    return Status;
}


//* EnumRegKeys
//
//  Enumerate the subkeys of the specified registry key.
//  Calls the callback function for each subkey.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
EnumRegKeys(
    HANDLE RegKey,
    EnumRegKeysCallback Callback,
    void *Context)
{
    uint Index;
    NTSTATUS Status;

    PAGED_CODE();

    for (Index = 0;; Index++) {
        Status = EnumRegKeyIndex(RegKey, Index, Callback, Context);
        if (! NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES)
                Status = STATUS_SUCCESS;
            break;
        }
    }

    return Status;
}

#define MAX_DELETE_REGKEY_ATTEMPTS      10

typedef struct DeleteRegKeyContext {
    struct DeleteRegKeyContext *Next;
    HANDLE RegKey;
    uint Attempts;
} DeleteRegKeyContext;

//* DeleteRegKeyCallback
//
//  Opens a subkey of the parent and pushes a new record onto the list.
//
NTSTATUS
DeleteRegKeyCallback(
    void *Context,
    HANDLE ParentKey,
    WCHAR *SubKeyName)
{
    DeleteRegKeyContext **pList = (DeleteRegKeyContext **) Context;
    DeleteRegKeyContext *Record;
    HANDLE SubKey;
    NTSTATUS Status;

    PAGED_CODE();

    Status = OpenRegKey(&SubKey, ParentKey, SubKeyName, OpenRegKeyDeleting);
    if (! NT_SUCCESS(Status))
        return Status;

    Record = ExAllocatePool(PagedPool, sizeof *Record);
    if (Record == NULL) {
        ZwClose(SubKey);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Record->RegKey = SubKey;
    Record->Attempts = 0;
    Record->Next = *pList;
    *pList = Record;

    return STATUS_SUCCESS;
}

//* DeleteRegKey
//
//  Deletes a registry key and all subkeys.
//
//  Uses depth-first iterative traversal instead of recursion,
//  to avoid blowing out the kernel stack.
//
//  Always closes the supplied registry key, even upon failure.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
DeleteRegKey(HANDLE RegKey)
{
    DeleteRegKeyContext *List;
    DeleteRegKeyContext *This;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Start the iteration by creating a record for the parent key.
    //

    List = ExAllocatePool(PagedPool, sizeof *List);
    if (List == NULL) {
        ZwClose(RegKey);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorReturn;
    }

    List->Next = NULL;
    List->RegKey = RegKey;
    List->Attempts = 0;

    while ((This = List) != NULL) {
        //
        // Try to delete the key at the front of the list.
        //
        This->Attempts++;
        Status = ZwDeleteKey(This->RegKey);
        if (NT_SUCCESS(Status)) {
            //
            // Remove the key from the list and repeat.
            //
            List = This->Next;
            ZwClose(This->RegKey);
            ExFreePool(This);
            continue;
        }

        //
        // If the deletion failed for some reason
        // other than the presence of subkeys, stop now.
        //
        if (Status != STATUS_CANNOT_DELETE)
            goto ErrorReturn;

        //
        // Limit the number of attempts to delete a key,
        // to avoid an infinite loop. However we do want
        // to try more than once, in case there is concurrent
        // activity.
        //
        if (This->Attempts >= MAX_DELETE_REGKEY_ATTEMPTS)
            goto ErrorReturn;

        //
        // Enumerate the child keys, pushing them on the list
        // in front of the parent key.
        //
        Status = EnumRegKeys(This->RegKey, DeleteRegKeyCallback, &List);
        if (! NT_SUCCESS(Status))
            goto ErrorReturn;

        //
        // After the child keys are deleted, we will try again
        // to delete the parent key.
        //
    }

    return STATUS_SUCCESS;

ErrorReturn:
    //
    // Cleanup remaining records.
    //
    while ((This = List) != NULL) {
        List = This->Next;
        ZwClose(This->RegKey);
        ExFreePool(This);
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
               "DeleteRegKey(%p) failed %x\n", RegKey, Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\security.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// IP security routines for Internet Protocol Version 6.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "ipsec.h"
#include "security.h"
#include "alloca.h"


//
// Global Variables.
//
KSPIN_LOCK IPSecLock;
SecurityPolicy *SecurityPolicyList;
SecurityAssociation *SecurityAssociationList = NULL;
ulong SecurityStateValidationCounter;
uchar Zero[max(MAXUCHAR, MAX_RESULT_SIZE)] = {0};

SecurityAlgorithm AlgorithmTable[NUM_ALGORITHMS];

#ifdef IPSEC_DEBUG

void dump_encoded_mesg(uchar *buff, uint len)
{
    uint i, cnt = 0;
    uint bytes = 0;
    uint wrds = 0;
    uchar *buf = buff;

    for (i = 0; i < len; i++) {
        if (wrds == 0) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                       "&%02x:     ", cnt));
        }

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "%02x", *buf));
        buf++;
        bytes++;
        if (!(bytes % 4)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                       " "));
            bytes = 0;
        }
        wrds++;
        if (!(wrds % 16)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                       "\n"));
            wrds = 0;
            cnt += 16;
        }
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
               "\n"));
}

void DumpKey(uchar *buff, uint len)
{
    uint i;

    for (i = 0; i < len; i++) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "|%c", buff[i]));
    }
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
               "|\n"));
}
#endif


//* SPCheckAddr - Compare IP address in packet to IP address in policy.
//
//  SPAddrField specifies the type of comparison:
//  WILDCARD_VALUE, SINGLE_VALUE, or RANGE_VALUE.
//
int
SPCheckAddr(
    IPv6Addr *PacketAddr,
    uint SPAddrField,
    IPv6Addr *SPAddr,
    IPv6Addr *SPAddrData)
{
    int Result;

    switch (SPAddrField) {

    case WILDCARD_VALUE:
        //
        // Always a match since the address is don't care.
        //
        Result = TRUE;
        break;

    case SINGLE_VALUE:
        //
        // Check if the address of the packet matches the SP selector.
        //
        Result = IP6_ADDR_EQUAL(PacketAddr, SPAddr);
        break;

    case RANGE_VALUE:
        //
        // Check if the address is in the specified selector range.
        //
        Result = (IP6_ADDR_LTEQ(SPAddr, PacketAddr) &&
                  IP6_ADDR_LTEQ(PacketAddr, SPAddrData));
        break;

    default:
        //
        // Should never happen.
        //
        ABORTMSG("SPCheckAddr: invalid SPAddrField value");
        Result = FALSE;
    }

    return Result;
}


//* SPCheckPort - Compare port in packet to port in policy.
//
uint
SPCheckPort(
    ushort PacketPort,
    uint SPPortField,
    ushort SPPort,
    ushort SPPortData)
{
    uint Result = FALSE;

    switch (SPPortField) {

    case WILDCARD_VALUE:
        // Always a match since the port is don't care.
        Result = TRUE;
        break;

    case SINGLE_VALUE:
        // Check if the port of the packet matches the SP selector.
        if (PacketPort == SPPort) {
            Result = TRUE;
        }
        break;

    case RANGE_VALUE:
        // Check if port is between range.
        if (PacketPort >= SPPort && PacketPort <= SPPortData) {
            Result = TRUE;
        }
        break;

    default:
        //
        // Should never happen.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "SPCheckPort: invalid value for SPPortField (%u)\n",
                   SPPortField));
    }

    return Result;
}


//* ReleaseSA
//
//  Releases a reference to an SA.
//
void
ReleaseSA(SecurityAssociation *SA)
{
    if (InterlockedDecrement((PLONG)&SA->RefCnt) == 0) {
        //
        // No more references, so deallocate it.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                   "Freeing SA: %p\n", SA));
        RemoveSecurityAssociation(SA);
        ExFreePool(SA);
    }
}


//* DeleteSA - Invalidate a security association.
//
//  The SA is removed from the SA chain.  All pointers from the SA entry are
//  removed and the related reference counts decremented.  The SP pointers to
//  the SA can be removed; however, there could be references from the temp SA
//  holders used during IPSec traffic processing.
//
//  The temp SA references (IPSecProc and SALinkage) remove the references
//  when traffic processing is done.  The case can occur where the SA is
//  deleted but the temp SA holder still has a reference.  In that case,
//  the SA is not removed from the global list.
//
int
DeleteSA(
    SecurityAssociation *SA)
{
    SecurityAssociation *FirstSA, *PrevSA = NULL;
    uint Direction;

    //
    // Get the start of the SA Chain.
    //
    Direction = SA->DirectionFlag;

    if (Direction == INBOUND) {
        FirstSA = SA->SecPolicy->InboundSA;
    } else {
        FirstSA = SA->SecPolicy->OutboundSA;
    }

    //
    // Find the invalid SA and keep track of the SA before it.
    //
    while (FirstSA != SA) {
        PrevSA = FirstSA;
        if (PrevSA == NULL) {
            // This is a problem it should never happen.
            // REVIEW: Can we change this to an ASSERT?
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                       "DeleteSA: SA was not found\n"));
            return FALSE;
        }
        FirstSA = FirstSA->ChainedSecAssoc;
    }

    //
    // Remove the SA from the SA Chain.
    //
    // Check if the invalid SA is the First SA of the chain.
    if (PrevSA == NULL) {
        // The invalid SA is the first SA so the SP needs to be adjusted.
        if (Direction == INBOUND) {
            SA->SecPolicy->InboundSA = FirstSA->ChainedSecAssoc;
        } else {
            SA->SecPolicy->OutboundSA = FirstSA->ChainedSecAssoc;
        }
    } else {
        // Just a entry in the Chain.
        PrevSA->ChainedSecAssoc = FirstSA->ChainedSecAssoc;
    }

    // Decrement the reference count of the SP.
    SA->SecPolicy->RefCnt--;

    // Remove the reference to the SP.
    SA->SecPolicy = NULL;

    SA->Valid = SA_REMOVED;

    // Decrement the reference count of the SA.
    ReleaseSA(SA);

    InvalidateSecurityState();

    return TRUE;
}

//* RemoveSecurityPolicy
//
//  Remove a policy from the global list.
//  References are not held for the global list links.
//
void
RemoveSecurityPolicy(SecurityPolicy *SP)
{
    if (SP->Prev == NULL) {
        SecurityPolicyList = SP->Next;
    } else {
        SP->Prev->Next = SP->Next;
    }
    if (SP->Next != NULL) {
        SP->Next->Prev = SP->Prev;
    }
}


//* DeleteSP - Removes an SP entry from the kernel.
//
//  The removal of an SP makes all the SAs belonging to the SP invalid.
//  Unlike the SA removal, this removes every reference to the invalid SP.
//  Therefore, a check does not need to be made to ensure the SP is valid.
//
//  Called with the security lock held.
//
int
DeleteSP(
    SecurityPolicy *SP)
{
    //
    // Remove the SP's SAs.
    //
    while (SP->InboundSA != NULL) {
        if (!(DeleteSA(SP->InboundSA))) {
            return FALSE;
        }
    }
    while (SP->OutboundSA != NULL) {
        if (!(DeleteSA(SP->OutboundSA))) {
            return FALSE;
        }
    }

    //
    // Take it off the global list.
    //
    RemoveSecurityPolicy(SP);

    // Check if this is part of an SA bundle.
    if (SP->SABundle != NULL) {
        SecurityPolicy *PrevSABundle, *NextSABundle;

        //
        // The SP pointer being removed is a middle or first SABundle pointer.
        //
        PrevSABundle = SP->PrevSABundle;
        NextSABundle = SP->SABundle;
        NextSABundle->PrevSABundle = PrevSABundle;

        if (PrevSABundle == NULL) {
            // First SABundle pointer.
            NextSABundle->RefCnt--;
        } else {
            //
            // Clean up the SABundle deletion affects on other SP pointers.
            //
            while (PrevSABundle != NULL) {
                PrevSABundle->NestCount--;
                PrevSABundle->SABundle = NextSABundle;
                NextSABundle = PrevSABundle;
                PrevSABundle = PrevSABundle->PrevSABundle;
            }

            SP->RefCnt--;
        }

        SP->RefCnt--;
    }

    //
    // Check if anything else is referencing the invalid SP.
    // All the interfaces and SA references have been removed.
    // The only thing left are SABundle pointers.
    //
    if (SP->RefCnt != 0) {
        SecurityPolicy *PrevSABundle, *NextSABundle;

        //
        // The SP pointer being removed is the last of the bundle pointers.
        //
        PrevSABundle = SP->PrevSABundle;
        NextSABundle = SP->SABundle;

        ASSERT(PrevSABundle != NULL);
        ASSERT(NextSABundle == NULL);

        PrevSABundle->RefCnt--;

        //
        // Cleanup the SABundle deletion affects on other SP pointers.
        //
        while (PrevSABundle != NULL) {
            PrevSABundle->NestCount--;
            PrevSABundle->SABundle = NextSABundle;
            NextSABundle = PrevSABundle;
            PrevSABundle = PrevSABundle->PrevSABundle;
        }

        SP->RefCnt--;

        // Now the reference count better be zero.
        if (SP->RefCnt != 0) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                       "DeleteSP: The SP list is corrupt!\n"));
            return FALSE;
        }
    }

    // Free the memory.
    ExFreePool(SP);

    InvalidateSecurityState();

    return TRUE;
}

//* RemoveSecurityAssociation
//
//  Remove an association from the global list.
//  References are not held for the global list links.
//
void
RemoveSecurityAssociation(SecurityAssociation *SA)
{
    if (SA->Prev == NULL) {
        SecurityAssociationList = SA->Next;
    } else {
        SA->Prev->Next = SA->Next;
    }
    if (SA->Next != NULL) {
        SA->Next->Prev = SA->Prev;
    }
}


//* FreeIPSecToDo
//
void
FreeIPSecToDo(
    IPSecProc *IPSecToDo,
    uint Number)
{
    uint i;

    for (i = 0; i < Number; i++) {
        ReleaseSA(IPSecToDo[i].SA);
    }

    ExFreePool(IPSecToDo);
}


//* InboundSAFind - find a SA in the Security Association Database.
//
//  A Security Association on a receiving machine is uniquely identified
//  by the tuple of SPI, IP Destination, and security protocol.
//
//  REVIEW: Since we can choose our SPI's to be system-wide unique, we
//  REVIEW: could do the lookup solely via SPI and just verify the others.
//
//  REVIEW: Should we do our IP Destination lookup via ADE?  Faster.
//
SecurityAssociation *
InboundSAFind(
    ulong SPI,       // Security Parameter Index.
    IPv6Addr *Dest,  // Destination address.
    uint Protocol)   // Security protocol in use (e.g. AH or ESP).
{
    SecurityAssociation *SA;
    KIRQL OldIrql;

    // Get Security Lock.
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    // Start at the first SA entry.
    for (SA = SecurityAssociationList; SA != NULL; SA = SA->Next) {
        // Check SPI.
        if (SPI == SA->SPI) {
            // Check destination IP address and IPSec protocol.
            if (IP6_ADDR_EQUAL(Dest, &SA->SADestAddr) &&
                (Protocol == SA->IPSecProto)) {

                // Check direction.
                if (SA->DirectionFlag == INBOUND) {
                    // Check if the SA entry is valid.
                    if (SA->Valid == SA_VALID) {
                        AddRefSA(SA);
                        break;
                    }
                    // Not valid so continue checking.
                    continue;
                }
            }
        }
    }

    // Release lock.
    KeReleaseSpinLock(&IPSecLock, OldIrql);

    return SA;
}


//* InboundSALookup - Check the matched SP for a matching SA.
//
//  In the SABundle case, this function is called recursively to compare all
//  the SA entries.  Note, the selectors are not compared for SABundles.
//
uint
InboundSALookup(
    SecurityPolicy *SP,
    SALinkage *SAPerformed)
{
    SecurityAssociation *SA;
    uint Result = FALSE;

    for (SA = SP->InboundSA; SA != NULL; SA = SA->ChainedSecAssoc) {
        if (SA == SAPerformed->This && SA->DirectionFlag == INBOUND) {
            //
            // Check if the SP entry is a bundle.
            //
            if (SP->SABundle != NULL && SAPerformed->Next != NULL) {
                // Recursive call.
                if (InboundSALookup(SP->SABundle, SAPerformed->Next)) {
                    Result = TRUE;
                    break;
                }

            } else if (SP->SABundle == NULL && SAPerformed->Next == NULL) {
                // Found a match and no bundle to check.
                if (SA->Valid == SA_VALID) {
                    Result = TRUE;
                } else {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                               "InboundSALookup: Invalid SA\n"));
                }
                break;

            } else {
                // SAs in packet disagree with SABundle so no match.
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                           "InboundSALookup: SA seen disagrees with SA "
                           "in SABundle\n"));
                break;
            }
        }
    }

    return Result;
}


//* InboundSecurityCheck - IPSec processing verification.
//
//  This function is called from the transport layer.  The policy selectors
//  are compared with the packet to find a match.  The search continues
//  until there is a match.
//
//  The RFC says that the inbound SPD does not need to be ordered.
//  However if that is the case, then Bypass and discard mode couldn't
//  be used to quickly handle a packet.  Also since most of the SPs are
//  bidirectional, the SP entries are ordered.  We require the administrator
//  to order the policies.
//
int
InboundSecurityCheck(
    IPv6Packet *Packet,
    ushort TransportProtocol,
    ushort SourcePort,
    ushort DestPort,
    Interface *IF)
{
    SecurityPolicy *SP;
    int Result = FALSE;
    KIRQL OldIrql;

    //
    // Get IPSec lock then get interface lock.
    // REVIEW: Do we still need to grab the IF lock here?
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    for (SP = SecurityPolicyList; SP != NULL; SP = SP->Next) {
        // Check Interface.
        if ((SP->IFIndex != 0) && (SP->IFIndex != IF->Index))
            continue;

        // Check Direction of SP.
        if (!(SP->DirectionFlag == INBOUND ||
              SP->DirectionFlag == BIDIRECTIONAL)) {
            continue;
        }

        // Check Remote Address.
        if (!SPCheckAddr(AlignAddr(&Packet->IP->Source), SP->RemoteAddrField,
                         &SP->RemoteAddr, &SP->RemoteAddrData)) {
            continue;
        }

        // Check Local Address.
        if (!SPCheckAddr(AlignAddr(&Packet->IP->Dest), SP->LocalAddrField,
                         &SP->LocalAddr, &SP->LocalAddrData)) {
            continue;
        }

        // Check Transport Protocol.
        if (SP->TransportProto == NONE) {
            // None so protocol passed.

        } else {
            if (SP->TransportProto != TransportProtocol) {
                continue;
            } else {
                // Check Remote Port.
                if (!SPCheckPort(SourcePort, SP->RemotePortField,
                                 SP->RemotePort, SP->RemotePortData)) {
                    continue;
                }

                // Check Local Port.
                if (!SPCheckPort(DestPort, SP->LocalPortField,
                                 SP->LocalPort, SP->LocalPortData)) {
                    continue;
                }
            }
        }

        // Check if the packet should be dropped.
        if (SP->SecPolicyFlag == IPSEC_DISCARD) {
            //
            // Packet is dropped by transport layer.
            // This essentially denies traffic.
            //
            break;
        }

        // Check if packet bypassed IPSec processing.
        if (Packet->SAPerformed == NULL) {
            //
            // Check if this is bypass mode.
            //
            if (SP->SecPolicyFlag == IPSEC_BYPASS) {
                // Packet is okay to be processed by transport layer.
                Result = TRUE;
                break;
            }
            // Check other policies, may change this to dropping later.
            continue;
        }

        //
        // Getting here means the packet saw an SA.
        //

        // Check IPSec mode.
        if (SP->IPSecSpec.Mode != Packet->SAPerformed->Mode) {
            //
            // Wrong mode for this traffic drop packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "InboundSecurityCheck: Wrong IPSec mode for traffic "
                       "Policy #%d\n", SP->Index));
            break;
        }

        // Check SA pointer.
        if (!InboundSALookup(SP, Packet->SAPerformed)) {
            //
            // SA lookup failed.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "InboundSecurityCheck: SA lookup failed Policy #%d\n",
                       SP->Index));
            break;
        }

        // Successful verification of IPSec.
        Result = TRUE;
        break;
    }

    // Release locks.
    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
    KeReleaseSpinLock(&IPSecLock, OldIrql);

    return Result;
}


//* OutboundSALookup - Find a SA for the matching SP.
//
//  This function is called after an SP match is found.  The SAs associated
//  with the SP are searched for a match.  If match is found, a check to see
//  if the SP contains a bundle is done.  A bundle causes a similar lookup.
//  If any of the bundle SAs are not found, the lookup is a failure.
//
IPSecProc *
OutboundSALookup(
    IPv6Addr *SourceAddr,
    IPv6Addr *DestAddr,
    ushort TransportProtocol,
    ushort DestPort,
    ushort SourcePort,
    SecurityPolicy *SP,
    uint *Action)
{
    SecurityAssociation *SA;
    uint i;
    uint BundleCount = 0;
    IPSecProc *IPSecToDo = NULL;

    *Action = LOOKUP_DROP;

    //
    // Find the SA entry associated with the found SP entry.
    // If there is a bundle, a subsequent search finds the bundled SAs.
    //
    for (SA = SP->OutboundSA; SA != NULL; SA = SA->ChainedSecAssoc) {
        if (SP->RemoteAddrSelector == PACKET_SELECTOR) {
            // Check Remote Address.
            if (!IP6_ADDR_EQUAL(DestAddr, &SA->DestAddr)) {
                continue;
            }
        }

        if (SP->LocalAddrSelector == PACKET_SELECTOR) {
            // Check Remote Address.
            if (!IP6_ADDR_EQUAL(SourceAddr, &SA->SrcAddr)) {
                continue;
            }
        }

        if (SP->RemotePortSelector == PACKET_SELECTOR) {
            if (DestPort != SA->DestPort) {
                continue;
            }
        }

        if (SP->LocalPortSelector == PACKET_SELECTOR) {
            if (SourcePort != SA->SrcPort) {
                continue;
            }
        }

        if (SP->TransportProtoSelector == PACKET_SELECTOR) {
            if (TransportProtocol != SA->TransportProto) {
                continue;
            }
        }

        // Check if the SA is valid.
        if (SA->Valid != SA_VALID) {
            // SA is invalid continue checking.
            continue;
        }

        //
        // Match found.
        //
#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Send using SP->Index=%d, SA->Index=%d\n",
                   SP->Index, SA->Index));
#endif
        BundleCount = SP->NestCount;

        // Allocate the IPSecToDo array.
        IPSecToDo = ExAllocatePool(NonPagedPool,
                                   (sizeof *IPSecToDo) * BundleCount);
        if (IPSecToDo == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "OutboundSALookup: "
                       "Couldn't allocate memory for IPSecToDo!?!\n"));
            return NULL;
        }

        //
        // Fill in IPSecToDo first entry.
        //
        IPSecToDo[0].SA = SA;
        AddRefSA(SA);
        IPSecToDo[0].Mode = SP->IPSecSpec.Mode;
        IPSecToDo[0].BundleSize = SP->NestCount;
        *Action = LOOKUP_CONT;
        break;
    } // end of for (SA = SP->OutboundSA; ...)

    // Check if there is a bundled SA.
    for (i = 1; i < BundleCount; i++) {
        *Action = LOOKUP_DROP;

        // Check to make sure the bundle pointer is not null (safety check).
        if (SP->SABundle == NULL) {
            // This is bad so exit loop.
            // Free IPSecToDo memory.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "OutboundSALookup: SP entry %d SABundle pointer is "
                       "NULL\n", SP->Index));
            FreeIPSecToDo(IPSecToDo, i);
            break;
        }

        SP = SP->SABundle;

        // Search through the SAs for this SP.
        for (SA = SP->OutboundSA; SA != NULL; SA = SA->ChainedSecAssoc) {
            if (SP->RemoteAddrSelector == PACKET_SELECTOR) {
                // Check Remote Address.
                if (!IP6_ADDR_EQUAL(DestAddr, &SA->DestAddr)) {
                    continue;
                }
            }

            if (SP->LocalAddrSelector == PACKET_SELECTOR) {
                // Check Remote Address.
                if (!IP6_ADDR_EQUAL(SourceAddr, &SA->SrcAddr)) {
                    continue;
                }
            }

            if (SP->RemotePortSelector == PACKET_SELECTOR) {
                if (DestPort != SA->DestPort) {
                    continue;
                }
            }

            if (SP->LocalPortSelector == PACKET_SELECTOR) {
                if (SourcePort != SA->SrcPort) {
                    continue;
                }
            }

            if (SP->TransportProtoSelector == PACKET_SELECTOR) {
                if (TransportProtocol != SA->TransportProto) {
                    continue;
                }
            }

            // Check if the SA is valid.
            if (SA->Valid != SA_VALID) {
                // SA is invalid continue checking.
                continue;
            }

            //
            // Match found.
            //

#ifdef IPSEC_DEBUG
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                       "Send using SP->Index=%d, SA->Index=%d\n",
                       SP->Index, SA->Index));
#endif
            //
            // Fill in IPSecToDo entry.
            //
            IPSecToDo[i].SA = SA;
            AddRefSA(SA);
            IPSecToDo[i].Mode = SP->IPSecSp