6,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Black ColorAdjustTable (256 bytes) */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  1,  1,  2,  3,  4,  5,  6,  8,  9, 11, 13,
  15, 18, 20, 23, 25, 28, 31, 34, 38, 41, 45, 48, 52, 56, 60, 64,
  69, 73, 77, 82, 87, 91, 96,101,106,111,116,121,126,131,136,141,
 146,151,156,161,166,170,175,180,185,189,194,198,202,206,211,214,
 218,222,225,229,232,235,238,240,243,245,247,249,251,253,254,255}
};


static unsigned char VD_DitherTable[4][40][40] =
{
/****************************************************/
/*             Start DitherTable             */
/****************************************************/
 {  /* Yellow DitherTable (144 byte ) */
  { 81,113,129, 93,125,141, 84,116,132, 96,128,144},
  { 33, 49, 97, 45, 61,109, 36, 52,100, 48, 64,112},
  {  1, 17, 65, 13, 29, 77,  4, 20, 68, 16, 32, 80},
  { 89,121,137, 85,117,133, 92,124,140, 88,120,136},
  { 41, 57,105, 37, 53,101, 44, 60,108, 40, 56,104},
  {  9, 25, 73,  5, 21, 69, 12, 28, 76,  8, 24, 72},
  { 83,115,131, 95,127,143, 82,114,130, 94,126,142},
  { 35, 51, 99, 47, 63,111, 34, 50, 98, 46, 62,110},
  {  3, 19, 67, 15, 31, 79,  2, 18, 66, 14, 30, 78},
  { 91,123,139, 87,119,135, 90,122,138, 86,118,134},
  { 43, 59,107, 39, 55,103, 42, 58,106, 38, 54,102},
  { 11, 27, 75,  7, 23, 71, 10, 26, 74,  6, 22, 70}
 },

 {  /* Cyan DitherTable (1600 bytes) */
  { 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36},
  { 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24},
  {  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50},
  { 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39},
  { 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27},
  { 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9},
  { 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41},
  { 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29},
  { 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17},
  { 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47},
  { 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35},
  { 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23},
  {  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49},
  { 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40},
  { 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28},
  { 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13},
  { 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42},
  { 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30},
  { 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18},
  { 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48},
  { 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36},
  { 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24},
  {  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50},
  { 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39},
  { 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27},
  { 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10},
  { 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41},
  { 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29},
  { 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17},
  { 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47},
  { 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35},
  { 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23},
  {  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49},
  { 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40},
  { 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28},
  { 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14},
  { 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42},
  { 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30},
  { 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18},
  { 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48}
 },

 {  /* Magenta DitherTable (1600 bytes) */
  { 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46},
  { 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20},
  { 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32},
  { 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44},
  { 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8},
  { 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26},
  { 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38},
  { 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52},
  { 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24},
  { 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36},
  { 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45},
  { 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19},
  { 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31},
  { 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43},
  { 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4},
  { 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25},
  { 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37},
  { 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51},
  { 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23},
  { 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35},
  { 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46},
  { 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20},
  { 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32},
  { 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44},
  { 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7},
  { 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26},
  { 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38},
  { 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52},
  { 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24},
  { 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36},
  { 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45},
  { 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19},
  { 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31},
  { 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43},
  { 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3},
  { 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25},
  { 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37},
  { 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51},
  { 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23},
  { 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35}
 },

 {  /* Black DitherTable (576 bytes) */
  { 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36},
  { 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60},
  {  1, 17, 29, 65, 73, 81,  9, 20, 32, 68, 76, 84,  2, 17, 29, 65, 73, 81, 10, 20, 32, 68, 76, 84},
  { 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79},
  { 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55},
  { 67, 75, 83, 13, 18, 30, 66, 74, 82,  6, 19, 31, 67, 75, 83, 14, 18, 30, 66, 74, 82,  5, 19, 31},
  { 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33},
  { 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57},
  { 12, 20, 32, 68, 76, 84,  3, 17, 29, 65, 73, 81, 11, 20, 32, 68, 76, 84,  4, 17, 29, 65, 73, 81},
  { 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78},
  { 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54},
  { 66, 74, 82,  7, 19, 31, 67, 75, 83, 15, 18, 30, 66, 74, 82,  8, 19, 31, 67, 75, 83, 16, 18, 30},
  { 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36},
  { 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60},
  {  2, 17, 29, 65, 73, 81, 10, 20, 32, 68, 76, 84,  1, 17, 29, 65, 73, 81,  9, 20, 32, 68, 76, 84},
  { 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79},
  { 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55},
  { 67, 75, 83, 14, 18, 30, 66, 74, 82,  5, 19, 31, 67, 75, 83, 13, 18, 30, 66, 74, 82,  6, 19, 31},
  { 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33},
  { 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57},
  { 11, 20, 32, 68, 76, 84,  4, 17, 29, 65, 73, 81, 12, 20, 32, 68, 76, 84,  3, 17, 29, 65, 73, 81},
  { 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78},
  { 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54},
  { 66, 74, 82,  8, 19, 31, 67, 75, 83, 16, 18, 30, 66, 74, 82,  7, 19, 31, 67, 75, 83, 15, 18, 30}
 }
};


static short VD_ExpandValueTable[4][256] =
{
/********************************************/
/*      Start ExpandValueTable       */
/********************************************/
 {  /* Yellow ExpandValueTable (256 words) */
   0,   2,   3,   5,   6,   8,   9,  11,  12,  14,  15,  17,  20,  22,  25,  27,
  30,  32,  35,  37,  40,  42,  45,  47,  49,  52,  54,  57,  59,  62,  64,  67,
  69,  72,  74,  77,  79,  82,  84,  87,  89,  92,  94,  97,  99, 102, 104, 106,
 109, 111, 115, 119, 122, 126, 130, 134, 137, 141, 145, 149, 152, 156, 160, 163,
 167, 171, 175, 178, 182, 186, 190, 193, 197, 201, 205, 208, 212, 216, 220, 223,
 227, 231, 234, 238, 242, 246, 250, 254, 258, 262, 266, 269, 273, 277, 281, 285,
 289, 293, 297, 301, 305, 309, 313, 316, 320, 324, 328, 332, 336, 340, 344, 348,
 352, 356, 360, 363, 367, 371, 375, 379, 383, 387, 391, 395, 399, 403, 407, 410,
 414, 418, 422, 426, 430, 434, 438, 442, 446, 450, 454, 457, 461, 465, 469, 473,
 477, 481, 487, 492, 497, 503, 508, 513, 518, 524, 529, 534, 540, 545, 550, 555,
 561, 566, 571, 577, 590, 602, 614, 626, 639, 651, 659, 663, 667, 672, 676, 680,
 684, 688, 690, 692, 693, 695, 697, 699, 700, 702, 704, 705, 707, 709, 710, 712,
 714, 716, 717, 719, 721, 722, 724, 726, 727, 729, 731, 733, 734, 736, 738, 739,
 741, 743, 745, 746, 748, 750, 751, 754, 756, 759, 762, 764, 767, 770, 772, 775,
 778, 780, 783, 786, 788, 791, 794, 796, 799, 802, 804, 807, 810, 812, 815, 818,
 820, 823, 826, 828, 831, 846, 867, 888, 908, 927, 946, 963, 974, 985, 997,1008},

 {  /* Cyan ExpandValueTable (256 words) */
   0,   1,   2,   3,   3,   4,   5,   6,   7,   8,   9,   9,  10,  11,  12,  13,
  14,  14,  15,  17,  21,  24,  28,  32,  36,  40,  43,  47,  51,  55,  59,  62,
  66,  70,  74,  78,  81,  85,  89,  93,  96, 100, 104, 108, 112, 115, 119, 123,
 127, 131, 134, 138, 142, 146, 150, 153, 157, 161, 165, 169, 172, 176, 180, 184,
 188, 191, 195, 199, 203, 207, 211, 215, 219, 224, 225, 226, 227, 228, 229, 230,
 231, 232, 233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
 248, 249, 250, 251, 252, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264,
 265, 266, 267, 269, 271, 273, 275, 278, 280, 282, 284, 286, 287, 288, 289, 291,
 292, 293, 295, 296, 297, 298, 300, 301, 302, 304, 305, 306, 307, 309, 310, 311,
 313, 314, 316, 317, 319, 320, 322, 323, 325, 326, 328, 329, 331, 332, 334, 335,
 337, 338, 340, 341, 343, 344, 346, 347, 349, 351, 353, 355, 356, 358, 359, 360,
 361, 362, 363, 364, 365, 366, 367, 368, 370, 371, 372, 373, 374, 375, 376, 377,
 378, 379, 380, 381, 382, 383, 384, 386, 387, 388, 389, 390, 391, 392, 393, 393,
 394, 395, 396, 396, 397, 398, 399, 399, 400, 401, 402, 402, 403, 404, 406, 408,
 410, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 425, 426, 427,
 428, 429, 430, 431, 432, 434, 437, 440, 443, 445, 448, 451, 454, 457, 461, 468},

 {  /* Magenta ExpandValueTable (256 words) */
   0,   1,   2,   4,   5,   6,   7,   8,   9,  11,  12,  13,  14,  15,  18,  22,
  26,  31,  35,  39,  44,  48,  52,  56,  61,  65,  69,  74,  78,  82,  86,  91,
  95,  99, 104, 108, 112, 117, 121, 125, 129, 134, 138, 142, 147, 151, 155, 160,
 164, 168, 172, 177, 181, 185, 190, 194, 198, 202, 207, 211, 215, 219, 223, 225,
 226, 227, 228, 229, 230, 231, 232, 233, 235, 236, 237, 238, 239, 240, 241, 242,
 243, 244, 245, 246, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259,
 260, 262, 263, 264, 265, 266, 267, 268, 271, 274, 276, 279, 282, 284, 286, 287,
 289, 290, 291, 293, 294, 296, 297, 298, 300, 301, 302, 304, 305, 307, 308, 309,
 311, 313, 317, 321, 322, 324, 325, 327, 328, 330, 332, 333, 335, 336, 338, 340,
 341, 343, 344, 346, 347, 351, 354, 358, 360, 362, 363, 364, 365, 366, 367, 368,
 369, 370, 371, 372, 373, 374, 376, 378, 383, 385, 385, 386, 387, 388, 389, 390,
 390, 391, 392, 393, 394, 394, 395, 396, 397, 398, 399, 399, 400, 401, 402, 403,
 403, 405, 408, 409, 410, 411, 411, 412, 413, 414, 415, 416, 416, 417, 418, 419,
 420, 421, 421, 422, 423, 424, 425, 426, 427, 427, 428, 429, 430, 431, 432, 432,
 433, 433, 434, 434, 435, 435, 436, 437, 439, 441, 442, 444, 446, 448, 449, 451,
 452, 453, 453, 454, 454, 455, 455, 456, 457, 458, 460, 461, 463, 465, 466, 468},

 {  /* Black ExpandValueTable (256 words) */
   0,   2,   3,   5,   6,   8,   9,  11,  12,  14,  15,  20,  28,  36,  44,  52,
  60,  68,  76,  84,  92,  97,  99, 102, 104, 106, 108, 111, 113, 115, 117, 120,
 122, 125, 133, 142, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
 172, 174, 176, 178, 180, 182, 184, 188, 191, 194, 197, 200, 202, 203, 205, 207,
 208, 210, 211, 213, 215, 216, 218, 220, 221, 223, 225, 228, 230, 233, 235, 238,
 241, 246, 251, 256, 257, 259, 260, 262, 263, 264, 265, 266, 266, 267, 267, 268,
 269, 269, 270, 270, 271, 272, 272, 274, 275, 277, 278, 279, 281, 282, 283, 285,
 286, 287, 289, 290, 291, 294, 296, 299, 301, 304, 305, 305, 306, 306, 307, 307,
 308, 309, 309, 310, 310, 311, 312, 312, 314, 316, 317, 319, 321, 322, 324, 326,
 328, 329, 331, 332, 334, 335, 336, 337, 338, 339, 341, 342, 343, 344, 345, 346,
 347, 348, 349, 351, 352, 353, 354, 355, 356, 361, 362, 363, 364, 365, 367, 368,
 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 382, 383, 385, 387,
 388, 388, 388, 388, 389, 389, 389, 389, 389, 389, 389, 389, 390, 390, 390, 390,
 390, 390, 390, 390, 391, 391, 391, 391, 391, 391, 391, 391, 392, 392, 392, 392,
 392, 392, 392, 393, 393, 393, 393, 393, 394, 394, 394, 394, 394, 394, 395, 395,
 395, 395, 395, 395, 396, 396, 396, 396, 397, 397, 398, 398, 399, 399, 400, 404}
};

typedef struct {
        unsigned char base;
        unsigned char offset;
        } ToneOptimaizeTable;

static ToneOptimaizeTable VD_ToneOptimaizeTable[4][232] =
{
/***************************************************/
/*         Start ToneOptimaizeTabl         */
/***************************************************/
 {  /* Yellow ToneOptimaizeTabl (464 bytes)	*/
  { 0, 0},
  { 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 8},{ 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 1},{ 6, 2},{ 6, 3},{ 6, 4},{ 6, 5},{ 6, 6},{ 6, 7},{ 6, 8},{ 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 1},{ 7, 2},{ 7, 3},{ 7, 4},{ 7, 5},{ 7, 6},{ 7, 7},{ 7, 8},{ 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8, 1},{ 8, 2},{ 8, 3},{ 8, 4},{ 8, 5},{ 8, 6},{ 8, 7},{ 8, 8},{ 8, 9},{ 8,10},{ 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9, 1},{ 9, 2},{ 9, 3},{ 9, 4},{ 9, 5},{ 9, 6},{ 9, 7},{ 9, 8},{ 9, 9},{ 9,10},{ 9,11},{ 9,12},{ 9,13},{ 9,14},{ 9,15},
  {10,10},{10,11},{10,12},{10,13},{10,14},{10,15},
  {11,10},{11,11},{11,12},{11,13},{11,14},{11,15},
  {12,10},{12,11},{12,12},{12,13},{12,14},{12,15},
  {13,10},{13,11},{13,12},{13,13},{13,14},{13,15},
  {14,11},{14,12},{14,13},{14,14},{14,15},
  {15,11},{15,12},{15,13},{15,14},{15,15},
  {16,11},{16,12},{16,13},{16,14},{16,15},
  {17,11},{17,12},{17,13},{17,14},{17,15},
  {18, 5},{18, 6},{18, 7},{18, 8},{18, 9},{18,10},{18,11},{18,12},{18,13},{18,14},{18,15},
  {19, 5},{19, 6},{19, 7},{19, 8},{19, 9},{19,10},{19,11},{19,12},{19,13},{19,14},{19,15},
  {20, 5},{20, 6},{20, 7},{20, 8},{20, 9},{20,10},{20,11},{20,12},{20,13},{20,14},{20,15},
  {21, 5},{21, 6},{21, 7},{21, 8},{21, 9},{21,10},{21,11},{21,12},{21,13},{21,14},{21,15},
  {22,12},{22,13},{22,14},{22,15},
  {23,12},{23,13},{23,14},{23,15},
  {24,12},{24,13},{24,14},{24,15},
  {25,12},{25,13},{25,14},{25,15},
  {26,12},{26,13},{26,14},{26,15},
  {27,12},{27,13},{27,14},{27,15},
  {28,12},{28,13},{28,14},{28,15},
  {29,12},{29,13},{29,14},{29,15},
  {30,13},{30,14},{30,15},
  {31,13},{31,14},{31,15},
  {32,13},{32,14},{32,15},
  {33,13},{33,14},{33,15}
 },

 {  /* Cyan ToneOptimaizeTabl (158 bytes)	*/
  { 0, 0},
  { 1, 3},{ 1, 4},{ 1, 5},{ 1, 6},{ 1, 7},{ 1, 8},{ 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 1},{ 2, 2},{ 2, 3},{ 2, 4},{ 2, 5},{ 2, 6},{ 2, 7},{ 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 7},{ 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,15}
 },

 {  /* Magenat ToneOptimaizeTabl (158 bytes)	*/
  { 0, 0},
  { 1, 3},{ 1, 4},{ 1, 5},{ 1, 6},{ 1, 7},{ 1, 8},{ 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 1},{ 2, 2},{ 2, 3},{ 2, 4},{ 2, 5},{ 2, 6},{ 2, 7},{ 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 7},{ 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,15}
 },

 {  /* Black ToneOptimaizeTabl (168 bytes)	*/
  { 0, 0},
  { 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 1},{ 3, 2},{ 3, 3},{ 3, 4},{ 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 3},{ 7, 4},{ 7, 5},{ 7, 6},{ 7, 7},{ 7, 8},{ 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8, 6},{ 8, 7},{ 8, 8},{ 8, 9},{ 8,10},{ 8,11}, {8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,13},{10,14},{10,15},
  {11,15},
  {12,14},{12,15},
  {13,13},{13,14},{13,15},
  {14,14},{14,15},
  {15,15},
  {16,15},
  {17,15},
  {18,15}
 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

// NTRAID#NTBUG9-576661-2002/03/14-yasuho-: Remove the dead codes

//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DevMode",
    "DisablePDEV",
    "EnablePDEV",
    "FilterGraphics",
    "GetImplementedMethod",
    "GetInfo",
    "PublishDriverInterface",
    "ResetPDEV",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\sources.inc ===
!IF 0

Copyright (C) 1996 - 1999 Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR_AL=$(PRNROOT)\gpd\alps\usa
GPDDIR_AL_JPN=$(PRNROOT)\gpd\alps\jpn
GPDDIR_CT=$(PRNROOT)\gpd\citzn\usa

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),eprstres
!else
DLLBASE=0x8000000
!endif

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/14-takashim
//     04/07/97 -zhanw-
//         Created it.

--*/

#include "pdev.h"

#include <strsafe.h>

BOOL APIENTRY 
OEMGetInfo(
    DWORD dwInfo,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote DWORD bytes.
    *pcbNeeded = sizeof(DWORD);

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (sizeof(DWORD) > cbSize) )
    {
        WARNING(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\apdlres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        bCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

// NOTICE-2002/3/14-takashim
//     04/07/97 -zhanw-
//         Created it.

--*/

#include "pdev.h"
#include <stdio.h>
#include <strsafe.h>

/*--------------------------------------------------------------------------*/
/*                           G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/
/*======================= P A P E R  S I Z E T A B L E =====================*/
const PHYSIZE phySize[12] = {
//      Width    Height        Physical paper size for 600dpi
       (0x1AAC),(0x2604),      // A3 1B66 x 26C4
       (0x12A5),(0x1AAC),      // A4 1362 x 1B66
       (0x0CEC),(0x12A4),      // A5
       (0x0000),(0x0000),      // A6 (Reserved)
       (0x16FA),(0x20DA),      // B4 17B8 x 2196
       (0x100F),(0x16FA),      // B5 10CE x 17B8
       (0x0000),(0x0000),      // B6 (Reserved)
       (0x087E),(0x0CEC),      // Post Card 93C x DAA (Origin is EE)
       (0x1330),(0x190C),      // Letter 13CE x 19C8
       (0x1330),(0x2014),      // Legal
       (0x0000),(0x0000),      // Executive (Reserved)
       (0x0000),(0x0000)       // Unfixed
};
/*==================== A / P D L  C O M M A N D  S T R I N G ===============*/
const BYTE CmdInAPDLMode[]    = {0x1B,0x7E,0x12,0x00,0x01,0x07};
const BYTE CmdOutAPDLMode[]   = {0x1B,0x7E,0x12,0x00,0x01,0x00};
const BYTE CmdAPDLStart[]     = {0x1C,0x01}; // A/PDL start
const BYTE CmdAPDLEnd[]       = {0x1C,0x02}; // A/PDL end
const BYTE CmdBeginPhysPage[] = {0x1C,0x03}; // Begin Physical Page
const BYTE CmdEndPhysPage[]   = {0x1C,0x04}; // End Physical Page
const BYTE CmdBeginLogPage[]  = {0x1C,0x05}; // Begin Logical page
const BYTE CmdEndLogPage[] = {0x1C,0x06}; // End Logical Page
const BYTE CmdEjectPhysPaper[] = {0x1C,0x0F};  // Print&Eject Phys Paper
//BYTE CmdMoveHoriPos[]   = {0x1C,0x21,0x00,0x00};      // Horizontal Relative
//BYTE CmdMoveVertPos[]   = {0x1C,0x22,0x00,0x00};      // Vertical Relative
const BYTE CmdGivenHoriPos[] = {0x1C,0x23,0x00,0x00}; // Horizontal Absolute
const BYTE CmdGivenVertPos[] = {0x1C,0x24,0x00,0x00}; // Vertical Absolute
const BYTE CmdSetGivenPos[] = {0x1C,0x40,0x00,0x00,0x00,0x00};
//BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03}; // Print String
const BYTE CmdBoldItalicOn[] = {
    0x1C,0xA5,0x08,0x04,0x06,0x02,0x30,0x00,0x00,0x00,0x00};
const BYTE CmdBoldOn[] = {
    0x1C,0xA5,0x04,0x04,0x02,0x02,0x20};
const BYTE CmdItalicOn[] = {
    0x1c,0xa5,0x08,0x04,0x06,0x02,0x10,0x00,0x00,0x00,0x00};
const BYTE CmdBoldItalicOff[] = {
    0x1c,0xa5,0x04,0x04,0x02,0x02,0x00};
//#287122
const BYTE CmdDelTTFont[]   = {0x1C,0x20,0xFF,0xFF};
const BYTE CmdDelDLCharID[] = { 0x1c, 0x20, 0xff, 0xff };

// for vertical font x adjustment
const BYTE CmdSelectSingleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x01,0x01};

//980212 #284407
//const BYTE CmdSelectDoubleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x00,0x00};
const BYTE CmdSelectDoubleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x01,0x00};

const BYTE CmdSelectSingleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x03,0x03};

//980212 #284407
//const BYTE CmdSelectDoubleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x02,0x02};
const BYTE CmdSelectDoubleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x03,0x02};

#define CmdSetPhysPaper pOEM->ajCmdSetPhysPaper
#define CmdSetPhysPage pOEM->ajCmdSetPhysPage
#define CmdDefDrawArea pOEM->ajCmdDefDrawArea

#define CMD_SET_PHYS_PAPER_PAPER_SIZE       5
#define CMD_SET_PHYS_PAPER_PAPER_TRAY       6
#define CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE   7
#define CMD_SET_PHYS_PAPER_DUPLEX           8
#define CMD_SET_PHYS_PAPER_COPY_COUNT       9
#define CMD_SET_PHYS_PAPER_UNIT_BASE        12
#define CMD_SET_PHYS_PAPER_LOGICAL_UNIT     13 // 2 bytes
#define CMD_SET_PHYS_PAPER_WIDTH            15 // 2 bytes
#define CMD_SET_PHYS_PAPER_HEIGHT           17 // 2 bytes

const BYTE XXXCmdSetPhysPaper[]  = {0x1C,0xA0,         // Set Physical Paper
                           0x10,              // length
                           0x01,              // SubCmd Basic Characteristics
                           0x05,              // SubCmdLength
                           0x01,              // Paper Size
                           0x01,              // PaperTray
                           0x00,              // AutoTrayMode
                           00,                // Duplex Mode
                           0x01,              // Copy Count
                           0x02,              // SubCmd Set Unfixed Paper Size
                           0x07,              // SubCmdLength
                           00,                // UnitBase
                           00,00,             // Logical Unit
                           00,00,             // Width
                           00,00};            // Height

#define CMD_SET_PHYS_PAGE_RES           6 // 2 bytes
#define CMD_SET_PHYS_PAGE_TONER_SAVE    10

const BYTE XXXCmdSetPhysPage[]   = {0x1C,0xA1,         // Set Physical Page
                           0x0D,              // Length
                           0x01,              // SubCmd Resolution
                           0x03,              // SubCmdLength
                           00,                // Unit Base of 10
                           0x0B,0xB8,         // and Logical Unit Res of 3000
                           0x02,              // SubCmd Toner Save
                           0x01,              // SubCmdLength
                           00,                // Toner Save OFF
                           0x03,              // SubCmd N-Up
                           0x03,              // SubCmdLength 
                           00,00,00};         // N-Up off 

#define CMD_DEF_DRAW_AREA_ORIGIN_X      5 // 2 bytes
#define CMD_DEF_DRAW_AREA_ORIGIN_Y      7 // 2 bytes
#define CMD_DEF_DRAW_AREA_WIDTH         9 // 2 bytes
#define CMD_DEF_DRAW_AREA_HEIGHT        11 // 2 bytes
#define CMD_DEF_DRAW_AREA_ORIENT        15 // 2 bytes

const BYTE XXXCmdDefDrawArea[]   = {0x1C,0xA2,         // Define Drawing Area
                           0x0D,              // length
                           0x01,              // SubCmd origin width,height
                           0x08,              // SubCmdLength
                           0x00,0x77,         // origin X
                           0x00,0x77,         // origin Y
                           00,00,             // width
                           00,00,             // height
                           0x02,              // SubCmd Media Origin
                           0x01,              // SubCmdLength
                           00};               // Portrait

/*****************************************************************************/
/*                                                                           */
/*  Module:         APDLRES.DLL                                              */
/*                                                                           */
/*  Function:       OEMEnablePDEV                                            */
/*                                                                           */
/*  Syntax:         PDEVOEM APIENTRY OEMEnablePDEV(                          */
/*                                      PDEVOBJ         pdevobj,             */
/*                                      PWSTR           pPrinterName,        */
/*                                      ULONG           cPatterns,           */
/*                                      HSURF          *phsurfPatterns,      */
/*                                      ULONG           cjGdiInfo,           */
/*                                      GDIINFO        *pGdiInfo,            */
/*                                      ULONG           cjDevInfo,           */
/*                                      DEVINFO        *pDevInfo,            */
/*                                      DRVENABLEDATA  *pded)                */
/*                                                                           */
/*  Description:    Allocate buffer of private data to pdevobj               */
/*                                                                           */
/*****************************************************************************/
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PAPDLPDEV pOEM;

    if (NULL == pdevobj)
    {
        // Invalid parameter.
        return NULL;
    }

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(APDLPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if (sizeof(CmdSetPhysPaper) < sizeof(XXXCmdSetPhysPaper)
            || sizeof(CmdSetPhysPage) < sizeof(XXXCmdSetPhysPage)
            || sizeof(CmdDefDrawArea) < sizeof(XXXCmdDefDrawArea))
    {
        ERR(("Dest buffer too small.\n"));
        return NULL;
    }
    CopyMemory(CmdSetPhysPaper, XXXCmdSetPhysPaper,
        sizeof(XXXCmdSetPhysPaper));
    CopyMemory(CmdSetPhysPage, XXXCmdSetPhysPage,
        sizeof(XXXCmdSetPhysPage));
    CopyMemory(CmdDefDrawArea, XXXCmdDefDrawArea,
        sizeof(XXXCmdDefDrawArea));

    return pdevobj->pdevOEM;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:         APDLRES.DLL                                              */
/*                                                                           */
/*  Function:       OEMDisablePDEV                                           */
/*                                                                           */
/*  Syntax:         VOID APIENTRY OEMDisablePDEV(                            */
/*                                          PDEVOBJ     pdevobj)             */
/*                                                                           */
/*  Description:    Free buffer of private data                              */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PAPDLPDEV pOEM;

    if (NULL == pdevobj)
    {
        // Invalid parameter.
        return;
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if (pOEM)
    {
        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
            pOEM->pjTempBuf = NULL;
            pOEM->dwTempBufLen = 0;
        }
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PAPDLPDEV pOEMOld, pOEMNew;
    PBYTE pTemp;
    DWORD dwTemp;

    if (NULL == pdevobjOld || NULL == pdevobjNew)
    {
        // Invalid parameter.
        return FALSE;
    }

    pOEMOld = (PAPDLPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PAPDLPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {

        // Save pointer and length
        pTemp = pOEMNew->pjTempBuf;
        dwTemp = pOEMNew->dwTempBufLen;

        *pOEMNew = *pOEMOld;

        // Restore..
        pOEMNew->pjTempBuf = pTemp;
        pOEMNew->dwTempBufLen = dwTemp;
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMFilterGraphics                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)        */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pBuf        points to buffer of graphics data                 */
/*             dwLen       length of buffer in bytes                         */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/

BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PAPDLPDEV           pOEM;
    ULONG               ulHorzPixel;

    BOOL bComp = TRUE;
    BYTE jTemp[15];
    DWORD dwOutLen;
    DWORD dwTemp;
    INT iTemp;
    DWORD dwPaddingCount;  /* #441427 */

    WORD wTmpHeight ;
    DWORD dwNewBufLen = 0 ;

    if (NULL == pdevobj || NULL == pBuf || 0 == dwLen)
    {
        // Invalid parameter.
        return FALSE;
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    //We have to make image hight multiple of 8
    if ( pOEM->wImgHeight % 8 != 0){

        VERBOSE(("Pad zeros to make multiple of 8\n"));

        wTmpHeight = ((pOEM->wImgHeight + 7) / 8) * 8; 
        dwNewBufLen = (DWORD)(wTmpHeight * pOEM->wImgWidth) / 8;
    }
    else{

        wTmpHeight = pOEM->wImgHeight;
        dwNewBufLen = dwLen;
    }

    if (NULL == pOEM->pjTempBuf ||
        dwNewBufLen > pOEM->dwTempBufLen) {

        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
        }
        pOEM->pjTempBuf = (PBYTE)MemAlloc(dwNewBufLen);
        if (NULL == pOEM->pjTempBuf) {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));

            pOEM->dwTempBufLen = 0;

            // Still try to ouptut with no compression.
            bComp = FALSE;
        }
        pOEM->dwTempBufLen = dwNewBufLen;
    }

    dwOutLen = dwNewBufLen;

    if (bComp) {

        // try compression
        dwOutLen = BRL_ECmd(
            (PBYTE)pBuf,
            (PBYTE)pOEM->pjTempBuf,
            dwLen,
            dwNewBufLen);

        // Does not fit into the destination buffer.
        if (dwOutLen >= dwNewBufLen) {

            // No compression.
            bComp = FALSE;
            dwOutLen = dwNewBufLen;
        }
    }

/* #441427: if bComp==FALSE, pjTempBuf == NULL */
//    if (!bComp) {
//        // Construct padding zeros.
//        ZeroMemory(pOEM->pjTempBuf, (dwOutLen - dwLen));
//    }

    iTemp = 0;
    jTemp[iTemp++] = 0x1c;
    jTemp[iTemp++] = 0xe1;

    // Set the LEN of the DrawBlockImage command
    dwTemp = dwOutLen + (bComp ? 9 : 5);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 24) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 16) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 8) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 0) & 0xff);

    jTemp[iTemp++] = (bComp ? 1 : 0);

    // Set the WIDTH parameter of the DrawBlockImage command
    jTemp[iTemp++] = HIBYTE(pOEM->wImgWidth);
    jTemp[iTemp++] = LOBYTE(pOEM->wImgWidth);

    // Set height parameters (9,10 byte)
    jTemp[iTemp++] = HIBYTE(wTmpHeight);
    jTemp[iTemp++] = LOBYTE(wTmpHeight);

    if (bComp) {
        // length of uncompressed data
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 24) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 16) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 8) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 0) & 0xff);
    }

    // Draw Block Image at Current Position
    WRITESPOOLBUF(pdevobj, jTemp, iTemp);
    if (bComp) {
        // Output compressed data, which also contains
        // padding zeros.
        WRITESPOOLBUF(pdevobj, pOEM->pjTempBuf, dwOutLen);
    }
    else {
        // Output uncompressed data, with padding zeros.

        WRITESPOOLBUF(pdevobj, pBuf, dwLen);

        /* #441427: if bComp==FALSE, pjTempBuf == NULL */
        if ( (dwOutLen - dwLen) > 0 )
        {
            for ( dwPaddingCount = 0 ; dwPaddingCount < dwOutLen - dwLen ; dwPaddingCount++ )
            {
                WRITESPOOLBUF(pdevobj, "\x00", 1 );
            }
        }
        //WRITESPOOLBUF(pdevobj, pOEM->pjTempBuf,
        //   (dwOutLen - dwLen));
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    bCommandCallback                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL bCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)   */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             dwCmdCbID                                                     */
/*             dwCount                                                       */
/*             pdwParams                                                     */
/*                                                                           */
/*  Output:    INT                                                           */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
bCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams,  // points to values of command params
    INT *piResult ) // result code
{
    PAPDLPDEV       pOEM;
    WORD            wTemp;
    WORD            wPhysWidth;
    WORD            wPhysHeight;
    WORD            wXval;
    WORD            wYval;
// #278517: RectFill
    BYTE            CmdDrawLine[] =
                    { 0x1C,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

    // Load default return code.
    if (NULL == pdevobj || NULL == piResult)
    {
        ERR(("Invalid parameter(s).\n"));
        return FALSE;
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    *piResult = 0;

    switch(dwCmdCbID)
    {
        case PAGECONTROL_BEGIN_JOB:
            //Move these command from PAGECONTROL_BEGIN_DOC

            /* Send Change Data Stream Command for Enter A/PDL mode */
            WRITESPOOLBUF(pdevobj, CmdInAPDLMode, sizeof(CmdInAPDLMode));

            /* Send A/PLDL start Command */
            WRITESPOOLBUF(pdevobj, CmdAPDLStart, sizeof(CmdAPDLStart));

            /* Delete downloaded font */
            //#287122
            //To clean up downloaded font in the printer.
            //#304858
            //This command makes printer do FF, cause error of duplex.
            //and #287122 does not replo with this chenge.
            WRITESPOOLBUF(pdevobj, CmdDelTTFont, sizeof(CmdDelTTFont));

            break ;

        /*------------------------------------------------------*/
        /* A/PDL start now                                      */
        /*------------------------------------------------------*/
        case PAGECONTROL_BEGIN_DOC:
            /* reset flag of sent Set Physical Paper command */
            pOEM->fSendSetPhysPaper = FALSE;

            /* initialize flag */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPage[CMD_SET_PHYS_PAGE_TONER_SAVE] = 0x00;

            break;

        /*------------------------------------------------------*/
        /* send Page Description command                        */
        /*------------------------------------------------------*/
        case PAGECONTROL_BEGIN_PAGE:
            pOEM->fGeneral |= (BIT_FONTSIM_RESET
                             | BIT_XMOVE_ABS
                             | BIT_YMOVE_ABS);
            pOEM->wXPosition = 0;
            pOEM->wYPosition = 0;
            pOEM->bCurByteMode = BYTE_BYTEMODE_RESET;

            /* reset duplex mode if fDuplex is FALSE */
            if(!pOEM->fDuplex)
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x00;     // Duplex OFF

            /* send Set Physical Paper command */
            WRITESPOOLBUF(pdevobj,
                                CmdSetPhysPaper, sizeof(CmdSetPhysPaper));

            if(pOEM->ulHorzRes == 600)   // set unit base
            {
                CmdSetPhysPage[CMD_SET_PHYS_PAGE_RES] = 0x17;
                CmdSetPhysPage[CMD_SET_PHYS_PAGE_RES + 1] = 0x70;
            } else {
                CmdSetPhysPage[CMD_SET_PHYS_PAGE_RES] = 0x0B;
                CmdSetPhysPage[CMD_SET_PHYS_PAGE_RES + 1] = 0xB8;
            }

            // send Set Physical Page command
            WRITESPOOLBUF(pdevobj, CmdSetPhysPage, sizeof(CmdSetPhysPage));

            // send Begin Physical Page command
            WRITESPOOLBUF(pdevobj, 
                                CmdBeginPhysPage, sizeof(CmdBeginPhysPage));

            // send Begin Logical Page command
            WRITESPOOLBUF(pdevobj, CmdBeginLogPage, sizeof(CmdBeginLogPage));

            // send Define Drawing Area command
            WRITESPOOLBUF(pdevobj, CmdDefDrawArea, sizeof(CmdDefDrawArea));
            break;

        case PAGECONTROL_END_PAGE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            // send End Logical Page command
            WRITESPOOLBUF(pdevobj, CmdEndLogPage, sizeof(CmdEndLogPage));

            // send End Physical Page command
            WRITESPOOLBUF(pdevobj, CmdEndPhysPage, sizeof(CmdEndPhysPage));
            break;

        case PAGECONTROL_ABORT_DOC:
        case PAGECONTROL_END_DOC:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            // Send delete DL char ID command
            if(pOEM->wNumDLChar)
            {
                WRITESPOOLBUF(pdevobj, CmdDelDLCharID, sizeof(CmdDelDLCharID));
                pOEM->wNumDLChar = 0;
            }

            /* Delete downloaded font
            WRITESPOOLBUF(pdevobj, CmdDelTTFont, sizeof(CmdDelTTFont));

            // send A/PDL End command
            WRITESPOOLBUF(pdevobj, CmdAPDLEnd, sizeof(CmdAPDLEnd));

            // Send A/PDL Mode out command
            WRITESPOOLBUF(pdevobj, CmdOutAPDLMode, sizeof(CmdOutAPDLMode));

            break;

        /*------------------------------------------------------*/
        /* save print direction                                 */
        /*------------------------------------------------------*/
        case PAGECONTROL_POTRAIT:           // 36
            pOEM->fOrientation = TRUE;
            break;

        case PAGECONTROL_LANDSCAPE:         // 37
            pOEM->fOrientation = FALSE;
            break;

        /*------------------------------------------------------*/
        /* save resolution                                     */
        /*------------------------------------------------------*/
        case RESOLUTION_300:
            pOEM->ulHorzRes = 300;
            pOEM->ulVertRes = 300;
            break;

        case RESOLUTION_600:
            pOEM->ulHorzRes = 600;
            pOEM->ulVertRes = 600;
            break;

        case SEND_BLOCK_DATA:
            // for graphics printing, send cursor move command at here
            bSendCursorMoveCommand( pdevobj, FALSE );

            pOEM->wImgWidth = (WORD)(PARAM(pdwParams, 1) * 8);
            pOEM->wImgHeight = (WORD)PARAM(pdwParams, 2);
            break;

        /*------------------------------------------------------*/
        /* set Drawing Area into SetPhysPaperDesc command       */
        /*------------------------------------------------------*/
        case PHYS_PAPER_A3:                 // 50
        case PHYS_PAPER_A4:                 // 51
        case PHYS_PAPER_B4:                 // 54
        case PHYS_PAPER_LETTER:             // 57
        case PHYS_PAPER_LEGAL:              // 58
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_SIZE] = SetDrawArea(pdevobj, dwCmdCbID);
            break;

        case PHYS_PAPER_B5:                 // 55
        case PHYS_PAPER_A5:                 // 52
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_SIZE] = SetDrawArea(pdevobj, dwCmdCbID);

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x00;      // Duplex is off
            break;

        case PHYS_PAPER_POSTCARD:           // 59
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_SIZE] = SetDrawArea(pdevobj, dwCmdCbID);

            /* if paper is Postcard, papersource is always Front Tray */
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x00;      // select Front Tray
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x00;      // Duplex is off
            break;

        case PHYS_PAPER_UNFIXED:            // 60
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

            /* if paper is Unfixed, papersource is always Front Tray */
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x00;      // Select Front Tray
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x00;      // Duplex is off

            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_SIZE] = SetDrawArea(pdevobj, dwCmdCbID);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_UNIT_BASE] = 0x00;     // UnitBase : 10 inch

            switch(pOEM->ulHorzRes)      // set logical unit
            {
            case 600:
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_LOGICAL_UNIT] = 0x17;
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_LOGICAL_UNIT + 1] = 0x70;
                break;

            case 300:
            default:
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_LOGICAL_UNIT] = 0x0B;
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_LOGICAL_UNIT + 1] = 0xB8;

                // Make sure it is meaningful value
                if (300 != pOEM->ulHorzRes)
                    pOEM->ulHorzRes = HORZ_RES_DEFAULT;
            }

            wPhysWidth  = (WORD)pOEM->szlPhysSize.cx / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            wPhysHeight = (WORD)pOEM->szlPhysSize.cy / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);

            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_WIDTH] = HIBYTE(wPhysWidth);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_WIDTH + 1] = LOBYTE(wPhysWidth);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_HEIGHT] = HIBYTE(wPhysHeight);
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_HEIGHT + 1] = LOBYTE(wPhysHeight);
            break;

        /*------------------------------------------------------*/
        /* set Paper Tray into SetPhysPaperDesc command         */
        /*------------------------------------------------------*/
        case PAPER_SRC_FTRAY:
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x00;      // Select Front Tray
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS1:
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x01;      // Select Cassette 1
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS2:
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x02;      // Select Cassette 2
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS3:
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x03;      // Select Cassette 3
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;      // Auto Tray Select is OFF
            break;
        case PAPER_SRC_AUTO_SELECT:         //Auto Tray Select ON
            if(pOEM->fScaleToFit == TRUE){  //Select PAPER_DEST_SCALETOFIT_ON
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x01;
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x03;
            }
            else if(pOEM->fScaleToFit == FALSE){ 
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_PAPER_TRAY] = 0x01;
                CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x01;
            }
            break;


        /*------------------------------------------------------*/
        /* set Auto Tray Mode into SetPhysPaperDesc command     */
        /*------------------------------------------------------*/
        case PAPER_DEST_SCALETOFIT_ON:      // 25
            pOEM->fScaleToFit = TRUE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x02;
            break;

        case PAPER_DEST_SCALETOFIT_OFF:     // 26
            pOEM->fScaleToFit = FALSE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_AUTO_TRAY_MODE] = 0x00;
            break;

        /*------------------------------------------------------*/
        /* set Duplex Mode into SetPhysPaperDesc command        */
        /*------------------------------------------------------*/
        case PAGECONTROL_DUPLEX_UPDOWN:
            pOEM->fDuplex = TRUE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x01;      // Up Side Down
            break;

        case PAGECONTROL_DUPLEX_RIGHTUP:
            pOEM->fDuplex = TRUE;
            CmdSetPhysPaper[CMD_SET_PHYS_PAPER_DUPLEX] = 0x02;      // Right Side Up
            break;

        case PAGECONTROL_DUPLEX_OFF:
            pOEM->fDuplex = FALSE;
            break;

        /*------------------------------------------------------*/
        /* set Toner Save into SetPhysPage command              */
        /*------------------------------------------------------*/
        case TONER_SAVE_OFF:                // 100
            CmdSetPhysPage[CMD_SET_PHYS_PAGE_TONER_SAVE] = 0x00;      // off
            break;

        case TONER_SAVE_DARK:               // 101
            CmdSetPhysPage[CMD_SET_PHYS_PAGE_TONER_SAVE] = 0x02;      // dark
            break;

        case TONER_SAVE_LIGHT:              // 102
            CmdSetPhysPage[CMD_SET_PHYS_PAGE_TONER_SAVE] = 0x01;      // right
            break;

        /*------------------------------------------------------*/
        /* set Copy Count to SetPhysPaperDesc command           */
        /*------------------------------------------------------*/
        case PAGECONTROL_MULTI_COPIES:
// @Aug/31/98 ->
           if(MAX_COPIES_VALUE < PARAM(pdwParams,0)) {
               CmdSetPhysPaper[CMD_SET_PHYS_PAPER_COPY_COUNT] = MAX_COPIES_VALUE;
           }
           else if (1 > PARAM(pdwParams,0)) {
               CmdSetPhysPaper[CMD_SET_PHYS_PAPER_COPY_COUNT] = 1;
           }
           else {
               CmdSetPhysPaper[CMD_SET_PHYS_PAPER_COPY_COUNT] = (BYTE)PARAM(pdwParams,0);
           }
// @Aug/31/98 <-
            break;

       /*------------------------------------------------------*/
        /* send Set Character Attribute with ornament           */
        /*------------------------------------------------------*/
        case BOLD_ON:
            if(!(pOEM->fGeneral & BIT_FONTSIM_BOLD))
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral |= BIT_FONTSIM_BOLD;
            }
            break;

        case ITALIC_ON:
            if(!(pOEM->fGeneral & BIT_FONTSIM_ITALIC))
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral |= BIT_FONTSIM_ITALIC;
            }
            break;

        case BOLD_OFF:
            if(pOEM->fGeneral & BIT_FONTSIM_BOLD)
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral &= ~BIT_FONTSIM_BOLD;
            }
            break;

        case ITALIC_OFF:
            if(pOEM->fGeneral & BIT_FONTSIM_ITALIC)
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral &= ~BIT_FONTSIM_ITALIC;
            }
            break;

        case SELECT_SINGLE_BYTE:
            if(ISVERTICALFONT(pOEM->bFontID))
            {
                if(pOEM->bCurByteMode == BYTE_DOUBLE_BYTE)
                {
                    if(pOEM->wCachedBytes)
                        VOutputText(pdevobj);
                    
                    if(pOEM->bFontID == MINCHO_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectSingleByteMincho, 
                                            sizeof(CmdSelectSingleByteMincho));
                    else if(pOEM->bFontID == GOTHIC_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectSingleByteGothic, 
                                            sizeof(CmdSelectSingleByteGothic));
                        
                }
                pOEM->bCurByteMode = BYTE_SINGLE_BYTE;
            }
            break;

        case SELECT_DOUBLE_BYTE:
            if(ISVERTICALFONT(pOEM->bFontID))
            {
                if(pOEM->bCurByteMode == BYTE_SINGLE_BYTE)
                {
                    if(pOEM->wCachedBytes)
                        VOutputText(pdevobj);

                    if(pOEM->bFontID == MINCHO_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectDoubleByteMincho, 
                                            sizeof(CmdSelectDoubleByteMincho));
                    else if(pOEM->bFontID == GOTHIC_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectDoubleByteGothic, 
                                            sizeof(CmdSelectDoubleByteGothic));
                        
                }
                pOEM->bCurByteMode = BYTE_DOUBLE_BYTE;
            }
            break;

        /*------------------------------------------------------*/
        /* Send 
        /*------------------------------------------------------*/
        case X_ABS_MOVE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            pOEM->wUpdateXPos = 0;
            if (0 == pOEM->ulHorzRes)
                pOEM->ulHorzRes = HORZ_RES_DEFAULT;
            wTemp = (WORD)PARAM(pdwParams,0) / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            pOEM->wXPosition = wTemp;
            pOEM->fGeneral |= BIT_XMOVE_ABS;
            *piResult = (INT)wTemp;
            return TRUE;

        case Y_ABS_MOVE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            //#332101 prob.4: wUpdateXPos is cleared only when X_ABS_MOVE and CR.
            //pOEM->wUpdateXPos = 0;
            if (0 == pOEM->ulVertRes)
                 pOEM->ulVertRes = VERT_RES_DEFAULT;
            wTemp = (WORD)PARAM(pdwParams,0) / (MASTER_UNIT / (WORD)pOEM->ulVertRes);
            pOEM->wYPosition = wTemp;
            pOEM->fGeneral |= BIT_YMOVE_ABS;
            *piResult = (INT)wTemp;
            return TRUE;

        case CR_EMULATION:
            pOEM->wXPosition = 0;
            pOEM->wUpdateXPos = 0;
            pOEM->fGeneral |= BIT_XMOVE_ABS;
            break;

        case SET_CUR_GLYPHID:
            if(!pdwParams || dwCount != 1)
            {
                ERR(("bCommandCallback: parameter is invalid.\n"));
                return FALSE;
            }

            if(PARAM(pdwParams,0) < MIN_GLYPH_ID || PARAM(pdwParams,0) > MAX_GLYPH_ID)
            {
                ERR(("bCommandCallback: glyph id is out of range.\n"));
                return FALSE;
            }
            pOEM->wGlyphID = (WORD)PARAM(pdwParams,0);
            break;

// #278517: RectFill
        case RECT_SET_WIDTH:
            if (0 == pOEM->ulHorzRes)
                pOEM->ulHorzRes = HORZ_RES_DEFAULT;
            wTemp = (WORD)PARAM(pdwParams,0) / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            pOEM->wRectWidth = wTemp;
            break;

        case RECT_SET_HEIGHT:
            if (0 == pOEM->ulVertRes)
                 pOEM->ulVertRes = VERT_RES_DEFAULT;
            wTemp = (WORD)PARAM(pdwParams,0) / (MASTER_UNIT / (WORD)pOEM->ulVertRes);
            pOEM->wRectHeight = wTemp;
            break;

        case RECT_FILL_BLACK:
            wTemp = pOEM->wXPosition;
            CmdDrawLine[2] = HIBYTE(wTemp);
            CmdDrawLine[3] = LOBYTE(wTemp);
            wTemp = pOEM->wYPosition;
            CmdDrawLine[4] = HIBYTE(wTemp);
            CmdDrawLine[5] = LOBYTE(wTemp);
            wTemp = pOEM->wRectWidth;
            CmdDrawLine[6] = HIBYTE(wTemp);
            CmdDrawLine[7] = LOBYTE(wTemp);
            wTemp = pOEM->wRectHeight;
            CmdDrawLine[8] = HIBYTE(wTemp);
            CmdDrawLine[9] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, CmdDrawLine, sizeof(CmdDrawLine));
            break;

        default:
            break;
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    bOutputCharStr                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL bOutputCharStr(PDEVOBJ, PUNIFONTOBJ, DWORD,   */
/*                                                   DWORD, PVOID)           */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj                                                        */
/*             dwType                                                        */
/*             dwCount                                                       */
/*             pGlyph                                                        */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BOOL
bOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PAPDLPDEV           pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    WORD                wLen = (WORD)dwCount;

    PBYTE               pbCommand;
    PDWORD              pdwGlyphID;
    WORD                wFontID;
    WORD                wCmdLen;

    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("bOutputCharStr: Invalid parameter(s).\n"));
        return FALSE;
    }

    if (0 == dwCount || NULL == pGlyph)
        return TRUE;

    switch(dwType)
    {
        case TYPE_GLYPHHANDLE:
            // Send appropriate cursor move command
            bSendCursorMoveCommand( pdevobj, TRUE );

            // Set font simulation if needed
            VSetFontSimulation( pdevobj );

// #333653: Change I/F for GETINFO_GLYPHSTRING begin

            // Translate character code
            GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
            GStr.dwCount   = dwCount;
            GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
            GStr.pGlyphIn  = pGlyph;
            GStr.dwTypeOut = TYPE_TRANSDATA;
            GStr.pGlyphOut = NULL;
            GStr.dwGlyphOutSize = 0;        /* new member of GETINFO_GLYPHSTRING */

            /* Get TRANSDATA buffer size */
            if(pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
                 || !GStr.dwGlyphOutSize )
            {
                ERR(("Get Glyph String error\n"));
                return FALSE;
            }

            // Alloc translation buffer
            if (NULL == pOEM->pjTempBuf ||
                pOEM->dwTempBufLen < GStr.dwGlyphOutSize)
            {
                if (NULL != pOEM->pjTempBuf) {
                    MemFree(pOEM->pjTempBuf);
                }
                pOEM->pjTempBuf = MemAllocZ(GStr.dwGlyphOutSize);
                if (NULL == pOEM->pjTempBuf)
                {
                    ERR(("Faild to allocate memory. (%d)\n",
                        GetLastError()));

                    pOEM->dwTempBufLen = 0;
                    return FALSE;
                }
                pOEM->dwTempBufLen = GStr.dwGlyphOutSize;
            }
            pTrans = (PTRANSDATA)pOEM->pjTempBuf;

            /* Get actual TRANSDATA */
            GStr.pGlyphOut = pTrans;
            if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
            {
                ERR(("GetInfo failed.\n"));
                return FALSE;
            }

// #333653: Change I/F for GETINFO_GLYPHSTRING end

            // Spooled device font characters
            for(dwI = 0; dwI < dwCount; dwI++, pTrans++)
            {

// ISSUE-2002/3/14-takashim - Condtion is not correct?
// Not sure what below wCachedBytes + dwCount * 2 > sizeof(pOEM->bCharData)
// means.  Is it counting the worst case, where all the characters are
// double-byte characters?
// Why this is within the "for" loop (dwCount never changes in it)?

                // Make sure there is no overflow
                if(pOEM->wCachedBytes + dwCount * 2 > sizeof(pOEM->bCharData))
                    VOutputText(pdevobj);

                switch(pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                    case MTYPE_DIRECT:
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                        pTrans->uCode.ubCode;
                        break;
                    
                    case MTYPE_PAIRED:
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                    pTrans->uCode.ubPairs[0];
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                    pTrans->uCode.ubPairs[1];
                        break;
                }
            }

            break;  //switch(dwType)

        case TYPE_GLYPHID:
            if(!pOEM->wNumDLChar || pOEM->wNumDLChar > MAX_DOWNLOAD_CHAR)
            {
                ERR(("Illegal number of DL glyphs.  wNumDLChar = %d\n",
                        pOEM->wNumDLChar));
                return FALSE;
            }

// ISSUE-2002/3/14-takashim - Not sure what "16" here stands for.
// The byte size of the CmdPrintDLChar[] below is 8 bytes,
// so this can be dwCount * 8?

            if (NULL == pOEM->pjTempBuf ||
                pOEM->dwTempBufLen < dwCount * 16) {

                if (NULL != pOEM->pjTempBuf) {
                    MemFree(pOEM->pjTempBuf);
                }
                pOEM->pjTempBuf = MemAllocZ((dwCount * 16));
                if(NULL == pOEM->pjTempBuf) {
                    ERR(("Faild to allocate memory. (%d)\n",
                        GetLastError()));

                    pOEM->dwTempBufLen = 0;
                    return FALSE;
                }
                pOEM->dwTempBufLen = dwCount * 16;
            }
            pbCommand = pOEM->pjTempBuf;
            wCmdLen = 0;
            wFontID = (WORD)(pUFObj->ulFontID - FONT_ID_DIFF);

            bSendCursorMoveCommand( pdevobj, FALSE );

            for (dwI = 0, pdwGlyphID = (PDWORD)pGlyph; 
                                        dwI < dwCount; dwI++, pdwGlyphID++)
            {
                BYTE    CmdPrintDLChar[] = "\x1C\xC1\x00\x04\x00\x00\x00\x00";
                WORD    wGlyphID = *(PWORD)pdwGlyphID;
                WORD    wDownloadedCharID;
                WORD    wXInc;
                WORD    wXAdjust;
                WORD    wYAdjust;

                if(wGlyphID > MAX_GLYPH_ID || wGlyphID < MIN_GLYPH_ID)
                {
                    ERR(("bOutputCharStr: GlyphID is invalid. GlyphID = %ld\n", wGlyphID));
                    return FALSE;
                }

                // set parameters each a character
                wDownloadedCharID = 
                                pOEM->DLCharID[wFontID][wGlyphID].wCharID;
                wXInc = pOEM->DLCharID[wFontID][wGlyphID].wXIncrement;
                wYAdjust= pOEM->DLCharID[wFontID][wGlyphID].wYAdjust;
                wXAdjust = pOEM->DLCharID[wFontID][wGlyphID].wXAdjust;

                // Position adjusting based on UPPERLEFT of font box
                pbCommand[wCmdLen++] = CmdGivenVertPos[0];
                pbCommand[wCmdLen++] = CmdGivenVertPos[1];
                pbCommand[wCmdLen++] = HIBYTE(pOEM->wYPosition - wYAdjust);
                pbCommand[wCmdLen++] = LOBYTE(pOEM->wYPosition - wYAdjust);

                if(wXAdjust)
                {
                    pbCommand[wCmdLen++] = CmdGivenHoriPos[0];
                    pbCommand[wCmdLen++] = CmdGivenHoriPos[1];
                    pbCommand[wCmdLen++] = HIBYTE(pOEM->wXPosition - wXAdjust);
                    pbCommand[wCmdLen++] = LOBYTE(pOEM->wXPosition - wXAdjust);
                    pOEM->wXPosition -= wXAdjust;
                }

                CmdPrintDLChar[4] = HIBYTE(wDownloadedCharID);
                CmdPrintDLChar[5] = LOBYTE(wDownloadedCharID);
                CmdPrintDLChar[6] = HIBYTE(wXInc);
                CmdPrintDLChar[7] = LOBYTE(wXInc);

                pOEM->wXPosition += wXInc;
                if (pOEM->dwTempBufLen
                        < (DWORD)(wCmdLen + sizeof(CmdPrintDLChar)))
                {
                    ERR(("Destination buffer too small.\n"));
                    return FALSE;
                }
                else
                {
                    memcpy(pbCommand + wCmdLen,
                            CmdPrintDLChar, sizeof(CmdPrintDLChar));
                    wCmdLen += sizeof(CmdPrintDLChar);
                }
            }
            WRITESPOOLBUF(pdevobj, pbCommand, wCmdLen);

            break;
    }
    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendFontCmd                                                */
/*                                                                           */
/*  Function:  send A/PDL-style font selection command.                      */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMSendFontCmd(                                 */
/*                                    PDEVOBJ, PUNIFONTOBJ, PFINVOCATION)    */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             pFInv       address of FINVOCATION                            */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY 
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv )
{
    PAPDLPDEV       pOEM;
    BYTE            rgcmd[CCHMAXCMDLEN];
    PGETINFO_STDVAR pSV;
    DWORD           dwStdVariable[STDVAR_BUFSIZE(2) / sizeof(DWORD)];
    DWORD           i, ocmd = 0;
    WORD            wHeight, wWidth;
//#305000
    WORD wDescend, wAscend ;

    if (NULL == pdevobj || NULL == pUFObj || NULL == pFInv)
    {
        // Invalid parameter(s).
        return;
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(pOEM->wCachedBytes)
        VOutputText(pdevobj);

    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = STDVAR_BUFSIZE(2);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 
                                                            pSV->dwSize, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    wHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wWidth = (WORD)pSV->StdVar[1].lStdVariable;

    if(pOEM->ulHorzRes == 300)
    {
        wHeight = (wHeight + 1) / 2;
        wWidth = (wWidth + 1) / 2;
    }

    pOEM->bFontID = (BYTE)pUFObj->ulFontID;

    if(pUFObj->ulFontID == 1 || pUFObj->ulFontID == 2)
    {
        // This font is vertical
        pOEM->wFontHeight = wWidth;
        pOEM->wWidths = wHeight;
    } else {
        // This font is horizontal.
        pOEM->wFontHeight = wHeight;
        pOEM->wWidths = wWidth;
    }

    //#305000: set to base line as a TT fonts.
    wAscend = pUFObj->pIFIMetrics->fwdWinAscender ;
    wDescend = pUFObj->pIFIMetrics->fwdWinDescender ;

    wDescend = pOEM->wFontHeight * wDescend / (wAscend + wDescend) ;
    pOEM->wFontHeight -= wDescend ;


    for (i = 0; i < pFInv->dwCount && ocmd < CCHMAXCMDLEN; )
    {
        if (pFInv->pubCommand[i] == '#'
                && i + 1 < pFInv->dwCount)
        {
            if (pFInv->pubCommand[i+1] == 'H')
            {
                rgcmd[ocmd++] = HIBYTE(wHeight);
                rgcmd[ocmd++] = LOBYTE(wHeight);
                i += 2;
                continue;
            }
            else if (pFInv->pubCommand[i+1] == 'W')
            {
                rgcmd[ocmd++] = HIBYTE(wWidth);
                rgcmd[ocmd++] = LOBYTE(wWidth);
                i += 2;
                continue;
            }
        }

        // Default case.
        rgcmd[ocmd++] = pFInv->pubCommand[i++];
    }

    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);
    return;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMTTDownloadMethod                                           */
/*                                                                           */
/*  Function:  Choose how to print TrueType font                             */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMTTDownloadMethod(                           */
/*                                    PDEVOBJ, PUNIFONTOBJ)                  */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ         pdevobj,
    PUNIFONTOBJ     pUFObj)
{
    PAPDLPDEV       pOEM;
    DWORD           dwReturn;

    dwReturn = TTDOWNLOAD_GRAPHICS;

    if (NULL == pdevobj || NULL == pUFObj)
        return dwReturn;

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(pOEM->wNumDLChar <= MAX_DOWNLOAD_CHAR)
        dwReturn = TTDOWNLOAD_BITMAP;

    VERBOSE(("TTDownloadMethod: dwReturn=%ld\n", dwReturn));

    return dwReturn;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMDownloadFontHeader                                         */
/*                                                                           */
/*  Function:  Download font header                                          */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMDownloadFontHeader(                         */
/*                                    PDEVOBJ, PUNIFONTOBJ)                  */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ         pdevobj, 
    PUNIFONTOBJ     pUFObj)
{
    // dummy support
    return (DWORD)100;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMDownloadCharGlyph                                          */
/*                                                                           */
/*  Function:  send char glyph                                               */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMDownloadFontHeader(                         */
/*                                 PDEVOBJ, PUNIFONTOBJ, HGLYPH, PDWORD)     */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             hGlyph      handle of glyph                                   */
/*             pdwWidth    address of glyph width                            */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ         pdevobj,
    PUNIFONTOBJ     pUFObj,
    HGLYPH          hGlyph,
    PDWORD          pdwWidth)
{
    PAPDLPDEV           pOEM;

    GETINFO_GLYPHBITMAP GD;
    GLYPHBITS          *pgb;

    WORD                wSrcGlyphWidth;
    WORD                wSrcGlyphHeight;
    WORD                wDstGlyphWidthBytes;
    WORD                wDstGlyphHeight;
    WORD                wDstGlyphBytes;

    WORD                wLeftMarginBytes;
    WORD                wShiftBits;

    PBYTE               pSrcGlyph;
    PBYTE               pDstGlyphSave;
    PBYTE               pDstGlyph;

    WORD                i, j;

    BYTE                CmdDownloadChar[] = 
                                "\x1c\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    WORD                wGlyphID;
    WORD                wFontID;
    WORD                wXCharInc;

    if (NULL == pdevobj || NULL == pUFObj || NULL == pdwWidth)
    {
        ERR(("OEMDownloadCharGlyph: Invalid parameter(s).\n"));
        return 0;
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    wGlyphID = pOEM->wGlyphID;
    wFontID = (WORD)(pUFObj->ulFontID - FONT_ID_DIFF);

    if(wGlyphID > MAX_GLYPH_ID || wFontID > MAX_FONT_ID)
    {
        ERR(("Parameter is invalid.\n"));
        return 0;
    }

    // Get glyph bitmap
    GD.dwSize = sizeof(GETINFO_GLYPHBITMAP);
    GD.hGlyph = hGlyph;
    GD.pGlyphData = NULL;
    if(!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GD, 
                                                            GD.dwSize, NULL))
    {
        ERR(("UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    // set parameters
    pgb = GD.pGlyphData->gdf.pgb;

    // set source glyph bitmap size
    wSrcGlyphWidth = (WORD)((pgb->sizlBitmap.cx + 7) / 8);
    wSrcGlyphHeight = (WORD)pgb->sizlBitmap.cy;

    // set dest. glyph bitmap size
    if(pgb->ptlOrigin.x >= 0)
    {
        wDstGlyphWidthBytes = (WORD)(((pgb->sizlBitmap.cx
                                         + pgb->ptlOrigin.x) + 7) / 8);

        wLeftMarginBytes = (WORD)(pgb->ptlOrigin.x / 8);
        pOEM->DLCharID[wFontID][wGlyphID].wXAdjust = 0;
        wShiftBits = (WORD)(pgb->ptlOrigin.x % 8);
    } else {
        wDstGlyphWidthBytes = (WORD)((pgb->sizlBitmap.cx + 7) / 8);
        wLeftMarginBytes = 0;
        pOEM->DLCharID[wFontID][wGlyphID].wXAdjust
                                                 = (WORD)ABS(pgb->ptlOrigin.x);
        wShiftBits = 0;
    }

    wDstGlyphHeight = wSrcGlyphHeight;
    wDstGlyphBytes = wDstGlyphWidthBytes * wDstGlyphHeight;

    if (wDstGlyphWidthBytes * 8 > MAXGLYPHWIDTH
            || wDstGlyphHeight > MAXGLYPHHEIGHT
            || wDstGlyphBytes > MAXGLYPHSIZE)
    {
        ERR(("No more glyph can be downloaded.\n"));
        return 0;
    }

    // set pointer of bitmap area
    if (NULL == pOEM->pjTempBuf ||
        pOEM->dwTempBufLen < wDstGlyphBytes) {

        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
        }
        pOEM->pjTempBuf = MemAllocZ(wDstGlyphBytes);
        if (NULL == pOEM->pjTempBuf)
        {
            ERR(("Memory alloc failed.\n"));
            return 0;
        }
        pOEM->dwTempBufLen = wDstGlyphBytes;
    }
    pDstGlyph = pOEM->pjTempBuf;
    pSrcGlyph = pgb->aj;

    // create Dst Glyph
    for(i = 0; i < wSrcGlyphHeight && pSrcGlyph && pDstGlyph; i++)
    {
        if(wLeftMarginBytes)
        {
            if (pOEM->dwTempBufLen - (pDstGlyph - pOEM->pjTempBuf)
                     < wLeftMarginBytes)
            {
                    ERR(("Dest buffer too small.\n"));
                    return 0;
            }
            memset(pDstGlyph, 0, wLeftMarginBytes);
            pDstGlyph += wLeftMarginBytes;
        }

        if(wShiftBits)
        {
            // First byte
            *pDstGlyph++ = (BYTE)((*pSrcGlyph++) >> wShiftBits);

            for(j = 0; j < wSrcGlyphWidth - 1; j++, pSrcGlyph++, pDstGlyph++)
            {
                WORD    wTemp1 = (WORD)*(pSrcGlyph - 1);
                WORD    wTemp2 = (WORD)*pSrcGlyph;

                wTemp1 <<= (8 - wShiftBits);
                wTemp2 >>= wShiftBits;
                *pDstGlyph = LOBYTE(wTemp1);
                *pDstGlyph |= LOBYTE(wTemp2);
            }

            // bounded last byte of src glyph
            if(((pgb->sizlBitmap.cx + wShiftBits + 7) >> 3) != wSrcGlyphWidth)
            {
                *pDstGlyph = *(pSrcGlyph - 1) << (8 - wShiftBits);
                pDstGlyph++;
            }
        } else {
            for(j = 0; j < wSrcGlyphWidth; j++, pSrcGlyph++, pDstGlyph++)
                *pDstGlyph = *pSrcGlyph;
        }
    }

    // set parameter at Download char table
    wXCharInc = wDstGlyphWidthBytes * 8;

    pOEM->wNumDLChar++;
    pOEM->DLCharID[wFontID][wGlyphID].wCharID = pOEM->wNumDLChar;
    pOEM->DLCharID[wFontID][wGlyphID].wXIncrement = 
                            (WORD)((GD.pGlyphData->ptqD.x.HighPart + 15) >> 4);
    pOEM->DLCharID[wFontID][wGlyphID].wYAdjust = (WORD)-pgb->ptlOrigin.y;

    //#305000 : Need to add 1 that was rounded off.
    if(pOEM->ulHorzRes == 300)
    {
        pOEM->DLCharID[wFontID][wGlyphID].wYAdjust += 1;
    }

    // send command
    // set LEN parameter
    CmdDownloadChar[2] = HIBYTE(7 + wDstGlyphBytes);
    CmdDownloadChar[3] = LOBYTE(7 + wDstGlyphBytes);
    
    // set ID parameter
    CmdDownloadChar[4] = HIBYTE(pOEM->wNumDLChar);
    CmdDownloadChar[5] = LOBYTE(pOEM->wNumDLChar);

    // set CW CH IW IH
    CmdDownloadChar[7] = CmdDownloadChar[9] = (BYTE)wXCharInc;
    CmdDownloadChar[8] = CmdDownloadChar[10] = (BYTE)wDstGlyphHeight;

    // send download char command and image
    WRITESPOOLBUF(pdevobj, (PBYTE)CmdDownloadChar, 11);
    WRITESPOOLBUF(pdevobj, (PBYTE)pOEM->pjTempBuf, wDstGlyphBytes);

    *pdwWidth = (DWORD)wXCharInc;

    return (DWORD)wDstGlyphBytes;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    SetDrawArea                                                   */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BYTE SetDrawArea(PDEVOBJ, DWORD)                              */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             dwCmdCbId                                                     */
/*                                                                           */
/*  Output:    BYTE                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BYTE SetDrawArea(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbId)
{
    PAPDLPDEV       pOEM;
    WORD            wWidth;
    WORD            wHeight;
    BYTE            bIndex;
    BYTE            bMargin;

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(dwCmdCbId != PHYS_PAPER_UNFIXED)
    {
        bIndex = (BYTE)(dwCmdCbId - PAPERSIZE_MAGIC);
        bMargin = 0x76;

        wWidth = (WORD)pOEM->szlPhysSize.cx - (0x76 * 2);
        wHeight = (WORD)pOEM->szlPhysSize.cy - (0x76 * 2);

        if(pOEM->ulHorzRes == 300)
        {
            wWidth /= 2;
            wHeight /= 2;
        }
    } else {
        bIndex = 0x7f;
        bMargin = 0x00;

        wWidth = (WORD)pOEM->szlPhysSize.cx - (0x25 * 2);
        wHeight= (WORD)pOEM->szlPhysSize.cy - (0x25 * 2);

        if(pOEM->ulHorzRes == 300)
        {
            wWidth /= 2;
            wHeight /= 2;
        }
    }

    /* set value of width, height into DefineDrawingArea command */
    CmdDefDrawArea[CMD_DEF_DRAW_AREA_WIDTH]  = HIBYTE(wWidth);
    CmdDefDrawArea[CMD_DEF_DRAW_AREA_WIDTH + 1] = LOBYTE(wWidth);
    CmdDefDrawArea[CMD_DEF_DRAW_AREA_HEIGHT] = HIBYTE(wHeight);
    CmdDefDrawArea[CMD_DEF_DRAW_AREA_HEIGHT + 1] = LOBYTE(wHeight);

    /* set value of Origin-X, Y into DefineDrawingArea command */
    if(pOEM->ulHorzRes == 600)
    {
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_X]
                = CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_Y] = 0x00;
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_X + 1]
                = CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_Y + 1] = bMargin;
    } else {
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_X]
                = CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_Y] = 0x00;
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_X + 1]
                = CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIGIN_Y + 1] = bMargin / 2;
    }

    /* set Media Origin into DefineDrawingArea command */
    if(pOEM->fOrientation)      // portrait
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIENT] = 0x00;
    else {                      // landscape
        CmdDefDrawArea[CMD_DEF_DRAW_AREA_ORIENT] = 0x03;
    }

    return bIndex;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    BRL_Ecmd                                                      */
/*                                                                           */
/*  Function:  ByteRunLength(HBP) Compression Routine                        */
/*                                                                           */
/*  Syntax:    WORD BRL_Ecmd(PBYTE, PBYTE, PBYTE, DWORD)                     */
/*                                                                           */
/*  Input:     lpbSrc                                                        */
/*             lpbTgt                                                        */
/*             lpbTmp                                                        */
/*             len                                                           */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD
BRL_ECmd(
    PBYTE   lpbSrc,
    PBYTE   lpbTgt,
    DWORD   lenNoPad,
    DWORD   len)
{

    BYTE    bRCnt  = 1;                     // repeating byte counter
    BYTE    bNRCnt = 0;                     // non-repeating byte counter
    BYTE    bSaveRCnt;
    DWORD i = 0, j = 0, k = 0, l = 0;     // movement trackers
    char    Go4LastByte = TRUE;             // flag to get last byte

#define jSrcByte(i) \
    ((i < lenNoPad) ? lpbSrc[(i)] : 0)

    /* start compression routine - ByteRunLength Encoding */
    do {
        if(jSrcByte(i) != jSrcByte(i+1))      // non-repeating data?
        {
            while(((jSrcByte(i) != jSrcByte(i+1))
                               && (((DWORD)(i+1)) < len)) && (bNRCnt < NRPEAK))
            {
                bNRCnt++;                   // if so, how many?
                i++;
            }

            /* if at last element but less than NRPEAK value */
            if( (((DWORD)(i+1))==len) && (bNRCnt<NRPEAK) )
            {
                bNRCnt++;                       // inc count for last element
                Go4LastByte = FALSE;            // no need to go back
            } else
                /* if at last BYTE, but before that, 
                                            NRPEAK value has been reached */
                if((((DWORD)(i+1))==len) && ((bNRCnt)==NRPEAK))
                    Go4LastByte = TRUE;         // get the last BYTE

// ISSUE-2002/3/14-takashim - Condition is not correct?
// The below can be (j + bNRCnt + 1) > len, since here we are only loading
// 1 + bNRCnd bytes to the dest buffer?

            /* Check Target's room to set data */ 
            if ( (j + bNRCnt + 2) > len )   /* 2 means [Counter] and what bNRCnt starts form 0 */
            {
                /* no room to set data, so return ASAP with the buffer size */
                /* not to use temporary buffer to output.                   */
				return (len);
            }

            /* assign the value for Number of Non-repeating bytes */
            lpbTgt[j] = bNRCnt-1;               // subtract one for WinP's case
            j++;                                // update tracker

            /* afterwards...write the Raw Data */
            for (l=0; l<bNRCnt;l++) 
            {
                lpbTgt[j] = jSrcByte(k);
                k++;
                j++;
            }

            /* reset counter */
            bNRCnt = 0;
        } else {                                // end of Non-repeating data
                                                // data is repeating
            while(((jSrcByte(i)==jSrcByte(i+1)) 
                                            && ( ((DWORD)(i+1)) < len)) 
                                            && (bRCnt<RPEAK))
            {
                bRCnt++;
                i++;
            }

            /* Convert to Two's Complement */
            bSaveRCnt   = bRCnt;                // save original value
            bRCnt = (BYTE) 0 - bRCnt;

            /* Check Target's room to set data */ 
            if ( j + 2 > len )              /* 2 means [Counter][Datum] */
            {
                /* no room to set data, so return ASAP with the buffer size */
                /* not to use temporary buffer to output.                   */
				return (len);
            }


            /* Write the Number of Repeating Data */
            lpbTgt[j] = bRCnt + 1;              // add one for WinP's case
            j++;                                // go to next element

            /* afterwards...write the Repeating data */
            lpbTgt[j] = jSrcByte(k);
            j++;

            /* update counters */
            k       += bSaveRCnt;
            bRCnt    = 1;
            i       += 1;

            /* check if last element has been reached */
            if (i==len)
                Go4LastByte=FALSE;              // if so, no need to go back
        }                                       // end of Repeating data
    } while (Go4LastByte);                      // end of Compression

    return ( j );
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    VOutputText                                                   */
/*                                                                           */
/*  Function:  Send device font characters spooled from bOutputCharStr     */
/*                                                                           */
/*  Syntax:    VOID VOutputText( PDEVOBJ )                                   */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID
VOutputText(
    PDEVOBJ     pdevobj)
{
    PBYTE       pCmd;
    WORD        wCmdLen = 0;
    PAPDLPDEV   pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

#define CMD_PRN_STR_CUR_VAL     2 // 2 bytes
    BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03}; // Print String

#define CMD_MOVE_HOR_POS_VAL    2 // 2 bytes
    BYTE CmdMoveHoriPos[] = {0x1C,0x21,0x00,0x00};      // Horizontal Relative
    BYTE fGeneralSave;

    // ensure Y position
    fGeneralSave = pOEM->fGeneral;
    pOEM->fGeneral |= BIT_YMOVE_ABS;
    pOEM->fGeneral &= ~BIT_XMOVE_ABS;
    bSendCursorMoveCommand( pdevobj, TRUE );
    pOEM->fGeneral = fGeneralSave;

    if(pOEM->wUpdateXPos)
    {
        CmdMoveHoriPos[CMD_MOVE_HOR_POS_VAL] = HIBYTE(pOEM->wUpdateXPos);
        CmdMoveHoriPos[CMD_MOVE_HOR_POS_VAL + 1] = LOBYTE(pOEM->wUpdateXPos);
        WRITESPOOLBUF(pdevobj, CmdMoveHoriPos, sizeof(CmdMoveHoriPos));
    }

    CmdPrnStrCurrent[CMD_PRN_STR_CUR_VAL] = HIBYTE((pOEM->wCachedBytes + 1));
    CmdPrnStrCurrent[CMD_PRN_STR_CUR_VAL + 1] = LOBYTE((pOEM->wCachedBytes + 1));

    WRITESPOOLBUF(pdevobj, CmdPrnStrCurrent, sizeof(CmdPrnStrCurrent));
    WRITESPOOLBUF(pdevobj, pOEM->bCharData, pOEM->wCachedBytes);

    //#332101 prob.4: Keep wUpdateXPos to accumulate
    pOEM->wUpdateXPos += pOEM->wWidths * (pOEM->wCachedBytes / 2);
    
    if(pOEM->wCachedBytes % 2)
        pOEM->wUpdateXPos += pOEM->wWidths / 2;

    ZeroMemory(pOEM->bCharData, sizeof(pOEM->bCharData));
    pOEM->wCachedBytes = 0;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    VSetFontSimulation                                            */
/*                                                                           */
/*  Function:  Set attribute of device font characters if needed             */
/*                                                                           */
/*  Syntax:    VOID VSetFontSimulation( PDEVOBJ )                            */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID 
VSetFontSimulation(
    PDEVOBJ     pdevobj)
{
    PAPDLPDEV       pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    BYTE            CmdFontSim[]       = {0x1C,0xA5,0x4,0x04,0x02,0x02,0x00,0x00,0x00,0x00,0x00};
    WORD            wCmdLen = 0;

    if((pOEM->fGeneral & FONTSIM_MASK) != pOEM->fCurFontSim || 
                                        (pOEM->fGeneral & BIT_FONTSIM_RESET) )
    {
        // Send Font simulation command
        if((pOEM->fGeneral & BIT_FONTSIM_RESET) && 
         (!(pOEM->fGeneral & BIT_FONTSIM_BOLD)) && 
         (!(pOEM->fGeneral & BIT_FONTSIM_ITALIC)) )
        {
            // Send Bold and Italic off
            CmdFontSim[6] = 0x00;   // Bold and Italic off
            wCmdLen = BYTE_WITHOUT_ITALIC;  // 7 bytes

            pOEM->fGeneral &= ~BIT_FONTSIM_RESET;
        } else {
            if(pOEM->fGeneral & BIT_FONTSIM_RESET)
                pOEM->fGeneral &= ~BIT_FONTSIM_RESET;

            CmdFontSim[6] = (pOEM->fGeneral & FONTSIM_MASK);
            wCmdLen = BYTE_WITHOUT_ITALIC;  // 7 bytes

            if(pOEM->fGeneral & BIT_FONTSIM_ITALIC)
            {
                CmdFontSim[2] = 0x08;   // Total length
                CmdFontSim[4] = 0x06;   // Ornament lengh
                wCmdLen = BYTE_WITH_ITALIC; // 11bytes
            }

            // update current font sim infomation
            pOEM->fCurFontSim = pOEM->fGeneral;
        }
        if(wCmdLen)
            WRITESPOOLBUF(pdevobj, CmdFontSim, wCmdLen);
    }
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    bSendCursorMoveCommand                                        */
/*                                                                           */
/*  Function:  Send appropriate cursor move command                          */
/*                                                                           */
/*  Syntax:    BOOL bSendCursorMoveCommand( PDEVOBJ, BOOL )                  */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*             BOOL    bAdjust    adjusting y position flag                  */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BOOL
bSendCursorMoveCommand(
    PDEVOBJ     pdevobj,        // pointer to the PDEVOBJ structure
    BOOL        bYAdjust)       // adjusting y position if device font
{
    PAPDLPDEV       pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    BYTE            bCursorMoveCmd[6];

    WORD            wCmdLen = 0;
    WORD            wY = pOEM->wYPosition;

	WORD			wI;
    if(bYAdjust)
        wY -= pOEM->wFontHeight;

    // Set appropriate cursor move command
    if( (pOEM->fGeneral & BIT_XMOVE_ABS) && (pOEM->fGeneral & BIT_YMOVE_ABS) )
    {
        if (sizeof(bCursorMoveCmd) < BYTE_XY_ABS
                || sizeof(CmdSetGivenPos) < BYTE_XY_ABS)
        {
            ERR(("Dest buffer too small.\n"));
            return FALSE;
        }
        memcpy(bCursorMoveCmd, CmdSetGivenPos, BYTE_XY_ABS);
        wCmdLen = BYTE_XY_ABS;
        pOEM->fGeneral &= ~BIT_XMOVE_ABS;
        pOEM->fGeneral &= ~BIT_YMOVE_ABS;

        // Set parameters
        bCursorMoveCmd[2] = HIBYTE(pOEM->wXPosition);
        bCursorMoveCmd[3] = LOBYTE(pOEM->wXPosition);
        bCursorMoveCmd[4] = HIBYTE(wY);
        bCursorMoveCmd[5] = LOBYTE(wY);
    } else if((pOEM->fGeneral & BIT_XMOVE_ABS)
                                    && (!(pOEM->fGeneral & BIT_YMOVE_ABS)) ) {
        if (sizeof(bCursorMoveCmd) < BYTE_SIMPLE_ABS
                || sizeof(CmdGivenHoriPos) < BYTE_SIMPLE_ABS)
        {
            ERR(("Dest buffer too small.\n"));
            return FALSE;
        }
        memcpy(bCursorMoveCmd, CmdGivenHoriPos, BYTE_SIMPLE_ABS);
        wCmdLen = BYTE_SIMPLE_ABS;
        pOEM->fGeneral &= ~BIT_XMOVE_ABS;

        // set parameter
        bCursorMoveCmd[2] = HIBYTE(pOEM->wXPosition);
        bCursorMoveCmd[3] = LOBYTE(pOEM->wXPosition);
    } else if((pOEM->fGeneral & BIT_YMOVE_ABS) 
                                    && (!(pOEM->fGeneral & BIT_XMOVE_ABS)) ) {
        if (sizeof(bCursorMoveCmd) < BYTE_SIMPLE_ABS
                || sizeof(CmdGivenVertPos) < BYTE_SIMPLE_ABS)
        {
            ERR(("Dest buffer too small.\n"));
            return FALSE;
        }
        memcpy(bCursorMoveCmd, CmdGivenVertPos, BYTE_SIMPLE_ABS);
        wCmdLen = BYTE_SIMPLE_ABS;
        pOEM->fGeneral &= ~BIT_YMOVE_ABS;

        // set parameter
        bCursorMoveCmd[2] = HIBYTE(wY);
        bCursorMoveCmd[3] = LOBYTE(wY);
    }

    if(wCmdLen)
        WRITESPOOLBUF(pdevobj, bCursorMoveCmd, wCmdLen);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\alpsres\dit\dither.c ===
/*************************** Module Header **********************************
 * dither
 *      Program to create actual dither tables from ALPS's original base 
 *      dither tables.
 *      
 *
 * Copyright (C) 1996-1999,  Microsoft Corporation
 * 1996/6/21 Created - Sueya Sugihara [sueyas] -
 *
 ****************************************************************************/

#include        <stddef.h>
#include        <windows.h>
#include        <winddi.h>

#include        <stdio.h>

#define Yellow   0
#define Cyan     1
#define Magenta  2
#define Kuro     3
#define Mono     4

static unsigned char H_OrgTable[4][68][68] = 
{
 { // Yellow
  {100,84,70,85,100,100,93,80,94,100,100,89,76,90,100},
  {99,46,31,40,97,97,48,38,44,100,100,48,34,42,99},
  {67,22,1,10,63,69,24,8,14,65,68,23,5,12,64},
  {67,26,20,15,63,69,29,21,19,65,68,28,21,17,64},
  {100,60,48,57,100,100,62,54,59,100,100,61,50,58,100},
  {100,91,78,92,100,100,86,73,87,100,100,95,82,96,100},
  {100,48,36,43,100,100,47,32,41,98,98,48,39,45,100},
  {68,24,6,13,64,68,23,3,11,63,69,25,9,14,66},
  {68,29,21,18,64,68,27,21,16,63,69,30,22,20,66},
  {100,62,52,58,100,100,61,49,57,100,100,63,56,59,100}
 },
 { // Cyan
  {46,65,89,90,80,18,45,64,87,87,79,16,44,63,91,91,81,20},
  {59,100,100,90,7,38,58,94,94,87,5,37,57,98,98,91,9,38},
  {75,100,100,30,41,52,73,94,94,28,40,50,71,98,98,33,42,53},
  {83,77,13,43,61,82,82,76,11,42,60,85,85,78,15,44,62,83},
  {83,2,35,55,97,97,82,1,34,54,100,100,85,3,36,56,93,93},
  {23,39,48,68,97,97,21,39,47,66,100,100,25,40,49,70,93,93},
  {45,64,86,86,79,15,44,63,91,91,81,19,46,65,89,88,80,17},
  {58,95,95,86,4,37,57,99,99,91,8,38,59,100,100,88,6,38},
  {72,95,95,26,40,50,71,99,99,32,42,53,74,100,100,29,41,51},
  {82,76,10,42,60,85,85,78,14,44,62,84,84,77,12,43,61,82},
  {82,1,34,54,92,92,85,3,36,56,100,100,84,2,35,55,96,96},
  {20,39,47,66,92,92,24,40,49,69,100,100,22,39,48,67,96,96}
 },
 { // Magenta
  {93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93},
  {1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82},
  {29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26},
  {49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62},
  {100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73},
  {80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88},
  {24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19},
  {46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40},
  {70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62},
  {89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97},
  {20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14},
  {41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36},
  {63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57},
  {95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95},
  {13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4},
  {35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30},
  {56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51},
  {98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98},
  {9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78},
  {31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23},
  {52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45},
  {96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68},
  {84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92},
  {28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22},
  {48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44},
  {76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66},
  {85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93},
  {16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12},
  {38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33},
  {60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55},
  {100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100},
  {15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10},
  {37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32},
  {59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53},
  {94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94},
  {3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81},
  {29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25},
  {50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47},
  {99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72},
  {79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87},
  {23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18},
  {46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39},
  {69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61},
  {90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98},
  {20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14},
  {47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36},
  {64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58},
  {96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96},
  {13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5},
  {35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30},
  {56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51},
  {97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97},
  {7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77},
  {31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22},
  {52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45},
  {95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67},
  {83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91},
  {27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21},
  {48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43},
  {75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65},
  {86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94},
  {17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12},
  {39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34},
  {60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55},
  {99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99},
  {16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11},
  {37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32},
  {59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54}
 },
 { // Kuro
  {93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69},
  {28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59},
  {54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65},
  {99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99},
  {99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99},
  {7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32},
  {27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57},
  {47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94},
  {88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94},
  {9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2},
  {16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23},
  {50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38},
  {86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92},
  {70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14},
  {60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22},
  {67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53},
  {97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74},
  {97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68},
  {30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58},
  {56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61},
  {95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95},
  {95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95},
  {3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29},
  {24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55},
  {40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98},
  {91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98},
  {12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6},
  {20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25},
  {52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46},
  {82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90},
  {68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10},
  {59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18},
  {64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51},
  {94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83},
  {94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69},
  {28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59},
  {54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65},
  {100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100},
  {100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100},
  {8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33},
  {27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57},
  {48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93},
  {87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93},
  {9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1},
  {15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23},
  {49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35},
  {85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92},
  {70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13},
  {60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21},
  {66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53},
  {98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76},
  {98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68},
  {31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58},
  {56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62},
  {96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96},
  {96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96},
  {4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29},
  {24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55},
  {42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97},
  {91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97},
  {11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5},
  {19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25},
  {52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44},
  {80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89},
  {68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10},
  {58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17},
  {63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51},
  {93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84}
 }
};

static unsigned char R_OrgTable[4][20][20] =
{
 { // Yellow
  { 1, 1, 5,20,33,33, 4, 4, 8,23,36,36},
  { 5, 5, 9,20,37,37, 8, 8,12,23,40,40},
  { 9, 9,13,24,37,37,12,12,14,28,40,40},
  {15,15,19,24,41,41,18,18,19,28,44,44},
  {29,29,53,57,61,61,32,32,56,60,66,66},
  {45,46,53,57,62,62,51,52,56,60,67,67},
  { 3, 3, 7,22,35,35, 2, 2, 6,21,34,34},
  { 7, 7,11,22,39,39, 6, 6,10,21,38,38},
  {11,11,14,27,39,39,10,10,13,25,38,38},
  {17,17,19,27,43,43,16,16,19,26,42,42},
  {31,31,55,59,65,65,30,30,54,58,63,63},
  {49,50,55,59,68,68,47,48,54,58,64,64}
 },
 { // Cyan
  {61,63,64,16, 3, 3,11,45,49},
  {67,68,68,17, 6, 6,11,37,51},
  {67,70,70,34,19,21,32,35,53},
  {23,25,31,46,55,58,59,39,29},
  { 7, 8,12,47,60,62,62,41,13},
  { 1, 1,10,50,65,69,69,42,14},
  { 5, 5,10,52,66,70,70,43,17},
  {18,20,30,30,27,28,31,40,33},
  {57,56,54,15, 9, 9,12,44,48}
 },
 { // Magenta
  {65, 1, 1,10,20,32,32, 9, 9,13,25,37,37,28,30,38,40,54,58,65},
  {66, 4, 6,10,22,34,34,15,17,19,27,53,53,50,50,44,47,54,60,66},
  {32, 8, 8,12,24,36,36,29,31,39,41,55,62,67,67, 3, 3,11,21,33},
  {34,14,16,18,26,52,52,51,51,48,49,56,64,68,68, 5, 7,11,23,35},
  {36,28,30,38,40,54,58,65,65, 1, 1,10,20,32,32, 9, 9,13,25,37},
  {52,50,50,44,47,54,60,66,66, 4, 6,10,22,34,34,15,17,19,27,53},
  {58,67,67, 3, 3,11,21,33,33, 8, 8,12,24,36,36,29,31,39,41,55},
  {60,68,68, 5, 7,11,23,35,35,14,16,18,26,52,52,51,51,48,49,56},
  {20,32,32, 9, 9,13,25,37,37,28,30,38,40,54,58,65,65, 1, 1,10},
  {22,34,34,15,17,19,27,53,53,50,50,44,47,54,60,66,66, 4, 6,10},
  {24,36,36,29,31,39,41,55,62,67,67, 3, 3,11,21,33,33, 8, 8,12},
  {26,52,52,51,51,48,49,56,64,68,68, 5, 7,11,23,35,35,14,16,18},
  {40,54,58,65,65, 1, 1,10,20,32,32, 9, 9,13,25,37,37,28,30,38},
  {47,54,60,66,66, 4, 6,10,22,34,34,15,17,19,27,53,53,50,50,44},
  { 3,11,21,33,33, 8, 8,12,24,36,36,29,31,39,41,55,62,67,67, 3},
  { 7,11,23,35,35,14,16,18,26,52,52,51,51,48,49,56,64,68,68, 5},
  { 9,13,25,37,37,28,30,38,40,54,58,67,67, 1, 1,10,20,32,32, 9},
  {17,19,27,53,53,50,50,44,47,54,60,68,68, 4, 6,10,22,34,34,15},
  {31,39,41,55,62,67,67, 3, 3,11,21,33,33, 8, 8,12,24,36,36,29},
  {51,48,49,56,64,68,68, 5, 7,11,23,35,35,14,16,18,26,52,52,51}
 },
 { // Kuro
  {60,60,58,50,52,54,62,62,35,17, 7, 8,11,30,29,14, 3, 3,10,27},
  {31,18,20,23,25,33,64,64,55,43,42,40,39,37,29,16, 6, 6,10,27},
  {28,13, 1, 1,10,26,59,59,56,44,45,48,60,61,36,17, 9, 9,12,30},
  {28,15, 4, 5,10,26,32,19,21,24,25,34,63,63,57,46,47,41,40,38},
  {35,17, 7, 8,11,30,29,14, 3, 3,10,27,60,60,58,50,52,54,62,62},
  {55,43,42,40,39,37,29,16, 6, 6,10,27,31,18,20,23,25,33,64,64},
  {56,44,45,48,60,61,36,17, 9, 9,12,30,28,13, 1, 1,10,26,59,59},
  {21,24,25,34,63,63,57,46,47,41,40,38,28,15, 4, 5,10,26,32,19},
  { 3, 3,10,27,60,60,58,50,52,54,62,62,35,17, 7, 8,11,30,29,14},
  { 6, 6,10,27,31,18,20,23,25,33,64,64,55,43,42,40,39,37,29,16},
  { 9, 9,12,30,28,13, 1, 1,10,26,59,59,56,44,45,48,60,61,36,17},
  {47,41,40,38,28,15, 4, 5,10,26,32,19,21,24,25,34,63,63,57,46},
  {52,54,62,62,35,17, 7, 8,11,30,29,14, 3, 3,10,27,60,60,58,50},
  {25,33,64,64,55,43,42,40,39,37,29,16, 6, 6,10,27,31,18,20,23},
  {10,26,59,59,56,44,45,48,60,61,36,17, 9, 9,12,30,28,13, 1, 1},
  {10,26,32,19,21,24,25,34,63,63,57,46,47,41,40,38,28,15, 4, 5},
  {11,30,29,14, 3, 3,10,27,60,60,58,50,52,54,62,62,35,17, 7, 8},
  {39,37,29,16, 6, 6,10,27,31,18,20,23,25,33,64,64,55,43,42,40},
  {60,61,36,17, 9, 9,12,30,28,13, 1, 1,10,26,59,59,56,44,45,48},
  {63,63,57,46,47,41,40,38,28,15, 4, 5,10,26,32,19,21,24,25,34}
 }
};

static unsigned char M_OrgTable[14][14] =
{
 {91,71,39,41,63,73,95,92,72,40,42,64,74,96},
 {69,37,21,23,43,45,75,70,38,22,24,44,46,76},
 {35,19,1,3,9,25,47,36,20,2,4,10,26,48},
 {33,17,5,7,11,27,49,34,18,6,8,12,28,50},
 {61,31,13,15,29,51,65,62,32,14,16,30,52,66},
 {85,59,57,55,53,67,87,86,60,58,56,54,68,88},
 {93,83,81,79,77,89,97,94,84,82,80,78,90,100},
 {92,72,40,42,64,74,96,91,71,39,41,63,73,95},
 {70,38,22,24,44,46,76,69,37,21,23,43,45,75},
 {36,20,2,4,10,26,48,35,19,1,3,9,25,47},
 {34,18,6,8,12,28,50,33,17,5,7,11,27,49},
 {62,32,14,16,30,52,66,61,31,13,15,29,51,65},
 {86,60,58,56,54,68,88,85,59,57,55,53,67,87},
 {94,84,82,80,78,90,99,93,83,81,79,77,89,98}
};

static unsigned char OHP_OrgTable[8][8] =
{
 {36, 40, 38, 32, 27, 23, 25, 31},
 {54, 56, 58, 44,  9,  7,  5, 19},
 {52, 62, 60, 42, 11,  1,  3, 21},
 {46, 50, 48, 34, 17, 13, 15, 29},
 {26, 22, 24, 30, 37, 41, 39, 33},
  {8,  6,  4, 18, 55, 57, 59, 45},
 {10,  0,  2, 20, 53, 63, 61, 43},
 {16, 12, 14, 28, 47, 51, 49, 35}
};

int _CRTAPI1
main( argc, argv )
int    argc;
char **argv;
{

    int H_MaxX[4], H_MaxY[4];
    int R_MaxX[4], R_MaxY[4];
    int M_MaxX,    M_MaxY;
    int OHP_MaxX,  OHP_MaxY;
    int x, y;
    int color;
    char szColor[10];
    FLOAT H_TableMax[4];
    FLOAT R_TableMax[4];
    FLOAT M_TableMax;
    FLOAT OHP_TableMax;
    FLOAT H_TableOffset[4];
    FLOAT R_TableOffset[4];
    FLOAT M_TableOffset;
    FLOAT OHP_TableOffset;


    H_MaxX[Yellow]  = 15; H_MaxY[Yellow]  = 10;
    H_MaxX[Cyan]    = 18; H_MaxY[Cyan]    = 12;
    H_MaxX[Magenta] = 68; H_MaxY[Magenta] = 68;
    H_MaxX[Kuro]    = 68; H_MaxY[Kuro]    = 68;

    R_MaxX[Yellow]  = 12; R_MaxY[Yellow]  = 12;
    R_MaxX[Cyan]    = 9;  R_MaxY[Cyan]    =  9;
    R_MaxX[Magenta] = 20; R_MaxY[Magenta] = 20;
    R_MaxX[Kuro]    = 20; R_MaxY[Kuro]    = 20;

    M_MaxX          = 14; M_MaxY          = 14;

    OHP_MaxX = 8;
    OHP_MaxY = 8;

    H_TableMax[Yellow] = 100.0;
    H_TableMax[Cyan] = 100.0;
    H_TableMax[Magenta] = 100.0;
    H_TableMax[Kuro] = 100.0;
    H_TableOffset[Yellow] = 2.55;
    H_TableOffset[Cyan] = 2.55;
    H_TableOffset[Magenta] = 2.55;
    H_TableOffset[Kuro] = 2.55;

    R_TableMax[Yellow] = 68.0;
    R_TableMax[Cyan] = 70.0;
    R_TableMax[Magenta] = 68.0;
    R_TableMax[Kuro] = 100.0;
    R_TableOffset[Yellow] = 3.77;
    R_TableOffset[Cyan] = 3.66;
    R_TableOffset[Magenta] = 3.76;
    R_TableOffset[Kuro] = 4.0;

    M_TableMax = 100.0;
    M_TableOffset = 2.55;

    OHP_TableMax = 63.0;
    OHP_TableOffset = 4.0;

    // HEIKATSU

    for( color=Yellow; color <= Kuro; color++){

        switch( color ){

        case Yellow:
            strcpy(szColor, "Yellow");
            break;
        case Cyan:
            strcpy(szColor, "Cyan");
            break;
        case Magenta:
            strcpy(szColor, "Magenta");
            break;
        case Kuro:
            strcpy(szColor, "Kuro");
            break;

        }

        printf("HEIKATSU NewTable[%s]\n", szColor);

        for( y=0; y < H_MaxY[color]; y++){


            for( x=0; x < H_MaxX[color]; x++){

                unsigned char ucOut;

                if( x != 0 )
                    printf(",");

                ucOut = (unsigned char)(( H_TableMax[color] - (H_OrgTable[color][y][x] - (FLOAT)0.5)) 
                                          * H_TableOffset[color] );

                printf("%d", ucOut);

            }
            printf("\n");
        }
        printf("\n");

    }

    // ROUGH

    for( color=Yellow; color <= Kuro; color++){

        switch( color ){

        case Yellow:
            strcpy(szColor, "Yellow");
            break;
        case Cyan:
            strcpy(szColor, "Cyan");
            break;
        case Magenta:
            strcpy(szColor, "Magenta");
            break;
        case Kuro:
            strcpy(szColor, "Kuro");
            break;

        }

        printf("ROUGH NewTable[%s]\n", szColor);

        for( y=0; y < R_MaxY[color]; y++){


            for( x=0; x < R_MaxX[color]; x++){

                unsigned char ucOut;

                if( x != 0 )
                    printf(",");

                ucOut = (unsigned char)(( R_TableMax[color] - (R_OrgTable[color][y][x] - (FLOAT)0.5))
                                          * R_TableOffset[color] );

                printf("%d", ucOut);

            }
            printf("\n");
        }
        printf("\n");

    }

    // MONO

    printf("MONO NewTable\n");

    for( y=0; y < M_MaxY; y++){


        for( x=0; x < M_MaxX; x++){

            unsigned char ucOut;

            if( x != 0 )
                printf(",");

            ucOut = (unsigned char)(( M_TableMax - (M_OrgTable[y][x] + (FLOAT)0.5))
                                      * M_TableOffset );

            printf("%d", ucOut);

        }
        printf("\n");
    }

    printf("\n");

    // OHP

    printf("OHP NewTable\n");

    for( y=0; y < OHP_MaxY; y++){


        for( x=0; x < OHP_MaxX; x++){

            unsigned char ucOut;

            if( x != 0 )
                printf(",");

            ucOut = (unsigned char)(( OHP_TableMax - (OHP_OrgTable[y][x] - (FLOAT)0.5))
                                      * OHP_TableOffset );

            printf("%d", ucOut);

        }
        printf("\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"

#include <strsafe.h>

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));

    if (NULL == ppv)
        return E_NOINTERFACE;

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    if (NULL == pDevOem)
        return E_FAIL;

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}

static
int __cdecl
iCompNames(
    const void *p1,
    const void *p2) {

    return strcmp(
        (NULL == p1 ? "" : *((char **)p1)),
        (NULL == p2 ? "" : *((char **)p2)));
};

LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (SUCCEEDED(StringCchLengthA(
            pMethodName, MAX_METHODNAME, NULL))) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    if (!bCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams, piResult))
    {
        return E_FAIL;
    }
    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    if (NULL == pdwResult)
        return E_FAIL;

    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    if (NULL == pdwResult)
        return E_FAIL;

    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    if (NULL == pdwResult)
        return E_FAIL;

    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    if (!bOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
    {
        return E_FAIL;
    }

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if (NULL == ppv)
        return E_NOINTERFACE;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\apti\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=apdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),apdlres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\apdlres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\apdlres.c

MISCFILES=\
    $(SRCDIR)\apdlres.ini \
    $(GPDDIR)\ate780j.gpd \
    $(GPDDIR)\ate840j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DisableDriver",
    "DisablePDEV",
    "DownloadCharGlyph",
    "DownloadFontHeader",
    "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
    "GetImplementedMethod",
    "GetInfo",
    "OutputCharStr",
    "PublishDriverInterface",
    "ResetPDEV",
    "SendFontCmd",
    "TTDownloadMethod",
};

// Maximum lenth of the method name which this plug-in has concern.
#define MAX_METHODNAME 23 // including terminating 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#ifdef __cplusplus
extern "C" {
#endif

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'APDL'
#define DLLTEXT(s)      "APDL: " s
#define OEM_VERSION      0x00010000L

/*--------------------------------------------------------------------------*/
/*                        D E F I N E  V A L U E                            */
/*--------------------------------------------------------------------------*/
#define PAPER_SRC_FTRAY                 20
#define PAPER_SRC_CAS1                  21
#define PAPER_SRC_CAS2                  22
#define PAPER_SRC_CAS3                  23
#define PAPER_SRC_AUTO                  24  //Not use by NT driver
#define PAPER_DEST_SCALETOFIT_ON        25
#define PAPER_DEST_SCALETOFIT_OFF       26
#define PAPER_SRC_AUTO_SELECT           27

#define PAGECONTROL_BEGIN_JOB           140
#define PAGECONTROL_BEGIN_DOC           30
#define PAGECONTROL_BEGIN_PAGE          31
#define PAGECONTROL_END_DOC             32
#define PAGECONTROL_END_PAGE            33
#define PAGECONTROL_DUPLEX_OFF          34
#define PAGECONTROL_ABORT_DOC           35
#define PAGECONTROL_POTRAIT             36
#define PAGECONTROL_LANDSCAPE           37
#define PAGECONTROL_MULTI_COPIES        38
#define PAGECONTROL_DUPLEX_UPDOWN       39
#define PAGECONTROL_DUPLEX_RIGHTUP      40

#define PAPERSIZE_MAGIC                 50 // this ID - 50 = Actual ID of A/PDL
#define PHYS_PAPER_A3                   50
#define PHYS_PAPER_A4                   51
#define PHYS_PAPER_A5                   52
#define PHYS_PAPER_A6                   53  // Reserved
#define PHYS_PAPER_B4                   54
#define PHYS_PAPER_B5                   55
#define PHYS_PAPER_B6                   56  // Reserved
#define PHYS_PAPER_LETTER               57
#define PHYS_PAPER_LEGAL                58
#define PHYS_PAPER_POSTCARD             59
#define PHYS_PAPER_EXECUTIVE            60  // Reserved
#define PHYS_PAPER_UNFIXED              61

#define X_ABS_MOVE                      70
#define Y_ABS_MOVE                      71
#define XY_ABS_MOVE                     78
#define X_REL_MOVE_RIGHT                110
#define Y_REL_MOVE_DOWN                 111

#define CR_EMULATION                    79
#define DUMMY_LF                        80
#define FF_EJECTPAGE                    81

#define BOLD_ON                         72
#define BOLD_OFF                        73
#define ITALIC_ON                       74
#define ITALIC_OFF                      75
#define SELECT_SINGLE_BYTE              120
#define SELECT_DOUBLE_BYTE              121

#define RESOLUTION_300                  76
#define RESOLUTION_600                  77
#define SEND_BLOCK_DATA                 82

#define TONER_SAVE_OFF                  100
#define TONER_SAVE_DARK                 101
#define TONER_SAVE_LIGHT                102

// #278517: RectFill
#define RECT_SET_WIDTH                  130
#define RECT_SET_HEIGHT                 131
#define RECT_FILL_BLACK                 132

#define MASTER_UNIT                     600
#define LINE_PER_BAND                   32
#define CCHMAXCMDLEN                    128
#define MAXIMGSIZE                      0xF000

#define NRPEAK                          0x7F
#define RPEAK                           0x80

// for download
#define SET_FONT_ID                     110
#define SELECT_FONT_ID                  111
#define SET_CUR_GLYPHID                 112
#define DELETE_FONT                     113

#define MAXGLYPHSIZE                    0x4000
#define MAXGLYPHWIDTH                   0x80
#define MAXGLYPHHEIGHT                  0x80

// Font ID definition in GPD -> Min 24  Max 48
#define FONT_ID_DIFF                    24

#define MAX_FONT_ID                     24
#define MAX_GLYPH_ID                    1024
#define MIN_GLYPH_ID                    32
#define MAX_DOWNLOAD_CHAR   MAX_FONT_ID * MAX_GLYPH_ID

// for fGeneral(font sim and X/Y move) flags
#define CURSORMOVE_MASK                 0x03    // 1 2 bit
#define FONTSIM_MASK                    0x30    // 5 6 bit

// Bit Flags
#define BIT_XMOVE_ABS                   0x01    // 1 Bit
#define BIT_YMOVE_ABS                   0x02    // 2 Bit
#define BIT_FONTSIM_ITALIC              0x10    // 5 Bit (Command spec)
#define BIT_FONTSIM_BOLD                0x20    // 6 Bit (Command spec)
#define BIT_FONTSIM_RESET               0x40    // 7 Bit

// Max num of spooled device font character
#define MAXDEVFONT                      1024

// Current text mode DBCS/SBCS
#define BYTE_BYTEMODE_RESET             0
#define BYTE_SINGLE_BYTE                1
#define BYTE_DOUBLE_BYTE                2

// Command length
#define BYTE_WITH_ITALIC                11
#define BYTE_WITHOUT_ITALIC             7
#define BYTE_XY_ABS                     6
#define BYTE_SIMPLE_ABS                 4

// device font face
#define MINCHO_HORI                     1
#define MINCHO_VERT                     2
#define GOTHIC_HORI                     3
#define GOTHIC_VERT                     4

// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		255
// @Aug/31/98 <-

// Fail-safe values.
#define HORZ_RES_DEFAULT        300
#define VERT_RES_DEFAULT        300

/*--------------------------------------------------------------------------*/
/*                       S T R U C T U R E  D E F I N E                     */
/*--------------------------------------------------------------------------*/
typedef struct tagPAPER {
    WORD    wWidth;
    WORD    wHeight;
} PHYSIZE, FAR * LPPHYSIZE;

typedef struct tag_TTDLCHAR {
    WORD    wCharID;        // Downloaded char ID for device
    WORD    wXIncrement;    // Increment value 
    WORD    wXAdjust;       // Adjust value for x
    WORD    wYAdjust;       // Adjust value for y
} DLCHAR, *PDLCHAR;

typedef struct tag_APDLPDEV {
    // Private extention
    ULONG   ulHorzRes;        // width of the physical surface
    ULONG   ulVertRes;        // height of the physical surface
    SIZEL   szlPhysSize;      // size of unwriteable margin
    POINTL  ptlPhysOffset;    // size of entire surface with unwriteable margin
    BOOL    fSendSetPhysPaper;// flag for sending set physical paper command
    BOOL    fDuplex;          // TRUE = duplex mode is selected
    BOOL    fScaleToFit;      // for set auto tray mode in Set Physical Paper
    BOOL    fOrientation;     // for set media origin in Define Drawing Area
    WORD    wWidths;          // move current position afer print device font

    BYTE    fGeneral;         // font sim and cursor move infomation
    BYTE    fCurFontSim;      // Currnet settings of font sim
    BYTE    bCurByteMode;     // for x position adjustment in vertical font

    WORD    wXPosition;       // Current X position
    WORD    wYPosition;       // Current Y position

    BYTE    bFontID;          // device font ID based on .rc file
    WORD    wUpdateXPos;      // for relative X move
    WORD    wCachedBytes;     // Bytes of cached device font character
    BYTE    bCharData[MAXDEVFONT];                  // Actual char data
    WORD    wFontHeight;                            // Device font height

    DLCHAR  DLCharID[MAX_FONT_ID][MAX_GLYPH_ID];    // Downloaded char data
    WORD    wNumDLChar;                             // Num of downloaded char
    WORD    wGlyphID;                               // Current GlyphID

    WORD    wImgWidth;
    WORD    wImgHeight;

    // Temp. buffer (dynamically allocated)
    // used for data compressoin work area, etc.
    PBYTE pjTempBuf;
    DWORD dwTempBufLen;

    // Command string buffers to keep status among
    // the Unidrv to minidriver callbacks.

    BYTE ajCmdSetPhysPaper[19];
    BYTE ajCmdSetPhysPage[16];
    BYTE ajCmdDefDrawArea[16];

// #278517: RectFill
    WORD    wRectWidth;
    WORD    wRectHeight;

} APDLPDEV, *PAPDLPDEV;

//+---------------------------------------------------------------------------+
//|                    F U N C T I O N  P R O T O T Y P E                     |
//+---------------------------------------------------------------------------+
BYTE  SetDrawArea(PDEVOBJ, DWORD);
DWORD BRL_ECmd(PBYTE, PBYTE, DWORD, DWORD);
VOID VOutputText( PDEVOBJ );
VOID  VSetFontSimulation( PDEVOBJ );
BOOL bSendCursorMoveCommand( PDEVOBJ, BOOL );

INT
bCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams,
    INT *piResult );

BOOL
bOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph );

/*--------------------------------------------------------------------------*/
/*                        D E F I N E  M A C R O                            */
/*--------------------------------------------------------------------------*/
#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, (PBYTE)(s), (DWORD)(n)))

#define PARAM(p,n) \
    (NULL == (p) ? 0 : *((DWORD *)(p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#define STDVAR_BUFSIZE(n) \
    (sizeof (GETINFO_STDVAR) + sizeof(DWORD) * 2 * ((n) - 1))

#define ISVERTICALFONT(n) \
    ( (n == MINCHO_VERT || n == GOTHIC_VERT) ? TRUE : FALSE )

#ifdef __cplusplus
}
#endif

#endif  //_PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\etc\code.c ===
/*****************************************************************************/
/* CODE.C                                                                    */
/*                                                                           */
/* The FE minidriver with Win95 style callbacks negotiates with the          */
/* Unidriver using a data block MINIDRVENABLEDATA. Minidriver exports a      */
/* callback function MiniDrvEnableDriver() to be recognized by the Unidriver */
/* (so that it can know the minidriver has Win95 style callbacks in it).     */
/*                                                                           */
/* Following files are used by only NT4.0 FE minidriver when driver use      */
/* callback function.                                                        */
/*                                                                           */
/*     gdidefs.inc     mdevice.h       print.h     mindrvrc.h                */
/*     minidriv.h      unidrv.h        udmdi.h     version.h                 */
/*     uniutil.c                                                             */
/*                                                                           */
/* Copyright (C) 1997-     Advanced Peripherals Technologies, Inc.           */
/*                                                                           */
/* <HISTORY>                                                                 */
/*                                                                           */
/*****************************************************************************/
//+---------------------------------------------------------------------------+
//|                         I N C L U D E  F I L E                            |
//+---------------------------------------------------------------------------+
char   *rgchModuleName = "APTiE840";
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"

#include "mindrvrc.h"
#include "minidriv.h"
#include "unidrv.h"

#include "code.h"

#include <windows.h>
#include <windowsx.h>
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvEnableDriver                                           */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA)                   */
/*                                                                           */
/*  Input:     *pEnableData                                                  */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
   if (pEnableData == NULL)
       return FALSE;

   if (pEnableData->cbSize == 0) {
       pEnableData->cbSize = sizeof(MINIDRVENABLEDATA);
       return TRUE;
   }

   if ((pEnableData->cbSize < sizeof(MINIDRVENABLEDATA))
       || (HIBYTE(pEnableData->DriverVersion) < HIBYTE(MDI_DRIVER_VERSION)))
       return FALSE;       // Wrong size and/or version mismatch.

   // Load address of Unidriver provided function
   if (!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvWriteSpoolBuf,(PFN *)&WriteSpoolBuf)
     ||!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvAllocMem,(PFN *)&AllocMem)
     ||!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvFreeMem,(PFN *)&FreeMem))
   {
       // Failed to get Unidriver callback function address.
       return FALSE;
   }
   // Set minidriver's function table to MINIDRVENABLEDATA
   pEnableData->cMiniDrvFn = sizeof(MiniDrvFnTab)/sizeof(MiniDrvFnTab[0]);
   pEnableData->pMinDrvFn = MiniDrvFnTab;

   return TRUE;    // Now we are done.
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvEnablePDEV                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL PASCAL MiniDrvEnablePDEV(LPDV, PGDIINFO)                 */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             pdevcaps                                                      */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL MiniDrvEnablePDEV(LPDV lpdv, PGDIINFO pdevcaps)
{
LPAPDL    lpApdl;

   lpdv->fMdv = FALSE;

   /* allocate memory for A/PDL structure */
   if (!(lpApdl = lpdv->lpMdv = AllocMem(sizeof(APDL))))
       return FALSE;

   /* allocate buffer for image compression */
   if (!(lpApdl->lpCompBuf = AllocMem(MAXIMGSIZE)))
       return FALSE;

   /* allocate buffer for image compression */
   if (!(lpApdl->lpTempBuf = AllocMem(MAXIMGSIZE)))
       return FALSE;

   /* save current resolution */
   lpApdl->ulHorzRes = pdevcaps->ulAspectX;
   lpApdl->ulVertRes = pdevcaps->ulAspectY;

   /* save physical offset of the unwriteable margin */
   lpApdl->ptlPhysOffset.x = pdevcaps->ptlPhysOffset.x;
   lpApdl->ptlPhysOffset.y = pdevcaps->ptlPhysOffset.y;

   /* save physical Size of the entire surface, including unwriteable margin */
   lpApdl->szlPhysSize.cx = pdevcaps->szlPhysSize.cx;
   lpApdl->szlPhysSize.cy = pdevcaps->szlPhysSize.cy;

   lpdv->fMdv = TRUE;

   return TRUE;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvDisablePDEV                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL PASCAL MiniDrvDisablePDEV(LPDV)                          */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL MiniDrvDisablePDEV(LPDV lpdv)
{
   if (lpdv->fMdv){
       FreeMem(((LPAPDL)(lpdv->lpMdv))->lpCompBuf);
       FreeMem(((LPAPDL)(lpdv->lpMdv))->lpTempBuf);
       FreeMem(lpdv->lpMdv);
       lpdv->fMdv = FALSE;
   }

   return TRUE;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    CBFilterGraphics                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    WORD PASCAL CBFilterGraphics(LPDV, LPSTR, WORD)               */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpBuf       points to buffer of graphics data                 */
/*             wLen        length of buffer in bytes                         */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/
WORD PASCAL CBFilterGraphics (LPDV lpdv, LPSTR lpBuf, WORD wLen)
{
LPAPDL lpApdl = lpdv->lpMdv;
ULONG  ulHorzPixel;
WORD   wCompLen;

LPSTR lpSrcImage;
LPSTR lpCompImage;
LPSTR lpTempImage;

   /*_ LPDV */
   lpSrcImage  = lpBuf;
   lpCompImage = lpApdl->lpCompBuf;
   lpTempImage = lpApdl->lpTempBuf;

   wCompLen = BRL_ECmd((LPBYTE)lpSrcImage,
                       (LPBYTE)lpCompImage,
                       (LPBYTE)lpTempImage,
                       wLen);

   // Set the LEN of the DrawBlockImage command
   CmdDrawImgCurrent[4] = (BYTE)((wCompLen + 9) >>8 & 0x00ff);
   CmdDrawImgCurrent[5] = (BYTE)((wCompLen + 9)     & 0x00ff);

   // Set the WIDTH parameter of the DrawBlockImage command
   ulHorzPixel = (ULONG)((wLen / LINE_PER_BAND) * 8); // in bits
   CmdDrawImgCurrent[7] = (BYTE)(ulHorzPixel >> 8 & 0x000000ffL);
   CmdDrawImgCurrent[8] = (BYTE)(ulHorzPixel      & 0x000000ffL);

   // Set the LEN of uncompressed data
   CmdDrawImgCurrent[13] = (BYTE)(wLen >> 8 & 0x000000ff);
   CmdDrawImgCurrent[14] = (BYTE)(wLen      & 0x000000ff);

   // Draw Block Image at Current Position
   WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdDrawImgCurrent, sizeof(CmdDrawImgCurrent));
   WriteSpoolBuf((LPDV)lpdv, lpCompImage, wCompLen);

   return wLen;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputCmd                                                  */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMOutputCmd(LPDV, WORD, LPDWORD)                 */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             wCmdCbId                                                      */
/*             lpdwParams                                                    */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		255
// @Aug/31/98 <-
VOID PASCAL OEMOutputCmd(LPDV lpdv, WORD wCmdCbId, LPDWORD lpdwParams)
{
LPAPDL lpApdl = lpdv->lpMdv;
WORD   wTemp;
WORD   wPhysWidth;
WORD   wPhysHeight;
DWORD  dwXval;
DWORD  dwYval;

   switch(wCmdCbId)
   {
       /*------------------------------------------------------*/
       /* A/PDL start now                                      */
       /*------------------------------------------------------*/
       case PAGECONTROL_BEGIN_DOC:
           /* reset flag of sent Set Physical Paper command */
           lpApdl->fSendSetPhysPaper = FALSE;
           /* initialize flag */
           lpApdl->fBold   = FALSE;
           lpApdl->fItalic = FALSE;
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPage[10] = 0x00;

           /* Send Change Data Stream Command for Enter A/PDL mode */
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdInAPDLMode, 6);
           /* Send A/PLDL start Command */
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdAPDLStart, 2);
           break;
       /*------------------------------------------------------*/
       /* send Page Description command                        */
       /*------------------------------------------------------*/
       case PAGECONTROL_BEGIN_PAGE:
           if(!lpApdl->fSendSetPhysPaper){     // if command has not sent yet

               /* reset duplex mode if fDuplex is FALSE */
               if(!lpApdl->fDuplex)
                   CmdSetPhysPaper[8] = 0x00;      // Duplex OFF

               /* send Set Physical Paper command */
               WriteSpoolBuf((LPDV)lpdv,
                           (LPSTR)CmdSetPhysPaper, sizeof(CmdSetPhysPaper));

               if(lpApdl->ulHorzRes == 600) {      // set unit base
                   CmdSetPhysPage[6] = 0x17;
                   CmdSetPhysPage[7] = 0x70;
               } else {
                   CmdSetPhysPage[6] = 0x0B;
                   CmdSetPhysPage[7] = 0xB8;
               }

               lpApdl->fSendSetPhysPaper = TRUE;   // already sent
           }

           // send Set Physical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdSetPhysPage, sizeof(CmdSetPhysPage));
           // send Begin Physical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdBeginPhysPage, sizeof(CmdBeginPhysPage));
           // send Begin Logical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdBeginLogPage, sizeof(CmdBeginLogPage));
           // send Define Drawing Area command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdDefDrawArea, sizeof(CmdDefDrawArea));
           break;
       case PAGECONTROL_END_PAGE:
           // send End Logical Page command
           WriteSpoolBuf ((LPDV)lpdv,(LPSTR)CmdEndLogPage,  sizeof(CmdEndLogPage));
           // send End Physical Page command
           WriteSpoolBuf ((LPDV)lpdv,(LPSTR)CmdEndPhysPage, sizeof(CmdEndPhysPage));
           break;

       case PAGECONTROL_ABORT_DOC:
       case PAGECONTROL_END_DOC:
           // send A/PDL End command
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdAPDLEnd, sizeof(CmdAPDLEnd));
           break;
       /*------------------------------------------------------*/
       /* save print direction                                 */
       /*------------------------------------------------------*/
       case PAGECONTROL_POTRAIT:           // 36
           lpApdl->fOrientation = TRUE;
           break;
       case PAGECONTROL_LANDSCAPE:         // 37
           lpApdl->fOrientation = FALSE;
           break;
       /*------------------------------------------------------*/
       /* set Drawing Area into SetPhysPaperDesc command       */
       /*------------------------------------------------------*/
       case PHYS_PAPER_A3:                 // 50
       case PHYS_PAPER_A4:                 // 51
       case PHYS_PAPER_B4:                 // 54
       case PHYS_PAPER_LETTER:             // 57
       case PHYS_PAPER_LEGAL:              // 58
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           break;

       case PHYS_PAPER_B5:                 // 55
       case PHYS_PAPER_A5:                 // 52
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off
           break;

       case PHYS_PAPER_POSTCARD:           // 59
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           /* if paper is Postcard, papersource is always Front Tray */
           CmdSetPhysPaper[6] = 0x00;      // select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off
           break;

       case PHYS_PAPER_UNFIXED:            // 60
           /* if paper is Unfixed, papersource is always Front Tray */
           CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off

           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           CmdSetPhysPaper[12] = 0x00;     // UnitBase : 10 inch

           if(lpApdl->ulHorzRes == 600) {  // set logical unit
               CmdSetPhysPaper[13] = 0x17;
               CmdSetPhysPaper[14] = 0x70;
           } else {
               CmdSetPhysPaper[13] = 0x0B;
               CmdSetPhysPaper[14] = 0xB8;
           }

           if(lpApdl->fOrientation){    // portrait
               wPhysWidth  = (WORD)lpApdl->szlPhysSize.cx;
               wPhysHeight = (WORD)lpApdl->szlPhysSize.cy;
           } else {                     // landscape
               wPhysWidth  = (WORD)lpApdl->szlPhysSize.cy;
               wPhysHeight = (WORD)lpApdl->szlPhysSize.cx;
           }

           CmdSetPhysPaper[15] = (BYTE)(wPhysWidth  >> 8 & 0x00ff);
           CmdSetPhysPaper[16] = (BYTE)(wPhysWidth       & 0x00ff);
           CmdSetPhysPaper[17] = (BYTE)(wPhysHeight >> 8 & 0x00ff);
           CmdSetPhysPaper[18] = (BYTE)(wPhysHeight      & 0x00ff);

           break;
       /*------------------------------------------------------*/
       /* set Paper Tray into SetPhysPaperDesc command         */
       /*------------------------------------------------------*/
       case PAPER_SRC_FTRAY:
           CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS1:
           CmdSetPhysPaper[6] = 0x01;      // Select Cassette 1
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS2:
           CmdSetPhysPaper[6] = 0x02;      // Select Cassette 2
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS3:
           CmdSetPhysPaper[6] = 0x03;      // Select Cassette 3
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       /*------------------------------------------------------*/
       /* set Auto Tray Mode into SetPhysPaperDesc command     */
       /*------------------------------------------------------*/
       case PAPER_DEST_SCALETOFIT_ON:      // 25
           lpApdl->fScaleToFit = TRUE;
           CmdSetPhysPaper[7] = 0x02;
           break;
       case PAPER_DEST_SCALETOFIT_OFF:     // 26
           lpApdl->fScaleToFit = FALSE;
           CmdSetPhysPaper[7] = 0x00;
           break;
       /*------------------------------------------------------*/
       /* set Duplex Mode into SetPhysPaperDesc command        */
       /*------------------------------------------------------*/
       case PAGECONTROL_DUPLEX_UPDOWN:
           lpApdl->fDuplex = TRUE;
           CmdSetPhysPaper[8] = 0x01;      // Up Side Down
           break;
       case PAGECONTROL_DUPLEX_RIGHTUP:
           lpApdl->fDuplex = TRUE;
           CmdSetPhysPaper[8] = 0x02;      // Right Side Up
           break;
       case PAGECONTROL_DUPLEX_OFF:
           lpApdl->fDuplex = FALSE;
           break;
       /*------------------------------------------------------*/
       /* set Toner Save into SetPhysPage command              */
       /*------------------------------------------------------*/
       case TONER_SAVE_OFF:                // 100
           CmdSetPhysPage[10] = 0x00;      // off
           break;
       case TONER_SAVE_DARK:               // 101
           CmdSetPhysPage[10] = 0x02;      // dark
           break;
       case TONER_SAVE_LIGHT:              // 102
           CmdSetPhysPage[10] = 0x01;      // right
           break;
       /*------------------------------------------------------*/
       /* set Copy Count to SetPhysPaperDesc command           */
       /*------------------------------------------------------*/
       case PAGECONTROL_MULTI_COPIES:
// @Aug/31/98 ->
           if(MAX_COPIES_VALUE < *lpdwParams)
               CmdSetPhysPaper[9] = MAX_COPIES_VALUE;
           else if(1 > *lpdwParams)
               CmdSetPhysPaper[9] = 1;
           else
               CmdSetPhysPaper[9] = (BYTE)*lpdwParams;
// @Aug/31/98 <-
           break;
       /*------------------------------------------------------*/
       /* send Set Character Attribute with ornament           */
       /*------------------------------------------------------*/
       case BOLD_ON:
           if (!lpApdl->fItalic)   // bold only
               WriteSpoolBuf(lpdv, CmdBoldOn, sizeof(CmdBoldOn));
           else                    // bold and italic
               WriteSpoolBuf(lpdv, CmdBoldItalicOn, sizeof(CmdBoldItalicOn));

           lpApdl->fBold = TRUE;
           break;
       case ITALIC_ON:
           if (!lpApdl->fBold)     // italic only
               WriteSpoolBuf(lpdv, CmdItalicOn, sizeof(CmdItalicOn));
           else                    // italic and bold
               WriteSpoolBuf(lpdv, CmdBoldItalicOn, sizeof(CmdBoldItalicOn));

           lpApdl->fItalic = TRUE;
           break;
       case BOLD_OFF:
       case ITALIC_OFF:
           lpApdl->fItalic = lpApdl->fBold = FALSE;
           WriteSpoolBuf(lpdv, CmdBoldItalicOff, sizeof(CmdBoldItalicOff));
           break;
       /*------------------------------------------------------*/
       /*                                                      */
       /*------------------------------------------------------*/
       case X_ABS_MOVE:
           wTemp = (WORD)*lpdwParams / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
           CmdGivenHoriPos[2] = (BYTE) (wTemp >> 8 & 0x00ff);
           CmdGivenHoriPos[3] = (BYTE) (wTemp & 0x00ff);
           /* Send SetGivenHorizontalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenHoriPos, sizeof(CmdGivenHoriPos));
           break;
       case Y_ABS_MOVE:
           wTemp = (WORD)*lpdwParams;
           CmdGivenVerPos[2] = (BYTE) (wTemp >> 8 & 0x00ff);
           CmdGivenVerPos[3] = (BYTE) (wTemp & 0x00ff);
           /* Send SetGivenVerticalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenVerPos, sizeof(CmdGivenVerPos));
           break;
       case CR_EMULATION:
           CmdGivenVerPos[2] = 0x00;
           CmdGivenVerPos[3] = 0x00;
           /* Send SetGivenVerticalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenVerPos, sizeof(CmdGivenVerPos));
           break;
       case XY_ABS_MOVE:
           if(lpApdl->ulHorzRes == 300) {
               dwXval = (DWORD) lpdwParams[0] / 2;
               dwYval = (DWORD) lpdwParams[1] / 2;
           } else {
               dwXval = (DWORD) lpdwParams[0];
               dwYval = (DWORD) lpdwParams[1];
           } /* endif */
           CmdSetGivenPos[2] = (BYTE)(dwXval >> 8 & 0x00ff);
           CmdSetGivenPos[3] = (BYTE)(dwXval      & 0x00ff);
           CmdSetGivenPos[4] = (BYTE)(dwYval >> 8 & 0x00ff);
           CmdSetGivenPos[5] = (BYTE)(dwYval      & 0x00ff);
           WriteSpoolBuf(lpdv, CmdSetGivenPos, sizeof(CmdSetGivenPos));
           break;
   }
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputChar                                                 */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMOutputChar(LPDV, LPSTR, WORD, SHORT)           */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpstr                                                         */
/*             len                                                           */
/*             rcID                                                          */
/*                                                                           */
/*  Output:    short                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID PASCAL OEMOutputChar(LPDV lpdv, LPSTR lpstr, WORD len, SHORT rcID)
{
LPAPDL lpApdl = lpdv->lpMdv;

   if (rcID){  // "rc != 0" means font is device font.
       CmdPrnStrCurrent[2] = (BYTE)((len+1) >> 8 & 0x00ff);
       CmdPrnStrCurrent[3] = (BYTE)((len+1)      & 0x00ff);

       /* send Print Character String at Current Position command */
       WriteSpoolBuf(lpdv, (LPSTR)CmdPrnStrCurrent, sizeof(CmdPrnStrCurrent));
       WriteSpoolBuf(lpdv, lpstr, len);

       if(len <= 2) {
           /* send Move Position Horizontally command */
           CmdMoveHoriPos[2] = (BYTE)((lpApdl->wWidths * len) >> 8 & 0x00ff);
           CmdMoveHoriPos[3] = (BYTE)((lpApdl->wWidths * len)      & 0x00ff);
           WriteSpoolBuf(lpdv, (LPSTR)CmdMoveHoriPos, sizeof(CmdMoveHoriPos));
       }
   }
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendScalableFontCmd                                        */
/*                                                                           */
/*  Function:  send A/PDL-style font selection command.                      */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMSendScalableFontCmd(LPDV, LPCD, LPFONTINFO)    */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpcd        offset to the command heap                        */
/*             lpFont      deveice font information                          */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID PASCAL OEMSendScalableFontCmd(LPDV lpdv, LPCD lpcd, LPFONTINFO lpFont)
{
LPSTR  lpcmd;
short  ocmd;
WORD   wCount;
BYTE   rgcmd[CCHMAXCMDLEN];    // build command here
LPAPDL lpApdl = lpdv->lpMdv;
WORD   wHeight;
WORD   wWidth;

   if (!lpcd || !lpFont)
       return;

   // be careful about integer overflow.
   lpcmd = (LPSTR)(lpcd+1);
   ocmd = 0;

   for (wCount = 0; wCount < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
       if (lpcmd[wCount] == '#' && lpcmd[wCount + 1] == 'H'){      // height
           wHeight = (lpFont->dfPixHeight - lpFont->dfInternalLeading);
           rgcmd[ocmd++] = HIBYTE(wHeight);
           rgcmd[ocmd++] = LOBYTE(wHeight);
           wCount += 2;
       }
       else {
           if (lpcmd[wCount] == '#' && lpcmd[wCount + 1] == 'W'){  // width
               if (lpFont->dfPixWidth > 0){
                   wWidth = lpFont->dfMaxWidth;
                   rgcmd[ocmd++] = HIBYTE(wWidth);
                   rgcmd[ocmd++] = LOBYTE(wWidth);

                   // move current position for device font in OEMOutputCHar
                   lpApdl->wWidths = lpFont->dfAvgWidth;
               }
               wCount += 2;
           }
           else
               rgcmd[ocmd++] = lpcmd[wCount++];
       }

   WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMScaleWidth                                                 */
/*                                                                           */
/*  Function:  return the scaled width which is calcualted based on the      */
/*             assumption that APDL assumes 72 points in one 1 inch.         */
/*                                                                           */
/*  Syntax:    SHORT PASCAL OEMScaleWidth(SHORT, SHORT, SHORT, SHORT, SHORT) */
/*                                                                           */
/*  Input:     width           in units specified by 'masterUnits'           */
/*             masterUnits                                                   */
/*             newHeight       in units specified by 'vRes'                  */
/*             vRes            height device units                           */
/*             hRes            width device units                            */
/*                                                                           */
/*  Output:    short                                                         */
/*                                                                           */
/*  Notice:    <extent> : <font units> = <base Width> : <hRes>               */
/*             <base width> : <etmMasterHeight> = <newWidth> : <newHeight>   */
/*             <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>  */
/*             <newWidth> = (<extent> * <hRes> * <newHeight>) /              */
/*                                             (<etmMasterUnits> * <vRes>)   */
/*                                                                           */
/*****************************************************************************/
SHORT PASCAL OEMScaleWidth(SHORT width, 
                   SHORT masterUnits, SHORT newHeight, SHORT vRes, SHORT hRes)
{
DWORD  newWidth10;
short  newWidth;

   // assert that hRes == vRes to avoid overflow problem.
   if (vRes != hRes)
       return 0;

   newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
   newWidth10 /= (DWORD)masterUnits;

   // we multiplied 10 first in order to maintain the precision of
   // the width calcution. Now convert it back and round to the
   // nearest integer.
   newWidth = (short)((newWidth10 + 5) / 10);

   return newWidth;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    SetDrawArea                                                   */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BYTE PASCAL SetDrawArea(LPDV, WORD)                           */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             wCmdCbId                                                      */
/*                                                                           */
/*  Output:    BYTE                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BYTE PASCAL SetDrawArea(LPDV lpdv, WORD wCmdCbId)
{
LPAPDL    lpApdl = lpdv->lpMdv;
WORD       wWidth;
WORD       wHeight;
BYTE       bIndex;

   if(wCmdCbId != PHYS_PAPER_UNFIXED){
       bIndex = (BYTE)(wCmdCbId - PAPERSIZE_MAGIC);
       wWidth = phySize[bIndex].wWidth / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
       wHeight= phySize[bIndex].wHeight / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
   } else {
       bIndex = 0x7f;
       if(lpApdl->ulHorzRes == 600){
           if(lpApdl->fOrientation){   // portrait
               wWidth = (WORD)lpApdl->szlPhysSize.cx - (0x5e * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cy - (0x5e * 2);
           } else {                    // landscape
               wWidth = (WORD)lpApdl->szlPhysSize.cy - (0x5e * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cx - (0x5e * 2);
           }
       } else {
           if(lpApdl->fOrientation){   // portrait
               wWidth = (WORD)lpApdl->szlPhysSize.cx - (0x2f * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cy - (0x2f * 2);
           } else {                    // landscape
               wWidth = (WORD)lpApdl->szlPhysSize.cy - (0x2f * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cx - (0x2f * 2);
           }
       }
   }

   /* set value of width, height into DefineDrawingArea command */
   CmdDefDrawArea[9]  = (BYTE)(wWidth  >> 8 & 0x00ff);
   CmdDefDrawArea[10] = (BYTE)(wWidth       & 0x00ff);
   CmdDefDrawArea[11] = (BYTE)(wHeight >> 8 & 0x00ff);
   CmdDefDrawArea[12] = (BYTE)(wHeight      & 0x00ff);

   /* set value of Origin-X, Y into DefineDrawingArea command */
   if(lpApdl->ulHorzRes == 600){
       CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
       CmdDefDrawArea[6] = CmdDefDrawArea[8] = 0x5e;
   } else {
       CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
       CmdDefDrawArea[6] = CmdDefDrawArea[8] = 0x2f;
   }

   /* set Media Origin into DefineDrawingArea command */
   if(lpApdl->fOrientation)    // portrait
       CmdDefDrawArea[15] = 0x00;
   else {                      // landscape
       if( wCmdCbId==50 || wCmdCbId==54 || wCmdCbId==61)
           CmdDefDrawArea[15] = 0x01;  // A3 or B4 or Unfixed
       else
           CmdDefDrawArea[15] = 0x03;
   }

   return bIndex;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    BRL_Ecmd                                                      */
/*                                                                           */
/*  Function:  ByteRunLength(HBP) Compression Routine                        */
/*                                                                           */
/*  Syntax:    WORD PASCAL BRL_Ecmd(LPBYTE, LPBYTE, LPBYTE, WORD)            */
/*                                                                           */
/*  Input:     lpbSrc                                                        */
/*             lpbTgt                                                        */
/*             lpbTmp                                                        */
/*             len                                                           */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
WORD PASCAL BRL_ECmd(LPBYTE lpbSrc, LPBYTE lpbTgt, LPBYTE lpbTmp, WORD len)
{

BYTE   bRCnt  = 1;                     // repeating byte counter
BYTE   bNRCnt = 0;                     // non-repeating byte counter
BYTE   bSaveRCnt;
WORD   i = 0, j = 0, k = 0, l = 0;     // movement trackers
char   Go4LastByte = TRUE;             // flag to get last byte

   /* initialize data */
   _fmemcpy(lpbTmp,(LPBYTE)lpbSrc,len);

   /* start compression routine - ByteRunLength Encoding */
   do {
       if(lpbSrc[i] != (lpbSrc[i+1])) {    // non-repeating data?
           while(((lpbTmp[i] != (lpbTmp[i+1]))
                               && ((i+1) < len)) && (bNRCnt < NRPEAK)) {
               bNRCnt++;                   // if so, how many?
               i++;
           }

           /* if at last element but less than NRPEAK value */
           if(((i+1)==len) && (bNRCnt<NRPEAK)) {
               bNRCnt++;                       // inc count for last element
               Go4LastByte = FALSE;            // no need to go back
           } else
               /* if at last BYTE, but before that, NRPEAK value has been reached */
               if(((i+1)==len) && ((bNRCnt)==NRPEAK))
                   Go4LastByte = TRUE;         // get the last BYTE

           /* assign the value for Number of Non-repeating bytes */
           lpbTgt[j] = bNRCnt-1;               // subtract one for WinP's case
           j++;                                // update tracker

           /* afterwards...write the Raw Data */
           for (l=0; l<bNRCnt;l++) {
               lpbTgt[j] = lpbSrc[k];
               k++;
               j++;
           }

           /* reset counter */
           bNRCnt = 0;
       } else {                                // end of Non-repeating data
                                               // data is repeating
           while(((lpbTmp[i]==(lpbTmp[i+1])) && ((i+1)<len)) && (bRCnt<RPEAK)) {
               bRCnt++;
               i++;
           }

           /* Convert to Two's Complement */
           bSaveRCnt   = bRCnt;                // save original value
           bRCnt = (BYTE) 0 - bRCnt;

           /* Write the Number of Repeating Data */
           lpbTgt[j] = bRCnt + 1;              // add one for WinP's case
           j++;                                // go to next element

           /* afterwards...write the Repeating data */
           lpbTgt[j] = lpbSrc[k];
           j++;

           /* update counters */
           k += bSaveRCnt;
           bRCnt  = 1;
           i     += 1;

           /* check if last element has been reached */
           if (i==len)
               Go4LastByte=FALSE;              // if so, no need to go back
       }                                       // end of Repeating data
   } while (Go4LastByte);                      // end of Compression

   return ( j );
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    fnOEMGetFontCmd                                               */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL fnOEMGetFontCmd(LPDV, WORD, PVOID, BOOL, PBYTE, PWORD)   */
/*                                                                           */
/*  InputF    lpdv                                                          */
/*             wCmdCbId                                                      */
/*             lpFont                                                        */
/*             fSelect                                                       */
/*             lpBuf                                                         */
/*             lpwSize                                                       */
/*                                                                           */
/*  OutputF                                                                 */
/*                                                                           */
/*  NoticeF                                                                 */
/*                                                                           */
/*  HistoryF  1996.05.20  Ver 1.00                                          */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL OEMGetFontCmd(LPDV lpdv, WORD wCmdCbId, PVOID lpFont, 
                                   BOOL fSelect, PBYTE lpBuf, PWORD lpwSize)
{
return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\apdlres\etc\code.h ===
/*****************************************************************************/
/* CODE.H                                                                    */
/*                                                                           */
/* Copyright (C) 1997-     Advanced Peripherals Technologies, Inc.           */
/*                                                                           */
/* <HISTORY>                                                                 */
/*                                                                           */
/*****************************************************************************/
/*--------------------------------------------------------------------------*/
/*                        D E F I N E  V A L U E                            */
/*--------------------------------------------------------------------------*/
#define PAPER_SRC_FTRAY                20
#define PAPER_SRC_CAS1                 21
#define PAPER_SRC_CAS2                 22
#define PAPER_SRC_CAS3                 23
#define PAPER_SRC_AUTO                 24  //Not use by NT driver
#define PAPER_DEST_SCALETOFIT_ON       25
#define PAPER_DEST_SCALETOFIT_OFF      26

#define PAGECONTROL_BEGIN_DOC          30
#define PAGECONTROL_BEGIN_PAGE         31
#define PAGECONTROL_END_DOC            32
#define PAGECONTROL_END_PAGE           33
#define PAGECONTROL_DUPLEX_OFF         34
#define PAGECONTROL_ABORT_DOC          35
#define PAGECONTROL_POTRAIT            36
#define PAGECONTROL_LANDSCAPE          37
#define PAGECONTROL_MULTI_COPIES       38
#define PAGECONTROL_DUPLEX_UPDOWN      39
#define PAGECONTROL_DUPLEX_RIGHTUP     40

#define PAPERSIZE_MAGIC                50  // this ID - 50 = Actual ID of A/PDL
#define PHYS_PAPER_A3                  50
#define PHYS_PAPER_A4                  51
#define PHYS_PAPER_A5                  52
#define PHYS_PAPER_A6                  53  // Reserved
#define PHYS_PAPER_B4                  54
#define PHYS_PAPER_B5                  55
#define PHYS_PAPER_B6                  56  // Reserved
#define PHYS_PAPER_LETTER              57
#define PHYS_PAPER_LEGAL               58
#define PHYS_PAPER_POSTCARD            59
#define PHYS_PAPER_EXECUTIVE           60  // Reserved
#define PHYS_PAPER_UNFIXED             61

#define X_ABS_MOVE                     70
#define Y_ABS_MOVE                     71
#define XY_ABS_MOVE                    78
#define CR_EMULATION                   79

#define BOLD_ON                        72
#define BOLD_OFF                       73
#define ITALIC_ON                      74
#define ITALIC_OFF                     75

#define RESOLUTION_300                 76
#define RESOLUTION_600                 77

#define TONER_SAVE_OFF                 100
#define TONER_SAVE_DARK                101
#define TONER_SAVE_LIGHT               102

#define MASTER_UNIT                    600
#define LINE_PER_BAND                  32
#define CCHMAXCMDLEN                   128
#define MAXIMGSIZE                     0xF000

#define NRPEAK                         0x7F
#define RPEAK                          0x80
/*--------------------------------------------------------------------------*/
/*                       S T R U C T U R E  D E F I N E                     */
/*--------------------------------------------------------------------------*/
typedef struct tagAPDL {
   ULONG   ulHorzRes;          // width of the physical surface
   ULONG   ulVertRes;          // height of the physical surface
   SIZEL   szlPhysSize;        // size of unwriteable margin
   POINTL  ptlPhysOffset;      // size of entire surface with unwriteable margin
   LPSTR   lpCompBuf;          // buffer for compressed data  
   LPSTR   lpTempBuf;          // temp buffer for compression
   BOOL    fBold;              // TRUE = device font is bold
   BOOL    fItalic;            // TRUE = device font is italic
   BOOL    fSendSetPhysPaper;  // flag for sending set physical paper command
   WORD    wPageCount;         // for send Eject & Print physical paper command
   BOOL    fDuplex;            // TRUE = duplex mode is selected
   BOOL    fScaleToFit;        // for set auto tray mode in Set Physical Paper
   BOOL    fOrientation;       // for set media origin in Define Drawing Area
   WORD    wWidths;            // move current position afer print device font
} APDL, FAR * LPAPDL;

typedef struct tagPAPER {
   WORD    wWidth;
   WORD    wHeight;
} PHYSIZE, FAR * LPPHYSIZE;
//+---------------------------------------------------------------------------+
//|                    F U N C T I O N  P R O T O T Y P E                     |
//+---------------------------------------------------------------------------+
BOOL  PASCAL MiniDrvEnablePDEV(LPDV, PGDIINFO);
BOOL  PASCAL MiniDrvDisablePDEV(LPDV);
WORD  PASCAL CBFilterGraphics(LPDV, LPSTR, WORD);
VOID  PASCAL OEMOutputCmd(PVOID, WORD, PDWORD);
BOOL  PASCAL OEMGetFontCmd(PVOID, WORD, PVOID, BOOL, PBYTE, PWORD);
SHORT PASCAL OEMScaleWidth(SHORT, SHORT, SHORT, SHORT, SHORT);
VOID  PASCAL OEMSendScalableFontCmd(PVOID, LPCD, LPFONTINFO);
BYTE  PASCAL IsDBCSLeadBytePAGES(BYTE);
VOID  PASCAL OEMOutputChar(PVOID, PVOID, WORD, SHORT);
BYTE  PASCAL SetDrawArea(LPDV, WORD);
WORD  PASCAL BRL_ECmd(LPBYTE, LPBYTE, LPBYTE, WORD);
/*--------------------------------------------------------------------------*/
/*                           G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/
/*======================= P A P E R  S I Z E T A B L E =====================*/
PHYSIZE phySize[12] = {
//      Width    Height        Physical paper size for 600dpi
       (0x1AAC),(0x2604),      // A3 1B66 x 26C4
       (0x12A5),(0x1AAC),      // A4 1362 x 1B66
       (0x0CEC),(0x12A4),      // A5
       (0x0000),(0x0000),      // A6 (Reserved)
       (0x16FA),(0x20DA),      // B4 17B8 x 2196
       (0x100F),(0x16FA),      // B5 10CE x 17B8
       (0x0000),(0x0000),      // B6 (Reserved)
       (0x087E),(0x0CEC),      // Post Card 93C x DAA (Origin is EE)
       (0x1330),(0x190C),      // Letter 13CE x 19C8
       (0x1330),(0x2014),      // Legal
       (0x0000),(0x0000),      // Executive (Reserved)
       (0x0000),(0x0000)       // Unfixed
};
/*==================== A / P D L  C O M M A N D  S T R I N G ===============*/
BYTE CmdInAPDLMode[]    = {0x1B,0x7E,0x12,0x00,0x01,0x07};
BYTE CmdAPDLStart[]     = {0x1C,0x01};                 // A/PDL start
BYTE CmdAPDLEnd[]       = {0x1C,0x02};                 // A/PDL end
BYTE CmdBeginPhysPage[] = {0x1C,0x03};                 // Begin Physical Page
BYTE CmdEndPhysPage[]   = {0x1C,0x04};                 // End Physical Page
BYTE CmdBeginLogPage[]  = {0x1C,0x05};                 // Begin Logical page
BYTE CmdEndLogPage[]    = {0x1C,0x06};                 // End Logical Page
BYTE CmdEjectPhysPaper[]= {0x1C,0x0F};                 // Print&Eject Phys Paper
BYTE CmdMoveHoriPos[]   = {0x1C,0x21,0x00,0x00};       // Horizontal Relative
BYTE CmdGivenHoriPos[]  = {0x1C,0x23,0x00,0x00};       // Horizontal Absolute
BYTE CmdGivenVerPos[]   = {0x1C,0x24,0x00,0x00};       // Vertical Absolute
BYTE CmdSetGivenPos[]   = {0x1C,0x40,0x00,0x00,0x00,0x00};
BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03};  // Print String
BYTE CmdBoldItalicOn[]  = {0x1C,0xA5,0x08,0x04,0x06,0x02,0x30,0x00,0x00,0x00,0x00};
BYTE CmdBoldOn[]        = {0x1C,0xA5,0x04,0x04,0x02,0x02,0x20};
BYTE CmdItalicOn[]      = {0x1c,0xa5,0x08,0x04,0x06,0x02,0x10,0x00,0x00,0x00,0x00};
BYTE CmdBoldItalicOff[] = {0x1c,0xa5,0x04,0x04,0x02,0x02,0x00};

BYTE CmdSetPhysPaper[]  = {0x1C,0xA0,          // Set Physical Paper
                           0x10,               // length
                           0x01,               // SubCmd Basic Characteristics
                           0x05,               // SubCmdLength
                           0x01,               // Paper Size
                           0x01,               // PaperTray
                           0x00,               // AutoTrayMode
                           00,                 // Duplex Mode
                           0x01,               // Copy Count
                           0x02,               // SubCmd Set Unfixed Paper Size
                           0x07,               // SubCmdLength
                           00,                 // UnitBase
                           00,00,              // Logical Unit
                           00,00,              // Width
                           00,00};             // Height

BYTE CmdSetPhysPage[]   = {0x1C,0xA1,          // Set Physical Page
                           0x0D,               // Length
                           0x01,               // SubCmd Resolution
                           0x03,               // SubCmdLength
                           00,                 // Unit Base of 10
                           0x0B,0xB8,          // and Logical Unit Res of 3000
                           0x02,               // SubCmd Toner Save
                           0x01,               // SubCmdLength
                           00,                 // Toner Save OFF
                           0x03,               // SubCmd N-Up
                           0x03,               // SubCmdLength 
                           00,00,00};          // N-Up off 

BYTE CmdDefDrawArea[]   = {0x1C,0xA2,          // Define Drawing Area
                           0x0D,               // length
                           0x01,               // SubCmd origin width,height
                           0x08,               // SubCmdLength
                           0x00,0x77,          // origin X
                           0x00,0x77,          // origin Y
                           00,00,              // width
                           00,00,              // height
                           0x02,               // SubCmd Media Origin
                           0x01,               // SubCmdLength
                           00};                // Portrait

BYTE CmdDrawImgCurrent[]= {0x1C,0xE1,          // Draw Image at current position
                           00,00,00,00,        // length
                           01,                 // Compress method : 0x01 = BRL
                           00,00,              // actual width of image
                           00,LINE_PER_BAND,   // actual height of image
                           00,00,00,00};       // length of raw image

UNIDRVFN_WRITESPOOLBUF WriteSpoolBuf;
UNIDRVFN_ALLOCMEM      AllocMem;
UNIDRVFN_FREEMEM       FreeMem;

DRVFN MiniDrvFnTab[] =
{
   {INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV},
   {INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV},
   {INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics},
   {INDEX_OEMOutputCmd,            (PFN)OEMOutputCmd},
   {INDEX_OEMGetFontCmd,           (PFN)OEMGetFontCmd},
   {INDEX_OEMOutputChar,           (PFN)OEMOutputChar},
   {INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd},
   {INDEX_OEMScaleWidth1,          (PFN)OEMScaleWidth}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\capplid.h ===
#ifndef _CAPPLID_H
#define _CAPPLID_H

// Callback ID's
#define RES_SELECTRES_240        14
#define RES_SELECTRES_400        15

#define CM_XM_ABS                20
#define CM_YM_ABS                22

#define AUTOFEED                 30

#define PS_SEGMENT               40
#define PS_A3                    40
#define PS_B4                    41
#define PS_A4                    42
#define PS_B5                    43
#define PS_LETTER                44
#define PS_POSTCARD              45
#define PS_MPF                   46
#define PS_A5                    47
#define PS_FREE                  48

#define CBID_PORT                50
#define CBID_LAND                51

#define PRN_2000                 60
#define PRN_2000W                61
#define PRN_3000                 62

#endif // _CAPPLID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include "strsafe.h"    // Security-Code 2002.3.6

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include "strsafe.h"         // Security-Code 2002.3.6

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\capplres.c ===
// =========================================================================
//
//        CASIO PAGEPRESTO Universal Printer Driver for MS-Windows NT 5.0
//
// =========================================================================

//// CAPPLERES.C file for CASIO PAGEPRESTO CAPPL/Base Common DLL


#include "pdev.h"
#include "capplid.h"
#include "strsafe.h"         // Security-Code 2002.3.6

#if DBG
#  include "mydbg.h"
#endif

#define CCHMAXCMDLEN 256

#define STR_SELECTRES_240_3K \
        "\x1B[1\x00\x03=5\x00\x1B[1\x00\x06=30240"
#define STR_SELECTRES_400_3K \
        "\x1B[1\x00\x03=5\x00\x1B[1\x00\x06=30400"

// ===== PaperSize =====
#define STR_LETTER_2000 \
        "\x1B@0\x05\x1B@A\x07\x1B@B\x07"
#define STR_LETTER_3000 \
        "\x1B[1\x00\x03@06\x1B[1\x00\x03@18"

#define STR_A3_3000 \
        "\x1B[1\x00\x03@00\x1B[1\x00\x03@10"

#define STR_A4_2000 \
        "\x1B@0\x03\x1B@A\x05\x1B@B\x05"
#define STR_A4_3000 \
        "\x1B[1\x00\x03@02\x1B[1\x00\x03@13"

#define STR_B4_2000 \
        "\x1B@0\x02\x1B@B\x04"
#define STR_B4_3000 \
        "\x1B[1\x00\x03@01\x1B[1\x00\x03@11"

#define STR_B5_2000 \
        "\x1B@0\x04\x1B@A\x06\x1B@B\x06"
#define STR_B5_3000 \
        "\x1B[1\x00\x03@04\x1B[1\x00\x03@14"

#define STR_A5_3000 \
        "\x1B[1\x00\x03@05\x1B[1\x00\x03@16"

#define STR_POSTCARD_2000 \
        "\x1B@0\x0C\x1B@A\x0E\x1B@B\x0E"
#define STR_POSTCARD_3000 \
        "\x1B[1\x00\x03@0;\x1B[1\x00\x03@1="

#define STR_FREE_2000 \
        "\x1B@0\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x1B@A\x03\x00\x00\x00\x00" \
        "\x1B@B\x03\x00\x00\x00\x00"
#define STR_FREE_3000 \
        "\x1B@0\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x1B[1\x00\x06@2\x00\x00\x00\x00" \
        "\x1B[1\x00\x03@1\x3F"

// ===== MPF Setting =====
#define OPT_NOSET         "Option1"
#define OPT_A3            "Option2"
#define OPT_B4            "Option3"
#define OPT_A4            "Option4"
#define OPT_B5            "Option5"
#define OPT_LETTER        "Option6"
#define OPT_POSTCARD      "Option7"
#define OPT_A5            "Option8"


#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define PARAM(p,n) \
    (*((p)+(n)))

#define MASTER_UNIT 1200

// ===== AutoFeed =====
const
static BYTE AutoFeed_2000[] = {    /* Auto Select */
                    0x33,        /* A3 */
                    0x34,        /* B4 */
                    0x35,        /* A4 */
                    0x36,        /* B5 */
                    0x33,        /* Letter */
                    0x33,        /* PostCard */
                    0x33,        /* MPF */
                    0x33         /* A5 */
};

const
static BYTE AutoFeed_3000[] = {    /* Auto Select */
                    0x38,        /* A3 */
                    0x34,        /* B4 */
                    0x35,        /* A4 */
                    0x36,        /* B5 */
                    0x37,        /* Letter */
                    0x37,        /* PostCard */
                    0x37,        /* MPF */
                    0x3B         /* A5 */
};



BOOL
BInitOEMExtraData(
        POEMUD_EXTRADATA pOEMExtra
    )
{
    // Initialize OEM Extra data.

    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}


BOOL
BMergeOEMExtraData(
        POEMUD_EXTRADATA pdmIn,
        POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;

    VERBOSE(("OEMEnablePDEV - %08x\n", pdevobj));

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->sRes = MASTER_UNIT / 240; // Default to 240dpi
    pOEM->jFreePaper = 0;          // Default to No(0)
    // misc initializations, if any

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    VERBOSE(("OEMDisablePDEV - %08x\n", pdevobj));

    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOld, pNew;

    VERBOSE(("OEMResetPDEV - %08x, %08x\n", pdevobjOld, pdevobjNew));

    if (NULL == (pOld = (PMYPDEV)pdevobjOld->pdevOEM) ||
        NULL == (pNew = (PMYPDEV)pdevobjNew->pdevOEM)) {
        ERR(("Invalid PDEV\n"));
        return FALSE;
    }

    *pNew = *pOld;
    return TRUE;
}


static
VOID
EmitJobSetup(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM
) {
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen = 0;
    BYTE jOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;

    if (pOEM->dwGeneral & FG_HAS_EMUL) {
        // Alster emulation mode setting
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = 'i';
        cmdbuf[wlen++] = 'w';
        cmdbuf[wlen++] = '0';
    }

    WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

    if (!DRVGETDRIVERSETTING(
            pdevobj, "MPFSetting", jOutput,
            sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        WARNING(("DrvGetDriverSetting(1) Failed\n"));
        pOEM->jMPFSetting = MPF_NOSET;
    } else {
        if (!strcmp(jOutput, OPT_A3)) {
            pOEM->jMPFSetting = MPF_A3;
            VERBOSE(("MPF_A3\n"));
        } else if (!strcmp(jOutput, OPT_B4)) {
            pOEM->jMPFSetting = MPF_B4;
            VERBOSE(("MPF_B4\n"));
        } else if (!strcmp(jOutput, OPT_A4)) {
            pOEM->jMPFSetting = MPF_A4;
            VERBOSE(("MPF_A4\n"));
        } else if (!strcmp(jOutput, OPT_B5)) {
            pOEM->jMPFSetting = MPF_B5;
            VERBOSE(("MPF_B5\n"));
        } else if (!strcmp(jOutput, OPT_A5)) {
            pOEM->jMPFSetting = MPF_A5;
            VERBOSE(("MPF_A5\n"));
        } else if (!strcmp(jOutput, OPT_LETTER)) {
            pOEM->jMPFSetting = MPF_LETTER;
            VERBOSE(("MPF_LETTER\n"));
        } else if (!strcmp(jOutput, OPT_POSTCARD)) {
            pOEM->jMPFSetting = MPF_POSTCARD;
            VERBOSE(("MPF_POSTCARD\n"));
        } else {
            pOEM->jMPFSetting = MPF_NOSET;
            VERBOSE(("MPF_NOSET\n"));
        }
    }
}

static
VOID
LoadPaperSelectCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM,
    INT iPaperID
) {

    switch (iPaperID) {
    case PS_LETTER:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_LETTER)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_LETTER_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_LETTER_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_LETTER)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_LETTER_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_LETTER_3000) - 1;
        }

        break;

    case PS_A3:
        // CP-3000 Only

        if (pOEM->jMPFSetting == MPF_A3)
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
        else
            pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

        pOEM->cmdPaperSize.cmd = STR_A3_3000;
        pOEM->cmdPaperSize.cmdlen = sizeof(STR_A3_3000) - 1;

        break;

    case PS_A4:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_A4)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_A4_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_A4_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_A4)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_A4_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_A4_3000) - 1;
        }

        break;

    case PS_B4:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_B4)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B4_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B4_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_B4)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B4_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B4_3000) - 1;
        }

        break;

    case PS_B5:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_B5)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B5_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B5_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_B5)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B5_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B5_3000) - 1;
        }

        break;

    case PS_A5:
        // CP-3000 Only

        if (pOEM->jMPFSetting == MPF_A5)
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
        else
            pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

        pOEM->cmdPaperSize.cmd = STR_A5_3000;
        pOEM->cmdPaperSize.cmdlen = sizeof(STR_A5_3000) - 1;

        break;

    case PS_POSTCARD:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_POSTCARD)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_POSTCARD_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_POSTCARD_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_POSTCARD)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_POSTCARD_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_POSTCARD_3000) - 1;
        }
        break;
    }
}

INT APIENTRY
OEMCommandCallback(
        PDEVOBJ pdevobj,
        DWORD   dwCmdCbID,
        DWORD   dwCount,
        PDWORD  pdwParams
    )
{
    PMYPDEV pOEM;
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen;
    WORD wTemp, i;
    WORD wDestX, wDestY;
    INT iRet = 0;
    DWORD dwTemp;
    WORD wVirPapX1;
    WORD wVirPapY1;
    WORD wVirPapX2;
    WORD wVirPapY2;
    WORD wPapLenX;
    WORD wPapLenY;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

#if DBG
{
    int i, max;
    for (i = 0; i < (max = sizeof(MyCallbackID) / sizeof(MyCallbackID[0])); i++) {
        if (MyCallbackID[i].dwID == dwCmdCbID){
            VERBOSE(("%s PARAMS: %d\n", MyCallbackID[i].S, dwCount));
            break;
        }
    }
    if (i == max)
        WARNING(("%d is Invalid ID\n", dwCmdCbID));
}
#endif

    ASSERT(VALID_PDEVOBJ(pdevobj));

    wlen = 0;

    //
    // fill in printer commands
    //

    switch (dwCmdCbID) {

    case RES_SELECTRES_240:

        pOEM->wOldX = pOEM->wOldY = 0;
        pOEM->sRes = MASTER_UNIT / 240;
        WRITESPOOLBUF(pdevobj, STR_SELECTRES_240_3K,
                sizeof(STR_SELECTRES_240_3K) - 1);
        break;

    case RES_SELECTRES_400:

        pOEM->wOldX = pOEM->wOldY = 0;
        pOEM->sRes = MASTER_UNIT / 400;
        WRITESPOOLBUF(pdevobj, STR_SELECTRES_400_3K,
                sizeof(STR_SELECTRES_400_3K) - 1);
        break;

    case CM_XM_ABS:
    case CM_YM_ABS:
        switch (dwCmdCbID) {
        case CM_XM_ABS:
            wDestX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            wDestY = pOEM->wOldY;
            pOEM->wOldX = wDestX;
            break;
        case CM_YM_ABS:
            wDestX = pOEM->wOldX;
            wDestY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            pOEM->wOldY = wDestY;
            break;
        }

        // ESC '\' '9' XX YY

//        wDestX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
//        wDestY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);

        VERBOSE(("(wDestX, wDestY): (%d, %d)\n", wDestX, wDestY));

        cmdbuf[wlen++] = 0x1b;
        cmdbuf[wlen++] = 0x5c;
        cmdbuf[wlen++] = 0x39;
        cmdbuf[wlen++] = (BYTE)((wDestX >> 8) | 0x80);
        cmdbuf[wlen++] = (BYTE)(wDestX);
        cmdbuf[wlen++] = (BYTE)(wDestY >> 8);
        cmdbuf[wlen++] = (BYTE)(wDestY);

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

        // Set return value accordingly.  Unidrv expects
        // the values to be retuned in device's unit here.

        switch (dwCmdCbID) {
        case CM_XM_ABS:
            iRet = wDestX;
            break;
        case CM_YM_ABS:
            iRet = wDestY;
            break;
        }

        break;

    case PS_LETTER:
    case PS_A3:
    case PS_A4:
    case PS_B4:
    case PS_B5:
    case PS_A5:
    case PS_POSTCARD:
        pOEM->jFreePaper = 0;  // No(0)
        LoadPaperSelectCmd(pdevobj, pOEM, (INT)dwCmdCbID);
        break;

    case PS_FREE:
        pOEM->jFreePaper = 1;  // yes(1)

        if (pOEM->jModel == MD_CP2000) {
            pOEM->stFreePaperSize.wX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);        // dot
            pOEM->stFreePaperSize.wY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];                     // MPF
        } else {
            pOEM->stFreePaperSize.wX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);        // dot
            pOEM->stFreePaperSize.wY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);

            dwTemp = PARAM(pdwParams, 0);
// 2001/02/27 ->
//          dwTemp = (dwTemp * 254) / MASTER_UNIT;                                      // 0.1mm a unit
//          pOEM->stFreePaperSize.wXmm = (WORD)((dwTemp + 5) / 10);                     //   1mm a unit, round
            dwTemp = (dwTemp * 2540) / MASTER_UNIT;                                     // 0.01mm a unit
            pOEM->stFreePaperSize.wXmm = (WORD)((dwTemp + 99) / 100);                   //    1mm a unit, roundup
// 2001/02/27 <-

            dwTemp = PARAM(pdwParams, 1);
// 2001/02/27 ->
//          dwTemp = (dwTemp * 254) / MASTER_UNIT;                                      // 0.1mm a unit
//          pOEM->stFreePaperSize.wYmm = (WORD)((dwTemp + 5) / 10);                     //   1mm a unit, round
            dwTemp = (dwTemp * 2540) / MASTER_UNIT;                                     // 0.01mm a unit
            pOEM->stFreePaperSize.wYmm = (WORD)((dwTemp + 99) / 100);                   //    1mm a unit, roundup
// 2001/02/27 <-
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];                     // MPF
        }

        break;

    case AUTOFEED:
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '@';
        cmdbuf[wlen++] = ')';
        cmdbuf[wlen++] = pOEM->jAutoSelect;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case CBID_PORT:
    case CBID_LAND:
        // Page Format
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '=';
        cmdbuf[wlen++] = '4';
        cmdbuf[wlen++] = 0x00;

        // Orientaion
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '@';
        if (dwCmdCbID == CBID_LAND)
            cmdbuf[wlen++] = '3';
        else
            cmdbuf[wlen++] = '2';

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

        // PaperSize
        if (pOEM->jFreePaper == 0) {
            WRITESPOOLBUF(pdevobj, pOEM->cmdPaperSize.cmd, pOEM->cmdPaperSize.cmdlen);
        } else {
            if (pOEM->jModel == MD_CP2000) {
                if (dwCmdCbID == CBID_LAND) {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wX - ((400 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wY;
                    wPapLenY  = pOEM->stFreePaperSize.wX;
                } else {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wX - ((400 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wX;
                    wPapLenY  = pOEM->stFreePaperSize.wY;
                }

                wlen = 0;
                wlen = sizeof(STR_FREE_2000) - 1;
                memcpy(cmdbuf, STR_FREE_2000, wlen);

                // VirtualPaperSize
                cmdbuf[ 4] = HIBYTE(wVirPapX1);         // X1
                cmdbuf[ 5] = LOBYTE(wVirPapX1);
                cmdbuf[ 6] = HIBYTE(wVirPapY1);         // Y1
                cmdbuf[ 7] = LOBYTE(wVirPapY1);
                cmdbuf[ 8] = HIBYTE(wVirPapX2);         // X2
                cmdbuf[ 9] = LOBYTE(wVirPapX2);
                cmdbuf[10] = HIBYTE(wVirPapY2);         // Y2
                cmdbuf[11] = LOBYTE(wVirPapY2);
                
                // PaperSize (APF)
                cmdbuf[16] = HIBYTE(wPapLenX);          // X1
                cmdbuf[17] = LOBYTE(wPapLenX);
                cmdbuf[18] = HIBYTE(wPapLenY);          // Y1
                cmdbuf[19] = LOBYTE(wPapLenY);
                
                // MPF-PaperSize
                cmdbuf[24] = HIBYTE(wPapLenX);          // X1
                cmdbuf[25] = LOBYTE(wPapLenX);
                cmdbuf[26] = HIBYTE(wPapLenY);          // Y1
                cmdbuf[27] = LOBYTE(wPapLenY);
                
                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            } else {

                if (dwCmdCbID == CBID_LAND) {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wX - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wYmm;
                    wPapLenY  = pOEM->stFreePaperSize.wXmm;
                } else {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wX - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wXmm;
                    wPapLenY  = pOEM->stFreePaperSize.wYmm;
                }
                
                wlen = sizeof(STR_FREE_3000) - 1;
                memcpy(cmdbuf, STR_FREE_3000, wlen);

                // VirtualPaperSize
                cmdbuf[ 4] = HIBYTE(wVirPapX1);         // X1
                cmdbuf[ 5] = LOBYTE(wVirPapX1);
                cmdbuf[ 6] = HIBYTE(wVirPapY1);         // Y1
                cmdbuf[ 7] = LOBYTE(wVirPapY1);
                cmdbuf[ 8] = HIBYTE(wVirPapX2);         // X2
                cmdbuf[ 9] = LOBYTE(wVirPapX2);
                cmdbuf[10] = HIBYTE(wVirPapY2);         // Y2
                cmdbuf[11] = LOBYTE(wVirPapY2);

                // MPF-PaperSize
                cmdbuf[19] = HIBYTE(wPapLenX);          // X
                cmdbuf[20] = LOBYTE(wPapLenX);
                cmdbuf[21] = HIBYTE(wPapLenY);          // Y
                cmdbuf[22] = LOBYTE(wPapLenY);

                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            }
        }
        break;

    case PRN_2000:
        pOEM->jModel = MD_CP2000;
        pOEM->dwGeneral &= ~FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;

    case PRN_2000W:
        pOEM->jModel = MD_CP2000;
        pOEM->dwGeneral |= FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;

    case PRN_3000:
        pOEM->jModel = MD_CP3000;
        pOEM->dwGeneral |= FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588585-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#include "strsafe.h"         // Security-Code 2002.3.6

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB: public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {

        //VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        //VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        //VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\mydbg.h ===
#if DBG
#ifndef MYDBG_H_INCLUDED
#define MYDBG_H_INCLUDED

typedef struct _tblCallbackID {
    char*   S;
    DWORD   dwID;
} tblCallbackID;

static tblCallbackID MyCallbackID[] = {
    {"RES_SELECTRES_240",  14},
    {"RES_SELECTRES_400",  15},
    {"CM_XM_ABS",          20},
    {"CM_YM_ABS",          22},
    {"AUTOFEED",           30},
    {"PS_A3",              40},
    {"PS_B4",              41},
    {"PS_A4",              42},
    {"PS_B5",              43},
    {"PS_LETTER",          44},
    {"PS_POSTCARD",        45},
    {"PS_MPF",             46},
    {"PS_A5",              47},
    {"CBID_PORT",          50},
    {"CBID_LAND",          51},
    {"PRN_2000",           60},
    {"PRN_2000W",          61},
    {"PRN_3000",           62}
};

#endif  // MYDBG_H_INCLUDED
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

TARGETNAME=capplres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),capplres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\capplres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\capplres.c

MISCFILES=\
    $(SRCDIR)\capplres.ini \
    $(GPDDIR)\cscp210j.gpd \
    $(GPDDIR)\cscp212j.gpd \
    $(GPDDIR)\cscp215j.gpd \
    $(GPDDIR)\cscp220j.gpd \
    $(GPDDIR)\cscp22wj.gpd \
    $(GPDDIR)\cscp325j.gpd \
    $(GPDDIR)\cscp350j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include "strsafe.h"         // Security-Code 2002.3.6

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'CPPL'      // CASIO CAPPL/B
#define DLLTEXT(s)      "CPPL: " s
#define OEM_VERSION      0x00010000L


#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

// For Cappl/Bace
typedef struct tag_CPPL_EXTRADATA {
    OEM_DMEXTRAHEADER    dmExtraHdr;
} CPPL_EXTRADATA, *PCPPL_EXTRADATA;

typedef struct {
    DWORD dwGeneral;
    SHORT   sRes;
    BYTE    jModel;
    struct st_cmd {
        char    *cmd;
        WORD    cmdlen;
    } cmdPaperSize;
    BYTE    jFreePaper;         // Yes(1). No(0)
    struct st_fps {
        WORD    wX;
        WORD    wY;
        WORD    wXmm;
        WORD    wYmm;
    } stFreePaperSize;
    BYTE    jMPFSetting;
    BYTE    jAutoSelect;
    WORD    wOldX;
    WORD    wOldY;
} MYPDEV, *PMYPDEV;

#define FG_HAS_EMUL 0x00000001

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define POEMUD_EXTRADATA PCPPL_EXTRADATA
#define OEMUD_EXTRADATA CPPL_EXTRADATA

// Value for byModel
#define MD_CP2000        0x00
#define MD_CP3000        0x01

// Value for byMPFSetting
#define MPF_NOSET        0x00
#define MPF_A3            0x01
#define MPF_B4            0x02
#define MPF_A4            0x03
#define MPF_B5            0x04
#define MPF_LETTER        0x05
#define MPF_POSTCARD    0x06
#define MPF_A5            0x07

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include "strsafe.h"    // Security-Code 2002.3.6

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\casn4res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    casn4res.c

Abstract:

    Implementation of GPD command callback for "csn4j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/

#include "pdev.h"
#include <stdio.h>
#include "strsafe.h"         // Security-Code 2002.3.6

//
// For debugging.
//

//#define DL_VERBOSE WARNING
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE WARNING
#define SC_VERBOSE VERBOSE

//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr);
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize);
// Replacement of strsafe-api 2002.3.6 <<<

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define RES_SELECTRES_300       70
#define RES_SELECTRES_600       71
#define RES_SELECTRES_300_COLOR 72

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_MPF         103
#define PSRC_SELECT_AUTO        104

#define XXXX_TONER_SAVE_NONE    110
#define XXXX_TONER_SAVE_1       111
#define XXXX_TONER_SAVE_2       112
#define XXXX_TONER_SAVE_3       113
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MediaType_1             140
#define MediaType_2             141
#define MediaType_3             142    //+CP-E8000

#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      160
#define COLOR_SELECT_RED        161
#define COLOR_SELECT_GREEN      162
#define COLOR_SELECT_BLUE       163
#define COLOR_SELECT_YELLOW     164
#define COLOR_SELECT_MAGENTA    165
#define COLOR_SELECT_CYAN       166
#define COLOR_SELECT_WHITE      167

#define DUMP_RASTER_CYAN        170
#define DUMP_RASTER_MAGENTA     171
#define DUMP_RASTER_YELLOW      172
#define DUMP_RASTER_BLACK       173

/* End of hack code */
#endif /* OEM doesn't want to fix minidriver */

//+CP-E8000 Begin
#define OUTBIN_SELECT_EXIT_1    190
#define OUTBIN_SELECT_EXIT_2    191
#define OUTBIN_SELECT_EXIT_3    192
#define OUTBIN_SELECT_EXIT_4    193
#define OUTBIN_SELECT_EXIT_5    194
#define OUTBIN_SELECT_EXIT_6    195
//+CP-E8000 End

// Modification of Color-mode command 2002.3.28 >>>
#define OPT_MONO                "Mono"
#define OPT_COLOR               "Color"
// Modification of Color-mode command 2002.3.28 <<<

//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

#define BYTE_LENGTH(s) (sizeof (s) - 1)

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
// CASIO 00/09/16 ->
//BYTE ENDDOC_EJL_RESET[] = "\x1d\rhE"
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
// CASIO 00/09/16 <-
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

char SET_FONT_ID[]        = "\x1D%d;%ddh{F";
char DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
char DLI_DELETE_FONT[]    = "\x1D%dddcF";
char SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
char SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
char SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

char FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
char FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
char PRN_DIRECTION[]      = "\x1D%droF";
char SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
char SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
char VERT_FONT_SET[]      = "\x1D%dvpC";
char BOLD_SET[]           = "\x1D%dweF";
char ITALIC_SET[]         = "\x1D%dslF";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_MPF        3
#define PSRC_AUTO       4

// CASIO 00/09/13 ->
BYTE *EJL_SelectPsrc[] = {
//   " PU=1", " PU=2", " PU=3", " PU=4", " PU=AU" };
   " PU=1", " PU=2", " PU=255", " PU=4", " PU=AU" };
// CASIO 00/09/13 <-

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

#define RES_300DPI      0
#define RES_600DPI      1
BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
#define XX_TONER_SAVE_3 3
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2", " ##TS=3" };

// Modification of Color-mode command 2002.3.28 >>>
//BYTE *EJL_SetColorMode[] = {
//    " ##CM=OFF", " ##CM=ON" };
BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=NML", " ##CM=ECO", " ##CM=ECO2" };
// Modification of Color-mode command 2002.3.28 >>>

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MediaType_1 1
#define XX_MediaType_2 2
//+CP-E8000 Begin
#define XX_MediaType_3 3
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS", " PK=TH" };
//+CP-E8000 End

//+CP-E8000 Begin
#define OUTBIN_EXIT_1 1
#define OUTBIN_EXIT_2 2
#define OUTBIN_EXIT_3 3
#define OUTBIN_EXIT_4 4
#define OUTBIN_EXIT_5 5
#define OUTBIN_EXIT_6 6
BYTE *EJL_SelectOutbin[] = {
   " ##ET=1", " ##ET=3", " ##ET=4", " ##ET=5", " ##ET=6", " ##ET=7"  };

#define JOBSHIFT_OFF 0
#define JOBSHIFT_ON  1
BYTE *EJL_JobShift[] = {
   " ##JO=OFF", " ##JO=ON"  };
//+CP-E8000 End

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31

/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
//        (dwFontID - FONT_MIN_ID), 0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
        &pDestEnd, &szRemLen,
        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
        DLI_SELECT_FONT_ID, (dwFontID - FONT_MIN_ID), 0)) {
        return;
    }
    wlen += (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;
// Modification of Color-mode command 2002.3.28 >>>
    BYTE            byOutput[64];
    DWORD           dwNeeded;
    DWORD           dwOptionsReturned;
// Modification of Color-mode command 2002.3.28 <<<

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iResolution = 0; 
    pOEM->iColor = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
//+CP-E8000 Begin
    pOEM->iOutBin = 0;
//+CP-E8000 End

// Modification of Color-mode command 2002.3.28 >>>
    // ColorMode
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMode", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMode) Failed\n"));
        pOEM->iColor = 0;
    } else {
        if (!strcmp(byOutput, OPT_COLOR)) {
            pOEM->iColor = 2;
        } else if (!strcmp(byOutput, OPT_MONO)) {
            pOEM->iColor = 0;
        }
    }
// Modification of Color-mode command 2002.3.28 <<<

    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;
    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;

    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT              iRet = 0;
    BYTE             *bp;
    BYTE             Cmd[BUFFLEN];
    PMYPDEV pOEM;
    WORD wlen;
    WORD wGray;
    DWORD dwTempX, dwTempY;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
            &pDestEnd, &szRemLen,
            STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
            BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
            &pDestEnd, &szRemLen,
            STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
            ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_SINGLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_SINGLE_BYTE,
            &pDestEnd, &szRemLen,
            STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION, pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET, 0)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_DOUBLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_DOUBLE_BYTE,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION, pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET,1)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral |= FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case RES_SELECTRES_300:
        pOEM->iResolution = RES_300DPI;
// Modification of Color-mode command 2002.3.28 >>>
//        pOEM->iColor = 0;
// Modification of Color-mode command 2002.3.28 <<<
        pOEM->iUnitFactor = MASTER_UNIT / 300;
        break;

    case RES_SELECTRES_600:
        pOEM->iResolution = RES_600DPI;
// Modification of Color-mode command 2002.3.28 >>>
//        pOEM->iColor = 0;
// Modification of Color-mode command 2002.3.28 <<<
        pOEM->iUnitFactor = MASTER_UNIT / 600;
        break;

    case RES_SELECTRES_300_COLOR:
        pOEM->iResolution = RES_300DPI;
// Modification of Color-mode command 2002.3.28 >>>
//        pOEM->iColor = 2;
// Modification of Color-mode command 2002.3.28 <<<
        pOEM->iUnitFactor = MASTER_UNIT / 300;
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:

        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
//        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectPsrc[pOEM->iPaperSource],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectOrient[pOEM->iOrientation],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        // CASIO extention

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectRes[pOEM->iResolution],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Modification of Color-mode command 2002.3.28 >>>
#if 0
        if (pOEM->iColor > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorMode[pOEM->iColor - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[pOEM->iColor - 1],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
#else
        if (pOEM->iColor > 0) {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[2],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
               break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        } else {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[0],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
               break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        }
#endif
// Modification of Color-mode command 2002.3.28 <<<

        if (pOEM->iDuplex > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetDuplex[pOEM->iDuplex - 1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetTonerSave[pOEM->iTonerSave],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetSmoohing[pOEM->iSmoothing],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetJamRecovery[pOEM->iJamRecovery],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        if (pOEM->iMediaType > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetMediaType[pOEM->iMediaType - 1],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
//+CP-E8000 Begin
        if (pOEM->iOutBin > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SelectOutbin[pOEM->iOutBin - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectOutbin[pOEM->iOutBin - 1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

            if (pOEM->iOutBin == OUTBIN_EXIT_2) {
// Replacement of strsafe-api 2002.3.6 >>>
//                strcpy( &Cmd[wlen],  EJL_JobShift[JOBSHIFT_ON] );
//                wlen += (WORD)strlen( &Cmd[wlen] );
                if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_JobShift[JOBSHIFT_ON],
                                            &pDestEnd, &szRemLen,
                                            STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                    break;
                }
                wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
            }
        }
//+CP-E8000 End

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EPg_SelectRes[pOEM->iResolution],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen );
        // 99/09/28 ->
        // break;
        // 99/09/28 <-

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case XXXX_TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case XXXX_TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case XXXX_TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case XXXX_TONER_SAVE_3:
        pOEM->iTonerSave = XX_TONER_SAVE_3;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MediaType_1:
        pOEM->iMediaType = XX_MediaType_1;
        break;

    case MediaType_2:
        pOEM->iMediaType = XX_MediaType_2;
        break;

//+CP-E8000 Begin
    case MediaType_3:
        pOEM->iMediaType = XX_MediaType_3;
        break;

    case OUTBIN_SELECT_EXIT_1:
        pOEM->iOutBin = OUTBIN_EXIT_1;
        break;

    case OUTBIN_SELECT_EXIT_2:
        pOEM->iOutBin = OUTBIN_EXIT_2;
        break;

    case OUTBIN_SELECT_EXIT_3:
        pOEM->iOutBin = OUTBIN_EXIT_3;
        break;

    case OUTBIN_SELECT_EXIT_4:
        pOEM->iOutBin = OUTBIN_EXIT_4;
        break;

    case OUTBIN_SELECT_EXIT_5:
        pOEM->iOutBin = OUTBIN_EXIT_5;
        break;

    case OUTBIN_SELECT_EXIT_6:
        pOEM->iOutBin = OUTBIN_EXIT_6;
        break;

//+CP-E8000 End
    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
//            wGray,
//            (WORD)dwTempX,
//            (WORD)dwTempY,
//            (WORD)(dwTempX + pOEM->wRectWidth - 1),
//            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    RECT_FILL,
                                    wGray,
                                    (WORD)dwTempX,
                                    (WORD)dwTempY,
                                    (WORD)(dwTempX + pOEM->wRectWidth - 1),
                                    (WORD)(dwTempY + pOEM->wRectHeight - 1))) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width, charoff;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 <<<
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
// Check of zero divide 2002.3.23 >>>
            if (width == 0) {
                ERR(("OEMSendFontCmd() 0Div-Check [width=0] \n"));
                return;
            }
// Check of zero divide 2002.3.23 <<<
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 <<<
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
// Check of zero divide 2002.3.23 >>>
    if (pIFI->fwdUnitsPerEm == 0) {
        ERR(("OEMSendFontCmd() 0Div-Check [pIFI->fwdUnitsPerEm=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
//        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_CHAR_OFFSET, (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0)) {
        return;
    }
    wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<<

    if (pOEM->fGeneral & FG_VERT)
    {
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    VERT_FONT_SET, 1)) {
            return;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
// Check of zero divide 2002.3.23 >>>
//    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;
    LONG tmp;
    if (vertRes == 0) {
        ERR(("LGetPointSize100() 0Div-Check [vertRes=0] \n"));
        return 0;
    }
    tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;
// Check of zero divide 2002.3.23 <<<

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr)
//{
//    register long count;
//
//        count = (long)strlen(_ltoa(size / 100, pStr, 10));
//        pStr[count++] = '.';
//        count += (long)strlen(_ltoa(size % 100, &pStr[count], 10));
//
//    return count;
//}
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize)
{
    register long count;
    size_t pcb;

        if (S_OK != StringCbLengthA(_ltoa(size / 100, pStr, 10), StrSize, &pcb))
            return 0;
        count = (WORD)pcb;
        pStr[count++] = '.';
        if (S_OK != StringCbLengthA(_ltoa(size % 100, &pStr[count], 10), StrSize-count, &pcb))
            return 0;
        count += (WORD)pcb;

    return count;
}
// Replacement of strsafe-api 2002.3.6 <<<

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
                wLen = 0; // 392057: PREFIX
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    if (NULL != pTransOrg)
    {
        MemFree(pTransOrg);
    }
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
//    BYTE sFontName[54];  // 2002.3.6 Buffer size insufficient
    BYTE sFontName[64];    // 2002.3.6
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;

    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    VERBOSE(("TT Font:\n"));
    VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if(pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if( MasterToDevice(pOEM,wCellHeight) > 64 ) return 0;
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

// Check of zero divide 2002.3.23 >>>
    if (iTemp == 0) {
        ERR(("OEMDownloadFontHeader() 0Div-Check [iTemp=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

// Replacement of strsafe-api 2002.3.6 >>>
//    iSizeFontName = wsprintf(sFontName,
//       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
//    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    if (S_OK != StringCbPrintfExA(sFontName, sizeof(sFontName),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeFontName = (WORD)(pDestEnd - sFontName);
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    VERBOSE(("FontHeader:\n"));
    VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// Replacement of strsafe-api 2002.3.6 >>>
//// CASIO 98/11/24 ->
////    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
////        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
////    }else{
//        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
////    }
//// CASIO 98/11/24 <-
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp))) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    VERBOSE(("ESCPageChar:\n"));
    VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\capplres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
     "DisableDriver",
     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
     "EnableDriver",
     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588586-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods


#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#include "strsafe.h"         // Security-Code 2002.3.6

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE(("pMethodName = %s, lRet = %d\n", pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=casn4res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),casn4res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\casn4res.rc \
    $(SRCDIR)\casn4res.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\casn4res.ini \
    $(SRCDIR)\icm\csn4001.icm \
    $(SRCDIR)\icm\csn4002.icm \
    $(SRCDIR)\icm\csn4003.icm \
    $(GPDDIR)\cscp710j.gpd \
    $(GPDDIR)\cscp720j.gpd \
    $(GPDDIR)\cscp725j.gpd \
    $(GPDDIR)\cscp730j.gpd \
    $(GPDDIR)\cscp740j.gpd \
    $(GPDDIR)\cscp750j.gpd \
    $(GPDDIR)\csn4j.gpd \
    $(GPDDIR)\cscpe80j.gpd \
    $(GPDDIR)\cscpb10j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

// Modification of Color-mode command 2002.3.28 >>>
#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))
// Modification of Color-mode command 2002.3.28 <<<

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD fGeneral;
    int  iEscapement;
    short iDevCharOffset;
    BYTE iPaperSource;
    BYTE iDuplex;
    BYTE iTonerSave;
    BYTE iOrientation;
    BYTE iResolution; 
    BYTE iColor;
    BYTE iSmoothing;
    BYTE iJamRecovery;
    BYTE iMediaType;
    BYTE iOutBin;             //+CP-E8000

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;

    BYTE iUnitFactor; // master vs device scale factor
    WORD wRectWidth, wRectHeight;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    DWORD dwSelectedColor;     // Latest selected color descirbe as COLOR_SELECT_xxx
    BYTE iColorMayChange;    // 1 means called block data callback that may change color
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS     0x00000001
#define FG_VERT     0x00000002
#define FG_PROP     0x00000004
#define FG_DOUBLE   0x00000008
#define FG_NULL_PEN 0x00000010
#define FG_BOLD     0x00000020
#define FG_ITALIC   0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\code.c ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "CITOHRES";


#include "pdev.h"

static const BYTE  FlipTable[ 256 ] =
{

#include	"fliptab.h"

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\casn4res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    OEMDBGP((DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        OEMDBGP((ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        OEMDBGP((ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}

#ifndef USERMODE_DRIVER
//
// Functions for outputting debug messages
//

VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif //USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\fliptab.h ===
0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for C-Itoh printers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CITH'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("CITOHRES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include <initguid.h>
#include <prcomoem.h>
#include "comoem.h"
#include <assert.h>
#include "code.c"

///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////
//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return E_FAIL;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return E_FAIL;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {
            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/
{
    DWORD dwResult;
    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));


    /*
     *    Easy to do - translate the input using FlipTable,  then call the
     *  Unidrv function DrvWriteSpoolBuf.
     */

    BYTE  *pb;
    DWORD   i;

    for( pb = pBuf, i = 0; i < dwLen; i++, pb++ )
	{	
	    *pb = FlipTable[ *pb ];
	}


    if(!SUCCEEDED(pOEMHelp->DrvWriteSpoolBuf( pdevobj, pBuf, dwLen, &dwResult )) || dwResult != dwLen)
	return E_FAIL;
    else	
        return S_OK;


}

STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H


#include <lib.h>

#include <PRINTOEM.H>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


#if 0
////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#endif // 0

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

#if DBG // For Check Build

#define OEMDBGP(msg)    DbgPrint msg;

#ifndef USERMODE_DRIVER
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);
#else
extern ULONG _cdecl DbgPrint(PCSTR, ...);
#endif //USERMODE_DRIVER

#else // Free Build

#define OEMDBGP(msg)

#endif //DBG



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\citohres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns E_FAIL if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnepkres\etc\canonch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "CANONCH";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\cnl4jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-550215-2002/02/21-yasuho-: Use strsafe.h
// NTRAID#NTBUG9-568204-2002/03/07-yasuho-: Should change much safer function.
// NTRAID#NTBUG9-568217-2002/03/07-yasuho-: Check divide by zero
// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code

#define LIPS4_DRIVER
#include "pdev.h"

#define CCHMAXCMDLEN 256
#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))
#define ABS(x)      (x > 0?x:-x)

#define WRITESPOOLBUF(pdevobj, cmd, len) \
	(pdevobj)->pDrvProcs->DrvWriteSpoolBuf(pdevobj, cmd, len)


// NTRAID#NTBUG9-289908-2002/03/07-yasuho-: pOEMDM -> pdevOEM
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PLIPSPDEV pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(LIPSPDEV))))
        {
            return NULL;
        }
    }

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;

    // Flags
    pOEM->fbold = FALSE; // uses Ornamented Character
    pOEM->fitalic = FALSE; // uses Char Orientatoin
    pOEM->fwhitetext = FALSE; // White Text mode
    pOEM->fdoublebyte = FALSE; // DBCS char mode
    pOEM->fvertical = FALSE; // Vertical writing mode
    pOEM->funderline = FALSE;
    pOEM->fstrikesthu = FALSE;
    pOEM->fpitch = FIXED;
    pOEM->flpdx = FALSE;
    pOEM->fcompress = 0x30; // default is non compress
    // Lips4 features
    pOEM->fduplex  = FALSE;
    pOEM->fduplextype  = VERT;
    pOEM->nxpages      = DEVICESETTING;
    pOEM->fsmoothing   = DEVICESETTING;
    pOEM->fecono       = DEVICESETTING;
    pOEM->fdithering   = DEVICESETTING;

    // Variables
    pOEM->ptCurrent.x  = pOEM->ptCurrent.y = 0;
    pOEM->ptInLine.x   = pOEM->ptInLine.y  = 0;
    pOEM->bLogicStyle  = INIT;
    pOEM->savechar     = -1;
    pOEM->printedchars = 0;
    pOEM->firstchar    = 0;
    pOEM->lastchar     = 0;
    pOEM->stringwidth  = 0;

    pOEM->curFontGrxIds[0] = pOEM->curFontGrxIds[1] = 0xff;
    pOEM->curFontGrxIds[2] = pOEM->curFontGrxIds[3] = 0xff;
    pOEM->curFontGrxIds[4] = pOEM->curFontGrxIds[5] = 0xff;
    pOEM->curFontGrxIds[6] = pOEM->curFontGrxIds[7] = 0xff;

    pOEM->tblPreviousFont.FontHeight = INIT;
    pOEM->tblPreviousFont.FontWidth  = INIT;
    pOEM->tblPreviousFont.MaxWidth   = INIT;
    pOEM->tblPreviousFont.AvgWidth   = INIT;
    pOEM->tblPreviousFont.Ascent     = INIT;
    pOEM->tblPreviousFont.Stretch    = INIT;
    pOEM->tblCurrentFont.FontHeight  = 50;
    pOEM->tblCurrentFont.FontWidth   = 25;
    pOEM->tblPreviousFont.MaxWidth   = 50;
    pOEM->tblPreviousFont.AvgWidth   = 25;
    pOEM->tblPreviousFont.Ascent     = 45;

    pOEM->OrnamentedChar[0] = pOEM->OrnamentedChar[1] = INIT;
    pOEM->OrnamentedChar[2] = pOEM->OrnamentedChar[3] = INIT;
    pOEM->OrnamentedChar[4] = INIT;
    pOEM->TextPath = INIT;
    pOEM->CharOrientation[0] = pOEM->CharOrientation[1] = INIT;
    pOEM->CharOrientation[2] = pOEM->CharOrientation[3] = INIT;

    pOEM->GLTable = INIT;
    pOEM->GRTable = INIT;
    pOEM->cachedfont  = 0; // We have no id 0 font.
    pOEM->papersize   = PAPER_DEFAULT; // A4
    pOEM->Escapement  = 0;
    pOEM->resolution  = 300;
    pOEM->unitdiv     = 2;
    // Vector command
    pOEM->wCurrentImage = 0;
#ifdef LIPS4C
    pOEM->flips4C = FALSE;
#endif // LIPS4C
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    pOEM->masterunit = 600;
// NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
    pOEM->tray = INIT;
    pOEM->method = INIT;
    pOEM->staple = INIT;
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: Sorter support
    pOEM->sorttype = INIT;
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
    pOEM->fCPCA = FALSE;
    pOEM->fCPCA2 = FALSE;
    CPCAInit(pOEM);
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-:
// Features are different from H/W options.
    pOEM->startbin = INIT;
// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
    pOEM->collate = INIT;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PLIPSPDEV pOEMOld, pOEMNew;

    pOEMOld = (PLIPSPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PLIPSPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

// BInitOEMExtraData() and BMergeOEMExtraData() has moved to common.c


// NTRAID#NTBUG9-568217-2002/03/07-yasuho-: iDwtoa(): Replace safer function.

// Support DRC
static BOOL
ToVFormat(long v, PBYTE *pbp, PBYTE pend, int bits)
{
	long		max, l;
	int		sign;

	sign = (v < 0);
	v = sign ? -v : v;
	max = 1 << bits;
	if (v >= max) {
		if (!ToVFormat(v >> bits, pbp, pend, 6))
			return FALSE;
	}
	l = (v & (max-1));
	if (bits == 4)
		l += sign ? ' ' : '0';
	else
		l += '@';
	if (*pbp >= pend)
		return FALSE;
	*(*pbp)++ = (char)l;
	return TRUE;
}

BOOL VFormat(long sParam, PBYTE *pbp, PBYTE pend)
{
    return ToVFormat(sParam, pbp, pend, 4);
}

//*****************************************************************
// Send current Font ID and Graphic set ID to printer anyway.
//*****************************************************************
BOOL SendFontGrxID(pdevobj)
    PDEVOBJ	pdevobj;
{
    PLIPSPDEV	pOEM;
    BYTE	ch[CCHMAXCMDLEN];
    PBYTE	pch, pend;
    BYTE	tid;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);
    pch = ch;
    pend = &ch[CCHMAXCMDLEN];

    // Send font, grx ids x 4 x 2
    if(pOEM->curFontGrxIds[0] != 0xff) {
        tid = pOEM->curFontGrxIds[0];
        // Font ID G0
        if (pch >= pend)
            return FALSE;
        *pch++ = 'T';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[1] != 0xff) {
        tid = pOEM->curFontGrxIds[1];
        // Font ID G1
        if (pch >= pend)
            return FALSE;
        *pch++ = 'm';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[2] != 0xff) {
        tid = pOEM->curFontGrxIds[2];
        // Font ID G2
        if (pch >= pend)
            return FALSE;
        *pch++ = 'n';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[3] != 0xff) {
        tid = pOEM->curFontGrxIds[3];
        // Font ID G3
        if (pch >= pend)
            return FALSE;
        *pch++ = 'o';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[4] != 0xff) {
        tid = pOEM->curFontGrxIds[4];
        // Grx ID G0
        if (pch >= pend)
            return FALSE;
        *pch++ = ']';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[5] != 0xff) {
        tid = pOEM->curFontGrxIds[5];
        // Grx ID G1
        if (pch >= pend)
            return FALSE;
        *pch++ = 0x60; // '`'
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[6] != 0xff) {
        tid = pOEM->curFontGrxIds[6];
        // Grx ID G2
        if (pch >= pend)
            return FALSE;
        *pch++ = 'a';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    if(pOEM->curFontGrxIds[7] != 0xff) {
        tid = pOEM->curFontGrxIds[7];
        // Grx ID G3
        if (pch >= pend)
            return FALSE;
        *pch++ = 'b';
        if (VFormat(tid, &pch, pend))
            return FALSE;
    }

    WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

    return TRUE;
}

// **** Put PaperSize Select command
BOOL SelectPaperSize(pdevobj, paperid)
    PDEVOBJ	pdevobj;
    char	paperid;
{
    char i;
    PLIPSPDEV pOEM;
    DWORD x, y;
    PBYTE pch;
    size_t rem;
    BYTE ch[CCHMAXCMDLEN];

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    // if papersize was set already, it's skipped
    if(pOEM->currentpapersize == paperid)
        return TRUE;

    // NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.

    i = paperid - PAPER_FIRST;

    if ((paperid != PAPER_PORT && paperid != PAPER_LAND) ||
        !pOEM->dwPaperWidth || !pOEM->dwPaperHeight) {
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            cmdSelectPaper, PaperIDs[i])))
            return FALSE;
    } else {
        // Custom forms
        // NTRAID#NTBUG9-309695-2002/03/07-yasuho-: 
        // top margin incorrect on custom:landscape:LIPS4c
        if (pOEM->flips4 || pOEM->flips4C) {
            if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, &rem, 0,
                cmdSelectUnit4, pOEM->resolution)))
                return FALSE;
        } else {
            if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, &rem, 0,
                cmdSelectUnit3)))
                return FALSE;
        }
        i = (paperid == PAPER_PORT) ? 80 : 81;
        if (!pOEM->unitdiv)
            return FALSE;
        x = pOEM->dwPaperWidth / (DWORD)pOEM->unitdiv;
        y = pOEM->dwPaperHeight / (DWORD)pOEM->unitdiv;
        if (FAILED(StringCchPrintfExA(pch, rem, &pch, NULL, 0,
            cmdSelectCustom, i, y, x)))
            return FALSE;
    }
    WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

    // save papersize
    pOEM->currentpapersize = paperid;

    return TRUE;
}


BOOL NEAR PASCAL SetPenAndBrush(PDEVOBJ pdevobj, WORD wType)
{
    BYTE        ch[CCHMAXCMDLEN];
    PBYTE       pch, pend;
    PLIPSPDEV	pOEM;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);
    pch = ch;
    pend = &ch[CCHMAXCMDLEN];

    if (SET_BRUSH == wType) {
        short sBrush;

        if (pOEM->sBrushStyle == INIT)
            pOEM->sBrushStyle = 0;

        if (pOEM->sBrushStyle & 0x20)
            sBrush = pOEM->sBrushStyle;
        else
            sBrush = BrushType[pOEM->sBrushStyle];

        if (&pch[4] > pend)
            return FALSE;
	*pch++ = 'I';
	*pch++ = (BYTE)sBrush;
	*pch++ = (pOEM->fVectCmd & VFLAG_PEN_NULL) ? '0' : '1';
	*pch++ = 0x1E;
    }

    if (SET_PEN == wType) {
        if (!(pOEM->fVectCmd & VFLAG_PEN_NULL)) {
            if (FAILED(StringCchPrintfExA(pch, (INT)(pch - ch), &pch, NULL, 0,
                "E1%d\x1E\x7DG%d1\x1E",
	        pOEM->sPenStyle,
	        pOEM->sPenColor)))
	        return FALSE;

            if (&pch[3] > pend)
                return FALSE;
            *pch++ = 'F';
            *pch++ = '1';
            if (!VFormat(pOEM->sPenWidth, &pch, pend))
                return FALSE;
            *pch++ = 0x1E;
        } else {
            if (FAILED(StringCchPrintfExA(pch, (INT)(pch - ch), &pch, NULL, 0,
	        "\x7DG20\x1E")))
	        return FALSE;
	}
    }

    if ((DWORD)(pch - ch) > 0)
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

    return TRUE;
}

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support

/*
 *      PJLStart
 */
static BOOL
PJLStart(PDEVOBJ pdevobj)
{
    PLIPSPDEV   pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);
    LPLIPSCmd   lp;
    short       res;
    INT         i;
    WORD        wlen;
    PBYTE       pch;
    BYTE        ch[CCHMAXCMDLEN];

    WRITESPOOLBUF(pdevobj, cmdPJLTOP1.pCmdStr, cmdPJLTOP1.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLTOP2.pCmdStr, cmdPJLTOP2.cbSize);

    // NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
    // Features are different from H/W options.
    switch (pOEM->tray) {
    default:
        break;
    case 0:     // AUTO
        i = 0;
        goto traycommon;
    case 100:   // DEFAULT
        i = 1;
        goto traycommon;
    case 101:   // SUBTRAY
        i = 2;
        goto traycommon;
    case 1:     // BIN1
    case 2:     // BIN2
    case 3:     // BIN3
        i = pOEM->tray + 2;
        // FALL THRU
    traycommon:
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            cmdPJLBinSelect, cmdBinType[i])))
            return FALSE;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        break;
    }

    // NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    res = pOEM->resolution;
    if(res == 1200)
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3SUPERFINE.pCmdStr, cmdPJLTOP3SUPERFINE.cbSize);
    else if(res == 600)
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3FINE.pCmdStr, cmdPJLTOP3FINE.cbSize);
    else
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3QUICK.pCmdStr,cmdPJLTOP3QUICK.cbSize);

    // NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
    switch (pOEM->method) {
    case METHOD_JOBOFFSET:
        WRITESPOOLBUF(pdevobj, cmdPJLTOP31JOBOFF.pCmdStr, cmdPJLTOP31JOBOFF.cbSize);
        break;

    case METHOD_STAPLE:
        if (pOEM->staple < 0 || pOEM->staple >= sizeof(cmdStapleModes) /
            sizeof(cmdStapleModes[0]))
            break;
        lp = &cmdStapleModes[pOEM->staple];
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            "%s%s\r\n",
            cmdPJLTOP31STAPLE.pCmdStr,
            lp->pCmdStr)))
            return FALSE;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        break;
    }

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    switch (pOEM->sorttype) {
    case SORTTYPE_SORT:
        i = 0;
        goto sortcommon;
    case SORTTYPE_GROUP:
        i = 1;
        goto sortcommon;
    case SORTTYPE_STAPLE:
        i = 2;
        goto sortcommon;
// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
    default:
        if (pOEM->collate != COLLATE_ON)
            break;
        i = 0;
        // FALL THRU
    sortcommon:
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            cmdPJLSorting, cmdSortType[i])))
            return FALSE;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        break;
    }

    if (pOEM->startbin != INIT) {
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            cmdPJLStartBin, pOEM->startbin)))
            return FALSE;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    }

    WRITESPOOLBUF(pdevobj, cmdPJLTOP4.pCmdStr, cmdPJLTOP4.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLTOP5.pCmdStr, cmdPJLTOP5.cbSize);

    return TRUE;
}

/*
 *      PJLEnd
 */
static void
PJLEnd(PDEVOBJ pdevobj)
{
    WRITESPOOLBUF(pdevobj, cmdPJLBOTTOM1.pCmdStr, cmdPJLBOTTOM1.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLBOTTOM2.pCmdStr, cmdPJLBOTTOM2.cbSize);
}

/*
 *	OEMCommandCallback
 */
INT APIENTRY OEMCommandCallback(
	PDEVOBJ pdevobj,
	DWORD   dwCmdCbID,
	DWORD   dwCount,
	PDWORD  pdwParams
	)
{
	INT			i, j, k;
	BYTE			*bp;
	BYTE			ch[CCHMAXCMDLEN];
	PLIPSPDEV               pOEM;
	LPGrxSetNo		pGS;
        DWORD                   r, g, b;
        PBYTE                   pch;
        PBYTE                   pend = &ch[CCHMAXCMDLEN];

	// DbgPrint(DLLTEXT("OEMCommandCallback() entry.\r\n"));

	//
	// verify pdevobj okay
	//
	// ASSERT(VALID_PDEVOBJ(pdevobj));

	//
	// fill in printer commands
	//
	i = 0;
	pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

	// Register PaperSize 40 - 65
	if(dwCmdCbID >= PAPER_FIRST && dwCmdCbID <= PAPER_LAST) {
	// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
	    pOEM->papersize = (char)dwCmdCbID;
	    if (dwCount < 2 || !pdwParams)
		return 0;
	    pOEM->dwPaperWidth = pdwParams[0];
	    pOEM->dwPaperHeight = pdwParams[1];
	    return 0;
	}

switch(dwCmdCbID)
    {
    long       cx,cy;
    short      res;

    case RES_SENDBLOCK:
	if (dwCount < 3 || !pdwParams)
	    break;
        cx = pOEM->ptCurrent.x;
        cy = pOEM->ptCurrent.y;

#ifdef LIPS4C
        // NOTE!: \x7DH cmd is not accepted when full color printing for
	//	  \x7DQ cmd.
        // Rasdd works as the following order when the model is not MD_SERIAL.
        // 1. Puts no white character.
        // 2. Puts graphics.
        // 3. Puts white character.
        // Therefore, black character is deleted when rasdd puts graphics due
        // to the design describing at NOTE!.
        // I have changed the type of printer model to MD_SERIAL.
        // Following \x7DH cmd is for grayscale printing.

	// NTRAID#NTBUG9-185744-2002/03/07-yasuho-: White font isn't printed
	// These 'hack' code doesn't necessary on NT5.

        if(pOEM->flips4C) {
        if(pOEM->bLogicStyle != OR_MODE) {
            // "\x7DH1\x1E"
	    pch = ch;
            if (&pch[4] > pend) return -1;
            *pch++ = '\x7D';
            *pch++ = 'H';
            *pch++ = '1';
            *pch++ = 0x1E;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

            pOEM->bLogicStyle = OR_MODE;
            }
	} else { // !flips4C
#endif // LIPS4C
        if (pOEM->fcolor) {
            if(pOEM->bLogicStyle != OVER_MODE) {
                pOEM->bLogicStyle = OVER_MODE;
	        pch = ch;
                if (&pch[4] > pend) return -1;
                *pch++ = 0x7D;
                *pch++ = 'H';
                *pch++ = '0';
                *pch++ = 0x1E;
                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
            }
        } else {
            if(pOEM->bLogicStyle != OR_MODE) {
                pOEM->bLogicStyle = OR_MODE;
	        pch = ch;
                if (&pch[4] > pend) return -1;
                *pch++ = 0x7D;
                *pch++ = 'H';
                *pch++ = '1';
                *pch++ = 0x1E;
                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
            }
        } // fcolor
#ifdef LIPS4C
	} // flips4C
#endif // LIPS4C

#ifdef LBP_2030
        if( pOEM->fcolor ) {
            if( pOEM->fplane == 0 ) {
                // "\x7DP{pt.X}{pt.Y}{36000}{36000}{Height}{Width}{1}{0}{1}{0}{0}{1}\x1E"
                pch = ch;
                if (&pch[2] > pend) return -1;
                *pch++ = 0x7D;
                *pch++ = 'P';

                if (!VFormat(cx, &pch, pend)) return -1;
                if (!VFormat(cy, &pch, pend)) return -1;

                res = pOEM->resolution;

                if (!VFormat(res * 100, &pch, pend)) return -1; // (x res)
                if (!VFormat(res * 100, &pch, pend)) return -1; // (y res)

                if (!VFormat(*(pdwParams+1), &pch, pend)) return -1; // height

                if(pOEM->fcolor == COLOR) {
                    // On 2030, specifying "RGB per line" data format did not
                    // work well (yellow ink was not printed.)  it seems that
                    // the same data can be printed out correctly if you
                    // specify "RGB per plane".
                    // (In this case we are sending out scan lines as planes
                    // with height 1.)

                    if (!VFormat(8*(*(pdwParams+2)), &pch, pend)) return -1;
                    if (&pch[2] > pend) return -1;
                    *pch++ = 0x31; // bits per color: 1
                    *pch++ = 0x3C; // data format: RGB per plane
                } else if (pOEM->fcolor == COLOR_8BPP) {
                    if (!VFormat(*(pdwParams+2), &pch, pend))
                        return -1;
                    if (&pch[2] > pend) return -1;
                    *pch++ = 0x38;      // bits per color: 8
                    *pch++ = 0x31;      // data format: color index
                } else { // COLOR_24BPP
                    if (!VFormat(*(pdwParams+2)/3, &pch, pend)) return -1;
                    if (&pch[2] > pend) return -1;
                    *pch++ = 0x38;      // bits per color: 8
                    *pch++ = 0x3A;      // data format: RGB per point
                }
                if (&pch[5] > pend) return -1;
                *pch++ = 0x30;      // Height Vector
                *pch++ = 0x31;
                *pch++ = 0x31;      // Width Vector
                *pch++ = 0x30;
                *pch++ = 0x1E;

                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

            }

            // "\x7DQ{1}{1}{0}{size of byte}\x1E"

            pch = ch;
            if (&pch[6] > pend) return -1;
            *pch++ = 0x7D;
            *pch++ = 'Q';
            *pch++ = 0x31;
            *pch++ = (pOEM->fplane < pOEM->fplaneMax) ? 0x30 : 0x31;
            *pch++ = pOEM->fcompress;
            if (!VFormat(*pdwParams, &pch, pend)) return -1;
            *pch++ = 0x1E;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

            if (pOEM->fcolor == COLOR) {
                if (pOEM->fplane >= pOEM->fplaneMax)
                    pOEM->fplane = 0;
                else
                    pOEM->fplane++;
            }
            break;
        } // fcolor
#endif //LBP_2030

        // "\x7DP{pt.X}{pt.Y}{30000}{30000}{Height}{Width}{1}{0}{1}{0}{0}{1}\x1E"
        pch = ch;
        if (&pch[2] > pend) return -1;
        *pch++ = 0x7D;
        *pch++ = 'P';

        if (!VFormat(cx, &pch, pend)) return -1;
        if (!VFormat(cy, &pch, pend)) return -1;

        res = pOEM->resolution;

        if (!VFormat(res * 100, &pch, pend)) return -1; // (x res)
        if (!VFormat(res * 100, &pch, pend)) return -1; // (y res)

        if (!VFormat((short)*(pdwParams+1), &pch, pend)) return -1; // height
        if (!VFormat((short)(8*(*(pdwParams+2))), &pch, pend)) // width
            return -1;

        if (&pch[7] > pend) return -1;
        *pch++ = 0x31;
        *pch++ = 0x30;
        *pch++ = 0x30;
        *pch++ = 0x31;
        *pch++ = 0x31;
        *pch++ = 0x30;
        // LIPS4 feature
        if(pOEM->flips4 == TRUE) {
            if (&pch[2] > pend) return -1;
            *pch++ = 0x30;
            *pch++ = 0x31; // batch image transfer
        }

        *pch++ = 0x1E;

        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

        // "\x7DQ{1}{1}{0}{size of byte}\x1E"

        pch = ch;
        if (&pch[7] > pend) return -1;
        *pch++ = 0x7D;
        *pch++ = 'Q';
        *pch++ = 0x31;
        *pch++ = 0x31;
        *pch++ = pOEM->fcompress;
        if (!VFormat(*pdwParams, &pch, pend)) return -1;
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

        break;

    case BEGIN_COMPRESS:
        pOEM->fcompress = 0x37; // Method 1
        break;

    case BEGIN_COMPRESS_TIFF:
        pOEM->fcompress = 0x3b; // TIFF
        break;

// Support DRC
    case BEGIN_COMPRESS_DRC:
        pOEM->fcompress = 0x3c; // DRC
        break;

    case END_COMPRESS:
        pOEM->fcompress = 0x30; // No compression
        break;

    // Select Resolution
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    case SELECT_RES_1200:
        pOEM->resolution = 1200;
        pOEM->unitdiv    = 1;
        break;

    case SELECT_RES_600:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif

        pOEM->resolution = 600;
        pOEM->unitdiv    = 1;
        break;

#ifdef LIPS4C
    case SELECT_RES4C_360:
	pOEM->resolution = 360;
	pOEM->unitdiv = 1;
	if (pOEM->fcolor)
            WRITESPOOLBUF(pdevobj, cmdColorMode4C.pCmdStr, cmdColorMode4C.cbSize);
	else
            WRITESPOOLBUF(pdevobj, cmdMonochrome4C.pCmdStr, cmdMonochrome4C.cbSize);
	break;
#endif // LIPS4C

    case SELECT_RES_300:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif
        pOEM->resolution = 300;
        pOEM->unitdiv    = 2;
        break;

    case SELECT_RES_150:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif
        pOEM->resolution = 150;
        pOEM->unitdiv    = 2;
        // 150 dpi mode means only image data is 150dpi
        break;

    case OCD_BEGINDOC:
        pOEM->flips4     = FALSE;

        res = pOEM->resolution;
        if(res == 600)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);
        else if(res == 300)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);
        else if(res == 150) // 150dpi means only image data is 150dpi
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);
        else
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);

        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
        pOEM->f1stpage = TRUE;
        pOEM->fvertical = FALSE;
        pOEM->currentpapersize = -1;
        break;

// NTRAID#NTBUG9-278671-2002/03/07-yasuho-: Finisher !work
    case OCD_BEGINDOC4_1200_CPCA2:
        pOEM->fCPCA2 = TRUE;
	/* FALL THRU */

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
    case OCD_BEGINDOC4_1200_CPCA:
        pOEM->fCPCA = TRUE;
	/* FALL THRU */

// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    case OCD_BEGINDOC4_1200:
	pOEM->masterunit = 1200;
	// Adjust unitdiv
	pOEM->unitdiv = (SHORT)(pOEM->masterunit / pOEM->resolution);
	/* FALL THRU */

    case OCD_BEGINDOC4:
        pOEM->flips4     = TRUE;

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
        if (pOEM->fCPCA)
            CPCAStart(pdevobj);
        else {
            if (!PJLStart(pdevobj))
                return -1;
        }
        goto setres;

#ifdef LBP_2030
    case OCD_BEGINDOC4_2030_CPCA:
        pOEM->fCPCA = TRUE;
	/* FALL THRU */

    case OCD_BEGINDOC4_2030:
        pOEM->flips4     = TRUE;
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
        if (pOEM->fCPCA)
            CPCAStart(pdevobj);
#endif

setres:

        res = pOEM->resolution;

// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
        if(res == 1200)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc1200.pCmdStr, cmdBeginDoc1200.cbSize);
        else if(res == 600)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);
        else if(res == 300){

#ifdef LBP_2030
// NTRAID#NTBUG9-195725-2002/03/07-yasuho-: !printed on 300dpi
            if( dwCmdCbID == OCD_BEGINDOC4_2030 || dwCmdCbID == OCD_BEGINDOC4_2030_CPCA){
                WRITESPOOLBUF(pdevobj, cmdBeginDoc4_2030.pCmdStr,cmdBeginDoc4_2030.cbSize);
            }else{
#endif
                WRITESPOOLBUF(pdevobj, cmdBeginDoc3004.pCmdStr,cmdBeginDoc3004.cbSize);
#ifdef LBP_2030
            }
#endif

        } else {

            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);

        }

        // LIPS4 features for only 730
        // Set Smoothing, Dithering and Econo mode
        i = pOEM->fsmoothing;
        j = pOEM->fecono;
        k = pOEM->fdithering;

        if(i==DEVICESETTING && j==DEVICESETTING && k==DEVICESETTING)
            ; // do nothing
        else { // send \x1B[n;n;n'v
            if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
                "\x1B[%d;%d;%d\'v", i, j, k)))
                return -1;

            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        }

#ifndef LBP_2030
        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
#endif
        pOEM->f1stpage = TRUE;
        pOEM->fvertical = FALSE;
        pOEM->currentpapersize = -1;

#ifdef LBP_2030
        // Send Color mode command
        if(pOEM->fcolor)            // COLOR or COLOR_24BPP or COLOR_8BPP
            {
            WRITESPOOLBUF(pdevobj, cmdColorMode.pCmdStr, cmdColorMode.cbSize);
            }
        else
            { // Send Monochrome mode command
            WRITESPOOLBUF(pdevobj, cmdMonochrome.pCmdStr, cmdMonochrome.cbSize);
            }

        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
#endif

        break;

#ifdef LIPS4C
    case OCD_BEGINDOC4C:
	pOEM->flips4C = TRUE;
	pOEM->f1stpage = TRUE;
	pOEM->fvertical = FALSE;
	pOEM->currentpapersize = -1;
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
	pOEM->masterunit = 360;
        WRITESPOOLBUF(pdevobj, cmdBeginDoc4C.pCmdStr, cmdBeginDoc4C.cbSize);
	break;
#endif // LIPS4C

// NTRAID#NTBUG9-304284-2002/03/07-yasuho-: Duplex isn't effective
// Actually, BEGINDOC means StartJob.
    case OCD_STARTDOC:
	// pOEM->f1stpage = TRUE;       // 1stpage means 1stdoc
	pOEM->fvertical = FALSE;
	pOEM->currentpapersize = -1;
	break;

#ifdef LBP_2030
    case OCD_SETCOLORMODE:
        pOEM->fcolor = COLOR; // if not color mode, system doesn't path
                                // here.
        pOEM->fplane = 0;
        pOEM->fplaneMax = 2;
        break;
    case OCD_SETCOLORMODE_24BPP:
        pOEM->fcolor = COLOR_24BPP;
        pOEM->fplane = 0;
        pOEM->fplaneMax = 0;
        break;

    case OCD_SETCOLORMODE_8BPP:
        pOEM->fcolor = COLOR_8BPP;
        pOEM->fplane = 0;
        pOEM->fplaneMax = 0;
        break;

    case OCD_ENDDOC4_2030:
        WRITESPOOLBUF(pdevobj, cmdEndDoc4.pCmdStr, cmdEndDoc4.cbSize);
        break;
#endif

    case OCD_ENDDOC4:
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
        if (pOEM->fCPCA)
            CPCAEnd(pdevobj, FALSE);
        else {
            WRITESPOOLBUF(pdevobj, cmdEndDoc4.pCmdStr, cmdEndDoc4.cbSize);
            PJLEnd(pdevobj);
        }
        break;

    case OCD_ENDPAGE:
        WRITESPOOLBUF(pdevobj, cmdEndPage.pCmdStr, cmdEndPage.cbSize);
        break;

#if defined(LIPS4C) || defined(LBP_2030)
    // NTRAID#NTBUG-137462-2002/03/07-yasuho-: 'X000' is printed.
    case OCD_ENDDOC4C:
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
        if (pOEM->fCPCA)
            CPCAEnd(pdevobj, TRUE);
        else
            WRITESPOOLBUF(pdevobj, cmdEndDoc4C.pCmdStr, cmdEndDoc4C.cbSize);
        break;

// NTRAID#NTBUG9-398861-2002/03/07-yasuho-: Orientation does not changed.
    case OCD_SOURCE_AUTO:
        pOEM->source = 0;
        break;

    case OCD_SOURCE_MANUAL:
        pOEM->source = 1;
        break;

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    case OCD_SOURCE_CASSETTE1:
    case OCD_SOURCE_CASSETTE2:
    case OCD_SOURCE_CASSETTE3:
    case OCD_SOURCE_CASSETTE4:
        pOEM->source = (char)(dwCmdCbID - OCD_SOURCE_CASSETTE1 + 11);
        break;

    case OCD_SOURCE_ENVELOPE:
        pOEM->source = 5;
        break;

    case OCD_BEGINPAGE4C:
	if (pOEM->f1stpage == FALSE)
	    WRITESPOOLBUF(pdevobj, cmdEndPicture.pCmdStr, cmdEndPicture.cbSize);

// NTRAID#NTBUG9-399861-2002/03/07-yasuho-: Orientation does not changed.
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
        if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
            cmdPaperSource, pOEM->source)))
            return -1;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
	// Thru away
#endif

    case OCD_BEGINPAGE:
        // Do Nothing

        if (!(pOEM->fVectCmd & VFLAG_INIT_DONE))
        {
            pOEM->fVectCmd |= VFLAG_PEN_NULL| VFLAG_BRUSH_NULL | VFLAG_INIT_DONE;
            pOEM->sBrushStyle = 0;
            pOEM->sPenStyle = 0;
        }

        pOEM->bLogicStyle = INIT;
        // NTRAID#NTBUG-120638-2002/03/07-yasuho-: image shift to right
        pOEM->ptCurrent.x = pOEM->ptInLine.x = 0;
        pOEM->ptCurrent.y = pOEM->ptInLine.y = 0;
        pOEM->stringwidth = 0;
        // NTRAID#NTBUG-289488-2002/03/07-yasuho-:
        // Vertical font doesn't rotated on 2nd page.
        pOEM->fvertical = FALSE;
        pOEM->CharOrientation[0] = pOEM->CharOrientation[1] = INIT;
        pOEM->CharOrientation[2] = pOEM->CharOrientation[3] = INIT;
        break;

    case OCD_PORTRAIT:
    case OCD_LANDSCAPE:

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
        if (pOEM->fCPCA) {
// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
            // Set number of copies
            if (pOEM->sorttype != SORTTYPE_SORT && pOEM->collate != COLLATE_ON)
                i = pOEM->copies;
            else
                i = 1;
            if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
                "\x1B[%dv", i)))
                return -1;
            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        }

        // Select Paper Size
        if (!SelectPaperSize(pdevobj, pOEM->papersize))
            return -1;

// NTRAID#NTBUG-185762-2002/03/07-yasuho-: Tilde isn't printed
// #ifndef LIPS4
        // If first page, the registration data would be downloaded
        // It doesn't need on LIPS4
        if(pOEM->f1stpage == TRUE && pOEM->flips4 == FALSE)
//        if(pOEM->f1stpage == TRUE)
            {
            // Download Graphic Set Registration to keep the conpatibility
            // against Canon's 3.1 driver
            // "\x1b[743;1796;30;0;32;127;.\x7dIBM819"
            // It means to register Windows character set for SBCS Device
            // fonts.
#ifdef LIPS4C
	    if (pOEM->flips4C)
                WRITESPOOLBUF(pdevobj, cmdGSETREGST4C.pCmdStr, cmdGSETREGST4C.cbSize);
	    else
                WRITESPOOLBUF(pdevobj, cmdGSETREGST.pCmdStr, cmdGSETREGST.cbSize);
#else
            WRITESPOOLBUF(pdevobj, cmdGSETREGST.pCmdStr, cmdGSETREGST.cbSize);
#endif // LIPS4C

            // Download SBCS physical device fontface from Dutch-Roman(7)
            // ZapfCalligraphic-BoldItalic(41)
            // Between the fontfaces, put \x00, and at the end of face,
            // put \x00 x 2
            for(i=0; i<MaxSBCSNumber; ++i)
                { // download all SBCS (ANSI) facename
                  // (without Symbol, Dingbats, DBCS)
                WRITESPOOLBUF(pdevobj, "\x00", 1); // put 0 at top of facename
                WRITESPOOLBUF(pdevobj, PSBCSList[i].facename, PSBCSList[i].len);
                }

            // and Graphic set registration command(REGDataSize = 193)
#ifdef LIPS4C
	    if(pOEM->flips4C)
                WRITESPOOLBUF(pdevobj, GrxData4C, REGDataSize4C);
	    else
                WRITESPOOLBUF(pdevobj, GrxData, REGDataSize);
#else
            WRITESPOOLBUF(pdevobj, GrxData, REGDataSize);
#endif // LIPS4C
            }
// #endif // !LIPS4

        // LIPS4 features
        if(pOEM->f1stpage == TRUE && pOEM->flips4 == TRUE)
            {
// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
            // N x Pages support
            switch (pOEM->nxpages) {
            default:
                WRITESPOOLBUF(pdevobj, cmdx1Page.pCmdStr, cmdx1Page.cbSize);
                break;
            case OCD_PAPERQUALITY_2XL:
                k = 21;
                goto xnpagecom;
            case OCD_PAPERQUALITY_2XR:
                k = 22;
                goto xnpagecom;
            case OCD_PAPERQUALITY_4XL:
                k = 41;
                goto xnpagecom;
            case OCD_PAPERQUALITY_4XR:
                k = 42;
                goto xnpagecom;
            xnpagecom:
                i = pOEM->papersize - PAPER_FIRST;
                if (FAILED(StringCchPrintfExA(ch, sizeof ch, &pch, NULL, 0,
                    cmdxnPageX, k, PaperIDs[i])))
                    return -1;
                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
                break;
            }

            // Duplexing support
            if(pOEM->fduplex == FALSE)
                {
                WRITESPOOLBUF(pdevobj, cmdDuplexOff.pCmdStr, cmdDuplexOff.cbSize);
                }
            else
                {
                WRITESPOOLBUF(pdevobj, cmdDuplexOn.pCmdStr, cmdDuplexOn.cbSize);
                if(pOEM->fduplextype == VERT) // Long edge
                    WRITESPOOLBUF(pdevobj, cmdDupLong.pCmdStr, cmdDupLong.cbSize);
                else
                    WRITESPOOLBUF(pdevobj, cmdDupShort.pCmdStr,cmdDupShort.cbSize);
                }
            }

// NTRAID#NTBUG-228625-2002/03/07-yasuho-: Stacker support
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
        // These command does no longer used.
        // "\x1B[12;{tray#};{faceup}~"
        // We use PJL command instead.

        // Start Font & Graphic list
        // Send "\x1B[0&\x7D" : Enter Vector Mode (VDM)
        WRITESPOOLBUF(pdevobj, cmdBeginVDM.pCmdStr, cmdBeginVDM.cbSize);

        // Download phisical font list and graphic set list
        // Send "\x20<" : Start Font List
        WRITESPOOLBUF(pdevobj, cmdFontList.pCmdStr, cmdFontList.cbSize);

        // All Physical fonts which can be supported in LIPS are downloaded
        // <p facename><separater><p facename2><separater>....
        // ...<p facenameN><\x1e (end of font list)>
        for(i=0; i<MaxFontNumber-1; ++i)
            { // download all fonts which can be supported in LIPS
            WRITESPOOLBUF(pdevobj, PFontList[i].facename, PFontList[i].len);
            WRITESPOOLBUF(pdevobj, cmdListSeparater.pCmdStr, cmdListSeparater.cbSize);
            }
        WRITESPOOLBUF(pdevobj, PFontList[i].facename, PFontList[i].len);

        // End of font list, send \x1e
        WRITESPOOLBUF(pdevobj, "\x1E", 1); // put 0x1e at end of facename

        // Initialize font height
        // When downloading font list, character heigh will be initialized.
        pOEM->tblPreviousFont.FontHeight = INIT;

        // All graphic set are downloaded
        // Send "\x20;" : Start Graphics set List
        WRITESPOOLBUF(pdevobj, cmdGrxList.pCmdStr, cmdGrxList.cbSize);

        // All Graphics sets which can be supported in LIPS are downloaded
        // <graphics set1><separater><graphics set2><separater>....
        // ...<graphics setN><\x1e (end of font list)>
        // NTRAID#NTBUG-185762-2002/03/07-yasuho-: Tilde isn't print
#ifdef LIPS4C
	if (pOEM->flips4C)
		pGS = GrxSetL4C;
	else
#endif
#ifdef LIPS4
	if (pOEM->flips4)
		pGS = GrxSetL4;
	else
#endif
		pGS = GrxSetL3;
        for(i=0; i<MaxGrxSetNumber-1; ++i, ++pGS)
            { // All Graphics sets which can be supported in LIPS are downloaded
            WRITESPOOLBUF(pdevobj, pGS->grxsetname, pGS->len);
            WRITESPOOLBUF(pdevobj, cmdListSeparater.pCmdStr, cmdListSeparater.cbSize);
            }
        WRITESPOOLBUF(pdevobj, pGS->grxsetname, pGS->len);


        res = pOEM->resolution;

        // Begin picture, set Scaling mode (in dots), Begin picture body
        // Send "\x1E#\x1E!0#\x1E$"
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
        if(res == 1200)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture1200.pCmdStr
                            , cmdBeginPicture1200.cbSize);
            }
        else if(res == 600)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture600.pCmdStr
                            , cmdBeginPicture600.cbSize);
            }
#ifdef LIPS4C
        else if(res == 360)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture4C.pCmdStr
                            , cmdBeginPicture4C.cbSize);
            }
#endif // LIPS4C
        else
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture.pCmdStr
                            , cmdBeginPicture.cbSize);
            }

#ifdef LBP_2030

        // Send Color Selection Mode command
        if(pOEM->fcolor)
            {
            if (pOEM->fcolor == COLOR_8BPP)
                {
                // We use Color Index for a text color [sueyas]
                // Send "\x1E!10"
                WRITESPOOLBUF(pdevobj, cmdColorIndex.pCmdStr, cmdColorIndex.cbSize);
                }
	    else
                {
                // We use RGB presentation
                // Send "\x1E!11"
                WRITESPOOLBUF(pdevobj, cmdColorRGB.pCmdStr, cmdColorRGB.cbSize);
                }
            }

        // Start VDM mode  (in dots), Begin picture body
        // Send "\x1E$"
        WRITESPOOLBUF(pdevobj, cmdEnterPicture.pCmdStr, cmdEnterPicture.cbSize);
#endif

        // If needed, Send VDC Extent

        // Specify a unit of text height (in dots), text clip mode (stroke)
        // Send "\x1E"\x7D#1\x1EU2\x1E"
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
        if(res == 1200)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip1200.pCmdStr, cmdTextClip1200.cbSize);
            }
        else if(res == 600)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip600.pCmdStr, cmdTextClip600.cbSize);
            }
#ifdef LIPS4C
        else if (res == 360)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip4C.pCmdStr, cmdTextClip4C.cbSize);
            }
#endif // LIPS4C
        else
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip.pCmdStr, cmdTextClip.cbSize);
            }

        // LIPS4 features
        // Send Poly line
        if(pOEM->flips4 == TRUE) {
            // send DMe80\x1E or DMe81\x1E
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
	    pch = ch;
	    if (&pch[4] > pend) return -1;
            *pch++ = 'D';
            *pch++ = 'M';
            if (!VFormat(res, &pch, pend)) return -1; // res

            *pch++ = (pOEM->nxpages == DEVICESETTING) ? '0' : '1';
            *pch++ = 0x1E;

            WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        }

        // As downloading font list and graphics list, font and graphics
        // table is initilized. We have to specifiy font and graphics table
        // each page except 1st page.

        if (pOEM->f1stpage == TRUE) {
            pOEM->f1stpage = FALSE;
        }
        else {
            if (!SendFontGrxID(pdevobj))
                return -1;
        }

        if (!SetPenAndBrush(pdevobj, SET_PEN))
            return -1;
        // end of orientation and begin doc
        break;

    case OCD_PRN_DIRECTION:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->Escapement = (short)*pdwParams % 360;
        break;

    case OCD_BOLD_ON:
        pOEM->fbold = TRUE;
        break;

    case OCD_BOLD_OFF:
        pOEM->fbold = FALSE;
        break;

    case OCD_ITALIC_ON:
        pOEM->fitalic = TRUE;
        break;

    case OCD_ITALIC_OFF:
        pOEM->fitalic = FALSE;
        break;

//    case OCD_UNDERLINE_ON:
//    case OCD_UNDERLINE_OFF:
//    case OCD_DOUBLEUNDERLINE_ON:
//    case OCD_DOUBLEUNDERLINE_OFF:
//    case OCD_STRIKETHRU_ON:
//    case OCD_STRIKETHRU_OFF:
    case OCD_WHITE_TEXT_ON:
        pOEM->fwhitetext = TRUE;
        break;

    case OCD_WHITE_TEXT_OFF:
        pOEM->fwhitetext = FALSE;
        break;

    case OCD_SINGLE_BYTE:
        pOEM->fdoublebyte = FALSE;
        break;

    case OCD_DOUBLE_BYTE:
        pOEM->fdoublebyte = TRUE;
        break;

    case OCD_VERT_ON:
        pOEM->fvertical = TRUE;
        break;

    case OCD_VERT_OFF:
        pOEM->fvertical = FALSE;
        break;

    case CUR_XM_ABS:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
        pOEM->ptCurrent.x = pOEM->ptInLine.x  = (short)*pdwParams
                                           / (pOEM->unitdiv);

        pOEM->printedchars = 0;
        pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

    case CUR_YM_ABS:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
        pOEM->ptCurrent.y = pOEM->ptInLine.y  = (short)*pdwParams
                                           / (pOEM->unitdiv);
        // NTRAID#NTBUG9-120640-2002/03/07-yasuho-:
        // Some characters shifted to right
	// Because this driver was set AT_GRXDATA_ORIGIN on CursorXAfterSend-
	// BlockData. Some of cases unidrv will only sent YMove command.
	// So it should be clear when any cursor move command was sent.
	// NTRAID#NTBUG-150061-2002/03/08-yasuho-: 
	// Subscript fonts are overlapped.
	// Revised for NTBUG9-120640. NTBUG9-120640 was fixed by GDI and
	// this fix has some side effects. Therefore, should be removed.
        // pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

    case CUR_XM_REL:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
        pOEM->ptCurrent.x = pOEM->ptInLine.x  += ((short)*pdwParams
                                           / (pOEM->unitdiv));
        // NTRAID#NTBUG9-120640-2002/03/07-yasuho-:
        // Some characters shifted to right
        pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

    case CUR_YM_REL:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
        pOEM->ptCurrent.y = pOEM->ptInLine.y  += ((short)*pdwParams
                                           / (pOEM->unitdiv));
        // NTRAID#NTBUG9-120640-2002/03/07-yasuho-:
        // Some characters shifted to right
        pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: XY_ABS: Remove the dead code

    case CUR_CR:
        // Unidrv needs to send CR in order to set x dimension to 0.
        pOEM->ptCurrent.x = pOEM->ptInLine.x  = 0;

        pOEM->printedchars = 0;
        pOEM->stringwidth  = 0;

        break;

// LIPS4 Features
    // Duplexing support
    case OCD_DUPLEX_ON:
        pOEM->fduplex  = TRUE;

        break;
    case OCD_DUPLEX_VERT:
        pOEM->fduplex  = TRUE;
        pOEM->fduplextype  = VERT;

        break;
    case OCD_DUPLEX_HORZ:
        pOEM->fduplex  = TRUE;
        pOEM->fduplextype  = HORZ;

        break;

    // N Pages Support (2x, 4x), orders
    case OCD_PAPERQUALITY_2XL:
        pOEM->nxpages      = OCD_PAPERQUALITY_2XL;

        break;
    case OCD_PAPERQUALITY_2XR:
        pOEM->nxpages      = OCD_PAPERQUALITY_2XR;

        break;
    case OCD_PAPERQUALITY_4XL:
        pOEM->nxpages      = OCD_PAPERQUALITY_4XL;

        break;
    case OCD_PAPERQUALITY_4XR:
        pOEM->nxpages      = OCD_PAPERQUALITY_4XR;

        break;

    // Smoothing support
    case OCD_TEXTQUALITY_ON:
        pOEM->fsmoothing   = 2; // ON should be 2

        break;
    case OCD_TEXTQUALITY_OFF:
        pOEM->fsmoothing   = 1; // OFF should be 1

        break;
    // Toner economy mode
    case OCD_PRINTDENSITY_ON:
        pOEM->fecono       = 2; // ON should be 2

        break;
    case OCD_PRINTDENSITY_OFF:
        pOEM->fecono       = 1; // OFF should be 1

        break;
    // Dithering mode
    case OCD_IMAGECONTROL_ON:
        pOEM->fdithering   = 2; // ON should be 2

        break;
    case OCD_IMAGECONTROL_OFF:
        pOEM->fdithering   = 1; // OFF should be 1

        break;


// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code
// Vector command.


// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code
// Support Color Bold


// NTRAID#NTBUG9-98276-2002/03/08-yasuho-: Support Color Bold
    // Select 8 colors directly.
    case OCD_SELECTBLACK:
        r = 0;
        g = 0;
        b = 0;
        goto selcolor;
    case OCD_SELECTBLUE:
        r = 0;
        g = 0;
        b = 1000;
        goto selcolor;
    case OCD_SELECTGREEN:
        r = 0;
        g = 1000;
        b = 0;
        goto selcolor;
    case OCD_SELECTCYAN:
        r = 0;
        g = 1000;
        b = 1000;
        goto selcolor;
    case OCD_SELECTRED:
        r = 1000;
        g = 0;
        b = 0;
        goto selcolor;
    case OCD_SELECTMAGENTA:
        r = 1000;
        g = 0;
        b = 1000;
        goto selcolor;
    case OCD_SELECTYELLOW:
        r = 1000;
        g = 1000;
        b = 0;
        goto selcolor;
    case OCD_SELECTWHITE:
        r = 1000;
        g = 1000;
        b = 1000;
        goto selcolor;

    // Select full color.
    case OCD_SELECTCOLOR:
        if (dwCount < 3 || !pdwParams)
            break;
	r = (pdwParams[0] * 200L) / 51L;
	g = (pdwParams[1] * 200L) / 51L;
	b = (pdwParams[2] * 200L) / 51L;
    selcolor:
        pch = ch;
        if (&pch[2] > pend) return -1;
        *pch++ = 'X';	// Select font color
        if (!VFormat(r, &pch, pend)) return -1;
        if (!VFormat(g, &pch, pend)) return -1;
        if (!VFormat(b, &pch, pend)) return -1;
        *pch++ = '\x1E';
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        // Remember the current color
        pOEM->CurColor.dwRed = r;
        pOEM->CurColor.dwGreen = g;
        pOEM->CurColor.dwBlue = b;
        break;

    // Select 256 color.
    case OCD_SELECTPALETTE:
        if (dwCount < 1 || !pdwParams)
            break;
        pch = ch;
        if (&pch[2] > pend) return -1;
        *pch++ = 'X';	// Select font color
        if (!VFormat(pdwParams[0], &pch, pend)) return -1; // Palette index
        *pch++ = '\x1E';
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        // Remember the current palette index
        pOEM->dwCurIndex = pdwParams[0];
        break;

    // NTRAID#NTBUG-185185-2002/03/07-yasuho-: Support RectFill
    case OCD_SETRECTWIDTH:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
	pOEM->RectWidth = *pdwParams / pOEM->unitdiv;
	break;
    case OCD_SETRECTHEIGHT:
	if (dwCount < 1 || !pdwParams)
	    break;
	if (!pOEM->unitdiv) return -1;
	pOEM->RectHeight = *pdwParams / pOEM->unitdiv;
	break;
    case OCD_RECTWHITEFILL:
	i = 0x29;
	goto fill;
    case OCD_RECTBLACKFILL:
	i = 0x31;
	goto fill;

   fill:
	{
	    long	x, y;

	    pch = ch;
	    if (pOEM->bLogicStyle != OVER_MODE) {
		if (&pch[4] > pend) return -1;
		*pch++ = '\x7D';
		*pch++ = 'H';
		*pch++ = '0';
		*pch++ = '\x1E';
		pOEM->bLogicStyle = OVER_MODE;
	    }

	    if (&pch[7] > pend) return -1;
            *pch++ = 'I';	// specify fill pattern
            *pch++ = (BYTE)i;
            *pch++ = 0x30;
            *pch++ = '\x1E';

            *pch++ = '\x7D';
            *pch++ = ':';	// fill rectangle
	    x = pOEM->ptCurrent.x;
	    if (!VFormat(x, &pch, pend)) return -1;
	    x += pOEM->RectWidth;
	    if (!VFormat(x, &pch, pend)) return -1;
	    y = pOEM->ptCurrent.y;
	    if (!VFormat(y, &pch, pend)) return -1;
	    y += pOEM->RectHeight;
	    if (!VFormat(y, &pch, pend)) return -1;
            *pch++ = '\x1E';
	    WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
	}
	break;

// NTRAID#NTBUG-228625-2002/03/07-yasuho-: Stacker support
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    case OCD_TRAY_AUTO:
	pOEM->tray = 0;
	break;
    case OCD_TRAY_DEFAULT:
	pOEM->tray = 100;
	break;
    case OCD_TRAY_SUBTRAY:
	pOEM->tray = 101;
	break;
    case OCD_TRAY_BIN1:
    case OCD_TRAY_BIN2:
    case OCD_TRAY_BIN3:
    case OCD_TRAY_BIN4:
    case OCD_TRAY_BIN5:
    case OCD_TRAY_BIN6:
    case OCD_TRAY_BIN7:
    case OCD_TRAY_BIN8:
    case OCD_TRAY_BIN9:
    case OCD_TRAY_BIN10:
	pOEM->tray = (char)(dwCmdCbID - OCD_TRAY_BIN1 + 1);
	break;

    case OCD_JOBOFFSET:
	pOEM->method = METHOD_JOBOFFSET;
	break;
    case OCD_STAPLE:
	pOEM->method = METHOD_STAPLE;
	break;
    case OCD_FACEUP:
	pOEM->method = METHOD_FACEUP;
	break;

    case OCD_TOPLEFT:
    case OCD_TOPCENTER:
    case OCD_TOPRIGHT:
    case OCD_MIDLEFT:
    case OCD_MIDCENTER:
    case OCD_MIDRIGHT:
    case OCD_BOTLEFT:
    case OCD_BOTCENTER:
    case OCD_BOTRIGHT:
	pOEM->staple = (char)(dwCmdCbID - OCD_TOPLEFT);
	break;

// Support DRC
    case OCD_SETBMPWIDTH:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->dwBmpWidth = *pdwParams;
        break;

    case OCD_SETBMPHEIGHT:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->dwBmpHeight = *pdwParams;
        break;

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: Sorter support
    case OCD_SORT:
	pOEM->sorttype = SORTTYPE_SORT;
	break;
    case OCD_STACK:
	pOEM->sorttype = SORTTYPE_STACK;
	break;
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    case OCD_GROUP:
	pOEM->sorttype = SORTTYPE_GROUP;
	break;
    case OCD_SORT_STAPLE:
	pOEM->sorttype = SORTTYPE_STAPLE;
	break;

    case OCD_COPIES:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->copies = (WORD)pdwParams[0];
	break;

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    case OCD_STARTBIN0:
    case OCD_STARTBIN1:
    case OCD_STARTBIN2:
    case OCD_STARTBIN3:
    case OCD_STARTBIN4:
    case OCD_STARTBIN5:
    case OCD_STARTBIN6:
    case OCD_STARTBIN7:
    case OCD_STARTBIN8:
    case OCD_STARTBIN9:
    case OCD_STARTBIN10:
	pOEM->startbin = (char)(dwCmdCbID - OCD_STARTBIN0);
	break;

// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
    case OCD_COLLATE_ON:
	pOEM->collate = COLLATE_ON;
	break;
    case OCD_COLLATE_OFF:
	pOEM->collate = COLLATE_OFF;
	break;
    }

    return 0;
}


/*
 *	OEMSendFontCmd
 */
VOID APIENTRY
OEMSendFontCmd(
	PDEVOBJ		pdevobj,
	PUNIFONTOBJ	pUFObj,
	PFINVOCATION	pFInv)
{
	PGETINFO_STDVAR pSV;
#define FI_HEIGHT	(pSV->StdVar[0].lStdVariable)
#define FI_WIDTH	(pSV->StdVar[1].lStdVariable)
#define FI_TEXTYRES	(pSV->StdVar[2].lStdVariable)
#define FI_TEXTXRES	(pSV->StdVar[3].lStdVariable)
	PBYTE		pubCmd;
	PIFIMETRICS	pIFI;
	DWORD 		lres, lheight, lvert, dwGetInfo;
	PLIPSPDEV       pOEM;
	BYTE		fontid, tid;
	WORD		firstchar, lastchar, unitdiv;
	WORD		i, ii;
	DWORD		adwStdVariable[2+2*4];
	BYTE		ch[CCHMAXCMDLEN];
	PBYTE		pch;
	PBYTE		pend = &ch[CCHMAXCMDLEN];

	// DbgPrint(DLLTEXT("OEMSendFontCmd() entry.\r\n"));

	pubCmd = pFInv->pubCommand;
	if (pubCmd == NULL) {
		// DbgPrint(DLLTEXT("Invalid SelectFont command.\r\n"));
		return;
	}
	pIFI = pUFObj->pIFIMetrics;
	pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code
// 2/5/98 takashim (FONTOBJ not always available)

	//
	// Get standard variables.
	//

	pSV = (PGETINFO_STDVAR)adwStdVariable;
	pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
	pSV->dwNumOfVariable = 4;
	pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
	pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
	pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
	pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
	dwGetInfo = pSV->dwSize;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_STDVARIABLE failed.\r\n"));
		return;
	}

	lres = pOEM->resolution;
	// NTRAID#NTBUG-120640-2002/03/07-yasuho-:
	// 150dpi means only image data is 150dpi
	// if(lres == 150)
	//     lres = 300;

	// use 1/300 inch unit, which should have already been set.
	// convert font height to 1/300 inch units
	lvert = FI_TEXTYRES;
	if (!pOEM->unitdiv) return;
	lheight = FI_HEIGHT / pOEM->unitdiv;

	if (!lvert) return;
	pOEM->tblCurrentFont.FontHeight = (short)((lheight
	    * lres + lvert/2) / lvert);
	//pOEM->tblCurrentFont.FontHeight = (short)(((lheight
	//    - (long)(lpFont->dfInternalLeading)) * lres + lvert/2) / lvert);
	pOEM->tblCurrentFont.FontWidth = (short)(FI_WIDTH / pOEM->unitdiv);
	// lpLips->tblCurrentFont.MaxWidth  = (short)(lpFont->dfMaxWidth);
	pOEM->tblCurrentFont.MaxWidth  = (short)(pIFI->fwdAveCharWidth * 2);
	pOEM->tblCurrentFont.AvgWidth  = (short)(pIFI->fwdAveCharWidth);
	if (!(pIFI->fwdWinAscender + pIFI->fwdWinDescender)) return;
	// NTRAID#NTBUG-120474-2002/03/07-yasuho-: font shift to right
	pOEM->tblCurrentFont.Ascent    = (short)(pOEM->tblCurrentFont.FontHeight
		* pIFI->fwdWinAscender / (pIFI->fwdWinAscender +
		pIFI->fwdWinDescender));

    // Obtain X/Y size ratio and calculate horizontal
    // expansion factor (supporting non-square scaling.)
 	if (!FI_HEIGHT || !FW_IFI(pIFI)) return;
        pOEM->tblCurrentFont.Stretch = (SHORT)(100
            * FI_WIDTH * FH_IFI(pIFI) / FI_HEIGHT / FW_IFI(pIFI));

	// Get font ID
	fontid = pubCmd[0]; // the first character means font Id

	if(fontid < FirstLogicalFont)
	    return;

        pch = ch;

	// Send font, grx ids x 4 x 2

	tid = LFontList[fontid - FirstLogicalFont][0];
	if (&pch[2] > pend) return;
	// Font ID G0
	*pch++ = 'T';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[0] = tid;

	tid = LFontList[fontid - FirstLogicalFont][1];
	if (&pch[2] > pend) return;
	// Font ID G1
	*pch++ = 'm';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[1] = tid;

	tid = LFontList[fontid - FirstLogicalFont][2];
	if (&pch[2] > pend) return;
	// Font ID G2
	*pch++ = 'n';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[2] = tid;

	tid = LFontList[fontid - FirstLogicalFont][3];
	if (&pch[2] > pend) return;
	// Font ID G3
	*pch++ = 'o';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[3] = tid;

	tid = LFontList[fontid - FirstLogicalFont][4];
	if (&pch[2] > pend) return;
	// Grx ID G0
	*pch++ = ']';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[4] = tid;

	tid = LFontList[fontid - FirstLogicalFont][5];
	if (&pch[2] > pend) return;
	// Grx ID G1
	*pch++ = 0x60;
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[5] = tid;

	tid = LFontList[fontid - FirstLogicalFont][6];
	if (&pch[2] > pend) return;
	// Grx ID G2
	*pch++ = 'a';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[6] = tid;

	tid = LFontList[fontid - FirstLogicalFont][7];
	if (&pch[2] > pend) return;
	// Grx ID G3
	*pch++ = 'b';
	if (!VFormat(tid, &pch, pend)) return;
	*pch++ = 0x1E;
	pOEM->curFontGrxIds[7] = tid;

	WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

	pOEM->GLTable = INIT;
	pOEM->GRTable = INIT;
	// NTRAID#NTBUG-150055-2002/03/07-yasuho-: 
	// White device font isn't printed out
	pOEM->OrnamentedChar[0] = pOEM->OrnamentedChar[1] = INIT;

	//*******************************************************************
	// Propotional Character Width Table
	// This buffer is saved character widths of LIPS device font to
	// caluculate a location of text in OEMOutputChar(). In LIPS, we
	// have to specify a location of text when printing the text every
	// time. But we can't get the information of lacation of text from
	// Unidriver every calling. So we need to manage the location of
	// text by ourselves in OEMOutputChar().
	//
	// By Hitoshis at March 28, 1995
	//*******************************************************************

	// Set Pitch of the font
	// if (pIFI->flInfo &
	//     (FM_INFO_OPTICALLY_FIXED_PITCH|FM_INFO_DBCS_FIXED_PITCH))
	// NTRAID#NTBUG9-120640-2002/03/07-yasuho-: for the proportional fonts
	if (pIFI->jWinPitchAndFamily & 0x01)
	    pOEM->fpitch = FIXED;
	else
	    pOEM->fpitch = PROP;

// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code

	// Save cached font in this time
	pOEM->cachedfont = fontid;
}


// **** Text path
BOOL SetTextPath(pdevobj, vert)
    PDEVOBJ	pdevobj;
    BOOL	vert;
{
    PLIPSPDEV  pOEM;
    char       c1;
    BOOL       ret;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    if(vert == TRUE) // Vertical writing mode
       c1 = 0x33;
    else // Horisontal writing mode
       c1 = 0x30;

    // Now send out printer commands if necessary.

    ret = FALSE;

    if (pOEM->TextPath != c1) {
        // set horizontal or vertical writing mode
        pOEM->TextPath = c1;
        ret = TRUE;
    }

    return ret;
}

// **** Character orientation
BOOL SetCharOrient(pdevobj, vert)
    PDEVOBJ	pdevobj;
    BOOL	vert;
{
    PLIPSPDEV  pOEM;
    short      s1, s2, s3, s4;
    short      t1, t2, t3, t4;
    BOOL       ret;
    short      esc;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    if(pOEM->fitalic == TRUE && vert != TRUE) {
        // if Italic and horisontal writing mode
        s1 = 208; // x of up vecter
        s2 = -978; // y of up vecter
        s3 = 1000; // x of base vecter
        s4 = 0; // y of base vecter
    } else if(pOEM->fitalic != TRUE && vert != TRUE) {
        // if non Italic and horisontal writing mode
        s1 = 0; // x of up vecter
        s2 = -1000; // y of up vecter
        s3 = 1000; // x of base vecter
        s4 = 0; // y of base vecter
    } else if(pOEM->fitalic == TRUE && vert == TRUE) {
        // if Italic and vertical writing mode
        s1 = -1000; // x of up vecter
        s2 = 0; // y of up vecter
        s3 = 208; // x of base vecter
        s4 = -978; // y of base vecter
    } else {
        // if non Italic and vertical writing mode
        s1 = -1000; // x of up vecter
        s2 = 0; // y of up vecter
        s3 = 0; // x of base vecter
        s4 = -1000; // y of base vecter
    }

    // calculate print direction
    t1 = s1; t2 = s2; t3 = s3; t4 = s4;
    esc = (pOEM->Escapement)/90;
    switch(esc) {
    case 0:
        break;

    case 1: // 90
        s1 = t2; // x of up vecter
        s2 = -t1; // y of up vecter
        s3 = t4; // x of base vecter
        s4 = -t3; // y of base vecter
        break;

    case 2: // 180
        s1 = -t1; // x of up vecter
        s2 = -t2; // y of up vecter
        s3 = -t3; // x of base vecter
        s4 = -t4; // y of base vecter
        break;

    case 3: // 270
        s1 = -t2; // x of up vecter
        s2 = t1; // y of up vecter
        s3 = -t4; // x of base vecter
        s4 = t3; // y of base vecter
        break;
    }

    // Now send out printer commands if necessary.

    ret = FALSE;

    if (pOEM->CharOrientation[0] != s1 ||
        pOEM->CharOrientation[1] != s2 ||
        pOEM->CharOrientation[2] != s3 ||
        pOEM->CharOrientation[3] != s4) {
        // save character orientation vector
        pOEM->CharOrientation[0] = s1;
        pOEM->CharOrientation[1] = s2;
        pOEM->CharOrientation[2] = s3;
        pOEM->CharOrientation[3] = s4;
        ret = TRUE;
    }

    return ret;
}


// **** Check cursor positoin after printing text
// Prop DBCS support
void UpdatePosition(pdevobj, len, width, bDBCSFont)
    PDEVOBJ	pdevobj;
    short       len;
    short	width;
    BOOL        bDBCSFont;
{
    PLIPSPDEV pOEM;
    char i;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    if(pOEM->fpitch == FIXED) {
        long       lmw, lc, s1;

        // lmw = (long)(pOEM->tblCurrentFont.MaxWidth);
        // lc = (long)len;
        // NTRAID#NTBUG-120640-2002/03/07-yasuho-: 
        // should be used FontHeight instead of MaxWidth
        // lmw = (long)(pOEM->tblCurrentFont.FontHeight);
        // NTRAID#NTBUG9-394067-2002/03/07-yasuho-: 
        // Compute font width with font stretching.
        s1 = pOEM->tblCurrentFont.Stretch;
        lmw = (long)(pOEM->tblCurrentFont.FontHeight * s1) / 100;
        if (len != 2)	// for single byte chars
	    lmw /= 2;

        // pOEM->stringwidth += (long)((lmw*lc+1)/2);
        pOEM->stringwidth += lmw - 1;
    } else if (bDBCSFont) {
    // Prop DBCS support
        long    w;

// NTRAID#NTBUG9-371640-2002/03/07-yasuho-: 
// Suisu and Dacchi isn't printed correctly on 150dpi.
        w = (width * 300) / pOEM->resolution;
        // NTRAID#NTBUG9-394067-2002/03/07-yasuho-: 
        // Compute font width with font stretching.
        w = (w * pOEM->tblCurrentFont.Stretch) / 100;
        pOEM->stringwidth += ((long)(pOEM->tblCurrentFont.FontHeight) * w)
            / 1000;
    } else {
// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code
// Prop DBCS support
        // Save a printed string width for device propotional character
        for(i=0; i<len; ++i) {
	    short	res, pow;
	    long	w;

            // sc = (short)((uchar)(lpstr[i])); // getting character code
            // pOEM->stringwidth += (long)((pOEM->widthbuffer)[sc]);
            // NTRAID#NTBUG-120640-2002/03/07-yasuho-: 
	    // I don't know why it should be power of 2 but it should be
	    // need to add for NT5 unidrv.	1/14/98 yasuho
	    res = pOEM->resolution;
	    w = width;
            // NTRAID#NTBUG9-394067-2002/03/07-yasuho-: 
            // Compute font width with font stretching.
            w = (w * pOEM->tblCurrentFont.Stretch) / 100;
#ifdef LIPS4C
            // NTRAID#NTBUG-185704-2002/03/07-yasuho-: 
	    // Font overlaps each other.
	    // Adjust font width calculation. This printers resolution does
	    // not divisible by integer calculation.
	    if (res == 360) {
		    pow = 1 * 2;
		    w = (long)width * 600L / res;
	    } else
#endif
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
	    if (!res) return;
	    pow = 1200 / res;
            pOEM->stringwidth += ((long)(pOEM->tblCurrentFont.FontHeight) *
		(long)(w * pow)) / 1000;
        }
    }
}

// **** Put location of the text
VOID
PutTextLocation(
    PDEVOBJ pdevobj,
    LONG *pCx,
    LONG *pCy)
{

    PLIPSPDEV  pOEM;
    long       cx, cy;
    short      esc;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    esc = (pOEM->Escapement)/90;

    switch(esc) {
    case 0:
        pOEM->ptInLine.x += (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) { // Vertical writing mode
            cy += (pOEM->tblCurrentFont.FontHeight / 2)
                         - pOEM->tblCurrentFont.Ascent;
        }
        break;

    case 1: // 90
        pOEM->ptInLine.y -= (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) { // Vertical writing mode
            cx -= (pOEM->tblCurrentFont.FontHeight / 2)
                         + pOEM->tblCurrentFont.Ascent
                         - pOEM->tblCurrentFont.FontHeight;
        }
        break;

    case 2: // 180
        pOEM->ptInLine.x -= (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) { // Vertical writing mode
            cy -= (pOEM->tblCurrentFont.FontHeight / 2)
                         - pOEM->tblCurrentFont.Ascent;
        }
        break;

    case 3: // 270
        pOEM->ptInLine.y += (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) { // Vertical writing mode
            cx += (pOEM->tblCurrentFont.FontHeight / 2)
                         + pOEM->tblCurrentFont.Ascent
                         - pOEM->tblCurrentFont.FontHeight;
        }
        break;
    }

    *pCx = cx;
    *pCy = cy;

    pOEM->stringwidth = 0;
}

/***************************************************************************
    Function Name : oemOutputChar

    Parameters    : LPDV	lpdv		Private Device Structure
                    LPSTR	lpstr		Print String
                    WORD	len		Length
                    WORD	rcID		Font ID

    Note          :

***************************************************************************/
short WINAPI oemOutputChar(pdevobj, lpstr, len, pIFI, width)
PDEVOBJ	pdevobj;
LPSTR lpstr;
WORD len;
PIFIMETRICS pIFI;
WORD width;
{
// #define MAKEWORD(l, h)  ((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))

// #define bIsDBCSLeadByte(c) \
//     ((c) >= 0x81 && (c) <= 0x9f || (c) >= 0xe0 && (c) <=0xfc)
#define bIsControlChar(c) \
    ((c) >= 0x00 && (c) <= 0x1f || (c) >= 0x80 && (c) <= 0x9f)

WORD	wJIScode;

BYTE *pStr;
PLIPSPDEV  pOEM;
BYTE       ch[CCHMAXCMDLEN];
short      i;
char       c1, c2;
char       p1, p2;
short      s1;
short      tsh, tsw;

BOOL bDBCSFont;
BYTE chCtrl[CCHMAXCMDLEN];
INT fTemp, fTempNew;
WORD wCount;
LONG cX, cY;
BOOL bVert;
BOOL bTemp;
BOOL bIsDBCS;
PBYTE   pch;
PBYTE   pend = &ch[CCHMAXCMDLEN];
// NTRAID#NTBUG9-679838-2002/08/05-yasuho-: dot does not printed.
PBYTE   pchCtrl;
PBYTE   pchCend = &chCtrl[CCHMAXCMDLEN];

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    // pOEM->fvertical = RcidIsDBCSVertFont( rcID );
    // bDBCSFont = RcidIsDBCSFont( rcID );
    pStr = (BYTE *)pIFI + pIFI->dpwszFaceName;
    pOEM->fvertical = (pStr[0] == '@' && pStr[1] == '\0'); // vertical font
    bDBCSFont = (pIFI->jWinCharSet == SHIFTJIS_CHARSET);
    bIsDBCS = (len == 2);

// **** Logic style
// Send logic style
if (pOEM->fcolor) {

    // If it is full-color mode, set logic to PATCOPY
    // (same value as B/W OR_MODE)

    if (pOEM->bLogicStyle != OR_MODE) {
        pch = ch;
        if (&pch[4] > pend) return -1;
        *pch++ = '\x7D';
        *pch++ = 'H';
        *pch++ = '1';
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        pOEM->bLogicStyle = OR_MODE;
    }

} else {

    if(pOEM->fwhitetext == TRUE && pOEM->bLogicStyle != AND_MODE) {
        // "\x7DH0\x0E" If White text mode, we should set AND mode
        pch = ch;
        if (&pch[4] > pend) return -1;
        *pch++ = '\x7D';
        *pch++ = 'H';
        *pch++ = '3';
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        pOEM->bLogicStyle = AND_MODE;
    }

    if(pOEM->fwhitetext != TRUE && pOEM->bLogicStyle != OR_MODE) {
        // "\x7DH1\x0E" If Black text mode, we should set OR mode
        pch = ch;
        if (&pch[4] > pend) return -1;
        *pch++ = '\x7D';
        *pch++ = 'H';
        *pch++ = '1';
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        pOEM->bLogicStyle = OR_MODE;
    }

} // fcolor

// NTRAID#NTBUG9-98276-2002/03/08-yasuho-: Support Color Bold
if (pOEM->fbold && pOEM->fcolor) {
    if ((pOEM->fcolor == COLOR_8BPP && pOEM->dwCurIndex != pOEM->dwOutIndex) ||
        (pOEM->fcolor != COLOR_8BPP &&
        (pOEM->CurColor.dwRed != pOEM->OutColor.dwRed ||
        pOEM->CurColor.dwGreen != pOEM->OutColor.dwGreen ||
        pOEM->CurColor.dwBlue != pOEM->OutColor.dwBlue))) {

        // Select Outline color.
        // We also need to specify the outline color for expand the character.
        pch = ch;
        if (&pch[3] > pend) return -1;
        *pch++ = 0x7D;          // Select Outline color
        *pch++ = 'X';
        if (pOEM->fcolor == COLOR_8BPP) { // palette mode
            if (!VFormat(pOEM->dwCurIndex, &pch, pend)) return -1;
            pOEM->dwOutIndex = pOEM->dwCurIndex;
        } else {
            if (!VFormat(pOEM->CurColor.dwRed, &pch, pend)) return -1;
            if (!VFormat(pOEM->CurColor.dwGreen, &pch, pend)) return -1;
            if (!VFormat(pOEM->CurColor.dwBlue, &pch, pend)) return -1;
            pOEM->OutColor = pOEM->CurColor;
        }
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    }
}

// **** Ornamented character
if(pOEM->fwhitetext == TRUE)
    c1 = -9; // white fill
else
    c1 = 1; // black fill

if(pOEM->fbold == TRUE)
    {
    short y;
    short res;

    y   = pOEM->tblCurrentFont.FontHeight;
    res = pOEM->resolution;

    // OrnamentedChar[1] : means how much bold is per Character Height
    // 0 regular,-2 < 48point,-3 < 96point,-4 >= 96points
    // 150dpi : 0 regular,-2 < 200dots,-3 < 400dots,-4 >= 400dots
    // 300dpi : 0 regular,-2 < 200dots,-3 < 400dots,-4 >= 400dots
    // 600dpi : 0 regular,-2 < 400dots,-3 < 800dots,-4 >= 800dots
    // (150dpi means only image date is 150dpi)
    //
    // NTRAID#NTBUG9-98276-2002/03/08-yasuho-: Support Color Bold
    // Calculate the expanded factor for the color mode.
    if (!(res / 6)) return -1;
    if (pOEM->fcolor) {
        c2 = (y / (res / 6)) + 1;
    } else {
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    if(res == 1200)
        {
        if(y < 400)
            c2 = -2; // Bold
        else if(y < 800)
            c2 = -3; // Bold
        else if(y >= 800)
            c2 = -4; // Bold
        }
    else if(res == 600)
        {
        if(y < 400)
            c2 = -2; // Bold
        else if(y < 800)
            c2 = -3; // Bold
        else if(y >= 800)
            c2 = -4; // Bold
        }
#ifdef LIPS4C
    else if(res == 360)
        {
        if(y < 240)
            c2 = -2; // Bold
        else if(y < 480)
            c2 = -3; // Bold
        else if(y >= 480)
            c2 = -4; // Bold
        }
#endif // LIPS4C
    else if(res == 300)
        {
        if(y < 200)
            c2 = -2; // Bold
        else if(y < 400)
            c2 = -3; // Bold
        else if(y >= 400)
            c2 = -4; // Bold
        }
    else if(res == 150)
        {
        if(y < 200)
            c2 = -2; // Bold
        else if(y < 400)
            c2 = -3; // Bold
        else if(y >= 400)
            c2 = -4; // Bold
        }
    else
        {
        c2 = 0; // Regular
        }
    } // fcolor
    } // fbold
// NTRAID#NTBUG9-441432-2002/03/07-yasuho-: 
// PREFIX: "c2" does not initialized if pOEM->fbold is FALSE.
else
    c2 = 0; // Regular

// Output OrnamentedCharacter
p1 = pOEM->OrnamentedChar[0]; // fill mode
p2 = pOEM->OrnamentedChar[1]; // weight bold

if(c1==p1 && c2==p2)
    ;  // we don't need to send this command
else
    // NTRAID#NTBUG9-98276-2002/03/07-yasuho-: Support Color Bold
    if (pOEM->fcolor) {

        // Character effects instruction #2.
        // We should use this command to bold the font for color models
        // because "<7D>^" command does not worked correctly on the color mode.
        pch = ch;
        if (&pch[11] > pend) return -1;
        *pch++ = 0x7D;
        *pch++ = '_';
        *pch++ = (c1 == -9) ? 0x29 : 0x31;      // White text
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '1';
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '0';
        if (!VFormat(c2, &pch, pend)) return -1;    // Outline size
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

        // save current mode
        pOEM->OrnamentedChar[0] = c1;
        pOEM->OrnamentedChar[1] = c2; //XXX
    } else {
        pch = ch;
        if (&pch[5] > pend) return -1;
        // \x7D^
        *pch++ = '\x7D';
        *pch++ = 0x5E;
        // fill mode
        *pch++ = (c1 == -9) ? 0x29 : 0x31; // -9:white text , 1:black text

        // save fill mode
        pOEM->OrnamentedChar[0] = c1;

        // bold mode
        if(c2==-4)
            *pch++ = 0x24; // -4 : 7 dots bold text
        else if(c2==-3)
            *pch++ = 0x23; // -3 : 5 dots bold text
        else if(c2==-2)
            *pch++ = 0x22; // -2 : 3 dots bold text
        else // should be c2 == 0
            *pch++ = 0x30; //  0 : regular text
        // save bold mode
        pOEM->OrnamentedChar[1] = c2;

        *pch++ = 0x1E;

        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

    }

// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code
// NTRAID#NTBUG-137882-2002/03/08-yasuho-: Black fonts doesn't printed.
// According to Canon, these commands doesn't necessary.

// **** Character height
s1 = pOEM->tblCurrentFont.FontHeight;
if(s1 == pOEM->tblPreviousFont.FontHeight)
    ; // we don't need to send this command
else {
    pch = ch;
    if (&pch[2] > pend) return -1;
    *pch++ = 'Y';
    if (!VFormat((long)s1, &pch, pend)) return -1;
    *pch++ = 0x1E;
    WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    // save character height
    pOEM->tblPreviousFont.FontHeight = s1;
}

// **** Character expansion factor
// support TC_SF_X_YINDEP
//tsh = pOEM->tblCurrentFont.FontHeight;
//tsw = pOEM->tblCurrentFont.MaxWidth;

s1 = pOEM->tblCurrentFont.Stretch;
if(s1 == pOEM->tblPreviousFont.Stretch)
    ; // we don't need to send this command
else {
    pch = ch;
    if (&pch[2] > pend) return -1;
    *pch++ = 'V';
    if (!VFormat((long)s1, &pch, pend)) return -1;
    *pch++ = 0x1E;
    WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    // restore character expansion factor
    pOEM->tblPreviousFont.Stretch = s1;
}

    pStr = (BYTE *)lpstr;

// **** Set writing mode

    pch = ch;
    bVert = FALSE;
    if (bDBCSFont) {
        if (bIsDBCS) {
            if (pOEM->fvertical)
                bVert = TRUE;
        }
    }

    if (SetTextPath(pdevobj, bVert)) {
        if (&pch[3] > pend) return -1;
        *pch++ = '[';
        *pch++ = pOEM->TextPath;
        *pch++ = 0x1E;
    }

    if (SetCharOrient(pdevobj, bVert)) {
        if (&pch[2] > pend) return -1;
        *pch++ = 'Z';
        if (!VFormat(pOEM->CharOrientation[0], &pch, pend)) return -1;
        if (!VFormat(pOEM->CharOrientation[1], &pch, pend)) return -1;
        if (!VFormat(pOEM->CharOrientation[2], &pch, pend)) return -1;
        if (!VFormat(pOEM->CharOrientation[3], &pch, pend)) return -1;
        *pch++ = 0x1e;
    }

// Normal Text mode
// **** Put location of the text

    bTemp = pOEM->fvertical;
    pOEM->fvertical = (char)bVert;
    PutTextLocation(pdevobj, &cX, &cY);
    pOEM->fvertical = (char)bTemp;
    if (&pch[2] > pend) return -1;
    *pch++ = '4';
    *pch++ = '0';
    if (!VFormat(cX, &pch, pend)) return -1;
    if (!VFormat(cY, &pch, pend)) return -1;

    // Check if we need switching between halfwidth and fulwidth.
    // We also check the existence of control characters.
    // Both of these require text data are send in separate chunks.

    fTemp = -1;
    // NTRAID#NTBUG9-550215-2002/03/07-yasuho-: PREFAST
    fTempNew = -1;
    wCount = 0;
    for (i = 0; i < len; i++) {
        if (bDBCSFont) {
            if (bIsDBCS) {
                fTempNew = 3;
                i++;
            }
            else if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 2;
            }
        }
        else {
            if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 1;
            }
        }

        // Status changed

        if (fTemp != fTempNew) {
            wCount++;
            fTemp = fTempNew;
        }
    }

    fTemp = -1;
    pchCtrl = chCtrl;
    for (i = 0; i < len; i++) {

        if (bDBCSFont) {
            if (bIsDBCS) {
                fTempNew = 3;
            }
            else if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 2;
            }
        }
        else {
            if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 1;
            }
        }

        if (fTemp != fTempNew) {

            wCount--;

// NTRAID#NTBUG9-679838-2002/08/05-yasuho-: dot does not printed.
            if (fTemp == 0) {
                if (&pch[1] > pend) return -1;
                *pch++ = 0x1E; // IS2
                WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
                if (&pchCtrl[1] > pchCend) return -1;
                *pchCtrl++ = 0x1E;
                WRITESPOOLBUF(pdevobj, chCtrl, (DWORD)(pchCtrl - chCtrl));
                pch = ch;
                pchCtrl = chCtrl;
                if (&pch[2] > pend) return -1;
                *pch++ = '4';
                *pch++ = '1';
            }

            if (&pch[1] > pend) return -1;
            *pch++ = (wCount > 0) ? '0' : '1';

            if (fTempNew == 3) {
                if (pOEM->fvertical == TRUE) {

                    if (pOEM->GLTable != 3) {
                        if (&pch[2] > pend) return -1;
                        *pch++ = 0x1B; // LS3
                        *pch++ = 0x6F; // LS3
                        pOEM->GLTable = 3;
                    }

                    bTemp = FALSE;
                    if (SetTextPath(pdevobj, TRUE)) {
                        if (bTemp == FALSE) {
                            if (&pch[1] > pend) return -1;
                            *pch++ = 0x1e;
                            bTemp = TRUE;
                        }
                        if (&pch[3] > pend) return -1;
                        *pch++ = '[';
                        *pch++ = pOEM->TextPath;
                        *pch++ = 0x1E;
                    }

                    if (SetCharOrient(pdevobj, TRUE)) {
                        if (bTemp == FALSE) {
                            if (&pch[1] > pend) return -1;
                            *pch++ = 0x1e;
                            bTemp = TRUE;
                        }
                        if (&pch[2] > pend) return -1;
                        *pch++ = 'Z';
                        if (!VFormat(pOEM->CharOrientation[0], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[1], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[2], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[3], &pch, pend))
                            return -1;
                        *pch++ = 0x1e;
                    }

                    if (bTemp != FALSE) {
                        if (&pch[3] > pend) return -1;
                        PutTextLocation(pdevobj, &cX, &cY);
                        *pch++ = '4';
                        *pch++ = '0';
                        if (!VFormat(cX, &pch, pend)) return -1;
                        if (!VFormat(cY, &pch, pend)) return -1;
                        *pch++ = (wCount > 0) ? '0' : '1';
                    }

                }
                else {
                    if (pOEM->GLTable != 2) {
                        if (&pch[2] > pend) return -1;
                        *pch++ = 0x1B; // LS2
                        *pch++ = 0x6E; // LS2
                        pOEM->GLTable = 2;
                    }
                }
            }
            else {

                if (pOEM->GLTable != 0) {
                    if (&pch[1] > pend) return -1;
                    *pch++ = 0x0F; // SI
                    pOEM->GLTable = 0;
                }

                if (pOEM->GRTable != 1) {
                    if (&pch[2] > pend) return -1;
                    *pch++ = 0x1B; // LS1R
                    *pch++ = 0x7E; // LS1R
                    pOEM->GRTable = 1;
                }
            }

        }

        if (fTempNew == 3) {

            /* Shift JIS to JIS */
            // wJIScode = MAKEWORD(pStr[i + 1], pStr[i]);
            // wJIScode = sjis2jis( wJIScode );
            if (&pch[2] > pend) return -1;
            *pch++ = pStr[i];
            *pch++ = pStr[i+1];
            // If len = 2, we assume the character is DBCS. And DBCS
            // character width is always fixed pitch.
            UpdatePosition(pdevobj, 2, width, bDBCSFont);
            i++;
        }
        else if (fTempNew == 0) {
// NTRAID#NTBUG9-679838-2002/08/05-yasuho-: dot does not printed.
            if (pchCtrl == chCtrl) {
                if (&pchCtrl[3] > pchCend) return -1;
                *pchCtrl++ = '4';
                *pchCtrl++ = 'B';
                *pchCtrl++ = '1';
                if (!VFormat(cX, &pchCtrl, pchCend)) return -1;
                if (!VFormat(cY, &pchCtrl, pchCend)) return -1;
                PutTextLocation(pdevobj, &cX, &cY);
            }
            if (&pchCtrl[1] > pchCend) return -1;
            *pchCtrl++ = pStr[i];
            UpdatePosition(pdevobj, 1, width, bDBCSFont);
        }
        else {

            if (bDBCSFont) {
                 if(pOEM->fvertical == TRUE) // Vertical writing mode
                     { // Hankaku mode always requires Horisontal writing
                     // **** Set writing mode

                    bTemp = FALSE;
                    if (SetTextPath(pdevobj, FALSE)) {
                        if (bTemp == FALSE) {
                            if (&pch[1] > pend) return -1;
                            *pch++ = 0x1e;
                            bTemp = TRUE;
                        }
                        if (&pch[3] > pend) return -1;
                        *pch++ = '[';
                        *pch++ = pOEM->TextPath;
                        *pch++ = 0x1E;
                    }

                    if (SetCharOrient(pdevobj, FALSE)) {
                        if (bTemp == FALSE) {
                            if (&pch[1] > pend) return -1;
                            *pch++ = 0x1e;
                            bTemp = TRUE;
                        }
                        if (&pch[2] > pend) return -1;
                        *pch++ = 'Z';
                        if (!VFormat(pOEM->CharOrientation[0], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[1], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[2], &pch, pend))
                            return -1;
                        if (!VFormat(pOEM->CharOrientation[3], &pch, pend))
                            return -1;
                        *pch++ = 0x1e;
                    }

                    if (bTemp != FALSE) {
                        pOEM->fvertical = FALSE;
                        PutTextLocation(pdevobj, &cX, &cY);
                        if (&pch[3] > pend) return -1;
                        *pch++ = '4';
                        *pch++ = '0';
                        if (!VFormat(cX, &pch, pend)) return -1;
                        if (!VFormat(cY, &pch, pend)) return -1;
                        *pch++ = (wCount > 0) ? '0' : '1';
                        pOEM->fvertical = TRUE;
                    }
                }
            }

            if (&pch[1] > pend) return -1;
            *pch++ = pStr[i];
            UpdatePosition(pdevobj, 1, width, bDBCSFont);
        }

        // Status changed
        if (fTemp != fTempNew) {
            fTemp = fTempNew;
        }
    }

    // Terminait string

// NTRAID#NTBUG9-679838-2002/08/05-yasuho-: dot does not printed.
    if (fTempNew == 0) {
        if (&pch[1] > pend) return -1;
        *pch++ = 0x1E; // IS2
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
        if (&pchCtrl[1] > pchCend) return -1;
        *pchCtrl++ = 0x1E;
        WRITESPOOLBUF(pdevobj, chCtrl, (DWORD)(pchCtrl - chCtrl));
    } else {
        if (&pch[1] > pend) return -1;
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    }

    return len;
}

/*
 *	OEMOutputCharStr
 */
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    PGETINFO_STDVAR	pSV;
    DWORD		adwStdVariable[2+2*2];
#define FI_FONTID	(pSV->StdVar[0].lStdVariable)
#undef	FI_WIDTH
#define FI_WIDTH	(pSV->StdVar[1].lStdVariable)
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH	GWidth;
    //
    // NTRAID#NTBUG-185776-2002/03/07-yasuho-: Some objects doesn't print
    //	There were moved to DEVOBJ.
    //
    // BYTE  aubBuff[256];
    // LONG  widBuf[64];
    // NTRAID#NTBUG-185762-2002/03/08-yasuho-: Tilde isn't printed
    // WCHAR  uniBuff[256/sizeof(WCHAR)];
// NTRAID#NTBUG-333653-2002/03/07-yasuho-: 
// Change I/F for GETINFO_GLYPHSTRING
    PTRANSDATA pTrans, aTrans;
    PDWORD pdwGlyphID;
    PWORD  pwUnicode;
    DWORD  dwI, dwGetInfo, width;
    PLIPSPDEV pOEM;
    PIFIMETRICS pIFI;
    // Prop DBCS support
    DWORD w;

    // DbgPrint(DLLTEXT("OEMOutputCharStr() entry.\r\n"));
    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        // DbgPrint(DLLTEXT("dwType = TYPE_GLYPHHANDLE\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = pOEM->aubBuff;
	dwGetInfo = GStr.dwSize;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

	CopyMemory(pOEM->uniBuff, pOEM->aubBuff, dwCount * sizeof(WCHAR));

        // pwUnicode = (PWORD)pOEM->aubBuff;
        // for (dwI = 0; dwI < dwCount; dwI ++)
        // {
        //     DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        // }

        GStr.dwTypeOut = TYPE_TRANSDATA;
// NTRAID#NTBUG-333653-2002/03/07-yasuho-: 
// Change I/F for GETINFO_GLYPHSTRING
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo) || !GStr.dwGlyphOutSize)
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }
        if ((aTrans = (PTRANSDATA)MemAlloc(GStr.dwGlyphOutSize)) == NULL) {
            // DbgPrint(DLLTEXT("MemAlloc failed.\r\n"));
            return;
        }
        GStr.pGlyphOut = aTrans;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            goto out;
        }

	//
	// Get standard variables.
	//

	pSV = (PGETINFO_STDVAR)adwStdVariable;
	pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
	pSV->dwNumOfVariable = 2;
	pSV->StdVar[0].dwStdVarID = FNT_INFO_CURRENTFONTID;
	pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
	dwGetInfo = pSV->dwSize;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_STDVARIABLE failed.\r\n"));
		goto out;
	}

	GWidth.dwSize = sizeof(GETINFO_GLYPHWIDTH);
	GWidth.dwCount = dwCount;
	GWidth.dwType = TYPE_GLYPHHANDLE;
	GWidth.pGlyph = pGlyph;
	GWidth.plWidth = pOEM->widBuf;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHWIDTH, &GWidth,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
		goto out;
	}

        // pTrans = (PTRANSDATA)pOEM->aubBuff;
        pTrans = aTrans;
	pIFI = pUFObj->pIFIMetrics;
	if (!pOEM->unitdiv) return;
	width = FI_WIDTH / pOEM->unitdiv;
        for (dwI = 0; dwI < dwCount; dwI++, pTrans++)
        {
            // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            // NTRAID#NTBUG-185762-2002/03/07-yasuho-: Tilde isn't printed
            case MTYPE_COMPOSE:
		pTrans->uCode.ubCode = (BYTE)pOEM->uniBuff[dwI];
		// FALL THRU
            case MTYPE_DIRECT:
                // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCode:0x%x\n"),pTrans->uCode.ubCode);
                oemOutputChar(pdevobj, &pTrans->uCode.ubCode, 1, pIFI,
			pOEM->widBuf[dwI]);
                break;
            case MTYPE_PAIRED:
                // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
                // Prop DBCS support
                w = (pOEM->fpitch == PROP) ? pOEM->widBuf[dwI] : width;
		if (pTrans->uCode.ubPairs[0])
			oemOutputChar(pdevobj, pTrans->uCode.ubPairs, 2, pIFI, w);
		else
			oemOutputChar(pdevobj, &(pTrans->uCode.ubPairs[1]), 1, pIFI, w);
                break;
            }
        }
out:
        MemFree(aTrans);
        break;

    case TYPE_GLYPHID:
        // DbgPrint(DLLTEXT("dwType = TYPE_GLYPHID\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHID;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_GLYPHHANDLE;
        GStr.pGlyphOut = pOEM->aubBuff;
	dwGetInfo = GStr.dwSize;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pdwGlyphID = (PDWORD)pOEM->aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            // DbgPrint(DLLTEXT("GlyphHandle[%d] = %d\r\n"), dwI, pdwGlyphID[dwI]);
        }

        GStr.dwTypeOut = TYPE_UNICODE;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pwUnicode = (PWORD)pOEM->aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            // DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            // DbgPrint(DLLTEXT("TYEP_GLYPHID:0x%x\n"), *(PDWORD)pGlyph);
            pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                 (PBYTE)pGlyph,
                                                 1);
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

// NTRAID#NTBUG9-289908-2002/03/08-yasuho-: pOEMDM -> pdevOEM
static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    // DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        // DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        // DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    // DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        // DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        // DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            // DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        // DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        // DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        // DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        // DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        // DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        // DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        // DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        // DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        // DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-550215-2002/03/08-yasuho-: Use strsafe.h
// NTRAID#NTBUG9-568220-2002/03/08-yasuho-: Remove the dead code
// NTRAID#NTBUG9-588570-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods


#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"

// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support
extern "C" {
BOOL APIENTRY
OEMWritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    PDWORD      pcbWritten);
}

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support
    else if (iid == IID_IPrintOemUni2)
    {
        *ppv = static_cast<IPrintOemUni2*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni2.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
// Support DRC
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                break;

            case (WCHAR)'I':
                break;

            case (WCHAR)'M':
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                break;
// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support
            case (WCHAR)'W':
                if (!strcmp(pstrWritePrinter, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

// NTRAID#NTBUG9-550215-2002/03/08-yasuho-: Use strsafe.h
    if (*piResult >= 0)
        return S_OK;
    else
        return E_FAIL;

}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    // return E_NOTIMPL;
// Support DRC
    *piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);
    if (*piResult > 0)
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}

// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support
LONG __stdcall IOemCB::WritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    DWORD       *pcbWritten)
{
    // DbgPrint(DLLTEXT("IOemCB::WritePrinter() entry.\r\n"));
    // return E_NOTIMPL;
    if (OEMWritePrinter(pdevobj, pBuf, cbBuffer, pcbWritten))
        return S_OK;
    else
        return E_FAIL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//


//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\drc.c ===
/*
 *	drc.c - Support Delta Row Compression
 */

#include "pdev.h"


// Support DRC

/*
 *	PutDRCData
 */
static PBYTE
PutDRCData(
    PBYTE       pData,
    DWORD       dwOffset,
    DWORD       dwSize,
    PBYTE       pOut,
    PBYTE       pOutEnd)
{
    DWORD       dwCount, dwOff;

    while (dwSize > 0) {
        dwCount = min(dwSize, 8);
        // offset
        if (dwOffset > 30) {
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)(((dwCount - 1) << 5) + 31);
            dwOffset -= 31;
            while (dwOffset >= 255) {
                dwOff = min(dwOffset, 255);
                if (pOut >= pOutEnd)
                    return NULL;
                *pOut++ = (BYTE)dwOff;
                dwOffset -= dwOff;
            }
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)dwOffset;
        } else {
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)(((dwCount - 1) << 5) + dwOffset);
        }
        dwOffset = 0;

        // data
        if (&pOut[dwCount] >= pOutEnd)
            return NULL;
        CopyMemory(pOut, pData, dwCount);
        pOut += dwCount;
        pData += dwCount;
        dwSize -= dwCount;
    }

    return pOut;
}

/*
 *	OEMCompression
 */
INT APIENTRY
OEMCompression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen)
{
    PLIPSPDEV   pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    PBYTE       pPre, pIn, pInEnd, pOut, pOutEnd, pStart, pBegin;
    PBYTE       pPre0, pIn0, pOutHead, pOut0, pOutEnd0;
    DWORD       dwI, dwLen, dwSize, dwOffset, dwCount;
    INT         rc;

#ifdef LBP_2030
    if (pOEM->fcolor == COLOR) // DRC can't support on 8color mode.
        return -1;
#endif
// NTRAID#NTBUG9-571824-2002/03/09-yasuho-:
// Possible buffer overrun if integer overflow was occured.
    if (pOEM->dwBmpWidth == 0 || pOEM->dwBmpHeight == 0 ||
        pOEM->dwBmpWidth > dwInLen || pOEM->dwBmpHeight > dwInLen ||
        (pOEM->dwBmpWidth * pOEM->dwBmpHeight) != dwInLen)
            return -1;

    // Do DRC compression
    rc = -1;
    pPre = NULL;
    pIn = pInBuf;
    pOut = pOutBuf;
    pOutEnd = &pOut[dwOutLen];

    for (dwI = 0; dwI < pOEM->dwBmpHeight; dwI++) {
        pStart = pBegin = pIn;
        pInEnd = &pIn[pOEM->dwBmpWidth];
        pOutHead = pOut;
        while (pIn < pInEnd) {
            if (pPre == NULL) {
                if (*pIn == 0) {
                    pIn++;
                    continue;
                }
            } else if (*pPre == *pIn) {
                pPre++, pIn++;
                continue;
            }
            pIn0 = pIn;
            if (pPre == NULL) {
                do {
                    pIn++;
                } while (pIn < pInEnd && *pIn);
            } else {
                do {
                    pPre++, pIn++;
                } while (pIn < pInEnd && *pPre != *pIn);
            }
            dwOffset = (DWORD)(pIn0 - pStart);
            dwSize = (DWORD)(pIn - pIn0);
            if (!(pOut = PutDRCData(pIn0, dwOffset, dwSize, pOut, pOutEnd)))
                goto out;
            pStart = pIn;
        }

        // Insert length of raster data
        if (pOut == pOutHead) {
            // identical
            if (pOut >= pOutEnd)
                goto out;
            *pOut++ = 0;
        } else {
            dwSize = (DWORD)(pOut - pOutHead);
            dwCount = (dwSize / 255) + 1;
            if (&pOut[dwCount] >= pOutEnd)
                goto out;
            pPre0 = pOut;
            pOut0 = pOut = &pOut[dwCount];
            while (pPre0 >= pOutHead)
                *--pOut0 = *--pPre0;
            pOut0 = pOutHead;
            while (dwSize >= 255) {
                dwLen = min(dwSize, 255);
                *pOut0++ = (BYTE)dwLen;
                dwSize -= dwLen;
            }
            *pOut0++ = (BYTE)dwSize;
        }

        // set to previous raster
        pPre = pBegin;
    }

    rc = (INT)(pOut - pOutBuf);

out:
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\sources.inc ===
!IF 0

Copyright (C) 1996 - 1999 Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)

TARGETNAME=cnl4jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLBASE=0x70000000
RCCODEPAGE=932

INCLUDES=$(PRNROOT)\inc

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\cnl4jres.rc \
         ..\cnl4jres.c \
         ..\common.c \
         ..\drc.c

UMTYPE=windows

MISCFILES=\
	$(GPDDIR)\cnl1510j.gpd \
	$(GPDDIR)\cnl1610j.gpd \
	$(GPDDIR)\cnl1710j.gpd \
	$(GPDDIR)\cnl1810j.gpd \
	$(GPDDIR)\cnl2030j.gpd \
	$(GPDDIR)\cnl2040j.gpd \
	$(GPDDIR)\cnl2160j.gpd \
	$(GPDDIR)\cnl2200j.gpd \
	$(GPDDIR)\cnl2260j.gpd \
	$(GPDDIR)\cnl2300j.gpd \
	$(GPDDIR)\cnl2360j.gpd \
	$(GPDDIR)\cnl310j.gpd \
	$(GPDDIR)\cnl320j.gpd \
	$(GPDDIR)\cnl320pj.gpd \
	$(GPDDIR)\cnl350j.gpd \
	$(GPDDIR)\cnl34e2j.gpd \
	$(GPDDIR)\cnl34ej.gpd \
	$(GPDDIR)\cnl34g2j.gpd \
	$(GPDDIR)\cnl39g2j.gpd \
	$(GPDDIR)\cnl404j.gpd \
	$(GPDDIR)\cnl430j.gpd \
	$(GPDDIR)\cnl44ej.gpd \
	$(GPDDIR)\cnl44fj.gpd \
	$(GPDDIR)\cnl44g2j.gpd \
	$(GPDDIR)\cnl450j.gpd \
	$(GPDDIR)\cnl45jj.gpd \
	$(GPDDIR)\cnl46dj.gpd \
	$(GPDDIR)\cnl46e2j.gpd \
	$(GPDDIR)\cnl46ej.gpd \
	$(GPDDIR)\cnl46g2j.gpd \
	$(GPDDIR)\cnl46gj.gpd \
	$(GPDDIR)\cnl46sj.gpd \
	$(GPDDIR)\cnl470j.gpd \
	$(GPDDIR)\cnl5030j.gpd \
	$(GPDDIR)\cnl66a1j.gpd \
	$(GPDDIR)\cnl66b1j.gpd \
	$(GPDDIR)\cnl68b1j.gpd \
	$(GPDDIR)\cnl720j.gpd \
	$(GPDDIR)\cnl730j.gpd \
	$(GPDDIR)\cnl740j.gpd \
	$(GPDDIR)\cnl750j.gpd \
	$(GPDDIR)\cnl830j.gpd \
	$(GPDDIR)\cnl840j.gpd \
	$(GPDDIR)\cnl850j.gpd \
	$(GPDDIR)\cnl870j.gpd \
	$(GPDDIR)\cnl880j.gpd \
	$(GPDDIR)\cnl910j.gpd \
	$(GPDDIR)\cnl930j.gpd \
	$(GPDDIR)\cnl930xj.gpd \
	$(GPDDIR)\cnl950j.gpd \
	$(GPDDIR)\cnlc680j.gpd \
	$(GPDDIR)\cnlc880j.gpd \
	$(GPDDIR)\cnli325j.gpd \
	$(GPDDIR)\cnli500j.gpd \
	$(GPDDIR)\cnli600j.gpd \
	$(GPDDIR)\cnlmeb1j.gpd \
	$(GPDDIR)\cnlmed1j.gpd \
	$(GPDDIR)\cnlmee1j.gpd \
	$(GPDDIR)\cnlp300j.gpd \
	..\cnl4jres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

// LIPS4MS.H
// The description of LIPS Device font
// Due to register device fonts before using, and we can't know
// all fonts driver has, this header file must know all font of
// LIPS to download the facename.
// Jan. 1st, 1995 Hitoshi Sekine

// NTRAID#NTBUG9-550215-2002/03/07-yasuho-: Use strsafe.h
// NTRAID#NTBUG9-568220-2002/03/07-yasuho-: Remove the dead code

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CNL4'      // Canon LIPS4 series dll
#define DLLTEXT(s)      __TEXT("CNL4:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


//***************************************************
// general current status table
//***************************************************
typedef unsigned char uchar;

//***************************************************
// LIPS current status table
//***************************************************
typedef struct tagLIPSFDV {
    short FontHeight; // Y (dots) in SendScalableFontCmd()
    short FontWidth;  // X (dots) in SendScalableFontCmd()
    short MaxWidth;
    short AvgWidth;
    short Ascent;
    short Stretch; // Width extension factor
} LIPSFDV, FAR * LPLIPSFDV;

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// NTRAID#NTBUG9-98276-2002/03/07-yasuho-: Support Color Bold
typedef struct _COLORVALUE {
        DWORD   dwRed, dwGreen, dwBlue;
} COLORVALUE;

// NTRAID#NTBUG-289908-2002/03/07-yasuho-: pOEMDM -> pdevOEM
typedef struct tag_LIPSPDEV {
	// private data as follows
    // short widthbuffer[256]; // buffer for device propotional character
    // Flags
    char  fbold; // uses Ornamented Character
    char  fitalic; // uses Char Orientatoin
    char  fwhitetext; // White Text mode
    char  fdoublebyte; // DBCS char mode
    char  fvertical; // Vertical writing mode
    char  funderline;
    char  fstrikesthu;
    char  fpitch;
    char  flpdx; // for only lpDx mode of ExtTextOut()
    char  f1stpage;
    char  fcompress; // 0x30 (no comp), 0x37 (method 1), or 0x3b (tiff)
    // features specific to LIPS4
    char  flips4;
    char  fduplex; // on or off (default)
    char  fduplextype; // vertical or horisontal
    char  fsmoothing; // device setting, on or off
    char  fecono; // device setting, on or off
    char  fdithering; // device setting, on or off
#ifdef LBP_2030
    char  fcolor;
    short fplane;
    short fplaneMax;
#endif
#ifdef LIPS4C
    char  flips4C;
#endif

    // Variables
    POINT    ptCurrent; // absolute position by cursor command
    POINT    ptInLine; // absolute position on Inline
    char     bLogicStyle;
    char     savechar; // for only lpDx mode of ExtTextOut()
    short    printedchars; // total number of printed characters
    long     stringwidth; // total width of printed propotional character
    char     firstchar; // first character code of the pfm
    char     lastchar; // last character code of the pfm

    uchar curFontGrxIds[8]; // G0 T, G1 m, G2 n, G3 o of font indeies
                            // G0 ], G1 `, G2 a, G3 b of Graphic Set indeies
                            // for GetFontCmd(), in PFM data
    LIPSFDV  tblPreviousFont; // font attribute of printer setting
    LIPSFDV  tblCurrentFont;  // font attribute of driver setting
    char  OrnamentedChar[5]; // }^ Bold sumilation
                // 1-Pattern, 2-Outline, 3-Rotation, 4-Mirror, 5-Negative
                // 2-Outline
                //   < 48 points  -> -2 (3 dots)
                //   < 96 points  -> -3 (5 dots)
                //   96 =< points -> -4 (7 dots)
    char  TextPath; // [ Vertical Writing or Horisontal Writing
    short CharOrientation[4]; // Z  Italic sumilation
//    short CharExpansionFactor; // V for only ZapfChancery ???
    char GLTable;  // takes 0 (g0), 1 (g1), 2 (g2), 3 (g3) or -1 (none)
    char GRTable;  // takes 0 (g0), 1 (g1), 2 (g2), 3 (g3) or -1 (none)
    unsigned char  cachedfont; // font id of cached font
    char  papersize; // PaperSize ID
    char  currentpapersize; // PaperSize ID in printer
// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
    DWORD dwPaperWidth;
    DWORD dwPaperHeight;
    short Escapement; // Print direction (0 - 360)
    short resolution; // resolution (600, 300, 150dpi)
		      // LIPS4C: (360, 180dpi)
    short unitdiv; // 600 / resolution (600 - 1, 300 - 2, 150 - 4)
		   // LIPS4C: (360 = 1, 180 = 2)
    // Lips4 feature
    char  nxpages; // 2xLeft, 2xRight, 4xLeft, 4xRight
//    short widthbuffer[256]; // buffer for device propotional character

    short sPenColor;
    short sPenWidth;
    short sBrushStyle;
    short sPenStyle;
    unsigned short fVectCmd;
    unsigned short  wCurrentImage;
    //
    // NTRAID#NTBUG-185776-2002/03/07-yasuho-: Some objects doesn't print
    //	Any buffer doesn't enough to print the long strings.
    //
#define MAX_GLYPHLEN	512
    WCHAR  aubBuff[MAX_GLYPHLEN];
    LONG   widBuf[MAX_GLYPHLEN];
    // NTRAID#NTBUG-185762-2002/03/07-yasuho-: Tilde isn't printed
    WCHAR  uniBuff[MAX_GLYPHLEN];
    // NTRAID#NTBUG-195162-2002/03/07-yasuho-: Color font incorrectly
    // NTRAID#NTBUG9-185185-2002/03/07-yasuho-: Support RectFill
    LONG RectWidth;
    LONG RectHeight;
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
    LONG masterunit;
// NTRAID#NTBUG-228625-2002/03/07-yasuho-: Stacker support
    char tray;          // Output tray: 0:auto, 1-N:binN,
                        //              100:default, 101:subtray
    char method;        // Output method: 0:JOB-OFFSET, 1:Staple, 2:Face up
    char staple;        // Staple mode: 0:TOPEFT, ... 9:BOTRIGHT
// NTRAID#NTBUG-399861-2002/03/07-yasuho-: Orientation does not changed.
    char source;        // Paper sources: 0:auto, 1:manual, 11:upper, 12:lower

// Support DRC
    DWORD dwBmpWidth;
    DWORD dwBmpHeight;

// NTRAID#NTBUG9-98276-2002/03/07-yasuho-: Support Color Bold
#if defined(LBP_2030) || defined(LIPS4C)
    // Remember current color to specify outline color.
    DWORD dwCurIndex, dwOutIndex;
    COLORVALUE CurColor, OutColor;
#endif // LBP_2030 || LIPS4C

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
    char fCPCA;        // Model which supported CPCA architecture.
// NTRAID#NTBUG9-278671-2002/03/07-yasuho-: Finisher !work
    char fCPCA2;       // for iR5000-6000
#define CPCA_PACKET_SIZE        20
    BYTE CPCAPKT[CPCA_PACKET_SIZE];     // CPCA Packet template buffer.
#define CPCA_BUFFER_SIZE        512
    BYTE CPCABuf[CPCA_BUFFER_SIZE];     // CPCA Packet cache buffer.
    DWORD CPCABcount;

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: Sorter support
    char sorttype;      // Sort method: 0:sort, 1:stack, 2:group
    WORD copies;

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
    char startbin;      // Start bin

// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
    char collate;       // Collate: 1:on, 0:off
} LIPSPDEV, *PLIPSPDEV;

//***************************************************
// below the definitions of structure from PFM.H
//***************************************************

typedef struct
{
  SIZEL sizlExtent;
  POINTFX  pfxOrigin;
  POINTFX  pfxCharInc;
} BITMAPMETRICS, FAR * LPBITMAPMETRICS;
typedef BYTE FAR * LPDIBITS;

 typedef struct  {
    short	dfType;
    short	dfPoints;
    short	dfVertRes;
    short	dfHorizRes;
    short	dfAscent;
    short	dfInternalLeading;
    short	dfExternalLeading;
    BYTE	dfItalic;
    BYTE	dfUnderline;
    BYTE	dfStrikeOut;
    short	dfWeight;
    BYTE	dfCharSet;
    short	dfPixWidth;
    short	dfPixHeight;
    BYTE	dfPitchAndFamily;
    short	dfAvgWidth;
    short	dfMaxWidth;
    BYTE	dfFirstChar;
    BYTE	dfLastChar;
    BYTE	dfDefaultChar;
    BYTE	dfBreakChar;
    short	dfWidthBytes;
    DWORD	dfDevice;
    DWORD	dfFace;
    DWORD	dfBitsPointer;
    DWORD	dfBitsOffset;
    BYTE	dfReservedByte;
 } PFMHEADER, * PPFMHEADER, far * LPPFMHEADER;

//***************************************************
// Defines
//***************************************************
#define OVER_MODE      0
#define OR_MODE        1
#define AND_MODE       3
#define INIT          -1
#define FIXED          0
#define PROP           1
#define DEVICESETTING  0
#define VERT           2
#define HORZ           4

// NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
#define METHOD_JOBOFFSET        1
#define METHOD_STAPLE           2
#define METHOD_FACEUP           3

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: Sorter support
#define SORTTYPE_SORT           1
#define SORTTYPE_STACK          2
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-:
// Features are different from H/W options.
#define SORTTYPE_GROUP          3
#define SORTTYPE_STAPLE         4

// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
#define COLLATE_ON              1
#define COLLATE_OFF             0

// Support DRC
#ifdef LBP_2030
#define COLOR          1
#define COLOR_24BPP    2
#define COLOR_8BPP     4
#define MONOCHROME     0
#endif

typedef struct tagLIPSCmd {
	WORD	cbSize;
	PBYTE	pCmdStr;
} LIPSCmd, FAR * LPLIPSCmd;

#ifdef LIPS4_DRIVER

//***************************************************
// LIPS command lists
//***************************************************

LIPSCmd cmdPJLTOP1         = { 23, "\x1B%-12345X@PJL CJLMODE\x0D\x0A"};
LIPSCmd cmdPJLTOP2         = { 10, "@PJL JOB\x0D\x0A"};
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
BYTE    cmdPJLBinSelect[]  = "@PJL SET BIN-SELECT = %s\r\n";
PBYTE   cmdBinType[] = {
    "AUTO",
    "OUTTRAY1",
    "OUTTRAY2",
    "BIN1",
    "BIN2",
    "BIN3",
};
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
LIPSCmd cmdPJLTOP3SUPERFINE= { 33, "@PJL SET RESOLUTION = SUPERFINE\x0D\x0A"};
LIPSCmd cmdPJLTOP3FINE     = { 28, "@PJL SET RESOLUTION = FINE\x0D\x0A"};
LIPSCmd cmdPJLTOP3QUICK    = { 29, "@PJL SET RESOLUTION = QUICK\x0D\x0A"};
// NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
LIPSCmd cmdPJLTOP31JOBOFF  = { 26, "@PJL SET JOB-OFFSET = ON\x0D\x0A"};
LIPSCmd cmdPJLTOP31STAPLE  = { 23, "@PJL SET STAPLE-MODE = "};
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
BYTE    cmdPJLSorting[]   = "@PJL SET SORTING = %s\r\n";
PBYTE   cmdSortType[] = {
    "SORT",
    "GROUP",
    "STAPLE",
};
BYTE    cmdPJLStartBin[]   = "@PJL SET START-BIN = %d\r\n";
LIPSCmd cmdPJLTOP4         = { 33, "@PJL SET LPARAM : LIPS SW2 = ON\x0D\x0A"};
LIPSCmd cmdPJLTOP5         = { 28, "@PJL ENTER LANGUAGE = LIPS\x0D\x0A"};
LIPSCmd cmdPJLBOTTOM1      = { 42, "\x1B%-12345X@PJL SET LPARM : LIPS SW2 = OFF\x0D\x0A"};
LIPSCmd cmdPJLBOTTOM2      = { 19, "@PJL EOJ\x0D\x0A\x1B%-12345X"};

// If send this command, White Bold character can be printed. But I don't
// know what command means.
LIPSCmd cmdWhiteBold       = { 9, "}S1\x1E}RF4\x1E"};

#ifdef LIPS4C
LIPSCmd cmdBeginDoc4C      = { 16, "\x1B%@\x1BP41;360;1J\x1B\\"};
LIPSCmd cmdColorMode4C     = {  7, "\x1B[1\"p\x1B<"};
LIPSCmd cmdMonochrome4C    = {  7, "\x1B[0\"p\x1B<"};
LIPSCmd cmdPaperSource4C   = {  4, "\x1B[0q"};         // AutoSheetFeeder
LIPSCmd cmdBeginPicture4C  = {  7, "\x1E#\x1E!0!2"};
LIPSCmd cmdTextClip4C      = {  9, "\x1E}y!2\x1EU2\x1E"};
#endif // LIPS4C
#if defined(LIPS4C) || defined(LBP_2030)
LIPSCmd cmdEndDoc4C        = { 11, "%\x1E}p\x1E\x1BP0J\x1B\\"};
#endif

// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
// NTRAID#NTBUG9-209691-2002/03/07-yasuho-: Inappropriately command.
LIPSCmd cmdBeginDoc1200    = { 31, "\x1B%@\x1BP41;1200;1JMS NT40 4/1200\x1B\\"};
LIPSCmd cmdBeginDoc600     = { 29, "\x1B%@\x1BP41;600;1JMS NT40 4/600\x1B\\"};
LIPSCmd cmdBeginDoc3004    = { 29, "\x1B%@\x1BP41;300;1JMS NT40 4/300\x1B\\"};
LIPSCmd cmdBeginDoc300     = { 29, "\x1B%@\x1BP31;300;1JMS NT40 3/300\x1B\\"};
LIPSCmd cmdBeginDoc150     = { 29, "\x1B%@\x1BP31;300;1JMS NT40 3/150\x1B\\"};
LIPSCmd cmdSoftReset       = { 2, "\x1B<"};
LIPSCmd cmdEndPage         = { 6, "\x0C%\x1E}p\x1E"};
LIPSCmd cmdEndDoc4         = { 6, "\x1BP0J\x1B\\"};
// LIPSCmd cmdBeginPicture600 = { 9, "\x1E#\x1E!0\x65\x38\x1E$"};
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
LIPSCmd cmdBeginPicture1200= { 8, "\x1E#\x1E!0AK0"};
#ifndef LBP_2030
LIPSCmd cmdBeginPicture600 = { 9, "\x1E#\x1E!0e8\x1E$"};
LIPSCmd cmdBeginPicture    = { 8, "\x1E#\x1E!0#\x1E$"};
#else
// NTRAID#NTBUG9-209706-2002/03/07-yasuho-: 
// Incorrect cursor move unit command.
LIPSCmd cmdBeginPicture600 = { 7, "\x1E#\x1E!0e8"};
LIPSCmd cmdBeginPicture    = { 6, "\x1E#\x1E!0#"};
LIPSCmd cmdEnterPicture    = { 2, "\x1E$"};
#endif
// LIPSCmd cmdTextClip600     = {10, "\x1E}Y\x65\x381\x1EU2\x1E"};
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
LIPSCmd cmdTextClip1200    = {11, "\x1E}YAK01\x1EU2\x1E"};
LIPSCmd cmdTextClip600     = {10, "\x1E}Ye81\x1EU2\x1E"};
LIPSCmd cmdTextClip        = { 9, "\x1E}Y#1\x1EU2\x1E"};
LIPSCmd cmdEndPicture      = { 5, "%\x1E}p\x1E"};

#ifdef LBP_2030
// NTRAID#NTBUG9-209691-2002/03/07-yasuho-: Inappropriately commands.
LIPSCmd cmdBeginDoc4_2030 = { 16, "\x1B%@\x1BP41;300;1J\x1B\\"};
LIPSCmd cmdColorMode    = {  5, "\x1B[1\"p"};
LIPSCmd cmdMonochrome   = {  5, "\x1B[0\"p"};
LIPSCmd cmdColorRGB     = {  4, "\x1E!11"};
LIPSCmd cmdColorIndex   = {  4, "\x1E!10"};
#endif

// N x Pages
LIPSCmd cmdx1Page          = { 5, "\x1B[;;o"};
// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
BYTE cmdxnPageX[] = "\x1B[%d;;%do";

// Duplex
LIPSCmd cmdDuplexOff       = { 5, "\x1B[0#x"};
LIPSCmd cmdDuplexOn        = { 7, "\x1B[2;0#x"};
LIPSCmd cmdDupLong         = { 7, "\x1B[0;0#w"};
LIPSCmd cmdDupShort        = { 7, "\x1B[2;0#w"};

// NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
LIPSCmd cmdStapleModes[]   = {
        { 7, "TOPLEFT" },       // 0
        { 9, "TOPCENTER" },     // 1
        { 8, "TOPRIGHT" },      // 2
        { 7, "MIDLEFT" },       // 3
        { 9, "MIDCENTER" },     // 4
        { 8, "MIDRIGHT" },      // 5
        { 7, "BOTLEFT" },       // 6
        { 9, "BOTCENTER" },     // 7
        { 8, "BOTRIGHT" },      // 8
};

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
BYTE cmdPaperSource[] = "\x1B[%dq";

//***************************************************
// Command Call Back IDs
//***************************************************
#define OCD_BEGINDOC             1
#define OCD_BEGINDOC4          100 // to check LIPS4 printer (730)
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
#define OCD_BEGINDOC4_1200     120
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
#define OCD_BEGINDOC4_1200_CPCA    121
// NTRAID#NTBUG9-278671-2002/03/07-yasuho-: Finisher !work
#define OCD_BEGINDOC4_1200_CPCA2   122
#ifdef LBP_2030
#define OCD_BEGINDOC4_2030     101 // to check LIPS4 printer (730)
#define OCD_ENDDOC4_2030       102
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
#define OCD_BEGINDOC4_2030_CPCA     104
#endif
#ifdef LIPS4C
#define OCD_BEGINDOC4C	       301
#endif // LIPS4C
#if defined(LIPS4C) || defined(LBP_2030)
// NTRAID#NTBUG-137462-2002/03/07-yasuho-: 'X000' is printed.
#define OCD_BEGINPAGE4C        302
#define OCD_ENDPAGE4C          303
#define OCD_ENDDOC4C           304
#endif
// NTRAID#NTBUG9-304284-2002/03/07-yasuho-: Duplex isn't effective
#define OCD_STARTDOC           130

#define OCD_PORTRAIT             2
#define OCD_LANDSCAPE            3
#define OCD_PRN_DIRECTION        4
#define OCD_ENDPAGE              5
#define OCD_ENDDOC4             99
#define OCD_BEGINPAGE            6
#define RES_SENDBLOCK            7
// NTRAID#NTBUG9-213732-2002/03/07-yasuho-: 1200dpi support
#define SELECT_RES_1200        108
#define SELECT_RES_600           8
#define SELECT_RES_300           9
#define SELECT_RES_150          10
#ifdef LIPS4C
#define SELECT_RES4C_360       308
#endif // LIPS4C
#define BEGIN_COMPRESS          11
#define BEGIN_COMPRESS_TIFF     103
#define END_COMPRESS            12
#define CUR_XM_ABS              15
#define CUR_YM_ABS              16
#define CUR_XY_ABS              17
#define CUR_CR                  18
#define OCD_BOLD_ON             20
#define OCD_BOLD_OFF            21
#define OCD_ITALIC_ON           22
#define OCD_ITALIC_OFF          23
#define OCD_UNDERLINE_ON        24
#define OCD_UNDERLINE_OFF       25
#define OCD_DOUBLEUNDERLINE_ON  26
#define OCD_DOUBLEUNDERLINE_OFF 27
#define OCD_STRIKETHRU_ON       28
#define OCD_STRIKETHRU_OFF      29
#define OCD_WHITE_TEXT_ON       30
#define OCD_WHITE_TEXT_OFF      31
#define OCD_SINGLE_BYTE         32
#define OCD_DOUBLE_BYTE         33
#define OCD_VERT_ON             34
#define OCD_VERT_OFF            35
#define CUR_XM_REL              36
#define CUR_YM_REL              37

#define OCD_DUPLEX_ON           13
#define OCD_DUPLEX_VERT         14
#define OCD_DUPLEX_HORZ         19

#define OCD_PAPERQUALITY_2XL    38
#define OCD_PAPERQUALITY_2XR    39
#define OCD_PAPERQUALITY_4XL    70
#define OCD_PAPERQUALITY_4XR    71

#define OCD_TEXTQUALITY_ON      72
#define OCD_TEXTQUALITY_OFF     73
#define OCD_PRINTDENSITY_ON     74
#define OCD_PRINTDENSITY_OFF    75
#define OCD_IMAGECONTROL_ON     76
#define OCD_IMAGECONTROL_OFF    77


#ifdef LBP_2030
#define OCD_SETCOLORMODE          200
#define OCD_SETCOLORMODE_24BPP    201
#define OCD_SETCOLORMODE_8BPP     202
#endif

// NTRAID#NTBUG9-98276-2002/03/07-yasuho-: Support Color Bold
#define OCD_SELECTBLACK         360
#define OCD_SELECTBLUE          361
#define OCD_SELECTGREEN         362
#define OCD_SELECTCYAN          363
#define OCD_SELECTRED           364
#define OCD_SELECTMAGENTA       365
#define OCD_SELECTYELLOW        366
#define OCD_SELECTWHITE         367
#define OCD_SELECTPALETTE       368
#define OCD_SELECTCOLOR         369

// NTRAID#NTBUG-185185-2002/03/07-yasuho-: Support RectFill
#define OCD_SETRECTWIDTH	401
#define OCD_SETRECTHEIGHT	402
#define OCD_RECTWHITEFILL	403
#define OCD_RECTBLACKFILL	404

// NTRAID#NTBUG9-228625-2002/03/07-yasuho-: Stacker support
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
// NOTE: Do not reorder between OCD_TOPLEFT and OCD_BOTRIGHT
#define OCD_TRAY_AUTO           410
#define OCD_TRAY_BIN1           411
#define OCD_TRAY_BIN2           412
#define OCD_TRAY_BIN3           413
#define OCD_TRAY_BIN4           414
#define OCD_TRAY_BIN5           415
#define OCD_TRAY_BIN6           416
#define OCD_TRAY_BIN7           417
#define OCD_TRAY_BIN8           418
#define OCD_TRAY_BIN9           419
#define OCD_TRAY_BIN10          420
#define OCD_TRAY_DEFAULT        428
#define OCD_TRAY_SUBTRAY        429

// NOTE: Do not reorder between OCD_TOPLEFT and OCD_BOTRIGHT
#define OCD_TOPLEFT             430
#define OCD_TOPCENTER           431
#define OCD_TOPRIGHT            432
#define OCD_MIDLEFT             433
#define OCD_MIDCENTER           434
#define OCD_MIDRIGHT            435
#define OCD_BOTLEFT             436
#define OCD_BOTCENTER           437
#define OCD_BOTRIGHT            438

// NTRAID#NTBUG9-399861-2002/03/07-yasuho-: Orientation does not changed.
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
// NOTE: DO NOT REORDER following values easier.
#define OCD_SOURCE_AUTO         450
#define OCD_SOURCE_CASSETTE1    451     // Upper
#define OCD_SOURCE_CASSETTE2    452     // Middle
#define OCD_SOURCE_CASSETTE3    453     // Lower
#define OCD_SOURCE_CASSETTE4    454
#define OCD_SOURCE_ENVELOPE     458
#define OCD_SOURCE_MANUAL       459

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: Sorter support
#define OCD_SORT                460
#define OCD_STACK               461
// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
#define OCD_GROUP               462
#define OCD_SORT_STAPLE         463     // special for MEDIO-B1

#define OCD_COPIES              465

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
#define OCD_JOBOFFSET           470
#define OCD_STAPLE              471
#define OCD_FACEUP              472

// NTRAID#NTBUG9-293002-2002/03/07-yasuho-: 
// Features are different from H/W options.
// NOTE: DO NOT REORDER following values easier.
#define OCD_STARTBIN0           480
#define OCD_STARTBIN1           481
#define OCD_STARTBIN2           482
#define OCD_STARTBIN3           483
#define OCD_STARTBIN4           484
#define OCD_STARTBIN5           485
#define OCD_STARTBIN6           486
#define OCD_STARTBIN7           487
#define OCD_STARTBIN8           488
#define OCD_STARTBIN9           489
#define OCD_STARTBIN10          490

// Support DRC
#define BEGIN_COMPRESS_DRC     510
#define OCD_SETBMPWIDTH        511
#define OCD_SETBMPHEIGHT       512

// NTRAID#NTBUG9-501162-2002/03/07-yasuho-: Collate does not work
#define OCD_COLLATE_ON          521
#define OCD_COLLATE_OFF         522

//*************************
// Paper Selection ID list
// \x1B[<Id>;;p
//*************************

// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
BYTE cmdSelectPaper[] = "\x1B[%d;;p";
BYTE cmdSelectUnit4[] = "\x1B[?7;%d I";
BYTE cmdSelectUnit3[] = "\x1B[7 I";
BYTE cmdSelectCustom[] = "\x1B[%d;%d;%dp";

/* The definitions for Page Format command */
#define PAPER_DEFAULT           44 /* 14 : A4 210 x 297 mm */

#define PAPER_FIRST             40 /*  */
#define PAPER_PORT              40 /*  0 : Portlait */
#define PAPER_LAND              41 /*  1 : Landscape */
#define PAPER_A3                42 /* 12 : A3 297 x 420 mm */
#define PAPER_A3_LAND           43 /* 13 : A3 Landscape 420 x 297 mm */
#define PAPER_A4                44 /* 14 : A4 210 x 297 mm */
#define PAPER_A4_LAND           45 /* 15 : A4 Landscape 297 x 210 mm */
#define PAPER_A5                46 /* 16 : A5 148 x 210 mm */
#define PAPER_A5_LAND           47 /* 17 : A5 Landscape 210 x 148 mm */
#define PAPER_POSTCARD          48 /* 18 : Japanese Postcard 100 x 148 mm */
#define PAPER_POSTCARD_LAND     49 /* 19 : Japanese Postcard Landscape */
#define PAPER_B4                50 /* 24 : B4 (JIS) 257 x 364 mm */
#define PAPER_B4_LAND           51 /* 25 : B4 (JIS) Landscape 364 x 257 mm */
#define PAPER_B5                52 /* 26 : B5 (JIS) 182 x 257 mm */
#define PAPER_B5_LAND           53 /* 27 : B5 (JIS) Landscape 257 x 182 mm */
#define PAPER_B6                54 /* 28 : B6 (JIS) 128 x 182 mm */
#define PAPER_B6_LAND           55 /* 29 : B6 (JIS) Landscape 182 x 128 mm */
#define PAPER_LETTER            56 /* 30 : Letter 8 1/2 x 11 in */
#define PAPER_LETTER_LAND       57 /* 31 : Letter Landscape 11 x 8 1/2 in */
#define PAPER_LEGAL             58 /* 32 : Legal 8 1/2 x 14 in */
#define PAPER_LEGAL_LAND        59 /* 33 : Legal Landscape 14 x 8 1/2 in */
#define PAPER_TABLOID           60 /* 34 : Tabloid 11 x 17 in */
#define PAPER_TABLOID_LAND      61 /* 35 : Tabloid Landscape 17 x 11 in */
#define PAPER_EXECUTIVE         62 /* 40 : Executive 7 1/4 x 10 1/2 in */
#define PAPER_EXECUTIVE_LAND    63 /* 41 : Executive Landscape */
#define PAPER_JENV_YOU4         64 /* 50 : Japanese Envelope You #4 */
#define PAPER_JENV_YOU4_LAND    65 /* 51 : Japanese Envelope You #4 Landscape */
// NTRAID#NTBUG9-350602-2002/03/07-yasuho-: Support new models for RC2
#define PAPER_DBL_POST          66 /* 20 : Japanese Double Postcard */
#define PAPER_DBL_POST_LAND     67 /* 21 : Japanese Double Postcard Landscape */
#define PAPER_JENV_YOU2         68 /* 52 : Japanese Envelope You #2 */
#define PAPER_JENV_YOU2_LAND    69 /* 53 : Japanese Envelope You #2 Landscape */
#define PAPER_LAST              69 /*  */

// Carousel
#define CAR_SET_PEN_COLOR       78

//Brush  50
#define BRUSH_SELECT            79
#define BRUSH_BYTE_2            80
#define BRUSH_END_1             81
#define BRUSH_NULL              82
#define BRUSH_SOLID             83
#define BRUSH_HOZI              84
#define BRUSH_VERT              85
#define BRUSH_FDIAG             86
#define BRUSH_BDIAG             87
#define BRUSH_CROSS             88
#define BRUSH_DIACROSS          89

#define PEN_NULL                90
#define PEN_SOLID               91
#define PEN_DASH                92
#define PEN_DOT                 93
#define PEN_DASHDOT             94
#define PEN_DASHDOTDOT          95

#define PEN_WIDTH               96

#define VECT_INIT               97

#define PENCOLOR_WHITE          0
#define PENCOLOR_BLACK          1

#define SET_PEN                 0
#define SET_BRUSH               1

#define VFLAG_PEN_NULL          0x01
#define VFLAG_BRUSH_NULL        0x02
#define VFLAG_INIT_DONE         0x04
#define VFLAG_VECT_MODE_ON      0x08

// NTRAID#NTBUG9-254925-2002/03/07-yasuho-: CUSTOM papers.
// All paper IDs
int PaperIDs[PAPER_LAST - PAPER_FIRST + 1] = {
{  0 }, /* PAPER_PORT           40 :  0 : Portlait */
{  1 }, /* PAPER_LAND           41 :  1 : Landscape */
{ 12 }, /* PAPER_A3             42 : 12 : A3 297 x 420 mm */
{ 13 }, /* PAPER_A3_LAND        43 : 13 : A3 Landscape 420 x 297 mm */
{ 14 }, /* PAPER_A4             44 : 14 : A4 210 x 297 mm */
{ 15 }, /* PAPER_A4_LAND        45 : 15 : A4 Landscape 297 x 210 mm */
{ 16 }, /* PAPER_A5             46 : 16 : A5 148 x 210 mm */
{ 17 }, /* PAPER_A5_LAND        47 : 17 : A5 Landscape 210 x 148 mm */
{ 18 }, /* PAPER_POSTCARD       48 : 18 : Japanese Postcard 100 x 148 mm */
{ 19 }, /* PAPER_POSTCARD_LAND  49 : 19 : Japanese Postcard Landscape */
{ 24 }, /* PAPER_B4             50 : 24 : B4 (JIS) 257 x 364 mm */
{ 25 }, /* PAPER_B4_LAND        51 : 25 : B4 (JIS) Landscape 364 x 257 mm */
{ 26 }, /* PAPER_B5             52 : 26 : B5 (JIS) 182 x 257 mm */
{ 27 }, /* PAPER_B5_LAND        53 : 27 : B5 (JIS) Landscape 257 x 182 mm */
{ 28 }, /* PAPER_B6             54 : 28 : B6 (JIS) 128 x 182 mm */
{ 29 }, /* PAPER_B6_LAND        55 : 29 : B6 (JIS) Landscape 182 x 128 mm */
{ 30 }, /* PAPER_LETTER         56 : 30 : Letter 8 1/2 x 11 in */
{ 31 }, /* PAPER_LETTER_LAND    57 : 31 : Letter Landscape 11 x 8 1/2 in */
{ 32 }, /* PAPER_LEGAL          58 : 32 : Legal 8 1/2 x 14 in */
{ 33 }, /* PAPER_LEGAL_LAND     59 : 33 : Legal Landscape 14 x 8 1/2 in */
{ 34 }, /* PAPER_TABLOID        60 : 34 : Tabloid 11 x 17 in */
{ 35 }, /* PAPER_TABLOID_LAND   61 : 35 : Tabloid Landscape 17 x 11 in */
{ 40 }, /* PAPER_EXECUTIVE      62 : 40 : Executive 7 1/4 x 10 1/2 in */
{ 41 }, /* PAPER_EXECUTIVE_LAND 63 : 41 : Executive Landscape */
{ 50 }, /* PAPER_JENV_YOU4      64 : 50 : Japanese Envelope You #4 */
{ 51 }, /* PAPER_JENV_YOU4_LAND 65 : 51 : JapaneseEnvelopeYou#4Landscape */
// NTRAID#NTBUG9-350602-2002/03/07-yasuho-: Support new models for RC2
{ 20 }, /* PAPER_DBL_POST       66 : 20 : Japanese Double Postcard */
{ 21 }, /* PAPER_DBL_POST_LAND  67 : 21 : Japanese Dbl Postcard Landscape */
{ 52 }, /* PAPER_JENV_YOU2      68 : 52 : Japanese Envelope You #2 */
{ 53 }, /* PAPER_JENV_YOU2_LAND 69 : 53 : JapaneseEnvelopeYou#2Landscape */
};

//***************************************************
// All font of this driver must be described here
//***************************************************
LIPSCmd cmdFontList = { 2, "\x20<"}; // Font List Command
LIPSCmd cmdListSeparater = { 1, "\x1F"}; // Separater of FontList & Graphic set

// Prop DBCS support
// Courier support
#define MaxFontNumber   59
#define MaxFacename     32
// Font Index Structure
typedef struct tagFontNo{
	char	facename[MaxFacename];
	char	len;
} FontNo, FAR * LPFontNo;

// All phisical fonts
// {"Font name", length of name}
FontNo PFontList[MaxFontNumber+1] = {
{"Mincho-Medium-H", 15},             //  1
{"Mincho-Medium", 13},               //  2
{"Gothic-Medium-H", 15},             //  3
{"Gothic-Medium", 13},               //  4
{"RoundGothic-Light-H", 19},         //  5
{"RoundGothic-Light", 17},           //  6
{"Dutch-Roman", 11},                 //  7
{"Dutch-Bold", 10},                  //  8
{"Dutch-Italic", 12},                //  9
{"Dutch-BoldItalic", 16},            // 10
{"Swiss", 5},                        // 11
{"Swiss-Bold", 10},                  // 12
{"Swiss-Oblique", 13},               // 13
{"Swiss-BoldOblique", 17},           // 14
{"Symbol", 6},                       // 15
{"Kaisho-Medium-H", 15},             // 16
{"Kaisho-Medium", 13},               // 17
{"Kyokasho-Medium-H", 17},           // 18
{"Kyokasho-Medium", 15},             // 19
{"AvantGarde-Book", 15},             // 20
{"AvantGarde-Demi", 15},             // 21
{"AvantGarde-BookOblique", 22},      // 22
{"AvantGarde-DemiOblique", 22},      // 23
{"Bookman-Light", 13},               // 24
{"Bookman-Demi", 12},                // 25
{"Bookman-LightItalic", 19},         // 26
{"Bookman-DemiItalic", 18},          // 27
{"ZapfChancery-MediumItalic", 25},   // 28
{"ZapfDingbats", 12},                // 29
{"CenturySchlbk-Roman", 19},         // 30
{"CenturySchlbk-Bold", 18},          // 31
{"CenturySchlbk-Italic", 20},        // 32
{"CenturySchlbk-BoldItalic", 24},    // 33
{"Swiss-Narrow", 12},                // 34
{"Swiss-Narrow-Bold", 17},           // 35
{"Swiss-Narrow-Oblique", 20},        // 36
{"Swiss-Narrow-BoldOblique", 24},    // 37
{"ZapfCalligraphic-Roman", 22},      // 38
{"ZapfCalligraphic-Bold", 21},       // 39
{"ZapfCalligraphic-Italic", 23},     // 40
{"ZapfCalligraphic-BoldItalic", 27}, // 41
{"Mincho-Ultra-Bold-H-YM", 22},      // 42 TypeBank font
{"Mincho-Ultra-Bold-YM", 20},        // 43 TypeBank font
{"Gothic-Bold-H-YO", 16},            // 44 TypeBank font
{"Gothic-Bold-YO", 14},              // 45 TypeBank font
{"Gyosho-Medium-H", 15},             // 46
{"Gyosho-Medium", 13},               // 47
{"Mincho-UltraBold-H", 18},          // 48
{"Mincho-UltraBold", 16},            // 49
{"Gothic-UltraBold-H", 18},          // 50
{"Gothic-UltraBold", 16},            // 51
// Prop DBCS support
{"Mincho-Medium-HPS", 17},           // 52
{"Mincho-Medium-PS", 16},            // 53
{"Gothic-Medium-HPS", 17},           // 54
{"Gothic-Medium-PS", 16},            // 55
// Courier support
{"Ncourier", 8},                     // 56
{"Ncourier-Bold", 13},               // 57
{"Ncourier-Italic", 15},             // 58
{"Ncourier-BoldItalic", 19},         // 59
{""}                                 // 60
};

//***************************************************
// All Graphic Set of this driver must be described here
//***************************************************
LIPSCmd cmdGrxList = { 2, "\x20;"}; // Graphics Set List Command

#define MaxGrxSetNumber   12
#define MaxGrxSetName     5
// GrxSet Index Structure
typedef struct tagGrxSet{
	char	grxsetname[MaxGrxSetName];
	char	len; // length of Graphic set string
} GrxSetNo, FAR * LPGrxSetNo;

// {"Graphics set name", length of name}
#ifdef LIPS4
GrxSetNo GrxSetL4[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1! &1", 5}, //  5 - Win31L (1061)
{"1! &2", 5}, //  6 - Win31R (1062)
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};
#endif // LIPS4
#ifdef LIPS4C
// {"Graphics set name", length of name}
GrxSetNo GrxSetL4C[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1\x22!$2", 5}, //  5 - 1"!$2  PSL (2142)
{"1\x27 4", 4},  //  6 - 1' 4  ?? (704) ANSI Windows char set, User defined
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};
#endif // LIPS4C
// LIPS3
GrxSetNo GrxSetL3[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1\x27\x24\x32", 4},  //  5 - IBML (742)
{"1\x27\x20\x34", 4},  //  6 - IBM819 (704 - user defined)
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};

//***************************************************
// LIPS font table
//***************************************************

// All logical fonts
/*
                   Font Index  Graphic Set Index
LFontList[Logical Font ID(PFM ID)].fontgrxids[GO,G1,G2,G3(font),G0,G1,G2,G3]
*/

// Prop DBCS support
// Courier support
#define   MaxLogicalFont   55
#define   FirstLogicalFont 101

// {font id x 4, grx id x 4}
// the index of array must be related with FontID in PFM file
// the index of array = FontID in PFM - 101
uchar LFontList[MaxLogicalFont+1][8] = {
{ 1, 1, 2, 2,  1,2,3,4},  //  1-"" (Mincho), "Mincho-Medium"
                          //  1-"W3" (HeiseiMinchoW7)
{ 3, 3, 4, 4,  1,2,3,4},  //  2-"" (Gothic), "Gothic-Medium"
                          //  2-"W5" (HeiseiGothicW9)
{ 5, 5, 6, 6,  1,2,3,4},  //  3-"" (RoundGothic), "RoundGothic-Medium"
{16,16,17,17,  1,2,3,4},  //  4-"" (Kaisho), "Kaisho-Medium"
{18,18,19,19,  1,2,3,4},  //  5-"" (Kyokasho), "Kyokasho-Medium"
{11, 3, 4, 4,  1,2,3,4},  //  6-"" (SUISU), "Swiss-Roman"
{12, 3, 4, 4,  1,2,3,4},  //  7-"" (SUISU), "Swiss-Bold"
{13, 3, 4, 4,  1,2,3,4},  //  8-"" (SUISU), "Swiss-Oblique"
{14, 3, 4, 4,  1,2,3,4},  //  9-"" (SUISU), "Swiss-BoldOblique"
{ 7, 1, 2, 2,  1,2,3,4},  // 10-"" (DACCHI), "Dutch-Roman"
{ 8, 1, 2, 2,  1,2,3,4},  // 11-"" (DACCHI), "Dutch-Bold"
{ 9, 1, 2, 2,  1,2,3,4},  // 12-"" (DACCHI), "Dutch-Italic"
{10, 1, 2, 2,  1,2,3,4},  // 13-"" (DACCHI), "Dutch-BoldItalic"
{11,11, 2, 2,  5,6,3,4},  // 14-"Swiss", "Swiss"
{12,12, 2, 2,  5,6,3,4},  // 15-"Swiss", "Swiss-Bold"
{13,13, 2, 2,  5,6,3,4},  // 16-"Swiss", "Swiss-Oblique"
{14,14, 2, 2,  5,6,3,4},  // 17-"Swiss", "Swiss-BoldOblique"
{ 7, 7, 2, 2,  5,6,3,4},  // 18-"Dutch", "Dutch-Roman"
{ 8, 8, 2, 2,  5,6,3,4},  // 19-"Dutch", "Dutch-Bold"
{ 9, 9, 2, 2,  5,6,3,4},  // 20-"Dutch", "Dutch-Italic"
{10,10, 2, 2,  5,6,3,4},  // 21-"Dutch", "Dutch-BoldItalic"
{15,15, 2, 2,  7,8,3,4},  // 22-"Symbol", "Symbol"
{20,20, 2, 2,  5,6,3,4},  // 23-"AvantGarde", "AvantGarde-Book"
{21,21, 2, 2,  5,6,3,4},  // 24-"AvantGarde", "AvantGarde-Demi"
{22,22, 2, 2,  5,6,3,4},  // 25-"AvantGarde", "AvantGarde-BookOblique"
{23,23, 2, 2,  5,6,3,4},  // 26-"AvantGarde", "AvantGarde-DemiOblique"
{24,24, 2, 2,  5,6,3,4},  // 27-"Bookman", "Bookman-Light"
{25,25, 2, 2,  5,6,3,4},  // 28-"Bookman", "Bookman-Demi"
{26,26, 2, 2,  5,6,3,4},  // 29-"Bookman", "Bookman-LightItalic"
{27,27, 2, 2,  5,6,3,4},  // 30-"Bookman", "Bookman-DemiItalic"
{28,28, 2, 2,  5,6,3,4},  // 31-"ZapfChancery", "ZapfChancery-MediumItalic"
{29,29, 2, 2,  9,10,3,4}, // 32-"ZapfDingbats", "ZapfDingbats"
{30,30, 2, 2,  5,6,3,4},  // 33-"CenturySchlbk", "CenturySchlbk-Roman"
{31,31, 2, 2,  5,6,3,4},  // 34-"CenturySchlbk", "CenturySchlbk-Bold"
{32,32, 2, 2,  5,6,3,4},  // 35-"CenturySchlbk", "CenturySchlbk-Italic"
{33,33, 2, 2,  5,6,3,4},  // 36-"CenturySchlbk", "CenturySchlbk-BoldItalic"
{34,34, 2, 2,  5,6,3,4},  // 37-"Swiss-Narrow", "Swiss-Narrow"
{35,35, 2, 2,  5,6,3,4},  // 38-"Swiss-Narrow", "Swiss-Narrow-Bold"
{36,36, 2, 2,  5,6,3,4},  // 39-"Swiss-Narrow", "Swiss-Narrow-Oblique"
{37,37, 2, 2,  5,6,3,4},  // 40-"Swiss-Narrow", "Swiss-Narrow-BoldOblique"
{38,38, 2, 2,  5,6,3,4},  // 41-"ZapfCalligraphic", "ZapfCalligraphic-Roman"
{39,39, 2, 2,  5,6,3,4},  // 42-"ZapfCalligraphic", "ZapfCalligraphic-Bold"
{40,40, 2, 2,  5,6,3,4},  // 43-"ZapfCalligraphic", "ZapfCalligraphic-Italic"
{41,41, 2, 2,  5,6,3,4},  // 44-"ZapfCalligraphic", "ZapfCalligraphic-BoldItalic"
{42,42,43,43,  1,2,3,4},  // 45-"H" (TypeBankMincho), "Mincho-Ultra-Bold"
{44,44,45,45,  1,2,3,4},  // 46-"B" (TypeBankGothic), "Gothic-Bold-YO"
{46,46,47,47,  1,2,3,4},  // 47-"s" (Gyosho), "Gyosho-Medium"

{48,48,49,49,  1,2,3,4},  // 48-"W7" (HeiseiMinchoW7), "Mincho-UltraBold"
{50,50,51,51,  1,2,3,4},  // 49-"W9" (HeiseiGothicW9), "Gothic-UltraBold"
// Prop DBCS support
{52,52,53,53,  1,2,11,12},// 50-" PS" (Mincho-PS), "Mincho-Medium-PS"
{54,54,55,55,  1,2,11,12},// 51-" PS" (Gothic-PS), "Gothic-Medium-PS"
// Courier support
{56,56, 2, 2,  5,6,3,4},  // 52-"Courier", "NCourier"
{57,57, 2, 2,  5,6,3,4},  // 53-"Courier", "NCourier-Bold"
{58,58, 2, 2,  5,6,3,4},  // 54-"Courier", "NCourier-Italic"
{59,59, 2, 2,  5,6,3,4},  // 55-"Courier", "NCourier-BoldItalic"
{0,0,0,0,0,0,0,0}    // 56
};

// Vertical font resource IDs
// They are used in OutputChar() to check with if a font is vertical
// face or not

#define RcidIsDBCSFont(k) ((k) >= 32 && (k) <= 63)
#define RcidIsDBCSVertFont(k) \
((k) == 41 || (k) == 43 || (k) == 45 || (k) == 47 || (k) == 49 ||\
(k) == 51 || (k) == 53 || (k) == 55 || (k) == 57 || (k) == 59 ||\
(k) == 61 || (k) == 63)

// #ifndef LIPS4

//***********************************************************
// Graphic Set registration data
// To keep the conpatibility against Canon's 3.1 driver 
//***********************************************************
// "\x1b[743;1796;30;0;32;127;.\x7dIBM819"
// '\x00'
//

LIPSCmd cmdGSETREGST =	{ 31, "\x1b[743;1796;30;0;32;127;.\x7dIBM819"};

// Download SBCS physical device fontface from Dutch-Roman(7)
// ZapfCalligraphic-BoldItalic(41)
// Between the fontfaces, put \x00, and at the end of face, 

#define REGDataSize  193

// put \x00 x 2
// and the following data
uchar GrxData[193+1] = {
0x00,0x00,
0x01,0x00,0x7d,0x00,0x2e,0x00,0x2f,
0x00,0x80,0x00,0x2c,0x00,0x13,0x00,0x35,0x00, // x9
0xc4,0x00,0xfc,0x00,0x94,0x00,0x21,0x00,0xc7,
0x00,0x24,0x00,0xfd,0x03,0x05,0x00,0x2b,0x00,
0x25,0x00,0xd0,0x00,0xd1,0x00,0xc2,0x00,0xa4,
0x00,0x39,0x00,0x85,0x00,0x8f,0x00,0xcf,0x00,
0x9a,0x00,0x22,0x00,0x46,0x00,0x44,0x00,0x48,
0x00,0x88,0x00,0xa8,0x00,0xa5,0x00,0xa6,0x00,
0xaa,0x00,0xa7,0x00,0xa9,0x00,0x93,0x00,0xab,
0x00,0xaf,0x00,0xac,0x00,0xad,0x00,0xae,0x00,
0xb3,0x00,0xb0,0x00,0xb1,0x00,0xb2,0x00,0x95,
0x00,0xb4,0x00,0xb8,0x00,0xb5,0x00,0xb6,0x00,
0xb9,0x00,0xb7,0x00,0x26,0x00,0x98,0x00,0xbe,
0x00,0xbb,0x00,0xbc,0x00,0xbd,0x00,0xc1,0x00,
0x96,0x00,0xa2,0x00,0xda,0x00,0xd7,0x00,0xd8,
0x00,0xdc,0x00,0xd9,0x00,0xdb,0x00,0x9b,0x00,
0xdd,0x00,0xe1,0x00,0xde,0x00,0xdf,0x00,0xe0,
0x00,0xe5,0x00,0xe2,0x00,0xe3,0x00,0xe4,0x00,
0xa3,0x00,0xe6,0x00,0xea,0x00,0xe7,0x00,0xe8,
0x00,0xeb,0x00,0xe9,0x00,0x27,0x00,0xa0,0x00,
0xf0,0x00,0xed,0x00,0xee,0x00,0xef,0x00,0xf3,
0x00,0x9e,0x00,0xf1};

#ifdef LIPS4C

LIPSCmd cmdGSETREGST4C =   { 30, "\x1b[807;1796;30;0;0;127;.\x7dIBM819"};

#define REGDataSize4C  257

// put \x00 x 2
// and the following data
uchar GrxData4C[257+1] = {
0x00,0x00,
0x01,0x00,0x01,0x00,0x86,
0x00,0x7F,0x00,0x87,0x00,0x14,0x00,0x37,
0x00,0x38,0x00,0x89,0x00,0x36,0x00,0xBA,
0x00,0x1F,0x00,0x99,0x00,0x01,0x00,0x01,
0x00,0x01,0x00,0x01,0x00,0x15,0x00,0x16,
0x00,0x17,0x00,0x18,0x00,0x04,0x00,0x84,
0x00,0x0E,0x00,0xF8,0x00,0xC6,0x00,0xEC,
0x00,0x20,0x00,0xA1,0x00,0x01,0x00,0x01,
0x00,0xBF,0x00,0x01,0x00,0x7D,0x00,0x2E,
0x00,0x2F,0x00,0x80,0x00,0x2C,0x00,0xC8,
0x00,0x35,0x00,0xC4,0x00,0xFC,0x00,0x94,
0x00,0x21,0x00,0xC7,0x00,0x0F,0x00,0xFD,
0x03,0x05,0x00,0x2B,0x00,0x25,0x00,0xD0,
0x00,0xD1,0x00,0x09,0x00,0xA4,0x00,0x39,
0x00,0x85,0x00,0x8F,0x00,0xCF,0x00,0x9A,
0x00,0x22,0x00,0x46,0x00,0x44,0x00,0x48,
0x00,0x88,0x00,0xA8,0x00,0xA5,0x00,0xA6,
0x00,0xAA,0x00,0xA7,0x00,0xA9,0x00,0x93,
0x00,0xAB,0x00,0xAF,0x00,0xAC,0x00,0xAD,
0x00,0xAE,0x00,0xB3,0x00,0xB0,0x00,0xB1,
0x00,0xB2,0x00,0x95,0x00,0xB4,0x00,0xB8,
0x00,0xB5,0x00,0xB6,0x00,0xB9,0x00,0xB7,
0x00,0x26,0x00,0x98,0x00,0xBE,0x00,0xBB,
0x00,0xBC,0x00,0xBD,0x00,0xC1,0x00,0x96,
0x00,0xA2,0x00,0xDA,0x00,0xD7,0x00,0xD8,
0x00,0xDC,0x00,0xD9,0x00,0xDB,0x00,0x9B,
0x00,0xDD,0x00,0xE1,0x00,0xDE,0x00,0xDF,
0x00,0xE0,0x00,0xE5,0x00,0xE2,0x00,0xE3,
0x00,0xE4,0x00,0xA3,0x00,0xE6,0x00,0xEA,
0x00,0xE7,0x00,0xE8,0x00,0xEB,0x00,0xE9,
0x00,0x27,0x00,0xA0,0x00,0xF0,0x00,0xED,
0x00,0xEE,0x00,0xEF,0x00,0xF3,0x00,0x9E,
0x00,0xF1};

#endif // LIPS4C

// #endif // !LIPS4

//***************************************************
// All SBCS(ANSI) font for the geristration of Graphic set
//***************************************************

#define MaxSBCSNumber   30
// #define MaxFacename     32
// Font Index Structure
// typedef struct tagFontNo{
// 	char	facename[MaxFacename];
// 	char	len;
// } FontNo, FAR * LPFontNo;

// All SBCS(ANSI) phisical fonts
FontNo PSBCSList[MaxFontNumber+1] = {
{"Dutch-Roman", 11},                 //  1
{"Dutch-Bold", 10},                  //  2
{"Dutch-Italic", 12},                //  3
{"Dutch-BoldItalic", 16},            //  4
{"Swiss", 5},                       //  5
{"Swiss-Bold", 10},                  //  6
{"Swiss-Oblique", 13},               //  7
{"Swiss-BoldOblique", 17},           //  8
{"AvantGarde-Book", 15},             //  9
{"AvantGarde-Demi", 15},             // 10
{"AvantGarde-BookOblique", 22},      // 11
{"AvantGarde-DemiOblique", 22},      // 12
{"Bookman-Light", 13},               // 13
{"Bookman-Demi", 12},                // 14
{"Bookman-LightItalic", 19},         // 15
{"Bookman-DemiItalic", 18},          // 16
{"ZapfChancery-MediumItalic", 25},   // 17
{"ZapfDingbats", 12},                // 18
{"CenturySchlbk-Roman", 19},         // 19
{"CenturySchlbk-Bold", 18},          // 20
{"CenturySchlbk-Italic", 20},        // 21
{"CenturySchlbk-BoldItalic", 24},    // 22
{"Swiss-Narrow", 12},                // 23
{"Swiss-Narrow-Bold", 17},           // 24
{"Swiss-Narrow-Oblique", 20},        // 25
{"Swiss-Narrow-BoldOblique", 24},    // 26
{"ZapfCalligraphic-Roman", 22},      // 27
{"ZapfCalligraphic-Bold", 21},       // 28
{"ZapfCalligraphic-Italic", 23},     // 29
{"ZapfCalligraphic-BoldItalic", 27}, // 30
{""}                             // 00
};

// Enter Vector mode
LIPSCmd cmdBeginVDM =	{ 5, "\x1b[0&}"};
#if defined(LBP_2030) || defined(LIPS4C)
LIPSCmd cmdEndVDM =	{ 3, "}p\x1E"};
LIPSCmd cmdBeginPalette = { 3, "^00"};
LIPSCmd cmdEndPalette =	{ 1, "\x1E"};
#endif // LBP_2030 || LIPS4C


// VectorMode commands
static char CMD_SET_PEN_WIDTH[] = "F1%s\x1E";

static char CMD_SET_PEN_TYPE[] = "E1%d\x1E";
static char CMD_SET_PEN_STYLE[]  =  "}G%d%c\x1E";
static char CMD_SET_BRUSH_STYLE[] =  "I%c%c\x1E";

//                         NULL   SOLID HOZI  VERT  FDIAG BDIAG CROSS DIACROSS
static char BrushType[8] = {0x30, 0x31, 0x25, 0x24, 0x23, 0x22, 0x27, 0x26};

#endif	// LIPS4_DRIVER

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support

// External functions
VOID CPCAInit(PLIPSPDEV pOEM);
VOID CPCAStart(PDEVOBJ pdevobj);
VOID CPCAEnd(PDEVOBJ pdevobj, BOOL fColor);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support
class IOemCB:public IPrintOemUni2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support

    //
    // IPrintOemUni2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data Universal driver is generating
    //
    // At DrvEnablePDEV time, Universal driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\spool.c ===
/*
 *	spool.c - WritePrinter hook.
 *
 *	Need to be manipulate the spooler data for Canon CPCA architecture.
 */

#include "pdev.h"

// NTRAID#NTBUG9-172276-2002/03/08-yasuho-: CPCA support

#define MAX_CPCA_PACKET_SIZE    4096    // Must be <= 64KB-1

// CPCA Operation codes
#define CPCA_JobStart           0x0011
#define CPCA_JobEnd             0x0013
#define CPCA_BinderStart        0x0014
#define CPCA_SetBinder          0x0015
#define CPCA_BinderEnd          0x0016
#define CPCA_DocumentStart      0x0017
#define CPCA_SetDocument        0x0018
#define CPCA_DocumentEnd        0x0019
#define CPCA_Send               0x001A
#define CPCA_ExecutiveMethod    0x001D

// CPCA Flags
#define F_Cont                  0x02

// CPCA Attributes
#define ATT_DOCFORMAT           0x002E
#define     DOCFORMAT_LIPS          0x27
#define ATT_RESOLUTION          0x003A
#define     RESOLUTION_QUICK        0x05
#define     RESOLUTION_FINE         0x06
#define     RESOLUTION_SUPERFINE    0x07
#define ATT_COPIES              0x07D7
#define ATT_OUTPUT              0x07D8
#define     OUTPUT_NO_COLLATE       0x08
#define     OUTPUT_COLLATE          0x0B
#define     OUTPUT_GROUP_COLLATE    0x0F
#define ATT_OUTPUTBIN           0x07D9
#define     OUTPUTBIN_FACEUP        0x01
#define     OUTPUTBIN_FACEDOWN      0x02
#define     OUTPUTBIN_SORT          0x11
#define     OUTPUTBIN_NUMBER        0x12
#define     OUTPUTBIN_STACK         0x15
#define ATT_FINISHING           0x07DA
#define     FINISHING_STAPLE        0x0C
#define     FINISHING_COUNT_1       0x66
#define     FINISHING_COUNT_2       0x67
#define ATT_OUTPUTPARTITION     0x084A
#define     OUTPART_JOBOFFSET       0x01
#define     OUTPART_NONE            0x04
#define ATT_OUTPUTFACE          0x084B
#define     OUTPUTFACE_FACEUP       0x01
#define     OUTPUTFACE_FACEDOWN     0x02
#define     OUTPUTFACE_NONE         0x03

static WORD     wStapleModes[] = {
        0x00CA,         // top_left
        0x00D5,         // top
        0x00CC,         // top_right
        0x00D3,         // left
        0x00EE,         // center (NOT USED)
        0x00D4,         // right
        0x00CB,         // bottom_left
        0x00D6,         // bottom
        0x00CD,         // bottom_right
};

extern LIPSCmd  cmdEndDoc4;
extern LIPSCmd  cmdEndDoc4C;

/*
 *	FlushCPCABuffer
 */
static BOOL
FlushCPCABuffer(PDEVOBJ pdevobj, PLIPSPDEV pOEM)
{
    DWORD               dwCount;

    if (pOEM->CPCABcount == 0)
        return TRUE;

    if (!WritePrinter(pdevobj->hPrinter, pOEM->CPCABuf, pOEM->CPCABcount,
        &dwCount) || dwCount != pOEM->CPCABcount)
        return FALSE;
    pOEM->CPCABcount = 0;

    return TRUE;
}

/*
 *      SendCPCAPacket
 */
static BOOL
SendCPCAPacket(
    PDEVOBJ pdevobj,
    WORD wCmd,
    BYTE flags,
    PBYTE pParams,
    WORD nParams)
{
    PLIPSPDEV           pOEM;
    PBYTE               pBuf;
    DWORD               dwCount;

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    dwCount = pOEM->CPCABcount;
    if (dwCount + CPCA_PACKET_SIZE + nParams > CPCA_BUFFER_SIZE) {
        if (!FlushCPCABuffer(pdevobj, pOEM))
            return FALSE;
        // NTRAID#NTBUG9-548450-2002/03/08-yasuho-: possible buffer overrun.
        dwCount = 0;
    }

    pBuf = pOEM->CPCAPKT;
    pBuf[3] = flags;
    pBuf[4] = HIBYTE(wCmd);
    pBuf[5] = LOBYTE(wCmd);
    pBuf[8] = HIBYTE(nParams);
    pBuf[9] = LOBYTE(nParams);

    CopyMemory(&pOEM->CPCABuf[dwCount], pOEM->CPCAPKT, CPCA_PACKET_SIZE);
    dwCount += CPCA_PACKET_SIZE;
    if (nParams) {
        CopyMemory(&pOEM->CPCABuf[dwCount], pParams, nParams);
        dwCount += nParams;
    }
    pOEM->CPCABcount = dwCount;

    return TRUE;
}

/*
 *      CPCAInit
 */
VOID
CPCAInit(PLIPSPDEV pOEM)
{
    pOEM->CPCAPKT[0] = 0xCD;    // Header ID
    pOEM->CPCAPKT[1] = 0xCA;
    pOEM->CPCAPKT[2] = 0x10;    // Version
    pOEM->CPCABcount = 0;
}

/*
 *      CPCAStart
 */
VOID
CPCAStart(PDEVOBJ pdevobj)
{
    PLIPSPDEV       pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    WORD            wTemp;
    BYTE            param[32];

    ZeroMemory(param, sizeof param);
    param[4] = 0x01;
    (VOID)SendCPCAPacket(pdevobj, CPCA_JobStart, 0, param, 13);

    // ZeroMemory(param, 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_BinderStart, 0, param, 4);

    param[0] = HIBYTE(ATT_COPIES);
    param[1] = LOBYTE(ATT_COPIES);
// NTRAID#NTBUG9-501162-2002/03/08-yasuho-: Collate does not work
    if (pOEM->sorttype == SORTTYPE_SORT || pOEM->collate == COLLATE_ON) {
        param[2] = HIBYTE(pOEM->copies);
        param[3] = LOBYTE(pOEM->copies);
    } else {
        param[2] = 0x00;
        param[3] = 0x01;
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 4);

    // NTRAID#NTBUG9-278671-2002/03/08-yasuho-: Finisher !work
    // NTRAID#NTBUG9-293002-2002/03/08-yasuho-: 
    // Features are different from H/W options.
    if (pOEM->fCPCA2) {
        param[0] = HIBYTE(ATT_OUTPUT);
        param[1] = LOBYTE(ATT_OUTPUT);
        param[2] = OUTPUT_COLLATE;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);
    }

    // NTRAID#NTBUG9-203340-2002/03/08-yasuho-: 
    // Output tray could not selected correctly.
    // NTRAID#NTBUG9-293002-2002/03/08-yasuho-: 
    // Features are different from H/W options.
    param[0] = HIBYTE(ATT_OUTPUTBIN);
    param[1] = LOBYTE(ATT_OUTPUTBIN);
    if (pOEM->tray == INIT || pOEM->tray == 100) {
        param[2] = OUTPUTBIN_FACEDOWN;
        ZeroMemory(&param[3], 4);
    } else if (pOEM->tray == 0) {
        param[2] = OUTPUTBIN_STACK;
        ZeroMemory(&param[3], 4);
    } else if (pOEM->tray == 101) {
        param[2] = OUTPUTBIN_FACEUP;
        ZeroMemory(&param[3], 4);
    } else {
        param[2] = OUTPUTBIN_NUMBER;
        param[3] = (BYTE)pOEM->tray;
        ZeroMemory(&param[4], 3);
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);

    if (pOEM->method != INIT) {
        // Staple stacker
        param[0] = HIBYTE(ATT_OUTPUTPARTITION);
        param[1] = LOBYTE(ATT_OUTPUTPARTITION);
        param[2] = (pOEM->method == METHOD_JOBOFFSET) ?
            OUTPART_JOBOFFSET : OUTPART_NONE;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);

        param[0] = HIBYTE(ATT_OUTPUTFACE);
        param[1] = LOBYTE(ATT_OUTPUTFACE);
        param[2] = (pOEM->method == METHOD_FACEUP) ?
            OUTPUTFACE_FACEUP : OUTPUTFACE_FACEDOWN;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);

        if (pOEM->method == METHOD_STAPLE) {
            param[0] = HIBYTE(ATT_FINISHING);
            param[1] = LOBYTE(ATT_FINISHING);
            param[2] = 1;
            param[3] = FINISHING_STAPLE;
            wTemp = pOEM->staple;
            if (wTemp < 0 || wTemp >= 9)
                wTemp = 0;
// NTRAID#NTBUG9-292998-2002/03/08-yasuho-: Stapling operate incorrectly.
            switch (wTemp) {
            default:
                param[4] = FINISHING_COUNT_1;
                break;
            case 1:     // top
            case 3:     // left
            case 5:     // right
            case 7:     // center
                param[4] = FINISHING_COUNT_2;
                break;
            }
            wTemp = wStapleModes[wTemp];
            param[5] = HIBYTE(wTemp);
            param[6] = LOBYTE(wTemp);
            (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);
        } else {
            param[0] = HIBYTE(ATT_FINISHING);
            param[1] = LOBYTE(ATT_FINISHING);
            param[2] = 0;
            (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);
        }
    } else if (pOEM->sorttype != INIT) {
        // Sorter
        param[0] = HIBYTE(ATT_OUTPUTBIN);
        param[1] = LOBYTE(ATT_OUTPUTBIN);
        param[2] = (pOEM->sorttype == SORTTYPE_SORT) ?
            OUTPUTBIN_SORT : OUTPUTBIN_STACK;
        ZeroMemory(&param[3], 4);
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);
    }

    ZeroMemory(param, 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_DocumentStart, 0, param, 4);

    param[0] = HIBYTE(ATT_DOCFORMAT);
    param[1] = LOBYTE(ATT_DOCFORMAT);
    param[2] = DOCFORMAT_LIPS;
    param[3] = 0;
    param[4] = 0;
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 5);

    // NTRAID#NTBUG9-244001-2002/03/08-yasuho-: 1200dpi doesn't work on LBP-470.
    param[0] = HIBYTE(ATT_RESOLUTION);
    param[1] = LOBYTE(ATT_RESOLUTION);
    if (pOEM->resolution == 1200)
        param[2] = RESOLUTION_SUPERFINE;
    else if (pOEM->resolution == 600)
        param[2] = RESOLUTION_FINE;
    else
        param[2] = RESOLUTION_QUICK;
    ZeroMemory(&param[3], 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 7);

    param[0] = HIBYTE(ATT_COPIES);
    param[1] = LOBYTE(ATT_COPIES);
// NTRAID#NTBUG9-501162-2002/03/08-yasuho-: Collate does not work
    if (pOEM->sorttype != SORTTYPE_SORT && pOEM->collate != COLLATE_ON) {
        param[2] = HIBYTE(pOEM->copies);
        param[3] = LOBYTE(pOEM->copies);
    } else {
        param[2] = 0x00;
        param[3] = 0x01;
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 4);

    (VOID)FlushCPCABuffer(pdevobj, pOEM);
}

/*
 *      CPCAEnd
 */
VOID
CPCAEnd(PDEVOBJ pdevobj, BOOL fColor)
{
    PLIPSPDEV       pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    LIPSCmd         *pCmd;
    BYTE            param[32];

    param[0] = 0x01;
    pCmd = fColor ? &cmdEndDoc4C : &cmdEndDoc4;
    CopyMemory(&param[1], pCmd->pCmdStr, pCmd->cbSize);
    (VOID)SendCPCAPacket(pdevobj, CPCA_Send, 0, param, pCmd->cbSize + 1);

    (VOID)SendCPCAPacket(pdevobj, CPCA_DocumentEnd, 0, NULL, 0);

    (VOID)SendCPCAPacket(pdevobj, CPCA_BinderEnd, 0, NULL, 0);

    param[0] = 0x00;
    (VOID)SendCPCAPacket(pdevobj, CPCA_JobEnd, 0, param, 1);

    (VOID)FlushCPCABuffer(pdevobj, pOEM);
}

/*
 *	OEMWritePrinter
 */
BOOL APIENTRY
OEMWritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    PDWORD      pcbWritten)
{
    PLIPSPDEV           pOEM;
    PBYTE               pTemp, pCmd;
    DWORD               dwSize, dwCount, dwWritten;
    WORD                wCount;
    BYTE                cmd[CPCA_PACKET_SIZE+1];

    // This is used for UNIDRV to detect the plug-in.
    if (pBuf == NULL && cbBuffer == 0)
        return TRUE;

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;

    // If printer is not CPCA, pass through to the spooler.
    if (!pOEM->fCPCA)
        return WritePrinter(pdevobj->hPrinter, pBuf, cbBuffer, pcbWritten) &&
            cbBuffer == *pcbWritten;

    pTemp = (PBYTE)pBuf;
    dwSize = cbBuffer;
    while (dwSize > 0) {
        dwCount = min(dwSize, MAX_CPCA_PACKET_SIZE);
        // Build Send packet
        pCmd = pOEM->CPCAPKT;
        pCmd[3] = F_Cont;
        pCmd[4] = HIBYTE(CPCA_Send);
        pCmd[5] = LOBYTE(CPCA_Send);
        wCount = (WORD)(dwCount + 1);
        pCmd[8] = HIBYTE(wCount);
        pCmd[9] = LOBYTE(wCount);
        CopyMemory(cmd, pOEM->CPCAPKT, CPCA_PACKET_SIZE);
        cmd[CPCA_PACKET_SIZE] = 0x01;
        if (!WritePrinter(pdevobj->hPrinter, cmd, sizeof cmd, &dwWritten) ||
            sizeof cmd != dwWritten)
            return FALSE;
        if (!WritePrinter(pdevobj->hPrinter, pTemp, dwCount, &dwWritten) ||
            dwCount != dwWritten)
            return FALSE;
        pTemp += dwCount;
        dwSize -= dwCount;
    }

    *pcbWritten = cbBuffer;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
// NTRAID#NTBUG9-172276-2002/03/07-yasuho-: CPCA support
CONST CHAR pstrWritePrinter[] = "WritePrinter";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include <strsafe.h>

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING, ("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING, ("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING, ("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING, ("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING, ("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CNRS'      // Canon/Qnix resource DLL
#define DLLTEXT(s)      "CNRS: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;

    // Private extention
	WORD				wMediaType;
	WORD				wPrintQuality;
	WORD				wInputBin;
} OEM_EXTRADATA, *POEM_EXTRADATA;

////////////////////////////////////////////////////////
//      OEM Command Callback ID definition
////////////////////////////////////////////////////////
// Job Setup
#define CMD_BEGIN_PAGE				1

// Media Type
#define	CMD_MEDIA_PLAIN				20		// Plain Paper
#define CMD_MEDIA_COAT				21		// Coated Paper
#define	CMD_MEDIA_OHP				22		// Transparency
#define	CMD_MEDIA_BPF				23		// Back Print Film
#define	CMD_MEDIA_FABRIC			24		// Fabric Sheet
#define	CMD_MEDIA_GLOSSY			25		// Glossy Paper
#define	CMD_MEDIA_HIGHGLOSS			26		// High Gloss Paper
#define	CMD_MEDIA_HIGHRESO			27		// High Resolution Paper
#define	CMD_MEDIA_BJ     			28		// BJ Cross
#define	CMD_MEDIA_JPNPST			29		// JapanesePostcard

// Print Quality
#define CMD_QUALITY_NORMAL			30
#define	CMD_QUALITY_HIGHQUALITY		31
#define	CMD_QUALITY_DRAFT			32

// Input Bin
#define	CMD_INPUTBIN_AUTO			40
#define	CMD_INPUTBIN_MANUAL			41

////////////////////////////////////////////////////////
//      OEM private extention index
////////////////////////////////////////////////////////
// Media Type Index
#define	NUM_MEDIA					8
#define	MEDIATYPE_PLAIN				0
#define	MEDIATYPE_COAT				1
#define	MEDIATYPE_OHP				2
#define	MEDIATYPE_BPF				3
#define	MEDIATYPE_FABRIC			4
#define	MEDIATYPE_GLOSSY			5
#define	MEDIATYPE_HIGHGLOSS			6
#define	MEDIATYPE_HIGHRESO			7

#define	MEDIATYPE_START		CMD_MEDIA_PLAIN

// PrintQuality Index
#define	NUM_QUALITY					3
#define	PRINTQUALITY_NORMAL			0
#define	PRINTQUALITY_HIGHQUALITY	1
#define PRINTQUALITY_DRAFT			2

#define	PRINTQUALITY_START	CMD_QUALITY_NORMAL

// Input Bin Index
#define NUM_INPUTBIN				2
#define	INPUTBIN_AUTO				0
#define	INPUTBIN_MANUAL				1

////////////////////////////////////////////////////////
//      Command parameter table
////////////////////////////////////////////////////////
static BYTE	bPrintModeParamTable[NUM_QUALITY][NUM_MEDIA] = 
{
	// Quality Normal
	{
		0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70
	}, 
	// Quality High Quality
	{
		0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71
	},
	// Quality Draft
	{
		0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72
	}
};
static BYTE	bInputBinMediaParamTable[NUM_MEDIA] =
{
	0x00, 0x10, 0x20, 0x20, 0x00, 0x10, 0x10, 0x00
};

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

GPDDIR_CN=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

!include $(PRNROOT)\print.inc

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),cnrstres
!else
DLLBASE=0x8000000
!endif

TARGETNAME=cnrstres
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\cnrstres.rc \
    $(SRCDIR)\cnrstres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\cnrstres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\cnrstres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// 
// Copyright (C) 1994-1999 Microsoft Corporation
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

#include <strsafe.h>

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

	// Private Extention
	pOEMExtra->wMediaType = MEDIATYPE_PLAIN;
	pOEMExtra->wPrintQuality = PRINTQUALITY_NORMAL;
	pOEMExtra->wInputBin = INPUTBIN_AUTO;
	
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wMediaType = pdmIn->wMediaType;
        pdmOut->wPrintQuality = pdmIn->wPrintQuality;
		pdmOut->wInputBin= pdmIn->wInputBin;
    }
    return TRUE;
}

// #######

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    POEM_EXTRADATA      pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
	BYTE				ESC_PRINT_MODE[] = "\x1B\x28\x63\x03\x00\x10\x00\x00";
	BYTE				ESC_INPUTBIN[]   = "\x1B\x28\x6C\x02\x00\x00\x00";

    switch(dwCmdCbId)
    {
		case CMD_BEGIN_PAGE:
			// Check the index of array
			// NTRAID#NTBUG9-577887-2002/03/15-shimm-
			if (pOEM->wPrintQuality >= NUM_QUALITY) goto error;
			if (pOEM->wMediaType >= NUM_MEDIA) goto error;

			// Set Print mode setting command parameter
			ESC_PRINT_MODE[6] = 
				bPrintModeParamTable[pOEM->wPrintQuality][pOEM->wMediaType];
			
			// Set input bin command parameter
			ESC_INPUTBIN[5] = (pOEM->wInputBin == INPUTBIN_AUTO ? 0x14 : 0x11);
			ESC_INPUTBIN[6] = bInputBinMediaParamTable[pOEM->wMediaType];

			WRITESPOOLBUF(pdevobj, (PBYTE)ESC_PRINT_MODE, 8);
			WRITESPOOLBUF(pdevobj, (PBYTE)ESC_INPUTBIN,7 );
			break;

		// Media Type
		case CMD_MEDIA_PLAIN:
		case CMD_MEDIA_COAT:
		case CMD_MEDIA_OHP:
		case CMD_MEDIA_BPF:
		case CMD_MEDIA_FABRIC:
		case CMD_MEDIA_GLOSSY:
		case CMD_MEDIA_HIGHGLOSS:
		case CMD_MEDIA_HIGHRESO:
			pOEM->wMediaType = (WORD)(dwCmdCbId - MEDIATYPE_START);
			break;

		// Print Quality
		case CMD_QUALITY_NORMAL:
		case CMD_QUALITY_HIGHQUALITY:
		case CMD_QUALITY_DRAFT:
			pOEM->wPrintQuality = (WORD)(dwCmdCbId - PRINTQUALITY_START);
			break;

		case CMD_INPUTBIN_AUTO:
			pOEM->wInputBin = INPUTBIN_AUTO;
			break;
		case CMD_INPUTBIN_MANUAL:
			pOEM->wInputBin = INPUTBIN_MANUAL;
			break;

        default:
            break;
    }

    return 0;
error:
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

// NTRAID#NTBUG9-588571-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

		// NTRAID#NTBUG9-577887-2002/03/15-shimm-
		if (*piResult < 0)
			return E_FAIL;
		else
			return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\colmatch.c ===
//***************************************************************************************************
//    COLMATCH.C
//
//    Functions of color matching
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
//#include    "DEBUG.H"
#include    "PRNCTL.H"
#include    "strsafe.h"         // Security-Code 2002.3.6


//---------------------------------------------------------------------------------------------------
//    Byte/Bit table
//---------------------------------------------------------------------------------------------------
static const BYTE BitTbl[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};


//---------------------------------------------------------------------------------------------------
//    Table for numbering dither method
//---------------------------------------------------------------------------------------------------
static const WORD DizNumTbl[7] = {1,                       // XX_DITHERING_OFF
                                  1,                       // XX_DITHERING_ON
                                  0,                       // XX_DITHERING_DET
                                  1,                       // XX_DITHERING_PIC
                                  2,                       // XX_DITHERING_GRA
                                  0,                       // XX_DITHERING_CAR
                                  3                        // XX_DITHERING_GOSA
};

#define MAX_DIZNUM (sizeof DizNumTbl / sizeof DizNumTbl[0])

//---------------------------------------------------------------------------------------------------
//    Define LUT fine name
//---------------------------------------------------------------------------------------------------
#define N4LUT000    L"CPN4RGB0.LUT"                         // For N4 printer
#define N4LUT001    L"CPN4RGB1.LUT"
#define N4LUT002    L"CPN4RGB2.LUT"
#define N4LUT003    L"CPN4RGB3.LUT"
#define N4LUT004    L"CPN4RGB4.LUT"
#define N4LUT005    L"CPN4RGB5.LUT"
#define N403LUTX    L"CPN4RGBX.LUT"                         // For N4-612 printer
#define N403LUTY    L"CPN4RGBY.LUT"

//---------------------------------------------------------------------------------------------------
//    Define DLL name
//---------------------------------------------------------------------------------------------------
#define CSN46RESDLL    L"CSN46RES.DLL"

//---------------------------------------------------------------------------------------------------
//    Define data
//---------------------------------------------------------------------------------------------------
#define DPI300    300
#define DPI600    600

static BYTE ORG_MODE_IN[]     = "\x1Bz\xD0\x01";
static BYTE ORG_MODE_OUT[]    = "\x1Bz\x00\x01";
static BYTE PALETTE_SELECT[]  = "Cd,%d,%d*";
static BYTE PLANE_RESET[]     = "Da,0,0,0,0*";

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static BOOL DizTblSetN4(PDEVOBJ, WORD);
static BOOL DizTblSetN403(PDEVOBJ, WORD);
static BOOL LutFileLoadN4(PDEVOBJ, WORD, WORD, WORD);
static BOOL LutFileLoadN403(PDEVOBJ, WORD, WORD);
static BOOL TnrTblSetN4(PDEVOBJ, SHORT);
static BOOL TnrTblSetN403(PDEVOBJ, SHORT);
static BOOL ColGosTblSet(LPN4DIZINF, WORD);
static void ColGosTblFree(LPN4DIZINF);
static void ColRgbGos(PDEVOBJ, WORD, WORD, WORD, LPBYTE);
static BOOL BmpBufAlloc(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBMPBIF);
static void BmpBufFree(LPBMPBIF);
static void BmpBufClear(LPBMPBIF);
static WORD Dithering001(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
static void BmpPrint(PDEVOBJ, LPBMPBIF, POINT, WORD, WORD, WORD);
static void BmpRGBCnv(LPRGB, LPBYTE, WORD, WORD, WORD, LPRGBQUAD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    LPN4DIZINF     lpN4DizInf;                              // N4DIZINF structure
    LPN403DIZINF   lpN403DizInf;                            // N403DIZINF structure

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->Col.Mch.Mode       = pOEM->iColorMatching;
    pOEM->Col.Mch.Diz        = pOEM->iDithering;
    pOEM->Col.Mch.PColor     = No;
    pOEM->Col.Mch.Toner      = 0;
    if (pOEM->iCmyBlack == XX_CMYBLACK_ON) {                // Replace K with CMY?
        pOEM->Col.Mch.CmyBlk = 1;
    } else {
        pOEM->Col.Mch.CmyBlk = 0;                           // Use black toner
    }
                                                            // 0 fixed
    pOEM->Col.Mch.Bright     = 0;
                                                            // 0 fixed
    pOEM->Col.Mch.Contrast   = 0;
                                                            // Color balance(R) : 10 fixed
    pOEM->Col.Mch.GamRed     = 10;
                                                            // Color balance(G) : 10 fixed
    pOEM->Col.Mch.GamGreen   = 10;
                                                            // Color balance(B) : 10 fixed
    pOEM->Col.Mch.GamBlue    = 10;
    pOEM->Col.Mch.Speed      = pOEM->iBitFont;
    pOEM->Col.Mch.Gos32      = No;
    pOEM->Col.Mch.LutNum     = 0;                           // LUT table number

    pOEM->Col.Mch.TnrNum     = 0;                           // Toner density table number

    pOEM->Col.Mch.SubDef     = Yes;                         // Not change setting of color balance, bright and contrast?

    CM_VERBOSE(("CMINit ENT Tn=%d Col=%d Mod=%d DZ=%d Cyk=%d Sp=%d Prt=%d\n", pOEM->iTone, pOEM->iColor, pOEM->Col.Mch.Mode,pOEM->Col.Mch.Diz,pOEM->Col.Mch.CmyBlk,pOEM->Col.Mch.Speed,pOEM->Printer));

    if (pOEM->Printer != PRN_N403) {                        // N4 printer

        if ((pOEM->Col.N4.lpDizInf = MemAllocZ(sizeof(N4DIZINF))) == NULL) {
            ERR(("Alloc ERROR!!\n"));
            return 0;
        }
        lpN4DizInf = pOEM->Col.N4.lpDizInf;

        if (pOEM->iColor != XX_MONO) {
            lpN4DizInf->ColMon = N4_COL;                      // Color
        } else {
            lpN4DizInf->ColMon = N4_MON;                      // Monochrome
        }
        if (pOEM->iResolution == XX_RES_300DPI) {
            pOEM->Col.wReso = DPI300;
        }
        pOEM->Col.DatBit = 1;
        pOEM->Col.BytDot = 8;                              // Numbers of DPI(2 value)

        if (pOEM->iBitFont == XX_BITFONT_OFF) {
            pOEM->Col.Mch.Gos32 = Yes;
        }
        pOEM->Col.Mch.Speed = Yes;

        if (pOEM->Col.Mch.Diz != XX_DITHERING_GOSA) {
            // Make dither table for N4 printer
            if (DizTblSetN4(pdevobj, pOEM->Col.Mch.Diz) == FALSE) {
                ERR(("DizTblSetN4 ERROR!!\n"));
                return 0;
            }
        }
        if (lpN4DizInf->ColMon == N4_COL) {

            if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                // Load LUT file
                if (LutFileLoadN4(pdevobj,
                                  pOEM->Col.Mch.Mode,
                                  pOEM->Col.Mch.Diz,
                                  pOEM->Col.Mch.Speed) == FALSE) {
                    ERR(("LutFileLoadN4 ERROR!!\n"));
                    return 0;
                }
                pOEM->Col.Mch.LutNum = 0;                    // Lut table number
            }
            // Make toner density table
            if (TnrTblSetN4(pdevobj, pOEM->Col.Mch.Toner) == FALSE) {
                ERR(("TnrTblSetN4 ERROR!!\n"));
                return 0;
            }
            pOEM->Col.Mch.TnrNum = 0;                        // Toner density table number
        }
    } else {                                                 // N403 printer

        if ((pOEM->Col.N403.lpDizInf = MemAllocZ(sizeof(N403DIZINF))) == NULL) {
            ERR(("Init Alloc ERROR!!\n"));
            return 0;
        }
        lpN403DizInf = pOEM->Col.N403.lpDizInf;

        if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
            pOEM->Col.Mch.Viv = 20;
        }
        pOEM->Col.wReso = (pOEM->iResolution == XX_RES_300DPI) ? DPI300 : DPI600;

        if (pOEM->iColor != XX_MONO) {
            lpN403DizInf->ColMon = N403_COL;                     // Color
        } else {
            lpN403DizInf->ColMon = N403_MON;                     // Monochrome
        }

        if (pOEM->iColor == XX_COLOR_SINGLE) {
            lpN403DizInf->PrnMod = (pOEM->iResolution == XX_RES_300DPI) ? N403_MOD_300B1 : N403_MOD_600B1;
        }
        if (pOEM->iColor == XX_COLOR_MANY) {
            lpN403DizInf->PrnMod = (pOEM->iResolution == XX_RES_300DPI) ? N403_MOD_300B4 : N403_MOD_600B2;
        }

        if (lpN403DizInf->PrnMod == N403_MOD_300B1) {            // 300DPI 2 value
            CM_VERBOSE(("N403_MOD_300B1\n"));
            pOEM->Col.DatBit = 1;
            pOEM->Col.BytDot = 8;                                // Number of DPI(2 value)
        } else if (lpN403DizInf->PrnMod == N403_MOD_300B4) {     // 300DPI 16 value
            CM_VERBOSE(("N403_MOD_300B4\n"));
            pOEM->Col.DatBit = 4;
            pOEM->Col.BytDot = 2;
        } else if (lpN403DizInf->PrnMod == N403_MOD_600B1) {     // 600DPI 2 value
            CM_VERBOSE(("N403_MOD_600B1\n"));
            pOEM->Col.DatBit = 1;
            pOEM->Col.BytDot = 8;
        } else {                                                 // 600DPI 4 value
            CM_VERBOSE(("N403_MOD_600B2\n"));
            pOEM->Col.DatBit = 2;
            pOEM->Col.BytDot = 4;
        }

        // Make dither table for N4-612 printer
        if (DizTblSetN403(pdevobj, pOEM->Col.Mch.Diz) == FALSE) {
            ERR(("diztblset n403 ERROR!!\n"));
            return 0;
        }
        if (lpN403DizInf->ColMon == N403_COL) {

            if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                // Load LUT file
                if (LutFileLoadN403(pdevobj,
                                    pOEM->Col.Mch.Mode,
                                    pOEM->Col.Mch.Speed) == FALSE) {
                    ERR(("lutfileloadn4 ERROR!!\n"));
                    return 0;
                }
                pOEM->Col.Mch.LutNum = 0;
            }
            // Make toner density table
            if (TnrTblSetN403(pdevobj, pOEM->Col.Mch.Toner) == FALSE) {
                ERR(("tnrtblsetn4 ERROR!!\n"));
                return 0;
            }
            pOEM->Col.Mch.TnrNum = 0;
        }

    }
    CM_VERBOSE(("ColMatchInit End pOEM->Col.wReso= %d\n",pOEM->Col.wReso));

    return TRUE;
}


//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBmp,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    PIPPARAMS           pIPParams)
{

    BMPBIF      bmpBuf;                             // BMPBIF structure
    POINT       drwPos;                             // Start position for spooling
    WORD        dstWByt;                            // X size of destination bitmap data
    LONG        dstX;                               // X coordinates of destination bitmap data
    LONG        dstY;                               // Y coordinates of destination bitmap data
    LONG        dstYEnd;                            // The last Y coordinates(+1) of destination bitmap data
    WORD        dstScn;                             // Number of destination bitmap data lines
    WORD        srcY;                               // Y coordinates of source bitmap data
    LONG        srcWByt;                            // Y size of source bitmap data
    WORD        setCnt;                             // count
    LPCMYK      lpCMYK;                             // CMYK temporary data buffer
    BYTE        Cmd[64];
    WORD        wlen;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    CM_VERBOSE(("   ImagePro ENTRY Dx=%d Dy=%d SxSiz=%d SySiz=%d BC=%d Sz=%d ",
                    pIPParams->ptOffset.x, pIPParams->ptOffset.y,
                    pBitmapInfoHeader->biWidth, pBitmapInfoHeader->biHeight, pBitmapInfoHeader->biBitCount,
                    pIPParams->dwSize));

    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        if (pOEM->iDithering == XX_DITHERING_GOSA) {
            if (pOEM->Col.N4.lpDizInf->GosRGB.Siz < (DWORD)pBitmapInfoHeader->biWidth) {
                ColGosTblFree(pOEM->Col.N4.lpDizInf);
                if ((ColGosTblSet(pOEM->Col.N4.lpDizInf, (WORD)pBitmapInfoHeader->biWidth)) == FALSE) {
                    return FALSE;
                }
            }
        }
    }

    // Initialization of
    // RGB buffer            :(X size of source bitmap data) * 3
    // CMYK buffer           :(X size of source bitmap data) * 4
    // CMYK bit buffer       :((X size of source bitmap data) * (Magnification of X) + 7) / 8 * (Y size of source bitmap data) * (Magnification of Y))
    memset(&bmpBuf, 0x00, sizeof(BMPBIF));
    if (BmpBufAlloc(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)pBitmapInfoHeader->biHeight, 0, 0, 1, 1, 1, 1, &bmpBuf) == FALSE) {
        ERR(("Alloc ERROR!!\n"));
        return FALSE;
    }

    bmpBuf.Diz = pOEM->iDithering;
    bmpBuf.Style = 0;
    bmpBuf.DatBit = pOEM->Col.DatBit;

    dstWByt = (WORD)((pBitmapInfoHeader->biWidth + pOEM->Col.BytDot - 1) / pOEM->Col.BytDot);

    srcWByt = (pBitmapInfoHeader->biWidth * pBitmapInfoHeader->biBitCount + 31L) / 32L * 4L;

    drwPos.x = dstX = pIPParams->ptOffset.x;
    dstY = pIPParams->ptOffset.y;
    srcY = 0;
    dstYEnd = pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight;

                                                        // Convert DIB and spool to the printer
    for (;dstY < dstYEnd; ) {
        BmpBufClear(&bmpBuf);
        drwPos.y = dstY;
        for (dstScn = 0; dstY < dstYEnd && dstScn < bmpBuf.Drv.Bit.Lin; dstScn++, dstY++) {    

            // Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
            BmpRGBCnv(bmpBuf.Drv.Rgb.Pnt, pSrcBmp, pBitmapInfoHeader->biBitCount, 0,
                     (WORD)pBitmapInfoHeader->biWidth, (LPRGBQUAD)pColorTable);

            if (pOEM->Col.Mch.Gos32 == Yes) {
                ColRgbGos(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)dstX, (WORD)dstY, (LPBYTE)bmpBuf.Drv.Rgb.Pnt);
            }

            // Convert RGB into CMYK
            bmpBuf.Drv.Rgb.AllWhite = (WORD)StrColMatching(pdevobj, (WORD)pBitmapInfoHeader->biWidth, bmpBuf.Drv.Rgb.Pnt, bmpBuf.Drv.Cmyk.Pnt);

            lpCMYK = bmpBuf.Drv.Cmyk.Pnt;
            if (pOEM->iDithering == XX_DITHERING_OFF) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if (lpCMYK[setCnt].Cyn != 0) { lpCMYK[setCnt].Cyn = 255; }
                    if (lpCMYK[setCnt].Mgt != 0) { lpCMYK[setCnt].Mgt = 255; }
                    if (lpCMYK[setCnt].Yel != 0) { lpCMYK[setCnt].Yel = 255; }
                    if (lpCMYK[setCnt].Bla != 0) { lpCMYK[setCnt].Bla = 255; }
                }
            }

            Dithering001(pdevobj, (WORD)pOEM->iDithering, (WORD)pBitmapInfoHeader->biWidth, (WORD)dstX, (WORD)dstY,
                         srcY, (WORD)bmpBuf.Drv.Rgb.AllWhite, (LPBYTE)bmpBuf.Drv.Cmyk.Pnt,
                         bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,
                         bmpBuf.Drv.Bit.Pnt[MGENTA] + dstWByt * dstScn,
                          bmpBuf.Drv.Bit.Pnt[YELLOW] + dstWByt * dstScn,
                          bmpBuf.Drv.Bit.Pnt[BLACK]  + dstWByt * dstScn);

            srcY++;
            pSrcBmp += srcWByt;
        }

        if (dstScn != 0) {
                                                        // Spool to printer
            BmpPrint(pdevobj, &bmpBuf, drwPos, (WORD)pBitmapInfoHeader->biWidth, dstScn, dstWByt);
        }
    }

    // Set back palette (Palette No. is fixed  , All plane(CMYK) is OK )
    // Same as palette state before OEMImageProcessing call 
    WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//    wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX)) {
        BmpBufFree(&bmpBuf);
        return FALSE;
    }
    wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Cmd, wlen);
    WRITESPOOLBUF(pdevobj, PLANE_RESET, BYTE_LENGTH(PLANE_RESET));
    WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

    BmpBufFree(&bmpBuf);

    CM_VERBOSE(("ImagePro End\n"));

    return TRUE;
}


//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL StrColMatching(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           MchSiz,                                  // X size of RGB
    LPRGB          lpRGB,                                   // RGB buffer
    LPCMYK         lpCMYK                                   // CMYK buffer
)
{
    LPN4DIZINF     lpN4DizInf;                              // N4DIZINF structure
    LPN403DIZINF   lpN403DizInf;                            // N403DIZINF structure
    WORD           chkCnt;                                  // RGB white data check count
    DWORD          bCnv;                                    // Replace black

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    for (chkCnt = 0; chkCnt < MchSiz; chkCnt++) {           // Check RGB data
        if (lpRGB[chkCnt].Blue != 0xff || lpRGB[chkCnt].Green != 0xff || lpRGB[chkCnt].Red != 0xff) {
            break;                                          // There are data except white data
        }
    }
    if (chkCnt >= MchSiz) {
        return Yes;                                         // All RGB data is white
    }
    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        lpN4DizInf = pOEM->Col.N4.lpDizInf;
        bCnv = pOEM->Col.Mch.CmyBlk;
        if (lpN4DizInf->ColMon == N4_COL) {                   // Color

            // Convert RGB data
            if (pOEM->Col.Mch.Diz == XX_DITHERING_OFF) {
                N4ColCnvLin(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (/*pOEM->Col.Mch.KToner == Yes && */MchSiz == 1 &&
                       lpRGB->Blue == lpRGB->Green && lpRGB->Blue == lpRGB->Red) {
                                                            // For monochrome
                N4ColCnvMon(lpN4DizInf, (DWORD)DizNumTbl[pOEM->Col.Mch.Diz], lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                if (pOEM->Col.Mch.Speed == Yes) {
                    N4ColMch000(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                } else {
                    N4ColMch001(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                }
            } else {
                N4ColCnvSld(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
            }
        } else {                                            // For monochrome
            N4ColCnvMon(lpN4DizInf, (DWORD)DizNumTbl[pOEM->Col.Mch.Diz], lpRGB, lpCMYK, (DWORD)MchSiz);
        }
    } else {                                                // N403 printer
        lpN403DizInf = pOEM->Col.N403.lpDizInf;
        bCnv = pOEM->Col.Mch.CmyBlk;
        if (lpN403DizInf->ColMon == N403_COL) {                 // Color

            if (pOEM->Col.Mch.Diz == XX_DITHERING_OFF) {

                N403ColCnvL02(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (/*pOEM->Col.Mch.KToner == Yes && */MchSiz == 1 &&
                       lpRGB->Blue == lpRGB->Green && lpRGB->Blue == lpRGB->Red) {
                                                            // For monochrome
                N403ColCnvMon(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
            } else if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                if (pOEM->Col.Mch.Speed == Yes) {
                    N403ColMch000(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                } else {
                    N403ColMch001(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                }
                if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
                    N403ColVivPrc(lpN403DizInf, lpCMYK, (DWORD)MchSiz, (DWORD)pOEM->Col.Mch.Viv);
                }
            } else {
                N403ColCnvSld(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
            }
        } else {                                            // For monochrome
            N403ColCnvMon(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
        }
    }
    return No;                                              // There are data except white data
}


//===================================================================================================
//    Allocate GOSA-KAKUSAN table (Only for N4 printer)
//===================================================================================================
BOOL ColGosTblSet(
    LPN4DIZINF      lpN4DizInf,                             // Pointer to N4DIZINF structure
    WORD            XSize                                   // Xsize
)
{
    if ((lpN4DizInf->GosRGB.Tbl[0] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 3)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosRGB.Tbl[1] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 3)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosCMYK.Tbl[0] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 4)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosCMYK.Tbl[1] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 4)) == NULL) {
        return 0;
    }

    lpN4DizInf->GosRGB.Num  = 0;
    lpN4DizInf->GosCMYK.Num = 0;
    lpN4DizInf->GosRGB.Siz  = XSize;
    lpN4DizInf->GosCMYK.Siz = XSize;
    lpN4DizInf->GosRGB.Yax  = 0xffffffff;
    lpN4DizInf->GosCMYK.Yax = 0xffffffff;
    return TRUE;
}


//===================================================================================================
//    Free GOSA-KAKUSAN table (Only for N4 printer)
//===================================================================================================
void ColGosTblFree(
    LPN4DIZINF        lpN4DizInf                            // Pointer to N4DIZINF structure
)
{
    if (lpN4DizInf->GosRGB.Tbl[0]) {
        MemFree(lpN4DizInf->GosRGB.Tbl[0]);
        lpN4DizInf->GosRGB.Tbl[0] = NULL;
    }
    if (lpN4DizInf->GosRGB.Tbl[1]) {
        MemFree(lpN4DizInf->GosRGB.Tbl[1])
        lpN4DizInf->GosRGB.Tbl[1] = NULL;
    }
    if (lpN4DizInf->GosCMYK.Tbl[0]) {
        MemFree(lpN4DizInf->GosCMYK.Tbl[0]);
        lpN4DizInf->GosCMYK.Tbl[0] = NULL;
    }
    if (lpN4DizInf->GosCMYK.Tbl[1]) {
        MemFree(lpN4DizInf->GosCMYK.Tbl[1]);
        lpN4DizInf->GosCMYK.Tbl[1] = NULL;
    }
    return;
}


//===================================================================================================
//    RGB data conversion(For GOSA-KAKUSAN, only for N4)
//===================================================================================================
void ColRgbGos(
    PDEVOBJ        pdevobj,
    WORD           XSize,
    WORD           XPos,
    WORD           YOff,
    LPBYTE         lpRGB
)
{
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->Printer == PRN_N403) {
        return;
    }
    lpN4DizInf = pOEM->Col.N4.lpDizInf;

    N4RgbGos(lpN4DizInf, (DWORD)XSize, (DWORD)XPos, (DWORD)YOff, lpRGB);
    return;
}


//===================================================================================================
//    Free dither table, toner density table , Lut table, N403DIZINF(N4DIZINF) structure buffer
//===================================================================================================
void FAR PASCAL DizLutTnrTblFree(
    PDEVOBJ     pdevobj
)
{
    int     i;
    DWORD   dizNum;
    WORD    alcCnt;
    WORD    alcTbl;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->Printer != PRN_N403
        && NULL != pOEM->Col.N4.lpDizInf) {

        // N4 printer

        CM_VERBOSE(("OEMDisablePDEV N4\n"));

        if (pOEM->Col.Mch.Diz != XX_DITHERING_GOSA) {
            dizNum = DizNumTbl[pOEM->Col.Mch.Diz];          // Dither number
            for (i = 0; i < 4; i++) {
                if (pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i]) {
                    MemFree(pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i]);
                    pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i] = NULL;
                }
            }
        }
        if (pOEM->Col.N4.lpDizInf->Tnr.Tbl) {
           MemFree(pOEM->Col.N4.lpDizInf->Tnr.Tbl);
           pOEM->Col.N4.lpDizInf->Tnr.Tbl = NULL;
        }
        if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
            if (pOEM->Col.N4.lpDizInf->Lut.Tbl) {
                MemFree(pOEM->Col.N4.lpDizInf->Lut.Tbl);
                pOEM->Col.N4.lpDizInf->Lut.Tbl = NULL;
            }
            if (pOEM->Col.Mch.Speed == No) {
                if (pOEM->Col.N4.lpDizInf->Lut.CchRgb) {
                    MemFree(pOEM->Col.N4.lpDizInf->Lut.CchRgb);
                    pOEM->Col.N4.lpDizInf->Lut.CchRgb = NULL;
                }
                if (pOEM->Col.N4.lpDizInf->Lut.CchCmy) {
                    MemFree(pOEM->Col.N4.lpDizInf->Lut.CchCmy);
                    pOEM->Col.N4.lpDizInf->Lut.CchCmy = NULL;
                }
            }
        }

        if (pOEM->iDithering == XX_DITHERING_GOSA) {
            ColGosTblFree(pOEM->Col.N4.lpDizInf);
        }

        if (pOEM->Col.N4.lpDizInf) {
            MemFree(pOEM->Col.N4.lpDizInf);
            pOEM->Col.N4.lpDizInf = NULL;
        }

    } else if (NULL != pOEM->Col.N403.lpDizInf) {

        // N4-612 printer

        CM_VERBOSE(("OEMDisablePDEV N403\n"));

        dizNum = DizNumTbl[pOEM->Col.Mch.Diz];

        if (pOEM->Col.N403.lpDizInf->PrnMod == N403_MOD_600B2 && pOEM->Col.Mch.Diz == XX_DITHERING_DET) {
            alcTbl = 1;
        } else {
            alcTbl = 4;
        }
        for (alcCnt = 0; alcCnt < alcTbl; alcCnt++) {
            if (pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt]) {
                MemFree(pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt]);
                pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt] = NULL;
            }
        }
        if (pOEM->Col.N403.lpDizInf->PrnMod == N403_MOD_600B2) {
            for (i = 0; i < 4; i++) {
                if (pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i]) {
                    MemFree(pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i]);
                    pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i] = NULL;
                }
            }
        }

        if (pOEM->Col.N403.lpDizInf->Tnr.Tbl) {
            MemFree(pOEM->Col.N403.lpDizInf->Tnr.Tbl);
            pOEM->Col.N403.lpDizInf->Tnr.Tbl = NULL;
        }

        if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
            if (pOEM->Col.N403.lpDizInf->Lut.Tbl) {
                MemFree(pOEM->Col.N403.lpDizInf->Lut.Tbl);
                pOEM->Col.N403.lpDizInf->Lut.Tbl = NULL;
            }
            if (pOEM->Col.Mch.Speed == No) {
                if (pOEM->Col.N403.lpDizInf->Lut.CchRgb) {
                    MemFree(pOEM->Col.N403.lpDizInf->Lut.CchRgb);
                    pOEM->Col.N403.lpDizInf->Lut.CchRgb = NULL;
                }
                if (pOEM->Col.N403.lpDizInf->Lut.CchCmy) {
                    MemFree(pOEM->Col.N403.lpDizInf->Lut.CchCmy);
                    pOEM->Col.N403.lpDizInf->Lut.CchCmy = NULL;
                }
            }
        }

        if (pOEM->Col.N403.lpDizInf) {
            MemFree(pOEM->Col.N403.lpDizInf);
            pOEM->Col.N403.lpDizInf = NULL;
        }
    }
}


//===================================================================================================
//    Allocate bitmap data buffer
//---------------------------------------------------------------------------------------------------
//    Allocate size
//          RGB buffer              :Source bitmap Xsize * 3
//          CMYK buffer             :Source bitmap Xsize * 4
//          CMYK bit buffer         :2 value    (Source Xsize * XNrt + 7) / 8 * Source Ysize * YNrt
//                                  :4 value    (Source Xsize * XNrt + 3) / 4 * Source Ysize * YNrt
//                                  :16 value   (Source Xsize * XNrt + 1) / 2 * Source Ysize * YNrt
//===================================================================================================
BOOL BmpBufAlloc(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           SrcXSiz,                                 // Source bitmap data Xsize
    WORD           SrcYSiz,                                 // Source bitmap data Ysize
    WORD           SrcXOff,                                 // Source X offset
    WORD           SrcYOff,                                 // Source Y offset
    WORD           XNrt,                                    // Magnification of X (numerator)
    WORD           XDnt,                                    // Magnification of X (denominator)
    WORD           YNrt,                                    // Magnification of Y (numerator)
    WORD           YDnt,                                    // Magnification of Y (denominator)
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           setSiz;
    WORD           setCnt;
    WORD           alcErr;                                  // Allocate error?
    WORD           bytDot;                                  // DPI
    WORD           xSiz;
    WORD           ySiz;
    WORD           alcLin;
    DWORD          alcSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    alcErr = Yes;

    bytDot = pOEM->Col.BytDot;

// Check of zero divide 2002.3.23 >>>
    if ((XDnt == 0) || (YDnt == 0)) {
        ERR(("BmpBufAlloc() 0Div-Check [XDnt, YDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    xSiz = (WORD)(((DWORD)SrcXOff + SrcXSiz) * XNrt / XDnt);
    xSiz -= (WORD)((DWORD)SrcXOff * XNrt / XDnt);

    ySiz = (WORD)(((DWORD)SrcYOff + SrcYSiz + 2) * YNrt / YDnt);
    ySiz -= (WORD)((DWORD)SrcYOff * YNrt / YDnt);
                                                            // The size of CMYK bit buffer
    if (((DWORD)((xSiz + bytDot - 1) / bytDot) * ySiz) < (64L * 1024L - 1L)) {
        alcLin = ySiz;
    } else {                                                // Over 64kb?
        alcLin = (WORD)((64L * 1024L - 1L) / ((xSiz + bytDot - 1) / bytDot));
    }

    alcSiz = ((xSiz + bytDot - 1) / bytDot) * alcLin;       // The size of CMYK bit buffer(8bit boundary)

    for ( ; ; ) {                                           // Allocation
                                                            // The number of lines that required.
        lpBmpBuf->Drv.Bit.BseLin = (WORD)((DWORD)(YNrt + YDnt - 1) / YDnt);
        if (lpBmpBuf->Drv.Bit.BseLin > alcLin) {
            break;
        }
        lpBmpBuf->Drv.Rgb.Siz = SrcXSiz * 3;                // RGB buffer
        if ((lpBmpBuf->Drv.Rgb.Pnt = (LPRGB)MemAllocZ(lpBmpBuf->Drv.Rgb.Siz)) == NULL) {
            break;
        }
        lpBmpBuf->Drv.Cmyk.Siz = SrcXSiz * 4;               // CMYK buffer
        if ((lpBmpBuf->Drv.Cmyk.Pnt = (LPCMYK)MemAllocZ(lpBmpBuf->Drv.Cmyk.Siz)) == NULL) {
            break;
        }
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {    // Color?
            setSiz = 4;                                     // CMYK
        } else {                                            // Mono?
            setSiz = 1;                                     // K
        }
                                                            // CMYK bit buffer
        for (setCnt = 0; setCnt < setSiz; setCnt++) {
            if ((lpBmpBuf->Drv.Bit.Pnt[setCnt] = MemAllocZ(alcSiz)) == NULL) {
                break;
            }
        }
        if (setCnt == setSiz) {
            lpBmpBuf->Drv.Bit.Siz = alcSiz;
            lpBmpBuf->Drv.Bit.Lin = alcLin;
            alcErr = No;                                    // Allocate OK
        }
        break;
    }
    if (alcErr == Yes) {                                    // Allocate error?
        BmpBufFree(lpBmpBuf);
        return FALSE;
    }

    return TRUE;
}


//===================================================================================================
//    Free bitmap data buffer
//===================================================================================================
void BmpBufFree(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    if (lpBmpBuf->Drv.Rgb.Pnt) {                            // Free RGB buffer
        MemFree(lpBmpBuf->Drv.Rgb.Pnt);
        lpBmpBuf->Drv.Rgb.Pnt = NULL;
    }
    if (lpBmpBuf->Drv.Cmyk.Pnt) {                           // Free CMYK buffer
        MemFree(lpBmpBuf->Drv.Cmyk.Pnt);
        lpBmpBuf->Drv.Cmyk.Pnt = NULL;
    }
                                                            // CMYK bit buffer
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // CMYK(2/4/16value)bitmap buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            MemFree(lpBmpBuf->Drv.Bit.Pnt[chkCnt]);
            lpBmpBuf->Drv.Bit.Pnt[chkCnt] = NULL;
        }
    }
    return;
}


//===================================================================================================
//    Clear CMYK bitmap data buffer
//===================================================================================================
void BmpBufClear(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // Clear CMYK(2/4/16value)bit buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            memset(lpBmpBuf->Drv.Bit.Pnt[chkCnt], 0x00, (WORD)lpBmpBuf->Drv.Bit.Siz);
        }
    }
    return;
}


//===================================================================================================
//    Dithering
//===================================================================================================
WORD Dithering001(                                          // Number of lines
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Diz,                                     // Type of dither
    WORD           XSize,                                   // Numer of Xpixel
    WORD           XPos,                                    // Start X position for spooling
    WORD           YPos,                                    // Start Y position for spooling
    WORD           YOff,                                    // Y offset(Only for GOSA-KAKUSAN)
    WORD           AllWhite,                                // All white data?
    LPBYTE         lpCMYKBuf,                               // CMYK buffer
    LPBYTE         lpCBuf,                                  // Line buffer(C)
    LPBYTE         lpMBuf,                                  // Line buffer(M)
    LPBYTE         lpYBuf,                                  // Line buffer(Y)
    LPBYTE         lpKBuf                                   // Line buffer(K)
)
{
    DWORD          dizLin = 0;  /* 441436: Assume failing dither => 0 lines */
                                /* NOTE: Nobody uses the return value of Dithering001 */
    LPN4DIZINF     lpN4DizInf;
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (AllWhite == Yes) {
        return 1;                                           // Number of line
    }
    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        lpN4DizInf = pOEM->Col.N4.lpDizInf;
        if (Diz == XX_DITHERING_GOSA) {
            dizLin = N4Gos001(lpN4DizInf,
                                 (DWORD)XSize, (DWORD)XPos, (DWORD)YPos, lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        } else {
            lpN4DizInf->Diz.Num = DizNumTbl[Diz];
            dizLin = N4Diz001(lpN4DizInf,
                                 (DWORD)XSize, (DWORD)XPos, (DWORD)YPos, lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        }
    } else {                                                // N4-612 printer
        lpN403DizInf = pOEM->Col.N403.lpDizInf;
        lpN403DizInf->Diz.Num = DizNumTbl[Diz];
        if (lpN403DizInf->PrnMod == N403_MOD_300B1 || lpN403DizInf->PrnMod == N403_MOD_600B1) {
            dizLin = N403Diz002(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
/*        } else if (lpN403DizInf->PrnMod == N403_MOD_300B2) {
            dizLin = N403Diz004(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
*/        } else if (lpN403DizInf->PrnMod == N403_MOD_600B2) {
// Addition of a condition (XX_DITHERING_OFF) 2002.3.28 >>>
//            if (lpN403DizInf->ColMon == N403_MON || Diz == XX_DITHERING_ON) {
            if (lpN403DizInf->ColMon == N403_MON || Diz == XX_DITHERING_ON || Diz == XX_DITHERING_OFF) {
// Addition of a condition (XX_DITHERING_OFF) 2002.3.28 <<<
                dizLin = N403Diz004(lpN403DizInf,
                                       (DWORD)XSize,
                                       (DWORD)XPos, (DWORD)YPos,
                                       (DWORD)0, (DWORD)0,
                                       (DWORD)1, (DWORD)1,
                                       (DWORD)1, (DWORD)1,
                                       (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
            } else if (lpN403DizInf->ColMon == N403_MON || Diz == XX_DITHERING_DET) {
                dizLin = N403DizSml(lpN403DizInf,
                                       (DWORD)XSize,
                                       (DWORD)XPos, (DWORD)YPos,
                                       (DWORD)0, (DWORD)0,
                                       (DWORD)1, (DWORD)1,
                                       (DWORD)1, (DWORD)1,
                                       (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
            }
        } else {
            dizLin = N403Diz016(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        }
    }
    return (WORD)dizLin;
}


//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void BmpPrint(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPBMPBIF       lpBmpBuf,                                // Pointer to bitmap buffer structure
    POINT          Pos,                                     // Start position for spooling
    WORD           Width,                                   // Width(dot)
    WORD           Height,                                  // Height(dot)
    WORD           WidthByte                                // Width(byte)
)
{
    DRWBMP         drwBmp;                                  // For Spooling bitmap data structure
    DRWBMPCMYK     drwBmpCMYK;                              // For Spooling CMYK bitmap data structure
    WORD           colCnt;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    static const CMYK colTbl[4] = {                         // CMYK table
        {  0,   0,   0, 255},                               // Black
        {  0,   0, 255,   0},                               // Yellow
        {  0, 255,   0,   0},                               // Magenta
        {255,   0,   0,   0}                                // Cyan
    };

    static const WORD plnTbl[4] = {                         // Plane table
        PLN_BLACK,
        PLN_YELLOW,
        PLN_MGENTA,
        PLN_CYAN
    };
    static const WORD frmTbl[4] = {0, 3, 2, 1};             // Frame table(For N4-612)

                                                            // Not N4-612 printer?
    if (pOEM->Printer != PRN_N403) {
        drwBmp.Style = lpBmpBuf->Style;
        drwBmp.DrawPos = Pos;
        drwBmp.Diz = lpBmpBuf->Diz;
        drwBmp.Width = Width;
        drwBmp.Height = Height;
        drwBmp.WidthByte = WidthByte;
                                                            // Color?
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {

            for (colCnt = 0; colCnt < 4; colCnt++) {        // Setting value for spooling bitmap data
                drwBmp.Plane = plnTbl[colCnt];              // For each plane
                drwBmp.Color = colTbl[colCnt];
                drwBmp.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
                PrnBitmap(pdevobj, &drwBmp);                // Spool bitmap data
            }
        } else {                                            // Mono
                                                            // Setting value for spooling bitmap data
            drwBmp.Color = colTbl[0];
            drwBmp.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;

            PrnBitmap(pdevobj, &drwBmp);                    // Spool bitmap data

        }
    } else {                                                // N4-612 printer?
        drwBmpCMYK.Style = lpBmpBuf->Style;
        drwBmpCMYK.DataBit = lpBmpBuf->DatBit;
        drwBmpCMYK.DrawPos = Pos;
        drwBmpCMYK.Width = Width;
        drwBmpCMYK.Height = Height;
        drwBmpCMYK.WidthByte = WidthByte;
                                                            // Color?
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {

            for (colCnt = 0; colCnt < 4; colCnt++) {        // Setting value for spooling bitmap data
                                                            // For each plane
                drwBmpCMYK.Plane = PLN_ALL;                 // All Plane is OK
                drwBmpCMYK.Frame = frmTbl[colCnt];
                drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
                PrnBitmapCMYK(pdevobj, &drwBmpCMYK);        // Spool bitmap data
            }
        } else {                                            // Mono
                                                            // Setting value for spooling bitmap data
            drwBmpCMYK.Plane = plnTbl[0];
            drwBmpCMYK.Frame = frmTbl[0];
            drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;
            PrnBitmapCMYK(pdevobj, &drwBmpCMYK);            // Spool bitmap data
        }
    }
    return;
}


//===================================================================================================
//     Allocate dither table(N4 printer)
//===================================================================================================
BOOL DizTblSetN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Diz                                      // Type of dither
)
{
    DWORD          dizNum;
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN4DizInf = pOEM->Col.N4.lpDizInf;
    dizNum = DizNumTbl[Diz];
    lpN4DizInf->Diz.Num = dizNum;

    if ((lpN4DizInf->Diz.Tbl[dizNum][0] = MemAllocZ(N4_DIZSIZ_CM)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][1] = MemAllocZ(N4_DIZSIZ_CM)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][2] = MemAllocZ(N4_DIZSIZ_YK)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][3] = MemAllocZ(N4_DIZSIZ_YK)) == NULL) {
         return 0;
    }
    N4DizPtnMak(lpN4DizInf, dizNum, dizNum);                // Make dither pattern
    return TRUE;
}


//===================================================================================================
//     Allocate dither table(N4-612 printer)
//===================================================================================================
BOOL DizTblSetN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Diz                                      // Type of dither
)
{
    DWORD          dizNum;
    DWORD          alcSiz;
    WORD           alcCnt;
    WORD           alcTbl;
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN403DizInf = pOEM->Col.N403.lpDizInf;
    dizNum = DizNumTbl[Diz];
    lpN403DizInf->Diz.Num = dizNum;

    if (lpN403DizInf->PrnMod == N403_MOD_300B1 || lpN403DizInf->PrnMod == N403_MOD_600B1) {
        alcSiz = N403_DIZSIZ_B1;
    } else if (/*lpN403DizInf->PrnMod == N403_MOD_300B2 ||*/ lpN403DizInf->PrnMod == N403_MOD_600B2) {
        alcSiz = N403_DIZSIZ_B2;
    } else {
        alcSiz = N403_DIZSIZ_B4;
    }

    if (lpN403DizInf->ColMon == N403_COL && lpN403DizInf->PrnMod == N403_MOD_600B2 && Diz == XX_DITHERING_DET) {
        alcTbl = 1;
    } else {
        alcTbl = 4;
    }
    for (alcCnt = 0; alcCnt < alcTbl; alcCnt++) {
        if ((lpN403DizInf->Diz.Tbl[dizNum][alcCnt] = MemAllocZ(alcSiz)) == NULL) {
            ERR(("DizTbl ALLOC ERROR!!\n"));
            return 0;
        }
    }

    if (lpN403DizInf->ColMon == N403_COL && lpN403DizInf->PrnMod == N403_MOD_600B2) {
        alcSiz = N403_ENTDIZSIZ_B2;
        for (alcCnt = 0; alcCnt < 4; alcCnt++) {
            if ((lpN403DizInf->EntDiz.Tbl[alcCnt] = MemAllocZ(alcSiz)) == NULL) {
                ERR(("EntDizTbl ALLOC ERROR!!\n"));
                return 0;
            }
        }
    }
    N403DizPtnMak(lpN403DizInf, dizNum, dizNum);            // Make dither pattern
    return TRUE;
}


//===================================================================================================
//    Load LUT file(For N4 printer)
//===================================================================================================
BOOL LutFileLoadN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Mch,                                     // Type of color match
    WORD           Diz,                                     // Type of dither
    WORD           Speed                                    // speed?
)
{
    HANDLE         fp_Lut;
    OFSTRUCT       opeBuf;
    WORD           setCnt;
    LPBYTE         lpDst;
    LPN4DIZINF     lpN4DizInf;
    DWORD          nSize;
    WCHAR          LutName[MAX_PATH], *pTemp;
    int            i;

    BOOL           bRet;
    DWORD          dwRet;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    nSize = GetModuleFileName(pdevobj->hOEM, LutName, MAX_PATH);
    nSize -= (sizeof (CSN46RESDLL) / sizeof (WCHAR) - 1);

    // Choice of LUT file
    pTemp = N4LUT000;           // Default value.
    if (Mch == XX_COLORMATCH_NORMAL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT000;
        } else {
            pTemp = N4LUT003;
        }
    } else if (Mch == XX_COLORMATCH_VIVCOL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT001;
        } else {
            pTemp = N4LUT004;
        }
    } else if (Mch == XX_COLORMATCH_NATCOL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT002;
        } else {
            pTemp = N4LUT005;
        }
    }

// Replacement of strsafe-api 2002.3.6 >>>
//    lstrcpy(&LutName[nSize], pTemp);
    if (S_OK != StringCchCopy(&LutName[nSize], MAX_PATH - nSize, pTemp))
        return 0;
// Replacement of strsafe-api 2002.3.6 <<<

    CM_VERBOSE(("n403 Newbuf--> %ws\n", LutName));

    // Open LUT file
    if (INVALID_HANDLE_VALUE == (fp_Lut = CreateFile(LutName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n",
                LutName, GetLastError()));
        return 0;
    }

    lpN4DizInf = pOEM->Col.N4.lpDizInf;

    if ((lpN4DizInf->Lut.Tbl = MemAllocZ((DWORD)N4_LUTTBLSIZ)) == NULL) {
        CloseHandle(fp_Lut);    /* 441434 */
        return 0;
    }
    lpDst = (LPBYTE)(lpN4DizInf->Lut.Tbl);
                                                            // Load LUT data
    for(setCnt = 0 ; setCnt < (N4_GLDNUM / 8) ; setCnt++) {

        if (FALSE == ReadFile(fp_Lut,
                &lpDst[(DWORD)setCnt * 8L * N4_GLDNUM * N4_GLDNUM * 4L],
                (8L * N4_GLDNUM * N4_GLDNUM * 4L), &dwRet, NULL)
            || 0 == dwRet) {

            ERR(("Error reading LUT file %ws (%d)\n",
                    LutName, GetLastError()));

            // Abort
            CloseHandle(fp_Lut);
            return FALSE;
        }
    }

    // Close LUT file
    if (FALSE == CloseHandle(fp_Lut)) {
        ERR(("Error closing LUT file %ws (%d)\n",
                LutName, GetLastError()));
    }

    if (Speed == No) {
        if ((lpN4DizInf->Lut.CchRgb = MemAllocZ(N4_CCHRGBSIZ)) == NULL) {
            return 0;
        }
        if ((lpN4DizInf->Lut.CchCmy = MemAllocZ(N4_CCHCMYSIZ)) == NULL) {
            return 0;
        }
        memset(lpN4DizInf->Lut.CchRgb, 0xff, N4_CCHRGBSIZ);
        memset(lpN4DizInf->Lut.CchCmy, 0x00, N4_CCHCMYSIZ);
    }
    return TRUE;
}


//===================================================================================================
//    Load LUT file(For N4-612 printer)
//===================================================================================================
BOOL LutFileLoadN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Mch,                                     // Type of color matching
    WORD           Speed
)
{
    HANDLE         fp_Lut;
    OFSTRUCT       opeBuf;
    WORD           setCnt;
    LPBYTE         lpDst;
    LPN403DIZINF   lpN403DizInf;
    DWORD          nSize;
    WCHAR          LutName[MAX_PATH], *pTemp;
    int            i;

    BOOL           bRet;
    DWORD          dwRet;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    nSize = GetModuleFileName(pdevobj->hOEM, LutName, MAX_PATH);
    nSize -= (sizeof (CSN46RESDLL) / sizeof (WCHAR) - 1);

    // Choice of LUT file
    if (Mch == XX_COLORMATCH_IRO) {
        pTemp = N403LUTY;
    } else {
        pTemp = N403LUTX;
    }

// Replacement of strsafe-api 2002.3.6 >>>
//    lstrcpy(&LutName[nSize], pTemp);
    if (S_OK != StringCchCopy(&LutName[nSize], MAX_PATH - nSize, pTemp))
        return 0;
// Replacement of strsafe-api 2002.3.6 <<<

    CM_VERBOSE(("n403 Newbuf--> %ws\n", LutName));

    // Open LUT file
    if (INVALID_HANDLE_VALUE == (fp_Lut = CreateFile( LutName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n",
                LutName, GetLastError()));
        return 0;
    }

    lpN403DizInf = pOEM->Col.N403.lpDizInf;

    if ((lpN403DizInf->Lut.Tbl = MemAllocZ((DWORD)N403_LUTTBLSIZ))== NULL) {
        CloseHandle(fp_Lut);    /* 441433 */
        return 0;
    }
    lpDst = (LPBYTE)(lpN403DizInf->Lut.Tbl);
                                                            // Load LUT data
    for(setCnt = 0 ; setCnt < (N403_GLDNUM / 8) ; setCnt++) {

        if (FALSE == ReadFile(fp_Lut,
                &lpDst[(DWORD)setCnt * 8L * N403_GLDNUM * N403_GLDNUM * 4L],
                (8L * N403_GLDNUM * N403_GLDNUM * 4L), &dwRet, NULL)
            || 0 == dwRet) {

            ERR(("Error reading LUT file %ws (%d)\n",
                    LutName, GetLastError()));

            // Abort
            CloseHandle(fp_Lut);
            return FALSE;
        }
    }

    // Close LUT file
    if (FALSE == CloseHandle(fp_Lut)) {
        ERR(("Error closing LUT file %ws (%d)\n",
                LutName, GetLastError()));
    }

    if (Speed == No) {
        if ((lpN403DizInf->Lut.CchRgb = MemAllocZ(N403_CCHRGBSIZ)) == NULL) {
            return 0;
        }
        if ((lpN403DizInf->Lut.CchCmy = MemAllocZ(N403_CCHCMYSIZ)) == NULL) {
            return 0;
        }
        memset(lpN403DizInf->Lut.CchRgb, 0xff, N403_CCHRGBSIZ);
        memset(lpN403DizInf->Lut.CchCmy, 0x00, N403_CCHCMYSIZ);
    }
    return TRUE;
}


//===================================================================================================
//    Allocate toner density table(For N4 printer)
//===================================================================================================
BOOL TnrTblSetN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    SHORT          Tnr                                      // Toner density(-30~30)
)
{
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN4DizInf = pOEM->Col.N4.lpDizInf;
    if ((lpN4DizInf->Tnr.Tbl = MemAllocZ(N4_TNRTBLSIZ)) == NULL) {
        return 0;
    }

    N4TnrTblMak(lpN4DizInf, (LONG)Tnr);
    return TRUE;
}


//===================================================================================================
//    Allocate toner density table(For N4-612 printer)
//===================================================================================================
BOOL TnrTblSetN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    SHORT          Tnr                                      // Toner density(-30~30)
)
{
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN403DizInf = pOEM->Col.N403.lpDizInf;

    if ((lpN403DizInf->Tnr.Tbl = MemAllocZ(N403_TNRTBLSIZ)) == NULL) {
        return 0;
    }

    N403TnrTblMak(lpN403DizInf, (LONG)Tnr);
    return TRUE;
}


//===================================================================================================
//    Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
//===================================================================================================
void BmpRGBCnv(
    LPRGB          lpRGB,                                   // Pointer to destination bitmap data
    LPBYTE         lpSrc,                                   // Pointer to source bitmap data
    WORD           SrcBit,                                  // Pixel of source bitmap data
    WORD           SrcX,                                    // X coordinates of source bitmap data
    WORD           SrcXSiz,                                 // X size of source bitmap data
    LPRGBQUAD      lpPlt                                    // Color palette table of source bitmap data(1/4/8pixel)
)
{
    WORD           setCnt;
    BYTE           colNum;
    LPWORD         lpWSrc;

    switch (SrcBit) {
        case 1:                                             // 1 bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                                                            // Foreground color?
                if (!(lpSrc[SrcX / 8] & BitTbl[SrcX & 0x0007])) {
                    lpRGB[setCnt].Blue  = lpPlt[0].rgbBlue;
                    lpRGB[setCnt].Green = lpPlt[0].rgbGreen;
                    lpRGB[setCnt].Red   = lpPlt[0].rgbRed;
                } else {
                    lpRGB[setCnt].Blue  = lpPlt[1].rgbBlue;
                    lpRGB[setCnt].Green = lpPlt[1].rgbGreen;
                    lpRGB[setCnt].Red   = lpPlt[1].rgbRed;
                }
            }
            break;
        case 4:                                             // 4bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                if (!(SrcX & 0x0001)) {                     // A even number coordinates?
                    colNum = lpSrc[SrcX / 2] / 16;
                } else {
                    colNum = lpSrc[SrcX / 2] % 16;
                }
                lpRGB[setCnt].Blue  = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Green = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red   = lpPlt[colNum].rgbRed;
            }
            break;
        case 8:                                             // 8bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                colNum = lpSrc[SrcX];
                lpRGB[setCnt].Blue  = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Green = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red   = lpPlt[colNum].rgbRed;
            }
            break;
        case 16:                                            // 16bit
            lpWSrc = (LPWORD)lpSrc + SrcX;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpWSrc++) {
                lpRGB[setCnt].Blue  = (BYTE)((*lpWSrc & 0x001f) << 3);
                lpRGB[setCnt].Green = (BYTE)((*lpWSrc & 0x03e0) >> 2);
                lpRGB[setCnt].Red   = (BYTE)((*lpWSrc / 0x0400) << 3);
            }
            break;
        case 24:                                            // 24 bit
            lpSrc += SrcX * 3;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 3) {
                lpRGB[setCnt].Red    = lpSrc[0];
                lpRGB[setCnt].Green    = lpSrc[1];
                lpRGB[setCnt].Blue    = lpSrc[2];
//                lpRGB[setCnt].Blue    = lpSrc[0];
//                lpRGB[setCnt].Green    = lpSrc[1];
//                lpRGB[setCnt].Red    = lpSrc[2];
            }
//            memcpy(lpRGB, lpSrc, SrcXSiz * 3);
            break;
        case 32:                                            // 32bit
            lpSrc += SrcX * 4;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 4) {
                lpRGB[setCnt].Blue  = lpSrc[0];
                lpRGB[setCnt].Green = lpSrc[1];
                lpRGB[setCnt].Red   = lpSrc[2];
            }
            break;
    }
    return;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\colmatch.h ===
//***************************************************************************************************
//    COLMATCH.H
//
//    Functions of color matching(C Header)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Include Header file
//---------------------------------------------------------------------------------------------------
#include "COLORDEF.H"
#include "N4DIZ.H"
#include "N403DIZ.H"

//---------------------------------------------------------------------------------------------------
//    Printer name
//---------------------------------------------------------------------------------------------------
#define PRN_N4      0
#define PRN_N403    1

//---------------------------------------------------------------------------------------------------
//    Data define
//---------------------------------------------------------------------------------------------------
#define No          0
#define Yes         1

#define XX_RES_300DPI            0
#define XX_RES_600DPI            1

#define XX_MONO                  0
#define XX_COLOR                 1
#define XX_COLOR_SINGLE          2
#define XX_COLOR_MANY            3

#define XX_DITHERING_OFF         0
#define XX_DITHERING_ON          1
#define XX_DITHERING_DET         2
#define XX_DITHERING_PIC         3
#define XX_DITHERING_GRA         4
#define XX_DITHERING_CAR         5
#define XX_DITHERING_GOSA        6

#define XX_COLORMATCH_NONE       0
#define XX_COLORMATCH_BRI        1
#define XX_COLORMATCH_VIV        2
#define XX_COLORMATCH_IRO        3
#define XX_COLORMATCH_NORMAL     4
#define XX_COLORMATCH_VIVCOL     5
#define XX_COLORMATCH_NATCOL     6

#define XX_BITFONT_OFF           0
#define XX_BITFONT_ON            1

#define XX_CMYBLACK_OFF          0
#define XX_CMYBLACK_ON           1

#define XX_COMPRESS_OFF          0
#define XX_COMPRESS_AUTO         1
#define XX_COMPRESS_RASTER       3

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PALETTE_SIZE    1

#define BYTE_LENGTH(s) (sizeof (s) - 1)

//===================================================================================================
//    Color matching structure
//===================================================================================================
typedef struct {
    WORD    wReso;                              // Resolution
    WORD    ColMon;                             // Color/Monochrome
    WORD    DatBit;                             // Data bit(1:2value 2:4value 4:16value)
    WORD    BytDot;                             // DPI (2value:8 4value:4 16value:2)
    struct {                                    // Strcture for color matching
        WORD        Mode;                       // Type of color matching
        WORD        Viv;                        // Vividly?(For N4-612Printer)
        WORD        KToner;                     // Gray color use black toner
        WORD        LutNum;                     // LUT table No.
        WORD        Diz;                        // Type od dithering
        SHORT       Toner;                      // Toner density(-30`30)
        WORD        TnrNum;                     // Toner density table No.
        WORD        CmyBlk;                     // Replace CMY by black toner
        WORD        Speed;                      // 0:high 1:normal
        WORD        Gos32;                      // GOSA?
        WORD        PColor;                     // Original color?
        WORD        SubDef;                     // Bright, contrast and gamma 
        SHORT       Bright;                     // bright
        SHORT       Contrast;                   // contrast
        WORD        GamRed;                     // Color balance(R)
        WORD        GamGreen;                   // Color balance(G)
        WORD        GamBlue;                    // Color balance(B)
    } Mch;
    union {
        struct {
            LPN4DIZINF      lpDizInf;           // Structure for control dithering and color-matching
        } N4;
        struct {
            LPN403DIZINF    lpDizInf;           // Structure for control dithering and color-matching
        } N403;
    };
} DEVCOL, FAR *LPDEVCOL;

//===================================================================================================
//    Bitmap buffer structure
//===================================================================================================
typedef struct {
    WORD    Diz;                                // Method of dithering
    WORD    Style;                              // Method of spooling
    WORD    DatBit;                             // Databit(1:2value 2:4value 4:16value)
    struct {
        struct {                                // Member of RGB buffer(for 1 line)
            WORD      AllWhite;                 // All data is white?
            DWORD     Siz;                      // Size
            LPRGB     Pnt;                      // Pointer
        } Rgb;
        struct {                                // Member of CMYK buffer(for 1 line)
            DWORD     Siz;                      // Size
            LPCMYK    Pnt;                      // Poiner
        } Cmyk;
        struct {                                // Member of CMYK(2/4/16value)bitmap buffer(maximum 64KB)
            DWORD     Siz;                      // Size
            WORD      BseLin;                   // The number of lines that require
            WORD      Lin;                      // The number of lines that allocate
            LPBYTE    Pnt[4];                   // Pointer
        } Bit;
    } Drv;
} BMPBIF, FAR* LPBMPBIF;

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(PDEVOBJ);

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(PDEVOBJ, PBYTE, PBITMAPINFOHEADER, PBYTE, PIPPARAMS);

//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL StrColMatching(PDEVOBJ, WORD, LPRGB, LPCMYK);

//===================================================================================================
//    Free dither table, toner density table , Lut table, N403DIZINF(N4DIZINF) structure buffer
//===================================================================================================
void FAR PASCAL DizLutTnrTblFree(PDEVOBJ);


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include "strsafe.h"         // Security-Code 2002.3.6

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cnrstres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\colordef.h ===
//***************************************************************************************************
//    COLORDEF.H
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Structure for RGB Color
//---------------------------------------------------------------------------------------------------
typedef DWORD         COLORREF;
typedef struct {
    BYTE        Blue;                                       // Density 0`255
    BYTE        Green;                                      // 
    BYTE        Red;                                        // 
} RGBS, FAR *LPRGB;

//---------------------------------------------------------------------------------------------------
//    Structure for CMYK Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Cyn;                                        // Density 0`255
    BYTE        Mgt;                                        // 
    BYTE        Yel;                                        // 
    BYTE        Bla;                                        // 
} CMYK, FAR *LPCMYK;

//---------------------------------------------------------------------------------------------------
//    Color number
//---------------------------------------------------------------------------------------------------
#define    BLACK           0
#define    YELLOW          1
#define    MGENTA          2
#define    CYAN            3


//    End of COLORDEF.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588587-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#include "strsafe.h"         // Security-Code 2002.3.6

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{

public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));

        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams);

        return S_OK;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));

        OEMMemoryUsage(pdevobj, pMemoryUsage);

        return S_OK;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "PDEV.H"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include "strsafe.h"    // Security-Code 2002.3.6

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\csn46res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    Csn46res.c

Abstract:

    Implementation of GPD command callback for "Csn46j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/


#include "PDEV.H"
#include <stdio.h>
#include "PRNCTL.H"
#include "strsafe.h"         // Security-Code 2002.3.6


//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr);
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize);
// Replacement of strsafe-api 2002.3.6 <<<

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_MPF         103
#define PSRC_SELECT_AUTO        104

#define TONER_SAVE_NONE         110
#define TONER_SAVE_1            111
#define TONER_SAVE_2            112
#define TONER_SAVE_3            113
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MEDIATYPE_1             140
#define MEDIATYPE_2             141
#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#define START_PAGE              160

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      170
#define COLOR_SELECT_RED        171
#define COLOR_SELECT_GREEN      172
#define COLOR_SELECT_BLUE       173
#define COLOR_SELECT_YELLOW     174
#define COLOR_SELECT_MAGENTA    175
#define COLOR_SELECT_CYAN       176
#define COLOR_SELECT_WHITE      177

#define DUMP_RASTER_CYAN        180
#define DUMP_RASTER_MAGENTA     181
#define DUMP_RASTER_YELLOW      182
#define DUMP_RASTER_BLACK       183
/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */


#define DEFINE_PALETTE_ENTRY    300
#define BEGIN_PALETTE_DEF       301
#define END_PALETTE_DEF         302
#define SELECT_PALETTE_ENTRY    303

#define OPT_DITHERING_ON        "Normal"
#define OPT_DITHERING_DET       "Detail"
#define OPT_DITHERING_OFF       "Diz_Off"

#define OPT_DITHERING_PIC       "PicImage"
#define OPT_DITHERING_GRA       "Graphic"
#define OPT_DITHERING_CAR       "Character"
#define OPT_DITHERING_GOSA      "Gosa"

#define OPT_N4_NONE             "N4_Off"
#define OPT_N403_NONE           "N4-612_Off"
#define OPT_COLORMATCH_NORMAL   "NormalCol"
#define OPT_COLORMATCH_VIVCOL   "VividCol"
#define OPT_COLORMATCH_NATCOL   "NaturalCol"
#define OPT_COLORMATCH_BRI      "ForBright"
#define OPT_COLORMATCH_VIV      "ForVivid"
#define OPT_COLORMATCH_IRO      "ForIro"

#define OPT_MONO                "Monochrome"
#define OPT_COLOR               "Color"         // MSKK 6/17/2002
#define OPT_COLOR_SINGLE        "Color_Single"
#define OPT_COLOR_MANY          "Color_Many"

#define OPT_1                   "Option1"
#define OPT_2                   "Option2"

#define OPT_AUTO                "Auto"
#define OPT_RASTER              "Raster"
#define OPT_PRESSOFF            "PressOff"


//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

BYTE CMD_START_PAGE[] =
    "\x1Bz\xD0\x01" "Ca*\x1Bz\x00\x01"
    "\x1D" "1alfP\x1D" "1affP\x1D"
    "0;0;0clfP\x1D" "0X\x1D" "0Y";

BYTE SET_FONT_ID[]        = "\x1D%d;%ddh{F";
BYTE DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
BYTE DLI_DELETE_FONT[]    = "\x1D%dddcF";
BYTE SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
BYTE SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
BYTE SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

BYTE FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
BYTE FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
BYTE PRN_DIRECTION[]      = "\x1D%droF";
BYTE SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
BYTE SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
BYTE VERT_FONT_SET[]      = "\x1D%dvpC";
BYTE BOLD_SET[]           = "\x1D%dweF";
BYTE ITALIC_SET[]         = "\x1D%dslF";

BYTE ORG_MODE_IN[]        = "\x1Bz\xD0\x01";
BYTE ORG_MODE_OUT[]       = "\x1Bz\x00\x01";
BYTE PALETTE_SELECT[]     = "Cd,%d,%d*";
BYTE PALETTE_DEFINE[]     = "Cf,%d,%d,%d,%d,%d*";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

BYTE OVERWRITE[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "1;0;100spE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_MPF        3
#define PSRC_AUTO       4
BYTE *EJL_SelectPsrc[] = {
// PU=3 ==> PU=255  2002.3.28 >>>
//   " PU=1", " PU=2", " PU=3", " PU=4", " PU=AU" };
   " PU=1", " PU=2", " PU=255", " PU=4", " PU=AU" };
// PU=3 ==> PU=255  2002.3.28 <<<

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

BYTE *EJL_SetColorTone[] = {
    " ##LE=OFF", " ##LE=ON" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
#define XX_TONER_SAVE_3 3
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2",  " ##TS=3" };

// Modification of Color-mode command 2002.3.28 >>>
//BYTE *EJL_SetColorMode[] = {
//    " ##CM=OFF", " ##CM=ON" };
BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=NML", " ##CM=ECO", " ##CM=ECO2" };
// Modification of Color-mode command 2002.3.28 <<<

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MEDIATYPE_1 1
#define XX_MEDIATYPE_2 2
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS" };

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31
/* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

#define PARAM(p,n) \
    (*((p)+(n)))

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
//        (dwFontID - FONT_MIN_ID), 0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                DLI_SELECT_FONT_ID, (dwFontID - FONT_MIN_ID), 0)) {
        return;
    }
    wlen += (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV         pOEM;
    BYTE            byOutput[64];
    DWORD           dwNeeded;
    DWORD           dwOptionsReturned;

    MY_VERBOSE(("\nOEMEnablePdev ENTRY\n"));

    if (!pdevobj->pdevOEM)
    {
        if (!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->sHeightDiv = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;

    // Get MYPDEV member
    // ColorMatching
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMatching", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMatching) Failed\n"));
        pOEM->Printer = PRN_N4;
        pOEM->iColorMatching = XX_COLORMATCH_NONE;
    } else {
        MY_VERBOSE(("ColorMatching:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_COLORMATCH_BRI)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_BRI;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIV)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_VIV;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_IRO)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_IRO;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NORMAL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NORMAL;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIVCOL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_VIVCOL;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NATCOL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NATCOL;
        } else if (!strcmp(byOutput, OPT_N4_NONE)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else if (!strcmp(byOutput, OPT_N403_NONE)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        }
    }

    // Resolution
    if (!DRVGETDRIVERSETTING(pdevobj, "Resolution", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Resolution) Failed\n"));
        pOEM->iResolution = XX_RES_300DPI;
    } else {
        MY_VERBOSE(("Resolution:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_1)) {
            pOEM->iResolution = XX_RES_300DPI;
            pOEM->iUnitFactor = 4;
            pOEM->sHeightDiv = 1;
        } else if (!strcmp(byOutput, OPT_2)) {
            pOEM->iResolution = XX_RES_600DPI;
            pOEM->iUnitFactor = 2;
            pOEM->sHeightDiv = 4;
        }
    }

    // Dithering
    if (!DRVGETDRIVERSETTING(pdevobj, "Dithering", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Dithering) Failed\n"));
        pOEM->iDithering = XX_DITHERING_OFF;
    } else {
        MY_VERBOSE(("Dithering:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_DITHERING_OFF)) {
            pOEM->iDithering = XX_DITHERING_OFF;
        } else if (!strcmp(byOutput, OPT_DITHERING_ON)) {
            pOEM->iDithering = XX_DITHERING_ON;
        } else if (!strcmp(byOutput, OPT_DITHERING_DET)) {
            pOEM->iDithering = XX_DITHERING_DET;
        } else if (!strcmp(byOutput, OPT_DITHERING_PIC)) {
            pOEM->iDithering = XX_DITHERING_PIC;
        } else if (!strcmp(byOutput, OPT_DITHERING_CAR)) {
            pOEM->iDithering = XX_DITHERING_CAR;
        } else if (!strcmp(byOutput, OPT_DITHERING_GRA)) {
            pOEM->iDithering = XX_DITHERING_GRA;
        } else if (!strcmp(byOutput, OPT_DITHERING_GOSA)) {
            pOEM->iDithering = XX_DITHERING_GOSA;
        } else {
            pOEM->iDithering = XX_DITHERING_OFF;
        }
    }

    // BitFont
    if (!DRVGETDRIVERSETTING(pdevobj, "BitFont", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(BitFont) Failed\n"));
        pOEM->iBitFont = XX_BITFONT_OFF;
    } else {
        MY_VERBOSE(("BitFont:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iBitFont = XX_BITFONT_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iBitFont = XX_BITFONT_ON;
        } else {
            pOEM->iBitFont = XX_BITFONT_OFF;
        }
    }

    // CmyBlack
    if (!DRVGETDRIVERSETTING(pdevobj, "CmyBlack", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(CmyBlack) Failed\n"));
        pOEM->iCmyBlack = XX_CMYBLACK_OFF;
    } else {
        MY_VERBOSE(("CmyBlack:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_ON;
        } else {
            pOEM->iCmyBlack = XX_CMYBLACK_OFF;
        }
    }

    // ColorMode
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMode", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMode) Failed\n"));
        pOEM->iColor = XX_COLOR;
    } else {
        MY_VERBOSE(("ColorMode:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_COLOR_SINGLE)) {
            pOEM->iColor = XX_COLOR_SINGLE;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY)) {
            pOEM->iColor = XX_COLOR_MANY;
        } else if (!strcmp(byOutput, OPT_COLOR)) {
            pOEM->iColor = XX_COLOR;
        } else if (!strcmp(byOutput, OPT_MONO)) {
            pOEM->iColor = XX_MONO;
        }
    }

    // Compress
    if (!DRVGETDRIVERSETTING(pdevobj, "Compress", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Compress) Failed\n"));
        pOEM->iCompress = XX_COMPRESS_OFF;
    } else {
        MY_VERBOSE(("Compress:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_AUTO)) {
            pOEM->iCompress = XX_COMPRESS_AUTO;
        } else if (!strcmp(byOutput, OPT_RASTER)) {
            pOEM->iCompress = XX_COMPRESS_RASTER;
        } else {
            pOEM->iCompress = XX_COMPRESS_OFF;
        }
    }

    if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
        if (ColMatchInit(pdevobj) == FALSE) {
            return NULL;
        }
    }
    MY_VERBOSE(("OEMEnablePdev END\n"));

    return pdevobj->pdevOEM;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMImageProcessing
//////////////////////////////////////////////////////////////////////////

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams)
{
    BOOL   bret;

    if (pIPParams->bBlankBand) {
        MY_VERBOSE(("BB=TRUE\n"));
        bret = TRUE;                // Not spool to printer
    }
    else {
        MY_VERBOSE(("BB=FALSE\n"));
        // DIB spool to printer
        bret = (DIBtoPrn(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, pIPParams)) ? TRUE : FALSE;
    }

    return (PBYTE)IntToPtr(bret);
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pdevobj->pdevOEM)
    {
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
            DizLutTnrTblFree(pdevobj);
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;
    INT i;

    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
//        *pOEMNew = *pOEMOld;
        pOEMNew->fGeneral         = pOEMOld->fGeneral;
        pOEMNew->iEscapement      = pOEMOld->iEscapement;
        pOEMNew->sHeightDiv       = pOEMOld->sHeightDiv;
        pOEMNew->iDevCharOffset   = pOEMOld->iDevCharOffset;
        pOEMNew->iPaperSource     = pOEMOld->iPaperSource;
        pOEMNew->iDuplex          = pOEMOld->iDuplex;
        pOEMNew->iTonerSave       = pOEMOld->iTonerSave;
        pOEMNew->iOrientation     = pOEMOld->iOrientation;
        pOEMNew->iResolution      = pOEMOld->iResolution; 
        pOEMNew->iColor           = pOEMOld->iColor;
        pOEMNew->iSmoothing       = pOEMOld->iSmoothing;
        pOEMNew->iJamRecovery     = pOEMOld->iJamRecovery;
        pOEMNew->iMediaType       = pOEMOld->iMediaType;
        pOEMNew->iUnitFactor      = pOEMOld->iUnitFactor;
        pOEMNew->iDithering       = pOEMOld->iDithering;
        pOEMNew->iColorMatching   = pOEMOld->iColorMatching;
        pOEMNew->iBitFont         = pOEMOld->iBitFont;
        pOEMNew->iCmyBlack        = pOEMOld->iCmyBlack;
        pOEMNew->iTone            = pOEMOld->iTone;
        pOEMNew->iPaperSize       = pOEMOld->iPaperSize;
        pOEMNew->iCompress        = pOEMOld->iCompress;
        pOEMNew->Printer          = pOEMOld->Printer;
        pOEMNew->wRectWidth       = pOEMOld->wRectWidth;
        pOEMNew->wRectHeight      = pOEMOld->wRectHeight;
        pOEMNew->dwDLFontID       = pOEMOld->dwDLFontID;
        pOEMNew->dwDLSelectFontID = pOEMOld->dwDLSelectFontID;
        pOEMNew->dwDLSetFontID    = pOEMOld->dwDLSetFontID;
        pOEMNew->wCharCode        = pOEMOld->wCharCode;

        pOEMNew->Col.wReso        = pOEMOld->Col.wReso;
        pOEMNew->Col.ColMon       = pOEMOld->Col.ColMon;
        pOEMNew->Col.DatBit       = pOEMOld->Col.DatBit;
        pOEMNew->Col.BytDot       = pOEMOld->Col.BytDot;
        pOEMNew->Col.Mch.Mode     = pOEMOld->Col.Mch.Mode;
        pOEMNew->Col.Mch.Viv      = pOEMOld->Col.Mch.Viv;
        pOEMNew->Col.Mch.KToner   = pOEMOld->Col.Mch.KToner;
        pOEMNew->Col.Mch.LutNum   = pOEMOld->Col.Mch.LutNum;
        pOEMNew->Col.Mch.Diz      = pOEMOld->Col.Mch.Diz;
        pOEMNew->Col.Mch.Toner    = pOEMOld->Col.Mch.Toner;
        pOEMNew->Col.Mch.TnrNum   = pOEMOld->Col.Mch.TnrNum;
        pOEMNew->Col.Mch.CmyBlk   = pOEMOld->Col.Mch.CmyBlk;
        pOEMNew->Col.Mch.Speed    = pOEMOld->Col.Mch.Speed;
        pOEMNew->Col.Mch.Gos32    = pOEMOld->Col.Mch.Gos32;
        pOEMNew->Col.Mch.PColor   = pOEMOld->Col.Mch.PColor;
        pOEMNew->Col.Mch.SubDef   = pOEMOld->Col.Mch.SubDef;
        pOEMNew->Col.Mch.Bright   = pOEMOld->Col.Mch.Bright;
        pOEMNew->Col.Mch.Contrast = pOEMOld->Col.Mch.Contrast;
        pOEMNew->Col.Mch.GamRed   = pOEMOld->Col.Mch.GamRed;
        pOEMNew->Col.Mch.GamGreen = pOEMOld->Col.Mch.GamGreen;
        pOEMNew->Col.Mch.GamBlue  = pOEMOld->Col.Mch.GamBlue;

        if (pOEMOld->Printer != PRN_N403) {
            if (NULL != pOEMNew->Col.N4.lpDizInf)
            {
//                MemFree(pOEMNew->Col.N4.lpDizInf);
                DizLutTnrTblFree(pdevobjNew);
            }
            pOEMNew->Col.N4.lpDizInf = pOEMOld->Col.N4.lpDizInf;
            pOEMOld->Col.N4.lpDizInf = NULL;
        }
        else {
            if (NULL != pOEMNew->Col.N403.lpDizInf) {
//                MemFree(pOEMNew->Col.N403.lpDizInf);
                DizLutTnrTblFree(pdevobjNew);
            }
            pOEMNew->Col.N403.lpDizInf = pOEMOld->Col.N403.lpDizInf;
            pOEMOld->Col.N403.lpDizInf = NULL;
        }
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT             iRet = 0;
    BYTE            Cmd[BUFFLEN];
    PMYPDEV         pOEM;
    WORD            wlen;
    WORD            wGray;
    DWORD           dwTempX, dwTempY;
    CMYK            TmpCmyk;
    RGBS            TmpRgb;
// MSKK 99/6/24
    WORD            wPalID;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6
    size_t pcb;          // 2002.3.6

    MY_VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

// Replacement of strsafe-api 2002.3.6 >>>
//       wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_SINGLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_SINGLE_BYTE,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION,pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET, 0)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_DOUBLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_DOUBLE_BYTE,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION,pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET, 1)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral |= FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:
        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
//        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectPsrc[pOEM->iPaperSource],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectOrient[pOEM->iOrientation],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        // CASIO extention

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectRes[pOEM->iResolution],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 >>>

// Modification of Color-mode command 2002.3.28 >>>
#if 0
        if (pOEM->iColor > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorMode[1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
#else
        if (pOEM->iColor > 0) {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[3],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        } else {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[0],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        }
#endif
// Modification of Color-mode command 2002.3.28 <<<

        if (pOEM->iDuplex > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetDuplex[pOEM->iDuplex - 1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 >>>
        }

        if (pOEM->iColor == XX_COLOR_MANY) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorTone[1] );
            if (S_OK != StringCbCopyA(&Cmd[wlen],sizeof(Cmd)-wlen,EJL_SetColorTone[1]))
                break;
// Replacement of strsafe-api 2002.3.6 <<<
        }
        else {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorTone[0] );
            if (S_OK != StringCbCopyA(&Cmd[wlen],sizeof(Cmd)-wlen,EJL_SetColorTone[0]))
                break;
// Replacement of strsafe-api 2002.3.6 <<<
        }
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbLengthA(&Cmd[wlen], sizeof(Cmd)-wlen, &pcb))
            break;
        wlen += (WORD)pcb;
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetTonerSave[pOEM->iTonerSave],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetSmoohing[pOEM->iSmoothing],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetJamRecovery[pOEM->iJamRecovery],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen], " ##SN=ON");
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, " ##SN=ON",
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        if (pOEM->iMediaType > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetMediaType[pOEM->iMediaType - 1],
                                        &pDestEnd, &szRemLen,
                                       STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == XX_RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EPg_SelectRes[pOEM->iResolution],
                                   &pDestEnd, &szRemLen,
                                   STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case TONER_SAVE_3:
        pOEM->iTonerSave = XX_TONER_SAVE_3;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MEDIATYPE_1:
        pOEM->iMediaType = XX_MEDIATYPE_1;
        break;

    case MEDIATYPE_2:
        pOEM->iMediaType = XX_MEDIATYPE_2;
        break;

    case DEFINE_PALETTE_ENTRY:
        //RGB -> CMYK
        TmpRgb.Red   = (BYTE)(PARAM(pdwParams, 1));
        TmpRgb.Green = (BYTE)(PARAM(pdwParams, 2));
        TmpRgb.Blue  = (BYTE)(PARAM(pdwParams, 3));

        memset(&TmpCmyk, 0x00, sizeof(TmpCmyk)); 
        StrColMatching(pdevobj, (WORD)1, &TmpRgb, &TmpCmyk);

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, PALETTE_DEFINE, wPalID, TmpCmyk.Cyn,
//            TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PALETTE_DEFINE, wPalID, TmpCmyk.Cyn,
                                    TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

        MY_VERBOSE(("DEFINE_PALETTE_ENTRY No %d\n",
            (INT)(PARAM(pdwParams, wPalID))));
        break;

    case BEGIN_PALETTE_DEF:
        MY_VERBOSE(("CmdBeginPaletteDef\n"));
        break;

    case END_PALETTE_DEF:
        MY_VERBOSE(("CmdEndPaletteDef\n"));
        break;

    case SELECT_PALETTE_ENTRY:
        MY_VERBOSE(("SELECT_PALETTE_ENTRY "));

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, wPalID);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PALETTE_SELECT, 0, wPalID)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
        break;

    case START_PAGE:
        WRITESPOOLBUF(pdevobj, CMD_START_PAGE, BYTE_LENGTH(CMD_START_PAGE));

        if (pOEM->iColor == XX_COLOR_MANY || pOEM->iColor == XX_COLOR_SINGLE) {
            //Initialize palette state (Spools pure black color command)
            wlen = 0;
            TmpRgb.Red = TmpRgb.Green = TmpRgb.Blue = 0;
            StrColMatching(pdevobj, (WORD)1, &TmpRgb, &TmpCmyk);
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen], ORG_MODE_IN );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, ORG_MODE_IN,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_DEFINE,
//                DEFAULT_PALETTE_INDEX,
//                TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
//            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_SELECT,
//                0, DEFAULT_PALETTE_INDEX);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        PALETTE_DEFINE,
                                        DEFAULT_PALETTE_INDEX,
                                        TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        PALETTE_SELECT,
                                        0, DEFAULT_PALETTE_INDEX)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 >>>
            WRITESPOOLBUF(pdevobj, Cmd, wlen);
            WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        }
        break;

    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        MY_VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
//            wGray,
//            (WORD)dwTempX,
//            (WORD)dwTempY,
//            (WORD)(dwTempX + pOEM->wRectWidth - 1),
//            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    RECT_FILL, 
                                    wGray,
                                    (WORD)dwTempX,
                                    (WORD)dwTempY,
                                    (WORD)(dwTempX + pOEM->wRectWidth - 1),
                                    (WORD)(dwTempY + pOEM->wRectHeight - 1))) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 <<<
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
// Check of zero divide 2002.3.23 >>>
            if (width == 0) {
                ERR(("OEMSendFontCmd() 0Div-Check [width=0] \n"));
                return;
            }
// Check of zero divide 2002.3.23 <<<
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 <<<
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
// Check of zero divide 2002.3.23 >>>
    if (pIFI->fwdUnitsPerEm == 0) {
        ERR(("OEMSendFontCmd() 0Div-Check [pIFI->fwdUnitsPerEm=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    MY_VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
//        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_CHAR_OFFSET,
                                (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0)) {
        return;
    }
    wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

    if (pOEM->fGeneral & FG_VERT)
    {
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                   &pDestEnd, &szRemLen,
                                   STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                   VERT_FONT_SET, 1)) {
            return;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
// Check of zero divide 2002.3.23 >>>
//    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;
    LONG tmp;
    if (vertRes == 0) {
        ERR(("LGetPointSize100() 0Div-Check [vertRes=0] \n"));
        return 0;
    }
    tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;
// Check of zero divide 2002.3.23 <<<

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr)
//{
//    register long count;
//
//    count = strlen(_ltoa(size / 100, pStr, 10));
//    pStr[count++] = '.';
//    count += strlen(_ltoa(size % 100, &pStr[count], 10));
//
//    return count;
//}
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize)
{
    register long count;
    size_t pcb;

    if (S_OK != StringCbLengthA(_ltoa(size / 100, pStr, 10), StrSize, &pcb))
        return 0;
    count = (WORD)pcb;
    pStr[count++] = '.';
    if (S_OK != StringCbLengthA(_ltoa(size % 100, &pStr[count], 10), StrSize-count, &pcb))
        return 0;
    count += (WORD)pcb;

    return count;
}
// Replacement of strsafe-api 2002.3.6 <<<

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    MY_VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));

            /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
            /* So, we need not check whether it is NULL. */
            MemFree(pTransOrg);
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            MY_VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            MY_VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                wLen = 0;       // ntbug9#226623: PREFIX
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            MY_VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
    /* So, we need not check whether it is NULL. */
    MemFree(pTransOrg);
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
//    BYTE sFontName[54];   // 2002.3.6 Buffer size insufficient
    BYTE sFontName[64];     // 2002.3.6
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;
    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    DL_VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    DL_VERBOSE(("TT Font:\n"));
    DL_VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    DL_VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    DL_VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    DL_VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    DL_VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if (pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    DL_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    DL_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    DL_VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    DL_VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if ( MasterToDevice(pOEM,wCellHeight) > 64 )
     {
         DL_VERBOSE(("Abort OEMDownloadFontHeader: pt=%d\n",
             MasterToDevice(pOEM, wCellHeight)));
         return 0;
     }
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

// Check of zero divide 2002.3.23 >>>
    if (iTemp == 0) {
        ERR(("OEMDownloadFontHeader() 0Div-Check [iTemp=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

// Replacement of strsafe-api 2002.3.6 >>>
//    iSizeFontName = wsprintf(sFontName,
//       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
    if (S_OK != StringCbPrintfExA(sFontName, sizeof(sFontName),
        &pDestEnd, &szRemLen,
        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
        "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeFontName = (WORD)(pDestEnd - sFontName);
//    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
        &pDestEnd, &szRemLen,
        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
        SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    DL_VERBOSE(("FontHeader:\n"));
    DL_VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    DL_VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    DL_VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    DL_VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    DL_VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    DL_VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    DL_VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    DL_VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    DL_VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    DL_VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    DL_VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    DL_VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    DL_VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    DL_VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    DL_VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    DL_VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    DL_VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    DL_VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    DL_VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    DL_VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    DL_VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    DL_VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    DL_VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    DL_VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    MY_VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// Replacement of strsafe-api 2002.3.6 >>>
//// CASIO 98/11/24 ->
////    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
////        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
////    }else{
//        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
////    }
//// CASIO 98/11/24 <-
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp))) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    MY_VERBOSE(("ESCPageChar:\n"));
    MY_VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    MY_VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    MY_VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    MY_VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    MY_VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    MY_VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    MY_VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    MY_VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    DL_VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    )
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
        pMemoryUsage->dwFixedMemoryUsage = (pOEM->Printer == PRN_N403) ?
            N403_DIZSIZ_B1 * 4 + N403_ENTDIZSIZ_B2 * 4 + N403_LUTTBLSIZ +
            N403_CCHRGBSIZ + N403_CCHCMYSIZ + N403_TNRTBLSIZ :
            N4_DIZSIZ_CM * 2 + N4_DIZSIZ_YK * 2 + N4_LUTTBLSIZ + N4_CCHRGBSIZ +
            N4_CCHCMYSIZ + N4_TNRTBLSIZ;
        pMemoryUsage->dwPercentMemoryUsage = 100 * (pOEM->Col.DatBit * 4 + 24 + 32) / 32;

        MY_VERBOSE(("OEMMemOryUsage pOEM->Col.DatBit = %d\n",pOEM->Col.DatBit));
    }

    return;
}


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\n403diz.h ===
//***************************************************************************************************
//    N403DIZ.H
//
//    C Header (Functions of dither and color matching (For N4-612 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Color/Monochrome
//---------------------------------------------------------------------------------------------------
#define    N403_COL            0
#define    N403_MON            1

//---------------------------------------------------------------------------------------------------
//    Printer mode
//---------------------------------------------------------------------------------------------------
#define    N403_MOD_300B1        0
#define    N403_MOD_300B2        1
#define    N403_MOD_300B4        2
#define    N403_MOD_600B1        3
#define    N403_MOD_600B2        4

//---------------------------------------------------------------------------------------------------
//    Type of dithering
//---------------------------------------------------------------------------------------------------
#define    N403_DIZ_SML        0
#define    N403_DIZ_MID        1
#define    N403_DIZ_RUG        2

//---------------------------------------------------------------------------------------------------
//    Dither pattern
//---------------------------------------------------------------------------------------------------
#define    N403_ALLDIZNUM        64
#define    N403_DIZSPC            4

//---------------------------------------------------------------------------------------------------
//    size of each table
//---------------------------------------------------------------------------------------------------
#define    N403_DIZSIZ_B1        (32 * 32)                  // dither table size (2value)
#define    N403_DIZSIZ_B2        (16 * 16 *  3)             // dither table size (4value)
#define    N403_DIZSIZ_B4        ( 8 *  8 * 15)             // dither table size (16value)
#define    N403_ENTDIZSIZ_B2    (16 * 16 *  3)              // entry dither table size (4value)
#define    N403_TNRTBLSIZ        256                        // toner density table size
#define    N403_GLDNUM            32                        // LUT table grid
#define    N403_GLDSPC            8                         // LUT table grid interval
                                                            // LUT table size
#define    N403_LUTTBLSIZ        ((DWORD)N403_GLDNUM * N403_GLDNUM * N403_GLDNUM * sizeof(CMYK))
#define    N403_CCHNUM            256                            // Number of cache tables
#define    N403_CCHRGBSIZ        (N403_CCHNUM * sizeof(RGBS))    // Cache table size(RGB)
#define    N403_CCHCMYSIZ        (N403_CCHNUM * sizeof(CMYK))    // Cache table size(CMYK)


//---------------------------------------------------------------------------------------------------
//    Structure for control dithering and color-matching
//---------------------------------------------------------------------------------------------------
typedef    struct {
    DWORD        ColMon;                                    // Color/Monochrome
    DWORD        PrnMod;                                    // Printermode
    struct {                                                // Structure for dither pattern
        DWORD        Num;                                   // Table current number(0`2)
        LPBYTE       Tbl[3][4];                             // Data table
    } Diz;
    struct {                                                // Structure for entry dither pattern
        LPBYTE       Tbl[4];                                // Data table
    } EntDiz;
    struct {                                                // Structure for toner density table
        LPBYTE       Tbl;                                   // Data table
    } Tnr;
    struct {                                                // Structure for LUT table 
        LPCMYK       Tbl;                                   // Data table
        LPRGB        CchRgb;                                // Cache table(RGB)
        LPCMYK       CchCmy;                                // Cache table(CMYK)
    } Lut;
    DWORD        DizSiz[4];                                 // dither pattern size
} N403DIZINF, *LPN403DIZINF;



//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N403DizPtnMak(LPN403DIZINF, DWORD, DWORD);
VOID WINAPI N403TnrTblMak(LPN403DIZINF, LONG);
DWORD WINAPI N403Diz002(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403Diz004(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403Diz016(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403DizSml(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403DizPrn(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
VOID WINAPI N403ColMch000(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColMch001(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColVivPrc(LPN403DIZINF, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColCnvSld(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColCnvL02(LPN403DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N403ColCnvMon(LPN403DIZINF, LPRGB, LPCMYK, DWORD);


//    End of N403DIZ.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\n4diz.h ===
//***************************************************************************************************
//    N4DIZ.H
//
//    C Header (Functions of dither and color matching (For N4 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Color or Monochrome
//---------------------------------------------------------------------------------------------------
#define    N4_COL                0
#define    N4_MON                1

//---------------------------------------------------------------------------------------------------
//    Dithering
//---------------------------------------------------------------------------------------------------
#define    N4_DIZ_SML            0
#define    N4_DIZ_MID            1
#define    N4_DIZ_RUG            2
#define    N4_DIZ_GOS            3

//---------------------------------------------------------------------------------------------------
//    Dither pattern
//---------------------------------------------------------------------------------------------------
#define    N4_ALLDIZNUM        64
#define    N4_DIZSPC            4

//---------------------------------------------------------------------------------------------------
//    Size of each table
//---------------------------------------------------------------------------------------------------
#define    N4_DIZSIZ_CM        (17 * 17)                    // Dither table size(CM)
#define    N4_DIZSIZ_YK        (16 * 16)                    // Dither table size(YK)
#define    N4_TNRTBLSIZ        256                          // Toner density 
#define    N4_GLDNUM            32                          // LUT table grid
#define    N4_GLDSPC            8                           // LUT table grid interval
                                                            // LUT table size
#define    N4_LUTTBLSIZ        ((DWORD)N4_GLDNUM * N4_GLDNUM * N4_GLDNUM * sizeof(CMYK))
#define    N4_CCHNUM            256                         // Number of Table
#define    N4_CCHRGBSIZ        (N4_CCHNUM * sizeof(RGBS))   // Table size(RGB)
#define    N4_CCHCMYSIZ        (N4_CCHNUM * sizeof(CMYK))   // Table size(CMYK)

//---------------------------------------------------------------------------------------------------
//    Structure for control dithering and color-matching
//---------------------------------------------------------------------------------------------------
typedef SHORT *LPSHORT;
typedef    struct {
    DWORD        ColMon;                                    // Color/Monochrome
    struct {                                                // Structure for dither pattern
        DWORD        Num;                                   // Table current number(0-2)
        LPBYTE       Tbl[3][4];                             // Data table
    } Diz;
    struct {                                                // Structure for toner density
        LPBYTE       Tbl;                                   // Data table
    } Tnr;
    struct {                                                // Structure for LUT table
        LPCMYK       Tbl;                                   // Data table
        LPRGB        CchRgb;                                // Cache table(RGB)
        LPCMYK       CchCmy;                                // Cache table(CMYK)
    } Lut;
    struct {                                                // Structure for GOSA-Dispersion(RGB) table
        DWORD        Num;                                   // Table current number(0-1)
        DWORD        Siz;                                   // Data table size
        DWORD        Yax;                                   // Y coordinates
        LPSHORT      Tbl[2];                                // Data table
    } GosRGB;
    struct {                                                // Structure for GOSA-Dispersion(CMYK) table
        DWORD        Num;                                   // Table current number(0-1)
        DWORD        Siz;                                   // Data table size
        DWORD        Yax;                                   // Y coordinates
        LPSHORT      Tbl[2];                                // Data table
    } GosCMYK;
} N4DIZINF, *LPN4DIZINF;


//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N4DizPtnMak(LPN4DIZINF, DWORD, DWORD);
VOID WINAPI N4DizPtnPrn(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE);
VOID WINAPI N4TnrTblMak(LPN4DIZINF, LONG);
DWORD WINAPI N4Diz001(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Diz00n(LPN4DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Gos001(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Gos00n(LPN4DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
VOID WINAPI N4RgbGos(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE);
VOID WINAPI N4ColMch000(LPN4DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N4ColMch001(LPN4DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N4ColCnvSld(LPN4DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCnvLin(LPN4DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCnvMon(LPN4DIZINF, DWORD, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCtr(LPN4DIZINF, LONG, LONG, LONG, LONG, LONG, DWORD, LPRGB);


//    End of N4DIZ.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\n4diz.c ===
//***************************************************************************************************
//    N4DIZ.C
//
//    Functions of dither and color matching (For N4 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "PDEV.H"
#include    "strsafe.h"         // Security-Code 2002.3.6

//***************************************************************************************************
//    Data define
//***************************************************************************************************
/*----------------------------------------------------------------------------
    Pattern original(Ver.3)
----------------------------------------------------------------------------*/
const static BYTE    MgtGinTbl[3] = { 144, 136, 116 };
const static BYTE    MgtTilTbl[3][4][4] = {
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Net ----*/
    {   {     1,    3,   14,   12    },
        {     8,   10,    4,    6    },
        {    15,   13,    0,    2    },
        {     5,    7,    9,   11    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    }
};
const static BYTE    YelGinTbl[3] = { 120, 120, 120 };
const static BYTE    YelTilTbl[3][4][4] = {
    /*--- Net ----*/
    {   {     0,    2,   14,   12    },
        {     8,   10,    5,    7    },
        {    15,   13,    1,    3    },
        {     4,    6,    9,   11    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    }
};
const static BYTE    BlaGinTbl[3] = { 100, 100, 100 };
const static BYTE    BlaTilTbl[3][4][4] = {
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Net ----*/
    {   {     0,    2,   14,   12    },
        {     8,   10,    5,    7    },
        {    15,   13,    1,    3    },
        {     4,    6,    9,   11    }    }
};
#define STRMGT 16
const static BYTE    MgtTilNum[17] = {
    2, 11, 13, 4, 15, 6, 3, 12, 1, 10, 16, 7, 14, 5, 8, 0, 9
};

/*----------------------------------------------------------------------------
    Pattern original(Ver.3) For enter to printer
----------------------------------------------------------------------------*/
const static BYTE Bun4x4All[16] = {                /* Dither pattern (4*4)    */
     0,     8,     2,    10,
    12,     4,    14,     6,
     3,    11,     1,     9,
    15,     7,    13,     5
};
const static BYTE Bun2x2All[16] = {                /* Dither pattern (2*2)    */
     0,     2,
     3,     1
};
/*==== Detail ====*/
const static BYTE Bun8x8Bla[64] = {                /* black   */
    /*---- Dispersion ----*/
    3,    35,    11,    43,    1,     33,    9,    41,
    51,   19,    59,    27,    49,    17,    57,   25,
    15,   47,    7,     39,    13,    45,    5,    37,
    63,   31,    55,    23,    61,    29,    53,   21,
    0,    32,    8,     40,    2,     34,    10,   42,
    48,   16,    56,    24,    50,    18,    58,   26,
    12,   44,    4,     36,    14,    46,    6,    38,
    60,   28,    52,    20,    62,    30,    54,   22
};
const static BYTE Bun8x8Cyn[64] = {                /* cyan     */
    /*---- Dispersion ----*/
    0,     63,    15,    51,    3,     60,    12,    48,
    16,    32,    31,    47,    19,    35,    28,    44,
    56,    8,     55,    7,     59,    11,    52,    4,
    36,    24,    40,    23,    39,    27,    43,    20,
    14,    50,    2,     61,    13,    49,    1,     62,
    30,    46,    18,    34,    29,    45,    17,    33,
    54,    6,     58,    10,    53,    5,     57,    9,
    41,    22,    38,    26,    42,    21,    37,    25
};
const static BYTE Bun8x8Mgt[64] = {                /* magenta    */
    /*---- Dispersion ----*/
    0,     31,    55,    39,    13,    17,    57,    41,
    48,    32,    8,     23,    61,    45,    5,     25,
    12,    16,    56,    40,    2,     29,    53,    37,
    60,    44,    4,     24,    50,    34,    10,    21,
    3,     28,    52,    36,    14,    18,    58,    42,
    51,    35,    11,    20,    62,    46,    6,     26,
    15,    19,    59,    43,    1,     30,    54,    38,
    63,    47,    7,     27,    49,    33,    9,     22
};
/*==== Normal ====*/
const static BYTE Mid8x8Cyn[64] = {                /* cyan     */
    /*---- Net ----*/
    32, 19, 14, 62, 63, 60,  2,  7,
    54,  4,  9, 31, 59, 22, 24, 58,
    50, 27, 42, 29, 16, 11, 40, 46,
    15, 37, 57, 53,  1,  6, 34, 38,
     0, 10, 45, 49, 25, 55, 51, 20,
     5, 36, 33, 18, 13, 43, 47, 35,
    56, 52, 39,  3,  8, 30, 41, 26,
    44, 48, 21, 23, 61, 28, 17, 12
};
const static BYTE Mid8x8Bla[64] = {                /* black   */
    /*---- Dispersion ----*/
    3,     35,    11,    43,    1,     33,    9,     41,
    51,    19,    59,    27,    49,    17,    57,    25,
    15,    47,    7,     39,    13,    45,    5,     37,
    63,    31,    55,    23,    61,    29,    53,    21,
    0,     32,    8,     40,    2,     34,    10,    42,
    48,    16,    56,    24,    50,    18,    58,    26,
    12,    44,    4,     36,    14,    46,    6,     38,
    60,    28,    52,    20,    62,    30,    54,    22
};
const static BYTE Mid8x8Mgt[64] = {                /* Magenta   */
    /*---- Net ----*/
    44, 48, 21, 23, 61, 28, 17, 12,
    56, 52, 39,  3,  8, 30, 41, 26,
     5, 36, 33, 18, 13, 43, 47, 35,
     0, 10, 45, 49, 25, 55, 51, 20,
    15, 37, 57, 53,  1,  6, 34, 38,
    50, 27, 42, 29, 16, 11, 40, 46,
    54,  4,  9, 31, 59, 22, 24, 58,
    32, 19, 14, 62, 63, 60,  2,  7
};
const static BYTE Mid8x8Yel[64] = {                /* Yellow  */
    /*---- Net ----*/
    50,    0,     8,     56,    48,    2,     10,    58,
    30,    32,    40,    20,    28,    34,    42,    22,
    14,    60,    52,    4,     12,    62,    54,    6,
    46,    16,    24,    36,    44,    18,    26,    38,
    49,    3,     11,    59,    51,    1,     9,     57,
    29,    35,    43,    23,    31,    33,    41,    21,
    13,    63,    55,    7,     15,    61,    53,    5,
    45,    19,    27,    39,    47,    17,    25,    37
};
/*==== collage ====*/
const static BYTE Syu8x8Cyn[64] = {                /* cyan        */
    /*---- center ----*/
    61,    45,    16,    12,    8,     28,    41,    57,
    5,     25,    36,    52,    48,    32,    21,    1,
    9,     29,    43,    59,    63,    47,    17,    13,
    49,    33,    23,    3,     7,     27,    37,    53,
    62,    46,    19,    15,    11,    31,    42,    58,
    6,     26,    39,    55,    51,    35,    22,    2,
    10,    30,    40,    56,    60,    44,    18,    14,
    50,    34,    20,    0,     4,     24,    38,    54
};
const static BYTE Syu8x8Mgt[64] = {                /* magenta   */
    /*---- center ----*/
    49,    13,    9,     61,    50,    14,    10,    62,
    33,    29,    25,    45,    34,    30,    26,    46,
    20,    40,    39,    19,    23,    43,    36,    16,
    4,     56,    55,    3,     7,     59,    52,    0,
    8,     60,    51,    15,    11,    63,    48,    12,
    24,    44,    35,    31,    27,    47,    32,    28,
    37,    17,    21,    41,    38,    18,    22,    42,
    53,    1,     5,     57,    54,    2,     6,     58
};
const static BYTE Syu8x8Yel[64] = {                /* yellow    */
    /*---- center ----*/
    5,     13,    39,    59,    58,    43,    17,    7,
    23,    31,    49,    44,    36,    50,    25,    15,
    41,    52,    26,    18,    10,    28,    53,    33,
    61,    34,    8,     0,     2,     20,    46,    60,
    62,    42,    16,    6,     4,     12,    38,    63,
    37,    55,    24,    14,    22,    30,    54,    45,
    11,    29,    48,    32,    40,    51,    27,    19,
    3,     21,    47,    56,    57,    35,    9,     1
};

const static BYTE Wgt001[8][8] = {
    {  0,  8, 56, 48,  2, 10, 58, 50 },
    { 32, 40, 20, 28, 34, 42, 22, 30 },
    { 60, 52,  4, 12, 62, 54,  6, 14 },
    { 16, 24, 36, 44, 18, 26, 38, 46 },
    {  3, 11, 59, 51,  1,  9, 57, 49 },
    { 35, 43, 23, 31, 33, 41, 21, 29 },
    { 63, 55,  7, 15, 61, 53,  5, 13 },
    { 19, 27, 39, 47, 17, 25, 37, 45 }
};
const static BYTE Wgt002[8][8] = {
    {  5, 13, 39, 59, 58, 43, 17,  7 },
    { 23, 31, 49, 44, 36, 50, 25, 15 },
    { 41, 52, 26, 18, 10, 28, 53, 33 },
    { 61, 34,  8,  0,  2, 20, 46, 60 },
    { 62, 42, 16,  6,  4, 12, 38, 63 },
    { 37, 55, 24, 14, 22, 30, 54, 45 },
    { 11, 29, 48, 32, 40, 51, 27, 19 },
    {  3, 21, 47, 56, 57, 35,  9,  1 }
};

const static SHORT SinTbl[256] = {
       0,    3,    6,    9,   12,   15,   18,   21,
      25,   28,   31,   34,   37,   40,   43,   46,
      49,   52,   54,   57,   60,   63,   66,   68,
      71,   73,   76,   79,   81,   83,   86,   88,
      90,   92,   95,   97,   99,  101,  103,  104,
     106,  108,  110,  111,  113,  114,  115,  117,
     118,  119,  120,  121,  122,  123,  124,  125,
     125,  126,  126,  127,  127,  127,  127,  127,
     127,  127,  127,  127,  127,  126,  126,  125,
     125,  124,  123,  123,  122,  121,  120,  119,
     117,  116,  115,  113,  112,  110,  109,  107,
     105,  104,  102,  100,   98,   96,   94,   91,
      89,   87,   85,   82,   80,   77,   75,   72,
      70,   67,   64,   61,   59,   56,   53,   50,
      47,   44,   41,   38,   35,   32,   29,   26,
      23,   20,   17,   14,   11,    7,    4,    1,
      -1,   -4,   -7,  -11,  -14,  -17,  -20,  -23,
     -26,  -29,  -32,  -35,  -38,  -41,  -44,  -47,
     -50,  -53,  -56,  -59,  -61,  -64,  -67,  -70,
     -72,  -75,  -77,  -80,  -82,  -85,  -87,  -89,
     -91,  -94,  -96,  -98, -100, -102, -104, -105,
    -107, -109, -110, -112, -113, -115, -116, -117,
    -119, -120, -121, -122, -123, -123, -124, -125,
    -125, -126, -126, -127, -127, -127, -127, -127,
    -127, -127, -127, -127, -127, -126, -126, -125,
    -125, -124, -123, -122, -121, -120, -119, -118,
    -117, -115, -114, -113, -111, -110, -108, -106,
    -104, -103, -101,  -99,  -97,  -95,  -92,  -90,
     -88,  -86,  -83,  -81,  -79,  -76,  -73,  -71,
     -68,  -66,  -63,  -60,  -57,  -54,  -52,  -49,
     -46,  -43,  -40,  -37,  -34,  -31,  -28,  -25,
     -21,  -18,  -15,  -12,   -9,   -6,   -3,    0
};

/*============================================================================
    Gamma revision table
============================================================================*/
const static BYTE GamTbl014[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
    0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
    0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
    0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
    0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
    0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
    0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
    0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
    0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
    0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
    0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
    0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
    0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
    0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
    0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
    0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
    0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
    0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
    0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
    0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
    0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff
};

const static BYTE GamTbl016[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05,
    0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
    0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 0x11,
    0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15,
    0x16, 0x17, 0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x20,
    0x21, 0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34,
    0x35, 0x36, 0x37, 0x38, 0x38, 0x39, 0x3a, 0x3b,
    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
    0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x65,
    0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
    0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x7a, 0x7b, 0x7c, 0x7d, 0x7f, 0x80, 0x81,
    0x82, 0x83, 0x85, 0x86, 0x87, 0x89, 0x8a, 0x8b,
    0x8c, 0x8e, 0x8f, 0x90, 0x92, 0x93, 0x94, 0x95,
    0x97, 0x98, 0x99, 0x9b, 0x9c, 0x9d, 0x9f, 0xa0,
    0xa1, 0xa3, 0xa4, 0xa5, 0xa7, 0xa8, 0xaa, 0xab,
    0xac, 0xae, 0xaf, 0xb0, 0xb2, 0xb3, 0xb5, 0xb6,
    0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbf, 0xc0, 0xc2,
    0xc3, 0xc4, 0xc6, 0xc7, 0xc9, 0xca, 0xcc, 0xcd,
    0xcf, 0xd0, 0xd2, 0xd3, 0xd5, 0xd6, 0xd8, 0xd9,
    0xdb, 0xdc, 0xde, 0xdf, 0xe1, 0xe2, 0xe4, 0xe5,
    0xe7, 0xe8, 0xea, 0xec, 0xed, 0xef, 0xf0, 0xf2,
    0xf3, 0xf5, 0xf7, 0xf8, 0xfa, 0xfb, 0xfd, 0xff
};


//***************************************************************************************************
//    Function
//***************************************************************************************************
//===================================================================================================
//    Make dither pattern
//===================================================================================================
VOID WINAPI N4DizPtnMak(
    LPN4DIZINF     lpDiz,
    DWORD          dizNum,
    DWORD          diz                                      // Type of dithering
)
{
    WORD           cntTil;                                  // count
    WORD           cntXax;                                  // count
    WORD           cntYax;                                  // count
    WORD           strXax;
    WORD           strYax;
    WORD           dotGin;
    DWORD          num;
    LPBYTE         DizTblCyn;                               // Dither pattern table(CMYK)
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

    /*---- Make black pattern for monochrome ----*/
    if(lpDiz->ColMon == N4_MON){
        for(cntTil = 0; cntTil < 4; cntTil++){
            for(cntYax = 0; cntYax < 8; cntYax++){
                for(cntXax = 0; cntXax < 8; cntXax++){
                    if(diz == N4_DIZ_SML){
                        num = (DWORD)Bun8x8Bla[cntYax*8+cntXax] * 4;
                    }else if(diz == N4_DIZ_MID){
                        num = (DWORD)Mid8x8Yel[cntYax*8+cntXax] * 4;
                    }else{
                        num = (DWORD)Syu8x8Yel[cntYax*8+cntXax] * 4;
                    }
                    num += (DWORD)Bun2x2All[cntTil];
//                    DizTblBla[(cntTil/2)*8+cntYax][(cntTil%2)*8+cntXax] = num;
                    DizTblBla[((cntTil / 2) * 8 + cntYax) * 16 + ((cntTil % 2) * 8 + cntXax)] = (BYTE)num;
                }
            }
        }
        return;
    }


    /*---- Make magenta cyan pattern ----*/
    strXax = 6;
    strYax = 0xffff;
    dotGin = MgtGinTbl[diz];
    for(cntTil = 0; cntTil < 17; cntTil++){
        strXax += 4;
        strYax += 1;
        num = (DWORD)STRMGT * 17 + (DWORD)MgtTilNum[cntTil];
        num = num * 255 / (17 * 17);
//        DizTblMgt[strYax % 17][strXax % 17] = num;
        DizTblMgt[(strYax % 17) * 17 + (strXax % 17)] = (BYTE)num;
        DizTblCyn[(strYax % 17) * 17 + (16 - strXax % 17)] = (BYTE)num;
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)MgtTilTbl[diz][cntYax][cntXax] * 17
                                        + (DWORD)MgtTilNum[cntTil];
                /* dot gain revision */
                if(num < (17*17/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 17*17/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (17*17/2) * dotGin / 100;
                }
                if(num < 4){ num = 4; }
                num = num * 255 / (17 * 17);
//                DizTblMgt[(strYax+cntYax+1)%17][(strXax+cntXax)%17] = num;
                DizTblMgt[((strYax + cntYax + 1) % 17) * 17 + ((strXax + cntXax) % 17)] = (BYTE)num;
//                DizTblCyn[(strYax+cntYax+1)%17][16-(strXax+cntXax)%17] = num;
                DizTblCyn[((strYax + cntYax + 1) % 17) * 17 + (16 - (strXax + cntXax) % 17)] = (BYTE)num;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    dotGin = YelGinTbl[diz];
    for(cntTil = 0; cntTil < 16; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)YelTilTbl[diz][cntYax][cntXax] * 16
                                        + (DWORD)Bun4x4All[cntTil];
                /* dot gain revision */
                if(num < (16*16/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 16*16/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (16*16/2) * dotGin / 100;
                }
                num *= 255;
                num /= 16 * 16;
                if(num < 4){ num = 4; }
//                DizTblYel[(cntTil/4)*4 + cntYax][(cntTil%4)*4 + cntXax] = num;
                DizTblYel[((cntTil / 4) * 4 + cntYax) * 16 + ((cntTil % 4) * 4 + cntXax)] = (BYTE)num;
            }
        }
    }
    /*---- Make black pattern ----*/
    dotGin = BlaGinTbl[diz];
    for(cntTil = 0; cntTil < 16; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)BlaTilTbl[diz][cntYax][cntXax] * 16
                                    + (DWORD)Bun4x4All[cntTil];
                /* dot gain revision */
                if(num < (16*16/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 16*16/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (16*16/2) * dotGin / 100;
                }
                num *= 255;
                num /= 16 * 16;
                if(num < 4){ num = 4; }
                
//                DizTblBla[(cntTil/4)*4 + cntYax][(cntTil%4)*4 + cntXax] = num;
                DizTblBla[((cntTil / 4) * 4 + cntYax) * 16 + ((cntTil % 4) * 4 + cntXax)] = (BYTE)num;
            }
        }
    }
}


//===================================================================================================
//     Make dither pattern (for printer entry)
//===================================================================================================
VOID WINAPI N4DizPtnPrn(
    LPN4DIZINF     lpDiz,
    DWORD          dizNum,
    DWORD          colNum,                                  // Color number(0:C 1:M 2:Y 3:K)
    DWORD          ptnSkl,                                  // Density(0`255)
    LPBYTE         ptnAdr                                   // Dither pattern
)
{
    WORD           nijRit;                                  /* dot gain(blot ratej        */
    DWORD          vldDot;
    DWORD          cnt064;                                  /* counter                    */
    DWORD          cnt016;                                  /* counter                    */
    DWORD          cntXax;                                  /* counter                    */
    DWORD          cntYax;                                  /* counter                    */
    LPBYTE         srcAdr;

    /*---- Source dither table address set ----*/
    if(dizNum == N4_DIZ_SML){
        switch(colNum){
            case 0:
                nijRit = 144;
                srcAdr = (LPBYTE)Bun8x8Cyn;
                break;
            case 1:
                nijRit = 144;
                srcAdr = (LPBYTE)Bun8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else if(dizNum == N4_DIZ_MID){
        switch(colNum){
            case 0:
                nijRit = 120;
                srcAdr = (LPBYTE)Mid8x8Cyn;
                break;
            case 1:
                nijRit = 120;
                srcAdr = (LPBYTE)Mid8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Mid8x8Yel;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else if(dizNum == N4_DIZ_RUG) {
        switch(colNum){
            case 0:
                nijRit = 120;
                srcAdr = (LPBYTE)Syu8x8Cyn;
                break;
            case 1:
                nijRit = 120;
                srcAdr = (LPBYTE)Syu8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Syu8x8Yel;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else{
        nijRit = 100;
        switch(colNum){
            case 0:
                srcAdr = (LPBYTE)Bun8x8Cyn;
                break;
            case 1:
                srcAdr = (LPBYTE)Bun8x8Mgt;
                break;
            case 2:
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    srcAdr = (LPBYTE)Mid8x8Yel;
                } else {
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }

    /*---- Get dot gain ----*/
    if(ptnSkl <= (DWORD)(255 * nijRit / 200)){
        vldDot = ((DWORD)32 * 32 * ptnSkl / 255) * 100 / nijRit;
    }else{
        vldDot = ((DWORD)20480 * ptnSkl - (DWORD)26112 * nijRit);
        vldDot /= ((DWORD)10200 - (DWORD)51 * nijRit);
        vldDot += 512;
    }

    /*---- Make pattern ----*/
    for(cntYax = 0 ; cntYax < 32 ; cntYax ++){
        ptnAdr[cntYax*4]     = 0x00;
        ptnAdr[cntYax*4 + 1] = 0x00;
        ptnAdr[cntYax*4 + 2] = 0x00;
        ptnAdr[cntYax*4 + 3] = 0x00;
        for(cntXax = 0 ; cntXax < 32 ; cntXax ++){
            /*---- 16 * 16 No ----*/
            cnt016 = Bun4x4All[4 * (cntYax/8) + cntXax/8];
            cnt064 = srcAdr[8*(cntYax%8) + cntXax%8];
            /*---- Make dither pattern ----*/
            if(vldDot > 16 * cnt064 + cnt016){
                ptnAdr[cntYax*4 + cntXax/8] |= ((BYTE)0x80 >> (cntXax % 8));
            }
        }
    }
}

//===================================================================================================
//    Make toner density table
//===================================================================================================
VOID WINAPI N4TnrTblMak(
    LPN4DIZINF     lpDiz,
    LONG           tnrDns
)
{
    LONG           innNum;
    LONG           outNum;
    LPBYTE         InnTblCmy;

    tnrDns *= 2;                                            // set twice as tnrdns
    InnTblCmy = lpDiz->Tnr.Tbl;
    /*---- Make CMYK conversion table ----*/
    if(tnrDns < 0){
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 255){    outNum = 255;
            }else{                outNum = innNum * (255 + tnrDns) / 255;
            }
            InnTblCmy[innNum] = (BYTE)outNum;
        }
    }else{
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 0){    outNum = 0;
            }else{                outNum = (innNum + tnrDns) * 255 / (255 + tnrDns);
            }
            InnTblCmy[innNum] = (BYTE)outNum;
        }
    }
}


//===================================================================================================
//    Dithering(Not stretch)
//===================================================================================================
DWORD WINAPI N4Diz001(                                      // Number of lines
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,                                  // x pixel
    DWORD          strXax,                                  // x start position
    DWORD          strYax,                                  // y start position
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,                               // Line buffer(C)
    LPBYTE         linBufMgt,                               // Line buffer(M)
    LPBYTE         linBufYel,                               // Line buffer(Y)
    LPBYTE         linBufBla                                // Line buffer(K)
)
{
    DWORD          cntHrz;
    BYTE           tmpByt;
    DWORD          dizNum;
    LPBYTE         DizTblCyn;
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    dizNum = lpDiz->Diz.Num;
    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

    /*---- Not stretch ----*/
    if(lpDiz->ColMon == N4_COL){
        DizTblCyn += strYax % 17 * 17;
        DizTblMgt += strYax % 17 * 17;
        DizTblYel += strYax % 16 * 16;
        DizTblBla += strYax % 16 * 16;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
//            if(cmyBuf[cntHrz*4+0] > DizTblCyn[strYax%17][strXax%17]){
            if (cmyBuf[cntHrz * 4 + 0] > DizTblCyn[strXax % 17]) {
                linBufCyn[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+1] > DizTblMgt[strYax%17][strXax%17]){
            if (cmyBuf[cntHrz * 4 + 1] > DizTblMgt[strXax % 17]) {
                linBufMgt[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+2] > DizTblYel[strYax%16][strXax%16]){
            if (cmyBuf[cntHrz * 4 + 2] > DizTblYel[strXax % 16]) {
                linBufYel[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+3] > DizTblBla[strYax%16][strXax%16]){
            if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[strXax % 16]) {
                linBufBla[cntHrz / 8] |= tmpByt;
            }
            strXax++;
        }
    } else {
        DizTblBla += strYax % 16 * 16;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
//            if(cmyBuf[cntHrz*4+3] > DizTblBla[strYax%16][strXax%16]){
            if (cmyBuf[ cntHrz * 4 + 3] > DizTblBla[strXax % 16]) {
                linBufBla[cntHrz / 8] |= tmpByt;
            }
            strXax++;
        }
    }
    return 1;
}


//===================================================================================================
//    Dither(Stretch )
//===================================================================================================
DWORD WINAPI N4Diz00n(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    DWORD          linByt,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          tmpXax;
    DWORD          tmpYax;
    DWORD          tmpBuf;
    BYTE           tmpByt;
    DWORD          dizNum;
    LPBYTE         DizTblCyn;
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    dizNum = lpDiz->Diz.Num;
    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N4Diz00n() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    /*---- Stretch ----*/
    if(lpDiz->ColMon == N4_COL){
//        yaxSet = (USINT)(yaxOfs + 1) * yaxNrt / yaxDnt;
//        yaxSet -= (USINT)yaxOfs * yaxNrt / yaxDnt;
        yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
        yaxSet -= yaxOfs * yaxNrt / yaxDnt;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
//            xaxSet = (USINT)(xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
//            xaxSet -= (USINT)(xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                tmpYax = strYax;
                for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
//                    if(cmyBuf[cntHrz*4+0] > DizTblCyn[tmpYax%17][strXax%17]){
                    if (cmyBuf[cntHrz * 4 + 0] > DizTblCyn[(tmpYax % 17) * 17 + (strXax % 17)]) {
                        linBufCyn[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+1] >    DizTblMgt[tmpYax%17][strXax%17]){
                    if (cmyBuf[cntHrz * 4 + 1] > DizTblMgt[(tmpYax % 17) * 17 + (strXax % 17)]) {
                        linBufMgt[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+2] >    DizTblYel[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 2] > DizTblYel[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufYel[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+3] >    DizTblBla[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                    tmpBuf += linByt;
                    tmpYax++;
                }
                strXax++;
                tmpXax++;
            }
        }
    } else {
//        yaxSet = (USHRT)(((USINT)yaxOfs + 1) * yaxNrt / yaxDnt);
//        yaxSet -= (USHRT)((USINT)yaxOfs * yaxNrt / yaxDnt);
        yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
        yaxSet -= yaxOfs * yaxNrt / yaxDnt;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
//            xaxSet = (USHRT)(((USINT)xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt);
//            xaxSet -= (USHRT)(((USINT)xaxOfs + cntHrz) * xaxNrt / xaxDnt);
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                tmpYax = strYax;
                for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
//                    if(cmyBuf[cntHrz*4+3] >    DizTblBla[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                    tmpBuf += linByt;
                    tmpYax++;
                }
                strXax++;
                tmpXax++;
            }
        }
    }
    return yaxSet;
}


#define CMYLOW        6
//===================================================================================================
//    GOSA-KAKUSAN(Not stretch)
//===================================================================================================
DWORD WINAPI N4Gos001(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    LONG           strHrz;
    LONG           endHrz;
    LONG           idc;
    LONG           i;
    LONG           k;
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          shiKii;
    SHORT          gos;
    SHORT          num;
    WORD           strCol;
    WORD           j;
    LPSHORT        CmyGo0;
    LPSHORT        CmyGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsCmy;

    if ((strYax & 1) == 0) {
        CmyGo0 = lpDiz->GosCMYK.Tbl[0];
        CmyGo1 = lpDiz->GosCMYK.Tbl[1];
    } else {
        CmyGo0 = lpDiz->GosCMYK.Tbl[1];
        CmyGo1 = lpDiz->GosCMYK.Tbl[0];
    }
    GosTblXSize = lpDiz->GosCMYK.Siz;
    YaxOfsCmy = lpDiz->GosCMYK.Yax;
    CmyGo0 += 4;
    CmyGo1 += 4;
    if(lpDiz->ColMon == N4_COL){ strCol = 0; }else{ strCol = 3; }

    if(strYax - YaxOfsCmy != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 4 ; i++){
            CmyGo1[i] = 0;
        }
    }
    YaxOfsCmy = strYax;
    CmyGo0 += strXax * 4;
    CmyGo1 += strXax * 4;

    /*---- filter set ----*/
    switch(strYax % 6){
        case 0:                                /*---- evn1 >> filter ----*/
            m00=3; m01=5; m02=3; m03=7; idc = +1;    break;
        case 1:                                /*---- odd1 >> filter ----*/
            m00=1; m01=5; m02=3; m03=7; idc = +1;    break;
        case 2:                                /*---- evn2 >> filter ----*/
            m00=4; m01=5; m02=4; m03=8; idc = +1;    break;
        case 3:                                /*---- odd2 << filter ----*/
            m00=1; m01=3; m02=0; m03=7; idc = -1;    break;
        case 4:                                /*---- evn3 << filter ----*/
            m00=2; m01=4; m02=0; m03=8; idc = -1;    break;
        case 5:                                /*---- odd4 >> filter ----*/
        default:
            m00=3; m01=8; m02=3; m03=8; idc = +1;    break;
    }
    sum = m00 + m01 + m02 + m03;
    if(idc == +1){
        strHrz = 0; endHrz = xaxSiz;
    }else{
        strHrz = xaxSiz - 1; endHrz = -1;
    }
    for(i = strHrz ; i != endHrz ; i+=idc){
        for(j = strCol ; j < 4 ; j++){
            k = i * 4 + j;
            num = cmyBuf[k];
            if(num < CMYLOW){ num = 0; }
            shiKii = num / 2 + 52;
            if(j != 2){                    /* except yellow               */
                if((num > 112)&&(num < 144)){
                    shiKii += 
                        ((SHORT)Wgt001[strYax%8][(i+strXax)%8]-32)*256/128;
                }else{
                    shiKii += 
                        ((SHORT)Wgt002[strYax%8][(i+strXax)%8]-32)*num/128;
                }
            }
            gos = (    CmyGo1[k - 4] * m00 + 
                    CmyGo1[k    ] * m01 +
                    CmyGo1[k + 4] * m02 +
                    CmyGo0[k - idc*4] * m03
                    ) / sum;
            if(gos + num > shiKii){
                CmyGo0[k] = num + gos - 255;
                /*---- enter line buffer ----*/
                if(j == 0){
                    linBufCyn[i/8] |= ((BYTE)0x80 >> (i%8));
                }else if(j == 1){
                    linBufMgt[i/8] |= ((BYTE)0x80 >> (i%8));
                }else if(j == 2){
                    linBufYel[i/8] |= ((BYTE)0x80 >> (i%8));
                }else{
                    linBufBla[i/8] |= ((BYTE)0x80 >> (i%8));
                }
            }else{
                CmyGo0[k] = num + gos;
            }
        }
    }
    lpDiz->GosCMYK.Yax = YaxOfsCmy;
    return    1;
}


//===================================================================================================
//    GOSA-KAKUSAN(Stretch)
//===================================================================================================
DWORD WINAPI N4Gos00n(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    DWORD          linByt,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    LONG           cntHrz;
    LONG           cntYax;
    LONG           cntXax;
    LONG           yaxSet;
    LONG           xaxSet;
    LONG           strHrz;
    LONG           endHrz;
    LONG           idc;
    LONG           i;
    LONG           k;
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          shiKii;
    SHORT          gos;
    SHORT          num;
    LPSHORT        bak;
    WORD           strCol;
    WORD           j;
    LPSHORT        CmyGo0;
    LPSHORT        CmyGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsCmy;

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N4Gos00n() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    if ((strYax & 1) == 0) {                                // y coordinates is even number?
        CmyGo0 = lpDiz->GosCMYK.Tbl[0];
        CmyGo1 = lpDiz->GosCMYK.Tbl[1];
    } else {
        CmyGo0 = lpDiz->GosCMYK.Tbl[1];
        CmyGo1 = lpDiz->GosCMYK.Tbl[0];
    }
    GosTblXSize = lpDiz->GosCMYK.Siz;
    YaxOfsCmy = lpDiz->GosCMYK.Yax;
    CmyGo0 += 4;
    CmyGo1 += 4;

    if(lpDiz->ColMon == N4_COL){ strCol = 0; }else{ strCol = 3; }

    if(strYax - YaxOfsCmy != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 4 ; i++){
            CmyGo1[i] = 0;
        }
    }
    YaxOfsCmy = strYax;
    CmyGo0 += strXax * 4;
    CmyGo1 += strXax * 4;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        /*---- filter set ----*/
        switch(strYax % 6){
            case 0:                                /*---- evn1 >> filter ----*/
                m00=3; m01=5; m02=3; m03=7; idc = +1;    break;
            case 1:                                /*---- odd1 >> filter ----*/
                m00=1; m01=5; m02=3; m03=7; idc = +1;    break;
            case 2:                                /*---- evn2 >> filter ----*/
                m00=4; m01=5; m02=4; m03=8; idc = +1;    break;
            case 3:                                /*---- odd2 << filter ----*/
                m00=1; m01=3; m02=0; m03=7; idc = -1;    break;
            case 4:                                /*---- evn3 << filter ----*/
                m00=2; m01=4; m02=0; m03=8; idc = -1;    break;
            case 5:                                /*---- odd4 >> filter ----*/
            default:
                m00=3; m01=8; m02=3; m03=8; idc = +1;    break;
        }
        sum = m00 + m01 + m02 + m03;
        if(idc == +1){
            strHrz = 0; endHrz = xaxSiz;
            i = 0;
        }else{
            strHrz = xaxSiz - 1; endHrz = -1;
            i = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
            i -= xaxOfs * xaxNrt / xaxDnt;
            i -= 1;
        }
        for(cntHrz = strHrz ; cntHrz != endHrz ; cntHrz+=idc){
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                for(j = strCol ; j < 4 ; j++){
                    k = i * 4 + j;
                    num = cmyBuf[cntHrz * 4 + j];
                    if(num < CMYLOW){ num = 0; }
                    shiKii = num / 2 + 52;
                    if(j != 2){                    /* except yellow        */
                        if((num > 112)&&(num < 144)){
                            shiKii += 
                            ((SHORT)Wgt001[strYax%8][(strXax+i)%8]-32)*256/128;
                        }else{
                            shiKii += 
                            ((SHORT)Wgt002[strYax%8][(strXax+i)%8]-32)*num/128;
                        }
                    }
                    gos = (    CmyGo1[k - 4] * m00 +
                            CmyGo1[k    ] * m01 +
                            CmyGo1[k + 4] * m02 +
                               CmyGo0[k - idc * 4] * m03
                               ) / sum;
                    if(gos + num > shiKii){
                        CmyGo0[k] = num + gos - 255;
                        /*---- enter line buffer ----*/
                        if(j == 0){
                            linBufCyn[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else if(j == 1){
                            linBufMgt[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else if(j == 2){
                            linBufYel[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else{
                            linBufBla[i/8] |= ((BYTE)0x80 >> (i%8));
                        }
                    }else{
                        CmyGo0[k] = num + gos;
                    }
                }
                i += idc;
            }
        }
        bak = CmyGo1;
        CmyGo1 = CmyGo0;
        CmyGo0 = bak;
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    if (yaxSet != 0) {
        lpDiz->GosCMYK.Yax = YaxOfsCmy + yaxSet - 1;
    }
    return    yaxSet;
}


#define BUNKAI    (SHORT)8
//===================================================================================================
//    RGB GOSA-Dispersion
//===================================================================================================
VOID WINAPI N4RgbGos(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          drwXax,
    DWORD          yaxOfs,
    LPBYTE         rgbBuf
)
{
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          j;
    SHORT          gos;
    SHORT          out;
    LONG           i;
    LONG           k;
    LONG           idc;
    LONG           strXax;
    LONG           endXax;

    LPSHORT        RgbGo0;
    LPSHORT        RgbGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsRgb;

    if ((yaxOfs & 1) == 0) {                                // Y coodinate is even number?
        RgbGo0 = lpDiz->GosRGB.Tbl[0];
        RgbGo1 = lpDiz->GosRGB.Tbl[1];
    } else {
        RgbGo0 = lpDiz->GosRGB.Tbl[1];
        RgbGo1 = lpDiz->GosRGB.Tbl[0];
    }
    GosTblXSize = lpDiz->GosRGB.Siz;
    YaxOfsRgb = lpDiz->GosRGB.Yax;
    RgbGo0 += 3;
    RgbGo1 += 3;
    if(yaxOfs - YaxOfsRgb != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 3 ; i++){
            RgbGo1[i] = 0;
        }
    }
    lpDiz->GosRGB.Yax = yaxOfs;
    RgbGo0 += drwXax * 3;
    RgbGo1 += drwXax * 3;
    /*---- filter set ----*/
    switch(yaxOfs % 6){
        case 0:                                    /*---- evn1 >> filter ----*/
            m00=3; m01=5; m02=3; m03=7;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 1:                                    /*---- odd1 >> filter ----*/
            m00=1; m01=5; m02=3; m03=7;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 2:                                    /*---- evn2 >> filter ----*/
            m00=4; m01=5; m02=4; m03=8;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 3:                                    /*---- odd2 << filter ----*/
            m00=1; m01=3; m02=0; m03=7;
            idc = -1; strXax = xaxSiz - 1; endXax = -1;
            break;
        case 4:                                    /*---- evn3 << filter ----*/
            m00=2; m01=4; m02=0; m03=8;
            idc = -1; strXax = xaxSiz - 1; endXax = -1;
            break;
        case 5:                                    /*---- odd4 >> filter ----*/
        default:
            m00=3; m01=8; m02=3; m03=8;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
    }
    sum = m00 + m01 + m02 + m03;

    /*---- GOSA-dispersion ----*/
    for(i = strXax ; i != endXax ; i += idc){
        for(j = 0 ; j < 3 ; j++){
            k = i * 3 + j;
            gos = (    m00 * RgbGo1[k - 3] + 
                    m01 * RgbGo1[k    ] +
                    m02 * RgbGo1[k + 3] +
                    m03 * RgbGo0[k - idc*3]
                    ) / sum;
            out = gos + rgbBuf[k];
            out = out / BUNKAI;
            out = out * BUNKAI;
            if(out > 255){ out = 255; }
            else if(out < 0){ out = 0; }
            RgbGo0[k] = (gos + (SHORT)rgbBuf[k]) - out;
            rgbBuf[k] = (BYTE)out;
        }
    }
    return;
}

//===================================================================================================
//    Color Matching(Speed is high)
//===================================================================================================
VOID WINAPI N4ColMch000(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    LPCMYK         LokUppRgbCmy;                            // Lut table
    LPBYTE         innTblCmy;                               // Toner density table
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpCal;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }
        tmpCal  = tmpRed / N4_GLDSPC * N4_GLDNUM * N4_GLDNUM;
        tmpCal += tmpGrn / N4_GLDSPC * N4_GLDNUM;
        tmpCal += tmpBlu / N4_GLDSPC;
        tmpCmy = LokUppRgbCmy[tmpCal];
        tmpCmy.Cyn = innTblCmy[tmpCmy.Cyn];
        tmpCmy.Mgt = innTblCmy[tmpCmy.Mgt];
        tmpCmy.Yel = innTblCmy[tmpCmy.Yel];
        tmpCmy.Bla = innTblCmy[tmpCmy.Bla];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }
}


//===================================================================================================
//    Color Matching(Speed is normal)
//===================================================================================================
VOID WINAPI N4ColMch001(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpR01;
    LONG           tmpR02;
    LONG           tmpG01;
    LONG           tmpG02;
    LONG           tmpB01;
    LONG           tmpB02;
    LONG           ln1;
    LONG           ln2;
    LONG           ln3;

    LONG           tmpC00;
    LONG           tmpM00;
    LONG           tmpY00;
    LONG           tmpK00;
    LONG           tmpC01;
    LONG           tmpM01;
    LONG           tmpY01;
    LONG           tmpK01;
    LONG           tmpC02;
    LONG           tmpM02;
    LONG           tmpY02;
    LONG           tmpK02;
    LONG           tmpC03;
    LONG           tmpM03;
    LONG           tmpY03;
    LONG           tmpK03;

    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LPRGB          CchRgb;
    LPCMYK         CchCmy;

    LPRGB          endAdr;
    DWORD          cch;
    RGBS           tmpRgb;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;
    CchRgb = lpDiz->Lut.CchRgb;
    CchCmy = lpDiz->Lut.CchCmy;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRgb = *rgbAdr;
        tmpRed = tmpRgb.Red;
        tmpGrn = tmpRgb.Green;
        tmpBlu = tmpRgb.Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }

        cch = ( tmpRed * 49 + tmpGrn * 9 + tmpBlu ) % N4_CCHNUM;
        if(    (CchRgb[cch].Red == tmpRgb.Red) &&
            (CchRgb[cch].Green == tmpRgb.Green) &&
            (CchRgb[cch].Blue == tmpRgb.Blue)
        ){
            *cmyAdr = CchCmy[cch];
            cmyAdr++;
            continue;
        }

        /*---- RGB -> CMYK ----*/
        tmpR01 = tmpRed * 31 / 255;
        tmpR02 = (tmpRed * 31 + 254) / 255;

        tmpG01 = tmpGrn * 31 / 255;
        tmpG02 = (tmpGrn * 31 + 254) / 255;

        tmpB01 = tmpBlu * 31 / 255;
        tmpB02 = (tmpBlu * 31 + 254) / 255;


        ln2 = tmpRed - tmpR01*255/31;
        if(ln2 == 0){
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
            tmpC00 = tmpCmy.Cyn;
            tmpM00 = tmpCmy.Mgt;
            tmpY00 = tmpCmy.Yel;
            tmpK00 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
            tmpC01 = tmpCmy.Cyn;
            tmpM01 = tmpCmy.Mgt;
            tmpY01 = tmpCmy.Yel;
            tmpK01 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
            tmpC02 = tmpCmy.Cyn;
            tmpM02 = tmpCmy.Mgt;
            tmpY02 = tmpCmy.Yel;
            tmpK02 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
            tmpC03 = tmpCmy.Cyn;
            tmpM03 = tmpCmy.Mgt;
            tmpY03 = tmpCmy.Yel;
            tmpK03 = tmpCmy.Bla;
        }else{
            ln1 = tmpR02*255/31 - tmpRed;
            if(ln1 == 0){
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 = tmpCmy.Cyn;
                tmpM00 = tmpCmy.Mgt;
                tmpY00 = tmpCmy.Yel;
                tmpK00 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01 = tmpCmy.Cyn;
                tmpM01 = tmpCmy.Mgt;
                tmpY01 = tmpCmy.Yel;
                tmpK01 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02 = tmpCmy.Cyn;
                tmpM02 = tmpCmy.Mgt;
                tmpY02 = tmpCmy.Yel;
                tmpK02 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03 = tmpCmy.Cyn;
                tmpM03 = tmpCmy.Mgt;
                tmpY03 = tmpCmy.Yel;
                tmpK03 = tmpCmy.Bla;
            }else{
                ln3 = ln1 + ln2;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 = ln1 * tmpCmy.Cyn;
                tmpM00 = ln1 * tmpCmy.Mgt;
                tmpY00 = ln1 * tmpCmy.Yel;
                tmpK00 = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 += ln2 * tmpCmy.Cyn;
                tmpM00 += ln2 * tmpCmy.Mgt;
                tmpY00 += ln2 * tmpCmy.Yel;
                tmpK00 += ln2 * tmpCmy.Bla;
                tmpC00 /= ln3;
                tmpM00 /= ln3;
                tmpY00 /= ln3;
                tmpK00 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01  = ln1 * tmpCmy.Cyn;
                tmpM01  = ln1 * tmpCmy.Mgt;
                tmpY01  = ln1 * tmpCmy.Yel;
                tmpK01  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01 += ln2 * tmpCmy.Cyn;
                tmpM01 += ln2 * tmpCmy.Mgt;
                tmpY01 += ln2 * tmpCmy.Yel;
                tmpK01 += ln2 * tmpCmy.Bla;
                tmpC01 /= ln3;
                tmpM01 /= ln3;
                tmpY01 /= ln3;
                tmpK01 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02  = ln1 * tmpCmy.Cyn;
                tmpM02  = ln1 * tmpCmy.Mgt;
                tmpY02  = ln1 * tmpCmy.Yel;
                tmpK02  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02 += ln2 * tmpCmy.Cyn;
                tmpM02 += ln2 * tmpCmy.Mgt;
                tmpY02 += ln2 * tmpCmy.Yel;
                tmpK02 += ln2 * tmpCmy.Bla;
                tmpC02 /= ln3;
                tmpM02 /= ln3;
                tmpY02 /= ln3;
                tmpK02 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03  = ln1 * tmpCmy.Cyn;
                tmpM03  = ln1 * tmpCmy.Mgt;
                tmpY03  = ln1 * tmpCmy.Yel;
                tmpK03  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03 += ln2 * tmpCmy.Cyn;
                tmpM03 += ln2 * tmpCmy.Mgt;
                tmpY03 += ln2 * tmpCmy.Yel;
                tmpK03 += ln2 * tmpCmy.Bla;
                tmpC03 /= ln3;
                tmpM03 /= ln3;
                tmpY03 /= ln3;
                tmpK03 /= ln3;
            }
        }


        ln2 = tmpGrn - tmpG01*255/31;
        if(ln2 != 0){
            ln1 = tmpG02*255/31 - tmpGrn;
            if(ln1 == 0){
                tmpC00 = tmpC02;
                tmpM00 = tmpM02;
                tmpY00 = tmpY02;
                tmpK00 = tmpK02;
                tmpC01 = tmpC03;
                tmpM01 = tmpM03;
                tmpY01 = tmpY03;
                tmpK01 = tmpK03;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC02) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM02) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY02) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK02) / ln3;
                tmpC01 = (ln1*tmpC01 + ln2*tmpC03) / ln3;
                tmpM01 = (ln1*tmpM01 + ln2*tmpM03) / ln3;
                tmpY01 = (ln1*tmpY01 + ln2*tmpY03) / ln3;
                tmpK01 = (ln1*tmpK01 + ln2*tmpK03) / ln3;
            }
        }


        ln2 = tmpBlu - tmpB01*255/31;
        if(ln2 != 0){
            ln1 = tmpB02*255/31 - tmpBlu;
            if(ln1 == 0){
                tmpC00 = tmpC01;
                tmpM00 = tmpM01;
                tmpY00 = tmpY01;
                tmpK00 = tmpK01;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC01) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM01) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY01) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK01) / ln3;
            }
        }

        tmpCmy.Cyn  = innTblCmy[tmpC00];
        tmpCmy.Mgt  = innTblCmy[tmpM00];
        tmpCmy.Yel  = innTblCmy[tmpY00];
        tmpCmy.Bla  = innTblCmy[tmpK00];
        *cmyAdr = tmpCmy;
        cmyAdr++;

        CchRgb[cch] = tmpRgb;
        CchCmy[cch] = tmpCmy;
    }
}


//===================================================================================================
//    RGB -> CMYK Conversion(No matching)
//===================================================================================================
VOID WINAPI N4ColCnvSld(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    BYTE           red;
    BYTE           grn;
    BYTE           blu;
    BYTE           cyn;
    BYTE           mgt;
    BYTE           yel;
    BYTE           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        if((red == 0)&&(grn == 0)&&(blu == 0)){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
        } else {
            cyn = 255 - red;
            mgt = 255 - grn;
            yel = 255 - blu;
            if(cyn > mgt){
                if(mgt > yel){
                    bla = yel / 4;
                }else{
                    bla = mgt / 4;
                }
            }else{
                if(cyn > yel){
                    bla = yel / 4;
                }else{
                    bla = cyn / 4;
                }
            }
            cyn -= bla;
            mgt -= bla;
            yel -= bla;
            if(innTblCmy != NULL){
                cmyAdr->Cyn = innTblCmy[GamTbl014[cyn]];
                cmyAdr->Mgt = innTblCmy[GamTbl014[mgt]];
                cmyAdr->Yel = innTblCmy[GamTbl014[yel]];
                cmyAdr->Bla = innTblCmy[bla];
            }else{
                cmyAdr->Cyn = GamTbl014[cyn];
                cmyAdr->Mgt = GamTbl014[mgt];
                cmyAdr->Yel = GamTbl014[yel];
                cmyAdr->Bla = bla;
            }
        }
    }
    return;
}


//===================================================================================================
//    RGB -> CMYK conversion
//===================================================================================================
VOID WINAPI N4ColCnvLin(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    WORD           red;
    WORD           grn;
    WORD           blu;
    WORD           mid;
    BYTE           cyn;
    BYTE           mgt;
    BYTE           yel;

    for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        mid = (red + grn + blu)/3;
        if(mid > 240){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 0;
        } else {
            cyn = 255;
            mgt = 255;
            yel = 255;
            mid += (255 - mid)/8;
            if(red > mid){ cyn = 0; }
            if(grn > mid){ mgt = 0; }
            if(blu > mid){ yel = 0; }
            if((cyn & mgt & yel)==255){
                cmyAdr->Cyn = 0;
                cmyAdr->Mgt = 0;
                cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
            } else {
                cmyAdr->Cyn = cyn;
                cmyAdr->Mgt = mgt;
                cmyAdr->Yel = yel;
                cmyAdr->Bla = 0;
            }
        }
    }
    return;
}


//===================================================================================================
//    RGB -> CMYK conversion (for monochrome)
//===================================================================================================
VOID WINAPI N4ColCnvMon(
    LPN4DIZINF     lpDiz,
    DWORD          diz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    LONG           red;
    LONG           grn;
    LONG           blu;
    LONG           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if (diz == N4_DIZ_SML) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 4; } else { bla += SinTbl[bla] / 24; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else if (diz == N4_DIZ_MID) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 8; } else { bla += SinTbl[bla] / 16; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else if (diz == N4_DIZ_RUG) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 32; } else { bla += SinTbl[bla] / 8; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 6; } else { bla += SinTbl[bla] / 24; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    }
    return;
}


//    End of N4DIZ.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\n403diz.c ===
//***************************************************************************************************
//    N403DIZ.C
//
//    Functions of dither and color matching (For N4-612 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "PDEV.H"
#include    "strsafe.h"         // Security-Code 2002.3.6

static    BYTE            InnTblCmy[256];
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta(cyan) ----*/
//const static BYTE        StrMgt002 = 16;
static BYTE        StrMgt002 = 16;
//const static BYTE        MgtTil302[4][4] = {
static BYTE        MgtTil302[4][4] = {
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 },
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 }
};
/*---- yellow ----*/
//const static BYTE        YelTil302[4][4] = {
static BYTE        YelTil302[4][4] = {
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 },
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 }
};
/*---- black ----*/
//const static BYTE        BlaTil302[4][4] = {
static BYTE        BlaTil302[4][4] = {
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 },
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 }
};
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta (cyan) ----*/
//const static BYTE        MgtTil304[5][5][3] = {
static BYTE        MgtTil304[5][5][3] = {
    { {27,37,47},{10,20,30},{ 0, 5,15},{58,68,73},{42,52,62} },
    { {59,69,74},{40,50,60},{25,35,45},{13,23,33},{ 3, 8,18} },
    { {14,24,34},{ 4, 9,19},{56,66,71},{43,53,63},{28,38,48} },
    { {44,54,64},{29,39,49},{11,21,31},{ 1, 6,16},{57,67,72} },
    { { 2, 7,17},{55,65,70},{41,51,61},{26,36,46},{12,22,32} }
};
/*---- yellow ----*/
//const static BYTE        YelTil304[4][4][3] = {
static BYTE        YelTil304[4][4][3] = {
    { {32,40,44},{ 8,16,24},{34,42,46},{10,18,26} },
    { { 0, 4,12},{20,28,36},{ 2, 6,14},{22,30,38} },
    { {35,43,47},{11,19,27},{33,41,45},{ 9,17,25} },
    { { 3, 7,15},{23,31,39},{ 1, 5,13},{21,29,37} }

};
/*---- black ----*/
//const static BYTE        BlaTil304[4][4][3] = {
static BYTE        BlaTil304[4][4][3] = {
    { { 0, 4,12},{20,28,36},{ 1, 5,13},{21,29,37} },
    { {32,40,44},{ 8,16,24},{33,41,45},{ 9,17,25} },
    { { 3, 7,15},{23,31,39},{ 2, 6,14},{22,30,38} },
    { {35,43,47},{11,19,27},{34,42,46},{10,18,26} }
};
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta(cyan) ----*/
//const static BYTE        MgtTil316[5][5] = {
static BYTE        MgtTil316[5][5] = {
    { 12,  5,  0, 23, 17 },
    { 24, 15, 10,  8,  3 },
    {  9,  4, 21, 18, 13 },
    { 19, 14,  6,  1, 22 },
    {  2, 20, 16, 11,  7 }
};
/*---- yellow ----*/
//const static BYTE        YelTil316[4][4] = {
static BYTE        YelTil316[4][4] = {
//    { 12,  4, 14,  6 },
//    {  0,  8,  2, 10 },
//    { 15,  7, 13,  5 },
//    {  3, 11,  1,  9 }
    {  6,  4, 15, 13 },
    { 10,  8,  3,  1 },
    { 14, 12,  7,  5 },
    {  2,  0, 11,  9 }
};
/*---- black ----*/
//const static BYTE        BlaTil316[4][4] = {
static BYTE        BlaTil316[4][4] = {
    {  0,  8,  1,  9 },
    { 12,  4, 13,  5 },
    {  3, 11,  2, 10 },
    { 15,  7, 14,  6 }
};
/*----------------------------------------------------------------------------
    Pattern original(600dpi)
----------------------------------------------------------------------------*/
/*---- cyan ----*/
//const static BYTE        CynTil600[10][10] = {
static BYTE        CynTil600[10][10] = {
    {  4, 24, 72, 57, 37, 77, 94, 99, 54,  9 },
    { 14, 44, 80, 85, 65, 25, 45, 60, 34, 19 },
    { 39, 79, 90, 95, 50,  5,  0, 20, 74, 59 },
    { 66, 26, 46, 61, 30, 15, 10, 40, 81, 86 },
    { 51,  6,  1, 21, 70, 55, 35, 75, 91, 96 },
    { 31, 16, 11, 41, 83, 88, 68, 28, 48, 63 },
    { 71, 56, 36, 76, 93, 98, 53,  8,  3, 23 },
    { 82, 87, 67, 27, 47, 62, 33, 18, 13, 43 },
    { 92, 97, 52,  7,  2, 22, 73, 58, 38, 78 },
    { 49, 64, 32, 17, 12, 42, 84, 89, 69, 29 }

};
/*---- magenta ----*/
//const static BYTE        MgtTil600[10][10] = {
static BYTE        MgtTil600[10][10] = {
    {  4, 54, 99, 94, 77, 37, 57, 72, 24,  9 },
    { 14, 34, 60, 45, 25, 65, 85, 80, 44, 19 },
    { 59, 74, 20,  5,  0, 50, 95, 90, 79, 39 },
    { 86, 81, 40, 15, 10, 30, 61, 46, 26, 66 },
    { 96, 91, 75, 35, 55, 70, 21,  6,  1, 51 },
    { 63, 48, 28, 68, 88, 83, 41, 16, 11, 31 },
    { 23,  8,  3, 53, 98, 93, 76, 36, 56, 71 },
    { 43, 18, 13, 33, 62, 47, 27, 67, 87, 82 },
    { 78, 38, 58, 73, 22,  7,  2, 52, 97, 92 },
    { 29, 69, 89, 84, 42, 17, 12, 32, 64, 49 }

};
/*---- yellow ----*/
//const static BYTE        YelTil600[6][6] = {
static BYTE        YelTil600[6][6] = {
//    {  5, 17, 35, 33, 21,  7 },
//    { 27,  8, 22, 14, 10, 19 },
//    { 30, 12,  2,  0, 24, 28 },
//    { 32, 20,  6,  4, 16, 34 },
//    { 15, 11, 18, 26,  9, 23 },
//    {  1, 25, 29, 31, 13,  3 }

    /* for smoothing */
    {  5, 13, 31, 29, 15,  7 },
    {  9, 21, 35, 33, 23, 11 },
    { 24, 16,  2,  0, 18, 26 },
    { 28, 14,  6,  4, 12, 30 },
    { 32, 22, 10,  8, 20, 34 },
    {  1, 19, 27, 25, 17,  3 }
};
/*---- black ----*/
//const static BYTE        BlaTil600[4][4] = {
static BYTE        BlaTil600[4][4] = {
    { 12,  9,  5, 13 },
    {  4,  1,  0, 10 },
    {  8,  3,  2,  6 },
    { 15,  7, 11, 14 }
};
/*----------------------------------------------------------------------------
    Pattern original(600dpi)
----------------------------------------------------------------------------*/
//const static BYTE DizPatPrn[4][64] = {
static BYTE DizPatPrn[4][64] = {
    /*---- cyan ----*/
    {  61, 45, 20, 12,  8, 28, 41, 57,
        1, 25, 36, 52, 48, 32, 17,  5,
        9, 29, 43, 59, 63, 47, 21, 13,
       49, 33, 19,  7,  3, 27, 37, 53,
       62, 46, 23, 15, 11, 31, 42, 58,
        2, 26, 39, 55, 51, 35, 18,  6,
       10, 30, 40, 56, 60, 44, 22, 14,
       50, 34, 16,  4,  0, 24, 38, 54    },
    /*---- magenta ----*/
    {  49, 13,  9, 61, 50, 14, 10, 62,
       33, 29, 25, 45, 34, 30, 26, 46,
       16, 40, 39, 23, 19, 43, 36, 20,
        0, 56, 55,  7,  3, 59, 52,  4,
        8, 60, 51, 15, 11, 63, 48, 12,
       24, 44, 35, 31, 27, 47, 32, 28,
       37, 21, 17, 41, 38, 22, 18, 42,
       53,  5,  1, 57, 54,  6,  2, 58    },
    /*---- yellow ----*/
    {  48, 36, 20, 52, 50, 38, 22, 54,
       16,  4,  0, 40, 18,  6,  2, 42,
       32, 12,  8, 24, 34, 14, 10, 26,
       60, 28, 44, 56, 62, 30, 46, 58,
       51, 39, 23, 55, 49, 37, 21, 53,
       19,  7,  3, 43, 17,  5,  1, 41,
       35, 15, 11, 27, 33, 13,  9, 25,
       63, 31, 47, 59, 61, 29, 45, 57    },
    /*---- black ----*/
    {   9, 25, 35, 15, 11, 27, 33, 13,
       45, 57, 63, 31, 47, 59, 61, 29,
       22, 54, 48, 36, 20, 52, 50, 38,
        2, 42, 16,  4,  0, 40, 18,  6,
       10, 26, 32, 12,  8, 24, 34, 14,
       46, 58, 60, 28, 44, 56, 62, 30,
       21, 53, 51, 39, 23, 55, 49, 37,
        1, 41, 19,  7,  3, 43, 17,  5    }
};
/*----------------------------------------------------------------------------
    Pattern original(monochrome)
----------------------------------------------------------------------------*/
//const static BYTE        Mon4x4Bun[8 * 8] = {
static BYTE        Mon4x4Bun[8 * 8] = {
     0,    32,     8,    40,     2,    34,    10,    42,
    48,    16,    56,    24,    50,    18,    58,    26,
    12,    44,     4,    36,    14,    46,     6,    38,
    60,    28,    52,    20,    62,    30,    54,    22,
     3,    35,    11,    43,     1,    33,     9,    41,
    51,    19,    59,    27,    49,    17,    57,    25,
    15,    47,     7,    39,    13,    45,     5,    37,
    63,    31,    55,    23,    61,    29,    53,    21
};
//const static BYTE        Mon4x4Ami[8 * 8] = {
static BYTE        Mon4x4Ami[8 * 8] = {
     8,  0, 56, 48, 10,  2, 58, 50,
    40, 32, 28, 20, 42, 34, 30, 22,
    60, 52, 12,  4, 62, 54, 14,  6,
    24, 16, 44, 36, 26, 18, 46, 38,
    11,  3, 59, 51,  9,  1, 57, 49,
    43, 35, 31, 23, 41, 33, 29, 21,
    63, 55, 15,  7, 61, 53, 13,  5,
    27, 19, 47, 39, 25, 17, 45, 37
};
//const static BYTE        Mon4x4Syu[8 * 8] = {
static BYTE        Mon4x4Syu[8 * 8] = {
    48, 36, 20, 52, 50, 38, 22, 54,
    16,  4,  0, 40, 18,  6,  2, 42,
    32, 12,  8, 24, 34, 14, 10, 26,
    60, 28, 44, 56, 62, 30, 46, 58,
    51, 39, 23, 55, 49, 37, 21, 53,
    19,  7,  3, 43, 17,  5,  1, 41,
    35, 15, 11, 27, 33, 13,  9, 25,
    63, 31, 47, 59, 61, 29, 45, 57
};
//const static BYTE        Mon8x8Ami[8 * 8] = {
static BYTE        Mon8x8Ami[8 * 8] = {
     7, 13, 39, 59, 58, 43, 17,  5,
    23, 31, 49, 44, 36, 50, 25, 15,
    41, 52, 26, 18, 10, 28, 53, 33,
    61, 34,  8,  2,  0, 20, 46, 60,
    62, 42, 16,  6,  4, 12, 38, 63,
    37, 55, 24, 14, 22, 30, 54, 45,
    11, 29, 48, 32, 40, 51, 27, 19,
     3, 21, 47, 56, 57, 35,  9,  1
};
//const static BYTE        Mon8x8Syu[8 * 8] = {
static BYTE        Mon8x8Syu[8 * 8] = {
    60, 57, 49, 34, 33, 45, 53, 61,
    52, 40, 29, 21, 17, 25, 41, 58,
    44, 24, 12,  9,  5, 13, 30, 50,
    32, 16,  4,  1,  0, 10, 22, 38,
    36, 20,  8,  3,  2,  6, 18, 34,
    48, 28, 15,  7, 11, 14, 26, 46,
    56, 43, 27, 19, 23, 31, 42, 54,
    63, 55, 47, 35, 39, 51, 59, 62
};
/*----------------------------------------------------------------------------
    pattern disposition table
----------------------------------------------------------------------------*/
//const static BYTE    MgtTilNum[17] = {
static BYTE    MgtTilNum[17] = {
    2, 11, 13, 4, 15, 6, 3, 12, 1, 10, 16, 7, 14, 5, 8, 0, 9
};
//const static BYTE Bun6x6All[36] = {
static BYTE Bun6x6All[36] = {
      0, 32,  8,  2, 34, 10,
     20, 16, 28, 22, 18, 30,
     12, 24,  4, 14, 26,  6,
      3, 35, 11,  1, 33,  9,
     23, 19, 31, 21, 17, 29,
     15, 27,  7, 13, 25,  5
};
//const static BYTE Bun4x4All[16] = {
static BYTE Bun4x4All[16] = {
      0,  8,  2, 10,
     12,  4, 14 , 6,
      3, 11,  1,  9,
     15,  7, 13,  5
};
//const static BYTE Bun3x3All[9] = {
static BYTE Bun3x3All[9] = {
      8,  3,  6,
      2,  4,  0,
      5,  1,  7
};
//const static BYTE Bun2x2All[4] = {
static BYTE Bun2x2All[4] = {
      0,  2,
      3,  1
};


/*============================================================================
    dot gain revision table
============================================================================*/
//const static BYTE GinTblP05[256] = {
static BYTE GinTblP05[256] = {
    /* 00 */    0x00,0x01,0x02,0x03,0x04,0x06,0x07,0x08,
    /* 08 */    0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x11,
    /* 10 */    0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
    /* 18 */    0x1a,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,
    /* 20 */    0x23,0x24,0x25,0x27,0x28,0x29,0x2a,0x2b,
    /* 28 */    0x2c,0x2d,0x2e,0x2f,0x30,0x32,0x33,0x34,
    /* 30 */    0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,
    /* 38 */    0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
    /* 40 */    0x46,0x47,0x48,0x4a,0x4b,0x4c,0x4d,0x4e,
    /* 48 */    0x4f,0x50,0x51,0x52,0x53,0x54,0x56,0x57,
    /* 50 */    0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    /* 58 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 60 */    0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
    /* 68 */    0x71,0x72,0x73,0x74,0x76,0x77,0x78,0x79,
    /* 70 */    0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,
    /* 78 */    0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    /* 80 */    0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,
    /* 88 */    0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,
    /* 90 */    0x9a,0x9b,0x9c,0x9c,0x9d,0x9e,0x9f,0xa0,
    /* 98 */    0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,
    /* a0 */    0xa9,0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,
    /* a8 */    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* b0 */    0xb8,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b8 */    0xbf,0xc0,0xc1,0xc2,0xc3,0xc3,0xc4,0xc5,
    /* c0 */    0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,
    /* c8 */    0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,
    /* d0 */    0xd5,0xd6,0xd7,0xd7,0xd8,0xd9,0xda,0xdb,
    /* d8 */    0xdc,0xdd,0xde,0xdf,0xe0,0xe0,0xe1,0xe2,
    /* e0 */    0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xe9,
    /* e8 */    0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,
    /* f0 */    0xf2,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    /* f8 */    0xf9,0xfa,0xfb,0xfb,0xfc,0xfd,0xfe,0xff
};
//const static BYTE GinTblP10[256] = {
static BYTE GinTblP10[256] = {
    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
};
//const static BYTE GinTblP15[256] = {
static BYTE GinTblP15[256] = {
    /* 00 */    0x00,0x01,0x03,0x04,0x05,0x07,0x08,0x09,
    /* 08 */    0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x13,0x14,
    /* 10 */    0x15,0x17,0x18,0x1a,0x1b,0x1c,0x1e,0x1f,
    /* 18 */    0x20,0x22,0x23,0x24,0x26,0x27,0x28,0x2a,
    /* 20 */    0x2b,0x2c,0x2e,0x2f,0x30,0x32,0x33,0x34,
    /* 28 */    0x35,0x37,0x38,0x39,0x3b,0x3c,0x3d,0x3f,
    /* 30 */    0x40,0x41,0x43,0x44,0x45,0x47,0x48,0x49,
    /* 38 */    0x4a,0x4c,0x4d,0x4e,0x50,0x51,0x52,0x53,
    /* 40 */    0x55,0x56,0x57,0x59,0x5a,0x5b,0x5c,0x5e,
    /* 48 */    0x5f,0x60,0x61,0x63,0x64,0x65,0x66,0x68,
    /* 50 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 58 */    0x73,0x74,0x75,0x76,0x77,0x79,0x7a,0x7b,
    /* 60 */    0x7c,0x7d,0x7e,0x80,0x81,0x82,0x83,0x84,
    /* 68 */    0x85,0x86,0x88,0x89,0x8a,0x8b,0x8c,0x8d,
    /* 70 */    0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
    /* 78 */    0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,
    /* 80 */    0x9e,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,
    /* 88 */    0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,
    /* 90 */    0xab,0xac,0xad,0xae,0xaf,0xb0,0xb0,0xb1,
    /* 98 */    0xb2,0xb3,0xb4,0xb4,0xb5,0xb6,0xb7,0xb8,
    /* a0 */    0xb8,0xb9,0xba,0xbb,0xbc,0xbc,0xbd,0xbe,
    /* a8 */    0xbf,0xbf,0xc0,0xc1,0xc2,0xc3,0xc3,0xc4,
    /* b0 */    0xc5,0xc6,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,
    /* b8 */    0xcb,0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd0,
    /* c0 */    0xd1,0xd2,0xd3,0xd3,0xd4,0xd5,0xd5,0xd6,
    /* c8 */    0xd7,0xd8,0xd8,0xd9,0xda,0xdb,0xdb,0xdc,
    /* d0 */    0xdd,0xde,0xde,0xdf,0xe0,0xe1,0xe1,0xe2,
    /* d8 */    0xe3,0xe3,0xe4,0xe5,0xe6,0xe6,0xe7,0xe8,
    /* e0 */    0xe9,0xe9,0xea,0xeb,0xeb,0xec,0xed,0xee,
    /* e8 */    0xee,0xef,0xf0,0xf1,0xf1,0xf2,0xf3,0xf3,
    /* f0 */    0xf4,0xf5,0xf6,0xf6,0xf7,0xf8,0xf9,0xf9,
    /* f8 */    0xfa,0xfb,0xfb,0xfc,0xfd,0xfe,0xfe,0xff
};


static void DizMak302(LPN403DIZINF, DWORD);
static void DizMak304(LPN403DIZINF, DWORD);
static void DizMak316(LPN403DIZINF, DWORD);
static void DizMak602(LPN403DIZINF, DWORD);
static void DizMak604(LPN403DIZINF, DWORD);
static void DizMakSmlPrn(LPN403DIZINF, DWORD);
static void DizMakMon002(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static void DizMakMon004(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static void DizMakMon016(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);


/*****************************************************************************
    Function
*****************************************************************************/
//===================================================================================================
//    Make dither pattern
//===================================================================================================
VOID WINAPI N403DizPtnMak(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    DWORD          diz
)
{
    if(lpDiz->ColMon == N403_COL){
        /*---- Color ----*/
        if(lpDiz->PrnMod == N403_MOD_300B1){        DizMak302(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_300B2){    DizMak304(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_300B4){    DizMak316(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_600B1){    DizMak602(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_600B2){
            if(diz == N403_DIZ_MID){        DizMak604(lpDiz, dizNum);
            }else if(diz == N403_DIZ_SML){    DizMakSmlPrn(lpDiz, dizNum);
            }
        }
    }else{
        /*---- Mono ----*/
        if(lpDiz->PrnMod == N403_MOD_300B1){
            if(diz == N403_DIZ_MID){        DizMakMon002(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 0, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon002(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 0, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon002(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_300B2){
            if(diz == N403_DIZ_MID){        DizMakMon004(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 6, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon004(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 12, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon004(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_300B4){
            if(diz == N403_DIZ_MID){        DizMakMon016(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 6, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon016(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 24, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon016(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_600B1){
            if(diz == N403_DIZ_MID){        DizMakMon002(lpDiz, dizNum, Mon8x8Ami, GinTblP05, 8, 32);
            }else if(diz == N403_DIZ_SML){    DizMakMon002(lpDiz, dizNum, Mon4x4Syu, GinTblP10, 16, 64);
            }else if(diz == N403_DIZ_RUG){    DizMakMon002(lpDiz, dizNum, Mon8x8Syu, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_600B2){
            if(diz == N403_DIZ_MID){        DizMakMon004(lpDiz, dizNum, Mon8x8Ami, GinTblP05, 8, 32);
            }else if(diz == N403_DIZ_SML){    DizMakMon004(lpDiz, dizNum, Mon4x4Syu, GinTblP10, 16, 64);
            }else if(diz == N403_DIZ_RUG){    DizMakMon004(lpDiz, dizNum, Mon8x8Syu, NULL,      0, 0);
            }
        }
    }
}


/*----------------------------------------------------------------------------
    @300dpi  2value
----------------------------------------------------------------------------*/
static void DizMak302(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntTil;
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LONG           strXax;
    LONG           strYax;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;

    DizTblC02 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM02 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY02 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 17;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 24;

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 0){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 0)*128/(128 - 0);
        }else if(num < (255 - 28)){
            num255 = 128 + (num - 128)*128/(128 - 28);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    strXax = 6;
    strYax = -1;
    for(cntTil = 0; cntTil < 17; cntTil++){
        strXax += 4;    strYax += 1;
        num = (DWORD)StrMgt002 * 17 + MgtTilNum[cntTil];
        num255 = num * 255 / (17 * 17 - 1);
        if(num255){
            num = num * GinTblP05[num255] / num255;
            num255 = num * 255 / (17 * 17 - 1);
            if(num255){
                num = num * InnTblCmy[num255]/num255;
                num255 = num * 255 / (17 * 17 - 1);
            }
        }
        if(num255 > 254){ num255 = 254; }
        DizTblM02[(strYax % 17) * 32 + (strXax % 17)] = (BYTE)num255;
        DizTblC02[(strYax % 17) * 32 + (16 - strXax % 17)] = (BYTE)num255;
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)MgtTil302[cntYax][cntXax] * 17;
                num += MgtTilNum[cntTil];
                num255 = num * 255 / (17 * 17 - 1);
                if(num255){
                    num = num * GinTblP05[num255] / num255;
                    num255 = num * 255 / (17 * 17 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (17 * 17 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblM02[((strYax + cntYax + 1) % 17) * 32 + ((strXax + cntXax) % 17)] = (BYTE)num255;
                DizTblC02[(strYax + cntYax + 1) % 17 * 32 + (16 - ((strXax + cntXax) % 17))] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntTil = 0; cntTil < 36; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)YelTil302[cntYax][cntXax] * 36;
                num += Bun6x6All[cntTil];
                num255 = num * 255 / (24 * 24 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (24 * 24 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (24 * 24 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblY02[((cntTil/6)*4 + cntYax) * 32 + ((cntTil%6)*4 + cntXax)] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntTil = 0; cntTil < 36; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)BlaTil302[cntYax][cntXax] * 36;
                num += Bun6x6All[cntTil];
                num255 = num * 255 / (24 * 24 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (24 * 24 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (24 * 24 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB02[((cntTil/6)*4 + cntYax) * 32 + ((cntTil%6)*4 + cntXax)] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    A300dpi  4value
----------------------------------------------------------------------------*/
static void DizMak304(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntTil;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;

    DizTblC04 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM04 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY04 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 10;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 12;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 20){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 20)*128/(128 - 20);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    for(cntTil = 0; cntTil < 4; cntTil++){
        for(cntYax = 0; cntYax < 5; cntYax++){
            for(cntXax = 0; cntXax < 5; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)MgtTil304[cntYax][cntXax][cnt] * 4;
                    num += Bun2x2All[cntTil];
                    num255 = num * 255 / (10 * 10 * 3 - 1);
                    if(num255){
                        num = num * GinTblP10[num255] / num255;
                        num255 = num * 255 / (10 * 10 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (10 * 10 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblM04[((cntTil / 2) * 5 + cntYax) * 16 * 3 +
                              ((cntTil % 2) * 5 + cntXax) * 3 + cnt] = (BYTE)num255;
                    DizTblC04[((cntTil / 2) * 5 + cntYax) * 16 * 3 +
                              (9 - ((cntTil % 2) * 5 + cntXax)) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntTil = 0; cntTil < 9; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)YelTil304[cntYax][cntXax][cnt] * 9;
                    num += Bun3x3All[cntTil];
                    num255 = num * 255 / (12 * 12 * 3 - 1);
                    if(num255){
                        num = num * GinTblP15[num255] / num255;
                        num255 = num * 255 / (12 * 12 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (12 * 12 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblY04[((cntTil / 3) * 4 + cntYax) * 16 * 3 +
                              ((cntTil % 3) * 4 + cntXax) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntTil = 0; cntTil < 9; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)BlaTil304[cntYax][cntXax][cnt] * 9;
                    num = ((num/4)*4*3 + num%4 + cnt*4)*9;
                    num += Bun3x3All[cntTil];
                    num255 = num * 255 / (12 * 12 * 3 - 1);
                    if(num255){
                        num = num * GinTblP15[num255] / num255;
                        num255 = num * 255 / (12 * 12 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (12 * 12 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblB04[((cntTil / 3) * 4 + cntYax) * 16 * 3 +
                              ((cntTil % 3) * 4 + cntXax) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
}


/*----------------------------------------------------------------------------
    B300dpi  16value
----------------------------------------------------------------------------*/
static void DizMak316(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC16;
    LPBYTE         DizTblM16;
    LPBYTE         DizTblY16;
    LPBYTE         DizTblB16;

    DizTblC16 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM16 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY16 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB16 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 5;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 4;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 20){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 20)*128/(128 - 20);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    for(cntYax = 0; cntYax < 5; cntYax++){
        for(cntXax = 0; cntXax < 5; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)MgtTil316[cntYax][cntXax] / 5) * 5 * 15;
                num += cnt * 5 + MgtTil316[cntYax][cntXax] % 5;
                num255 = num * 255 / (5 * 5 * 15 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (5 * 5 * 15 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (5 * 5 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblM16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
                DizTblC16[cntYax * 8 * 15 + (4-cntXax) * 15 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 4; cntYax++){
        for(cntXax = 0; cntXax < 4; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)YelTil316[cntYax][cntXax] / 4 * 4) * 15;
                num += cnt * 4 + YelTil316[cntYax][cntXax] % 4;
                num255 = num * 255 / (4 * 4 * 15 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (4 * 4 * 15 - 1);
                    if(num255 > 128){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (4 * 4 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblY16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 4; cntYax++){
        for(cntXax = 0; cntXax < 4; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)BlaTil316[cntYax][cntXax] / 4 * 4) * 15;
                num += cnt * 4 + BlaTil316[cntYax][cntXax] % 4;
                num255 = num * 255 / (4 * 4 * 15 - 1);
                if(num255){
                    num = num * GinTblP15[num255] / num255;
                    num255 = num * 255 / (4 * 4 * 15 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (4 * 4 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    C600dpi  2value
----------------------------------------------------------------------------*/
static void DizMak602(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;

    DizTblC02 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM02 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY02 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 20;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 24;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 24){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 24)*128/(128 - 24);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make cyan pattern ----*/
    for(cntYax = 0; cntYax < 20; cntYax++){
        for(cntXax = 0; cntXax < 20; cntXax++){
            num = (LONG)CynTil600[cntYax%10][cntXax%10];
            num = num*4 + Bun2x2All[(cntYax/10)*2 + cntXax/10];
            num255 = num * 255 / (20*20-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (20*20-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (20*20-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblC02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0; cntYax < 20; cntYax++){
        for(cntXax = 0; cntXax < 20; cntXax++){
            num = (LONG)MgtTil600[cntYax%10][cntXax%10];
            num = num*4 + Bun2x2All[(cntYax/10)*2 + cntXax/10];
            num255 = num * 255 / (20*20-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (20*20-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (20*20-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblM02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 24; cntYax++){
        for(cntXax = 0; cntXax < 24; cntXax++){
            num = (LONG)YelTil600[cntYax%6][cntXax%6];
            num = num*16 + Bun4x4All[(cntYax/6)*4 + cntXax/6];
            num255 = num * 255 / (24*24-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (24*24-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (24*24-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblY02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 24; cntYax++){
        for(cntXax = 0; cntXax < 24; cntXax++){
            num = (LONG)BlaTil600[cntYax%4][cntXax%4];
            num = num*36 + Bun6x6All[(cntYax/4)*6 + cntXax/4];
            num255 = num * 255 / (24*24-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (24*24-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (24*24-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblB02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
}


/*----------------------------------------------------------------------------
    D600dpi  4value
----------------------------------------------------------------------------*/
static void DizMak604(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LONG           tmpNum;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;

    DizTblC04 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM04 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY04 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 10;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 12;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 24){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 24)*128/(128 - 24);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make cyan pattern ----*/
    for(cntYax = 0; cntYax < 10; cntYax++){
        for(cntXax = 0; cntXax < 10; cntXax++){
            num = (LONG)CynTil600[cntYax][cntXax];
            num = (num/5)*5*3 + num%5;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = num + cnt*5;
                num255 = tmpNum * 255 / (10*10*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (10*10*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (10*10*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblC04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0; cntYax < 10; cntYax++){
        for(cntXax = 0; cntXax < 10; cntXax++){
            num = (LONG)MgtTil600[cntYax][cntXax];
            num = (num/5)*5*3 + num%5;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = num + cnt*5;
                num255 = tmpNum * 255 / (10*10*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (10*10*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (10*10*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblM04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 12; cntYax++){
        for(cntXax = 0; cntXax < 12; cntXax++){
            num = (LONG)YelTil600[cntYax%6][cntXax%6] * 3;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = (num + cnt)*4 + Bun2x2All[(cntYax/6)*2 + cntXax/6];
                num255 = tmpNum * 255 / (12*12*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (12*12*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (12*12*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblY04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 12; cntYax++){
        for(cntXax = 0; cntXax < 12; cntXax++){
            num = (LONG)BlaTil600[cntYax%4][cntXax%4] * 3;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = (num + cnt)*9 + Bun3x3All[(cntYax/4)*3 + cntXax/4];
                num255 = tmpNum * 255 / (12*12*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (12*12*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (12*12*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblB04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    E600dpi 4value DETAIL
----------------------------------------------------------------------------*/
static void DizMakSmlPrn(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblSml;
    LPBYTE         DizTblPc4;
    LPBYTE         DizTblPm4;
    LPBYTE         DizTblPy4;
    LPBYTE         DizTblPb4;

    DizTblSml = lpDiz->Diz.Tbl[dizNum][0];
    DizTblPc4 = lpDiz->EntDiz.Tbl[0];
    DizTblPm4 = lpDiz->EntDiz.Tbl[1];
    DizTblPy4 = lpDiz->EntDiz.Tbl[2];
    DizTblPb4 = lpDiz->EntDiz.Tbl[3];

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 64){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 64)*128/(128 - 64);
        }else if(num < (255 - 48)){
            num255 = 128 + (num - 128)*128/(128 - 48);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make magenta pattern ----*/
    /*---- Make cyan pattern ----*/
    /*---- Make yellow pattern ----*/
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 16; cntYax++){
        for(cntXax = 0; cntXax < 16; cntXax++){
            for(cnt = 0; cnt < 3; cnt++){
                num = BlaTil302[cntYax%4][cntXax%4] * 3 + cnt;
                num = num * 16 + Bun4x4All[cntYax/4*4 + cntXax/4];
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP15[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblSml[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 32){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 32)*128/(128 - 32);
        }else if(num < (255 - 44)){
            num255 = 128 + (num - 128)*128/(128 - 44);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make cyan pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[0][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPc4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[1][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPm4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[2][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPy4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[3][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPb4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    7 Monochrome  2value
----------------------------------------------------------------------------*/
static void DizMakMon002(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB02;

// Check of zero divide 2002.3.23 >>>
    if ((minCut < 0) || (128 <= minCut)) {
        ERR(("DizMakMon002() 0Div-Check [minCut=%d] \n",minCut));
        return;
    }
    if ((maxCut < 0) || (128 <= maxCut)) {
        ERR(("DizMakMon002() 0Div-Check [maxCut=%d] \n",maxCut));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 32;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 32;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 32; cntYax++){
        for(cntXax = 0; cntXax < 32; cntXax++){
            num = (LONG)tilTbl[cntYax%8*8 + cntXax%8];
            num = num * 16 + Bun4x4All[cntYax/8*4 + cntXax/8];
            num255 = num * 255 / (32*32 - 1);
            if(num255){
                if(ginTbl != NULL){
                    num = num * ginTbl[num255] / num255;
                    num255 = num * 255 / (32*32 - 1);
                }
                if(num255){
                    num = num * InnTblCmy[num255]/num255;
                    num255 = num * 255 / (32*32 - 1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblB02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
}


/*----------------------------------------------------------------------------
    GMonochrome 4value
----------------------------------------------------------------------------*/
static void DizMakMon004(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB04;

// Check of zero divide 2002.3.23 >>>
    if ((minCut < 0) || (128 <= minCut)) {
        ERR(("DizMakMon004() 0Div-Check [minCut=%d] \n",minCut));
        return;
    }
    if ((maxCut < 0) || (128 <= maxCut)) {
        ERR(("DizMakMon004() 0Div-Check [maxCut=%d] \n",maxCut));
        return;
    }
// Check of zero divide 2002.3.23 <<<
    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 16;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 16;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 16; cntYax++){
        for(cntXax = 0; cntXax < 16; cntXax++){
            for(cnt = 0; cnt < 3; cnt++){
                num = (LONG)tilTbl[cntYax%8*8 + cntXax%8] * 3 + cnt;
                num = num * 4 + Bun2x2All[cntYax/8*2 + cntXax/8];
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    if(ginTbl != NULL){
                        num = num * ginTbl[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    Hmonochrome 16value
----------------------------------------------------------------------------*/
static void DizMakMon016(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB16;

// Check of zero divide 2002.3.23 >>>
    if ((minCut < 0) || (128 <= minCut)) {
        ERR(("DizMakMon016() 0Div-Check [minCut=%d] \n",minCut));
        return;
    }
    if ((maxCut < 0) || (128 <= maxCut)) {
        ERR(("DizMakMon016() 0Div-Check [maxCut=%d] \n",maxCut));
        return;
    }
// Check of zero divide 2002.3.23 <<<
    DizTblB16 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 8;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 8;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 8; cntYax++){
        for(cntXax = 0; cntXax < 8; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = tilTbl[cntYax*8 + cntXax];
                num = num / 8 * 8 * 15 + cnt * 8 + num % 8;
                num255 = num * 255 / (8*8*15 - 1);
                if(num255){
                    if(ginTbl != NULL){
                        num = num * ginTbl[num255] / num255;
                        num255 = num * 255 / (8*8*15 - 1);
                    }
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (8*8*15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }
}


//===================================================================================================
//    Make toner density control table
//===================================================================================================
VOID WINAPI N403TnrTblMak(
    LPN403DIZINF   lpDiz,
    LONG           tnrDns
)
{
    LONG           innNum;
    LONG           outNum;
    LPBYTE         innTblCmy;

    tnrDns *= 2;
    innTblCmy = lpDiz->Tnr.Tbl;
    /*---- Make CMYK conversion table ----*/
    if(tnrDns < 0){
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 255){    outNum = 255;
            }else{                outNum = innNum * (255 + tnrDns) / 255;
            }
            innTblCmy[innNum] = (BYTE)outNum;
        }
    }else{
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 0){    outNum = 0;
            }else{                outNum = (innNum + tnrDns) * 255 / (255 + tnrDns);
            }
            innTblCmy[innNum] = (BYTE)outNum;
        }
    }
}


//===================================================================================================
//    Dithering(2 value)
//===================================================================================================
DWORD WINAPI N403Diz002(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;
    LPBYTE         dizTblC02;
    LPBYTE         dizTblM02;
    LPBYTE         dizTblY02;
    LPBYTE         dizTblB02;
    CMYK           tmpCmy;
    BYTE           tmpByt;

    DizTblC02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];

// Check of zero divide 2002.3.23 >>>
    if ((DizSizCyn == 0) || (DizSizMgt == 0)||
        (DizSizYel == 0) || (DizSizBla == 0)) {
        ERR(("N403Diz002() 0Div-Check [DizSizCyn,Mgt,Yel,Bla=0] \n"));
        return 0;
    }
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N403Diz002() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC02 = DizTblC02 + strYax % DizSizCyn * 32;
        dizTblM02 = DizTblM02 + strYax % DizSizMgt * 32;
        dizTblY02 = DizTblY02 + strYax % DizSizYel * 32;
        dizTblB02 = DizTblB02 + strYax % DizSizBla * 32;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
            tmpBuf = cntHrz / 8;
            if(tmpCmy.Cyn){
                if (tmpCmy.Cyn > dizTblC02[strXax % DizSizCyn]) {
                    linBufCyn[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Mgt){
                if (tmpCmy.Mgt > dizTblM02[strXax % DizSizMgt]) {
                    linBufMgt[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Yel){
                if (tmpCmy.Yel > dizTblY02[strXax % DizSizYel]) {
                    linBufYel[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Bla){
                if (tmpCmy.Bla > dizTblB02[strXax % DizSizBla]) {
                    linBufBla[tmpBuf] |= tmpByt;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC02 = DizTblC02 + strYax % DizSizCyn * 32;
        dizTblM02 = DizTblM02 + strYax % DizSizMgt * 32;
        dizTblY02 = DizTblY02 + strYax % DizSizYel * 32;
        dizTblB02 = DizTblB02 + strYax % DizSizBla * 32;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                if(tmpCmy.Cyn){
                    if (tmpCmy.Cyn > dizTblC02[(strXax + tmpXax) % DizSizCyn]) {
                        linBufCyn[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Mgt){
                    if (tmpCmy.Mgt > dizTblM02[(strXax + tmpXax) % DizSizMgt]) {
                        linBufMgt[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Yel){
                    if (tmpCmy.Yel > dizTblY02[(strXax + tmpXax) % DizSizYel]) {
                        linBufYel[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Bla){
                    if (tmpCmy.Bla > dizTblB02[(strXax + tmpXax) % DizSizBla]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(4value)
//===================================================================================================
DWORD WINAPI N403Diz004(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;
    LPBYTE         dizTblC04;
    LPBYTE         dizTblM04;
    LPBYTE         dizTblY04;
    LPBYTE         dizTblB04;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblC04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];

// Check of zero divide 2002.3.23 >>>
    if ((DizSizCyn == 0) || (DizSizMgt == 0)||
        (DizSizYel == 0) || (DizSizBla == 0)) {
        ERR(("N403Diz004() 0Div-Check [DizSizCyn,Mgt,Yel,Bla=0] \n"));
        return 0;
    }
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N403Diz004() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC04 = DizTblC04 + strYax % DizSizCyn * 16 * 3;
        dizTblM04 = DizTblM04 + strYax % DizSizMgt * 16 * 3;
        dizTblY04 = DizTblY04 + strYax % DizSizYel * 16 * 3;
        dizTblB04 = DizTblB04 + strYax % DizSizBla * 16 * 3;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            if(tmpCmy.Cyn){
                dizTbl = dizTblC04 + strXax % DizSizCyn * 3;
                if (tmpCmy.Cyn > dizTbl[0]) {
                    if (tmpCmy.Cyn > dizTbl[2]) {
                        linBufCyn[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Cyn > dizTbl[1]) {
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt){
                dizTbl = dizTblM04 + strXax % DizSizMgt * 3;
                if (tmpCmy.Mgt > dizTbl[0]) {
                    if (tmpCmy.Mgt > dizTbl[2]) {
                        linBufMgt[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Mgt > dizTbl[1]) {
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel){
                dizTbl = dizTblY04 + strXax % DizSizYel * 3;
                if (tmpCmy.Yel > dizTbl[0]) {
                    if (tmpCmy.Yel > dizTbl[2]) {
                        linBufYel[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Yel > dizTbl[1]) {
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- black ----*/
            if(tmpCmy.Bla){
                dizTbl = dizTblB04 + strXax % DizSizBla * 3;
                if (tmpCmy.Bla > dizTbl[0]) {
                    if (tmpCmy.Bla > dizTbl[2]) {
                        linBufBla[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Bla > dizTbl[1]) {
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC04 = DizTblC04 + strYax % DizSizCyn * 16 * 3;
        dizTblM04 = DizTblM04 + strYax % DizSizMgt * 16 * 3;
        dizTblY04 = DizTblY04 + strYax % DizSizYel * 16 * 3;
        dizTblB04 = DizTblB04 + strYax % DizSizBla * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                if(tmpCmy.Cyn){
                    dizTbl = dizTblC04 + (strXax + tmpXax) % DizSizCyn * 3;
                    if (tmpCmy.Cyn > dizTbl[0]) {
                        if (tmpCmy.Cyn > dizTbl[2]) {
                            linBufCyn[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Cyn > dizTbl[1]) {
                            linBufCyn[tmpBuf] |= tmp002;
                        }else{
                            linBufCyn[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt){
                    dizTbl = dizTblM04 + (strXax + tmpXax) % DizSizMgt * 3;
                    if (tmpCmy.Mgt > dizTbl[0]) {
                        if (tmpCmy.Mgt > dizTbl[2]) {
                            linBufMgt[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Mgt > dizTbl[1]) {
                            linBufMgt[tmpBuf] |= tmp002;
                        }else{
                            linBufMgt[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel){
                    dizTbl = dizTblY04 + (strXax + tmpXax) % DizSizYel * 3;
                    if (tmpCmy.Yel > dizTbl[0]) {
                        if (tmpCmy.Yel > dizTbl[2]) {
                            linBufYel[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Yel > dizTbl[1]) {
                            linBufYel[tmpBuf] |= tmp002;
                        }else{
                            linBufYel[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- balck ----*/
                if(tmpCmy.Bla){
                    dizTbl = dizTblB04 + (strXax + tmpXax) % DizSizBla * 3;
                    if (tmpCmy.Bla > dizTbl[0]) {
                        if (tmpCmy.Bla > dizTbl[2]) {
                            linBufBla[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Bla > dizTbl[1]) {
                            linBufBla[tmpBuf] |= tmp002;
                        }else{
                            linBufBla[tmpBuf] |= tmp001;
                        }
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(16value)
//===================================================================================================
DWORD WINAPI N403Diz016(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          min;
    DWORD          max;
    DWORD          mid;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC16;
    LPBYTE         DizTblM16;
    LPBYTE         DizTblY16;
    LPBYTE         DizTblB16;
    LPBYTE         dizTblC16;
    LPBYTE         dizTblM16;
    LPBYTE         dizTblY16;
    LPBYTE         dizTblB16;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;

    DizTblC16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];


// Check of zero divide 2002.3.23 >>>
    if ((DizSizCyn == 0) || (DizSizMgt == 0)||
        (DizSizYel == 0) || (DizSizBla == 0)) {
        ERR(("N403Diz016() 0Div-Check [DizSizCyn,Mgt,Yel,Bla=0] \n"));
        return 0;
    }
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N403Diz016() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC16 = DizTblC16 + strYax % DizSizCyn * 8 * 15;
        dizTblM16 = DizTblM16 + strYax % DizSizMgt * 8 * 15;
        dizTblY16 = DizTblY16 + strYax % DizSizYel * 8 * 15;
        dizTblB16 = DizTblB16 + strYax % DizSizBla * 8 * 15;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 2;
            /*--- cyan ----*/
            if(tmpCmy.Cyn){
                dizTbl = dizTblC16 + strXax % DizSizCyn * 15;
                if (tmpCmy.Cyn > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Cyn > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufCyn[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt){
                dizTbl = dizTblM16 + strXax % DizSizMgt * 15;
                if (tmpCmy.Mgt > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Mgt > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufMgt[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel){
                dizTbl = dizTblY16 + strXax % DizSizYel * 15;
                if (tmpCmy.Yel > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Yel > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufYel[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- balck ----*/
            if(tmpCmy.Bla){
                dizTbl = dizTblB16 + strXax % DizSizBla * 15;
                if (tmpCmy.Bla > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Bla > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufBla[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 4 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC16 = DizTblC16 + strYax % DizSizCyn * 8 * 15;
        dizTblM16 = DizTblM16 + strYax % DizSizMgt * 8 * 15;
        dizTblY16 = DizTblY16 + strYax % DizSizYel * 8 * 15;
        dizTblB16 = DizTblB16 + strYax % DizSizBla * 8 * 15;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpBuf = tmpXax / 2;
                /*--- cyan ----*/
                if(tmpCmy.Cyn){
                    dizTbl = dizTblC16 + (strXax + tmpXax) % DizSizCyn * 15;
                    if (tmpCmy.Cyn > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Cyn > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufCyn[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt){
                    dizTbl = dizTblM16 + (strXax + tmpXax) % DizSizMgt * 15;
                    if (tmpCmy.Mgt > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Mgt > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufMgt[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel){
                    dizTbl = dizTblY16 + (strXax + tmpXax) % DizSizYel * 15;
                    if (tmpCmy.Yel > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Yel > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufYel[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- black ----*/
                if(tmpCmy.Bla){
                    dizTbl = dizTblB16 + (strXax + tmpXax) % DizSizBla * 15;
                    if (tmpCmy.Bla > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Bla > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufBla[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(600DPI 4value DETAIL)
//===================================================================================================
DWORD WINAPI N403DizSml(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          tblNum;
    LPBYTE         DizTblSml;
    LPBYTE         dizTblSml;
    CMYK           tmpCmy;
    BYTE           lvl001;
    BYTE           lvl002;
    BYTE           lvl003;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblSml = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N403DizSml() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblSml = DizTblSml + strYax % 16 * 16 * 3;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tblNum = strXax % 16 * 3;
            lvl001 = dizTblSml[tblNum + 0];
            lvl002 = dizTblSml[tblNum + 1];
            lvl003 = dizTblSml[tblNum + 2];
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            if(tmpCmy.Cyn > lvl001){
                if(tmpCmy.Cyn > lvl003){
                    linBufCyn[tmpBuf] |= tmp003;
                }else if(tmpCmy.Cyn > lvl002){
                    linBufCyn[tmpBuf] |= tmp002;
                }else{
                    linBufCyn[tmpBuf] |= tmp001;
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt > lvl001){
                if(tmpCmy.Mgt > lvl003){
                    linBufMgt[tmpBuf] |= tmp003;
                }else if(tmpCmy.Mgt > lvl002){
                    linBufMgt[tmpBuf] |= tmp002;
                }else{
                    linBufMgt[tmpBuf] |= tmp001;
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel > lvl001){
                if(tmpCmy.Yel > lvl003){
                    linBufYel[tmpBuf] |= tmp003;
                }else if(tmpCmy.Yel > lvl002){
                    linBufYel[tmpBuf] |= tmp002;
                }else{
                    linBufYel[tmpBuf] |= tmp001;
                }
            }
            /*--- black ----*/
            if(tmpCmy.Bla > lvl001){
                if(tmpCmy.Bla > lvl003){
                    linBufBla[tmpBuf] |= tmp003;
                }else if(tmpCmy.Bla > lvl002){
                    linBufBla[tmpBuf] |= tmp002;
                }else{
                    linBufBla[tmpBuf] |= tmp001;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblSml = DizTblSml + strYax % 16 * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tblNum = tmpXax % 16 * 3;
                lvl001 = dizTblSml[tblNum + 0];
                lvl002 = dizTblSml[tblNum + 1];
                lvl003 = dizTblSml[tblNum + 2];
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                if(tmpCmy.Cyn > lvl001){
                    if(tmpCmy.Cyn > lvl003){
                        linBufCyn[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Cyn > lvl002){
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt > lvl001){
                    if(tmpCmy.Mgt > lvl003){
                        linBufMgt[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Mgt > lvl002){
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel > lvl001){
                    if(tmpCmy.Yel > lvl003){
                        linBufYel[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Yel > lvl002){
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
                /*--- black ----*/
                if(tmpCmy.Bla > lvl001){
                    if(tmpCmy.Bla > lvl003){
                        linBufBla[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Bla > lvl002){
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(600DPI 4value NORMAL)
//===================================================================================================
DWORD WINAPI N403DizPrn(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    LPBYTE         DizTblPc4;
    LPBYTE         DizTblPm4;
    LPBYTE         DizTblPy4;
    LPBYTE         DizTblPb4;
    LPBYTE         dizTblPc4;
    LPBYTE         dizTblPm4;
    LPBYTE         dizTblPy4;
    LPBYTE         dizTblPb4;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblPc4 = lpDiz->EntDiz.Tbl[0];
    DizTblPm4 = lpDiz->EntDiz.Tbl[1];
    DizTblPy4 = lpDiz->EntDiz.Tbl[2];
    DizTblPb4 = lpDiz->EntDiz.Tbl[3];

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("N403DizPrn() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        dizTblPc4 = DizTblPc4 + strYax % 16 * 16 * 3;
        dizTblPm4 = DizTblPm4 + strYax % 16 * 16 * 3;
        dizTblPy4 = DizTblPy4 + strYax % 16 * 16 * 3;
        dizTblPb4 = DizTblPb4 + strYax % 16 * 16 * 3;
        /*---- Stretch ----*/
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            dizTbl = dizTblPc4 + strXax % 16 * 3;
            if(tmpCmy.Cyn > dizTbl[0]){
                if(tmpCmy.Cyn > dizTbl[2]){
                    linBufCyn[tmpBuf] |= tmp003;
                }else if(tmpCmy.Cyn > dizTbl[1]){
                    linBufCyn[tmpBuf] |= tmp002;
                }else{
                    linBufCyn[tmpBuf] |= tmp001;
                }
            }
            /*--- magenta ----*/
            dizTbl = dizTblPm4 + strXax % 16 * 3;
            if(tmpCmy.Mgt > dizTbl[0]){
                if(tmpCmy.Mgt > dizTbl[2]){
                    linBufMgt[tmpBuf] |= tmp003;
                }else if(tmpCmy.Mgt > dizTbl[1]){
                    linBufMgt[tmpBuf] |= tmp002;
                }else{
                    linBufMgt[tmpBuf] |= tmp001;
                }
            }
            /*--- yellow ----*/
            dizTbl = dizTblPy4 + strXax % 16 * 3;
            if(tmpCmy.Yel > dizTbl[0]){
                if(tmpCmy.Yel > dizTbl[2]){
                    linBufYel[tmpBuf] |= tmp003;
                }else if(tmpCmy.Yel > dizTbl[1]){
                    linBufYel[tmpBuf] |= tmp002;
                }else{
                    linBufYel[tmpBuf] |= tmp001;
                }
            }
            /*--- black ----*/
            dizTbl = dizTblPb4 + strXax % 16 * 3;
            if(tmpCmy.Bla > dizTbl[0]){
                if(tmpCmy.Bla > dizTbl[2]){
                    linBufBla[tmpBuf] |= tmp003;
                }else if(tmpCmy.Bla > dizTbl[1]){
                    linBufBla[tmpBuf] |= tmp002;
                }else{
                    linBufBla[tmpBuf] |= tmp001;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblPc4 = DizTblPc4 + strYax % 16 * 16 * 3;
        dizTblPm4 = DizTblPm4 + strYax % 16 * 16 * 3;
        dizTblPy4 = DizTblPy4 + strYax % 16 * 16 * 3;
        dizTblPb4 = DizTblPb4 + strYax % 16 * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                dizTbl = dizTblPc4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Cyn > dizTbl[0]){
                    if(tmpCmy.Cyn > dizTbl[2]){
                        linBufCyn[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Cyn > dizTbl[1]){
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
                /*--- magenta ----*/
                dizTbl = dizTblPm4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Mgt > dizTbl[0]){
                    if(tmpCmy.Mgt > dizTbl[2]){
                        linBufMgt[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Mgt > dizTbl[1]){
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
                /*--- yellow ----*/
                dizTbl = dizTblPy4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Yel > dizTbl[0]){
                    if(tmpCmy.Yel > dizTbl[2]){
                        linBufYel[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Yel > dizTbl[1]){
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
                /*--- black ----*/
                dizTbl = dizTblPb4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Bla > dizTbl[0]){
                    if(tmpCmy.Bla > dizTbl[2]){
                        linBufBla[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Bla > dizTbl[1]){
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Color matching(high speed)
//===================================================================================================
VOID WINAPI N403ColMch000(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpCal;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }
        tmpCal  = tmpRed / N403_GLDSPC * N403_GLDNUM * N403_GLDNUM;
        tmpCal += tmpGrn / N403_GLDSPC * N403_GLDNUM;
        tmpCal += tmpBlu / N403_GLDSPC;
        tmpCmy = LokUppRgbCmy[tmpCal];
        tmpCmy.Cyn = innTblCmy[tmpCmy.Cyn];
        tmpCmy.Mgt = innTblCmy[tmpCmy.Mgt];
        tmpCmy.Yel = innTblCmy[tmpCmy.Yel];
        tmpCmy.Bla = innTblCmy[tmpCmy.Bla];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }
}


//===================================================================================================
//    Color matching(normal speed)
//===================================================================================================
VOID WINAPI N403ColMch001(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpR01;
    LONG           tmpR02;
    LONG           tmpG01;
    LONG           tmpG02;
    LONG           tmpB01;
    LONG           tmpB02;
    LONG           ln1;
    LONG           ln2;
    LONG           ln3;

    LONG           tmpC00;
    LONG           tmpM00;
    LONG           tmpY00;
    LONG           tmpK00;
    LONG           tmpC01;
    LONG           tmpM01;
    LONG           tmpY01;
    LONG           tmpK01;
    LONG           tmpC02;
    LONG           tmpM02;
    LONG           tmpY02;
    LONG           tmpK02;
    LONG           tmpC03;
    LONG           tmpM03;
    LONG           tmpY03;
    LONG           tmpK03;

    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LPRGB          CchRgb;
    LPCMYK         CchCmy;

    LPRGB          endAdr;
    DWORD          cch;
    RGBS           tmpRgb;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;
    CchRgb = lpDiz->Lut.CchRgb;
    CchCmy = lpDiz->Lut.CchCmy;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRgb = *rgbAdr;
        tmpRed = tmpRgb.Red;
        tmpGrn = tmpRgb.Green;
        tmpBlu = tmpRgb.Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }

        /*---- Cache color matching ----*/
        cch = ( tmpRed * 49 + tmpGrn * 9 + tmpBlu ) % N403_CCHNUM;
        if(    (CchRgb[cch].Red == tmpRgb.Red) &&
            (CchRgb[cch].Green == tmpRgb.Green) &&
            (CchRgb[cch].Blue == tmpRgb.Blue)
        ){
            *cmyAdr = CchCmy[cch];
            cmyAdr++;
            continue;
        }

        /*---- RGB -> CMYK ----*/
        tmpR01 = tmpRed * 31 / 255;
        tmpR02 = (tmpRed * 31 + 254) / 255;

        tmpG01 = tmpGrn * 31 / 255;
        tmpG02 = (tmpGrn * 31 + 254) / 255;

        tmpB01 = tmpBlu * 31 / 255;
        tmpB02 = (tmpBlu * 31 + 254) / 255;


        ln2 = tmpRed - tmpR01*255/31;
        if(ln2 == 0){
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
            tmpC00 = tmpCmy.Cyn;
            tmpM00 = tmpCmy.Mgt;
            tmpY00 = tmpCmy.Yel;
            tmpK00 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
            tmpC01 = tmpCmy.Cyn;
            tmpM01 = tmpCmy.Mgt;
            tmpY01 = tmpCmy.Yel;
            tmpK01 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
            tmpC02 = tmpCmy.Cyn;
            tmpM02 = tmpCmy.Mgt;
            tmpY02 = tmpCmy.Yel;
            tmpK02 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
            tmpC03 = tmpCmy.Cyn;
            tmpM03 = tmpCmy.Mgt;
            tmpY03 = tmpCmy.Yel;
            tmpK03 = tmpCmy.Bla;
        }else{
            ln1 = tmpR02*255/31 - tmpRed;
            if(ln1 == 0){
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 = tmpCmy.Cyn;
                tmpM00 = tmpCmy.Mgt;
                tmpY00 = tmpCmy.Yel;
                tmpK00 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01 = tmpCmy.Cyn;
                tmpM01 = tmpCmy.Mgt;
                tmpY01 = tmpCmy.Yel;
                tmpK01 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02 = tmpCmy.Cyn;
                tmpM02 = tmpCmy.Mgt;
                tmpY02 = tmpCmy.Yel;
                tmpK02 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03 = tmpCmy.Cyn;
                tmpM03 = tmpCmy.Mgt;
                tmpY03 = tmpCmy.Yel;
                tmpK03 = tmpCmy.Bla;
            }else{
                ln3 = ln1 + ln2;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 = ln1 * tmpCmy.Cyn;
                tmpM00 = ln1 * tmpCmy.Mgt;
                tmpY00 = ln1 * tmpCmy.Yel;
                tmpK00 = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 += ln2 * tmpCmy.Cyn;
                tmpM00 += ln2 * tmpCmy.Mgt;
                tmpY00 += ln2 * tmpCmy.Yel;
                tmpK00 += ln2 * tmpCmy.Bla;
                tmpC00 /= ln3;
                tmpM00 /= ln3;
                tmpY00 /= ln3;
                tmpK00 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01  = ln1 * tmpCmy.Cyn;
                tmpM01  = ln1 * tmpCmy.Mgt;
                tmpY01  = ln1 * tmpCmy.Yel;
                tmpK01  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01 += ln2 * tmpCmy.Cyn;
                tmpM01 += ln2 * tmpCmy.Mgt;
                tmpY01 += ln2 * tmpCmy.Yel;
                tmpK01 += ln2 * tmpCmy.Bla;
                tmpC01 /= ln3;
                tmpM01 /= ln3;
                tmpY01 /= ln3;
                tmpK01 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02  = ln1 * tmpCmy.Cyn;
                tmpM02  = ln1 * tmpCmy.Mgt;
                tmpY02  = ln1 * tmpCmy.Yel;
                tmpK02  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02 += ln2 * tmpCmy.Cyn;
                tmpM02 += ln2 * tmpCmy.Mgt;
                tmpY02 += ln2 * tmpCmy.Yel;
                tmpK02 += ln2 * tmpCmy.Bla;
                tmpC02 /= ln3;
                tmpM02 /= ln3;
                tmpY02 /= ln3;
                tmpK02 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03  = ln1 * tmpCmy.Cyn;
                tmpM03  = ln1 * tmpCmy.Mgt;
                tmpY03  = ln1 * tmpCmy.Yel;
                tmpK03  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03 += ln2 * tmpCmy.Cyn;
                tmpM03 += ln2 * tmpCmy.Mgt;
                tmpY03 += ln2 * tmpCmy.Yel;
                tmpK03 += ln2 * tmpCmy.Bla;
                tmpC03 /= ln3;
                tmpM03 /= ln3;
                tmpY03 /= ln3;
                tmpK03 /= ln3;
            }
        }


        ln2 = tmpGrn - tmpG01*255/31;
        if(ln2 != 0){
            ln1 = tmpG02*255/31 - tmpGrn;
            if(ln1 == 0){
                tmpC00 = tmpC02;
                tmpM00 = tmpM02;
                tmpY00 = tmpY02;
                tmpK00 = tmpK02;
                tmpC01 = tmpC03;
                tmpM01 = tmpM03;
                tmpY01 = tmpY03;
                tmpK01 = tmpK03;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC02) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM02) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY02) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK02) / ln3;
                tmpC01 = (ln1*tmpC01 + ln2*tmpC03) / ln3;
                tmpM01 = (ln1*tmpM01 + ln2*tmpM03) / ln3;
                tmpY01 = (ln1*tmpY01 + ln2*tmpY03) / ln3;
                tmpK01 = (ln1*tmpK01 + ln2*tmpK03) / ln3;
            }
        }


        ln2 = tmpBlu - tmpB01*255/31;
        if(ln2 != 0){
            ln1 = tmpB02*255/31 - tmpBlu;
            if(ln1 == 0){
                tmpC00 = tmpC01;
                tmpM00 = tmpM01;
                tmpY00 = tmpY01;
                tmpK00 = tmpK01;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC01) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM01) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY01) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK01) / ln3;
            }
        }

        tmpCmy.Cyn  = innTblCmy[tmpC00];
        tmpCmy.Mgt  = innTblCmy[tmpM00];
        tmpCmy.Yel  = innTblCmy[tmpY00];
        tmpCmy.Bla  = innTblCmy[tmpK00];
        *cmyAdr = tmpCmy;
        cmyAdr++;

        CchRgb[cch] = tmpRgb;
        CchCmy[cch] = tmpCmy;
    }
}


//===================================================================================================
//    CMYK data color vividly
//===================================================================================================
VOID WINAPI N403ColVivPrc(
    LPN403DIZINF   lpDiz,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          vivNum
)
{
    LPCMYK         endAdr;
    LONG           tmpCyn;
    LONG           tmpMgt;
    LONG           tmpYel;
    LONG           tmpMid;

    for(endAdr = cmyAdr+xaxSiz ; cmyAdr < endAdr ; cmyAdr++){
        tmpCyn = cmyAdr->Cyn;
        tmpMgt = cmyAdr->Mgt;
        tmpYel = cmyAdr->Yel;
        tmpMid = (tmpCyn + tmpMgt + tmpYel) / 3;
        tmpCyn += (tmpCyn - tmpMid) * (SHORT)vivNum / 100;
        tmpMgt += (tmpMgt - tmpMid) * (SHORT)vivNum / 100;
        tmpYel += (tmpYel - tmpMid) * (SHORT)vivNum / 100;
        if(tmpCyn < 0){tmpCyn = 0;}else if(tmpCyn > 255){tmpCyn = 255;}
        if(tmpMgt < 0){tmpMgt = 0;}else if(tmpMgt > 255){tmpMgt = 255;}
        if(tmpYel < 0){tmpYel = 0;}else if(tmpYel > 255){tmpYel = 255;}
        cmyAdr->Cyn = (BYTE)tmpCyn;
        cmyAdr->Mgt = (BYTE)tmpMgt;
        cmyAdr->Yel = (BYTE)tmpYel;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion(No matching)
//===================================================================================================
VOID WINAPI N403ColCnvSld(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    DWORD          tmpRed;
    DWORD          tmpGrn;
    DWORD          tmpBlu;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if(innTblCmy != NULL){
        for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
            tmpRed = rgbAdr->Red;
            tmpGrn = rgbAdr->Green;
            tmpBlu = rgbAdr->Blue;
            if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
                cmyAdr->Cyn = 0;
                cmyAdr->Mgt = 0;
                cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
                cmyAdr++;
                continue;
            }
            cmyAdr->Cyn = innTblCmy[255 - GinTblP15[tmpRed]];
            cmyAdr->Mgt = innTblCmy[255 - GinTblP15[tmpGrn]];
            cmyAdr->Yel = innTblCmy[255 - GinTblP15[tmpBlu]];
            cmyAdr->Bla = 0;
            cmyAdr++;
        }
        return;
    }
    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = (BYTE)255 - GinTblP15[tmpRed];
        cmyAdr->Mgt = (BYTE)255 - GinTblP15[tmpGrn];
        cmyAdr->Yel = (BYTE)255 - GinTblP15[tmpBlu];
        cmyAdr->Bla = 0;
        cmyAdr++;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion (for 1dot line)
//===================================================================================================
VOID WINAPI N403ColCnvL02(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    DWORD          tmpRed;
    DWORD          tmpGrn;
    DWORD          tmpBlu;
    DWORD          tmpMid;
    BYTE           tmpCyn;
    BYTE           tmpMgt;
    BYTE           tmpYel;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
        if(tmpMid > 240){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 0;
            cmyAdr++;
            continue;
        }
        tmpCyn = 255;
        tmpMgt = 255;
        tmpYel = 255;
        tmpMid += (255 - tmpMid) / 8;
        if(tmpRed > tmpMid){ tmpCyn = 0; }
        if(tmpGrn > tmpMid){ tmpMgt = 0; }
        if(tmpBlu > tmpMid){ tmpYel = 0; }
        if((tmpCyn & tmpMgt & tmpYel) == 255){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = tmpCyn;
        cmyAdr->Mgt = tmpMgt;
        cmyAdr->Yel = tmpYel;
        cmyAdr->Bla = 0;
        cmyAdr++;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion (for monochrome)
//===================================================================================================
VOID WINAPI N403ColCnvMon(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    DWORD          red;
    DWORD          grn;
    DWORD          blu;
    BYTE           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if(innTblCmy != NULL){
        for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = innTblCmy[255 - GinTblP10[(red*3 + grn*5 + blu*2) / 10]];
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = bla;
            cmyAdr++;
        }
        return;
    }
    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        bla = (BYTE)255 - GinTblP10[(red*3 + grn*5 + blu*2) / 10];
        cmyAdr->Cyn = 0;
        cmyAdr->Mgt = 0;
        cmyAdr->Yel = 0;
        cmyAdr->Bla = bla;
        cmyAdr++;
    }
}


// End of N403DIZ.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>

#include <prcomoem.h>
#include "COLMATCH.H"

//
// For debugging.
//

//#define MY_VERBOSE(x) DBGPRINT(DBG_WARNING, x)
#define MY_VERBOSE VERBOSE
//#define DL_VERBOSE MY_VERBOSE
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE MY_VERBOSE
#define SC_VERBOSE VERBOSE
//#define CM_VERBOSE MY_VERBOSE
#define CM_VERBOSE VERBOSE


//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define DRVGETGPDDATA(p, t, i, b, s, n) \
  ((p)->pDrvProcs->DrvGetGPDData(p, t, i, b, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

#define DEFAULT_PALETTE_INDEX   0

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD    fGeneral;
    int    iEscapement;
    short    sHeightDiv;
    short    iDevCharOffset;
    BYTE    iPaperSource;
    BYTE    iDuplex;
    BYTE    iTonerSave;
    BYTE    iOrientation;
    BYTE    iResolution; 
    BYTE    iColor;
    BYTE    iSmoothing;
    BYTE    iJamRecovery;
    BYTE    iMediaType;
    BYTE    iUnitFactor;         // factor of master unit
    BYTE    iDithering;
    BYTE    iColorMatching;
    BYTE    iBitFont;
    BYTE    iCmyBlack;
    BYTE    iTone;
    BYTE    iPaperSize;
    BYTE    iCompress;
    WORD    Printer;
    DEVCOL  Col;
    WORD    wRectWidth, wRectHeight;

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS        0x00000001
#define FG_VERT        0x00000002
#define FG_PROP        0x00000004
#define FG_DOUBLE      0x00000008
#define FG_NULL_PEN    0x00000010
#define FG_BOLD        0x00000020
#define FG_ITALIC      0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..
N4SRCDIR=..\..\casn4res

TARGETNAME=csn46res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),csn46res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\csn46res.rc \
    $(SRCDIR)\csn46res.c \
    $(SRCDIR)\colmatch.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\n403diz.c \
    $(SRCDIR)\n4diz.c \
    $(SRCDIR)\prnctl.c

MISCFILES=\
    $(SRCDIR)\csn46res.ini \
    $(SRCDIR)\lut\cpn4rgbx.lut \
    $(SRCDIR)\lut\cpn4rgby.lut \
    $(N4SRCDIR)\icm\csn4001.icm \
    $(N4SRCDIR)\icm\csn4002.icm \
    $(N4SRCDIR)\icm\csn4003.icm \
    $(GPDDIR)\csn46j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
    "DrvGetGPDData",
    "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
    "ImageProcessing",
    "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\prnctl.c ===
//***************************************************************************************************
//    PRNCTL.C
//
//    Functions of controlling printer
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    <stdio.h>
#include    "PRNCTL.H"
#include    "strsafe.h"         // Security-Code 2002.3.6

// Replacement of API 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of API 2002.3.6 >>>

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Type of pressing raster image
//---------------------------------------------------------------------------------------------------
#define   RASTER_COMP     0                         // Press
#define   RASTER_NONCOMP  1                         // Not press
#define   RASTER_EMPTY    2                         // Empty

//---------------------------------------------------------------------------------------------------
//    Buffer for setting command
//---------------------------------------------------------------------------------------------------
static BYTE        CmdBuf[1 * 1024];                // 1KB

//---------------------------------------------------------------------------------------------------
//    Structure for setting command
//---------------------------------------------------------------------------------------------------
typedef const struct {
    WORD        Size;                               // Command size
    LPBYTE      Cmd;                                // Command buffer
} CMDDEF, FAR *LPCMDDEF;

//===================================================================================================
//    Command define
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//    Change mode
//---------------------------------------------------------------------------------------------------
static CMDDEF ModOrgIn =    { 4, "\x1b""z""\xd0\x01"};      // ESC/Page -> original
static CMDDEF ModOrgOut =   { 4, "\x1b""z""\x00\x01"};      // original -> ESC/Page

//---------------------------------------------------------------------------------------------------
//    Setting overwrite
//---------------------------------------------------------------------------------------------------
static CMDDEF CfgWrtMod =    { 6, "\x1d""%uowE"};           // Setting overwrite

//---------------------------------------------------------------------------------------------------
//    Setting spool positon
//---------------------------------------------------------------------------------------------------
static CMDDEF PosAbsHrz =    { 4, "\x1d""%dX"};             // Horizontal
static CMDDEF PosAbsVtc =    { 4, "\x1d""%dY"};             // Vertical

//---------------------------------------------------------------------------------------------------
//    Spool bitmap data
//---------------------------------------------------------------------------------------------------
static CMDDEF ImgDrw =       {16, "\x1d""%u;%u;%u;%dbi{I"}; // Spool bit image
static CMDDEF ImgRasStr =    {15, "\x1d""%u;%u;%u;%dbrI"};  // Start spool raster image
static CMDDEF ImgRasEnd =    { 4, "\x1d""erI"};             // End spool raster image
static CMDDEF ImgRasDrw =    { 6, "\x1d""%ur{I"};           // Spool raster image
static CMDDEF ImgRasNon =    { 6, "\x1d""%uu{I"};           // Spool raster image(Not press)
static CMDDEF ImgRasEpy =    { 5, "\x1d""%ueI"};            // Spool empty raster image

//---------------------------------------------------------------------------------------------------
//    CASIO original
//---------------------------------------------------------------------------------------------------
static CMDDEF OrgColCmy =    {15, "Cc,%u,%u,%u,%u*"};       // CMYK
static CMDDEF OrgDrwPln =    {15, "Da,%u,%u,%u,%u*"};       // Setting plane
static CMDDEF OrgImgCmy =    {26, "Cj%w,%u,%u,%u,%l,%l,%u,%u*"};   // CMYK bitimage

static BYTE OVERWRITE[] = 
    "\x1D" "1owE"                      //MOV1
    "\x1D" "0tsE";

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static WORD        PlaneCmdStore(PDEVOBJ, LPBYTE, WORD);
static void        BitImgImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE);
static BOOL        RasterImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE);
static WORD        RasterSize(WORD, WORD, WORD, WORD, LPBYTE);
static WORD        RasterComp(LPBYTE, WORD, LPBYTE, LPBYTE, LPWORD);
static void        CMYKImgCmd(PDEVOBJ, WORD, LONG, LONG, WORD, WORD, WORD, WORD, WORD, DWORD, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static WORD        CmdCopy(LPBYTE, LPCMDDEF);
static WORD        CmdStore(LPBYTE, LPCMDDEF, LPINT);
static WORD        INTtoASC(LPBYTE, int);
static WORD        USINTtoASC(LPBYTE, WORD);
static WORD        LONGtoASC(LPBYTE, LONG);
static WORD        USLONGtoASC(LPBYTE, DWORD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMP       lpBmp                                    // Pointer to DRWBMP structure
)
{
    WORD           siz,size;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;                               // byte
    LPBYTE         lpTmpBuf;
    LPBYTE         lpSchBit;
    LPBYTE         lpBit;                                   // Pointer to Bitmap data
    POINT          drwPos;
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;                                 // Width from the left edge
    WORD           widRCnt;                                 // Width from the right edge
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    WORD           img1st;                                  // Spool first image data?
    int            pam[4];
    int            palm[1];

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpTmpBuf = NULL;
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;

    MY_VERBOSE((" PB "));

    img1st = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {               // 1 Spool bitmap data
                                                          // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {
                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {                    // first lineH
                        strHigCnt = higCnt;
                        invLft = widLCnt;                 // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;             // Renew invalid size from the left edge
                        }
                    }
                                                          // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {            // first lineH
                                invRgt = widRCnt;         // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;     // Renew invalid size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                             // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                        // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {    // 1line all NULL data & There were data except NULL data in previous line
                break;                                    // Go to spool bitmap data
            }
        }
        if (higSiz != 0) {                                // There are data for spoolH
            if (img1st == Yes) {                          // Spool for the first time
                                                          // Compress?
                if (pOEM->iCompress != XX_COMPRESS_OFF) {
                    if ((lpTmpBuf = MemAllocZ(widthByte * height)) != NULL) {
                        comp = Yes;
                    }
                }
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                // ColorH
                if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
                    pam[0] = lpBmp->Color.Cyn;
                    pam[1] = lpBmp->Color.Mgt;
                    pam[2] = lpBmp->Color.Yel;
                    pam[3] = lpBmp->Color.Bla;
                    siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

                    siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                }
                // Original mode out
                siz += CmdCopy(CmdBuf + siz, &ModOrgOut);
                if (siz != 0) {                         // There are data for spool?
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                            // Not first time
            }

            drwPos.x = lpBmp->DrawPos.x + invLft * 8;   // x coordinates
            drwPos.y = lpBmp->DrawPos.y + strHigCnt;    // y coordinates
            palm[0] = drwPos.x;
            siz = CmdStore(CmdBuf, &PosAbsHrz, palm);
            palm[0] = drwPos.y;
            siz += CmdStore(CmdBuf + siz, &PosAbsVtc, palm);
            if (siz != 0) {                             // There are data for spool?
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            }

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
            if (comp == Yes) {                          // Compress?

                if (RasterImgCmd(pdevobj, pOEM->iCompress, width, higSiz,
                                 widthByte, 0, invLft, invRgt, lpBit, lpTmpBuf) == No) {
                    comp = No;                          // But compress rate is poor, no compress
                }
            }
            if (comp == No) {                           // Not compress

                BitImgImgCmd(pdevobj, width, higSiz, widthByte, 0, invLft, invRgt, lpBit);
            }
        }
    }
    if (lpTmpBuf) {
        MemFree(lpTmpBuf);
    }
    return;
}


//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMPCMYK   lpBmp                                    // Pointer to DRWBMPCMYK structure
)
{
    WORD           siz;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;
    LPBYTE         lpSchBit;                                // Pointer to bitmap data
    LPBYTE         lpBit;                                   // Pointer to bitmap data
    LONG           xPos;
    LONG           yPos;
    WORD           posClpLft;                               // Clipping dot size
    DWORD          posAdj;                                  // 1/7200inch
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;
    WORD           widRCnt;
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    DWORD          invLftBit;                               // Invalid bit size from the left edge
    DWORD          invRgtBit;                               // Invalid bit size from the right edge
    WORD           rgtBit;                                  // Valid bit size from the right edge
    WORD           img1st;                                  // Spool for the first time
    DWORD          dstSiz;
    LPBYTE         lpDst;
    LPBYTE         lpTmp;
    int            pam[1];
    WORD           img1st_2;                                // Spool for the first time

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE((" CM "));

// Check of zero divide 2002.3.23 >>>
    if (lpBmp->DataBit == 0) {
        ERR(("PrnBitmapCMYK() 0Div-Check [lpBmp->DataBit=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    lpTmp = NULL;
    posAdj = 7200 / pOEM->Col.wReso;                        // 1/7200inch
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;
    if (pOEM->iCompress != XX_COMPRESS_OFF) {

        if ((lpTmp = MemAllocZ(widthByte * height)) != NULL) {
            comp = Yes;
        }
    }
    img1st = Yes;
    img1st_2 = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {                // 1 Spool bitmap data
                                                           // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {

                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {
                        strHigCnt = higCnt;                // first line
                        invLft = widLCnt;                  // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;              // Renew invalid size from the left edge
                        }
                    }
                                                           // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {             // first line
                                invRgt = widRCnt;          // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;      // Renew size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                              // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                         // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {     // 1line all NULL data & There were data except NULL data in previous line
                break;                                     // goto spool
            }
        }
        if (higSiz != 0) {                                 // There are data for spool
            if (img1st_2 == Yes) {
                WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
                img1st_2 = No;
            }
            // When Colormode is XX_COLOR_MANY ,not compress
            if (comp == Yes && pOEM->iColor == XX_COLOR_MANY) {
                comp = No;
            }
            if (comp == No && img1st == Yes) {
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                                                            // Plane
                siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                if (siz != 0) {                             // There are data for spool
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                                // not first
            }

            invLftBit = (DWORD)invLft * 8;
            if (invRgt != 0) {

                if ((rgtBit = (WORD)((DWORD)width * lpBmp->DataBit % 8)) == 0) {
                    rgtBit = 8;
                }
                if (rgtBit == 8) {
                    invRgtBit = (DWORD)invRgt * 8;
                } else {
                    invRgtBit = ((DWORD)invRgt - 1) * 8 + rgtBit;
                }
            } else {
                invRgtBit = 0;
            }
            posClpLft = (WORD)(invLftBit / lpBmp->DataBit);
                                                             // Start position of spooling
            xPos = ((LONG)lpBmp->DrawPos.x + posClpLft) * posAdj;
            yPos = ((LONG)lpBmp->DrawPos.y + strHigCnt) * posAdj;

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
                                                             // Spool CMYK bit image
            CMYKImgCmd(pdevobj, comp, xPos, yPos, lpBmp->Frame, lpBmp->DataBit, width, higSiz, widthByte,
                       invLftBit, invRgtBit, lpBit, lpTmp, (LONG)lpBmp->DrawPos.x + posClpLft, (LONG)lpBmp->DrawPos.y + strHigCnt);
        }
    }
    if (img1st == No) {                                      // Already spool 
        // Original mode out
        siz = CmdCopy(CmdBuf, &ModOrgOut);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    }
    if (lpTmp) {
        MemFree(lpTmp);
    }
    return;
}


//===================================================================================================
//    Spool plane command
//===================================================================================================
WORD PlaneCmdStore(                                         // Size of command
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPBYTE         lpDst,
    WORD           Plane
)
{
    int            pam[4];
    WORD           siz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (Plane & PLN_CYAN) {
        pam[0] = 0;                                         // Spool
    } else {
        pam[0] = 1;                                         // Not spool
    }
    if (Plane & PLN_MGENTA) {
        pam[1] = 0;                                         // Spool
    } else {
        pam[1] = 1;                                         // Not spool
    }
    if (Plane & PLN_YELLOW) {
        pam[2] = 0;                                         // Spool
    } else {
        pam[2] = 1;                                         // Not spool
    }
    if (Plane & PLN_BLACK) {
        pam[3] = 0;                                         // Spool
    } else {
        pam[3] = 1;                                         // Not spool
    }
    siz = CmdStore(lpDst, &OrgDrwPln, pam);
    return siz;
}


//===================================================================================================
//    Spool bitimage command data
//===================================================================================================
void BitImgImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotare(0fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit                                    // Bitmap data
)
{
    int            pam[10];
    WORD           siz;
    WORD           widByt;
    WORD           linCnt;

    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size
        pam[0] = WidthByte * Height;                        // Number of Data byte
        pam[1] = Width;
        pam[2] = Height;
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
    } else {                                                // There are invalid size
        widByt = WidthByte - InvLeft - InvRight;            // Width byte
        pam[0] = widByt * Height;
        if (InvRight == 0) {                                // There are no invalid size from the right edge
            pam[1] = Width - InvLeft * 8;                   // Width bit image
        } else {
            pam[1] = widByt * 8;                            // Width bit image
        }
        pam[2] = Height;                                    // Height bit image
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line
            lpBit += InvLeft;
            WRITESPOOLBUF(pdevobj, lpBit, widByt);
            lpBit += widByt;
            lpBit += InvRight;
        }
    }
    return;
}


//===================================================================================================
//    Spool raster image command data
//===================================================================================================
BOOL RasterImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotate(0:fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the left edge
    LPBYTE         lpBit,                                   // Pointer to bitmap data
    LPBYTE         lpBuf                                    // Pointer to raster image data buffer
)
{
    int            pam[4];
    WORD           siz;
    WORD           widByt;
    WORD           setCnt;
    WORD           ras;                                     // Type of raster image
    WORD           befRas;                                  // Type of raster image(Privious line)
    LPBYTE         lpLas;                                   // Privious raster data
    WORD           dstSiz;                                  // byte size
    WORD           rasSiz;                                  // Raster image data byte size
    WORD           rasEpy;

    MY_VERBOSE((" RAS "));

    widByt = WidthByte - InvLeft - InvRight;                // Width byte (Not include invalid size)
    if (Comp == XX_COMPRESS_AUTO) {
                                                            // Get raster image size
        rasSiz = RasterSize(Height, widByt, InvLeft, InvRight, lpBit);
        if (rasSiz > (widByt * Height / 5 * 4)) {           // Raster rate is more than 80%
            return No;                                      // Error
        }
    }
    pam[0] = 4;
    if (InvRight == 0) {                                    // No invalid size from the right edge
        pam[1] = Width - InvLeft * 8;                       // Width
    } else {
        pam[1] = widByt * 8;                                // Width
    }
    pam[2] = Height;                                        // Height
    pam[3] = Rotation;
    siz = CmdStore(CmdBuf, &ImgRasStr, pam);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    lpLas = NULL;
    rasSiz = 0;
    rasEpy = 0;
    for (setCnt = 0; setCnt < Height; setCnt++) {
        lpBit += InvLeft;
                                                            // Compress
        ras = RasterComp(lpBuf + rasSiz, widByt, lpBit, lpLas, &dstSiz);
        if (setCnt != 0 && befRas != ras) {                 // Not same as raster state of previous line
            if (befRas == RASTER_COMP) {
                pam[0] = rasSiz;
                siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);        // Spool command
                WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);      // Spool data
                rasSiz = 0;
            } else if (befRas == RASTER_EMPTY) {
                pam[0] = rasEpy;
                siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                rasEpy = 0;
            }
        }                                                   // Spool state of current line
        if (ras == RASTER_COMP) {
            rasSiz += dstSiz;
        } else if (ras == RASTER_EMPTY) {
            rasEpy++;
        } else {
            pam[0] = dstSiz;
            siz = CmdStore(CmdBuf, &ImgRasNon, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);            // Spool command
            WRITESPOOLBUF(pdevobj, lpBit, dstSiz);          // Spool data
        }
        befRas = ras;                                       // Renew
        lpLas = lpBit;                                      // Renew
        lpBit += widByt;                                    // Renew
        lpBit += InvRight;
    }
    if (rasSiz != 0) {                                      // There are raster data without spooling
        pam[0] = rasSiz;
        siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
        WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);              // Spool data
    } else if (rasEpy != 0) {                               // There are empty raster data without spooling
        pam[0] = rasEpy;
        siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
    }
    siz = CmdCopy(CmdBuf, &ImgRasEnd);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    return Yes;
}


//===================================================================================================
//    Get size of raster image
//===================================================================================================
WORD RasterSize(
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           InvLeft,
    WORD           InvRight,
    LPBYTE         lpBit
)
{
    WORD           rasSiz;
    WORD           chkCnt;
    WORD           rasEpy;
    LPBYTE         lpLas;
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;

    rasSiz = 0;
    rasEpy = 0;
    lpLas = NULL;
    for (chkCnt = 0; chkCnt < Height; chkCnt++) {           // Check size of raster image
        lpBit += InvLeft;
        srcCnt = WidthByte;
        for (; srcCnt != 0; srcCnt--) {
            if (lpBit[srcCnt - 1] != 0x00) {
                break;
            }
        }
        if (srcCnt == 0) {                                  // 1 line All white data?
            rasEpy++;
            lpLas = lpBit;
            lpBit += WidthByte;
            lpBit += InvRight;
            continue;
        }
        if (rasEpy != 0) {
            rasSiz += 8;
            rasEpy = 0;
        }
        empSiz = WidthByte - srcCnt;
        for (dstCnt = 0, srcCnt = 0; srcCnt < WidthByte; ) {
            if (lpLas != NULL) {
                if (lpLas[srcCnt] == lpBit[srcCnt]) {
                    equCnt = 1;
                    srcCnt++;
                    for (; srcCnt < WidthByte; srcCnt++) {

                        if (lpLas[srcCnt] != lpBit[srcCnt]) {
                            break;
                        }
                        equCnt++;
                    }
                    if (srcCnt == WidthByte) {
                        rasSiz++;
                        break;
                    }
                }
                rasSiz++;
                if (equCnt >= 63) {
                    rasSiz += ((equCnt / 255) + 1);
                }
            }

            if (srcCnt < (WidthByte - 1) && lpBit[srcCnt] == lpBit[srcCnt + 1]) {
                cmpDat = lpBit[srcCnt];
                equCnt = 2;

                for (srcCnt += 2; srcCnt < WidthByte; srcCnt++) {
                    if (cmpDat != lpBit[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                rasSiz += 2;
                if (equCnt >= 63) {
                    rasSiz += equCnt / 255 + 1;
                }
            } else {
                if (WidthByte < (dstCnt + 9)) {
                    rasSiz += WidthByte - empSiz + 9;
                    break;
                }
                if ((WidthByte - srcCnt) < 8) {
                    rasSiz += WidthByte - srcCnt + 1;
                    srcCnt += WidthByte - srcCnt;
                } else {
                    rasSiz += 9;
                    srcCnt += 8;
                }
            }
        }
        lpLas = lpBit;
        lpBit += WidthByte;
        lpBit += InvRight;
    }
    return rasSiz;
}


//===================================================================================================
//    Compress raster image
//===================================================================================================
WORD RasterComp(
    LPBYTE         lpDst,
    WORD           Siz,
    LPBYTE         lpSrc,
    LPBYTE         lpLas,
    LPWORD         lpDstSiz
)
{
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;
    WORD           setCnt;
    BYTE           flgByt;
    WORD           flgPnt;

    static const BYTE flgTbl[8] = {0x00, 0x01, 0x02, 0x04,
                                   0x08, 0x10, 0x20, 0x40};

    srcCnt = Siz;
    for (; srcCnt != 0; srcCnt--) {
        if (lpSrc[srcCnt - 1] != 0x00) {
            break;
        }
    }
    if (srcCnt == 0) {
        *lpDstSiz = 0;
        return RASTER_EMPTY;
    }
    empSiz = Siz - srcCnt;
    for (dstCnt = 0, srcCnt = 0; srcCnt < Siz; ) {
        if (lpLas != NULL) {
            if (lpLas[srcCnt] == lpSrc[srcCnt]) {
                equCnt = 1;
                srcCnt++;
                for (; srcCnt < Siz; srcCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                if (srcCnt == Siz) {
                    break;
                }
                if (Siz < (dstCnt + equCnt / 255 + 1)) {
                    *lpDstSiz = Siz - empSiz;
                    return RASTER_NONCOMP;
                }
                if (equCnt < 63) {
                    lpDst[dstCnt++] = 0x80 | (BYTE)equCnt;
                } else {
                    lpDst[dstCnt++] = 0x80 | 0x3f;
                    for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                        lpDst[dstCnt++] = 0xff;
                    }
                    lpDst[dstCnt++] = (BYTE)equCnt;
                }
            }
        }

        if (srcCnt < (Siz - 1) && lpSrc[srcCnt] == lpSrc[srcCnt + 1]) {
            cmpDat = lpSrc[srcCnt];
            equCnt = 2;
            for (srcCnt += 2; srcCnt < Siz; srcCnt++) {
                if (cmpDat != lpSrc[srcCnt]) {
                    break;
                }
                equCnt++;
            }
            if (Siz < (dstCnt + equCnt / 255 + 2)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            if (equCnt < 63) {
                lpDst[dstCnt++] = 0xc0 | (BYTE)equCnt;
            } else {
                lpDst[dstCnt++] = 0xc0 | 0x3f;
                for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                    lpDst[dstCnt++] = 0xff;
                }
                lpDst[dstCnt++] = (BYTE)equCnt;
            }
            lpDst[dstCnt++] = cmpDat;
        } else {
            if (Siz < (dstCnt + 9)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            flgPnt = dstCnt;
            dstCnt++;
            flgByt = 0x00;
            if (lpLas != NULL) {
                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        lpDst[dstCnt++] = lpSrc[srcCnt];
                        flgByt |= flgTbl[setCnt];
                    }
                }
            } else {

                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    lpDst[dstCnt++] = lpSrc[srcCnt];
                    flgByt |= flgTbl[setCnt];
                }
            }
            lpDst[flgPnt] = flgByt;
        }
    }
    if (Siz == dstCnt) {
        *lpDstSiz = Siz - empSiz;
        return RASTER_NONCOMP;
    }
    lpDst[dstCnt++] = 0x80;
    *lpDstSiz = dstCnt;
    return RASTER_COMP;
}


//===================================================================================================
//    Spool CMYK Bit image command
//===================================================================================================
void CMYKImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    LONG           XPos,
    LONG           YPos,
    WORD           Frame,
    WORD           DataBit,                                 // (1:2value 2:4value 4:16value)
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    DWORD          InvLeft,                                 // Invalid size from the left edge
    DWORD          InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit,
    LPBYTE         lpTmp,
    LONG           XPos_P,
    LONG           YPos_P
)
{
    int            pam[11];
    WORD           siz;
    WORD           widByt;                                  // Width byte(Not include invalid size)
    WORD           Plane;
    LPBYTE         lpDst;                                   // Memory copy
    LPBYTE         lpSrc;                                   // Memory copy
    WORD           linCnt;
    DWORD          widBit;                                  // Width bit(Not include invalid size)
    DWORD          dstSiz;
    DWORD          rasSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

// Check of zero divide 2002.3.23 >>>
    if (DataBit == 0) {
        ERR(("CMYKImgCmd() 0Div-Check [DataBit=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    widBit = (DWORD)Width * DataBit - InvLeft - InvRight;

    if (Comp == Yes) {                                       // Compress
        siz = CmdCopy(CmdBuf, &ModOrgIn);                    // Original mode in

        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
            pam[0] = 0;
            pam[1] = 0;
            pam[2] = 0;
            pam[3] = 0;
            if (Frame == 1) {
                pam[0] = 255;
                Plane = PLN_CYAN;
            }
            if (Frame == 2) {
                pam[1] = 255;
                Plane = PLN_MGENTA;
            }
            if (Frame == 3) {
                pam[2] = 255;
                Plane = PLN_YELLOW;
            }
            if (Frame == 0) {
                pam[3] = 255;
                Plane = PLN_BLACK;
            }
            siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

            siz += PlaneCmdStore(pdevobj, CmdBuf + siz, Plane);
        }
        siz += CmdCopy(CmdBuf + siz, &ModOrgOut);           // Original mode out
        if (siz != 0) {                                     // There are data for spoolH

            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }
        pam[0] = XPos_P;
        siz = CmdStore(CmdBuf, &PosAbsHrz, pam);
        pam[0] = YPos_P;
        siz += CmdStore(CmdBuf + siz, &PosAbsVtc, pam);
        if (siz != 0) {                                     // There are data for spool
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }

        if (RasterImgCmd(pdevobj, pOEM->iCompress, Width, Height,
                         WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit, lpTmp) == No) {
            // Not compress because compress rate is poor
            BitImgImgCmd(pdevobj, Width, Height, WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit);
        }
    }

    if (Comp == No) {                                        // Not compress
        pam[2] = 0;
        pam[3] = Frame;
        pam[4] = DataBit;
        pam[5] = HIWORD(XPos);
        pam[6] = LOWORD(XPos);
        pam[7] = HIWORD(YPos);
        pam[8] = LOWORD(YPos);
        pam[10] = Height;
        if (InvLeft == 0 && InvRight == 0) {                 // Not include invalid size
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = WidthByte * Height;                     // Data byte size (low byte)
            pam[9] = Width;
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            WRITESPOOLBUF(pdevobj, lpBit, pam[1]);
        } else {                                             // Include invalid size
            widByt = (WORD)((widBit + 7) / 8);
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = widByt * Height;                        // Data byte size (low byte)
            pam[9] = (WORD)(widBit / DataBit);
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            for (linCnt = 0; linCnt < Height; linCnt++) {    // Spool bitmap data by 1 line
                WRITESPOOLBUF(pdevobj, lpBit + (WORD)(InvLeft / 8), widByt);
                lpBit += WidthByte;
            }
        }
    }
    return;
}


//===================================================================================================
//    Copy command buffer
//===================================================================================================
WORD CmdCopy(
    LPBYTE         lpDst,
    LPCMDDEF       lpCmdInf
)
{
    WORD           siz;
    LPBYTE         lpCmd;

    lpCmd = lpCmdInf->Cmd;
    for (siz = 0; siz < lpCmdInf->Size; siz++) {
        lpDst[siz] = lpCmd[siz];
    }
    return siz;
}


//===================================================================================================
//    Copy command data
//===================================================================================================
WORD CmdStore(
    LPBYTE         lpDst,
    LPCMDDEF       CmdInf,
    LPINT          lpPam
)
{
    LPBYTE         lpCmd;
    BYTE           cmdDat;
    WORD           cmdCnt;
    WORD           setCnt;
    WORD           pamCnt;
    WORD           upmDat;
    int            pamDat;
    DWORD          dDat;
    LONG           lDat;

    setCnt = 0;
    pamCnt = 0;
    lpCmd = CmdInf->Cmd;
    for (cmdCnt = 0; cmdCnt < CmdInf->Size; cmdCnt++) {     // Copy
        cmdDat = *lpCmd++;
        if (cmdDat != '%') {
            lpDst[setCnt++] = cmdDat;
        } else {
            cmdCnt++;
            switch (cmdDat = *lpCmd++) {                    // Type
                case 'u':
                    setCnt += USINTtoASC(&lpDst[setCnt], (WORD)lpPam[pamCnt++]);
                    break;
                case 'd':
                    setCnt += INTtoASC(&lpDst[setCnt], lpPam[pamCnt++]);
                    break;
#if 0   /* 441435: Currently Not used */
                case 'y':
                    upmDat = (WORD)lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat / 100));
                    }
                    if ((upmDat % 100) != 0) {
                        lpDst[setCnt++] = '.';

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat % 100));
                    }
                    break;
                case 'z':
                    pamDat = lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += INTtoASC(&lpDst[setCnt], (pamDat / 100));
                    }
                    if ((pamDat % 100) != 0) {
                        lpDst[setCnt++] = '.';
                        if (pamDat < 0) {
                            pamDat = 0 - pamDat;
                        }

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(pamDat % 100));
                    }
                    break;
#endif   /* 441435: Currently Not used */
                case 'w':
                    dDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += USLONGtoASC(&lpDst[setCnt], dDat);
                    pamCnt += 2;
                    break;
                case 'l':
                    lDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += LONGtoASC(&lpDst[setCnt], lDat);
                    pamCnt += 2;
                    break;
#if 0   /* 441435: Currently Not used */
                case 'b':
                    lpDst[setCnt++] = (BYTE)lpPam[pamCnt++];
                    break;
#endif   /* 441435: Currently Not used */
                case '%':
                    lpDst[setCnt++] = cmdDat;
                    break;
            }
        }
    }
    return setCnt;
}


//===================================================================================================
//    int -> ascii
//===================================================================================================
WORD INTtoASC(
    LPBYTE         lpDst,
    int            Dat                                      // Conversion data
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (int)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    usint -> ascii
//===================================================================================================
WORD USINTtoASC(
    LPBYTE         lpDst,
    WORD           Dat
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    long -> ascii
//===================================================================================================
WORD LONGtoASC(
    LPBYTE         lpDst,
    LONG           Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (LONG)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    uslong -> ascii
//===================================================================================================
WORD USLONGtoASC(
    LPBYTE         lpDst,
    DWORD          Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn46res\prnctl.h ===
//***************************************************************************************************
//    PRNCTL.H
//
//    C Header(Functions of controlling printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Plane
//---------------------------------------------------------------------------------------------------
#define    PLN_CYAN        0x8000
#define    PLN_MGENTA      0x4000
#define    PLN_YELLOW      0x2000
#define    PLN_BLACK       0x1000

#define    PLN_ALL            (PLN_CYAN | PLN_MGENTA | PLN_YELLOW | PLN_BLACK)

//---------------------------------------------------------------------------------------------------
//    Structure of spooling bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    CMYK        Color;                                      // CMYK
    WORD        Diz;                                        // Type of dithering
    POINT       DrawPos;                                    // Start position of spooling
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // bitamp data
} DRWBMP, FAR *LPDRWBMP;

//---------------------------------------------------------------------------------------------------
//    Structure of spooling CMYK bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    WORD        Frame;                                      // Frame
    WORD        DataBit;                                    // Databit
    POINT       DrawPos;                                    // Start position of spool
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // Bitmap data
} DRWBMPCMYK, FAR *LPDRWBMPCMYK;


//***************************************************************************************************
//     Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(PDEVOBJ, LPDRWBMP);

//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(PDEVOBJ, LPDRWBMPCMYK);

// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\coldef.h ===
//***************************************************************************************************
//    COLDEF.H
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Structure for RGB Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Blu;                                        // Density 0 to 255
    BYTE        Grn;                                        // 
    BYTE        Red;                                        // 
} RGBS, *LPRGB;

//---------------------------------------------------------------------------------------------------
//    Structure for CMYK Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Cyn;                                        // Density 0 tot 255
    BYTE        Mgt;                                        // 
    BYTE        Yel;                                        // 
    BYTE        Bla;                                        // 
} CMYK, *LPCMYK;

//---------------------------------------------------------------------------------------------------
//    Color number
//---------------------------------------------------------------------------------------------------
#define    BLACK           0
#define    YELLOW          1
#define    MGENTA          2
#define    CYAN            3

//---------------------------------------------------------------------------------------------------
//    Magnification
//---------------------------------------------------------------------------------------------------
typedef struct {
    UINT    Nrt;                                            // Numerator
    UINT    Dnt;                                            // Denominator
} MAG, FAR *LPMAG;

// End of COLDEF.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\comdiz.h ===
//***************************************************************************************************
//    COMDIZ.H
//
//    C Header (Functions of dither and color matching (For N5-XX1 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    DLL file name
//---------------------------------------------------------------------------------------------------
#if defined(CASIO)
#if defined(COLPRINTER)
    #define N403_DIZDLL     TEXT("CPN4DT32.DLL")
#else
    #define N403_DIZDLL     TEXT("CP70DT32.DLL")
#endif
#else
#if defined(MINOLTA)
    #define N403_DIZDLL     TEXT("MWXDT32.DLL")
#endif
#endif

#define N501_DIZDLL         TEXT("CPN5DT32.DLL")
#define E800_DIZDLL         TEXT("CP80DT32.DLL")

//---------------------------------------------------------------------------------------------------
//    Error code (N501 Only)
//---------------------------------------------------------------------------------------------------
#define ERRNON              0                               // Normal completion
#define ERRILLPRM           1                               // Invalid paramater
#define ERRDIZHED           2                               // Dither  Invalid Header
#define ERRDIZNON           3                               // Dither  Not found
#define ERRDIZSLS           4                               // Dither  Invalid Threshold sizes
#define ERRDIZSIZ           5                               // Dither  Invalid X/Y size
#define ERRDIZADJ           6                               // Dither  Invalid Adjustment value

//---------------------------------------------------------------------------------------------------
//    Color / Mono mode
//---------------------------------------------------------------------------------------------------
#define CMMCOL              0                               // Color
#define CMMMON              1                               // Mono

//---------------------------------------------------------------------------------------------------
//    Engine kind
//---------------------------------------------------------------------------------------------------
#define ENG621              0                               // IX-621
#define ENG516              1                               // IX-516

//---------------------------------------------------------------------------------------------------
//    Printer mode  *1:N501 Only  *2:CP-E8000 Only
//---------------------------------------------------------------------------------------------------
#define PRM302              0                               // 300DPI     2value
#define PRM316              1                               // 300DPI    16value
#define PRM602              2                               // 600DPI     2value
#define PRM604              3                               // 600DPI     4value
#define PRM616              4                               // 600DPI    16value  *1
#define PRM122              5                               // 1200DPI    2value  *2

//---------------------------------------------------------------------------------------------------
//    Color matching mode
//---------------------------------------------------------------------------------------------------
#define MCHFST              0                               // LUT First
#define MCHNML              1                               // LUT Normal
#define MCHSLD              2                               // No (Solid)
#define MCHPRG              3                               // Primary color (progressive)
#define MCHMON              4                               // Monochrome

//---------------------------------------------------------------------------------------------------
//    Printer model (CP70 Only)
//---------------------------------------------------------------------------------------------------
#define CP7100_MON          0                               // Mono printer(CP-7100)
#define CP7200_MON          1                               // Mono printer(CP-7200)
#define CP7300_MON          2                               // Mono printer(CP-7300)
#define CP7400_MON          3                               // Mono printer(CP-7400)
#define CP7500_MON          4                               // Mono printer(CP-7500)

//---------------------------------------------------------------------------------------------------
//    Black Tonaer replacement mode
//---------------------------------------------------------------------------------------------------
#define KCGNON              0                               // No
#define KCGBLA              1                               // Black (RGB=0)
#define KCGGRY              2                               // Glay  (R=G=B)

//---------------------------------------------------------------------------------------------------
//    UCR mode
//---------------------------------------------------------------------------------------------------
#define UCRNOO              0                               // No
#define UCR001              1                               // UCR (TypeT)
#define UCR002              2                               // UCR (TypeU)

//---------------------------------------------------------------------------------------------------
//    LUT mode (N501 Only)
//---------------------------------------------------------------------------------------------------
#define LUT_XD              0                               // Brightness
#define LUT_YD              1                               // Tincture
#define LUT_XL              2                               // Brightness(linear)
#define LUT_YL              3                               // Tincture(linear)

//---------------------------------------------------------------------------------------------------
//    Dither mode (N501 Only)
//---------------------------------------------------------------------------------------------------
#define KNDCHR              0                               // Text / Graphic
#define KNDIMG              1                               // Image

//---------------------------------------------------------------------------------------------------
//    Dither Pattern
//---------------------------------------------------------------------------------------------------
#define DIZCHA              0                               // Text / Graphic        *
#define DIZSML              1                               // Small
#define DIZMID              2                               // middle
#define DIZRUG              3                               // Rough
#define DIZGOS              4                               // Error dispersion      *
#define DIZSTO              5                               // Random number

//---------------------------------------------------------------------------------------------------
//    Dither pattern Tone (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
#define ALLDIZNUM           64                              // All dither nuber
#define DIZSPC              4                               // Dithering interval

//---------------------------------------------------------------------------------------------------
//    Necessary size of each table(Byte) (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
// N403
#define DIZSIZ_B1           (34 * 34)                       // Dither table size(2value)
#define DIZSIZ_B2           (34 * 34 * 3)                   // Dither table size(4value)
#define DIZSIZ_B4           (12 * 12 * 15)                  // Dither table size(16value)
// N4
#define DIZSIZ_CM           (17 * 17)                       // Dither table size(CM)
#define DIZSIZ_YK           (16 * 16)                       // Dither table size(YK)
// CP70
#define DIZSIZ              (32 * 32)                       // Dither table size

//---------------------------------------------------------------------------------------------------
//    LUT table RBG -> CMYK (old version)
//---------------------------------------------------------------------------------------------------
// N4/N403/CP70
#define GLDNUM              32                              // Table grid number
#define GLDSPC              8                               // Table grid interval
#define LUTSIZ              ((DWORD)GLDNUM * GLDNUM * GLDNUM)// LUT size(*CMYK=128k)
#define LUTTBLSIZ           ((DWORD)LUTSIZ * sizeof(CMYK))
// N501
#define GLDNUM016           16                              // Table grid number
#define GLDNUM032           32                              // Table grid number
#define LUTSIZ016           GLDNUM016 * GLDNUM016 * GLDNUM016   // LUT size
#define LUTSIZ032           GLDNUM032 * GLDNUM032 * GLDNUM032   // LUT size
#define LUTSIZRGB           LUTSIZ016 * sizeof(RGBS)        // LUT size
#define LUTSIZCMY           LUTSIZ016 * sizeof(CMYK)        // LUT size

//---------------------------------------------------------------------------------------------------
//    Color transformation table (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
#define TNRTBLSIZ           256                             // Toner density table size
#define CCHRGBSIZ           (CCHTBLSIZ * sizeof(RGBS))      // Cache table size(RGB)
#define CCHCMYSIZ           (CCHTBLSIZ * sizeof(CMYK))      // Cache table size(CMYK)

//---------------------------------------------------------------------------------------------------
//    Cashe table size
//---------------------------------------------------------------------------------------------------
#define CCHTBLSIZ           256                             // Cache table size

//---------------------------------------------------------------------------------------------------
//    Work area size (N501 Only)
//---------------------------------------------------------------------------------------------------
#define LUTGLBWRK           32768                           // Sum LUT work area size
#define LUT032WRK           32768                           // First LUT work area size
#define DIZINFWRK           32768                           // Dither work area size

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Color designated table structure (N501 Only)
//===================================================================================================
typedef struct {
    BYTE            Red;                                    // Red   (0 to 255)
    BYTE            Grn;                                    // Green (0 to 255)
    BYTE            Blu;                                    // Blue  (0 to 255)
    BYTE            Cyn;                                    // Cyan    (0 to 255)
    BYTE            Mgt;                                    // Magenta (0 to 255)
    BYTE            Yel;                                    // Yellow  (0 to 255)
    BYTE            Bla;                                    // Black   (0 to 255)
} COLCOLDEF, FAR* LPCOLCOLDEF;

//===================================================================================================
//    RGB Color Control structure
//===================================================================================================
typedef struct {
    LONG            Lgt;                                    // brightness   (-100 to 100)
    LONG            Con;                                    // Contrast     (-100 to 100)
    LONG            Crm;                                    // Chroma       (-100 to 100)
    LONG            Gmr;                                    // Gamma(R)     (1 to 30)
    LONG            Gmg;                                    // Gamma(G)     (1 to 30)
    LONG            Gmb;                                    // Gamma(B)     (1 to 30)
    LPBYTE          Dns;                                    // Toner density table [DNSTBLSIZ]
    LONG            DnsRgb;                                 // RGB density  (-30 to 30)
} RGBINF, FAR* LPRGBINF;

//===================================================================================================
//    CMYK Color Control structure
//===================================================================================================
typedef struct {
    LONG            Viv;                                    // Vivid        (-100 to 100)
    LPBYTE          Dns;                                    // Toner density table [DNSTBLSIZ]
    LONG            DnsCyn;                                 // Toner density(C) (-30 to 30)
    LONG            DnsMgt;                                 // Toner density(M) (-30 to 30)
    LONG            DnsYel;                                 // Toner density(Y) (-30 to 30)
    LONG            DnsBla;                                 // Toner density(K) (-30 to 30)
} CMYKINF, FAR* LPCMYKINF;

//===================================================================================================
//    Color Matching information structure  *N4/N403/CP70
//===================================================================================================
typedef struct {
    DWORD           Mch;                                    // Color Matching       def
    DWORD           Bla;                                    // Black replacement    def
    DWORD           Ucr;                                    // UCR                  def
    DWORD           UcrCmy;                                 // UCR (UCR quantity)
    DWORD           UcrBla;                                 // UCR (Ink version generation quantity)
    DWORD           UcrTnr;                                 //+UCR (Toner gross weight)   CASIO 2001/02/15
    LPCMYK          UcrTbl;                                 // UCR table
    LPBYTE          GryTbl;                                 // Gray transfer table
    DWORD           LutGld;                                 // LUT Grid number          *
    LPCMYK          LutAdr;                                 // LUT address
    DWORD           ColQty;                                 // Color designated number
    LPCOLCOLDEF     ColAdr;                                 // Color designated table
    LPRGB           CchRgb;                                 // RGB Cache table[CCHTBLSIZ]
    LPCMYK          CchCmy;                                 // CMYK Cache table[CCHTBLSIZ]
} COLMCHINF, FAR* LPCOLMCHINF;

//===================================================================================================
//    Dither pattern information structure  *1:N4/N403/CP70  *2:N501(IX-621)/CP-E8000(IX-516)
//===================================================================================================
#ifndef LPSHORT
typedef SHORT FAR*  LPSHORT;
#endif
typedef struct {
    DWORD           ColMon;                                 // Color mode           def
    DWORD           PrnMod;                                 // DPI / TONE           def
    DWORD           PrnEng;                                 // Engin kind           def  *2
    DWORD           PrnKnd;                                 // Printer(Mono only)        *1
    DWORD           DizKnd;                                 // Dither kind          def
    DWORD           DizPat;                                 // Dither pattern       def
    DWORD           DizSls;                                 // Dither pattern Threshold
    DWORD           SizCyn;                                 // Dither pattern size Cyan
    DWORD           SizMgt;                                 // Dither pattern size Magenta
    DWORD           SizYel;                                 // Dither pattern size Yellow
    DWORD           SizBla;                                 // Dither pattern size Black
    LPBYTE          TblCyn;                                 // Dither pattern table Cyan
    LPBYTE          TblMgt;                                 // Dither pattern table Magenta
    LPBYTE          TblYel;                                 // Dither pattern table Yellow
    LPBYTE          TblBla;                                 // Dither pattern table Black
} DIZINF, FAR* LPDIZINF;

//===================================================================================================
//    Drawing information structure
//===================================================================================================
typedef struct {
    DWORD           XaxSiz;                                 // X Pixel size
    DWORD           StrXax;                                 // Start position for drawing X(dot)
    DWORD           StrYax;                                 // Start position for drawing Y(dot)
    DWORD           XaxNrt;                                 // X Magnification numerator
    DWORD           XaxDnt;                                 // X Magnification denominator
    DWORD           YaxNrt;                                 // Y Magnification numerator
    DWORD           YaxDnt;                                 // Y Magnification denominator
    DWORD           XaxOfs;                                 // X Offset
    DWORD           YaxOfs;                                 // Y Offset
    DWORD           LinDot;                                 // Destination, 1 line dot number
    DWORD           LinByt;                                 // Destination, 1 line byte number
    LPCMYK          CmyBuf;                                 // CMYK data buffer
    LPBYTE          LinBufCyn;                              // Line buffer(C)
    LPBYTE          LinBufMgt;                              // Line buffer(M)
    LPBYTE          LinBufYel;                              // Line buffer(Y)
    LPBYTE          LinBufBla;                              // Line buffer(K)
    DWORD           AllLinNum;                              // Housing line number
} DRWINF, FAR* LPDRWINF;

//===================================================================================================
//    Error dispersion information structure
//===================================================================================================
typedef struct {
    struct {
        DWORD       Num;                                    // Current table array number(0 to 1)
        DWORD       Siz[2];                                 // Data table size
        DWORD       Yax[2];                                 // Setting data table Y coordinate
        LPSHORT     Tbl[2][2];                              // Data table
    } GosRGB;
    struct {                                                // Error dispersion table information(CMYK)
        DWORD       Num;                                    // Current table array number(0 to 1)
        DWORD       Siz[2];                                 // Data table size
        DWORD       Yax[2];                                 // Setting data table Y coordinate
        LPSHORT     Tbl[2][2];                              // Data table
    } GosCMYK;
} GOSINF, FAR* LPGOSINF;

// End of COMDIZ.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\colmatch.c ===
//***************************************************************************************************
//    COLMATCH.C
//
//    Functions of color matching
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    "PRNCTL.H"
#include    "strsafe.h"    // Security-Code 2002.3.6


//---------------------------------------------------------------------------------------------------
//    Byte/Bit table
//---------------------------------------------------------------------------------------------------
static const BYTE BitTbl[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

//---------------------------------------------------------------------------------------------------
//    Define LUT file name
//---------------------------------------------------------------------------------------------------
#define N501LUTR    L"CPN5RGB.LT3"                          // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define Dither file name
//---------------------------------------------------------------------------------------------------
#define N501DIZ     L"CPN5NML.DIZ"                          // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define DLL name
//---------------------------------------------------------------------------------------------------
#define CSN5RESDLL    L"CSN5RES.DLL"                        // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define data
//---------------------------------------------------------------------------------------------------
#define DPI300    300
#define DPI600    600

static BYTE ORG_MODE_IN[]     = "\x1Bz\xD0\x01";
static BYTE ORG_MODE_OUT[]    = "\x1Bz\x00\x01";
static BYTE PALETTE_SELECT[]  = "Cd,%d,%d*";
static BYTE PLANE_RESET[]     = "Da,0,0,0,0*";

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static BOOL BmpBufAlloc(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBMPBIF);
static void BmpBufFree(LPBMPBIF);
static void BmpBufClear(LPBMPBIF);
static void BmpPrint(PDEVOBJ, LPBMPBIF, POINT, WORD, WORD, WORD);
static void BmpRGBCnv(LPRGB, LPBYTE, WORD, WORD, WORD, LPRGBQUAD);

static BOOL ColMchInfSet(PDEVOBJ);
static BOOL DizInfSet(PDEVOBJ);
static UINT GetDizPat(PDEVOBJ);
static BOOL DizFileOpen(PDEVOBJ, LPDIZINF);
static BOOL ColUcrTblMak(PDEVOBJ, LPCMYK);
static BOOL ColGryTblMak(PDEVOBJ, LPCMYK);
static BOOL ColLutMakGlbMon(PDEVOBJ);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    LPBYTE          lpColIF;                                // N5 Color Matching information
    LPRGBINF        lpRGBInfImg;                            // RGB Color change information
    LPCMYKINF       lpCMYKInfImg;                           // CMYK Color information
    UINT            num001;
    SHORT           KToner;
    DWORD           allocSize;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ColMatchInit() Start *****\n"));

    pOEM->Col.Mch.Mode       = pOEM->iColorMatching;
    pOEM->Col.Mch.Diz        = pOEM->iDithering;
    pOEM->Col.Mch.Bright     = 0;                           // 0 fixed
    pOEM->Col.Mch.Contrast   = 0;                           // 0 fixed
    pOEM->Col.Mch.GamRed     = 10;                          // Color balance(R) : 10 fixed
    pOEM->Col.Mch.GamGreen   = 10;                          // Color balance(G) : 10 fixed
    pOEM->Col.Mch.GamBlue    = 10;                          // Color balance(B) : 10 fixed
    pOEM->Col.Mch.Speed      = pOEM->iBitFont;
    pOEM->Col.Mch.LutNum     = 0;                           // LUT table number

    MY_VERBOSE(("CMINit ENT Tn=%d Col=%d Mod=%d DZ=%d Cyk=%d Sp=%d Prt=%d\n", pOEM->iTone, pOEM->iColor, 
         pOEM->Col.Mch.Mode,pOEM->Col.Mch.Diz,pOEM->Col.Mch.CmyBlk,pOEM->Col.Mch.Speed,pOEM->Printer));

    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if ((lpColIF = MemAllocZ(                           // RGB Color change/Color Matching/Dither pattern Information
            (DWORD)((sizeof(RGBINF) + sizeof(CMYKINF) + sizeof(COLMCHINF) + sizeof(DIZINF))))) == NULL) {
            ERR(("Init Alloc ERROR!!\n"));
            return 0;
        }
        pOEM->Col.lpColIF = lpColIF;                        // RGB Color change/Color Matching/Dither pattern Information
        pOEM->Col.Mch.lpRGBInf  = (LPRGBINF)lpColIF;    lpColIF += sizeof(RGBINF);
        pOEM->Col.Mch.lpCMYKInf = (LPCMYKINF)lpColIF;   lpColIF += sizeof(CMYKINF);
        pOEM->Col.Mch.lpColMch  = (LPCOLMCHINF)lpColIF; lpColIF += sizeof(COLMCHINF);
        pOEM->Col.Mch.lpDizInf  = (LPDIZINF)lpColIF;    lpColIF += sizeof(DIZINF);
        MY_VERBOSE(("ColMatchInit() MemAllocZ(lpColIF)\n"));

        pOEM->Col.wReso = (pOEM->iResolution == XX_RES_300DPI) ? DPI300 : DPI600;
        MY_VERBOSE(("ColMatchInit() pOEM->Col.wReso[%d] \n", pOEM->Col.wReso));

        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {               // Color?
            pOEM->Col.ColMon = CMMCOL;                      // Color
        } else {
            pOEM->Col.ColMon = CMMMON;                      // Monochrome
        }
        MY_VERBOSE(("ColMatchInit() pOEM->Col.ColMon[%d] \n", pOEM->Col.ColMon));

        if (pOEM->Col.ColMon == CMMCOL) {                   // Color?
            if (pOEM->Col.wReso == DPI300) {                // 300DPI?
                if (pOEM->iColor == XX_COLOR_SINGLE) {
                    pOEM->Col.Dot = XX_TONE_2;
                } else {
                    pOEM->Col.Dot = XX_TONE_16;
                }
            } else {                                        // 600DPI?
                if (pOEM->iColor == XX_COLOR_SINGLE) {
                    pOEM->Col.Dot = XX_TONE_2;
                } else if (pOEM->iColor == XX_COLOR_MANY) {
                    pOEM->Col.Dot = XX_TONE_4;
                } else {
                    pOEM->Col.Dot = XX_TONE_16;
                }
            }
            MY_VERBOSE(("ColMatchInit() Col.Dot[%d] \n", pOEM->Col.Dot));

            if (pOEM->Col.wReso == DPI300) {                // 300DPI?
                if (pOEM->Col.Dot == XX_TONE_2) {           // 2value?
                    CM_VERBOSE(("N5_MOD_300_TONE_2\n"));
                    pOEM->Col.DatBit = 1; pOEM->Col.BytDot = 8;
                } else {                                    // 16value
                    CM_VERBOSE(("N5_MOD_300_TONE_16\n"));
                    pOEM->Col.DatBit = 4; pOEM->Col.BytDot = 2;
                }
            } else {                                        // 600DPI
                if (pOEM->Col.Dot == XX_TONE_2) {           // 2value?
                    CM_VERBOSE(("N5_MOD_600_TONE_2\n"));
                    pOEM->Col.DatBit = 1; pOEM->Col.BytDot = 8;
                } else if (pOEM->Col.Dot == XX_TONE_4) {    // 4value?
                    CM_VERBOSE(("N5_MOD_600_TONE_4\n"));
                    pOEM->Col.DatBit = 2; pOEM->Col.BytDot = 4;
                } else {                                    // 16value?
                    CM_VERBOSE(("N5_MOD_600_TONE_16\n"));
                    pOEM->Col.DatBit = 4; pOEM->Col.BytDot = 2;
                }
            }
        }
        MY_VERBOSE(("ColMatchInit() DatBit[%d] BytDot[%d]\n", pOEM->Col.DatBit, pOEM->Col.BytDot));
                                                            // Color Matching setting
        pOEM->Col.Mch.CmyBlk = Yes;                         // Black replacement
        pOEM->Col.Mch.GryKToner = No;                       // Gray black toner print
        pOEM->Col.Mch.Ucr = UCRNOO;                         // UCR No
        pOEM->Col.Mch.KToner = pOEM->iCmyBlack;             // Black toner usage

        switch (pOEM->iCmyBlack) {
            case XX_CMYBLACK_GRYBLK:
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = Yes;
                pOEM->Col.Mch.Ucr = UCR001;                 //+CASIO 2001/02/15
                break;
            case XX_CMYBLACK_BLKTYPE1:
                pOEM->Col.Mch.Ucr = UCR001;
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_BLKTYPE2:
                pOEM->Col.Mch.Ucr = UCR002;
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_BLACK:
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_TYPE1:
                pOEM->Col.Mch.Ucr = UCR001;
                pOEM->Col.Mch.CmyBlk = No;
                break;
            case XX_CMYBLACK_TYPE2:
                pOEM->Col.Mch.Ucr = UCR002;
                pOEM->Col.Mch.CmyBlk = No;
                break;
            case XX_CMYBLACK_NONE:
                pOEM->Col.Mch.CmyBlk = No;
                break;
            default:
                break;
        }
        MY_VERBOSE(("ColMatchInit() Mch.CmyBlk[%d] Mch.KToner[%d] Mch.Ucr[%d] \n", 
                 pOEM->Col.Mch.CmyBlk, pOEM->Col.Mch.KToner, pOEM->Col.Mch.Ucr));

        pOEM->Col.Mch.PColor = No;                          // Primary color processing ?
        pOEM->Col.Mch.Tnr = 0;                              // Depth of color(Tonor)
        pOEM->Col.Mch.SubDef = Yes;                         // Not change setting of color balance, bright and contrast ?
        pOEM->Col.Mch.LutMakGlb = No;                       // Global LUT make ?

        pOEM->Col.Mch.CchMch = (UINT)-1;                    // Cache initialize
        pOEM->Col.Mch.CchCnv = (UINT)-1;
        pOEM->Col.Mch.CchRGB.Red = 255;
        pOEM->Col.Mch.CchRGB.Grn = 255;
        pOEM->Col.Mch.CchRGB.Blu = 255;

        lpRGBInfImg = pOEM->Col.Mch.lpRGBInf;               // RGB Color change information
        lpRGBInfImg->Lgt = 0;                               //  0 fixed Brightness adjustment
        lpRGBInfImg->Con = 0;                               //  0 fixed Contrast adjustment
        lpRGBInfImg->Crm = 0;                               //  0 fixed Chroma adjustment
        lpRGBInfImg->Gmr = 10;                              // 10 fixed Color balance(Gamma revision)(Red)
        lpRGBInfImg->Gmg = 10;                              // 10 fixed Color balance(Gamma revision)(Green)
        lpRGBInfImg->Gmb = 10;                              // 10 fixed Color balance(Gamma revision)(Blue)
        lpRGBInfImg->Dns = NULL;                            // NULL fixed Toner density table
        lpRGBInfImg->DnsRgb = 0;                            //  0 fixed RGB density

        lpCMYKInfImg = pOEM->Col.Mch.lpCMYKInf;             // CMYK Color change information
        if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {      // Vivid?
            lpCMYKInfImg->Viv = 20;
        }
        lpCMYKInfImg->Dns  = NULL;                          // NULL fixed Toner density table
        lpCMYKInfImg->DnsCyn = 0;                           //  0 fixed Depth of color(Cyan)
        lpCMYKInfImg->DnsMgt = 0;                           //  0 fixed Depth of color(Magenta)
        lpCMYKInfImg->DnsYel = 0;                           //  0 fixed Depth of color(Yellow)
        lpCMYKInfImg->DnsBla = 0;                           //  0 fixed Depth of color(Black)

        MY_VERBOSE(("ColMatchInit() ColMchInfSet()\n"));
        if (ColMchInfSet(pdevobj) == FALSE) {               // Color Matching information setting
            return 0;
        }

        MY_VERBOSE(("ColMatchInit() DizInfSet()\n"));
        if (DizInfSet(pdevobj) == FALSE) {                  // Dither pattern information setting
            return 0;
        }
                                                            // RGB convert area (*Temp area)
        if ((pOEM->Col.lpTmpRGB = MemAlloc(sizeof(RGBS))) == NULL) {
            return 0;
        }
                                                            // CMYK convert area (*Temp area)
        allocSize = (pOEM->iColor != XX_MONO) ? sizeof(CMYK) : 1;
        if ((pOEM->Col.lpTmpCMYK = MemAlloc(allocSize)) == NULL) {
            return 0;
        }
                                                            // Draw information (*Temp area)
        if ((pOEM->Col.lpDrwInf = MemAlloc(sizeof(DRWINF))) == NULL) {
            return 0;
        }
    }

    return TRUE;
}

//===================================================================================================
//    Disable the color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchDisable(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    UINT            num001;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ColMatchDisable() Start\n"));
    if (pOEM->Col.lpLut032 != NULL) {                       // Free LUT32GRID
        MemFree(pOEM->Col.lpLut032);
    }
    if (pOEM->Col.lpUcr != NULL) {                          // Free UCR table
        MemFree(pOEM->Col.lpUcr);
    }
    if (pOEM->Col.lpLutMakGlb != NULL) {                    // Free LUTMAKGLG
        MemFree(pOEM->Col.lpLutMakGlb);
    }
    if (pOEM->Col.lpGryTbl != NULL) {                       // Free Gray transfer table
        MemFree(pOEM->Col.lpGryTbl);
    }

    if (pOEM->Col.lpColIF  != NULL) {                       // Free RGB Color change/Color Matching/Dither pattern Information
        MemFree(pOEM->Col.lpColIF);
    }
    if (pOEM->Col.LutTbl != NULL) {                         // Free Look-up table buffer
        MemFree(pOEM->Col.LutTbl);
    }
    if (pOEM->Col.CchRGB != NULL) {                         // Free Cache table for RGB
        MemFree(pOEM->Col.CchRGB);
    }
    if (pOEM->Col.CchCMYK != NULL) {                        // Free Cache table for CMYK
        MemFree(pOEM->Col.CchCMYK);
    }
    for (num001 = 0; num001 < 4; num001++) {                // Free Dither pattern table
        if (pOEM->Col.DizTbl[num001] != NULL) {
            MemFree(pOEM->Col.DizTbl[num001]);
        }
    }
    if (pOEM->Col.lpTmpRGB != NULL) {                       // Free RGB convert area (*Temp area)
        MemFree(pOEM->Col.lpTmpRGB);
    }
    if (pOEM->Col.lpTmpCMYK != NULL) {                      // Free CMYK convert area (*Temp area)
        MemFree(pOEM->Col.lpTmpCMYK);
    }
    if (pOEM->Col.lpDrwInf != NULL) {                       // Free Draw information (*Temp area)
        MemFree(pOEM->Col.lpDrwInf);
    }

    MY_VERBOSE(("ColMatchDisable() End\n"));
    return TRUE;
}

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBmp,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    PIPPARAMS           pIPParams)
{

    BMPBIF      bmpBuf;                             // BMPBIF structure
    POINT       drwPos;                             // Start position for spooling
    WORD        dstWByt;                            // X size of destination bitmap data
    LONG        dstX;                               // X coordinates of destination bitmap data
    LONG        dstY;                               // Y coordinates of destination bitmap data
    LONG        dstYEnd;                            // The last Y coordinates(+1) of destination bitmap data
    WORD        dstScn;                             // Number of destination bitmap data lines
    WORD        srcY;                               // Y coordinates of source bitmap data
    LONG        srcWByt;                            // Y size of source bitmap data
    MAG         xMag;                               // X magnification
    MAG         yMag;                               // Y magnification
    POINT       pos;                                // Start position for drawing
    POINT       off;                                // coordinates of source bitmap data
    WORD        setCnt;                             // count
    LPCMYK      lpCMYK;                             // CMYK temporary data buffer
    LPRGB       lpRGB;                              // RGB temporary data buffer
    BYTE        Cmd[64];
    WORD        wlen;
    LPSTR       pDestEnd;     // 2002.3.6
    size_t      szRemLen;     // 2002.3.6
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ImagePro DIBtoPrn() Start\n"));
    MY_VERBOSE(("ImagePro ENTRY Dx=%d Dy=%d SxSiz=%d SySiz=%d BC=%d Sz=%d\n", 
             pIPParams->ptOffset.x, pIPParams->ptOffset.y,
             pBitmapInfoHeader->biWidth, pBitmapInfoHeader->biHeight, pBitmapInfoHeader->biBitCount,
             pIPParams->dwSize));

    // Initialization of
    // RGB buffer            :(X size of source bitmap data) * 3
    // CMYK buffer           :(X size of source bitmap data) * 4
    // CMYK bit buffer       :((X size of source bitmap data) * (Magnification of X) + 7) / 8 * (Y size of source bitmap data) * (Magnification of Y))
    memset(&bmpBuf, 0x00, sizeof(BMPBIF));
    MY_VERBOSE(("ImagePro BmpBufAlloc()\n"));

    if (BmpBufAlloc(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)pBitmapInfoHeader->biHeight, 0, 0, 1, 1, 1, 1, &bmpBuf) == FALSE) {
        ERR(("Alloc ERROR!!\n"));
        return FALSE;
    }

    bmpBuf.Diz = pOEM->iDithering;
    bmpBuf.Style = 0;
    bmpBuf.DatBit = pOEM->Col.DatBit;

    dstWByt = (WORD)((pBitmapInfoHeader->biWidth + pOEM->Col.BytDot - 1) / pOEM->Col.BytDot);

    srcWByt = (pBitmapInfoHeader->biWidth * pBitmapInfoHeader->biBitCount + 31L) / 32L * 4L;

    drwPos.x = dstX = pIPParams->ptOffset.x;
    dstY = pIPParams->ptOffset.y;
    srcY = 0;
    dstYEnd = pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight;

    MY_VERBOSE(("ImagePro dstWByt[%d] srcWByt[%d]\n", dstWByt, srcWByt));
    MY_VERBOSE(("ImagePro dstX[%d] dstY[%d] dstYEnd[%d]\n", dstX, dstY, dstYEnd));

                                                            // Convert DIB and spool to the printer
    for (;dstY < dstYEnd;) {
        BmpBufClear(&bmpBuf);
        drwPos.y = dstY;
        MY_VERBOSE(("ImagePro drwPos.x[%d] drwPos.y[%d] Drv.Bit.Lin[%d]\n", drwPos.x, drwPos.y, bmpBuf.Drv.Bit.Lin));

        for (dstScn = 0; dstY < dstYEnd && dstScn < bmpBuf.Drv.Bit.Lin; dstScn++, dstY++) {    

            MY_VERBOSE(("ImagePro dstY[%d] dstScn[%d]\n", dstY, dstScn));
            MY_VERBOSE(("ImagePro BmpRGBCnv()\n"));
//            DUMP_VERBOSE(pSrcBmp,64);
            //----------------------------------------------------------------------------------------------------
            // Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
            BmpRGBCnv(bmpBuf.Drv.Rgb.Pnt,
                      pSrcBmp,
                      pBitmapInfoHeader->biBitCount,
                      0,
                     (WORD)pBitmapInfoHeader->biWidth,
                     (LPRGBQUAD)pColorTable);
            
            // Convert RGB=0 into RGB=1
            lpRGB = bmpBuf.Drv.Rgb.Pnt;
            if ((pOEM->iCmyBlack == XX_CMYBLACK_BLKTYPE1) 
            ||  (pOEM->iCmyBlack == XX_CMYBLACK_BLKTYPE2)) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if ((lpRGB[setCnt].Blu | lpRGB[setCnt].Grn |lpRGB[setCnt].Red) == 0) {
                        lpRGB[setCnt].Blu = 1; lpRGB[setCnt].Grn = 1; lpRGB[setCnt].Red = 1;
                    }
                }
            }
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Rgb.Pnt,64);

            MY_VERBOSE(("ImagePro ColMatching()\n"));
            //----------------------------------------------------------------------------------------------------
            // Convert RGB into CMYK
            bmpBuf.Drv.Rgb.AllWhite = (WORD)ColMatching(
                pdevobj,
                No,
                No,
                (LPRGB)bmpBuf.Drv.Rgb.Pnt,
                (WORD)pBitmapInfoHeader->biWidth,
                (LPCMYK)bmpBuf.Drv.Cmyk.Pnt);
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Cmyk.Pnt,64);

            lpCMYK = bmpBuf.Drv.Cmyk.Pnt;
            if (pOEM->iDithering == XX_DITH_NON) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if (lpCMYK[setCnt].Cyn != 0) { lpCMYK[setCnt].Cyn = 255; }
                    if (lpCMYK[setCnt].Mgt != 0) { lpCMYK[setCnt].Mgt = 255; }
                    if (lpCMYK[setCnt].Yel != 0) { lpCMYK[setCnt].Yel = 255; }
                    if (lpCMYK[setCnt].Bla != 0) { lpCMYK[setCnt].Bla = 255; }
                }
            }

            MY_VERBOSE(("ImagePro Dithering()\n"));
            //----------------------------------------------------------------------------------------------------
            pos.x = dstX; pos.y = dstY;                     // Drawing start position
            off.x = 0; off.y = 0;                           // Coordinates of source bitmap data
            xMag.Nrt = 1; xMag.Dnt = 1;                     // X magnification
            yMag.Nrt = 1; yMag.Dnt = 1;                     // Y magnification
            Dithering(
                pdevobj,
                (WORD)bmpBuf.Drv.Rgb.AllWhite,
                (WORD)pBitmapInfoHeader->biWidth,
                pos,
                off,
                xMag,
                yMag,
                (LPCMYK)bmpBuf.Drv.Cmyk.Pnt,
                (DWORD)dstWByt,
                 bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[MGENTA] + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[YELLOW] + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[BLACK]  + dstWByt * dstScn
                );
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,64);    MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[MGENTA]   + dstWByt * dstScn,64);  MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[YELLOW]   + dstWByt * dstScn,64);  MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[BLACK]   + dstWByt * dstScn,64);   MY_VERBOSE(("\n"));

            srcY++;
            pSrcBmp += srcWByt;
        }

        if (dstScn != 0) {
                                                        // Spool to printer

            MY_VERBOSE(("ImagePro BmpPrint()\n"));
            BmpPrint(pdevobj, &bmpBuf, drwPos, (WORD)pBitmapInfoHeader->biWidth, dstScn, dstWByt);
        }
    }

    // Set back palette (Palette No. is fixed  , All plane(CMYK) is OK )
    // Same as palette state before OEMImageProcessing call 
    MY_VERBOSE(("ImagePro WRITESPOOLBUF()\n"));
    WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//    wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX)) {
        BmpBufFree(&bmpBuf);
        return FALSE;
    }
    wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Cmd, wlen);
    WRITESPOOLBUF(pdevobj, PLANE_RESET, BYTE_LENGTH(PLANE_RESET));
    WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

    BmpBufFree(&bmpBuf);

    CM_VERBOSE(("ImagePro End\n\n"));

    return TRUE;
}


//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL ColMatching(                                // AllWhite?
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    UINT            PColor,                                 // 1 dot line / Char12P or less point?
    UINT            BCnvFix,                                // Black replacement fixation?(No:dialog use)
    LPRGB           lpInRGB,                                // RGB line(Input)
    UINT            MchSiz,                                 // RGB size
    LPCMYK          lpInCMYK                                // CMYK line(Output)
)
{
    LPRGB           lpRGB;                                  // RGB line
    LPCMYK          lpCMYK;                                 // CMYK line
    LPCMYKINF       lpCMYKInf;                              // CMYK Color change information
    UINT            chkCnt;                                 // RGB check counter for white
    LPCOLMCHINF     lpColMch;                               // Color Matching Information
    UINT            cMch;                                   // Color Matching type
    UINT            bCnv;                                   // Black replacement
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (MchSiz == 1) {                                      // RGB size=1 ?
        lpRGB  = pOEM->Col.lpTmpRGB;                        // RGB convert area (*Temp area)
        lpCMYK = pOEM->Col.lpTmpCMYK;                       // CMYK convert area (*Temp area)
        *lpRGB = *lpInRGB;                                  // Input RGB
    } else {
        lpRGB  = lpInRGB;                                   // RGB line
        lpCMYK = lpInCMYK;                                  // CMYK line
    }
    for (chkCnt = 0; chkCnt < MchSiz; chkCnt++) {           // check of All white
        if ((lpRGB[chkCnt].Blu & lpRGB[chkCnt].Grn & lpRGB[chkCnt].Red) != 0xff) { break; }
    }
    if (chkCnt >= MchSiz) {                                 // All white data?
        if (MchSiz == 1) {                                  // White set to CMYK
            lpInCMYK->Cyn = 0x00;
            lpInCMYK->Mgt = 0x00;
            lpInCMYK->Yel = 0x00;
            lpInCMYK->Bla = 0x00;
        }
        return Yes;                                         // All white
    }
    if (chkCnt != 0) {                                      // White data existence in the left end?
        memset(lpCMYK, 0x00, chkCnt * sizeof(CMYK));        // White set to CMYK
        (HPBYTE)lpCMYK   += chkCnt * sizeof(CMYK);          // Change of the head position of CMYK area
        (HPBYTE)lpInCMYK += chkCnt * sizeof(CMYK);          // Change of the head position of CMYK area
        (HPBYTE)lpRGB    += chkCnt * sizeof(RGBS);          // Change of the head position of RGB area
        MchSiz -= chkCnt;                                   // Change of RGB size
    }
    if (pOEM->Col.ColMon == CMMCOL) {                       // Color?
        if ((PColor == Yes && pOEM->Col.Mch.PColor == Yes) || pOEM->Col.Mch.Diz == XX_DITH_NON) {
            cMch = MCHPRG;                                  // Color Matching  progressive
        } else if (pOEM->Col.Mch.Mode == XX_COLORMATCH_NONE) {
            cMch = MCHSLD;                                  // Color Matching  Solid
        } else {
            if (pOEM->Col.Mch.Speed == Yes) {               // Color Matching  High speed?
                cMch = MCHFST;                              // Color Matching  LUT First
            } else {
                cMch = MCHNML;                              // Color Matching  LUT Normal
            }
        }

        bCnv = KCGNON;                                      // Black unreplacement(Three color toner printings of black)
        if ((pOEM->Col.Mch.CmyBlk == Yes && pOEM->Col.Mch.GryKToner == No) ||  
            (BCnvFix == Yes)) {
            bCnv = KCGBLA;                                  // Black replacement (RGB=0 -> K)
        }
        if (pOEM->Col.Mch.CmyBlk == Yes && pOEM->Col.Mch.GryKToner == Yes) {
            bCnv = KCGGRY;                                  // Black & gray replacement (R=G=B -> K)
        }

                                                            // UCR?
        if (pOEM->Col.Mch.CmyBlk == No && pOEM->Col.Mch.Ucr != UCRNOO && BCnvFix == No) {
            bCnv = KCGNON;                                  // Black unreplacement(Three color toner printings of black)
        }
        
        MY_VERBOSE(("   ColMatching  ICM USE !! [%d]\n", pOEM->iIcmMode));
        if (pOEM->iIcmMode == XX_ICM_USE && BCnvFix == No) {// ICM ?
            cMch = MCHSLD;                                  // Color Matching  Solid
            bCnv = KCGNON;                                  // Black unreplacement
        }

    } else {
        cMch = MCHMON;                                      // Color Matching MONO
        bCnv = KCGNON;                                      // Black unreplacement
    }
    if (MchSiz == 1) {
        if (pOEM->Col.Mch.CchMch   == cMch &&               // With cash information all same?
            pOEM->Col.Mch.CchCnv   == bCnv &&
            pOEM->Col.Mch.CchRGB.Red == lpRGB->Red &&
            pOEM->Col.Mch.CchRGB.Grn == lpRGB->Grn &&
            pOEM->Col.Mch.CchRGB.Blu == lpRGB->Blu) {
            *lpInCMYK = pOEM->Col.Mch.CchCMYK;              // Output CMYK setting
            return No;                                      // Existence except for white data
        } else {
            pOEM->Col.Mch.CchMch = cMch;                    // Update cache (CMYK is eliminated)
            pOEM->Col.Mch.CchCnv = bCnv;
            pOEM->Col.Mch.CchRGB = *lpRGB;
        }
    }

//  if (pOEM->Col.Mch.LutMakGlb == No && pOEM->Col.Mch.SubDef == No) {
//      ColControl(pdevobj, lpRGB, MchSiz);             // RGB Color cotrol
//  }

    lpCMYKInf = pOEM->Col.Mch.lpCMYKInf;                    // CMYK Color cotrol information

    lpColMch  = pOEM->Col.Mch.lpColMch;                     // Color Matching information
    lpColMch->Mch = (DWORD)cMch;                            // Color Matching
    lpColMch->Bla = (DWORD)bCnv;                            // Black replacement

    MY_VERBOSE(("N501_ColMchPrc()  Mch=[%d] Bla=[%d] Ucr=[%d] UcrCmy=[%d] UcrTnr=[%d] UcrBla=[%d]\n",
             lpColMch->Mch, lpColMch->Bla, lpColMch->Ucr, lpColMch->UcrCmy, lpColMch->UcrTnr, lpColMch->UcrBla));
    MY_VERBOSE(("                  LutGld=[%d] ColQty=[%d]\n",lpColMch->LutGld, lpColMch->ColQty));

    N501_ColMchPrc((DWORD)MchSiz, lpRGB, lpCMYK, lpColMch);
    if (pOEM->Col.Mch.LutMakGlb == No && (lpCMYKInf->Viv != 0 || lpCMYKInf->Dns != NULL)) {

        MY_VERBOSE(("N501_ColCtrCmy()  Viv=[%d] DnsCyn=[%d] DnsMgt=[%d] DnsYel=[%d] DnsBla=[%d]\n",
                    lpCMYKInf->Viv, lpCMYKInf->DnsCyn, lpCMYKInf->DnsMgt, lpCMYKInf->DnsYel, lpCMYKInf->DnsBla));
        N501_ColCtrCmy((DWORD)MchSiz, lpCMYK, lpCMYKInf);
    }

    if (MchSiz == 1) {                                      // RGB size=1 ?
        *lpInCMYK = *lpCMYK;                                // output CMYK setting
        pOEM->Col.Mch.CchCMYK = *lpCMYK;                    // Update cache (CMYK)
    }
    return No;                                              // Existence except for white data
}

//===================================================================================================
//    Convert CMYK data into Dither data
//===================================================================================================
UINT FAR PASCAL Dithering(                                  // Output line count
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    UINT            AllWhite,                               // All white data?
    UINT            XSize,                                  // X Size
    POINT           Pos,                                    // Start position for drawing
    POINT           Off,                                    // Y size of source bitmap data
    MAG             XMag,                                   // X magnification
    MAG             YMag,                                   // Y magnification
    LPCMYK          lpCMYK,                                 // CMYK line
    DWORD           LinByt,                                 // Dither pattern buffer size(Byte / 1Line)
    LPBYTE          lpCBuf,                                 // Line buffer(C)
    LPBYTE          lpMBuf,                                 // Line buffer(M)
    LPBYTE          lpYBuf,                                 // Line buffer(Y)
    LPBYTE          lpKBuf                                  // Line buffer(K)
)
{
    LPDIZINF        lpDiz;
    LPDRWINF        lpDrw;
    UINT            linNum;
    DWORD           whtByt;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ImagePro Dithering() Start\n"));

// Check of zero divide 2002.3.23 >>>
    if ((YMag.Dnt == 0) || (XMag.Dnt == 0)) {
        ERR(("Dithering() 0Div-Check [YMag.Dnt, XMag.Dnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    if (AllWhite == Yes) {                                  // All White data?
        linNum = MagPixel(Off.y, YMag.Nrt, YMag.Dnt);       // Housing line number
        whtByt = (DWORD)LinByt * linNum;                    // White set byte number
        MY_VERBOSE(("ImagePro Dithering() linNum[%d] whtByt[%d] \n", linNum, whtByt));
        if (pOEM->Col.ColMon == CMMCOL) {                   // Color?
            memset(lpCBuf, 0x00, whtByt);                   // White set to CMYK
            memset(lpMBuf, 0x00, whtByt);
            memset(lpYBuf, 0x00, whtByt);
        }
        memset(lpKBuf, 0x00, whtByt);
        MY_VERBOSE(("ImagePro Dithering() AllWhite=Yes\n"));
        return linNum;
    }

    lpDiz = pOEM->Col.Mch.lpDizInf;                         // Dither pattern information
    MY_VERBOSE(("                     ColMon=[%d] PrnMod=[%d] PrnKnd=[%d] DizKnd=[%d] DizPat=[%d]\n",
             lpDiz->ColMon, lpDiz->PrnMod, lpDiz->PrnKnd, lpDiz->DizKnd, lpDiz->DizPat));
    MY_VERBOSE(("                     DizSls=[%d] SizCyn=[%d] SizMgt=[%d] SizYel=[%d] SizBla=[%d]\n",
             lpDiz->DizSls, lpDiz->SizCyn, lpDiz->SizMgt, lpDiz->SizYel, lpDiz->SizBla));

    lpDrw = pOEM->Col.lpDrwInf;                             // Draw information (*Temp area)
    lpDrw->XaxSiz    = (DWORD)XSize;                        // X Pixel number
    lpDrw->StrXax    = (DWORD)Pos.x;                        // Start position for drawing X
    lpDrw->StrYax    = (DWORD)Pos.y;                        // Start position for drawing Y
    lpDrw->XaxNrt    = (DWORD)XMag.Nrt;                     // X Magnification numerator
    lpDrw->XaxDnt    = (DWORD)XMag.Dnt;                     // X Magnification Denominator
    lpDrw->YaxNrt    = (DWORD)YMag.Nrt;                     // Y Magnification Numerator
    lpDrw->YaxDnt    = (DWORD)YMag.Dnt;                     // Y Magnification Denominator
    lpDrw->XaxOfs    = (DWORD)Off.x;                        // X Offset
    lpDrw->YaxOfs    = (DWORD)Off.y;                        // Y Offset
    lpDrw->LinDot    = (DWORD)XSize;                        // Destination, 1 line dot number
    lpDrw->LinByt    = (DWORD)LinByt;                       // Destination, 1 line byte number
    lpDrw->CmyBuf    = (LPCMYK)lpCMYK;                      // CMYK data buffer
    lpDrw->LinBufCyn = lpCBuf;                              // Destination buffer(CMYK)
    lpDrw->LinBufMgt = lpMBuf;
    lpDrw->LinBufYel = lpYBuf;
    lpDrw->LinBufBla = lpKBuf;
    lpDrw->AllLinNum = 0;                                   // Total of the line number for Image

    MY_VERBOSE(("N501_ColDizPrc()  XaxSiz=[%d] StrXax=[%d] StrYax=[%d] XaxNrt=[%d] XaxDnt=[%d]\n",
                lpDrw->XaxSiz, lpDrw->StrXax, lpDrw->StrYax, lpDrw->XaxNrt, lpDrw->XaxDnt));
    MY_VERBOSE(("N501_ColDizPrc()  YaxNrt=[%d] YaxDnt=[%d] XaxOfs=[%d] YaxOfs=[%d] LinDot=[%d] LinByt=[%d]\n",
                lpDrw->YaxNrt, lpDrw->YaxDnt, lpDrw->XaxOfs, lpDrw->YaxOfs, lpDrw->LinDot, lpDrw->LinByt));

    N501_ColDizPrc(lpDiz, lpDrw);                           // Dithering

    MY_VERBOSE(("Dithering() End\n"));
    return (WORD)lpDrw->AllLinNum;                          // Housing line number
}

//===================================================================================================
//      Color control
//===================================================================================================
VOID FAR PASCAL ColControl(
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    LPRGB           lpRGB,                                  // RGB Line
    UINT            RGBSiz                                  // RGB Size
)
{
    LPRGBINF        lpRGBInf;                               // RGB Color change information
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpRGBInf = pOEM->Col.Mch.lpRGBInf;
    N501_ColCtrRgb((DWORD)RGBSiz, lpRGB, lpRGBInf);         // RGB Color cntrol
    return;
}

//===================================================================================================
//    Allocate bitmap data buffer
//---------------------------------------------------------------------------------------------------
//    Allocate size
//          RGB buffer              :Source bitmap Xsize * 3
//          CMYK buffer             :Source bitmap Xsize * 4
//          CMYK bit buffer         :2 value    (Source Xsize * XNrt + 7) / 8 * Source Ysize * YNrt
//                                  :4 value    (Source Xsize * XNrt + 3) / 4 * Source Ysize * YNrt
//                                  :16 value   (Source Xsize * XNrt + 1) / 2 * Source Ysize * YNrt
//===================================================================================================
BOOL BmpBufAlloc(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           SrcXSiz,                                 // Source bitmap data Xsize
    WORD           SrcYSiz,                                 // Source bitmap data Ysize
    WORD           SrcXOff,                                 // Source X offset
    WORD           SrcYOff,                                 // Source Y offset
    WORD           XNrt,                                    // Magnification of X (numerator)
    WORD           XDnt,                                    // Magnification of X (denominator)
    WORD           YNrt,                                    // Magnification of Y (numerator)
    WORD           YDnt,                                    // Magnification of Y (denominator)
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           setSiz;
    WORD           setCnt;
    WORD           alcErr;                                  // Allocate error?
    WORD           bytDot;                                  // DPI
    WORD           xSiz;
    WORD           ySiz;
    WORD           alcLin;
    DWORD          alcSiz;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    alcErr = Yes;

    bytDot = pOEM->Col.BytDot;

// Check of zero divide 2002.3.23 >>>
    if ((XDnt == 0) || (YDnt == 0)) {
        ERR(("BmpBufAlloc() 0Div-Check [XDnt, YDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    xSiz = (WORD)(((DWORD)SrcXOff + SrcXSiz) * XNrt / XDnt);
    xSiz -= (WORD)((DWORD)SrcXOff * XNrt / XDnt);
    MY_VERBOSE(("BmpBufAlloc() xSiz[%d] \n", xSiz));

    ySiz = (WORD)(((DWORD)SrcYOff + SrcYSiz + 2) * YNrt / YDnt);
    ySiz -= (WORD)((DWORD)SrcYOff * YNrt / YDnt);
    MY_VERBOSE(("BmpBufAlloc() ySiz[%d] \n", ySiz));
                                                            // The size of CMYK bit buffer
    if (((DWORD)((xSiz + bytDot - 1) / bytDot) * ySiz) < (64L * 1024L - 1L)) {
        alcLin = ySiz;
    } else {                                                // Over 64KB?
        alcLin = (WORD)((64L * 1024L - 1L) / ((xSiz + bytDot - 1) / bytDot));
    }
    MY_VERBOSE(("BmpBufAlloc() bytDot[%d] \n", bytDot));

    alcSiz = ((xSiz + bytDot - 1) / bytDot) * alcLin;       // The size of CMYK bit buffer(8bit boundary)
    MY_VERBOSE(("BmpBufAlloc() alcLin[%d] \n", alcLin));
    MY_VERBOSE(("BmpBufAlloc() alcSiz[%ld] \n", alcSiz));

    for ( ; ; ) {                                           // Allocation
                                                            // The number of lines that required
        lpBmpBuf->Drv.Bit.BseLin = (WORD)((DWORD)(YNrt + YDnt - 1) / YDnt);
        if (lpBmpBuf->Drv.Bit.BseLin > alcLin) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Bit.BseLin[%d] \n", lpBmpBuf->Drv.Bit.BseLin));

        lpBmpBuf->Drv.Rgb.Siz = SrcXSiz * 3;                // RGB buffer
        if ((lpBmpBuf->Drv.Rgb.Pnt = (LPRGB)MemAllocZ(lpBmpBuf->Drv.Rgb.Siz)) == NULL) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Rgb.Siz[%d] \n", lpBmpBuf->Drv.Rgb.Siz));

        lpBmpBuf->Drv.Cmyk.Siz = SrcXSiz * 4;               // CMYK buffer
        if ((lpBmpBuf->Drv.Cmyk.Pnt = (LPCMYK)MemAllocZ(lpBmpBuf->Drv.Cmyk.Siz)) == NULL) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Cmyk.Siz[%d] \n", lpBmpBuf->Drv.Cmyk.Siz));

        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {               // Color?
            setSiz = 4;                                     // CMYK
        } else {                                            // Mono?
            setSiz = 1;                                     // K
        }
        MY_VERBOSE(("BmpBufAlloc() setSiz[%d] \n", setSiz));
                                                            // CMYK bit buffer
        for (setCnt = 0; setCnt < setSiz; setCnt++) {
            if ((lpBmpBuf->Drv.Bit.Pnt[setCnt] = MemAllocZ(alcSiz)) == NULL) {
                break;
            }
        }
        if (setCnt == setSiz) {
            lpBmpBuf->Drv.Bit.Siz = alcSiz;
            lpBmpBuf->Drv.Bit.Lin = alcLin;
            alcErr = No;                                    // Allocate OK
        }
        break;
    }
    if (alcErr == Yes) {                                    // Allocate error?
        BmpBufFree(lpBmpBuf);
        return FALSE;
    }

    return TRUE;
}


//===================================================================================================
//    Free bitmap data buffer
//===================================================================================================
void BmpBufFree(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    if (lpBmpBuf->Drv.Rgb.Pnt) {                            // Free RGB buffer
        MemFree(lpBmpBuf->Drv.Rgb.Pnt);
        lpBmpBuf->Drv.Rgb.Pnt = NULL;
    }
    if (lpBmpBuf->Drv.Cmyk.Pnt) {                           // Free CMYK buffer
        MemFree(lpBmpBuf->Drv.Cmyk.Pnt);
        lpBmpBuf->Drv.Cmyk.Pnt = NULL;
    }
                                                            // CMYK bit buffer
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // CMYK(2/4/16value)bitmap buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            MemFree(lpBmpBuf->Drv.Bit.Pnt[chkCnt]);
            lpBmpBuf->Drv.Bit.Pnt[chkCnt] = NULL;
        }
    }
    return;
}


//===================================================================================================
//    Clear CMYK bitmap data buffer
//===================================================================================================
void BmpBufClear(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    MY_VERBOSE(("BmpBufClear() Siz[%ld] \n", lpBmpBuf->Drv.Bit.Siz));
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // Clear CMYK(2/4/16value)bit buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            memset(lpBmpBuf->Drv.Bit.Pnt[chkCnt], 0x00, (WORD)lpBmpBuf->Drv.Bit.Siz);
        }
    }
    return;
}

//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void BmpPrint(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPBMPBIF       lpBmpBuf,                                // Pointer to bitmap buffer structure
    POINT          Pos,                                     // Start position for spooling
    WORD           Width,                                   // Width(dot)
    WORD           Height,                                  // Height(dot)
    WORD           WidthByte                                // Width(byte)
)
{
    DRWBMP         drwBmp;                                  // For Spooling bitmap data structure
    DRWBMPCMYK     drwBmpCMYK;                              // For Spooling CMYK bitmap data structure
    WORD           colCnt;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    static const CMYK colTbl[4] = {                         // CMYK table
        {  0,   0,   0, 255},                               // Black
        {  0,   0, 255,   0},                               // Yellow
        {  0, 255,   0,   0},                               // Magenta
        {255,   0,   0,   0}                                // Cyan
    };

    static const WORD plnTbl[4] = {                         // Plane table
        PLN_BLACK,
        PLN_YELLOW,
        PLN_MGENTA,
        PLN_CYAN
    };
    static const WORD frmTbl[4] = {0, 3, 2, 1};             // Frame table

    drwBmpCMYK.Style = lpBmpBuf->Style;
    drwBmpCMYK.DataBit = lpBmpBuf->DatBit;
    drwBmpCMYK.DrawPos = Pos;
    drwBmpCMYK.Width = Width;
    drwBmpCMYK.Height = Height;
    drwBmpCMYK.WidthByte = WidthByte;
    MY_VERBOSE(("BmpPrint() Style[%d] DatBit[%d]\n", drwBmpCMYK.Style, lpBmpBuf->DatBit));
    MY_VERBOSE(("          Width[%d] Height[%d] WidthByte[%d]\n", Width, Height, WidthByte));
                                                            // Color?
    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY
     || pOEM->iColor == XX_COLOR_MANY2) {

        for (colCnt = 0; colCnt < 4; colCnt++) {            // Setting value for spooling bitmap data
            MY_VERBOSE(("          colCnt[%d]\n", colCnt));
            drwBmpCMYK.Plane = PLN_ALL;                     // All Plane is OK
            drwBmpCMYK.Frame = frmTbl[colCnt];
            drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
            PrnBitmapCMYK(pdevobj, &drwBmpCMYK);            // Spool bitmap data
        }
    } else {                                                // Mono
                                                            // Setting value for spooling bitmap data
        drwBmpCMYK.Plane = plnTbl[0];
        drwBmpCMYK.Frame = frmTbl[0];
        drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;
        PrnBitmapCMYK(pdevobj, &drwBmpCMYK);                // Spool bitmap data
    }

    return;
}

//===================================================================================================
//    Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
//===================================================================================================
void BmpRGBCnv(
    LPRGB          lpRGB,                                   // Pointer to destination bitmap data
    LPBYTE         lpSrc,                                   // Pointer to source bitmap data
    WORD           SrcBit,                                  // Pixel of source bitmap data
    WORD           SrcX,                                    // X coordinates of source bitmap data
    WORD           SrcXSiz,                                 // X size of source bitmap data
    LPRGBQUAD      lpPlt                                    // Color palette table of source bitmap data(1/4/8pixel)
)
{
    WORD           setCnt;
    BYTE           colNum;
    LPWORD         lpWSrc;

    MY_VERBOSE(("BmpRGBCnv SrcBit[%d]\n", SrcBit));
    switch (SrcBit) {
        case 1:                                             // 1 bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                                                            // Foreground color?
                if (!(lpSrc[SrcX / 8] & BitTbl[SrcX & 0x0007])) {
                    lpRGB[setCnt].Blu = lpPlt[0].rgbBlue;
                    lpRGB[setCnt].Grn = lpPlt[0].rgbGreen;
                    lpRGB[setCnt].Red = lpPlt[0].rgbRed;
                } else {
                    lpRGB[setCnt].Blu = lpPlt[1].rgbBlue;
                    lpRGB[setCnt].Grn = lpPlt[1].rgbGreen;
                    lpRGB[setCnt].Red = lpPlt[1].rgbRed;
                }
            }
            break;
        case 4:                                             // 4bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                if (!(SrcX & 0x0001)) {                     // A even number coordinates?
                    colNum = lpSrc[SrcX / 2] / 16;
                } else {
                    colNum = lpSrc[SrcX / 2] % 16;
                }
                lpRGB[setCnt].Blu = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Grn = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red = lpPlt[colNum].rgbRed;
            }
            break;
        case 8:                                             // 8bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                colNum = lpSrc[SrcX];
                lpRGB[setCnt].Blu = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Grn = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red = lpPlt[colNum].rgbRed;
            }
            break;
        case 16:                                            // 16bit
            lpWSrc = (LPWORD)lpSrc + SrcX;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpWSrc++) {
                lpRGB[setCnt].Blu = (BYTE)((*lpWSrc & 0x001f) << 3);
                lpRGB[setCnt].Grn = (BYTE)((*lpWSrc & 0x03e0) >> 2);
                lpRGB[setCnt].Red = (BYTE)((*lpWSrc / 0x0400) << 3);
            }
            break;
        case 24:                                            // 24 bit
            lpSrc += SrcX * 3;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 3) {
                lpRGB[setCnt].Red    = lpSrc[0];
                lpRGB[setCnt].Grn    = lpSrc[1];
                lpRGB[setCnt].Blu    = lpSrc[2];
            }
            break;
        case 32:                                            // 32bit
            lpSrc += SrcX * 4;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 4) {
                lpRGB[setCnt].Blu = lpSrc[0];
                lpRGB[setCnt].Grn = lpSrc[1];
                lpRGB[setCnt].Red = lpSrc[2];
            }
            break;
    }
    return;
}

//===================================================================================================
//    Color Matching information setting
//===================================================================================================
BOOL ColMchInfSet(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    static LPTSTR   N501LutNam[] = {                        // N501 LUT file name
        N501LUTR                                            // Color Matching
    };

    LPCOLMCHINF     lpColMch;                               // Color Matching information
    UINT            ColMch;                                 // Color Matching Method
    UINT            lutTbl;                                 // LUT file table number
    UINT            lutNum;                                 // LUT number(0:direct 1:linear *Except for N403:0Fixed)
    LPTSTR          lutNam;                                 // LUT file name
    LPTSTR          filNam;                                 // LUT file name(FULL PATH)
    DWORD           pthSiz;                                 // DRIVER PATH
    HANDLE          hFile;                                  // file handle
    HPBYTE          hpLoad;                                 // LUT pointer
    DWORD           seek;                                   // LUT seek
    LPBYTE          lpLut032Buf;                            // First LUT 32 GRID area
    LPBYTE          lpLut032Wrk;                            // First LUT 32 GRID work area
    LPBYTE          lpLutMakGlbBuf;                         // Sum LUT area
    LPBYTE          lpLutMakGlbWrk;                         // Sum LUT work area
    LPCMYK          LutAdr;
    DWORD           dwRet;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColMchInfSet() Start\n"));
    lpColMch = pOEM->Col.Mch.lpColMch;                      // Color Matching Information
    lpColMch->Bla    = KCGNON;
    lpColMch->LutGld = 0;
    lpColMch->Ucr = pOEM->Col.Mch.Ucr;
    lpColMch->UcrCmy = 40;                                  // UCR quantity 40%
    lpColMch->UcrBla = 90;                                  // Ink version generation quantity 90%
    lpColMch->UcrTnr = 270;                                 //+Toner gross weight 270%  CASIO 20001/02/15
    lpColMch->UcrTbl = NULL;                                // UCK table
    lpColMch->GryTbl = NULL;                                // Gray transfer table

    if (pOEM->Col.ColMon == CMMMON) {                       // Mono?
        lpColMch->Mch = MCHMON;
//        if ((ColLutMakGlbMon(pdevobj)) == FALSE) {
//            return FALSE;
//        }
        return TRUE;
    }
    if (pOEM->Col.Mch.Speed == Yes) {                       // First?
        lpColMch->Mch = MCHFST;
    } else {
        lpColMch->Mch = MCHNML;
    }
    if (pOEM->Col.Mch.Diz == XX_DITH_NON) {                 // Not Dithering?
        lpColMch->Mch = MCHPRG;                             // progressive
        return TRUE;
    }
    lutNum = 0;                                             // LUT number(0:direct 1:linear *Except for N403:0Fixed)
    lutTbl = 0;                                             // number of LUT table array
    ColMch = pOEM->Col.Mch.Mode;                            // Color Matching mode
    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if (ColMch == XX_COLORMATCH_BRI 
         || ColMch == XX_COLORMATCH_VIV) {                  // Brightness or Vivid?
            lutTbl = 0;
            lutNum = LUT_XD;
        } else if (ColMch == XX_COLORMATCH_TINT) {          // tincture?
            lutTbl = 0;
            lutNum = LUT_YD;
        } else if (ColMch == XX_COLORMATCH_NONE) {
            lpColMch->Mch = MCHSLD;                         // Solid
            lutTbl = 0;
            lutNum = LUT_XD;
        }
        lutNam = N501LutNam[lutTbl];                        // LUT file name
    }

    if ((filNam = MemAllocZ(MAX_PATH * sizeof(TCHAR))) == NULL) {
        return FALSE;
    }
    pthSiz = GetModuleFileName(pdevobj->hOEM, filNam, MAX_PATH);
    pthSiz -= ((sizeof(CSN5RESDLL) / sizeof(WCHAR)) - 1);
// Replacement of strsafe-api 2002.3.6 >>>
//    lstrcpy(&filNam[pthSiz], lutNam);
    if (S_OK != StringCchCopy(&filNam[pthSiz], MAX_PATH - pthSiz, lutNam)) {
        MemFree(filNam);
        return FALSE;
    }
// Replacement of strsafe-api 2002.3.6 <<<

    MY_VERBOSE(("LUT filNam [%ws]\n", filNam));
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(filNam,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n", filNam, GetLastError()));
        MemFree(filNam);
        return FALSE;
    }
    MemFree(filNam);

    if ((hpLoad = MemAlloc(LUTFILESIZ)) == NULL) {          // LUT read buffer
        CloseHandle(hFile);
        return FALSE;
    }
    MY_VERBOSE(("ColMchInfSet() LUT file read\n"));
    if (FALSE == ReadFile(hFile,                            // LUT file read
        hpLoad, LUTFILESIZ, &dwRet, NULL)) {

        ERR(("Error reading LUT file %ws (%d)\n", filNam, GetLastError()));

        // Abort
        MemFree(hpLoad);
        CloseHandle(hFile);
        return FALSE;
    }

    MY_VERBOSE(("ColMchInfSet() N501_ColLutDatRdd()\n"));
    MY_VERBOSE(("ColMchInfSet() lutNum[%d] \n", lutNum));
//    if ((seek = (N501_ColLutDatRdd((LPBYTE)hpLoad, (DWORD)lutNum))) == 0) {
    if ((seek = (N501_ColLutDatRdd((LPBYTE)hpLoad, lutNum))) == 0) {
        MemFree(hpLoad);
        CloseHandle(hFile);
        return FALSE;
    }
    lpColMch->LutAdr = (LPCMYK)(hpLoad + seek);             // LUT file Head address + seek
    LutAdr = (LPCMYK)(hpLoad + seek);
    pOEM->Col.LutTbl = hpLoad;                              // LUT table

    if (lpColMch->Mch == MCHSLD) {                          // Color Matching Solid?
        MY_VERBOSE(("ColMchInfSet() Mch == MCHSLD \n"));
                                                            // Black & gray replacement ?
        if (pOEM->Col.Mch.GryKToner == Yes && pOEM->Col.Mch.CmyBlk == Yes) {
                                                            // Gray transfer table make
            if ((ColGryTblMak(pdevobj, LutAdr)) == FALSE) {
                MemFree(hpLoad);
                CloseHandle(hFile);
                return FALSE;
            }
        }

        if (lpColMch->Ucr != UCRNOO) {                      // UCR?
            MY_VERBOSE(("ColMchInfSet() Mch == MCHSLD && Ucr != UCRNOO \n"));
            if ((ColUcrTblMak(pdevobj,  (LPCMYK)(hpLoad + seek))) == FALSE) {
                MemFree(hpLoad);
                CloseHandle(hFile);
                return FALSE;
            }
        }
        CloseHandle(hFile);
        return TRUE;
    }

    MY_VERBOSE(("ColMchInfSet() Global LUT Start\n"));
    if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
        MY_VERBOSE(("ColMchInfSet() Global LUT area\n"));
                                                            // Global LUT area
        if ((lpLutMakGlbBuf = MemAlloc(LUTMAKGLBSIZ)) == NULL) {    
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // Global LUT work area
        MY_VERBOSE(("ColMchInfSet() Global LUT work area\n"));
        if ((lpLutMakGlbWrk = MemAlloc(LUTGLBWRK)) == NULL) {   
            MemFree(lpLutMakGlbBuf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // Make Global LUT 
        MY_VERBOSE(("ColMchInfSet() N501_ColLutMakGlb()\n"));
        if ((N501_ColLutMakGlb(NULL, (LPCMYK)(hpLoad + seek), pOEM->Col.Mch.lpRGBInf, pOEM->Col.Mch.lpCMYKInf,
                              (LPCMYK)lpLutMakGlbBuf, lpLutMakGlbWrk)) != ERRNON) {
            MemFree(lpLutMakGlbWrk);
            MemFree(lpLutMakGlbBuf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
        pOEM->Col.lpLutMakGlb = lpLutMakGlbBuf;
        pOEM->Col.Mch.LutMakGlb = Yes;
        lpColMch->LutAdr = (LPCMYK)lpLutMakGlbBuf;
        LutAdr = (LPCMYK)lpLutMakGlbBuf;
        MemFree(lpLutMakGlbWrk);
    }

    if (pOEM->Col.Mch.Speed == Yes) {                       // First?
                                                            // First LUT 32 GRID area
        MY_VERBOSE(("ColMchInfSet() First LUT 32 GRID area\n"));
        if ((lpLut032Buf = MemAlloc(LUT032SIZ)) == NULL) {
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // First LUT(32GRID) wark area
        if ((lpLut032Wrk = MemAlloc(LUT032WRK)) == NULL) {  
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            MemFree(lpLut032Buf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // First LUT(32GRID) Make
        MY_VERBOSE(("ColMchInfSet() N501_ColLutMak032()\n"));
        N501_ColLutMak032(LutAdr, (LPCMYK)lpLut032Buf, lpLut032Wrk);
        MemFree(lpLut032Wrk);
        lpColMch->LutAdr = (LPCMYK)lpLut032Buf;
        LutAdr = (LPCMYK)lpLut032Buf;
        pOEM->Col.lpLut032 = lpLut032Buf;
    }

    MY_VERBOSE(("ColMchInfSet() Black & gray replacement ?\n"));
                                                            // Black & gray replacement ?
    if (pOEM->Col.Mch.GryKToner == Yes && pOEM->Col.Mch.CmyBlk == Yes) {
        MY_VERBOSE(("ColMchInfSet() Black & gray replacement [Yes]\n"));
        if ((ColGryTblMak(pdevobj, LutAdr)) == FALSE) {     // Gray transfer table make
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            if (lpLut032Buf != NULL) {
                MemFree(lpLut032Buf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
    }

    if (lpColMch->Ucr != UCRNOO &&                          // UCR & (Normal or First)?
       (lpColMch->Mch == MCHFST || lpColMch->Mch == MCHNML) ) {
                                                            // UCR table create
        MY_VERBOSE(("ColMchInfSet() ColUcrTblMak()\n"));
        if ((ColUcrTblMak(pdevobj, LutAdr)) == FALSE) {
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            if (lpLut032Buf != NULL) {
                MemFree(lpLut032Buf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
        MY_VERBOSE(("ColMchInfSet() ColUcrTblMak() OK!!\n"));
    }

    CloseHandle(hFile);

    lpColMch->ColQty = (DWORD)0;                            // The color designated number
    lpColMch->ColAdr = NULL;                                // Color designated table

    if ((pOEM->Col.CchRGB = MemAlloc(CCHRGBSIZ)) == NULL)  {
        return FALSE;
    }
    if ((pOEM->Col.CchCMYK = MemAlloc(CCHCMYSIZ)) == NULL)  {
        MemFree(pOEM->Col.CchRGB);
        return FALSE;
    }
    lpColMch->CchRgb = (LPRGB)pOEM->Col.CchRGB;
    lpColMch->CchCmy = (LPCMYK)pOEM->Col.CchCMYK;

    MY_VERBOSE(("ColMchInfSet() N501_ColCchIni()\n"));
    N501_ColCchIni(lpColMch);                               // Cache table initialize

    MY_VERBOSE(("ColMchInfSet() End\n"));
    return TRUE;
}


//===================================================================================================
//    Dither information setting
//===================================================================================================
BOOL DizInfSet(                                             // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    LPDIZINF        lpDiz;                                  // Dither pattern information
    DWORD           dizSizC;                                // Dither pattern size(C)
    DWORD           dizSizM;                                // Dither pattern size(M)
    DWORD           dizSizY;                                // Dither pattern size(Y)
    DWORD           dizSizK;                                // Dither pattern size(K)
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("DizInfSet() Start\n"));
    lpDiz = pOEM->Col.Mch.lpDizInf;                         // Dither pattern information
    if (pOEM->Col.ColMon == CMMCOL) {                       // Color?
        lpDiz->ColMon = CMMCOL;
    } else {                                                // Mono
        lpDiz->ColMon = CMMMON;
    }                                                       // Get dither pattern
    if ((lpDiz->DizPat = (DWORD)GetDizPat(pdevobj)) == 0xff) {
        return TRUE;                                        // TRUE(Not dithering)
    }
    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if (pOEM->Col.wReso == DPI300) {                    // 300DPI?
            if (pOEM->Col.Dot == XX_TONE_2) {               // 2value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM302\n"));
                lpDiz->PrnMod = PRM302;
            } else {                                        // 16value
                MY_VERBOSE(("DizInfSet() PrnMod=PRM316\n"));
                lpDiz->PrnMod = PRM316;
            }
        } else {                                            // 600DPI
            if (pOEM->Col.Dot == XX_TONE_2) {               // 2value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM602\n"));
                lpDiz->PrnMod = PRM602;
            } else if (pOEM->Col.Dot == XX_TONE_4){         // 4value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM604\n"));
                lpDiz->PrnMod = PRM604;
            } else if (pOEM->Col.Dot == XX_TONE_16){        // 16value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM616\n"));
                lpDiz->PrnMod = PRM616;
            }
        }

        lpDiz->TblCyn = NULL;                               // To acquire dither pattern size
        lpDiz->TblMgt = NULL;
        lpDiz->TblYel = NULL;
        lpDiz->TblBla = NULL;

        MY_VERBOSE(("DizInfSet() DizFileOpen()\n"));
        lpDiz->DizKnd = KNDIMG;                             // Dither Kind
        if ((DizFileOpen(pdevobj, lpDiz)) == FALSE) {       // Get dither pattern size
            return FALSE;
        }
        dizSizC = lpDiz->SizCyn * lpDiz->SizCyn * lpDiz->DizSls;
        dizSizM = lpDiz->SizMgt * lpDiz->SizMgt * lpDiz->DizSls;
        dizSizY = lpDiz->SizYel * lpDiz->SizYel * lpDiz->DizSls;
        dizSizK = lpDiz->SizBla * lpDiz->SizBla * lpDiz->DizSls;
        MY_VERBOSE(("DizInfSet() dizSizC[%d] M[%d] Y[%d] K[%d]\n", dizSizC, dizSizM, dizSizY, dizSizK));
    }

    MY_VERBOSE(("DizInfSet() Dither pattern table area Alloc\n"));
    if (lpDiz->ColMon == CMMCOL) {                          // Color?
        lpDiz->SizCyn = dizSizC;                            // Dither pattern table(Cyan)
        if ((pOEM->Col.DizTbl[0] = MemAlloc(dizSizC)) == NULL) {
            return FALSE;
        }
        lpDiz->TblCyn = (LPBYTE)pOEM->Col.DizTbl[0];

        lpDiz->SizMgt = dizSizM;                            // Dither pattern table(Magenta)
        if ((pOEM->Col.DizTbl[1] = MemAlloc(dizSizM)) == NULL) {
            return FALSE;
        }
        lpDiz->TblMgt = (LPBYTE)pOEM->Col.DizTbl[1];

        lpDiz->SizYel = dizSizY;                            // Dither pattern table(Yellow)
        if ((pOEM->Col.DizTbl[2] = MemAlloc(dizSizY)) == NULL) {
            return FALSE;
        }
        lpDiz->TblYel = (LPBYTE)pOEM->Col.DizTbl[2];
    }

    lpDiz->SizBla = dizSizK;                                // Dither pattern table(Black)
    if ((pOEM->Col.DizTbl[3] = MemAlloc(dizSizK)) == NULL) {
        return FALSE;
    }
    lpDiz->TblBla = (LPBYTE)pOEM->Col.DizTbl[3];

    MY_VERBOSE(("DizInfSet() DizFileOpen()\n"));
    if ((DizFileOpen(pdevobj, lpDiz)) == FALSE) {           // Make dither pattern
        return FALSE;
    }

    MY_VERBOSE(("DizInfSet() End\n"));
    return TRUE;                                            // TRUE
}

//===================================================================================================
//    Get Dither pattern type
//===================================================================================================
UINT GetDizPat(                                             // Dither pattern(0xff: Not dithering)
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    static const WORD DizNumTbl[XX_MAXDITH] = {DIZMID,      // DITH_IMG
                                            DIZRUG,         // DITH_GRP
                                            DIZSML,         // DITH_TXT
                                            0xff,           // DITH_GOSA
                                            DIZMID,         // DITH_NORMAL
                                            DIZMID,         // DITH_HS_NORMAL
                                            DIZSML,         // DITH_DETAIL
                                            DIZRUG,         // DITH_EMPTY
                                            DIZSTO,         // DITH_SPREAD
                                            DIZMID          // DITH_NON
    };
    UINT            dizPat;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;
    dizPat = DizNumTbl[pOEM->Col.Mch.Diz];
    return dizPat;
}


//===================================================================================================
//    Read dither file
//===================================================================================================
BOOL DizFileOpen(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPDIZINF       lpDiz                                    // Dither pattern
)
{
    LPTSTR          drvPth;
    LPTSTR          filNam;
    DWORD           pthSiz;
    HANDLE          hFile;
    LPBYTE          lpDizBuf;
    LPBYTE          lpDizWrkBuf;
    DWORD           dwRet;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("DizFileOpen() Start\n"));

    if ((filNam = MemAllocZ(MAX_PATH * sizeof(TCHAR))) == NULL) {
        return FALSE;
    }
    pthSiz = GetModuleFileName(pdevobj->hOEM, filNam, MAX_PATH);
    pthSiz -= ((sizeof(CSN5RESDLL) / sizeof(WCHAR)) - 1);
// Replacement of strsafe-api 2002.3.6 >>>
//    lstrcpy(&filNam[pthSiz], N501DIZ);                      // Dither file name (FULL PATH)
    if (S_OK != StringCchCopy(&filNam[pthSiz], MAX_PATH - pthSiz, N501DIZ)) {
        MemFree(filNam);
        return FALSE;
    }
// Replacement of strsafe-api 2002.3.6 <<<

    MY_VERBOSE(("DIZ filNam [%ws]\n", filNam));
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(filNam,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening DIZ file %ws (%d)\n", filNam, GetLastError()));
        MemFree(filNam);
        return 0;
    }
    MemFree(filNam);

    if ((lpDizBuf = MemAlloc(DIZFILESIZ)) == NULL) {
        CloseHandle(hFile);
        return FALSE;
    }

    if ((lpDizWrkBuf = MemAlloc(DIZINFWRK)) == NULL) {
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    if (FALSE == ReadFile(hFile, lpDizBuf, DIZFILESIZ, &dwRet, NULL)) {

        ERR(("Error reading DIZ file %ws (%d)\n", filNam, GetLastError()));

        // Abort
        MemFree(lpDizWrkBuf);
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    MY_VERBOSE(("N501_ColDizInfSet()  ColMon=[%d] PrnMod=[%d] PrnKnd=[%d] DizKnd=[%d] DizPat=[%d]\n",
                lpDiz->ColMon, lpDiz->PrnMod, lpDiz->PrnKnd, lpDiz->DizKnd, lpDiz->DizPat));
    MY_VERBOSE(("                     DizSls=[%d] SizCyn=[%d] SizMgt=[%d] SizYel=[%d] SizBla=[%d]\n",
                lpDiz->DizSls, lpDiz->SizCyn, lpDiz->SizMgt, lpDiz->SizYel, lpDiz->SizBla));
    if ((N501_ColDizInfSet((LPBYTE)lpDizBuf, lpDiz, lpDizWrkBuf)) != ERRNON) {
        MemFree(lpDizWrkBuf);
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    MemFree(lpDizWrkBuf);
    MemFree(lpDizBuf);
    CloseHandle(hFile);
    MY_VERBOSE(("DizFileOpen() End\n"));

    return TRUE;
}

//#if defined(CPN5SERIES)                                       // N501
//===================================================================================================
//    Make UCR table
//===================================================================================================
BOOL ColUcrTblMak(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPCMYK         LutAdr                                   // LUT address
)
{
    LPCOLMCHINF     lpColMch;
    LPBYTE          lpUcrTbl;
    LPBYTE          lpUcrWrk;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColUcrTblMak() MemAlloc(UCRTBLSIZ)\n"));
    lpColMch = pOEM->Col.Mch.lpColMch;
    if ((lpUcrTbl = MemAlloc(UCRTBLSIZ)) == NULL) {
        return FALSE;
    }
    MY_VERBOSE(("ColUcrTblMak() MemAlloc(UCRWRKSIZ)\n"));
    if ((lpUcrWrk = MemAlloc(UCRWRKSIZ)) == NULL) {
        MemFree(lpUcrTbl);
        return FALSE;
    }
    MY_VERBOSE(("ColUcrTblMak() N501_ColUcrTblMak()\n"));
    if ((N501_ColUcrTblMak(lpColMch->Mch, LutAdr, (LPCMYK)lpUcrTbl, lpUcrWrk)) != ERRNON) {
        MemFree(lpUcrWrk);
        MemFree(lpUcrTbl);
        return FALSE;
    }
    lpColMch->UcrTbl = (LPCMYK)lpUcrTbl;
    pOEM->Col.lpUcr = lpUcrTbl;
    MemFree(lpUcrWrk);

    MY_VERBOSE(("ColUcrTblMak() End\n"));
    return TRUE;
}

//===================================================================================================
//    Make Gray transfer table
//===================================================================================================
BOOL ColGryTblMak(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPCMYK          LutAdr                                  // LUT address
)
{
    LPCOLMCHINF     lpColMch;
    LPBYTE          lpGryTbl;
    LPBYTE          lpCmpBuf;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColGryTblMak() \n"));
    lpColMch = pOEM->Col.Mch.lpColMch;

    if ((lpGryTbl = MemAlloc(GRYTBLSIZ)) == NULL) {         // Gray transfer table area
        return FALSE;
    }
    if ((lpCmpBuf = MemAlloc(LUTGLBWRK)) == NULL) {         // Gray transfer table work area
        MemFree(lpGryTbl);
        return FALSE;
    }
                                                            // Make Gray transfer table
    if ((N501_ColGryTblMak(lpColMch->Mch, LutAdr, lpGryTbl, lpCmpBuf)) != ERRNON) {
        MemFree(lpCmpBuf);
        MemFree(lpGryTbl);
        return FALSE;
    }

    lpColMch->GryTbl = (LPBYTE)lpGryTbl;
    pOEM->Col.lpGryTbl = lpGryTbl;
    MemFree(lpCmpBuf);
    MY_VERBOSE(("ColGryTblMak() End\n"));

    return TRUE;
}
//#endif

//#if defined(CPN5SERIES) || defined(CPE8SERIES)                                      // N501
//===================================================================================================
//    Make LUT table (MONO)
//===================================================================================================
BOOL ColLutMakGlbMon(                                       // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    LPCOLMCHINF     lpColMch;
    LPRGB           lpRGB;
    LPBYTE          lpLutMakGlbBuf;
    LPBYTE          lpLutMakGlbWrk;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColLutMakGlbMon() \n"));
    lpColMch = pOEM->Col.Mch.lpColMch;
    lpRGB = NULL;                                           // Not sRGB

                                                            // Global LUT area
    if ((lpLutMakGlbBuf = MemAlloc(LUTMAKGLBSIZ)) == NULL) {
        return FALSE;
    }

    if ((lpLutMakGlbWrk = MemAlloc(LUTGLBWRK)) == NULL) {   // Global LUT work area
        MemFree(lpLutMakGlbBuf);
        return FALSE;
    }
                                                            // Make Gray transfer table (MONO)
    if ((N501_ColLutMakGlbMon(lpRGB, pOEM->Col.Mch.lpRGBInf, pOEM->Col.Mch.lpCMYKInf,
                          (LPCMYK)lpLutMakGlbBuf, lpLutMakGlbWrk)) != ERRNON) {
        MemFree(lpLutMakGlbWrk);
        MemFree(lpLutMakGlbBuf);
        return FALSE;
    }

    lpColMch->LutAdr = (LPCMYK)lpLutMakGlbBuf;
    pOEM->Col.lpLutMakGlb = lpLutMakGlbBuf;
    pOEM->Col.Mch.LutMakGlb = Yes;
    MemFree(lpLutMakGlbWrk);
    MY_VERBOSE(("ColLutMakGlbMon() End\n"));

    return TRUE;
}
//#endif

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\colmatch.h ===
//***************************************************************************************************
//    COLMATCH.H
//
//    Functions of color matching(C Header)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Include Header file
//---------------------------------------------------------------------------------------------------
#include "COLDEF.H"
#include "COMDIZ.H"
#include "N501DIZ.H"

//---------------------------------------------------------------------------------------------------
//    Printer name
//---------------------------------------------------------------------------------------------------
#define PRN_N5      0

//---------------------------------------------------------------------------------------------------
//    Color Matching DLL name
//---------------------------------------------------------------------------------------------------
#define N501_ColCchIni          N501ColCchIni
#define N501_ColMchPrc          N501ColMchPrc
#define N501_ColCnvC2r          N501ColCnvC2r
#define N501_ColDizInfSet       N501ColDizInfSet
#define N501_ColDizPrc          N501ColDizPrc
#define	N501_ColLutMakGlbMon	N501ColLutMakGlbMon
#define N501_ColUcrTblMak       N501ColUcrTblMak
#define N501_ColPtcPrc          N501ColPtcPrc
#define N501_ColCtrRgb          N501ColCtrRgb
#define N501_ColCtrCmy          N501ColCtrCmy
#define N501_ColLutDatRdd       N501ColLutDatRdd
#define N501_ColLutMakGlb       N501ColLutMakGlb
#define N501_ColLutMak032       N501ColLutMak032
#define N501_ColColDatRdd       N501ColColDatRdd
#define N501_ColDrwInfSet       N501ColDrwInfSet
#define	N501_ColGryTblMak		N501ColGryTblMak
#define N501_ExeJpgDcdJdg       ExeJpgDcdJdg
#define N501_ExeJpgEcd          ExeJpgEcd
#define	Qty_BmpFilWrkSizGet		BmpFilWrkSizGet
#define	Qty_BmpFilterExe		BmpFilterExe
#define	Qty_BmpEnlWrkSizGet		BmpEnlWrkSizGet
#define	Qty_BmpEnlExe			BmpEnlExe

//---------------------------------------------------------------------------------------------------
//    Data define
//---------------------------------------------------------------------------------------------------
#define No          0
#define Yes         1

#define XX_RES_300DPI            0
#define XX_RES_600DPI            1

#define XX_MONO                  0
#define XX_COLOR                 1
#define XX_COLOR_SINGLE          2
#define XX_COLOR_MANY            3
#define XX_COLOR_MANY2           4

#define XX_DITH_IMG              0
#define XX_DITH_GRP              1
#define XX_DITH_TXT              2
#define XX_DITH_GOSA             3
#define XX_DITH_NORMAL           4
#define XX_DITH_HS_NORMAL        5
#define XX_DITH_DETAIL           6
#define XX_DITH_EMPTY            7
#define XX_DITH_SPREAD           8
#define XX_DITH_NON              9
#define XX_MAXDITH              10

#define XX_COLORMATCH_BRI        1
#define XX_COLORMATCH_TINT       2
#define XX_COLORMATCH_VIV        3
#define XX_COLORMATCH_NONE       4

#define XX_BITFONT_OFF           0
#define XX_BITFONT_ON            1

#define XX_CMYBLACK_GRYBLK       0
#define XX_CMYBLACK_BLKTYPE1     1
#define XX_CMYBLACK_BLKTYPE2     2
#define XX_CMYBLACK_BLACK        3
#define XX_CMYBLACK_TYPE1        4
#define XX_CMYBLACK_TYPE2        5
#define XX_CMYBLACK_NONE         6

#define XX_COMPRESS_OFF          0
#define XX_COMPRESS_AUTO         1
#define XX_COMPRESS_RASTER       3

#define XX_TONE_2                0
#define XX_TONE_4                1
#define XX_TONE_16               2

#define XX_ICM_NON               1
#define XX_ICM_USE               2

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PALETTE_SIZE    1

#define BYTE_LENGTH(s) (sizeof (s) - 1)

#define MagPixel(Dat, Nrt, Dnt)     ((((Dat) + 1) * (Nrt) / (Dnt)) - ((Dat) * (Nrt) / (Dnt)))

typedef char                            FAR *HPSTR;
typedef BYTE                            FAR *HPBYTE;

//===================================================================================================
//    Dither pattern buffer
//===================================================================================================
typedef struct {
    LPBYTE  lpC;                                // Cyan
    LPBYTE  lpM;                                // Magenta
    LPBYTE  lpY;                                // Yellow
    LPBYTE  lpK;                                // Black
} DIZBUF, FAR *LPDIZBUF;

//===================================================================================================
//    Read buffer size
//===================================================================================================
#define LUTFILESIZ      70L * 1024L             // N501 Buffer size for LUT file read
#define DIZFILESIZ      408L * 1024L            // N501 Buffer size for DIZ file read
#define LUT032SIZ       128L * 1024L            // N501 Buffer size for LUT32GRID
#define UCRTBLSIZ       2048L                   // N501 Buffer size for UCR table
#define UCRWRKSIZ       32768                   // N501 Buffer size for UCR table work
#define sRGBLUTFILESIZ  16L * 1024L             // N501 Buffer size for LUT file read (sRGB)
#define LUTMAKGLBSIZ    16L * 1024L             // N501 Buffer size for LUTMAKGLB
#define GRYTBLSIZ       256L                    // N501 Buffer size for Gray transfer table

//===================================================================================================
//    Color matching structure
//===================================================================================================
typedef struct {
    WORD    wReso;                              // Resolution
    WORD    ColMon;                             // Color/Monochrome
    WORD    DatBit;                             // Data bit(1:2value 2:4value 4:16value)
    WORD    BytDot;                             // DPI (2value:8 4value:4 16value:2)
    struct {                                    // Strcture for color matching
        WORD        Mode;                       // Type of color matching
        WORD        GryKToner;                  //+N5 Gray color use black toner ?
        WORD        Viv;                        // Vividly?(For N4-612Printer)
        WORD        LutNum;                     // LUT table No.
        WORD        Diz;                        // Type od dithering
        SHORT       Tnr;                        // Toner density(-30 to 30)
        WORD        CmyBlk;                     // Replace CMY by black toner ?
        WORD        Speed;                      // 0:high 1:normal
        WORD        Gos32;                      // GOSA?
        WORD        PColor;                     // Original color?
        WORD        Ucr;                        //+N5 Ucr
        WORD        SubDef;                     // Bright, contrast and gamma ?
        SHORT       Bright;                     // bright
        SHORT       Contrast;                   // contrast
        WORD        GamRed;                     // Color balance(R)
        WORD        GamGreen;                   // Color balance(G)
        WORD        GamBlue;                    // Color balance(B)
        LPRGBINF    lpRGBInf;                   //+N5 RGB transformation information
        LPCMYKINF   lpCMYKInf;                  //+N5 CMYK  transformation information
        LPCOLMCHINF lpColMch;                   //+N5 Color matching information
        LPDIZINF    lpDizInf;                   //+N5 Dithering pattern information
        UINT        CchMch;                     // Cache information for Color Matching
        UINT        CchCnv;                     // Cache information for use black toner
        RGBS        CchRGB;                     // Cache information for input RGB
        CMYK        CchCMYK;                    // Cache information for output CMYK
		WORD		LutMakGlb;					//+N5 Global LUT make ?
        WORD        KToner;                     // Black toner usage
    } Mch;
    UINT        InfSet;                         //+N5  Color information setting completion
    WORD        Dot;                            //+N5  Dot tone (TONE2, TONE4, TONE16)
    LPVOID      lpColIF;                        //+N5  RGBINF / CMYKINF / COLMCHINF / DIZINF pointer
    LPVOID      LutTbl;                         //+N5  Look-up table
    LPVOID      CchRGB;                         //+N5  Cache table for RGB
    LPVOID      CchCMYK;                        //+N5  Cache table for CMYK
    LPVOID      DizTbl[4];                      //+N5  Dither pattern table
    LPRGB       lpTmpRGB;                       //+N5  RGB convert area (*Temp area)
    LPCMYK      lpTmpCMYK;                      //+N5  CMYK convert area (*Temp area)
    LPDRWINF    lpDrwInf;                       //+N5  Draw information (*Temp area)
    LPBYTE      lpLut032;                       //+N5  LUT32GRID
    LPBYTE      lpUcr;                          //+N5  Ucr table
    LPBYTE      lpLutMakGlb;                    //+N5  LUTMAKGLB
    LPBYTE      lpGryTbl;                       //+N5  Gray transfer table 
} DEVCOL, FAR *LPDEVCOL;

//===================================================================================================
//    Bitmap buffer structure
//===================================================================================================
typedef struct {
    WORD    Diz;                                // Method of dithering
    WORD    Style;                              // Method of spooling
    WORD    DatBit;                             // Databit(1:2value 2:4value 4:16value)
    struct {
        struct {                                // Member of RGB buffer(for 1 line)
            WORD      AllWhite;                 // All data is white?
            DWORD     Siz;                      // Size
            LPRGB     Pnt;                      // Pointer
        } Rgb;
        struct {                                // Member of CMYK buffer(for 1 line)
            DWORD     Siz;                      // Size
            LPCMYK    Pnt;                      // Poiner
        } Cmyk;
        struct {                                // Member of CMYK(2/4/16value)bitmap buffer(maximum 64KB)
            DWORD     Siz;                      // Size
            WORD      BseLin;                   // The number of lines that require
            WORD      Lin;                      // The number of lines that allocate
            LPBYTE    Pnt[4];                   // Pointer
        } Bit;
    } Drv;
} BMPBIF, FAR* LPBMPBIF;

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(PDEVOBJ);

//===================================================================================================
//    Disable the color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchDisable(PDEVOBJ);

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(PDEVOBJ, PBYTE, PBITMAPINFOHEADER, PBYTE, PIPPARAMS);

//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL ColMatching(PDEVOBJ, UINT, UINT, LPRGB, UINT, LPCMYK);

//===================================================================================================
//    Convert CMYK data into Dither data
//===================================================================================================
UINT FAR PASCAL Dithering(PDEVOBJ, UINT, UINT, POINT, POINT, MAG, MAG, LPCMYK, DWORD, 
                          LPBYTE, LPBYTE, LPBYTE, LPBYTE);
//===================================================================================================
//    Color Control
//===================================================================================================
VOID FAR PASCAL ColControl(PDEVOBJ, LPRGB, UINT);


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\csn5res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    Csn5res.c

Abstract:

    Implementation of GPD command callback for "Csn5j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/


#include "PDEV.H"
#include <stdio.h>
#include "PRNCTL.H"
#include "strsafe.h"    // Security-Code 2002.3.6


//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 >>>

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr);
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize);
// Replacement of strsafe-api 2002.3.6 <<<

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_CASETTE_4   103
#define PSRC_SELECT_CASETTE_5   104
#define PSRC_SELECT_CASETTE_6   105
#define PSRC_SELECT_MPF         106
#define PSRC_SELECT_AUTO        107

#define TONER_SAVE_NONE         110
#define TONER_SAVE_1            111
#define TONER_SAVE_2            112
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MEDIATYPE_1             140
#define MEDIATYPE_2             141
#define MEDIATYPE_3             142
#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#define START_PAGE              160

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      170
#define COLOR_SELECT_RED        171
#define COLOR_SELECT_GREEN      172
#define COLOR_SELECT_BLUE       173
#define COLOR_SELECT_YELLOW     174
#define COLOR_SELECT_MAGENTA    175
#define COLOR_SELECT_CYAN       176
#define COLOR_SELECT_WHITE      177

#define DUMP_RASTER_CYAN        180
#define DUMP_RASTER_MAGENTA     181
#define DUMP_RASTER_YELLOW      182
#define DUMP_RASTER_BLACK       183
/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

#define OUTBIN_SELECT_EXIT_1    190
#define OUTBIN_SELECT_EXIT_2    191

#define DEFINE_PALETTE_ENTRY    300
#define BEGIN_PALETTE_DEF       301
#define END_PALETTE_DEF         302
#define SELECT_PALETTE_ENTRY    303

#define OPT_DITH_NORMAL         "Normal"
#define OPT_DITH_DETAIL         "Detail"
#define OPT_DITH_EMPTY          "Empty"
#define OPT_DITH_SPREAD         "Spread"
#define OPT_DITH_NON            "Diz_Off"

#define OPT_COLORMATCH_BRI      "ForBright"
#define OPT_COLORMATCH_BRIL     "ForBrightL"
#define OPT_COLORMATCH_TINT     "ForTint"
#define OPT_COLORMATCH_TINTL    "ForTintL"
#define OPT_COLORMATCH_VIV      "ForVivid"
#define OPT_COLORMATCH_NONE     "Mch_Off"

#define OPT_MONO                "Mono"
#define OPT_COLOR               "Color"
#define OPT_COLOR_SINGLE        "Color_Single"
#define OPT_COLOR_MANY          "Color_Many"
#define OPT_COLOR_MANY2         "Color_Many2"

#define OPT_1                   "Option1"
#define OPT_2                   "Option2"

#define OPT_CMYBLACK_GRYBLK     "GrayBlack"
#define OPT_CMYBLACK_BLKTYPE1   "BlackType1"
#define OPT_CMYBLACK_BLKTYPE2   "BlackType2"
#define OPT_CMYBLACK_BLACK      "Black"
#define OPT_CMYBLACK_TYPE1      "Type1"
#define OPT_CMYBLACK_TYPE2      "Type2"
#define OPT_CMYBLACK_NONE       "Non"

#define OPT_AUTO                "Auto"
#define OPT_RASTER              "Raster"
#define OPT_PRESSOFF            "PressOff"


//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

BYTE CMD_START_PAGE[] =
    "\x1Bz\xD0\x01" "Ca*\x1Bz\x00\x01"
    "\x1D" "1alfP\x1D" "1affP\x1D"
    "0;0;0clfP\x1D" "0X\x1D" "0Y";

BYTE SET_FONT_ID[]        = "\x1D%d;%ddh{F";
BYTE DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
BYTE DLI_DELETE_FONT[]    = "\x1D%dddcF";
BYTE SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
BYTE SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
BYTE SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

BYTE FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
BYTE FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
BYTE PRN_DIRECTION[]      = "\x1D%droF";
BYTE SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
BYTE SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
BYTE VERT_FONT_SET[]      = "\x1D%dvpC";
BYTE BOLD_SET[]           = "\x1D%dweF";
BYTE ITALIC_SET[]         = "\x1D%dslF";

BYTE ORG_MODE_IN[]        = "\x1Bz\xD0\x01";
BYTE ORG_MODE_OUT[]       = "\x1Bz\x00\x01";
BYTE PALETTE_SELECT[]     = "Cd,%d,%d*";
BYTE PALETTE_DEFINE[]     = "Cf,%d,%d,%d,%d,%d*";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

BYTE OVERWRITE[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "1;0;100spE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_CASETTE_4  3
#define PSRC_CASETTE_5  4
#define PSRC_CASETTE_6  5
#define PSRC_MPF        6
#define PSRC_AUTO       7
BYTE *EJL_SelectPsrc[] = {
   " PU=1", " PU=2", " PU=255", " PU=254", " PU=253", " PU=252", " PU=4", " PU=AU" };

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

BYTE *EJL_SetColorTone[] = {
    " ##LE=OFF", " ##LE=ON", " ##LE=16" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2" };

// Modification of Color-mode command 2002.3.28 >>>
//BYTE *EJL_SetColorMode[] = {
//    " ##CM=OFF", " ##CM=ON" };
BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=NML", " ##CM=ECO", " ##CM=ECO2" };
// Modification of Color-mode command 2002.3.28 <<<

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MEDIATYPE_1 1
#define XX_MEDIATYPE_2 2
#define XX_MEDIATYPE_3 3
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS", " PK=TH" };

#define OUTBIN_EXIT_1 1
#define OUTBIN_EXIT_2 2
BYTE *EJL_SelectOutbin[] = {
   " ##ET=1", " ##ET=2" };

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31
/* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

#define PARAM(p,n) \
    (*((p)+(n)))

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
//        (dwFontID - FONT_MIN_ID), 0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                DLI_SELECT_FONT_ID, (dwFontID - FONT_MIN_ID), 0)) {
        return;
    }
    wlen += (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV         pOEM;
    BYTE            byOutput[64];
    DWORD           dwNeeded;
    DWORD           dwOptionsReturned;

    MY_VERBOSE(("\nOEMEnablePdev ENTRY\n"));

    if (!pdevobj->pdevOEM)
    {
        if (!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->sHeightDiv = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
    pOEM->iOutBin = 0;                  //+N5
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;

    // Get MYPDEV member
    // ColorMatching
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMatching", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMatching) Failed\n"));
        pOEM->Printer = PRN_N5;
        pOEM->iColorMatching = XX_COLORMATCH_NONE;
    } else {
        MY_VERBOSE(("            ColorMatching:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_COLORMATCH_BRI)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_BRI;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_TINT)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_TINT;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIV)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_VIV;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NONE)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        }
    }
    MY_VERBOSE(("            pOEM->Printer:[%d]\n", pOEM->Printer));
    MY_VERBOSE(("            pOEM->iColorMatching:[%d]\n", pOEM->iColorMatching));

    // Resolution
    if (!DRVGETDRIVERSETTING(pdevobj, "Resolution", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Resolution) Failed\n"));
        pOEM->iResolution = XX_RES_300DPI;
    } else {
        MY_VERBOSE(("            Resolution:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_1)) {
            pOEM->iResolution = XX_RES_300DPI;
            pOEM->iUnitFactor = 4;
            pOEM->sHeightDiv = 1;
        } else if (!strcmp(byOutput, OPT_2)) {
            pOEM->iResolution = XX_RES_600DPI;
            pOEM->iUnitFactor = 2;
            pOEM->sHeightDiv = 4;
        }
    }
    MY_VERBOSE(("            pOEM->iResolution:[%d]\n", pOEM->iResolution));
    MY_VERBOSE(("            pOEM->iUnitFactor:[%d]\n", pOEM->iUnitFactor));
    MY_VERBOSE(("            pOEM->sHeightDiv:[%d]\n", pOEM->sHeightDiv));

    // Dithering
    if (!DRVGETDRIVERSETTING(pdevobj, "Dithering", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Dithering) Failed\n"));
        pOEM->iDithering = XX_DITH_NON;
    } else {
        MY_VERBOSE(("            Dithering:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_DITH_NORMAL)) {
            pOEM->iDithering = XX_DITH_NORMAL;
        } else if (!strcmp(byOutput, OPT_DITH_DETAIL)) {
            pOEM->iDithering = XX_DITH_DETAIL;
        } else if (!strcmp(byOutput, OPT_DITH_EMPTY)) {
            pOEM->iDithering = XX_DITH_EMPTY;
        } else if (!strcmp(byOutput, OPT_DITH_SPREAD)) {
            pOEM->iDithering = XX_DITH_SPREAD;
        } else {
            pOEM->iDithering = XX_DITH_NON;
        }
    }
    MY_VERBOSE(("            pOEM->iDithering:[%d]\n", pOEM->iDithering));

    // BitFont
    if (!DRVGETDRIVERSETTING(pdevobj, "BitFont", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(BitFont) Failed\n"));
        pOEM->iBitFont = XX_BITFONT_OFF;
    } else {
        MY_VERBOSE(("            BitFont:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iBitFont = XX_BITFONT_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iBitFont = XX_BITFONT_ON;
        } else {
            pOEM->iBitFont = XX_BITFONT_OFF;
        }
    }
    MY_VERBOSE(("            pOEM->iBitFont:[%d]\n", pOEM->iBitFont));

    // CmyBlack
    if (!DRVGETDRIVERSETTING(pdevobj, "CmyBlack", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(CmyBlack) Failed\n"));
        pOEM->iCmyBlack = XX_CMYBLACK_NONE;
    } else {
        MY_VERBOSE(("            CmyBlack:[%s]\n", byOutput));
// CASIO 2001/02/15 ->
        if (pOEM->iDithering == XX_DITH_NON) {
            pOEM->iCmyBlack = XX_CMYBLACK_NONE;
//      if (!strcmp(byOutput, OPT_CMYBLACK_GRYBLK)) {
        } else if (!strcmp(byOutput, OPT_CMYBLACK_GRYBLK)) {
// CASIO 2001/02/15 <-
            pOEM->iCmyBlack = XX_CMYBLACK_GRYBLK;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLKTYPE1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLKTYPE1;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLKTYPE2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLKTYPE2;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLACK)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLACK;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_TYPE1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_TYPE1;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_TYPE2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_TYPE2;
        } else {
            pOEM->iCmyBlack = XX_CMYBLACK_NONE;
        }
    }
    MY_VERBOSE(("            pOEM->iCmyBlack:[%d]\n", pOEM->iCmyBlack));

    // ColorMode
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMode", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMode) Failed\n"));
        pOEM->iColor = XX_COLOR;
    } else {
        MY_VERBOSE(("            ColorMode:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_COLOR_SINGLE)) {
            pOEM->iColor = XX_COLOR_SINGLE;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY)) {
            pOEM->iColor = XX_COLOR_MANY;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY2)) {
            pOEM->iColor = XX_COLOR_MANY2;
        } else if (!strcmp(byOutput, OPT_COLOR)) {
            pOEM->iColor = XX_COLOR;
        } else if (!strcmp(byOutput, OPT_MONO)) {
            pOEM->iColor = XX_MONO;
        }
    }
    MY_VERBOSE(("            pOEM->iColor:[%d]\n", pOEM->iColor));

    // Compress
    if (!DRVGETDRIVERSETTING(pdevobj, "Compress", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Compress) Failed\n"));
        pOEM->iCompress = XX_COMPRESS_OFF;
    } else {
        MY_VERBOSE(("            Compress:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_AUTO)) {
            pOEM->iCompress = XX_COMPRESS_AUTO;
        } else if (!strcmp(byOutput, OPT_RASTER)) {
            pOEM->iCompress = XX_COMPRESS_RASTER;
        } else {
            pOEM->iCompress = XX_COMPRESS_OFF;
        }
    }
    MY_VERBOSE(("            pOEM->iCompress:[%d]\n", pOEM->iCompress));

    MY_VERBOSE(("            pdevobj->pPublicDM->dmICMMethod:[%d]\n", pdevobj->pPublicDM->dmICMMethod));
    if (pdevobj->pPublicDM->dmICMMethod == 1) {
        pOEM->iIcmMode = XX_ICM_NON;
    } else {
        pOEM->iIcmMode = XX_ICM_USE;
    }
    MY_VERBOSE(("            pOEM->iICMMethod:[%d]\n", pOEM->iIcmMode));

    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY 
     || pOEM->iColor == XX_COLOR_MANY2) {           //+N5
        if (ColMatchInit(pdevobj) == FALSE) {
            return NULL;
        }
    }
    MY_VERBOSE(("OEMEnablePdev END\n"));

    return pdevobj->pdevOEM;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMImageProcessing
//////////////////////////////////////////////////////////////////////////

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams)
{
    BOOL   bret;

    if (pIPParams->bBlankBand) {
        MY_VERBOSE(("BB=TRUE\n"));
        bret = TRUE;                // Not spool to printer
    }
    else {
        MY_VERBOSE(("BB=FALSE\n"));
        // DIB spool to printer
        bret = (DIBtoPrn(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, pIPParams)) ? TRUE : FALSE;
    }

    return (PBYTE)IntToPtr(bret);
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pdevobj->pdevOEM)
    {
        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {       //+N5
            ColMatchDisable(pdevobj);
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;
    UINT            num001;

    MY_VERBOSE(("OEMResetPDEV() Start\n"));
    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
//        *pOEMNew = *pOEMOld;
        pOEMNew->fGeneral         = pOEMOld->fGeneral;
        pOEMNew->iEscapement      = pOEMOld->iEscapement;
        pOEMNew->sHeightDiv       = pOEMOld->sHeightDiv;
        pOEMNew->iDevCharOffset   = pOEMOld->iDevCharOffset;
        pOEMNew->iPaperSource     = pOEMOld->iPaperSource;
        pOEMNew->iDuplex          = pOEMOld->iDuplex;
        pOEMNew->iTonerSave       = pOEMOld->iTonerSave;
        pOEMNew->iOrientation     = pOEMOld->iOrientation;
        pOEMNew->iResolution      = pOEMOld->iResolution; 
        pOEMNew->iColor           = pOEMOld->iColor;
        pOEMNew->iSmoothing       = pOEMOld->iSmoothing;
        pOEMNew->iJamRecovery     = pOEMOld->iJamRecovery;
        pOEMNew->iMediaType       = pOEMOld->iMediaType;
        pOEMNew->iOutBin          = pOEMOld->iOutBin;
        pOEMNew->iIcmMode         = pOEMOld->iIcmMode;
        pOEMNew->iUnitFactor      = pOEMOld->iUnitFactor;
        pOEMNew->iDithering       = pOEMOld->iDithering;
        pOEMNew->iColorMatching   = pOEMOld->iColorMatching;
        pOEMNew->iBitFont         = pOEMOld->iBitFont;
        pOEMNew->iCmyBlack        = pOEMOld->iCmyBlack;
        pOEMNew->iTone            = pOEMOld->iTone;
        pOEMNew->iPaperSize       = pOEMOld->iPaperSize;
        pOEMNew->iCompress        = pOEMOld->iCompress;
        pOEMNew->Printer          = pOEMOld->Printer;
        pOEMNew->wRectWidth       = pOEMOld->wRectWidth;
        pOEMNew->wRectHeight      = pOEMOld->wRectHeight;
        pOEMNew->dwDLFontID       = pOEMOld->dwDLFontID;
        pOEMNew->dwDLSelectFontID = pOEMOld->dwDLSelectFontID;
        pOEMNew->dwDLSetFontID    = pOEMOld->dwDLSetFontID;
        pOEMNew->wCharCode        = pOEMOld->wCharCode;

        pOEMNew->Col.wReso        = pOEMOld->Col.wReso;
        pOEMNew->Col.ColMon       = pOEMOld->Col.ColMon;
        pOEMNew->Col.DatBit       = pOEMOld->Col.DatBit;
        pOEMNew->Col.BytDot       = pOEMOld->Col.BytDot;
        pOEMNew->Col.Mch.Mode     = pOEMOld->Col.Mch.Mode;
        pOEMNew->Col.Mch.GryKToner= pOEMOld->Col.Mch.GryKToner;
        pOEMNew->Col.Mch.Viv      = pOEMOld->Col.Mch.Viv;
        pOEMNew->Col.Mch.LutNum   = pOEMOld->Col.Mch.LutNum;
        pOEMNew->Col.Mch.Diz      = pOEMOld->Col.Mch.Diz;
        pOEMNew->Col.Mch.Tnr      = pOEMOld->Col.Mch.Tnr;
        pOEMNew->Col.Mch.CmyBlk   = pOEMOld->Col.Mch.CmyBlk;
        pOEMNew->Col.Mch.Speed    = pOEMOld->Col.Mch.Speed;
        pOEMNew->Col.Mch.Gos32    = pOEMOld->Col.Mch.Gos32;
        pOEMNew->Col.Mch.PColor   = pOEMOld->Col.Mch.PColor;
        pOEMNew->Col.Mch.Ucr      = pOEMOld->Col.Mch.Ucr;
        pOEMNew->Col.Mch.SubDef   = pOEMOld->Col.Mch.SubDef;
        pOEMNew->Col.Mch.Bright   = pOEMOld->Col.Mch.Bright;
        pOEMNew->Col.Mch.Contrast = pOEMOld->Col.Mch.Contrast;
        pOEMNew->Col.Mch.GamRed   = pOEMOld->Col.Mch.GamRed;
        pOEMNew->Col.Mch.GamGreen = pOEMOld->Col.Mch.GamGreen;
        pOEMNew->Col.Mch.GamBlue  = pOEMOld->Col.Mch.GamBlue;
        pOEMNew->Col.Mch.CchMch   = pOEMOld->Col.Mch.CchMch;
        pOEMNew->Col.Mch.CchCnv   = pOEMOld->Col.Mch.CchCnv;
        pOEMNew->Col.Mch.CchRGB   = pOEMOld->Col.Mch.CchRGB;
        pOEMNew->Col.Mch.CchCMYK  = pOEMOld->Col.Mch.CchCMYK;
        pOEMNew->Col.Mch.LutMakGlb= pOEMOld->Col.Mch.LutMakGlb;
        pOEMNew->Col.Mch.KToner   = pOEMOld->Col.Mch.KToner;

        pOEMNew->Col.Dot  = pOEMOld->Col.Dot;
        if (NULL != pOEMNew->Col.lpColIF) { MemFree(pOEMNew->Col.lpColIF); }
        pOEMNew->Col.lpColIF = pOEMOld->Col.lpColIF;
        pOEMOld->Col.lpColIF = NULL;
        pOEMNew->Col.Mch.lpRGBInf = pOEMOld->Col.Mch.lpRGBInf;
        pOEMNew->Col.Mch.lpCMYKInf = pOEMOld->Col.Mch.lpCMYKInf;
        pOEMNew->Col.Mch.lpColMch = pOEMOld->Col.Mch.lpColMch;
        pOEMNew->Col.Mch.lpDizInf = pOEMOld->Col.Mch.lpDizInf;
        pOEMOld->Col.Mch.lpRGBInf = NULL;
        pOEMOld->Col.Mch.lpCMYKInf = NULL;
        pOEMOld->Col.Mch.lpColMch = NULL;
        pOEMOld->Col.Mch.lpDizInf = NULL;
        if (NULL != pOEMNew->Col.LutTbl) { MemFree(pOEMNew->Col.LutTbl); }
        pOEMNew->Col.LutTbl = pOEMOld->Col.LutTbl;
        pOEMOld->Col.LutTbl = NULL;
        if (NULL != pOEMNew->Col.CchRGB) { MemFree(pOEMNew->Col.CchRGB); }
        pOEMNew->Col.CchRGB = pOEMOld->Col.CchRGB;
        pOEMOld->Col.CchRGB = NULL;
        if (NULL != pOEMNew->Col.CchCMYK) { MemFree(pOEMNew->Col.CchCMYK); }
        pOEMNew->Col.CchCMYK = pOEMOld->Col.CchCMYK;
        pOEMOld->Col.CchCMYK = NULL;
        for (num001 = 0; num001 < 4; num001++) {
            if (NULL != pOEMNew->Col.DizTbl[num001]) { MemFree(pOEMNew->Col.DizTbl[num001]); }
            pOEMNew->Col.DizTbl[num001] = pOEMOld->Col.DizTbl[num001];
            pOEMOld->Col.DizTbl[num001] = NULL;
        }
        if (NULL != pOEMNew->Col.lpTmpRGB) { MemFree(pOEMNew->Col.lpTmpRGB); }
        pOEMNew->Col.lpTmpRGB = pOEMOld->Col.lpTmpRGB;
        pOEMOld->Col.lpTmpRGB = NULL;
        if (NULL != pOEMNew->Col.lpTmpCMYK) { MemFree(pOEMNew->Col.lpTmpCMYK); }
        pOEMNew->Col.lpTmpCMYK = pOEMOld->Col.lpTmpCMYK;
        pOEMOld->Col.lpTmpCMYK = NULL;
        if (NULL != pOEMNew->Col.lpDrwInf) { MemFree(pOEMNew->Col.lpDrwInf); }
        pOEMNew->Col.lpDrwInf = pOEMOld->Col.lpDrwInf;
        pOEMOld->Col.lpDrwInf = NULL;
        if (NULL != pOEMNew->Col.lpLut032) { MemFree(pOEMNew->Col.lpLut032); }
        pOEMNew->Col.lpLut032 = pOEMOld->Col.lpLut032;
        pOEMOld->Col.lpLut032 = NULL;
        if (NULL != pOEMNew->Col.lpUcr) { MemFree(pOEMNew->Col.lpUcr); }
        pOEMNew->Col.lpUcr = pOEMOld->Col.lpUcr;
        pOEMOld->Col.lpUcr = NULL;
        if (NULL != pOEMNew->Col.lpLutMakGlb) { MemFree(pOEMNew->Col.lpLutMakGlb); }
        pOEMNew->Col.lpLutMakGlb = pOEMOld->Col.lpLutMakGlb;
        pOEMOld->Col.lpLutMakGlb = NULL;
        if (NULL != pOEMNew->Col.lpGryTbl) { MemFree(pOEMNew->Col.lpGryTbl); }
        pOEMNew->Col.lpGryTbl = pOEMOld->Col.lpGryTbl;
        pOEMOld->Col.lpGryTbl = NULL;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT             iRet = 0;
    BYTE            Cmd[BUFFLEN];
    PMYPDEV         pOEM;
    WORD            wlen;
    WORD            wGray;
    DWORD           dwTempX, dwTempY;
    CMYK            TmpCmyk;
    RGBS            TmpRgb;
// MSKK 99/6/24
    WORD            wPalID;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6
    size_t pcb;          // 2002.3.6

    MY_VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_SINGLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_SINGLE_BYTE,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION, pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET, 0)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy(Cmd,FS_DOUBLE_BYTE);
//        wlen = (WORD)strlen( Cmd );
//        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (S_OK != StringCbCopyExA(Cmd, sizeof(Cmd), FS_DOUBLE_BYTE,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PRN_DIRECTION, pOEM->iEscapement)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        if (pOEM->fGeneral & FG_VERT)
        {
// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        VERT_FONT_SET, 1)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
        pOEM->fGeneral |= FG_DOUBLE;
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
//                         (pOEM->fGeneral & FG_BOLD)?15:0);
//        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
//                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_CASETTE_4:
        pOEM->iPaperSource = PSRC_CASETTE_4;
        break;

    case PSRC_SELECT_CASETTE_5:
        pOEM->iPaperSource = PSRC_CASETTE_5;
        break;

    case PSRC_SELECT_CASETTE_6:
        pOEM->iPaperSource = PSRC_CASETTE_6;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:
        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
//        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectPsrc[pOEM->iPaperSource],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectOrient[pOEM->iOrientation],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        // CASIO extention

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectRes[pOEM->iResolution],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Modification of Color-mode command 2002.3.28 >>>
#if 0
        if (pOEM->iColor > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorMode[1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
#else
        if (pOEM->iColor > 0) {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        } else {
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetColorMode[0],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
        }
#endif
// Modification of Color-mode command 2002.3.28 <<<

        if (pOEM->iDuplex > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetDuplex[pOEM->iDuplex - 1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }

        if (pOEM->iColor == XX_COLOR_MANY) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorTone[1] );
            if (S_OK != StringCbCopyA(&Cmd[wlen],sizeof(Cmd)-wlen,EJL_SetColorTone[1]))
                break;
// Replacement of strsafe-api 2002.3.6 <<<
        } else if (pOEM->iColor == XX_COLOR_MANY2) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorTone[2] );
            if (S_OK != StringCbCopyA(&Cmd[wlen],sizeof(Cmd)-wlen,EJL_SetColorTone[2]))
                break;
// Replacement of strsafe-api 2002.3.6 <<<
        } else {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetColorTone[0] );
            if (S_OK != StringCbCopyA(&Cmd[wlen],sizeof(Cmd)-wlen,EJL_SetColorTone[0]))
                break;
// Replacement of strsafe-api 2002.3.6 <<<
        }
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbLengthA(&Cmd[wlen], sizeof(Cmd)-wlen, &pcb))
            break;
        wlen += (WORD)pcb;
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetTonerSave[pOEM->iTonerSave],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetSmoohing[pOEM->iSmoothing],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetJamRecovery[pOEM->iJamRecovery],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen], " ##SN=ON");
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, " ##SN=ON",
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

        if (pOEM->iMediaType > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SetMediaType[pOEM->iMediaType - 1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
//+N5 Begin
        if (pOEM->iOutBin > 0) {
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen],  EJL_SelectOutbin[pOEM->iOutBin -1] );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EJL_SelectOutbin[pOEM->iOutBin -1],
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        }
//+N5 End

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == XX_RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
// Replacement of strsafe-api 2002.3.6 >>>
//        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
//        wlen += (WORD)strlen( &Cmd[wlen] );
        if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, EPg_SelectRes[pOEM->iResolution],
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
            break;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MEDIATYPE_1:
        pOEM->iMediaType = XX_MEDIATYPE_1;
        break;

    case MEDIATYPE_2:
        pOEM->iMediaType = XX_MEDIATYPE_2;
        break;
    case MEDIATYPE_3:
        pOEM->iMediaType = XX_MEDIATYPE_3;
        break;

    case OUTBIN_SELECT_EXIT_1:
        pOEM->iOutBin = OUTBIN_EXIT_1;
        break;

    case OUTBIN_SELECT_EXIT_2:
        pOEM->iOutBin = OUTBIN_EXIT_2;
        break;

    case DEFINE_PALETTE_ENTRY:
        //RGB -> CMYK
        TmpRgb.Red  = (BYTE)(PARAM(pdwParams, 1));
        TmpRgb.Grn  = (BYTE)(PARAM(pdwParams, 2));
        TmpRgb.Blu  = (BYTE)(PARAM(pdwParams, 3));

        memset(&TmpCmyk, 0x00, sizeof(TmpCmyk)); 
        ColMatching(pdevobj, No, No, &TmpRgb, (WORD)1, &TmpCmyk);

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, PALETTE_DEFINE, wPalID, TmpCmyk.Cyn,
//            TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PALETTE_DEFINE, wPalID,
                                    TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

        MY_VERBOSE(("DEFINE_PALETTE_ENTRY No %d\n",
            (INT)(PARAM(pdwParams, wPalID))));
        break;

    case BEGIN_PALETTE_DEF:
        MY_VERBOSE(("CmdBeginPaletteDef\n"));
        break;

    case END_PALETTE_DEF:
        MY_VERBOSE(("CmdEndPaletteDef\n"));
        break;

    case SELECT_PALETTE_ENTRY:
        MY_VERBOSE(("SELECT_PALETTE_ENTRY "));

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, wPalID);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    PALETTE_SELECT, 0, wPalID)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
        break;

    case START_PAGE:
        MY_VERBOSE(("OEMCommandCallback() START_PAGE Start\n"));
        WRITESPOOLBUF(pdevobj, CMD_START_PAGE, BYTE_LENGTH(CMD_START_PAGE));

        if (pOEM->iColor == XX_COLOR_MANY 
         || pOEM->iColor == XX_COLOR_MANY2                  //+N5
         || pOEM->iColor == XX_COLOR_SINGLE) {
            //Initialize palette state (Spools pure black color command)
            wlen = 0;
            TmpRgb.Red = TmpRgb.Grn = TmpRgb.Blu = 0;
            MY_VERBOSE(("OEMCommandCallback() ColMatching()\n"));
            ColMatching(pdevobj, No, No, &TmpRgb, (WORD)1, &TmpCmyk);
            
// Replacement of strsafe-api 2002.3.6 >>>
//            strcpy( &Cmd[wlen], ORG_MODE_IN );
//            wlen += (WORD)strlen( &Cmd[wlen] );
            if (S_OK != StringCbCopyExA(&Cmd[wlen], sizeof(Cmd)-wlen, ORG_MODE_IN,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<

// Replacement of strsafe-api 2002.3.6 >>>
//            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_DEFINE,
//                DEFAULT_PALETTE_INDEX,
//                TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
//            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_SELECT,
//                0, DEFAULT_PALETTE_INDEX);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        PALETTE_DEFINE,
                                        DEFAULT_PALETTE_INDEX,
                                        TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
            if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        PALETTE_SELECT,
                                        0, DEFAULT_PALETTE_INDEX)) {
                break;
            }
            wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 <<<
            WRITESPOOLBUF(pdevobj, Cmd, wlen);
            WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        }
        MY_VERBOSE(("OEMCommandCallback() START_PAGE End\n"));
        break;

    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID)) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        MY_VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

// Replacement of strsafe-api 2002.3.6 >>>
//        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
//            wGray,
//            (WORD)dwTempX,
//            (WORD)dwTempY,
//            (WORD)(dwTempX + pOEM->wRectWidth - 1),
//            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    RECT_FILL, 
                                    wGray,
                                    (WORD)dwTempX,
                                    (WORD)dwTempY,
                                    (WORD)(dwTempX + pOEM->wRectWidth - 1),
                                    (WORD)(dwTempY + pOEM->wRectHeight - 1))) {
            break;
        }
        wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 >>>
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 >>>
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
// Check of zero divide 2002.3.23 >>>
            if (width == 0) {
                ERR(("OEMSendFontCmd() 0Div-Check [width=0] \n"));
                return;
            }
// Check of zero divide 2002.3.23 <<<
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
// Replacement of strsafe-api 2002.3.6 >>>
//            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut], sizeof(aubCmd)-dwOut);
// Replacement of strsafe-api 2002.3.6 <<<
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
// Check of zero divide 2002.3.23 >>>
    if (pIFI->fwdUnitsPerEm == 0) {
        ERR(("OEMSendFontCmd() 0Div-Check [pIFI->fwdUnitsPerEm=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    MY_VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

// Replacement of strsafe-api 2002.3.6 >>>
//    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
//        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);
    if (S_OK != StringCbPrintfExA(Cmd, sizeof(Cmd),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_CHAR_OFFSET,
                                (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0)) {
        return;
    }
    wlen = (WORD)(pDestEnd - Cmd);
// Replacement of strsafe-api 2002.3.6 <<<

    if (pOEM->fGeneral & FG_VERT)
    {
// Replacement of strsafe-api 2002.3.6 >>>
//        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        if (S_OK != StringCbPrintfExA(&Cmd[wlen], sizeof(Cmd)-wlen,
                                    &pDestEnd, &szRemLen,
                                    STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                    VERT_FONT_SET, 1)) {
           return;
        }
        wlen += (WORD)(pDestEnd - &Cmd[wlen]);
// Replacement of strsafe-api 2002.3.6 >>>
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

// Replacement of strsafe-api 2002.3.6 >>>
//LONG
//LConvertFontSizeToStr(
//    LONG  size,
//    PSTR  pStr)
//{
//    register long count;
//
//    count = strlen(_ltoa(size / 100, pStr, 10));
//    pStr[count++] = '.';
//    count += strlen(_ltoa(size % 100, &pStr[count], 10));
//
//    return count;
//}
LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr,
    size_t StrSize)
{
    register long count;
    size_t pcb;

    if (S_OK != StringCbLengthA(_ltoa(size / 100, pStr, 10), StrSize, &pcb))
        return 0;
    count = (WORD)pcb;
    pStr[count++] = '.';
    if (S_OK != StringCbLengthA(_ltoa(size % 100, &pStr[count], 10), StrSize-count, &pcb))
        return 0;
    count += (WORD)pcb;

    return count;
}
// Replacement of strsafe-api 2002.3.6 <<<

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    MY_VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));

            /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
            /* So, we need not check whether it is NULL. */
            MemFree(pTransOrg);
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            MY_VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            MY_VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
                wLen = 0;
                break;
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            MY_VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
    /* So, we need not check whether it is NULL. */
    MemFree(pTransOrg);
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
//    BYTE sFontName[54];   // 2002.3.6 Buffer size insufficient
    BYTE sFontName[64];     // 2002.3.6
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;
    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    DL_VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    DL_VERBOSE(("TT Font:\n"));
    DL_VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    DL_VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    DL_VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    DL_VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    DL_VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if (pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    DL_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    DL_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    DL_VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    DL_VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if ( MasterToDevice(pOEM,wCellHeight) > 64 )
     {
         DL_VERBOSE(("Abort OEMDownloadFontHeader: pt=%d\n",
             MasterToDevice(pOEM, wCellHeight)));
         return 0;
     }
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

// Check of zero divide 2002.3.23 >>>
    if (iTemp == 0) {
        ERR(("OEMDownloadFontHeader() 0Div-Check [iTemp=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<
    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

// Replacement of strsafe-api 2002.3.6 >>>
//    iSizeFontName = wsprintf(sFontName,
//       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
    if (S_OK != StringCbPrintfExA(sFontName, sizeof(sFontName),
        &pDestEnd, &szRemLen,
        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
        "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeFontName = (WORD)(pDestEnd - sFontName);
//    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
        &pDestEnd, &szRemLen,
        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
        SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID)) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    DL_VERBOSE(("FontHeader:\n"));
    DL_VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    DL_VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    DL_VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    DL_VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    DL_VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    DL_VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    DL_VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    DL_VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    DL_VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    DL_VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    DL_VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    DL_VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    DL_VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    DL_VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    DL_VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    DL_VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    DL_VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    DL_VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    DL_VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    DL_VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    DL_VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    DL_VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    DL_VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    DL_VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    LPSTR  pDestEnd;     // 2002.3.6
    size_t szRemLen;     // 2002.3.6

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    MY_VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// Replacement of strsafe-api 2002.3.6 >>>
//// CASIO 98/11/24 ->
////    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
////        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
////    }else{
//        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
////    }
//// CASIO 98/11/24 <-
    if (S_OK != StringCbPrintfExA(Buff, sizeof(Buff),
                                &pDestEnd, &szRemLen,
                                STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp))) {
        return 0;
    }
    iSizeOfBuf = (WORD)(pDestEnd - Buff);
// Replacement of strsafe-api 2002.3.6 <<<
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    MY_VERBOSE(("ESCPageChar:\n"));
    MY_VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    MY_VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    MY_VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    MY_VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    MY_VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    MY_VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    MY_VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    MY_VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    DL_VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    )
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY
     || pOEM->iColor == XX_COLOR_MANY2) {
        pMemoryUsage->dwFixedMemoryUsage = 
            LUTSIZ016 + LUTSIZ032 + LUTSIZRGB + LUTSIZCMY + 
            CCHRGBSIZ + CCHCMYSIZ + 
            LUTGLBWRK + LUT032WRK + DIZINFWRK + 
            LUTFILESIZ + DIZFILESIZ + LUT032SIZ + 
            UCRTBLSIZ + UCRWRKSIZ + sRGBLUTFILESIZ + LUTMAKGLBSIZ;
        pMemoryUsage->dwPercentMemoryUsage = 100 * (pOEM->Col.DatBit * 4 + 24 + 32) / 32;

        MY_VERBOSE(("OEMMemoryUsage()  dwFixedMemoryUsage:[%d]\n", pMemoryUsage->dwFixedMemoryUsage));
        MY_VERBOSE(("                  dwPercentMemoryUsage:[%d]\n", pMemoryUsage->dwPercentMemoryUsage));
        MY_VERBOSE(("                  pOEM->Col.DatBit:[%d]\n", pOEM->Col.DatBit));
        MY_VERBOSE(("OEMMemOryUsage pOEM->Col.DatBit = %d\n",pOEM->Col.DatBit));
    }

    return;
}


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "PDEV.H"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include "strsafe.h"    // Security-Code 2002.3.6

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588588-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#include "strsafe.h"    // Security-Code 2002.3.6

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{

public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));

        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams);

        return S_OK;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));

        OEMMemoryUsage(pdevobj, pMemoryUsage);

        return S_OK;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\debug2.c ===
#include <minidrv.h>
#include <stdio.h>
#include <process.h>
#include <stdarg.h>
#include "debug2.h"
#include "strsafe.h"    // Security-Code 2002.3.6
//
// Functions for outputting debug messages
//

#ifdef DEBUG2_FILE
#if (DBG)

VOID DbgFPrint(LPCSTR pstrFormat,  ...)
{
    FILE *stream;
    va_list ap;
    char wbuff[512];

    va_start(ap, pstrFormat);
    if ((stream = fopen( DEBU2_FNAME, "a" )) == NULL) {
        return;
    }
    vfprintf(stream, pstrFormat, ap);
    fclose(stream);
    va_end(ap);
}

#ifdef DEBUG2_DUMP_USE
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    FILE *stream;
    LPBYTE cur_ptr;
    UINT cnt01;
    UINT cnt02;
    UINT line_max;
    UINT line_rem;
    BYTE d_dump_buff[256];
    
    if ((stream = fopen( DEBU2_FNAME, "a" )) == NULL) {
        return;
    }
    cur_ptr = src;

    line_max = src_size / 16;
    line_rem = src_size % 16;
    for (cnt01=0; cnt01 < line_max; cnt01++) {
        memset(d_dump_buff, 0x00, sizeof(d_dump_buff));
        for (cnt02=0; cnt02 < 16; cnt02++) {
// Replacement of strsafe-api 2002.3.6 >>>
//            sprintf(d_dump_buff+(3*cnt02), " %02X", *(cur_ptr + cnt02));
            if (S_OK != StringCbPrintfExA(d_dump_buff+(3*cnt02), sizeof(d_dump_buff)-(3*cnt02),
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        " %02X", *(cur_ptr + cnt02))) {
                fclose(stream);
                return;
            }
// Replacement of strsafe-api 2002.3.6 >>>
+        }
        fprintf(stream, d_dump_buff);
        fprintf(stream, "\n");

        cur_ptr += 16;
    }
    if (line_rem > 0) {
        memset(d_dump_buff, 0x00, sizeof(d_dump_buff));
        for (cnt02=0; cnt02 < 16 && cnt02 < line_rem; cnt02++) {
// Replacement of strsafe-api 2002.3.6 >>>
//            sprintf(d_dump_buff+(3*cnt02), " %02X ", *(cur_ptr + cnt02));
            if (S_OK != StringCbPrintfExA(d_dump_buff+(3*cnt02), sizeof(d_dump_buff)-(3*cnt02),
                                        &pDestEnd, &szRemLen,
                                        STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE,
                                        " %02X", *(cur_ptr + cnt02))) {
                fclose(stream);
                return;
            }
// Replacement of strsafe-api 2002.3.6 <<<
        }
        fprintf(stream, d_dump_buff);
        fprintf(stream, "\n");
    }
    fclose(stream);
}
#else   // DEBUG2_DUMP_USE
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    ;
}
#endif  // DEBUG2_DUMP_USE

#else   // DBG
VOID DbgFPrint(LPCSTR pstrFormat,  ...)
{
    ;
}
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    ;
}
#endif  // DBG
#endif  // DEBUG2_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\debug2.h ===
#ifndef _DEBUG2_H_
#define _DEBUG2_H_

// Select 'File output' Or 'Normal VERBOSE'
//#define DEBUG2_FILE

#ifdef DEBUG2_FILE
#define DEBU2_FNAME     "C:\\TEMP\\unilog.txt"
//#define DEBUG2_DUMP_USE
    VOID DbgFPrint(LPCSTR,  ...);
    VOID DbgFDump(LPBYTE, UINT);
#endif  // DEBUG2_FILE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colmh.h ===
//***************************************************************************************************
//    N5COLMH.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID  WINAPI N501ColCchIni(LPCOLMCHINF);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColGryTblMak(DWORD, LPCMYK, LPBYTE, LPBYTE);
DWORD WINAPI N501ColUcrTblMak(DWORD, LPCMYK, LPCMYK, LPBYTE);
#endif

VOID  WINAPI N501ColMchPrc(DWORD, LPRGB, LPCMYK, LPCOLMCHINF);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID  WINAPI N501ColPtcPrc(DWORD, DWORD, LPBYTE, LPCMYK, LPCMYK);
#endif

VOID  WINAPI N501ColCnvC2r(DWORD, LPCMYK, LPRGB, DWORD, LPBYTE);

//  End of N5COLMH.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colmh.c ===
//***************************************************************************************************
//    N5COLMH.C
//
//    Functions color matching (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLMH.H"
#include    "strsafe.h"    // Security-Code 2002.3.6


//===================================================================================================
//      Dot gain revision table
//===================================================================================================
//static BYTE GinTblP10[256] = {
//    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
//    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
//    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
//    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
//    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
//    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
//    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
//    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
//    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
//    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
//    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
//    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
//    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
//    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
//    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
//    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
//    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
//    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
//    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
//    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
//    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
//    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
//    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
//    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
//    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
//    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
//    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
//    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
//    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
//    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
//    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
//    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
//};


//---------------------------------------------------------------------------------------------------
//      Color matching(high speed)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch000(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(normal speed)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch001(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(solid)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvSld(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);

//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK(2Level) conversion (for 1dot line)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColCnvL02(
    DWORD,
    LPRGB,
    LPCMYK
);
#endif

//---------------------------------------------------------------------------------------------------
//      RGB -> K conversion (for monochrome)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvMon(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);

//---------------------------------------------------------------------------------------------------
//      Color matching(UCR)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMchUcr(
    LPCMYK,
    LPRGB,
    DWORD,
    DWORD,
    DWORD,
    DWORD,                                                  //+ UCR (Toner gross weight)   CASIO 2001/02/15
    LPCMYK
);
#endif


//***************************************************************************************************
//      Function
//***************************************************************************************************
//===================================================================================================
//      Cache table initialize
//===================================================================================================
VOID WINAPI N501ColCchIni(                                  // Return value no
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       cnt;
    RGBS        colRgb;
    CMYK        colCmy;
    LPRGB       cchRgb;
    LPCMYK      cchCmy;

    if ((mchInf->CchRgb == NULL) || (mchInf->CchCmy == NULL)) return;

    cchRgb = mchInf->CchRgb;
    cchCmy = mchInf->CchCmy;
    colRgb.Red = colRgb.Grn = colRgb.Blu = 255;
    colCmy.Cyn = colCmy.Mgt = colCmy.Yel = colCmy.Bla = 0;

    /*----- Cache table initialize -----------------------------------*/
    for (cnt = 0; cnt < CCHTBLSIZ; cnt++) {
        *cchRgb = colRgb;
        *cchCmy = colCmy;
        cchRgb++;
        cchCmy++;
    }

    return;
}


//===================================================================================================
//      Gray transfer table make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColGryTblMak(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    DWORD       colMch,                                     // Color matching
    LPCMYK      lutAdr,                                     // LUT address
    LPBYTE      gryTbl,                                     // Gray transfer table          (*1)
    LPBYTE      wrk                                         // Work                         (*2)
)
{
    COLMCHINF   mchInf;                                     // Color matching information
    LPRGB       rgb;                                        // struct ColRgb rgb[256]
    LPCMYK      gry;                                        // struct ColCmy gry[256]
    DWORD       n, tmp, tmC, tmM, tmY;

    /*----- Input parameter check --------------------------------------------------*/
    if ((lutAdr == NULL) || (gryTbl == NULL) || (wrk == NULL)) return ERRILLPRM;

    /*----- Work buffer setting ----------------------------------------------------*/
    rgb = (LPRGB)wrk;                   /* Work for gray transformation RGB   768B  */
    gry = (LPCMYK)(wrk + (sizeof(RGBS) * 256));
                                        /* Work for gray transformation CMYK 1024B  */

    /*----- Color matching information setting for gray value table generation -----*/
    mchInf.Mch = MCHNML;                /* Color matching     nornal        */
    mchInf.Bla = KCGNON;                /* Black replacement  NO Fixed      */
    mchInf.Ucr = UCRNOO;                /* UCR                NO Fixed      */
    mchInf.LutAdr = lutAdr;             /* LUT address        input value   */
    mchInf.ColQty = (DWORD)0;           /* Color quality      0 Fixed       */
    mchInf.ColAdr = NULL;               /* Color address       NULL Fixed   */
    mchInf.CchRgb = NULL;               /* Cache for RGB       NULL Fixed   */
    mchInf.CchCmy = NULL;               /* Cache for CMYK      NULL Fixed   */

    /*----- Gray value(RGB value before transformation) setting --------------------*/
    for (n = 0; n < (DWORD)256; n++)
        rgb[n].Red = rgb[n].Grn = rgb[n].Blu = (BYTE)n;

    /*----- Gray value(RGB -> CMYK) ------------------------------------------------*/
    switch (colMch) {
        case MCHNML: ExeColMch001((DWORD)256, rgb, gry, &mchInf); break;
        default:     ExeColCnvSld((DWORD)256, rgb, gry, &mchInf); break;
    }

    /*----- Gray transfer table setting --------------------------------------------*/
    for (n = 0; n < (DWORD)256; n++) {
        tmC = gry[n].Cyn;
        tmM = gry[n].Mgt;
        tmY = gry[n].Yel;
        tmp = (tmC * (DWORD)30 + tmM * (DWORD)59 + tmY * (DWORD)11) / (DWORD)100;
        gryTbl[n] = (BYTE)tmp;
    }
    gryTbl[255] = (BYTE)0;              /* White is '0' fix */

    /*  gryTbl[0] ` [16] adjusted to line (gryTbl[0](Black) is '255' fix)      */
    tmp = (DWORD)255 - gryTbl[16];
    for (n = 0; n < (DWORD)16; n++) {
        gryTbl[n] = (BYTE)((tmp * ((DWORD)16 - n)) / (DWORD)16) + gryTbl[16];
    }

    return ERRNON;
}
#endif

//===================================================================================================
//      UCR table Make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColUcrTblMak(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    DWORD       colMch,                                     // Color matching
    LPCMYK      lutAdr,                                     // LUT address
    LPCMYK      ucrTbl,                                     // Table for UCR
    LPBYTE      wrk                                         // Work
)
{
    COLMCHINF   mchInf;                                     // Color matching information
    LPRGB       rgb;                                        // struct ColRgb rgb[256]
    LPCMYK      gry;                                        // struct ColCmy gry[257]
    LPCMYK      gryCyn;                                     // Gray value    (Cyan conversion value)
    LPCMYK      dnsCyn;                                     // Density value (Cyan conversion value)
    DWORD       loC, hiC, loM, hiM, loY, hiY, loK, hiK, saC, saM, saY, saK, n, m;
    DWORD       tmp, tmC, tmM, tmY;

    /*----- Input parameter check --------------------------------------------------*/
    if ((colMch != MCHFST) && (colMch != MCHNML) && (colMch != MCHSLD))
        return ERRILLPRM;
    if ((lutAdr == NULL) || (ucrTbl == NULL) || (wrk == NULL)) return ERRILLPRM;

    /*----- Work buffer setting ----------------------------------------------------*/
    rgb = (LPRGB)wrk;                   /* Work for gray transformation RGB   768B  */
    gry = (LPCMYK)(wrk + (sizeof(RGBS) * 256));
                                        /* Work for gray transformation CMYK 1028B  */

    /*----- LUT table pointer setting ----------------------------------------------*/
    gryCyn = ucrTbl;
    dnsCyn = ucrTbl + 256;

    /*----- Color matching information setting for gray value table generation -----*/
    mchInf.Mch = colMch;                /* Color matching      input value  */
    mchInf.Bla = KCGNON;                /* Black replacement   NO Fixed     */
    mchInf.Ucr = UCRNOO;                /* UCR                 NO Fixed     */
    mchInf.LutAdr = lutAdr;             /* LUT address         input value  */
    mchInf.ColQty = (DWORD)0;           /* Color quality       0 Fixed      */
    mchInf.ColAdr = NULL;               /* Color address       NULL Fixed   */
    mchInf.CchRgb = NULL;               /* Cache for RGB       NULL Fixed   */
    mchInf.CchCmy = NULL;               /* Cache for CMYK      NULL Fixed   */

    /*----- Gray value(RGB value before transformation) setting ---------------------*/
    for (n = 0; n < (DWORD)256; n++)
        rgb[n].Red = rgb[n].Grn = rgb[n].Blu = (BYTE)(255 - n);

    /*----- Gray value(RGB -> CMYK) -------------------------------------------------*/
    switch (colMch) {
        case MCHFST: ExeColMch000((DWORD)256, rgb, gry, &mchInf); break;
        case MCHNML: ExeColMch001((DWORD)256, rgb, gry, &mchInf); break;
//      default:     ExeColCnvSld((DWORD)256, rgb, gry, mchInf.Bla); break;
        default:     ExeColCnvSld((DWORD)256, rgb, gry, &mchInf); break;
    }

    /*----- Gray value(K) setting ---------------------------------------------------*/
//    for (n = 0; n < (DWORD)256; n++) gry[n].Bla = GinTblP10[n];
    for (n = 0; n < (DWORD)256; n++) {
//CASIO 2001/02/15 ->
//      tmC = gry[255 - n].Cyn;
//      tmM = gry[255 - n].Mgt;
//      tmY = gry[255 - n].Yel;
        tmC = gry[n].Cyn;
        tmM = gry[n].Mgt;
        tmY = gry[n].Yel;
        tmp = (tmC * (DWORD)30 + tmM * (DWORD)59 + tmY * (DWORD)11) / (DWORD)100;
//      gry[n].Bla = (BYTE)(255 - tmp);
        gry[n].Bla = (BYTE)tmp;
//CASIO 2001/02/15 <-
    }

    /*  gry[0] ` [16].Bla adjusted to line (gry[0].Bla(White) is '0' fix)      */
    tmp = gry[16].Bla;
    for (n = 0; n < (DWORD)16; n++) {
        gry[n].Bla = (BYTE)((tmp * n + (DWORD)15) / (DWORD)16);
    }

    /*----- Gray value, Limiter value setting for density value calculation ---------*/
    gry[256].Cyn = gry[256].Mgt = gry[256].Yel = gry[256].Bla = (BYTE)255;

    /*----- Gray value, Density value(Each Cyan conversion value) calculation -------*/
    for (n = 0; n < (DWORD)256; n++) {
        loC = gry[n].Cyn; hiC = gry[n + 1].Cyn; saC = (hiC > loC)? hiC - loC: 0;
        loM = gry[n].Mgt; hiM = gry[n + 1].Mgt; saM = (hiM > loM)? hiM - loM: 0;
        loY = gry[n].Yel; hiY = gry[n + 1].Yel; saY = (hiY > loY)? hiY - loY: 0;
        loK = gry[n].Bla; hiK = gry[n + 1].Bla; saK = (hiK > loK)? hiK - loK: 0;
        for (m = 0; m < saC; m++) gryCyn[m + loC].Mgt = (BYTE)(saM * m / saC + loM);
        for (m = 0; m < saC; m++) gryCyn[m + loC].Yel = (BYTE)(saY * m / saC + loY);
        for (m = 0; m < saC; m++) gryCyn[m + loC].Bla = (BYTE)(saK * m / saC + loK);
        for (m = 0; m < saM; m++) dnsCyn[m + loM].Mgt = (BYTE)(saC * m / saM + loC);
        for (m = 0; m < saY; m++) dnsCyn[m + loY].Yel = (BYTE)(saC * m / saY + loC);
    }
//CASIO 2001/02/15 ->
    gryCyn[255].Mgt = gryCyn[255].Yel = gryCyn[255].Bla = 
    dnsCyn[255].Mgt = dnsCyn[255].Yel = (BYTE)255;
//CASIO 2001/02/15 <-

    return ERRNON;
}
#endif

//===================================================================================================
//      Color matching procedure
//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK
//===================================================================================================
VOID WINAPI N501ColMchPrc(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (Pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    switch (mchInf->Mch) {
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case MCHFST:                                        // LUT transformation(high speed)
            ExeColMch000(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHNML:                                        // LUT transformation(normal speed)
            ExeColMch001(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHSLD:                                        // NO (solid)
//          ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf->Bla);
            ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHPRG:                                        // Primary color(progressive)
            ExeColCnvL02(xaxSiz, rgbAdr, cmyAdr);
            break;
#endif
        case MCHMON:                                        // Monochrome
//            ExeColCnvMon(xaxSiz, rgbAdr, cmyAdr);
            ExeColCnvMon(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        default:                                            // Indistinct
//          ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf->Bla);
            ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf);
    }

    return;
}


//===================================================================================================
//      Palette table transformation procedure
//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000
VOID WINAPI N501ColPtcPrc(                                  // Return value no
    DWORD       colBit,                                     // Data bit value
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPBYTE      srcAdr,                                     // RGB (input)
    LPCMYK      dstAdr,                                     // CMYK (output)
    LPCMYK      pltAdr                                      // Palette table address
)
{
    DWORD       cntXax;
    DWORD       cntBit;
    DWORD       bitNum;
    BYTE        pltNum;

    /*===== 256 color (8bit) ===============================================*/
    if (colBit == 8) {
        for (cntXax = xaxSiz; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr]; dstAdr++;
            srcAdr++;
        }
        return;
    }

    /*===== 16 color (4bit) ================================================*/
    if (colBit == 4) {
        for (cntXax = xaxSiz / 2; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 4]; dstAdr++; *srcAdr <<= 4;
            *dstAdr = pltAdr[*srcAdr >> 4]; dstAdr++;
            srcAdr++;
        }
        if (xaxSiz % 2) 
            *dstAdr = pltAdr[*srcAdr >> 4];
        return;
    }

    /*====  4 color (2bit) =================================================*/
    if (colBit == 2) {
        for (cntXax = xaxSiz / 4; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++;
            srcAdr++;
        }
        for (cntXax = xaxSiz % 4; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
        }
        return;
    }

    /*=====  2 color (1bit) ================================================*/
    if (colBit == 1) {
        for (cntXax = xaxSiz / 8; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++;
            srcAdr++;
        }
        for (cntXax = xaxSiz % 8; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
        }
        return;
    }

    /*===== Others(7, 6, 5, 3bit) =========================================*/
    bitNum = 0;
    for (cntXax = 0; cntXax < xaxSiz; cntXax++) {
        pltNum = (BYTE)0x00;
        for (cntBit = colBit; cntBit > 0; cntBit--) {
            if (srcAdr[bitNum / 8] & ((BYTE)0x80 >> bitNum % 8)) {
                pltNum |= ((BYTE)0x01 << (cntBit - 1));
            }
            bitNum++;
        }
        *dstAdr = pltAdr[pltNum]; dstAdr++;
    }

    return;
}
#endif

//===================================================================================================
//      CMYK -> RGB conversion
//===================================================================================================
VOID WINAPI N501ColCnvC2r(                                  // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPCMYK      cmyAdr,                                     // CMYK (input)
    LPRGB       rgbAdr,                                     // RGB (output)
    DWORD       gldNum,                                     // LUT Grid number
    LPBYTE      lutTblRgb                                   // LUT Address (R->G->B)
)
{
    DWORD       tmpC00, tmpM00, tmpY00, tmpK00;
    DWORD       tmpC01, tmpM01, tmpY01, tmpK01;
    DWORD       lenCyn, lenMgt, lenYel, lenBla;
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       calPrm;
    LPCMYK      endAdr;
    LPRGB       lutCmy;
    RGBS        tmpRgb, tmpRgbSav;
    LPRGB       lutTbl;
    RGBS        lutTbl000;

    lutTbl = (LPRGB)lutTblRgb;
    lutTbl000.Red = lutTbl->Blu;
    lutTbl000.Grn = lutTbl->Grn;
    lutTbl000.Blu = lutTbl->Red;

    for (endAdr = cmyAdr + xaxSiz; cmyAdr < endAdr; cmyAdr++) {
        tmpC00 = cmyAdr->Cyn;
        tmpM00 = cmyAdr->Mgt;
        tmpY00 = cmyAdr->Yel;
        tmpK00 = cmyAdr->Bla;

        /*----- Monochrome ----------------------------------------------------------*/
        if ((tmpC00 | tmpM00 | tmpY00) == 0) {
            if (tmpK00 == 0) { *rgbAdr = lutTbl000; rgbAdr++; continue; }
            tmpK01 = tmpK00;
            tmpK00 = tmpK00 * (gldNum - 1) / 255;
            lenBla = tmpK01 * (gldNum - 1) - tmpK00 * 255;
            tmpK01 = (tmpK01 * (gldNum - 1) + 254) / 255;

            calPrm = (DWORD)255 - lenBla;
            tmpRgb = lutTbl[tmpK00 * gldNum * gldNum * gldNum];
            tmpRed = calPrm * tmpRgb.Red;
            tmpGrn = calPrm * tmpRgb.Grn;
            tmpBlu = calPrm * tmpRgb.Blu;

            calPrm = lenBla;
            tmpRgb = lutTbl[tmpK01 * gldNum * gldNum * gldNum];
            tmpRed += calPrm * tmpRgb.Red;
            tmpGrn += calPrm * tmpRgb.Grn;
            tmpBlu += calPrm * tmpRgb.Blu;

            tmpRed += (DWORD)255 / 2;
            tmpGrn += (DWORD)255 / 2;
            tmpBlu += (DWORD)255 / 2;

//          tmpRgb.Red = (BYTE)(tmpRed / (DWORD)255);
//          tmpRgb.Blu = (BYTE)(tmpBlu / (DWORD)255);
            tmpRgb.Red = (BYTE)(tmpBlu / (DWORD)255);
            tmpRgb.Grn = (BYTE)(tmpGrn / (DWORD)255);
            tmpRgb.Blu = (BYTE)(tmpRed / (DWORD)255);

            *rgbAdr = tmpRgb;
            rgbAdr++;
            continue;
        }

        /*----- CMYK -> RGB ---------------------------------------------------------*/
        tmpC01 = tmpC00;
        tmpC00 = tmpC00 * (gldNum - 1) / 255;
        lenCyn = tmpC01 * (gldNum - 1) - tmpC00 * 255;
        tmpC01 = (tmpC01 * (gldNum - 1) + 254) / 255;

        tmpM01 = tmpM00;
        tmpM00 = tmpM00 * (gldNum - 1) / 255;
        lenMgt = tmpM01 * (gldNum - 1) - tmpM00 * 255;
        tmpM01 = (tmpM01 * (gldNum - 1) + 254) / 255;

        tmpY01 = tmpY00;
        tmpY00 = tmpY00 * (gldNum - 1) / 255;
        lenYel = tmpY01 * (gldNum - 1) - tmpY00 * 255;
        tmpY01 = (tmpY01 * (gldNum - 1) + 254) / 255;

        tmpK01 = tmpK00;
        tmpK00 = tmpK00 * (gldNum - 1) / 255;
        lenBla = tmpK01 * (gldNum - 1) - tmpK00 * 255;
        tmpK01 = (tmpK01 * (gldNum - 1) + 254) / 255;

        lutCmy = lutTbl + tmpK00 * gldNum * gldNum * gldNum;

        /* 0 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed = calPrm * tmpRgb.Red;
        tmpGrn = calPrm * tmpRgb.Grn;
        tmpBlu = calPrm * tmpRgb.Blu;
        /* 1 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 2 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 3 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 4 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 5 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 6 */
        calPrm = lenCyn*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 7 */
        calPrm = lenCyn*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 * 255 * 255 / 2;
        tmpGrn += (DWORD)255 * 255 * 255 / 2;
        tmpBlu += (DWORD)255 * 255 * 255 / 2;
//      tmpRgbSav.Red = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));
//      tmpRgbSav.Blu = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Red = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Grn = (BYTE)(tmpGrn / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Blu = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));

        if (tmpK01 == tmpK00) { *rgbAdr = tmpRgbSav; rgbAdr++; continue; }

        lutCmy = lutTbl + tmpK01 * gldNum * gldNum * gldNum;
        /* 0 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed = calPrm * tmpRgb.Red;
        tmpGrn = calPrm * tmpRgb.Grn;
        tmpBlu = calPrm * tmpRgb.Blu;
        /* 1 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 2 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 3 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 4 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 5 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 6 */
        calPrm = lenCyn*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 7 */
        calPrm = lenCyn*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 * 255 * 255 / 2;
        tmpGrn += (DWORD)255 * 255 * 255 / 2;
        tmpBlu += (DWORD)255 * 255 * 255 / 2;
//      tmpRgb.Red = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));
//      tmpRgb.Blu = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgb.Red = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgb.Grn = (BYTE)(tmpGrn / ((DWORD)255 * 255 * 255));
        tmpRgb.Blu = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));

        calPrm = (DWORD)255 - lenBla;
        tmpRed = calPrm * tmpRgbSav.Red;
        tmpGrn = calPrm * tmpRgbSav.Grn;
        tmpBlu = calPrm * tmpRgbSav.Blu;

        calPrm = lenBla;
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 / 2;
        tmpGrn += (DWORD)255 / 2;
        tmpBlu += (DWORD)255 / 2;

        tmpRgb.Red = (BYTE)(tmpRed / (DWORD)255);
        tmpRgb.Grn = (BYTE)(tmpGrn / (DWORD)255);
        tmpRgb.Blu = (BYTE)(tmpBlu / (DWORD)255);

        *rgbAdr = tmpRgb;
        rgbAdr++;
    }

    return;
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//      Color matching(high speed) (for 32GridLUT)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch000(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       blaCnv, ucr;
    DWORD       ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPRGB       endAdr;
    LPCMYK      lutTbl, ucrTbl;
    CMYK        tmpCmy;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;
    lutTbl = mchInf->LutAdr;
    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        if (blaCnv == KCGGRY) {
            if ((tmpRed == tmpGrn) && (tmpRed == tmpBlu)) {
                tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
//                tmpCmy.Bla = 255 - GinTblP10[tmpRed];
                tmpCmy.Bla = gryTbl[tmpRed];
                *cmyAdr = tmpCmy;
                cmyAdr++;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpRed | tmpGrn | tmpBlu) == 0) {
                tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
                tmpCmy.Bla = 255;
                *cmyAdr = tmpCmy;
                cmyAdr++;
                continue;
            }
        }
        *cmyAdr = lutTbl[tmpRed / 8 * GLDNUM032 * GLDNUM032 + 
                         tmpGrn / 8 * GLDNUM032 + 
                         tmpBlu / 8];

        /*----- UCR Procedure -------------------------------------------------------*/
//      if (ucr != UCRNOO) ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrTbl);
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-

        cmyAdr++;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(normal speed) (for 16Grid)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch001(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpR00, tmpG00, tmpB00;
    DWORD       lenRed, lenGrn, lenBlu;
    DWORD       lenR00, lenG00, lenB00;
    DWORD       tmpRxC, tmpGxM, tmpBxY, tmpBla;
    DWORD       calPrm;
    DWORD       cch;
    DWORD       blaCnv;
    DWORD       n, colDefQty, ucr, cchTblSiz;
    DWORD       ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPCMYK      lutTbl;
    LPCMYK      lutCur;
    LPCMYK      ucrTbl;
    RGBS        tmpRgb, cchBufRgb;
    LPRGB       cchRgb;
    CMYK        tmpCmy, cchBufCmy;
    LPCMYK      cchCmy;
    CMYK        cmyBla;
    LPCOLCOLDEF colDef;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;
    lutTbl = mchInf->LutAdr;
    colDefQty = mchInf->ColQty;
    colDef = mchInf->ColAdr;
    if ((mchInf->CchRgb == NULL) || (mchInf->CchCmy == NULL)) {
        cchTblSiz = (DWORD)1;
        cchRgb = &cchBufRgb;
        cchCmy = &cchBufCmy;
        cchRgb->Red = cchRgb->Grn = cchRgb->Blu = (BYTE)255;
        cchCmy->Cyn = cchCmy->Mgt = cchCmy->Yel = cchCmy->Bla = (BYTE)0;
    } else {
        cchTblSiz = CCHTBLSIZ;
        cchRgb = mchInf->CchRgb;
        cchCmy = mchInf->CchCmy;
    }

    cmyBla.Cyn = cmyBla.Mgt = cmyBla.Yel = 0; cmyBla.Bla = 255;

    for (; xaxSiz > 0; xaxSiz--) {
        tmpRgb = *rgbAdr++;
        tmpB00 = tmpRgb.Blu; tmpG00 = tmpRgb.Grn; tmpR00 = tmpRgb.Red;

        if (blaCnv == KCGGRY) {
            if ((tmpR00 == tmpG00) && (tmpR00 == tmpB00)) {
                tmpCmy = cmyBla;
//                tmpCmy.Bla -= GinTblP10[tmpR00];
                tmpCmy.Bla = gryTbl[tmpR00];
                *cmyAdr++ = tmpCmy;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpR00 | tmpG00 | tmpB00) == 0) {
                *cmyAdr++ = cmyBla;
                continue;
            }
        }

        /*----- Color setting -------------------------------------------------------*/
        if (colDefQty) {
            for (n = 0; n < colDefQty; n++) {
                if ((colDef[n].Red == (BYTE)tmpR00) &&
                    (colDef[n].Grn == (BYTE)tmpG00) &&
                    (colDef[n].Blu == (BYTE)tmpB00)) {
                    cmyAdr->Cyn = colDef[n].Cyn;
                    cmyAdr->Mgt = colDef[n].Mgt;
                    cmyAdr->Yel = colDef[n].Yel;
                    cmyAdr->Bla = colDef[n].Bla;
                    cmyAdr++;
                    break;
                }
            }
            if (n != colDefQty) continue;
        }

        /*----- Color matching cache  -----------------------------------------------*/
        cch = (tmpR00 * 49 + tmpG00 * 9 + tmpB00) % cchTblSiz;
        if ((cchRgb[cch].Red == (BYTE)tmpR00) && 
            (cchRgb[cch].Grn == (BYTE)tmpG00) && 
            (cchRgb[cch].Blu == (BYTE)tmpB00)) { 
            *cmyAdr++ = cchCmy[cch];
            continue;
        }

        /*----- RGB -> CMYK transformation ------------------------------------------*/
        tmpRxC = tmpR00;
        tmpR00 = tmpRxC * (GLDNUM016 - 1) / 255;
        lenRed = tmpRxC * (GLDNUM016 - 1) - tmpR00 * 255;
        lenR00 = (DWORD)255 - lenRed;

        tmpGxM = tmpG00;
        tmpG00 = tmpGxM * (GLDNUM016 - 1) / 255;
        lenGrn = tmpGxM * (GLDNUM016 - 1) - tmpG00 * 255;
        lenG00 = (DWORD)255 - lenGrn;

        tmpBxY = tmpB00;
        tmpB00 = tmpBxY * (GLDNUM016 - 1) / 255;
        lenBlu = tmpBxY * (GLDNUM016 - 1) - tmpB00 * 255;
        lenB00 = (DWORD)255 - lenBlu;

        lutCur = &lutTbl[(tmpR00 * GLDNUM016 + tmpG00) * GLDNUM016 + tmpB00];

        /* 0 */
        calPrm = lenR00 * lenG00 * lenB00;
        tmpCmy = *lutCur;
        tmpRxC = calPrm * tmpCmy.Cyn;
        tmpGxM = calPrm * tmpCmy.Mgt;
        tmpBxY = calPrm * tmpCmy.Yel;
        tmpBla = calPrm * tmpCmy.Bla;

        /* 1 */
        if (lenBlu) {
            calPrm = lenR00 * lenG00 * lenBlu;
            tmpCmy = *(lutCur + 1);
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 2 */
        if (lenGrn) {
            calPrm = lenR00 * lenGrn * lenB00;
            tmpCmy = *(lutCur + GLDNUM016);
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 3 */
        if (lenGrn && lenBlu) {
            calPrm = lenR00 * lenGrn * lenBlu;
            tmpCmy = *(lutCur + (GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 4 */
        if (lenRed) {
            calPrm = lenRed * lenG00 * lenB00;
            tmpCmy = *(lutCur + (GLDNUM016 * GLDNUM016));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 5 */
        if (lenRed && lenBlu) {
            calPrm = lenRed * lenG00 * lenBlu;
            tmpCmy = *(lutCur + (GLDNUM016 * GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 6 */
        if (lenRed && lenGrn) {
            calPrm = lenRed * lenGrn * lenB00;
            tmpCmy = *(lutCur + ((GLDNUM016 + 1) * GLDNUM016));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 7 */
        if (lenRed && lenGrn && lenBlu) {
            calPrm = lenRed * lenGrn * lenBlu;
            tmpCmy = *(lutCur + ((GLDNUM016 + 1) * GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }

        tmpRxC += (DWORD)255 * 255 * 255 / 2;
        tmpGxM += (DWORD)255 * 255 * 255 / 2;
        tmpBxY += (DWORD)255 * 255 * 255 / 2;
        tmpBla += (DWORD)255 * 255 * 255 / 2;

        tmpCmy.Cyn = (BYTE)(tmpRxC / ((DWORD)255 * 255 * 255));
        tmpCmy.Mgt = (BYTE)(tmpGxM / ((DWORD)255 * 255 * 255));
        tmpCmy.Yel = (BYTE)(tmpBxY / ((DWORD)255 * 255 * 255));
        tmpCmy.Bla = (BYTE)(tmpBla / ((DWORD)255 * 255 * 255));

        /*----- UCR proceure --------------------------------------------------------*/
//      if (ucr != UCRNOO) ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrTbl);
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-

        *cmyAdr++ = tmpCmy;

        /*----- Color matching cache ------------------------------------------------*/
        cchRgb[cch] = tmpRgb; cchCmy[cch] = tmpCmy;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(solid)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvSld(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
//  DWORD       blaCnv                                      // Black replacement 
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       blaCnv, ucr, ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPCMYK      ucrTbl;
    LPRGB       endAdr;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;

    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        if (blaCnv == KCGGRY) {
            if ((tmpRed == tmpGrn) && (tmpRed == tmpBlu)) {
                cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
//                cmyAdr->Bla = 255 - GinTblP10[tmpRed];
                cmyAdr->Bla = gryTbl[tmpRed];
                cmyAdr++;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpRed | tmpGrn | tmpBlu) == 0) {
                cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
                cmyAdr++;
                continue;
            }
        }
        cmyAdr->Cyn = (BYTE)(255 - tmpRed);
        cmyAdr->Mgt = (BYTE)(255 - tmpGrn);
        cmyAdr->Yel = (BYTE)(255 - tmpBlu);
        cmyAdr->Bla = 0;

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        /*----- UCR proceure --------------------------------------------------------*/
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-
#endif

        cmyAdr++;
    }

    return;
}


//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK(2Level) conversion (for 1dot line)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColCnvL02(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr                                      // CMYK (output)
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       tmpMid;
    LPRGB       endAdr;
    BYTE        tmpCyn, tmpMgt, tmpYel;

    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
        if (tmpMid > 240) {
            cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = cmyAdr->Bla = 0;
            cmyAdr++;
            continue;
        }
        tmpCyn = tmpMgt = tmpYel = 255;
        tmpMid += (255 - tmpMid) / 8;
        if (tmpRed > tmpMid) tmpCyn = 0;
        if (tmpGrn > tmpMid) tmpMgt = 0;
        if (tmpBlu > tmpMid) tmpYel = 0;
        if ((tmpCyn & tmpMgt & tmpYel) == 255) {
            cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = tmpCyn;
        cmyAdr->Mgt = tmpMgt;
        cmyAdr->Yel = tmpYel;
        cmyAdr->Bla = 0;
        cmyAdr++;
    }

    return;
}
#endif


//---------------------------------------------------------------------------------------------------
//      RGB -> K conversion (for monochrome)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvMon(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    CMYK        tmpCmy;
    LPRGB       endAdr;
    LPBYTE      gryTbl;

    gryTbl = (LPBYTE)(mchInf->LutAdr);

    tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
//        tmpCmy.Bla = (BYTE)255 - GinTblP10[(tmpRed * 3 + tmpGrn * 5 + tmpBlu * 2) / 10];
        tmpCmy.Bla = gryTbl[(tmpRed*3 + tmpGrn*5 + tmpBlu*2) / 10];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }

    return;
}

//---------------------------------------------------------------------------------------------------
//      Color matching(UCR)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMchUcr(                                   // Return value no
    LPCMYK      cmy,                                        // CMYK (input, output)
    LPRGB       rgb,                                        // RGB (input)
    DWORD       ucr,                                        // UCR type
    DWORD       ucrCmy,                                     // UCR (UCR quantity)
    DWORD       ucrBla,                                     // UCR (ink version generation quantity)
    DWORD       ucrTnr,                                     // UCR (Toner gross weight)
    LPCMYK      ucrTbl                                      // UCR table
)
{
    LPCMYK      gryCyn;                                     // Gray value (Cyan conversion value)
    LPCMYK      dnsCyn;                                     // Density value (Cyan conversion value)
    DWORD       blaGen, min, sub, rgbMin, rgbMax, tmp;
    DWORD       ttlTnr, adjVal;
    DWORD       ucrQty;
//  DWORD       gryRat, ucrRat, blaRat, gryDns;
    LONG        cyn, mgt, yel, bla;

    DWORD xx = 128;                                         /* @@@ */

    gryCyn = ucrTbl;
    dnsCyn = ucrTbl + 256;
    ucrTnr = (ucrTnr * (DWORD)255) / (DWORD)100;           //+CASIO 2001/02/15

    cyn = cmy->Cyn;
    mgt = cmy->Mgt;
    yel = cmy->Yel;
    bla = cmy->Bla;

    /*----- Minimum density calculation of CMY  --------------------------------------*/
    min = cyn;
    if (min > dnsCyn[mgt].Mgt) min = dnsCyn[mgt].Mgt;
    if (min > dnsCyn[yel].Yel) min = dnsCyn[yel].Yel;

    if (ucr == UCR001) {                /* TypeT(for char, graphic)    */

        /*----- Gray degree calculation ----------------------------------------------*/
        rgbMin = rgbMax = rgb->Red;
        if (rgbMin > rgb->Grn) rgbMin = rgb->Grn;
        if (rgbMin > rgb->Blu) rgbMin = rgb->Blu;
        if (rgbMax < rgb->Grn) rgbMax = rgb->Grn;
        if (rgbMax < rgb->Blu) rgbMax = rgb->Blu;

// CASIO 2001/02/15 ->
//      sub = (DWORD)255 - (rgbMax - rgbMin);
//      blaGen = min * sub / (DWORD)255;
//
//      gryRat = ((rgbMax - rgbMin) * 100) / 255;
//      gryRat = (gryRat < (DWORD)20)? (DWORD)20 - gryRat: (DWORD)0;
//                                      /* Gray rate [100%] = 20, [80% or less] = 0 */
//
//      /* UCR rate    case of gray-rate(gryRat) 100 to 80%, +20 to +0      */
//      ucrRat = ucrCmy + gryRat;
//      /* Black rate  case of gray-rate(gryRat) 100 to 80%, +10 to +0      */
//      blaRat = ucrBla + (gryRat / 2);
//
//      /* Black rate, case of gray-density(gryDns) 100 to 80%, +10 to +0   */
//      gryDns = rgbMin * 100 / 255;
//      gryDns = (gryDns < (DWORD)20)? (DWORD)20 - gryDns: (DWORD)0;
//      blaRat += (gryDns / 2);
//
//      if (ucrRat > (DWORD)100) ucrRat = (DWORD)100;
//      if (blaRat > (DWORD)100) blaRat = (DWORD)100;
//
//      ucrQty = (blaGen * ucrRat) / 100;
//      blaGen = (blaGen * blaRat) / 100;

        sub = rgbMax - rgbMin;
        if (sub > (DWORD)50) blaGen = (DWORD)0;
        else {
            if (sub <= (DWORD)10) {
                tmp = (DWORD)10 - sub;
                ucrCmy += tmp;
                ucrBla += tmp;
            }
            if (sub <= (DWORD)5) {
                tmp = ((DWORD)5 - sub) * (DWORD)2;
                ucrCmy += tmp;
            }
            if (ucrCmy > 100) ucrCmy = 100;
            if (ucrBla > 100) ucrBla = 100;

            tmp = (DWORD)50 - sub;
            blaGen = min * tmp / (DWORD)50;
        }
// CASIO 2001/02/15 <-

    } else {                            /* TypeU(for image)                */

// CASIO 2001/02/15 ->
//      /* UCR processing be NOP, */
//      /* in the case that minimum density is smaller than the prescription value (50%) */
//      if (min < 127) return;
//
//      /* Density revision (127-255 -> 0-255)                              */
////    min = ((min - 127) * 255 + 64) / 128;
//      min = ((min - 127) * 255 + 64) / xx;
//
//      /* Gamma 3.0 approximation (If the speed-up is necessary table transformation)   */
//      if      (min <=  63) blaGen = 0;
//      else if (min <= 127) blaGen = ((min -  63) * 15         + 32) / 64;
//      else if (min <= 191) blaGen = ((min - 127) * ( 79 - 15) + 32) / 64 + 15;
//      else                 blaGen = ((min - 191) * (255 - 79) + 32) / 64 + 79;
//
//      ucrQty = (blaGen * ucrCmy) / 100; /* UCR quantity                     */
//      blaGen = (blaGen * ucrBla) / 100; /* ink version generation quantity  */

        /* K generation no, */
        /* in the case that minimum density is smaller than the prescription value (50%) */
        if (min < 127) blaGen = 0;
        else {
            /* Density revision (127-255 -> 0-255)                              */
//          min = ((min - 127) * 255 + 64) / 128;
            min = ((min - 127) * 255 + 64) / xx;

            /* Gamma 3.0 approximation (If the speed-up is necessary table transformation)   */
            if      (min <=  63) blaGen = 0;
            else if (min <= 127) blaGen = ((min- 63) *      15  + 32) / 64;
            else if (min <= 191) blaGen = ((min-127) * ( 79-15) + 32) / 64 + 15;
            else                 blaGen = ((min-191) * (255-79) + 32) / 64 + 79;
        }
// CASIO 2001/02/15 <-
    }

    /*----- Toner gross weight calculation(input CMYK value) ------------------------*/
    ttlTnr = cyn + mgt + yel + bla;

    if ((blaGen == 0) && (ttlTnr <= ucrTnr)) return;

    /*----- Ink version generation (K replacement) ----------------------------------*/
// CASIO 2001/02/15 ->
//  if (blaGen == 0) return;
//
//  ucrQty = (blaGen * ucrCmy) / 100;   /* UCR quantity                     */
//  blaGen = (blaGen * ucrBla) / 100;   /* ink version generation quantity  */
//
////cyn -= blaGen;                      /* Adjustment with a gray value     */
//  cyn -= ucrQty;                      /* Adjustment with a gray value     */
////mgt -= gryCyn[blaGen].Mgt;
//  mgt -= gryCyn[ucrQty].Mgt;
////yel -= gryCyn[blaGen].Yel;
//  yel -= gryCyn[ucrQty].Yel;
//  bla += gryCyn[blaGen].Bla;
    if (blaGen) {
        ucrQty = (blaGen * ucrCmy) / 100; /* UCR quantity                   */
        blaGen = (blaGen * ucrBla) / 100; /* ink version generation quantity*/

        cyn -= ucrQty;                  /* Adjustment with a gray value     */
        mgt -= gryCyn[ucrQty].Mgt;
        yel -= gryCyn[ucrQty].Yel;
        bla += gryCyn[blaGen].Bla;

        ttlTnr = cyn + mgt + yel + bla; /* Toner gross weight calculation   */
    }

    /*----- Toner gross weight restriction ---------------------------------*/
    if (ttlTnr > ucrTnr) {
        adjVal = (ttlTnr - ucrTnr + 2) / 3;
        cyn -= adjVal;
        mgt -= adjVal;
        yel -= adjVal;
    }
// CASIO 2001/02/15 <-

    if (cyn <   0) cyn =   0;           /* BYTE value(0 - 255) adjustment   */
    if (mgt <   0) mgt =   0;
    if (yel <   0) yel =   0;
    if (bla <   0) bla =   0;
    if (cyn > 255) cyn = 255;
    if (mgt > 255) mgt = 255;
    if (yel > 255) yel = 255;
    if (bla > 255) bla = 255;

    cmy->Cyn = (BYTE)cyn;               /* UCR processing value setting     */
    cmy->Mgt = (BYTE)mgt;
    cmy->Yel = (BYTE)yel;
    cmy->Bla = (BYTE)bla;

    return;
}
#endif


// End of N5COLMH.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colsb.h ===
//***************************************************************************************************
//    N5COLSB.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N501ColCtrRgb(DWORD, LPRGB, LPRGBINF);
VOID WINAPI N501ColCtrCmy(DWORD, LPCMYK, LPCMYKINF);

//  End of N5COLSB.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n501diz.h ===
//***************************************************************************************************
//    N501DIZ.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID  WINAPI N501ColCchIni(LPCOLMCHINF);
DWORD WINAPI N501ColGryTblMak(DWORD, LPCMYK, LPBYTE, LPBYTE);
DWORD WINAPI N501ColUcrTblMak(DWORD, LPCMYK, LPCMYK, LPBYTE);
VOID  WINAPI N501ColMchPrc(DWORD, LPRGB, LPCMYK, LPCOLMCHINF);
VOID  WINAPI N501ColPtcPrc(DWORD, DWORD, LPBYTE, LPCMYK, LPCMYK);
VOID  WINAPI N501ColCnvC2r(DWORD, LPCMYK, LPRGB, DWORD, LPBYTE);
VOID  WINAPI N501ColCtrRgb(DWORD, LPRGB, LPRGBINF);
VOID  WINAPI N501ColCtrCmy(DWORD, LPCMYK, LPCMYKINF);
DWORD WINAPI N501ColLutDatRdd(LPBYTE, DWORD);
DWORD WINAPI N501ColLutMakGlb(LPRGB, LPCMYK, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
DWORD WINAPI N501ColLutMakGlbMon(LPRGB, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
VOID  WINAPI N501ColLutMak032(LPCMYK, LPCMYK, LPBYTE);
DWORD WINAPI N501ColColDatRdd(LPBYTE, LPDWORD);
DWORD WINAPI N501ColDizInfSet(LPBYTE, LPDIZINF, LPBYTE);
DWORD WINAPI N501ColDrwInfSet(LPDIZINF, LPDRWINF, DWORD);
VOID  WINAPI N501ColDizPrc(LPDIZINF, LPDRWINF);

//  End of N501DIZ.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizmk.c ===
//***************************************************************************************************
//    N5DIZMK.C
//
//    Functions dithering (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLMH.H"
#include    "N5COLSB.H"
#include    "N5DIZMK.H"
#include    "strsafe.h"    // Security-Code 2002.3.6


//===================================================================================================
//      Definition of the random number dithering pattern distinction bit
//===================================================================================================
#define NEWSTO          0x80000000      /* MSB ON                           */

//===================================================================================================
//      LUT data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColLutIdtTbl[4] =
//    /*  Brightness(Direct)  tincture(Direct)    Brightness(linear)  tincture(linear)        */
//    {   0x20000000,         0x20000002,         0x20000001,         0x20000003 };
static DWORD ColLutIdtTbl[2] =
    /*  Brightness(Direct)  tincture(Direct)    */
    {   0x20000000,         0x20000002 };
#endif

//===================================================================================================
//      Dithering pattern data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColDizDizIdtTbl[2][5][4][5] = {
static DWORD ColDizDizIdtTbl621[2][5][4][5] = {
/*        C           M           Y           K        Monochrome                   */
  /****** For Char, Graphic (8x8 size) **********************************************/
  {
    /*===== 300dpi 2value ==========================================================*/
  { { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* fime       */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* middle     */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* rough      */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* fime       */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* middle     */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* rough      */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* fime       */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* middle     */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* rough      */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A } }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* fime       */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* middle     */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* rough      */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* fime       */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* middle     */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* rough      */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C } }  /* random     */
  }, 
  /****** For Image (Optional size) *************************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* fime       */
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* middle     */
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* rough      */
    { (NEWSTO+0), (NEWSTO+1), (NEWSTO+2), (NEWSTO+3), (NEWSTO+3) } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* fime       */
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* middle     */
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* rough      */
    { (NEWSTO+4), (NEWSTO+5), (NEWSTO+6), (NEWSTO+7), (NEWSTO+7) } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000003F },   /* fime       */
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000001F },   /* middle     */
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x20000040 },   /* rough      */
    { (NEWSTO+8), (NEWSTO+9), (NEWSTO+10),(NEWSTO+11),(NEWSTO+11)} }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x20000020, 0x20000021, 0x20000022, 0x20000023, 0x20000023 },   /* fime       */
    { 0x20000024, 0x20000025, 0x20000026, 0x20000052, 0x20000027 },   /* middle     */
    { 0x20000047, 0x20000048, 0x2000002A, 0x2000002B, 0x2000002A },   /* rough      */
    { (NEWSTO+12),(NEWSTO+13),(NEWSTO+14),(NEWSTO+15),(NEWSTO+15)} }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x2000002C, 0x2000002D, 0x2000002E, 0x2000002F, 0x2000002F },   /* fime       */
    { 0x20000030, 0x20000031, 0x20000032, 0x20000053, 0x20000033 },   /* middle     */
    { 0x20000049, 0x2000004A, 0x20000036, 0x20000037, 0x20000036 },   /* rough      */
    { (NEWSTO+16),(NEWSTO+17),(NEWSTO+18),(NEWSTO+19),(NEWSTO+19)} }  /* random     */
  }
};
#endif

static DWORD ColDizDizIdtTbl516[2][3][4] = {
/*    fime        middle      rough       random                                    */
  /****** Characte or Graphic (8 x 8 size) ******************************************/
  { { 0x20000038, 0x20000038, 0x20000038, 0x20000038 },     /*  300dpi 2value       */
    { 0x2000003A, 0x2000003A, 0x2000003A, 0x2000003A },     /*  600dpi 2value       */
    { 0x30000000, 0x30000000, 0x30000000, 0x30000000 } },   /* 1200dpi 2value       */
  /****** Image (optional size) *****************************************************/
  { { 0x2000003D, 0x2000003D, 0x20000040, (NEWSTO+3) },     /*  300dpi 2value       */
    { 0x2000003F, 0x2000001F, 0x20000040, (NEWSTO+11) },    /*  600dpi 2value       */
    { 0x30000001, 0x30000002, 0x30000003, (NEWSTO+11) } }   /* 1200dpi 2value       */
};

//===================================================================================================
//      Revision value table data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColDizAdjIdtTbl[2][5][4][5] = {
static DWORD ColDizAdjIdtTbl621[2][5][4][5] = {
/*        C           M           Y           K        Monochrome                   */
  /****** For Char, Graphic (8x8 size) **********************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* fime       */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* middle     */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* rough      */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* fime       */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* middle     */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* rough      */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 } }, /* random     */
    /*===== 600dpi 2value =========================================================*/
  { { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* fime       */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* middle     */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* rough      */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 } }, /* random     */
    /*===== 600dpi 4value =========================================================*/
  { { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* fime       */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* middle     */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* rough      */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* fime       */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* middle     */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* rough      */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A } }  /* random     */
  }, 
  /****** For Image (Optional size) *************************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* fime       */
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* middle     */
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* rough      */
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* fime       */
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* middle     */
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* rough      */
    { 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001 } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000001F },   /* fime       */
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000000E },   /* middle     */
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x20000020 },   /* rough      */
    { 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002 } }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x2000000F, 0x2000000F, 0x20000010, 0x20000011, 0x20000011 },   /* fime       */
    { 0x20000012, 0x20000012, 0x20000008, 0x20000024, 0x20000013 },   /* middle     */
    { 0x20000021, 0x20000021, 0x20000015, 0x20000016, 0x20000015 },   /* rough      */
    { 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003 } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000017, 0x20000017, 0x20000018, 0x20000019, 0x20000019 },   /* fime       */
    { 0x2000001A, 0x2000001A, 0x2000000A, 0x20000025, 0x2000001B },   /* middle     */
    { 0x20000022, 0x20000022, 0x2000001D, 0x2000001E, 0x2000001D },   /* rough      */
    { 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004 } }  /* random     */
  }
};
#endif

static DWORD ColDizAdjIdtTbl516[2][3][4] = {
/*    fime        middle      rough       random                                    */
  /****** Characte or Graphic (8 x 8 size) ******************************************/
  { { 0x30000000, 0x30000000, 0x30000000, 0x30000000 },     /*  300dpi 2value       */
    { 0x30000001, 0x30000001, 0x30000001, 0x30000001 },     /*  600dpi 2value       */
    { 0x30000002, 0x30000002, 0x30000002, 0x30000002 } },   /* 1200dpi 2value       */
  /****** Image (optional size) *****************************************************/
  { { 0x30000000, 0x30000000, 0x30000003, 0x30000004 },     /*  300dpi 2value       */
    { 0x30000005, 0x30000006, 0x30000007, 0x30000008 },     /*  600dpi 2value       */
    { 0x30000009, 0x3000000A, 0x3000000B, 0x3000000C } }    /* 1200dpi 2value       */
};

//===================================================================================================
//      Random number dithering pattern inside ID correspondence table
//===================================================================================================
static struct {
    DWORD   Idt;                        /* Dithering pattern ID             */
    DWORD   IdtTbl;                     /* Many value mask table ID         */
    DWORD   Sls;                        /* Threshold                        */
    DWORD   OfsXax;                     /* Offset X (base pattern shift)    */
    DWORD   OfsYax;                     /* Offset Y (base pattern shift)    */
} ColDizIdtTblSto[20] = {
    /*  inside ID         Idt         TblIdt   Sls  OfsX  OfsY              */
    /* (NEWSTO+0)  */ { 0x00000000, 0xFFFFFFFF,  1,  181,  33 }, /* 302 C   */
    /* (NEWSTO+1)  */ { 0x00000000, 0xFFFFFFFF,  1,   53, 118 }, /* 302 M   */
    /* (NEWSTO+2)  */ { 0x00000000, 0xFFFFFFFF,  1,  138, 161 }, /* 302 Y   */
    /* (NEWSTO+3)  */ { 0x00000000, 0xFFFFFFFF,  1,    0,   0 }, /* 302 K   */
    /* (NEWSTO+4)  */ { 0x00000001, 0x00000005, 15,  181,  33 }, /* 316 C   */
    /* (NEWSTO+5)  */ { 0x00000001, 0x00000005, 15,   53, 118 }, /* 316 M   */
    /* (NEWSTO+6)  */ { 0x00000001, 0x00000005, 15,  138, 161 }, /* 316 Y   */
    /* (NEWSTO+7)  */ { 0x00000001, 0x00000005, 15,    0,   0 }, /* 316 K   */
    /* (NEWSTO+8)  */ { 0x00000000, 0xFFFFFFFF,  1,  181,  33 }, /* 602 C   */
    /* (NEWSTO+9)  */ { 0x00000000, 0xFFFFFFFF,  1,   53, 118 }, /* 602 M   */
    /* (NEWSTO+10) */ { 0x00000000, 0xFFFFFFFF,  1,  138, 161 }, /* 602 Y   */
    /* (NEWSTO+11) */ { 0x00000000, 0xFFFFFFFF,  1,    0,   0 }, /* 602 K   */
    /* (NEWSTO+12) */ { 0x00000001, 0x00000006,  3,  181,  33 }, /* 604 C   */
    /* (NEWSTO+13) */ { 0x00000001, 0x00000006,  3,   53, 118 }, /* 604 M   */
    /* (NEWSTO+14) */ { 0x00000001, 0x00000006,  3,  138, 161 }, /* 604 Y   */
    /* (NEWSTO+15) */ { 0x00000001, 0x00000006,  3,    0,   0 }, /* 604 K   */
    /* (NEWSTO+16) */ { 0x00000001, 0x00000007, 15,  181,  33 }, /* 616 C   */
    /* (NEWSTO+17) */ { 0x00000001, 0x00000007, 15,   53, 118 }, /* 616 M   */
    /* (NEWSTO+18) */ { 0x00000001, 0x00000007, 15,  138, 161 }, /* 616 Y   */
    /* (NEWSTO+19) */ { 0x00000001, 0x00000007, 15,    0,   0 }  /* 616 K   */
};

//===================================================================================================
//      Dot gain revision table
//===================================================================================================
static BYTE GinTblP10[256] = {
    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
};

//===================================================================================================
//      Gamma revision table for sRGB (1.2)
//===================================================================================================
static BYTE GamTbl[256] = 
    /*---- 1.2 ----*/
    {   0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08,
        0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0e, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1a,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21,
        0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
        0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
        0x5e, 0x5f, 0x60, 0x61, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0, 0xa1, 0xa2,
        0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9,
        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
        0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xff  };

//===================================================================================================
//      Gamma revision table for sRGB MONO (1.4)
//===================================================================================================
static BYTE GamTblMon[256] = 
    /*---- 1.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
        0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
        0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
        0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
        0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
        0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
        0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
        0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
        0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
        0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
        0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
        0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff  };


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering pattern ID , Get adjustment value table ID
//---------------------------------------------------------------------------------------------------
static VOID ColDizIdtGet(                                   // Return value no
    LPDIZINF,                                               // Dithering information
    DWORD,                                                  // Color number 0:C M:1 2:Y 3:K 4:Mono
    LPDWORD,                                                // (output) Dithering pattern ID
    LPDWORD                                                 // (output) Adjustment value table ID
);

//---------------------------------------------------------------------------------------------------
//      Dithering pattern file data reading
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDatRdd(                                  // Error status
    LPBYTE,                                                 // Dithering file data
    DWORD,                                                  // Dithering pattern ID
    DWORD,                                                  // Adjustment value table ID
    DWORD,                                                  // Threshold(For confirmation)
    LPDWORD,                                                // Dithering pattern size housing address
    LPBYTE,                                                 // Dithering pattern data housing address
    LPBYTE                                                  // Work area
);

//---------------------------------------------------------------------------------------------------
//      Dithering pattern block head searching
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDizSch(                                  // The dithering pattern block head
    LPBYTE,                                                 // Dithering pattern file data
    DWORD                                                   // Dithering pattern ID
);

//---------------------------------------------------------------------------------------------------
//      Adjustment value table block head searching
//---------------------------------------------------------------------------------------------------
static DWORD ColDizAdjSch(                                  // The adjustment value table block head
    LPBYTE,                                                 // Dithering pattern file data
    DWORD                                                   // adjustment value table ID
);

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLng(                                     // Reading data(DWORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static WORD FleRddSht(                                      // Reading data(WORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLngLtl(                                  // Reading data(DWORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static WORD FleRddShtLtl(                                   // Reading data(WORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      LUT data read
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutDatRdd(                              // LUT pointer
    LPBYTE      lutDat,                                     // LUT file data
    DWORD       lutNum                                      // LUT number
)
{
    DWORD       n, num;
    DWORD       pnt, gldNum, qtyTbl, adrTbl;

    /*======================================================================*/
    /* LUT file format  Header information(128byte)                         */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  LUT file distinction "LUT_"                               */
    /*   4 -  63  Text information (nonused)                                */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reservation completion data                               */
    /*======================================================================*/
    /*----- LUT file distinction -------------------------------------------*/
    if ((lutDat[0] != 'L') || (lutDat[1] != 'U') || (lutDat[2] != 'T') || 
        (lutDat[3] != '_')) return 0L;

    /*----- LUT Procedure (each version) -----------------------------------*/
    switch (FleRddLngLtl(lutDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - 131  Housing LUT number(n)                                 */
        /* 132 - 135  LUT(0) Grid number                                    */
        /* 136 - 139  LUT(0) Data address                                   */
        /*     .                .                                           */
        /*     .                .                                           */
        /* xxx - xxx  LUT(n-1) Grid number                                  */
        /* xxx - xxx  LUT(n-1) Data address                                 */
        /*==================================================================*/
        if (lutNum == (DWORD)0xFFFFFFFF) lutNum = 0L;
                                    /* Custom LUT in the case of, head LUT  */
        if (lutNum >= FleRddLngLtl(lutDat, 128L)) /* Housing LUT number     */
            return 0L;
        pnt = 132L + lutNum * 8;                /* Reading pointer seek     */
        gldNum = FleRddLngLtl(lutDat, pnt);     /* Grid number              */
        return FleRddLngLtl(lutDat, pnt + 4L);  /* Table data address   */

      case 110:                         /* Ver1.10                          */
        /*==================================================================*/
        /* Ver1.10                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - xxx  Mask ROM format ("LT95")                              */
        /*==================================================================*/
        /*----- Custom LUT -------------------------------------------------*/
        if (lutNum == (DWORD)0xFFFFFFFF) {
            adrTbl = FleRddLng(lutDat, 44L + 128L); /* LUT information address  */
            return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                        /* LUT pointer                      */
        }
        /*----- Uncustom LUT -----------------------------------------------*/
        switch (lutNum) {
            case LUT_XD: num = 0; break;        /* Brightness               */
            case LUT_YD: num = 1; break;        /* Tincture                 */
//            case LUT_XL: num = 2; break;        /* Brightness(linear)       */
//            case LUT_YL: num = 3; break;        /* Tincture(linear)         */
            default: return 0L;
        }

        qtyTbl = FleRddLng(lutDat, 40L + 128L); /* LUT number               */
        adrTbl = FleRddLng(lutDat, 44L + 128L); /* LUT information address  */
        for (n = 0; n < qtyTbl; n++) {
            if (ColLutIdtTbl[num] == FleRddLng(lutDat, adrTbl + 128L))
                return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                        /* LUT pointer                      */
            adrTbl += 20L;
        }
        return 0L;

      default:                          /* Other versions                   */
        return 0L;
    }
}
#endif

//===================================================================================================
//      Global LUT make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutMakGlb(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    LPRGB       lutRgb,                                     // Transformation former LUT RGB->RGB
    LPCMYK      lutCmy,                                     // Transformation former LUT RGB->CMYK
    LPRGBINF    rgbInf,                                     // RGB information
    LPCMYKINF   cmyInf,                                     // cmyk information
    LPCMYK      lutGlb,                                     // Global LUT
    LPBYTE      wrk                                         // Work
)
{
    DWORD       n, red, grn, blu, pnt;
    LPRGB       tmpRgb;                                     // RGB->RGB
    COLMCHINF   mchInf;                                     // Color matching information
//  LPRGB       cchRgb;                                     // Color transformation cache table (RGB)
//  LPCMYK      cchCmy;                                     // Color transformation cache table (CMYK)

    tmpRgb = (LPRGB)wrk;                /* RGB temporary buffer     12288B  */

//  cchRgb = (LPRGB)wrk;                /* Cache buffer  RGB          768B  */
//  cchCmy = (LPCMYK)(wrk + (sizeof(RGBS) * CCHTBLSIZ));
//                                      /* Cache buffer CMYK         1024B  */
//  tmpRgb = (LPRGB)(wrk + (sizeof(RGBS) * CCHTBLSIZ + sizeof(CMYK) * CCHTBLSIZ));
//                                      /* RGB temporary buffer     12288B  */

    if ((lutCmy == NULL) || (rgbInf == NULL) || (cmyInf == NULL) || 
        (lutGlb == NULL)) return ERRILLPRM; /* Parameter error              */

    /*----- Transformation former LUT (RGB->RGB) ---------------------------*/
    if (lutRgb != NULL) {               /* RGB->RGB LUT use */
//      for (n = 0; n < (DWORD)LUTSIZ016; n++) tmpRgb[n] = lutRgb[n];
        for (n = 0; n < (DWORD)LUTSIZ016; n++) {
            tmpRgb[n].Red = lutRgb[n].Blu;
            tmpRgb[n].Grn = lutRgb[n].Grn;
            tmpRgb[n].Blu = lutRgb[n].Red;
        }
    } else {                            /* RGB->RGB LUT unused  */
        for (red = 0; red < 16; red++) {
            for (grn = 0; grn < 16; grn++) {
                for (blu = 0; blu < 16; blu++) {
                    pnt = red * 16 * 16 + grn * 16 + blu;
                    tmpRgb[pnt].Red = (BYTE)red * 17;
                    tmpRgb[pnt].Grn = (BYTE)grn * 17;
                    tmpRgb[pnt].Blu = (BYTE)blu * 17;
                }
            }
        }
    }

    /*----- RGB color control ----------------------------------------------*/
    if (    (rgbInf->Lgt) ||            /* Brightness       Except for 0    */
            (rgbInf->Con) ||            /* Contrast         Except for 0    */
            (rgbInf->Crm) ||            /* Chroma           Except for 0    */
            (rgbInf->Gmr != 10) ||      /* Gamma(R)         Except for 1.0  */
            (rgbInf->Gmg != 10) ||      /* Gamma(G)         Except for 1.0  */
            (rgbInf->Gmb != 10) ||      /* Gamma(B)         Except for 1.0  */
            (rgbInf->DnsRgb)        )   /*  RGB density     Except for 0    */
        N501ColCtrRgb((DWORD)LUTSIZ016, tmpRgb, rgbInf);

    /*----- Color matching information set ---------------------------------*/
    mchInf.Mch = MCHNML;                /* LUT: normal                      */
    mchInf.Bla = KCGNON;                /* Black replacement: NO            */
    mchInf.Ucr = UCRNOO;                /* UCR: NO                          */
    mchInf.UcrTbl = NULL;               /* UCR table: NO                    */
    mchInf.LutAdr = lutCmy;             /* LUT address (Transformation former LUT)  */
    mchInf.ColQty = 0;                  /* Color quality: 0                 */
    mchInf.ColAdr = NULL;               /* Color table: NO                  */
    mchInf.CchRgb = NULL;               /* RGB cache table: NO              */
    mchInf.CchCmy = NULL;               /* CMYK cache table: NO             */

    /*----- Color matching (RGB->CMYK) -------------------------------------*/
    N501ColCchIni(&mchInf);             /* Cache table initialize           */
    N501ColMchPrc((DWORD)LUTSIZ016, tmpRgb, lutGlb, &mchInf);

    /*----- CMYK color contorol --------------------------------------------*/
    if (    (cmyInf->Viv) ||            /* Vivid                Except for 0    */
            (cmyInf->DnsCyn) ||         /* Printing density(C)  Except for 0    */
            (cmyInf->DnsMgt) ||         /* Printing density(M)  Except for 0    */
            (cmyInf->DnsYel) ||         /* Printing density(Y)  Except for 0    */
            (cmyInf->DnsBla)        )   /* Printing density(K)  Except for 0    */
        N501ColCtrCmy((DWORD)LUTSIZ016, lutGlb, cmyInf);

    return ERRNON;
}
#endif

//===================================================================================================
//      Global LUT make (monochrome)
//===================================================================================================
DWORD WINAPI N501ColLutMakGlbMon(                           // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    LPRGB       lutRgb,                                     // Transformation former LUT RGB->RGB
    LPRGBINF    rgbInf,                                     // RGB information
    LPCMYKINF   cmyInf,                                     // cmyk informatio
    LPCMYK      lutGlb,                                     // Global LUT
    LPBYTE      wrk                                         // Work
)
{
    DWORD       n, red, grn, blu, tmp;
    LPRGB       tmpRgb;                                     // RGB  -> RBG
    LPCMYK      tmpCmy;                                     // CMYK -> CMYK
    LPBYTE      lut;

    tmpRgb = (LPRGB)wrk;                /* RGB temporary buffer        768B */
    tmpCmy = (LPCMYK)(wrk + (DWORD)768);/* CMYK temporary buffer      1024B */

    if ((rgbInf == NULL) || (cmyInf == NULL) || (lutGlb == NULL)) 
        return ERRILLPRM;               /* Parameter error                  */

    /*----- Transformation former LUT (RGB -> RGB) -------------------------*/
    if (lutRgb != NULL) {               /* RGB->RGB LUT use                 */
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = GamTbl[n];
        }
    } else {                            /* RGB->RGB LUT unused              */
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = (BYTE)n;
        }
    }

    /*----- RGB color control ----------------------------------------------*/
    if (    (rgbInf->Lgt) ||            /* Brightness      Except for 0     */
            (rgbInf->Con) ||            /* Contrast        Except for 0     */
            (rgbInf->Crm) ||            /* Chroma          Except for 0     */
            (rgbInf->Gmr != 10) ||      /* Gamma(R)        Except for 1.0   */
            (rgbInf->Gmg != 10) ||      /* Gamma(G)        Except for 1.0   */
            (rgbInf->Gmb != 10) ||      /* Gamma(B)        Except for 1.0   */
            (rgbInf->Dns)           )   /* RGB density     Except for 0     */
        N501ColCtrRgb((DWORD)256, tmpRgb, rgbInf);

    /*----- Color matching (RGB->CMYK) -------------------------------------*/
    for (n = 0; n < (DWORD)256; n++) {
        red = GamTblMon[tmpRgb[n].Red];
        grn = GamTblMon[tmpRgb[n].Grn];
        blu = GamTblMon[tmpRgb[n].Blu];
        tmp = (red * (DWORD)3 + grn * (DWORD)5 + blu * (DWORD)2) / (DWORD)10;
        tmpCmy[n].Cyn = tmpCmy[n].Mgt = tmpCmy[n].Yel = (BYTE)0;
        tmpCmy[n].Bla = (BYTE)255 - GinTblP10[tmp];
    }

    /*----- CMYK color contorol --------------------------------------------*/
    if (    (cmyInf->Viv) ||            /* Vivid                Except for 0    */
            (cmyInf->DnsCyn) ||         /* Printing density(C)  Except for 0    */
            (cmyInf->DnsMgt) ||         /* Printing density(M)  Except for 0    */
            (cmyInf->DnsYel) ||         /* Printing density(Y)  Except for 0    */
            (cmyInf->DnsBla)        )   /* Printing density(K)  Except for 0    */
        N501ColCtrCmy((DWORD)LUTSIZ016, tmpCmy, cmyInf);

    /*----- Global LUT set --------------------------------------------------*/
    lut = (BYTE *)lutGlb;
    for (n = 0; n < (DWORD)256; n++) {
        lut[n] = tmpCmy[n].Bla;
    }

    return ERRNON;
}

//===================================================================================================
//      High speed LUT(32grid) make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID WINAPI N501ColLutMak032(                               // Return value no
    LPCMYK      lutBse,                                     // Transformation former LUT (16grid)
    LPCMYK      lut032,                                     // High speed LUT(32grid)
    LPBYTE      wrk                                         // Work
)
{
    COLMCHINF   mchInf;                                     // Color matching information
//  LPRGB       cchRgb;                                     // Color transformation cash table (RBG)
//  LPCMYK      cchCmy;                                     // Color transformation cash table (CMYK)
    DWORD       red, grn, blu;
    RGBS        rgb;
    LPRGB       srcRgb;

    srcRgb = (LPRGB)wrk;                /* RGB temporary buffer        96B  */

//  cchRgb = (LPRGB)wrk;                /* Cache buffer RGB           768B  */
//  cchCmy = (LPCMYK)(wrk + (sizeof(RGBS) * CCHTBLSIZ));
//                                      /* Cache buffer CMYK         1024B  */
//  srcRgb = (LPRGB)(wrk + (sizeof(RGBS) * CCHTBLSIZ + sizeof(CMYK) * CCHTBLSIZ));
//                                      /* RGB temporary buffer        96B  */

    /*----- Color matching information set ---------------------------------*/
    mchInf.Mch = MCHNML;                /* LUT: normal                      */
    mchInf.Bla = KCGNON;                /* Black replacement: NO            */
    mchInf.Ucr = UCRNOO;                /* UCR: NO                          */
    mchInf.UcrTbl = NULL;               /* UCR table: NO                    */
    mchInf.LutAdr = lutBse;             /* LUT address (Transformation former LUT)      */
    mchInf.ColQty = 0;                  /* Color quality: 0                 */
    mchInf.ColAdr = NULL;               /* Color table: NO                  */
    mchInf.CchRgb = NULL;               /* RGB cache table: NO              */
    mchInf.CchCmy = NULL;               /* CMYK cache table: NO             */

    /*----- 32grid LUT make ------------------------------------------------*/
    for (red = 0; red < GLDNUM032; red++) {
        rgb.Red = (BYTE)(red * 255 / (GLDNUM032 - 1));
        for (grn = 0; grn < GLDNUM032; grn++) {
            rgb.Grn = (BYTE)(grn * 255 / (GLDNUM032 - 1));
            for (blu = 0; blu < GLDNUM032; blu++) {
                rgb.Blu = (BYTE)(blu * 255 / (GLDNUM032 - 1));
                srcRgb[blu] = rgb;
            }
            N501ColMchPrc((DWORD)GLDNUM032, srcRgb, lut032, &mchInf);
            lut032 += GLDNUM032;
        }
    }
}
#endif

//===================================================================================================
//      Color data read
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColColDatRdd(                              // Color data pointer
    LPBYTE      colDat,                                     // Color data file data
    LPDWORD     colQty                                      // Color data quality
)
{
    /*======================================================================*/
    /* Color data file format    Header information(128byte)                */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  Color data file distinction "CDF_"                        */
    /*   4 -  63  Text information  (nonused)                               */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reserved                                          */
    /*======================================================================*/
    /*----- Color data file distinction ------------------------------------*/
    if ((colDat[0] != 'C') || (colDat[1] != 'D') || (colDat[2] != 'F') || 
        (colDat[3] != '_')) return 0L;

    /*----- Color data procedure (each version) ----------------------------*/
    switch (FleRddLngLtl(colDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - 131  Color data quality (n)                                */
        /* 132 - 138  Color value(RGB-CMYK) #1                              */
        /* 139 - 145  Color value(RGB-CMYK) #2                              */
        /*     .                .                                           */
        /*     .                .                                           */
        /* xxx - xxx  Color value(RGB-CMYK) #n-1                            */
        /* xxx - xxx  Color value(RGB-CMYK) #n                              */
        /*==================================================================*/
        if ((*colQty = (DWORD)FleRddLng(colDat, 128L)) == 0) /* Color data quality  */
            return 0L;                  /* Color data quality: 0            */
        return 132L;                    /* Color data pointer               */

      default:                          /* Other versions                   */
        return 0L;
    }
}
#endif

//===================================================================================================
//      Dithering pattern information set
//===================================================================================================
DWORD WINAPI N501ColDizInfSet(                              // ERRNON    : OK
                                                            // ERRDIZHED : Header error
                                                            // ERRDIZNON : Dithering data no
                                                            // ERRDIZSLS : Threshold error
                                                            // ERRDIZSIZ : X/Y size error
                                                            // ERRDIZADJ : Adjustment value error
    LPBYTE      dizDat,                                     // Dithering file data
    LPDIZINF    dizInf,                                     // Dithering information
    LPBYTE      wrk                                         // Work
)
{
    DWORD       sts, sls;
    DWORD       idtDiz, idtAdj;

    /*======================================================================*/
    /* Dithering file format   Header information(128byte)                  */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  Dithering file distinction "DIZ_"                         */
    /*   4 -  63  Text information (nonused)                                */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reserved                                                  */
    /*======================================================================*/
    /*----- Dithering file distinction -------------------------------------*/
    if ((dizDat[0] != 'D') || (dizDat[1] != 'I') || (dizDat[2] != 'Z') || 
        (dizDat[3] != '_')) return ERRDIZHED;

    /*----- Dithering procedure (each version) -----------------------------*/
    switch (FleRddLngLtl(dizDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - xxx  Mask ROM format ("DP95")                              */
        /*==================================================================*/
        switch (dizInf->PrnMod) {
            case PRM316: case PRM616: sls = 15; break;
            case PRM604:              sls =  3; break;
            default:                  sls =  1; break;
        }
        dizInf->DizSls = sls;

        dizDat += 128L;

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        if (dizInf->ColMon == CMMCOL) {
            /*===== Color mode =============================================*/
            /*----- Cyn ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 0, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizCyn), dizInf->TblCyn, wrk)) != ERRNON)
                return sts;
            /*----- Mgt ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 1, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizMgt), dizInf->TblMgt, wrk)) != ERRNON)
                return sts;
            /*----- Yel ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 2, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizYel), dizInf->TblYel, wrk)) != ERRNON)
                return sts;
            /*----- Bla ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 3, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
        } else {
#endif
            /*===== Monochrome mode, Black =================================*/
            ColDizIdtGet(dizInf, 4, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        }
#endif
        return ERRNON;

      default:                          /* Other versions                   */
        return ERRDIZHED;
    }
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//      Dithering pattern ID , Get adjustment value table ID
//---------------------------------------------------------------------------------------------------
static VOID ColDizIdtGet(                                   // Return value no
    LPDIZINF    dizInf,                                     // Dithering information
    DWORD       col,                                        // Color number 0:C M:1 2:Y 3:K 4:Mono
    LPDWORD     idtDiz,                                     // (output) Dithering pattern ID
    LPDWORD     idtAdj                                      // (output) Adjustment value table ID
)
{
    DWORD       knd, mod, diz;

    knd = (dizInf->DizKnd == KNDCHR)? 0: 1;

//    switch (dizInf->PrnMod) {
//        case PRM316: mod = 1; break;
//        case PRM602: mod = 2; break;
//        case PRM604: mod = 3; break;
//        case PRM616: mod = 4; break;
//        case PRM122: mod = 2; break;  /* 1200dpi 2value   */
//        default:     mod = 0; break;
//    }

    switch (dizInf->DizPat) {
        case DIZSML: diz = 0; break;
        case DIZRUG: diz = 2; break;
        case DIZSTO: diz = 3; break;
        default:     diz = 1; break;
    }

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
    switch (dizInf->PrnEng) {
        case ENG516:                    /* IX-516 MONO 1200dpi/2value   */
#endif
            switch (dizInf->PrnMod) {
                case PRM602: mod = 1; break;
                case PRM122: mod = 2; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl516[knd][mod][diz];
            *idtAdj = ColDizAdjIdtTbl516[knd][mod][diz];
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
            break;

        default:                        /* IX-621 COLOR 600dpi/16value  */
            switch (dizInf->PrnMod) {
                case PRM316: mod = 1; break;
                case PRM602: mod = 2; break;
                case PRM604: mod = 3; break;
                case PRM616: mod = 4; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl621[knd][mod][diz][col];
            *idtAdj = ColDizAdjIdtTbl621[knd][mod][diz][col];
            break;
    }
#endif

//    *idtDiz = ColDizDizIdtTbl[knd][mod][diz][col];
//    *idtAdj = ColDizAdjIdtTbl[knd][mod][diz][col];
}

//---------------------------------------------------------------------------------------------------
//      Dithering pattern file data reading
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDatRdd(                                  // ERRNON    : OK
                                                            // ERRDIZNON : Dithering data no
                                                            // ERRDIZSLS : Threshold error
                                                            // ERRDIZSIZ : X/Y size error
                                                            // ERRDIZADJ : Adjustment value error
    LPBYTE      dizDat,                                     // Dithering file data
    DWORD       idtDiz,                                     // Dithering pattern ID
    DWORD       idtAdj,                                     // Adjustment value table ID
    DWORD       chkSls,                                     // Threshold(For confirmation)
    LPDWORD     siz,                                        // Dithering pattern size housing address
    LPBYTE      tbl,                                        // Dithering pattern data housing address
    LPBYTE      wrk                                         // Work area
)
{
    DWORD       n, dimNum, datSiz, sls, ofsXax, ofsYax, ofsPnt, dst, src;
    BYTE        dat;
    LPBYTE      adjTbl, slsTbl;
    DWORD       idtTbl;
    USHORT      sizXax, sizYax;
    DWORD       pnt;

    adjTbl = wrk;                       /* Adjustment value table buffer    256B    */
    slsTbl = wrk + 256;                 /* Threshold table buffer          3825B    */

    if (tbl != NULL) {
        if (idtAdj != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtAdj)) == 0L)
                                        /* adjustment value table block head        */
                return ERRDIZNON;
            pnt = FleRddLng(dizDat, pnt + 16L);
                                        /* Adjustment value table address           */
            for (n = 0; n < 256; n++) adjTbl[n] = dizDat[pnt + n];
                                        /* Data copy                                */
        } else {
            for (n = 0; n < 256; n++) adjTbl[n] = (BYTE)n;
        }
    }

    /*----- Normal dithering pattern(Unrandom number dithering pattern) ----*/
    if (!(idtDiz & NEWSTO)) {
        if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                        /* Dithering pattern block head     */
            return ERRDIZNON;           /* Dithering data no                */
        switch (FleRddSht(dizDat, pnt + 8L)) {  /* Data attribute           */
            case 0x1000: sls =  1; break;
            case 0x3000: sls =  3; break;
            case 0xF000: sls = 15; break;
            default: return ERRDIZSLS;          /* Threshold error          */
        }
        if (sls != chkSls) return ERRDIZSLS;    /* Threshold error          */
        sizXax = FleRddSht(dizDat, pnt + 12L);  /* X size                   */
        sizYax = FleRddSht(dizDat, pnt + 14L);  /* Y size                   */
        if (sizXax != sizYax) return ERRDIZSIZ; /* X/Y size error           */
        *siz = sizXax;                  /* Dithering pattern size set       */
        if (tbl == NULL) return ERRNON;

        pnt = FleRddLng(dizDat, pnt + 16L);
                                        /* Dithering pattern data address   */
        datSiz = sizXax * sizYax * sls;
        for (n = 0; n < datSiz; n++) tbl[n] = adjTbl[dizDat[pnt + n]];
                                        /* Dithering pattern data set       */
        return ERRNON;
    }

    /*----- Random number dithering pattern (NEW screen) -------------------*/
    dimNum = (DWORD)(idtDiz & ~(DWORD)NEWSTO);
    idtDiz = ColDizIdtTblSto[dimNum].Idt;
    idtTbl = ColDizIdtTblSto[dimNum].IdtTbl;
    sls    = ColDizIdtTblSto[dimNum].Sls;
    ofsXax = ColDizIdtTblSto[dimNum].OfsXax;
    ofsYax = ColDizIdtTblSto[dimNum].OfsYax;

    if (sls != chkSls) return ERRDIZSLS;        /* Threshold error          */

    if (tbl != NULL) {
        /* Many value mask table read                                       */
        datSiz = (DWORD)255 * sls;

        if (idtTbl != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtTbl)) == 0L)
                                        /* The many value mask table block head */
                return ERRDIZNON;       /* Dithering data no                */
            pnt = FleRddLng(dizDat, pnt + 16L);
            for (n = 0; n < datSiz; n++) slsTbl[n] = dizDat[pnt + n];
                                        /* Data copy                        */
        } else {
            for (n = 0; n < datSiz; n++) slsTbl[n] = (BYTE)n;
        }
    }

    if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                        /* The dithering pattern block head */
        return ERRDIZNON;               /* Dithering data no                */
    if (FleRddSht(dizDat, pnt + 8L) != (USHORT)0x1000) { /* Data attribute  */
                                        /* random number DIZ, Basis mask=1(0x1000)  */
        return ERRDIZADJ;               /* Other is error               */
    }
    sizXax = FleRddSht(dizDat, pnt + 12L);      /* X size                   */
    sizYax = FleRddSht(dizDat, pnt + 14L);      /* Y size                   */
// Check of zero divide 2002.3.20 >>>
    if ((sizXax == 0) || (sizYax == 0))
        return ERRDIZSIZ;                       /* X/Y size orror           */
// Check of zero divide 2002.3.20 <<<
    if (sizXax != sizYax) return ERRDIZSIZ;     /* X/Y size orror           */

    *siz = sizXax;                      /* Dithering pattern size set       */
    if (tbl == NULL) return ERRNON;

    pnt = FleRddLng(dizDat, pnt + 16L); /* Dithering pattern data address   */

    datSiz = (DWORD)sizXax * sizYax;
    ofsXax %= sizXax;
    ofsYax %= sizYax;
    ofsPnt = ofsYax * sizXax + ofsXax;

    /* Shift different color and I do the data copy with 2 stages, to express   */
    for (dst = (datSiz - ofsPnt), src = 0; src < ofsPnt; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    for (dst = 0; src < datSiz; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    return ERRNON;
}

//===================================================================================================
//      Dithering pattern block head searching
//===================================================================================================
static DWORD ColDizDizSch(                                  // The dithering pattern block head
    LPBYTE      dizDat,                                     // Dithering pattern file data
    DWORD       idtDiz                                      // Dithering pattern ID
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(dizDat, 40L);    /* Dithering pattern quality                    */
    adrTbl = FleRddLng(dizDat, 44L);    /* Dithering pattern information bureau address */

    for (n = 0; n < qtyTbl; n++) {
        if (idtDiz == FleRddLng(dizDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

//===================================================================================================
//      Adjustment value table block head searching
static DWORD ColDizAdjSch(                                  // The adjustment value table block head
    LPBYTE      adjDat,                                     // Dithering pattern file data
    DWORD       idtAdj                                      // adjustment value table ID
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(adjDat, 48L);    /* Adjustment table quality                 */
    adrTbl = FleRddLng(adjDat, 52L);    /* Adjustment table infomatiopn address     */

    for (n = 0; n < qtyTbl; n++) {
        if (idtAdj == FleRddLng(adjDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

//===================================================================================================
//      File data read
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLng(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt + 3] + (DWORD)fle[pnt + 2] * 0x100 + 
                (DWORD)fle[pnt + 1] * 0x10000 + (DWORD)fle[pnt] * 0x1000000;
}

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static USHORT FleRddSht(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt + 1] + (USHORT)fle[pnt] * 0x100;
}

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLngLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt] + (DWORD)fle[pnt + 1] * 0x100 + 
                (DWORD)fle[pnt + 2] * 0x10000 + (DWORD)fle[pnt + 3] * 0x1000000;
}

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static USHORT FleRddShtLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt] + (USHORT)fle[pnt + 1] * 0x100;
}


// End of N5DIZMK.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colsb.c ===
//***************************************************************************************************
//    N5COLSB.C
//
//    Functions of color matching (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLSB.H"
#include    "strsafe.h"    // Security-Code 2002.3.6


//===================================================================================================
//      Gamma revision table (0.1 - 0.9)
//===================================================================================================
static BYTE GamTbl001[9][256] = {
    /*---- 0.1 ----*/
    {   0x00, 0x91, 0x9c, 0xa2, 0xa7, 0xab, 0xae, 0xb1,
        0xb3, 0xb5, 0xb7, 0xb9, 0xbb, 0xbc, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcc, 0xcd, 0xce,
        0xce, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd8, 0xd9, 0xd9, 0xd9, 0xda,
        0xda, 0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdd, 0xdd,
        0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf, 0xe0,
        0xe0, 0xe0, 0xe1, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2,
        0xe2, 0xe3, 0xe3, 0xe3, 0xe3, 0xe4, 0xe4, 0xe4,
        0xe5, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe8,
        0xe8, 0xe9, 0xe9, 0xe9, 0xe9, 0xea, 0xea, 0xea,
        0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xec,
        0xec, 0xec, 0xec, 0xec, 0xed, 0xed, 0xed, 0xed,
        0xed, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xef,
        0xef, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf3,
        0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf4, 0xf4, 0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf5,
        0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf6, 0xf6,
        0xf6, 0xf6, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7,
        0xf7, 0xf7, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8,
        0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
        0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa,
        0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb,
        0xfb, 0xfb, 0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
        0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd, 0xfd,
        0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.2 ----*/
    {   0x00, 0x53, 0x60, 0x68, 0x6e, 0x73, 0x78, 0x7b,
        0x7f, 0x82, 0x84, 0x87, 0x89, 0x8c, 0x8e, 0x90,
        0x92, 0x93, 0x95, 0x97, 0x98, 0x9a, 0x9b, 0x9d,
        0x9e, 0x9f, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb7, 0xb8, 0xb9, 0xb9, 0xba, 0xbb,
        0xbc, 0xbc, 0xbd, 0xbe, 0xbe, 0xbf, 0xbf, 0xc0,
        0xc1, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4, 0xc4, 0xc5,
        0xc5, 0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc8, 0xc9,
        0xc9, 0xca, 0xcb, 0xcb, 0xcb, 0xcc, 0xcc, 0xcd,
        0xcd, 0xce, 0xce, 0xcf, 0xcf, 0xd0, 0xd0, 0xd1,
        0xd1, 0xd1, 0xd2, 0xd2, 0xd3, 0xd3, 0xd4, 0xd4,
        0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6, 0xd7, 0xd7,
        0xd8, 0xd8, 0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xda,
        0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdc, 0xdd, 0xdd,
        0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf, 0xe0, 0xe0,
        0xe0, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3,
        0xe3, 0xe3, 0xe3, 0xe4, 0xe4, 0xe4, 0xe5, 0xe5,
        0xe5, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7, 0xe7, 0xe7,
        0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9, 0xe9, 0xea,
        0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xeb, 0xec, 0xec,
        0xec, 0xec, 0xed, 0xed, 0xed, 0xee, 0xee, 0xee,
        0xee, 0xef, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf3, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf4, 0xf5, 0xf5, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6,
        0xf6, 0xf6, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf8,
        0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
        0xfa, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb,
        0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd,
        0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.3 ----*/
    {   0x00, 0x30, 0x3b, 0x42, 0x49, 0x4e, 0x52, 0x56,
        0x59, 0x5d, 0x60, 0x62, 0x65, 0x68, 0x6a, 0x6c,
        0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x79, 0x7b,
        0x7d, 0x7e, 0x80, 0x81, 0x83, 0x84, 0x85, 0x87,
        0x88, 0x89, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9e, 0x9f, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad,
        0xae, 0xae, 0xaf, 0xb0, 0xb1, 0xb1, 0xb2, 0xb3,
        0xb3, 0xb4, 0xb5, 0xb5, 0xb6, 0xb7, 0xb7, 0xb8,
        0xb9, 0xb9, 0xba, 0xbb, 0xbb, 0xbc, 0xbc, 0xbd,
        0xbe, 0xbe, 0xbf, 0xbf, 0xc0, 0xc0, 0xc1, 0xc2,
        0xc2, 0xc3, 0xc3, 0xc4, 0xc4, 0xc5, 0xc5, 0xc6,
        0xc7, 0xc7, 0xc8, 0xc8, 0xc9, 0xc9, 0xca, 0xca,
        0xcb, 0xcb, 0xcc, 0xcc, 0xcd, 0xcd, 0xce, 0xce,
        0xcf, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd3, 0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6,
        0xd6, 0xd7, 0xd7, 0xd8, 0xd8, 0xd8, 0xd9, 0xd9,
        0xda, 0xda, 0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdd,
        0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xe0, 0xe0,
        0xe0, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3, 0xe3,
        0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9,
        0xea, 0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xec, 0xec,
        0xed, 0xed, 0xed, 0xee, 0xee, 0xee, 0xef, 0xef,
        0xef, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf2,
        0xf2, 0xf2, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf7, 0xf7,
        0xf7, 0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xfa,
        0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb, 0xfc, 0xfc,
        0xfc, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.4 ----*/
    {   0x00, 0x1b, 0x24, 0x2a, 0x30, 0x34, 0x38, 0x3c,
        0x3f, 0x42, 0x45, 0x48, 0x4a, 0x4d, 0x4f, 0x51,
        0x54, 0x56, 0x58, 0x5a, 0x5b, 0x5d, 0x5f, 0x61,
        0x62, 0x64, 0x66, 0x67, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x78,
        0x79, 0x7a, 0x7b, 0x7c, 0x7e, 0x7f, 0x80, 0x81,
        0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x96, 0x97, 0x98,
        0x99, 0x9a, 0x9b, 0x9c, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa7, 0xa8, 0xa9, 0xaa, 0xaa, 0xab,
        0xac, 0xad, 0xad, 0xae, 0xaf, 0xaf, 0xb0, 0xb1,
        0xb1, 0xb2, 0xb3, 0xb4, 0xb4, 0xb5, 0xb6, 0xb6,
        0xb7, 0xb7, 0xb8, 0xb9, 0xb9, 0xba, 0xbb, 0xbb,
        0xbc, 0xbd, 0xbd, 0xbe, 0xbe, 0xbf, 0xc0, 0xc0,
        0xc1, 0xc2, 0xc2, 0xc3, 0xc3, 0xc4, 0xc5, 0xc5,
        0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc9, 0xc9, 0xca,
        0xca, 0xcb, 0xcb, 0xcc, 0xcd, 0xcd, 0xce, 0xce,
        0xcf, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd7,
        0xd7, 0xd8, 0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xdb,
        0xdb, 0xdc, 0xdc, 0xdd, 0xdd, 0xde, 0xde, 0xdf,
        0xdf, 0xe0, 0xe0, 0xe1, 0xe1, 0xe2, 0xe2, 0xe3,
        0xe3, 0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xea, 0xea,
        0xea, 0xeb, 0xeb, 0xec, 0xec, 0xed, 0xed, 0xee,
        0xee, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf1, 0xf1,
        0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf4, 0xf4, 0xf5,
        0xf5, 0xf5, 0xf6, 0xf6, 0xf7, 0xf7, 0xf8, 0xf8,
        0xf8, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb,
        0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfe, 0xfe, 0xff  },

    /*---- 0.5 ----*/
    {   0x00, 0x0f, 0x16, 0x1b, 0x1f, 0x23, 0x26, 0x2a,
        0x2d, 0x2f, 0x32, 0x34, 0x37, 0x39, 0x3b, 0x3d,
        0x3f, 0x41, 0x43, 0x45, 0x47, 0x48, 0x4a, 0x4c,
        0x4e, 0x4f, 0x51, 0x52, 0x54, 0x55, 0x57, 0x58,
        0x5a, 0x5b, 0x5c, 0x5e, 0x5f, 0x60, 0x62, 0x63,
        0x64, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
        0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,
        0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8b, 0x8c, 0x8d,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x93, 0x94,
        0x95, 0x96, 0x97, 0x98, 0x99, 0x99, 0x9a, 0x9b,
        0x9c, 0x9d, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa1,
        0xa2, 0xa3, 0xa4, 0xa5, 0xa5, 0xa6, 0xa7, 0xa8,
        0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xad, 0xae,
        0xae, 0xaf, 0xb0, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3,
        0xb4, 0xb5, 0xb5, 0xb6, 0xb7, 0xb8, 0xb8, 0xb9,
        0xba, 0xba, 0xbb, 0xbc, 0xbc, 0xbd, 0xbe, 0xbe,
        0xbf, 0xc0, 0xc0, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc9,
        0xc9, 0xca, 0xcb, 0xcb, 0xcc, 0xcd, 0xcd, 0xce,
        0xce, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd3,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd6, 0xd6, 0xd7, 0xd7,
        0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xdb, 0xdc, 0xdc,
        0xdd, 0xdd, 0xde, 0xde, 0xdf, 0xe0, 0xe0, 0xe1,
        0xe1, 0xe2, 0xe2, 0xe3, 0xe4, 0xe4, 0xe5, 0xe5,
        0xe6, 0xe6, 0xe7, 0xe7, 0xe8, 0xe9, 0xe9, 0xea,
        0xea, 0xeb, 0xeb, 0xec, 0xec, 0xed, 0xed, 0xee,
        0xee, 0xef, 0xf0, 0xf0, 0xf1, 0xf1, 0xf2, 0xf2,
        0xf3, 0xf3, 0xf4, 0xf4, 0xf5, 0xf5, 0xf6, 0xf6,
        0xf7, 0xf7, 0xf8, 0xf8, 0xf9, 0xf9, 0xfa, 0xfa,
        0xfb, 0xfb, 0xfc, 0xfc, 0xfd, 0xfd, 0xfe, 0xff  },

    /*---- 0.6 ----*/
    {   0x00, 0x09, 0x0d, 0x11, 0x14, 0x18, 0x1a, 0x1d,
        0x1f, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
        0x30, 0x32, 0x33, 0x35, 0x37, 0x38, 0x3a, 0x3c,
        0x3d, 0x3f, 0x40, 0x42, 0x43, 0x45, 0x46, 0x47,
        0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x51, 0x52,
        0x53, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
        0x5d, 0x5e, 0x5f, 0x60, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
        0x7f, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,
        0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8b, 0x8c,
        0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x93,
        0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x99, 0x9a,
        0x9b, 0x9c, 0x9d, 0x9e, 0x9e, 0x9f, 0xa0, 0xa1,
        0xa2, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xaa, 0xab, 0xac, 0xad, 0xad,
        0xae, 0xaf, 0xb0, 0xb1, 0xb1, 0xb2, 0xb3, 0xb4,
        0xb4, 0xb5, 0xb6, 0xb7, 0xb7, 0xb8, 0xb9, 0xba,
        0xba, 0xbb, 0xbc, 0xbd, 0xbd, 0xbe, 0xbf, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4, 0xc5, 0xc5,
        0xc6, 0xc7, 0xc7, 0xc8, 0xc9, 0xc9, 0xca, 0xcb,
        0xcc, 0xcc, 0xcd, 0xce, 0xce, 0xcf, 0xd0, 0xd0,
        0xd1, 0xd2, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd9, 0xd9, 0xda, 0xdb, 0xdb,
        0xdc, 0xdd, 0xdd, 0xde, 0xde, 0xdf, 0xe0, 0xe0,
        0xe1, 0xe2, 0xe2, 0xe3, 0xe4, 0xe4, 0xe5, 0xe6,
        0xe6, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xea, 0xeb,
        0xeb, 0xec, 0xed, 0xed, 0xee, 0xef, 0xef, 0xf0,
        0xf0, 0xf1, 0xf2, 0xf2, 0xf3, 0xf4, 0xf4, 0xf5,
        0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf8, 0xf9, 0xfa,
        0xfa, 0xfb, 0xfb, 0xfc, 0xfd, 0xfd, 0xfe, 0xff  },

    /*---- 0.7 ----*/
    {   0x00, 0x05, 0x08, 0x0b, 0x0d, 0x10, 0x12, 0x14,
        0x16, 0x18, 0x1a, 0x1c, 0x1d, 0x1f, 0x21, 0x22,
        0x24, 0x26, 0x27, 0x29, 0x2a, 0x2c, 0x2d, 0x2f,
        0x30, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38, 0x3a,
        0x3b, 0x3c, 0x3e, 0x3f, 0x40, 0x41, 0x43, 0x44,
        0x45, 0x46, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
        0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x77,
        0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
        0x8f, 0x90, 0x91, 0x91, 0x92, 0x93, 0x94, 0x95,
        0x96, 0x97, 0x98, 0x98, 0x99, 0x9a, 0x9b, 0x9c,
        0x9d, 0x9e, 0x9f, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
        0xa4, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xa9,
        0xaa, 0xab, 0xac, 0xad, 0xae, 0xae, 0xaf, 0xb0,
        0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
        0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
        0xca, 0xcb, 0xcc, 0xcd, 0xcd, 0xce, 0xcf, 0xd0,
        0xd1, 0xd1, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd9, 0xda, 0xda, 0xdb, 0xdc,
        0xdd, 0xdd, 0xde, 0xdf, 0xe0, 0xe0, 0xe1, 0xe2,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe5, 0xe6, 0xe7, 0xe8,
        0xe8, 0xe9, 0xea, 0xeb, 0xeb, 0xec, 0xed, 0xed,
        0xee, 0xef, 0xf0, 0xf0, 0xf1, 0xf2, 0xf2, 0xf3,
        0xf4, 0xf5, 0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf9,
        0xfa, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xff  },

    /*---- 0.8 ----*/
    {   0x00, 0x03, 0x05, 0x07, 0x09, 0x0a, 0x0c, 0x0e,
        0x0f, 0x11, 0x13, 0x14, 0x16, 0x17, 0x18, 0x1a,
        0x1b, 0x1d, 0x1e, 0x1f, 0x21, 0x22, 0x23, 0x25,
        0x26, 0x27, 0x28, 0x2a, 0x2b, 0x2c, 0x2d, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
        0x42, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
        0x4b, 0x4c, 0x4d, 0x4e, 0x50, 0x51, 0x52, 0x53,
        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,
        0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
        0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
        0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,
        0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x82,
        0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
        0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x90, 0x91,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xba, 0xbb, 0xbc,
        0xbd, 0xbe, 0xbf, 0xc0, 0xc0, 0xc1, 0xc2, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
        0xcb, 0xcc, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1,
        0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd6, 0xd7,
        0xd8, 0xd9, 0xda, 0xdb, 0xdb, 0xdc, 0xdd, 0xde,
        0xdf, 0xe0, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5,
        0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xe9, 0xea, 0xeb,
        0xec, 0xed, 0xee, 0xee, 0xef, 0xf0, 0xf1, 0xf2,
        0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff  },

    /*---- 0.9 ----*/
    {   0x00, 0x01, 0x03, 0x04, 0x06, 0x07, 0x08, 0x09,
        0x0b, 0x0c, 0x0d, 0x0f, 0x10, 0x11, 0x12, 0x13,
        0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x25, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x40,
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
        0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
        0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
        0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
        0x89, 0x8a, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
        0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4,
        0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcb,
        0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
        0xd4, 0xd5, 0xd6, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
        0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe1,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
        0xea, 0xeb, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff  }
};

//===================================================================================================
//      Gamma revision table (1.2 to 3.0)
//===================================================================================================
static BYTE GamTbl002[10][256] = {
    /*---- 1.2 ----*/
    {   0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08,
        0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0e, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1a,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21,
        0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
        0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
        0x5e, 0x5f, 0x60, 0x61, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0, 0xa1, 0xa2,
        0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9,
        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
        0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xff  },

    /*---- 1.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
        0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
        0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
        0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
        0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
        0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
        0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
        0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
        0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
        0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
        0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
        0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff  },

    /*---- 1.6 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
        0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05,
        0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
        0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 0x11,
        0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15,
        0x16, 0x17, 0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x20,
        0x21, 0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d,
        0x2e, 0x2f, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34,
        0x35, 0x36, 0x37, 0x38, 0x38, 0x39, 0x3a, 0x3b,
        0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
        0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
        0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
        0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x7a, 0x7b, 0x7c, 0x7d, 0x7f, 0x80, 0x81,
        0x82, 0x83, 0x85, 0x86, 0x87, 0x89, 0x8a, 0x8b,
        0x8c, 0x8e, 0x8f, 0x90, 0x92, 0x93, 0x94, 0x95,
        0x97, 0x98, 0x99, 0x9b, 0x9c, 0x9d, 0x9f, 0xa0,
        0xa1, 0xa3, 0xa4, 0xa5, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xae, 0xaf, 0xb0, 0xb2, 0xb3, 0xb5, 0xb6,
        0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbf, 0xc0, 0xc2,
        0xc3, 0xc4, 0xc6, 0xc7, 0xc9, 0xca, 0xcc, 0xcd,
        0xcf, 0xd0, 0xd2, 0xd3, 0xd5, 0xd6, 0xd8, 0xd9,
        0xdb, 0xdc, 0xde, 0xdf, 0xe1, 0xe2, 0xe4, 0xe5,
        0xe7, 0xe8, 0xea, 0xec, 0xed, 0xef, 0xf0, 0xf2,
        0xf3, 0xf5, 0xf7, 0xf8, 0xfa, 0xfb, 0xfd, 0xff  },

    /*---- 1.8 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03,
        0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05,
        0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10,
        0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 0x18, 0x19,
        0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e, 0x1e,
        0x1f, 0x20, 0x21, 0x21, 0x22, 0x23, 0x24, 0x24,
        0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x50, 0x51,
        0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6e, 0x6f, 0x70, 0x71, 0x73, 0x74, 0x75, 0x76,
        0x78, 0x79, 0x7a, 0x7c, 0x7d, 0x7e, 0x80, 0x81,
        0x82, 0x84, 0x85, 0x86, 0x88, 0x89, 0x8a, 0x8c,
        0x8d, 0x8f, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97,
        0x98, 0x9a, 0x9b, 0x9d, 0x9e, 0xa0, 0xa1, 0xa3,
        0xa4, 0xa6, 0xa7, 0xa9, 0xaa, 0xac, 0xad, 0xaf,
        0xb0, 0xb2, 0xb3, 0xb5, 0xb6, 0xb8, 0xb9, 0xbb,
        0xbd, 0xbe, 0xc0, 0xc1, 0xc3, 0xc5, 0xc6, 0xc8,
        0xc9, 0xcb, 0xcd, 0xce, 0xd0, 0xd2, 0xd3, 0xd5,
        0xd7, 0xd8, 0xda, 0xdc, 0xdd, 0xdf, 0xe1, 0xe2,
        0xe4, 0xe6, 0xe8, 0xe9, 0xeb, 0xed, 0xef, 0xf0,
        0xf2, 0xf4, 0xf6, 0xf7, 0xf9, 0xfb, 0xfd, 0xff  },

    /*---- 2.0 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
        0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
        0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13,
        0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18,
        0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d, 0x1d,
        0x1e, 0x1f, 0x1f, 0x20, 0x21, 0x21, 0x22, 0x23,
        0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29,
        0x2a, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
        0x31, 0x32, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4f, 0x50,
        0x51, 0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59,
        0x5a, 0x5b, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x63,
        0x64, 0x65, 0x66, 0x68, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x78,
        0x79, 0x7a, 0x7c, 0x7d, 0x7f, 0x80, 0x81, 0x83,
        0x84, 0x86, 0x87, 0x89, 0x8a, 0x8c, 0x8d, 0x8f,
        0x90, 0x92, 0x93, 0x95, 0x96, 0x98, 0x99, 0x9b,
        0x9c, 0x9e, 0xa0, 0xa1, 0xa3, 0xa4, 0xa6, 0xa8,
        0xa9, 0xab, 0xac, 0xae, 0xb0, 0xb1, 0xb3, 0xb5,
        0xb6, 0xb8, 0xba, 0xbc, 0xbd, 0xbf, 0xc1, 0xc3,
        0xc4, 0xc6, 0xc8, 0xca, 0xcb, 0xcd, 0xcf, 0xd1,
        0xd3, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0,
        0xe1, 0xe3, 0xe5, 0xe7, 0xe9, 0xeb, 0xed, 0xef,
        0xf1, 0xf3, 0xf5, 0xf7, 0xf9, 0xfb, 0xfd, 0xff  },

    /*---- 2.2 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04,
        0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06,
        0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,
        0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13,
        0x13, 0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d,
        0x1d, 0x1e, 0x1f, 0x1f, 0x20, 0x21, 0x21, 0x22,
        0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28,
        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50,
        0x51, 0x52, 0x54, 0x55, 0x56, 0x57, 0x58, 0x5a,
        0x5b, 0x5c, 0x5d, 0x5f, 0x60, 0x61, 0x63, 0x64,
        0x65, 0x67, 0x68, 0x69, 0x6b, 0x6c, 0x6d, 0x6f,
        0x70, 0x72, 0x73, 0x75, 0x76, 0x77, 0x79, 0x7a,
        0x7c, 0x7d, 0x7f, 0x80, 0x82, 0x83, 0x85, 0x86,
        0x88, 0x8a, 0x8b, 0x8d, 0x8e, 0x90, 0x92, 0x93,
        0x95, 0x97, 0x98, 0x9a, 0x9c, 0x9d, 0x9f, 0xa1,
        0xa2, 0xa4, 0xa6, 0xa8, 0xa9, 0xab, 0xad, 0xaf,
        0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbb, 0xbd,
        0xbf, 0xc1, 0xc3, 0xc5, 0xc7, 0xc9, 0xcb, 0xcd,
        0xcf, 0xd1, 0xd3, 0xd5, 0xd7, 0xd9, 0xdb, 0xdd,
        0xdf, 0xe1, 0xe3, 0xe5, 0xe7, 0xe9, 0xeb, 0xed,
        0xef, 0xf1, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xff  },

    /*---- 2.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06,
        0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,
        0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13,
        0x13, 0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c,
        0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21, 0x21, 0x22,
        0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28,
        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0x52,
        0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5a, 0x5c,
        0x5d, 0x5e, 0x60, 0x61, 0x63, 0x64, 0x65, 0x67,
        0x68, 0x6a, 0x6b, 0x6d, 0x6e, 0x6f, 0x71, 0x72,
        0x74, 0x76, 0x77, 0x79, 0x7a, 0x7c, 0x7d, 0x7f,
        0x81, 0x82, 0x84, 0x85, 0x87, 0x89, 0x8a, 0x8c,
        0x8e, 0x90, 0x91, 0x93, 0x95, 0x96, 0x98, 0x9a,
        0x9c, 0x9e, 0x9f, 0xa1, 0xa3, 0xa5, 0xa7, 0xa9,
        0xab, 0xad, 0xaf, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8,
        0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc7, 0xc9,
        0xcb, 0xcd, 0xcf, 0xd1, 0xd3, 0xd5, 0xd8, 0xda,
        0xdc, 0xde, 0xe0, 0xe3, 0xe5, 0xe7, 0xe9, 0xec,
        0xee, 0xf0, 0xf3, 0xf5, 0xf7, 0xfa, 0xfc, 0xff  },

    /*---- 2.6 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
        0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06,
        0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09,
        0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x10, 0x11, 0x11, 0x12, 0x13, 0x13,
        0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18,
        0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d,
        0x1e, 0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23,
        0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29,
        0x2a, 0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30,
        0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3f, 0x40, 0x41,
        0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 0x49, 0x4a,
        0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0x52, 0x53, 0x54,
        0x56, 0x57, 0x58, 0x5a, 0x5b, 0x5c, 0x5e, 0x5f,
        0x61, 0x62, 0x64, 0x65, 0x67, 0x68, 0x6a, 0x6b,
        0x6d, 0x6e, 0x70, 0x71, 0x73, 0x75, 0x76, 0x78,
        0x79, 0x7b, 0x7d, 0x7e, 0x80, 0x82, 0x84, 0x85,
        0x87, 0x89, 0x8b, 0x8c, 0x8e, 0x90, 0x92, 0x94,
        0x96, 0x97, 0x99, 0x9b, 0x9d, 0x9f, 0xa1, 0xa3,
        0xa5, 0xa7, 0xa9, 0xab, 0xad, 0xaf, 0xb1, 0xb3,
        0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc5,
        0xc7, 0xc9, 0xcb, 0xce, 0xd0, 0xd2, 0xd5, 0xd7,
        0xd9, 0xdc, 0xde, 0xe0, 0xe3, 0xe5, 0xe8, 0xea,
        0xed, 0xef, 0xf2, 0xf4, 0xf7, 0xf9, 0xfc, 0xff  },

    /*---- 2.8 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
        0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x07,
        0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09,
        0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
        0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10,
        0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,
        0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 0x18,
        0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e,
        0x1e, 0x1f, 0x20, 0x21, 0x21, 0x22, 0x23, 0x24,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32,
        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
        0x3b, 0x3c, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
        0x45, 0x46, 0x47, 0x48, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4f, 0x50, 0x51, 0x53, 0x54, 0x56, 0x57, 0x58,
        0x5a, 0x5b, 0x5d, 0x5e, 0x60, 0x61, 0x63, 0x64,
        0x66, 0x67, 0x69, 0x6a, 0x6c, 0x6e, 0x6f, 0x71,
        0x73, 0x74, 0x76, 0x78, 0x7a, 0x7b, 0x7d, 0x7f,
        0x81, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,
        0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xaf,
        0xb1, 0xb3, 0xb5, 0xb8, 0xba, 0xbc, 0xbe, 0xc1,
        0xc3, 0xc6, 0xc8, 0xca, 0xcd, 0xcf, 0xd2, 0xd4,
        0xd7, 0xd9, 0xdc, 0xde, 0xe1, 0xe3, 0xe6, 0xe9,
        0xeb, 0xee, 0xf1, 0xf3, 0xf6, 0xf9, 0xfc, 0xff  },

    /*---- 3.0 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
        0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09,
        0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x14,
        0x14, 0x15, 0x15, 0x16, 0x17, 0x17, 0x18, 0x19,
        0x19, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e, 0x1f,
        0x20, 0x21, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38,
        0x39, 0x3b, 0x3c, 0x3d, 0x3f, 0x40, 0x42, 0x43,
        0x45, 0x46, 0x48, 0x49, 0x4b, 0x4c, 0x4e, 0x50,
        0x51, 0x53, 0x55, 0x57, 0x59, 0x5a, 0x5c, 0x5e,
        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e,
        0x70, 0x73, 0x75, 0x77, 0x79, 0x7c, 0x7e, 0x80,
        0x83, 0x85, 0x88, 0x8a, 0x8d, 0x8f, 0x92, 0x95,
        0x97, 0x9a, 0x9d, 0xa0, 0xa2, 0xa5, 0xa8, 0xab,
        0xae, 0xb1, 0xb4, 0xb7, 0xbb, 0xbe, 0xc1, 0xc4,
        0xc8, 0xcb, 0xce, 0xd2, 0xd5, 0xd9, 0xdc, 0xe0,
        0xe4, 0xe7, 0xeb, 0xef, 0xf3, 0xf7, 0xfb, 0xff  }
};


//===================================================================================================
//      Toner density table make
//===================================================================================================
static VOID ColDnsMak(                                      // Return value no
    LONG,                                                   // Density(-30 to 30)
    LPBYTE                                                  // Density table address
);

//===================================================================================================
//      Brightness table make
//===================================================================================================
static VOID ColLgtMak(                                      // Return value no
    LONG,                                                   // Brightness(-100 to 100)
    LPBYTE                                                  // Brightness table address
);

//===================================================================================================
//      Contrast table make
//===================================================================================================
static VOID ColConMak(                                      // Return value no
    LONG,                                                   // Contrast(-100 to 100)
    LPBYTE                                                  // Contrast table address
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      RBG color control
//===================================================================================================
VOID WINAPI N501ColCtrRgb(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (pioxel)
    LPRGB       rgbBuf,                                     // RGB buffer pointer
//  RGBINF      rgbInf                                      // RBG information
    LPRGBINF    rgbInf                                      // RBG information
)
{
    LONG        tmpRed, tmpGrn, tmpBlu;
    LONG        tmpMid;
    LPRGB       endAdr;
    LPBYTE      gamTblRed = 0;
    LPBYTE      gamTblGrn = 0;
    LPBYTE      gamTblBlu = 0;
    LPBYTE      dnsTbl = 0;
    LPBYTE      lgtTbl = 0, conTbl = 0;
    BYTE        tmpTbl[256], tmpTbl001[256], tmpTbl002[256];

    /*----- Gamma revision table address set ----------------------------------------*/
//  if ((rgbInf.Gmr > 0) && (rgbInf.Gmr < 10))
//      gamTblRed = GamTbl001[rgbInf.Gmr - 1];
//  else if ((rgbInf.Gmr > 10) && (rgbInf.Gmr < 31))
//      gamTblRed = GamTbl002[(rgbInf.Gmr - 11) / 2];
//
//  if ((rgbInf.Gmg > 0) && (rgbInf.Gmg < 10))
//      gamTblGrn = GamTbl001[rgbInf.Gmg - 1];
//  else if ((rgbInf.Gmg > 10) && (rgbInf.Gmg < 31))
//      gamTblGrn = GamTbl002[(rgbInf.Gmg - 11) / 2];
//
//  if ((rgbInf.Gmb > 0) && (rgbInf.Gmb < 10))
//      gamTblBlu = GamTbl001[rgbInf.Gmb - 1];
//  else if ((rgbInf.Gmb > 10) && (rgbInf.Gmb < 31))
//      gamTblBlu = GamTbl002[(rgbInf.Gmb - 11) / 2];
    if ((rgbInf->Gmr > 0) && (rgbInf->Gmr < 10))
        gamTblRed = GamTbl001[rgbInf->Gmr - 1];
    else if ((rgbInf->Gmr > 10) && (rgbInf->Gmr < 31))
        gamTblRed = GamTbl002[(rgbInf->Gmr - 11) / 2];

    if ((rgbInf->Gmg > 0) && (rgbInf->Gmg < 10))
        gamTblGrn = GamTbl001[rgbInf->Gmg - 1];
    else if ((rgbInf->Gmg > 10) && (rgbInf->Gmg < 31))
        gamTblGrn = GamTbl002[(rgbInf->Gmg - 11) / 2];

    if ((rgbInf->Gmb > 0) && (rgbInf->Gmb < 10))
        gamTblBlu = GamTbl001[rgbInf->Gmb - 1];
    else if ((rgbInf->Gmb > 10) && (rgbInf->Gmb < 31))
        gamTblBlu = GamTbl002[(rgbInf->Gmb - 11) / 2];

    /*----- Printing density table address set --------------------------------------*/
//  if (rgbInf.Dns) {
    if (rgbInf->DnsRgb) {
//      ColDnsMak(rgbInf.Dns * (-1), tmpTbl);
        ColDnsMak(rgbInf->DnsRgb * (-1), tmpTbl);
        dnsTbl = tmpTbl;
    }

    /*----- Brightness table address set --------------------------------------------*/
//  if (rgbInf.Lgt) {
    if (rgbInf->Lgt) {
//      ColLgtMak(rgbInf.Lgt, tmpTbl001);
        ColLgtMak(rgbInf->Lgt, tmpTbl001);
        lgtTbl = tmpTbl001;
    }

    /*----- Contrast table address set ----------------------------------------------*/
//  if (rgbInf.Con) {
    if (rgbInf->Con) {
//      ColConMak(rgbInf.Con, tmpTbl002);
        ColConMak(rgbInf->Con, tmpTbl002);
        conTbl = tmpTbl002;
    }

    /*===== RBG color control =================================================*/
    for (endAdr = rgbBuf + xaxSiz; rgbBuf < endAdr; rgbBuf++) {
        tmpRed = rgbBuf->Red;
        tmpGrn = rgbBuf->Grn;
        tmpBlu = rgbBuf->Blu;

        /*----- Printing density ----------------------------------------------------*/
        if (dnsTbl) {
            tmpRed = dnsTbl[tmpRed];
            tmpGrn = dnsTbl[tmpGrn];
            tmpBlu = dnsTbl[tmpBlu];
        }

        /*----- Brightness ----------------------------------------------------------*/
////    if (rgbInf.Lgt != 0) {
////        tmpRed += rgbInf.Lgt / 3;
////        tmpGrn += rgbInf.Lgt / 3;
////        tmpBlu += rgbInf.Lgt / 3;
        if (rgbInf->Lgt != 0) {
            tmpRed = lgtTbl[tmpRed];
            tmpGrn = lgtTbl[tmpGrn];
            tmpBlu = lgtTbl[tmpBlu];

            /****** Conventionally specification *************************************/
//          tmpRed += rgbInf->Lgt / 3;
//          tmpGrn += rgbInf->Lgt / 3;
//          tmpBlu += rgbInf->Lgt / 3;
//          if (tmpRed < 0) tmpRed = 0; else if (tmpRed > 255) tmpRed = 255;
//          if (tmpGrn < 0) tmpGrn = 0; else if (tmpGrn > 255) tmpGrn = 255;
//          if (tmpBlu < 0) tmpBlu = 0; else if (tmpBlu > 255) tmpBlu = 255;
        }

        /*----- Contrast ------------------------------------------------------------*/
//      if (rgbInf.Con != 0) {
        if (rgbInf->Con != 0) {
            tmpRed = conTbl[tmpRed];
            tmpGrn = conTbl[tmpGrn];
            tmpBlu = conTbl[tmpBlu];
        }

        /*----- Chroma (Old, contrast)-----------------------------------------------*/
//      if (rgbInf.Crm != 0) {
        if (rgbInf->Crm != 0) {
            tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
//          tmpRed += (tmpRed - tmpMid) * rgbInf.Crm / 200;
//          tmpGrn += (tmpGrn - tmpMid) * rgbInf.Crm / 200;
//          tmpBlu += (tmpBlu - tmpMid) * rgbInf.Crm / 200;
            tmpRed += (tmpRed - tmpMid) * rgbInf->Crm / 200;
            tmpGrn += (tmpGrn - tmpMid) * rgbInf->Crm / 200;
            tmpBlu += (tmpBlu - tmpMid) * rgbInf->Crm / 200;
            if (tmpRed < 0) tmpRed = 0; else if (tmpRed > 255) tmpRed = 255;
            if (tmpGrn < 0) tmpGrn = 0; else if (tmpGrn > 255) tmpGrn = 255;
            if (tmpBlu < 0) tmpBlu = 0; else if (tmpBlu > 255) tmpBlu = 255;
        }

        /*----- Gamma ---------------------------------------------------------------*/
        if (gamTblRed) tmpRed = gamTblRed[tmpRed];
        if (gamTblGrn) tmpGrn = gamTblGrn[tmpGrn];
        if (gamTblBlu) tmpBlu = gamTblBlu[tmpBlu];

        rgbBuf->Red = (BYTE)tmpRed;
        rgbBuf->Grn = (BYTE)tmpGrn;
        rgbBuf->Blu = (BYTE)tmpBlu;
    }

    return;
}


//===================================================================================================
//      CMYK color control
//===================================================================================================
VOID WINAPI N501ColCtrCmy(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (pioxel)
    LPCMYK      cmyBuf,                                     // RGB buffer pointer
//  CMYKINF     cmyInf                                      // CMYK information
    LPCMYKINF   cmyInf                                      // CMYK information
)
{
    LONG        tmpCyn, tmpMgt, tmpYel, tmpBla;
    LONG        tmpMid;
    LPCMYK      endAdr;
    LPBYTE      dnsTblCyn = 0;
    LPBYTE      dnsTblMgt = 0;
    LPBYTE      dnsTblYel = 0;
    LPBYTE      dnsTblBla = 0;
    BYTE        tmpTblCyn[256], tmpTblMgt[256], tmpTblYel[256], tmpTblBla[256];

    /*----- Printing density table address set --------------------------------------*/
//  if (cmyInf.DnsCyn) {
//      ColDnsMak(cmyInf.DnsCyn, tmpTblCyn);
    if (cmyInf->DnsCyn) {
        ColDnsMak(cmyInf->DnsCyn, tmpTblCyn);
        dnsTblCyn = tmpTblCyn;
    }
//  if (cmyInf.DnsMgt) {
//      ColDnsMak(cmyInf.DnsMgt, tmpTblMgt);
    if (cmyInf->DnsMgt) {
        ColDnsMak(cmyInf->DnsMgt, tmpTblMgt);
        dnsTblMgt = tmpTblMgt;
    }
//  if (cmyInf.DnsYel) {
//      ColDnsMak(cmyInf.DnsYel, tmpTblYel);
    if (cmyInf->DnsYel) {
        ColDnsMak(cmyInf->DnsYel, tmpTblYel);
        dnsTblYel = tmpTblYel;
    }
//  if (cmyInf.DnsBla) {
//      ColDnsMak(cmyInf.DnsBla, tmpTblBla);
    if (cmyInf->DnsBla) {
        ColDnsMak(cmyInf->DnsBla, tmpTblBla);
        dnsTblBla = tmpTblBla;
    }

    /*===== CMYK color control ==============================================*/
    for (endAdr = cmyBuf + xaxSiz; cmyBuf < endAdr; cmyBuf++) {
        tmpCyn = cmyBuf->Cyn;
        tmpMgt = cmyBuf->Mgt;
        tmpYel = cmyBuf->Yel;
        tmpBla = cmyBuf->Bla;

        /*----- Vivid ---------------------------------------------------------------*/
//      if (cmyInf.Viv) {
        if (cmyInf->Viv) {
            tmpMid = (tmpCyn + tmpMgt + tmpYel) / 3;
//          tmpCyn += (tmpCyn - tmpMid) * cmyInf.Viv / 100;
//          tmpMgt += (tmpMgt - tmpMid) * cmyInf.Viv / 100;
//          tmpYel += (tmpYel - tmpMid) * cmyInf.Viv / 100;
            tmpCyn += (tmpCyn - tmpMid) * cmyInf->Viv / 100;
            tmpMgt += (tmpMgt - tmpMid) * cmyInf->Viv / 100;
            tmpYel += (tmpYel - tmpMid) * cmyInf->Viv / 100;
            if (tmpCyn < 0) tmpCyn = 0; else if (tmpCyn > 255) tmpCyn = 255;
            if (tmpMgt < 0) tmpMgt = 0; else if (tmpMgt > 255) tmpMgt = 255;
            if (tmpYel < 0) tmpYel = 0; else if (tmpYel > 255) tmpYel = 255;
        }

        /*----- Printing density adjustment -----------------------------------------*/
        if (dnsTblCyn) tmpCyn = dnsTblCyn[tmpCyn];
        if (dnsTblMgt) tmpMgt = dnsTblMgt[tmpMgt];
        if (dnsTblYel) tmpYel = dnsTblYel[tmpYel];
        if (dnsTblBla) tmpBla = dnsTblBla[tmpBla];

        cmyBuf->Cyn = (BYTE)tmpCyn;
        cmyBuf->Mgt = (BYTE)tmpMgt;
        cmyBuf->Yel = (BYTE)tmpYel;
        cmyBuf->Bla = (BYTE)tmpBla;
    }

    return;
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//===================================================================================================
//      Toner density table make
//===================================================================================================
static VOID ColDnsMak(                                      // Return value no
    LONG        prnDns,                                     // Density(-30 to 30)
    LPBYTE      dnsTbl                                      // Density table address
)
{
    LONG        innNum;
    LONG        outNum;

    prnDns *= 2;

//  dnsTbl[0] = (BYTE)0;
//  for (innNum = 1; innNum <= 254; innNum++) {
    for (innNum = 0; innNum <= 255; innNum++) {
        outNum = innNum + prnDns;
        if (outNum <   0) outNum =   0;
        if (outNum > 255) outNum = 255;
        dnsTbl[innNum] = (BYTE)outNum;
    }
//  dnsTbl[255] = (BYTE)255;

    return;
}


//===================================================================================================
//      Brightness table make
//===================================================================================================
static VOID ColLgtMak(                                      // Return value no
    LONG        lgt,                                        // Brightness(-100 to 100)
    LPBYTE      tbl                                         // Brightness table address
)
{
    LONG        prnDns;
    LPBYTE      dnsTbl;
    LONG        innNum, outNum;

    prnDns = lgt;
    dnsTbl = tbl;

    if (prnDns < 0) {
        for (innNum = 0; innNum < 256; innNum++) {
            if (innNum == 255) outNum = 255;
            else               outNum = innNum * (255 + prnDns) / 255;
            dnsTbl[innNum] = (BYTE)outNum;
        }
    } else {
        for (innNum = 0; innNum < 256; innNum++) {
            if (innNum == 0) outNum = 0;
            else             outNum = (innNum + prnDns) * 255 / (255 + prnDns);
            dnsTbl[innNum] = (BYTE)outNum;
        }
    }

    return;
}


//===================================================================================================
//      Contrast table make
//===================================================================================================
static VOID ColConMak(                                      // Return value no
    LONG        con,                                        // Contrast(-100 to 100)
    LPBYTE      tbl                                         // Contrast table address
)
{
    LONG        n, m, min, mid, max, rng;

    mid = (LONG)127;                                        /* The mean value be 127 fixation   */

    if (con > 0) {
        min = con * mid / (LONG)100;                        /* min (0 - 127)                    */
        max = (LONG)255 - min;                              /* max (128 to 255)                   */
        rng = max - min;                                    /* Inclination range                */

        /*----- Contrast up ---------------------------------------------------------*/
        for (n = 0; n <= min; n++) tbl[n] = (BYTE)0;
        for (m = 0; n <= max; n++, m++)
            tbl[n] = (BYTE)((m * (LONG)255) / rng);
        for (; n <= (LONG)255; n++) tbl[n] = (BYTE)255;

    } else {
        con *= (LONG)(-1);                                  /* Contrast value is integer                */
        min = con * mid / (LONG)100;                        /* min (0 to 127)                            */
        max = (LONG)255 - min;                              /* max (128 to 255)                          */
        rng = max - min;                                    /* Inclination range                        */

        /*----- Contrast down -------------------------------------------------------*/
        for (n = 0; n <= (LONG)255; n++) 
            tbl[n] = (BYTE)(((n * rng) / (LONG)255) + min);

    }

    return;
}


// End of N5COLSB.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizmk.h ===
//***************************************************************************************************
//    N5DIZMK.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutDatRdd(LPBYTE, DWORD);
DWORD WINAPI N501ColLutMakGlb(LPRGB, LPCMYK, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
#endif

DWORD WINAPI N501ColLutMakGlbMon(LPRGB, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID  WINAPI N501ColLutMak032(LPCMYK, LPCMYK, LPBYTE);
DWORD WINAPI N501ColColDatRdd(LPBYTE, LPDWORD);
#endif
DWORD WINAPI N501ColDizInfSet(LPBYTE, LPDIZINF, LPBYTE);

//  End of N5DIZMK.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizpc.c ===
//***************************************************************************************************
//    N5DIZPC.C
//
//    Functions of dithering (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "PDEV.H"       //+2002.2.23
//#include    "COLDEF.H"   //-2002.2.23
//#include    "COMDIZ.H"   //-2002.2.23
//#include    "N5DIZPC.H"  //-2002.2.23
#include    "strsafe.h"    // Security-Code 2002.3.6


//===================================================================================================
//      Structure for dithering information (each color)
//===================================================================================================
typedef struct {
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Cur;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Xsp;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Xep;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Ysp;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Yep;
    struct {
        DWORD       Cyn;
        DWORD       Mgt;
        DWORD       Yel;
        DWORD       Bla;
    } DYY;
} DIZCOLINF, FAR* LPDIZCOLINF;


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering (color 2value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC02(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC04(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC16(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 2value)
//---------------------------------------------------------------------------------------------------
static VOID DizPrcM02(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM04(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM16(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering procedure (For DRIVER)
//---------------------------------------------------------------------------------------------------
static VOID ColDizPrcNln(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);

//---------------------------------------------------------------------------------------------------
//      Dithering information set (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfSetCol(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF,                                            // Dithering information (each color)
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Threshold (per 1pixel)
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfSetMon(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF,                                            // Dithering information (each color)
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Threshold (per 1pixel)
);

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfChgCol(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF                                             // Dithering information (each color)
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfChgMon(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF                                             // Dithering information (each color)
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      Drawing information make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColDrwInfSet(                              // In a bundle development possibility line number
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Dithering information
    DWORD       linBufSiz                                   // Line buffer size (1color)
)
{
    DWORD       lvl;

// Check of zero divide 2002.3.23 >>>
    if ((drwInf->XaxNrt == 0) || (drwInf->XaxDnt == 0) ||
        (drwInf->YaxNrt == 0) || (drwInf->YaxDnt == 0)) {
        ERR(("N501ColDrwInfSet() 0Div-Check [drwInf->XaxNrt,XaxDnt,YaxNrt,YaxDnt=0] \n"));
        return 0;
    }
// Check of zero divide 2002.3.23 <<<

    /*----- variable power offset calculation ------------------------------*/
    drwInf->XaxOfs = (drwInf->StrXax * drwInf->XaxDnt + drwInf->XaxNrt / 2) / drwInf->XaxNrt;
    drwInf->YaxOfs = (drwInf->StrYax * drwInf->YaxDnt + drwInf->YaxNrt / 2) / drwInf->YaxNrt;
    /*----- One line dot number calculation --------------------------------*/
    drwInf->LinDot = 
        (drwInf->XaxOfs + drwInf->XaxSiz) * drwInf->XaxNrt / drwInf->XaxDnt - 
         drwInf->XaxOfs                   * drwInf->XaxNrt / drwInf->XaxDnt;
    /*----- One line byte calculation --------------------------------------*/
    switch (dizInf->PrnMod) {
        case PRM316: case PRM616: lvl = 4; break;
        case PRM604:              lvl = 2; break;
        default:                  lvl = 1; break;
    }
    drwInf->LinByt = (drwInf->LinDot * lvl + 7) / 8;
    /*----- In a bundle development possibility line number ----------------*/
    return (linBufSiz / drwInf->LinByt) * drwInf->YaxDnt / drwInf->YaxNrt;
}
#endif

//===================================================================================================
//      Dithering procedure (For DRIVER)
//===================================================================================================
VOID WINAPI N501ColDizPrc(                                  // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf                                      // Drawing information
)
{
    ColDizPrcNln(dizInf, drwInf, 1);
    return;
}


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering procedure (For DRIVER)
//---------------------------------------------------------------------------------------------------
static VOID ColDizPrcNln(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    DWORD       lvl;

    switch (dizInf->PrnMod) {
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case PRM316: case PRM616: lvl = 4; break;
        case PRM604:              lvl = 2; break;
#endif
        default:                  lvl = 1; break;
    }

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
    if (dizInf->ColMon == CMMCOL) {
        /*===== Color ======================================================*/
        switch (lvl) {
            case 1: DizPrcC02(dizInf, drwInf, linNum); return;
            case 2: DizPrcC04(dizInf, drwInf, linNum); return;
            case 4: DizPrcC16(dizInf, drwInf, linNum); return;
        }
    }
#endif

    /*===== Monochrome =====================================================*/
    switch (lvl) {
        case 1: DizPrcM02(dizInf, drwInf, linNum); return;
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case 2: DizPrcM04(dizInf, drwInf, linNum); return;
        case 4: DizPrcM16(dizInf, drwInf, linNum); return;
#endif
    }
}


//---------------------------------------------------------------------------------------------------
//      Dithering (color 2value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC02(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 1;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix = (BYTE)0x80;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn++) bytCyn |= wrtPix;  // Cyan
                if (cmy.Mgt > *dizMgt++) bytMgt |= wrtPix;  // Magenta
                if (cmy.Yel > *dizYel++) bytYel |= wrtPix;  // Yellow
                if (cmy.Bla > *dizBla++) bytBla |= wrtPix;  // Black

                if (!(wrtPix >>= 1)) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix = (BYTE)0x80;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix = (BYTE)0x80;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn++) bytCyn |= wrtPix; // Cyan
                    if (cmy.Mgt > *dizMgt++) bytMgt |= wrtPix; // Magenta
                    if (cmy.Yel > *dizYel++) bytYel |= wrtPix; // Yellow
                    if (cmy.Bla > *dizBla++) bytBla |= wrtPix; // Black

                    if (!(wrtPix >>= 1)) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix = (BYTE)0x80;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC04(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix004, wrtPix008, wrtPix00c;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 3;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn) {                    // Cyan
                    if      (cmy.Cyn > *(dizCyn + 2)) bytCyn |= wrtPix00c;
                    else if (cmy.Cyn > *(dizCyn + 1)) bytCyn |= wrtPix008;
                    else                              bytCyn |= wrtPix004;
                }
                if (cmy.Mgt > *dizMgt) {                    // Magenta
                    if      (cmy.Mgt > *(dizMgt + 2)) bytMgt |= wrtPix00c;
                    else if (cmy.Mgt > *(dizMgt + 1)) bytMgt |= wrtPix008;
                    else                              bytMgt |= wrtPix004;
                }
                if (cmy.Yel > *dizYel) {                    // Yellow
                    if      (cmy.Yel > *(dizYel + 2)) bytYel |= wrtPix00c;
                    else if (cmy.Yel > *(dizYel + 1)) bytYel |= wrtPix008;
                    else                              bytYel |= wrtPix004;
                }
                if (cmy.Bla > *dizBla) {                    // Black
                    if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                    else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                    else                              bytBla |= wrtPix004;
                }

                wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                if (!wrtPix004) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix004 = (BYTE)0x40;
                    wrtPix008 = (BYTE)0x80;
                    wrtPix00c = (BYTE)0xc0;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
                dizCyn += elmSiz;
                dizMgt += elmSiz;
                dizYel += elmSiz;
                dizBla += elmSiz;
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {            /* Magnification set for vertical   */

            amrXax = amrXax000;
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn) {                // Cyan
                        if      (cmy.Cyn > *(dizCyn + 2)) bytCyn |= wrtPix00c;
                        else if (cmy.Cyn > *(dizCyn + 1)) bytCyn |= wrtPix008;
                        else                              bytCyn |= wrtPix004;
                    }
                    if (cmy.Mgt > *dizMgt) {                // Magenta
                        if      (cmy.Mgt > *(dizMgt + 2)) bytMgt |= wrtPix00c;
                        else if (cmy.Mgt > *(dizMgt + 1)) bytMgt |= wrtPix008;
                        else                              bytMgt |= wrtPix004;
                    }
                    if (cmy.Yel > *dizYel) {                // Yellow
                        if      (cmy.Yel > *(dizYel + 2)) bytYel |= wrtPix00c;
                        else if (cmy.Yel > *(dizYel + 1)) bytYel |= wrtPix008;
                        else                              bytYel |= wrtPix004;
                    }
                    if (cmy.Bla > *dizBla) {                // Black
                        if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                        else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                        else                              bytBla |= wrtPix004;
                    }

                    wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                    if (!wrtPix004) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix004 = (BYTE)0x40;
                        wrtPix008 = (BYTE)0x80;
                        wrtPix00c = (BYTE)0xc0;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
                    dizCyn += elmSiz;
                    dizMgt += elmSiz;
                    dizYel += elmSiz;
                    dizBla += elmSiz;
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC16(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    DWORD       sft;
    BYTE        min, max, mid;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 15;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("DizPrcC16() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            sft = 4;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn) {                    // Cyan
                    if (cmy.Cyn > *(dizCyn + 14)) bytCyn |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Cyn > *(dizCyn + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytCyn |= (mid + 1) << sft;
                    }
                }
                if (cmy.Mgt > *dizMgt) {                    // Magenta
                    if (cmy.Mgt > *(dizMgt + 14)) bytMgt |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Mgt > *(dizMgt + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytMgt |= (mid + 1) << sft;
                    }
                }
                if (cmy.Yel > *dizYel) {                    // Yellow
                    if (cmy.Yel > *(dizYel + 14)) bytYel |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Yel > *(dizYel + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytYel |= (mid + 1) << sft;
                    }
                }
                if (cmy.Bla > *dizBla) {                    // Black
                    if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Bla > *(dizBla + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytBla |= (mid + 1) << sft;
                    }
                }

                if (sft == 0) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    sft = 8;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
                sft-=4;
                dizCyn += elmSiz;
                dizMgt += elmSiz;
                dizYel += elmSiz;
                dizBla += elmSiz;
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (sft != 4) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        //Magnification set for vertical

            amrXax = amrXax000;
            sft = 4;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn) {                // Cyan
                        if (cmy.Cyn > *(dizCyn + 14)) bytCyn |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Cyn > *(dizCyn + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytCyn |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Mgt > *dizMgt) {                // Magenta
                        if (cmy.Mgt > *(dizMgt + 14)) bytMgt |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Mgt > *(dizMgt + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytMgt |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Yel > *dizYel) {                // Yellow
                        if (cmy.Yel > *(dizYel + 14)) bytYel |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Yel > *(dizYel + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytYel |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Bla > *dizBla) {                // Black
                        if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Bla > *(dizBla + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytBla |= (mid + 1) << sft;
                        }
                    }

                    if (sft == 0) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        sft = 8;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
                    sft-=4;
                    dizCyn += elmSiz;
                    dizMgt += elmSiz;
                    dizYel += elmSiz;
                    dizBla += elmSiz;
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (sft != 4) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 2value)
//---------------------------------------------------------------------------------------------------
static VOID DizPrcM02(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 1;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("DizPrcM02() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix = (BYTE)0x80;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla++) bytBla |= wrtPix;  // Black

                if (!(wrtPix >>= 1)) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix = (BYTE)0x80;
                    bytBla = (BYTE)0x00;
                }
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix = (BYTE)0x80;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla++) bytBla |= wrtPix; // Black

                    if (!(wrtPix >>= 1)) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix = (BYTE)0x80;
                        bytBla = (BYTE)0x00;
                    }
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}


//---------------------------------------------------------------------------------------------------
//      Dithering (mono 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM04(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix004, wrtPix008, wrtPix00c;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 3;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("DizPrcM04() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla) {                    // Black
                    if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                    else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                    else                              bytBla |= wrtPix004;
                }

                wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                if (!wrtPix004) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix004 = (BYTE)0x40;
                    wrtPix008 = (BYTE)0x80;
                    wrtPix00c = (BYTE)0xc0;
                    bytBla = (BYTE)0x00;
                }
                dizBla += elmSiz;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {                            // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla) { /* Black                       */
                        if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                        else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                        else                              bytBla |= wrtPix004;
                    }

                    wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                    if (!wrtPix004) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix004 = (BYTE)0x40;
                        wrtPix008 = (BYTE)0x80;
                        wrtPix00c = (BYTE)0xc0;
                        bytBla = (BYTE)0x00;
                    }
                    dizBla += elmSiz;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM16(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    DWORD       sft;
    BYTE        min, max, mid;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 15;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

// Check of zero divide 2002.3.23 >>>
    if ((xaxDnt == 0) || (yaxDnt == 0)) {
        ERR(("DizPrcM04() 0Div-Check [xaxDnt,yaxDnt=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            sft = 4;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla) {                    // Black
                    if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Bla > *(dizBla + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytBla |= (mid + 1) << sft;
                    }
                }

                if (sft == 0) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    sft = 8;
                    bytBla = (BYTE)0x00;
                }
                sft-=4;
                dizBla += elmSiz;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (sft != 4) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {                            // Magnification set for vertical

            amrXax = amrXax000;
            sft = 4;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla) {                // Black
                        if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Bla > *(dizBla + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytBla |= (mid + 1) << sft;
                        }
                    }

                    if (sft == 0) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        sft = 8;
                        bytBla = (BYTE)0x00;
                    }
                    sft-=4;
                    dizBla += elmSiz;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (sft != 4) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfSetCol(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf,                                  // Dithering information (each color)
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       elmSiz                                      // Threshold (per 1pixel)
)
{
    DWORD       dizSiz, dzx, dzy;
    LPBYTE      diz;

// Check of zero divide 2002.3.23 >>>
    if ((dizInf->SizCyn == 0) || (dizInf->SizMgt == 0) ||
        (dizInf->SizYel == 0) || (dizInf->SizBla == 0)) {
        ERR(("DizInfSetCol() 0Div-Check [dizInf->SizCyn,SizMgt,SizYel,SizBla=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

//  dizSiz = dizInf->SizCyn; DizCynDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizCyn; dizColInf->DYY.Cyn = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizCynDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Cyn;
    diz = dizInf->TblCyn;
//  DizCynCur = diz + dzy + dzx;
//  DizCynXsp = diz + dzy; DizCynXep = DizCynXsp + DizCynDYY;
//  DizCynYsp = diz + dzx; DizCynYep = DizCynYsp + dizSiz * DizCynDYY;
    dizColInf->Cur.Cyn = diz + dzy + dzx;
    dizColInf->Xsp.Cyn = diz + dzy; dizColInf->Xep.Cyn = dizColInf->Xsp.Cyn + dizColInf->DYY.Cyn;
    dizColInf->Ysp.Cyn = diz + dzx; dizColInf->Yep.Cyn = dizColInf->Ysp.Cyn + dizSiz * dizColInf->DYY.Cyn;

//  dizSiz = dizInf->SizMgt; DizMgtDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizMgt; dizColInf->DYY.Mgt = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizMgtDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Mgt;
    diz = dizInf->TblMgt;
//  DizMgtCur = diz + dzy + dzx;
//  DizMgtXsp = diz + dzy; DizMgtXep = DizMgtXsp + DizMgtDYY;
//  DizMgtYsp = diz + dzx; DizMgtYep = DizMgtYsp + dizSiz * DizMgtDYY;
    dizColInf->Cur.Mgt = diz + dzy + dzx;
    dizColInf->Xsp.Mgt = diz + dzy; dizColInf->Xep.Mgt = dizColInf->Xsp.Mgt + dizColInf->DYY.Mgt;
    dizColInf->Ysp.Mgt = diz + dzx; dizColInf->Yep.Mgt = dizColInf->Ysp.Mgt + dizSiz * dizColInf->DYY.Mgt;

//  dizSiz = dizInf->SizYel; DizYelDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizYel; dizColInf->DYY.Yel = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizYelDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Yel;
    diz = dizInf->TblYel;
//  DizYelCur = diz + dzy + dzx;
//  DizYelXsp = diz + dzy; DizYelXep = DizYelXsp + DizYelDYY;
//  DizYelYsp = diz + dzx; DizYelYep = DizYelYsp + dizSiz * DizYelDYY;
    dizColInf->Cur.Yel = diz + dzy + dzx;
    dizColInf->Xsp.Yel = diz + dzy; dizColInf->Xep.Yel = dizColInf->Xsp.Yel + dizColInf->DYY.Yel;
    dizColInf->Ysp.Yel = diz + dzx; dizColInf->Yep.Yel = dizColInf->Ysp.Yel + dizSiz * dizColInf->DYY.Yel;

//  dizSiz = dizInf->SizBla; DizBlaDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizBla; dizColInf->DYY.Bla = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizBlaDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Bla;
    diz = dizInf->TblBla;
//  DizBlaCur = diz + dzy + dzx;
//  DizBlaXsp = diz + dzy; DizBlaXep = DizBlaXsp + DizBlaDYY;
//  DizBlaYsp = diz + dzx; DizBlaYep = DizBlaYsp + dizSiz * DizBlaDYY;
    dizColInf->Cur.Bla = diz + dzy + dzx;
    dizColInf->Xsp.Bla = diz + dzy; dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
    dizColInf->Ysp.Bla = diz + dzx; dizColInf->Yep.Bla = dizColInf->Ysp.Bla + dizSiz * dizColInf->DYY.Bla;

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfSetMon(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf,                                  // Dithering information (each color)
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       elmSiz                                      // Threshold (per 1pixel)
)
{
    DWORD       dizSiz, dzx, dzy;
    LPBYTE      diz;

// Check of zero divide 2002.3.23 >>>
    if (dizInf->SizBla == 0) {
        ERR(("DizInfSetMon() 0Div-Check [dizInf->SizBla=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

//  dizSiz = dizInf->SizBla; DizBlaDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizBla; dizColInf->DYY.Bla = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizBlaDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Bla;
    diz = dizInf->TblBla;
//  DizBlaCur = diz + dzy + dzx;
//  DizBlaXsp = diz + dzy; DizBlaXep = DizBlaXsp + DizBlaDYY;
//  DizBlaYsp = diz + dzx; DizBlaYep = DizBlaYsp + dizSiz * DizBlaDYY;
    dizColInf->Cur.Bla = diz + dzy + dzx;
    dizColInf->Xsp.Bla = diz + dzy; dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
    dizColInf->Ysp.Bla = diz + dzx; dizColInf->Yep.Bla = dizColInf->Ysp.Bla + dizSiz * dizColInf->DYY.Bla;

    return;
}


//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfChgCol(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf                                   // Dithering information (each color)
)
{
//  DizCynCur += DizCynDYY; DizCynXsp += DizCynDYY; DizCynXep += DizCynDYY;
    dizColInf->Cur.Cyn += dizColInf->DYY.Cyn;
    dizColInf->Xsp.Cyn += dizColInf->DYY.Cyn;
    dizColInf->Xep.Cyn += dizColInf->DYY.Cyn;
//  DizMgtCur += DizMgtDYY; DizMgtXsp += DizMgtDYY; DizMgtXep += DizMgtDYY;
    dizColInf->Cur.Mgt += dizColInf->DYY.Mgt;
    dizColInf->Xsp.Mgt += dizColInf->DYY.Mgt;
    dizColInf->Xep.Mgt += dizColInf->DYY.Mgt;
//  DizYelCur += DizYelDYY; DizYelXsp += DizYelDYY; DizYelXep += DizYelDYY;
    dizColInf->Cur.Yel += dizColInf->DYY.Yel;
    dizColInf->Xsp.Yel += dizColInf->DYY.Yel;
    dizColInf->Xep.Yel += dizColInf->DYY.Yel;
//  DizBlaCur += DizBlaDYY; DizBlaXsp += DizBlaDYY; DizBlaXep += DizBlaDYY;
    dizColInf->Cur.Bla += dizColInf->DYY.Bla;
    dizColInf->Xsp.Bla += dizColInf->DYY.Bla;
    dizColInf->Xep.Bla += dizColInf->DYY.Bla;

//  if (DizCynCur == DizCynYep) {
//      DizCynXsp = dizInf->TblCyn;
//      DizCynXep = DizCynXsp + DizCynDYY;
//      DizCynCur = DizCynYsp;
//  }
    if (dizColInf->Cur.Cyn == dizColInf->Yep.Cyn) {
        dizColInf->Xsp.Cyn = dizInf->TblCyn;
        dizColInf->Xep.Cyn = dizColInf->Xsp.Cyn + dizColInf->DYY.Cyn;
        dizColInf->Cur.Cyn = dizColInf->Ysp.Cyn;
    }
//  if (DizMgtCur == DizMgtYep) {
//      DizMgtXsp = dizInf->TblMgt;
//      DizMgtXep = DizMgtXsp + DizMgtDYY;
//      DizMgtCur = DizMgtYsp;
//  }
    if (dizColInf->Cur.Mgt == dizColInf->Yep.Mgt) {
        dizColInf->Xsp.Mgt = dizInf->TblMgt;
        dizColInf->Xep.Mgt = dizColInf->Xsp.Mgt + dizColInf->DYY.Mgt;
        dizColInf->Cur.Mgt = dizColInf->Ysp.Mgt;
    }
//  if (DizYelCur == DizYelYep) {
//      DizYelXsp = dizInf->TblYel;
//      DizYelXep = DizYelXsp + DizYelDYY;
//      DizYelCur = DizYelYsp;
//  }
    if (dizColInf->Cur.Yel == dizColInf->Yep.Yel) {
        dizColInf->Xsp.Yel = dizInf->TblYel;
        dizColInf->Xep.Yel = dizColInf->Xsp.Yel + dizColInf->DYY.Yel;
        dizColInf->Cur.Yel = dizColInf->Ysp.Yel;
    }
//  if (DizBlaCur == DizBlaYep) {
//      DizBlaXsp = dizInf->TblBla;
//      DizBlaXep = DizBlaXsp + DizBlaDYY;
//      DizBlaCur = DizBlaYsp;
//  }
    if (dizColInf->Cur.Bla == dizColInf->Yep.Bla) {
        dizColInf->Xsp.Bla = dizInf->TblBla;
        dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
        dizColInf->Cur.Bla = dizColInf->Ysp.Bla;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfChgMon(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf                                   // Dithering information (each color)
)
{
//  DizBlaCur += DizBlaDYY; DizBlaXsp += DizBlaDYY; DizBlaXep += DizBlaDYY;
    dizColInf->Cur.Bla += dizColInf->DYY.Bla;
    dizColInf->Xsp.Bla += dizColInf->DYY.Bla;
    dizColInf->Xep.Bla += dizColInf->DYY.Bla;

//  if (DizBlaCur == DizBlaYep) {
//      DizBlaXsp = dizInf->TblBla;
//      DizBlaXep = DizBlaXsp + DizBlaDYY;
//      DizBlaCur = DizBlaYsp;
//  }
    if (dizColInf->Cur.Bla == dizColInf->Yep.Bla) {
        dizColInf->Xsp.Bla = dizInf->TblBla;
        dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
        dizColInf->Cur.Bla = dizColInf->Ysp.Bla;
    }

    return;
}


// End of N5DIZPC.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\prnctl.c ===
//***************************************************************************************************
//    PRNCTL.C
//
//    Functions of controlling printer
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    <stdio.h>
#include    "PRNCTL.H"
#include    "strsafe.h"    // Security-Code 2002.3.6

// Replacement of strsafe-api 2002.3.6 >>>
//#ifdef wsprintf
//#undef wsprintf
//#endif // wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Type of pressing raster image
//---------------------------------------------------------------------------------------------------
#define   RASTER_COMP     0                         // Press
#define   RASTER_NONCOMP  1                         // Not press
#define   RASTER_EMPTY    2                         // Empty

//---------------------------------------------------------------------------------------------------
//    Buffer for setting command
//---------------------------------------------------------------------------------------------------
static BYTE        CmdBuf[1 * 1024];                // 1KB

//---------------------------------------------------------------------------------------------------
//    Structure for setting command
//---------------------------------------------------------------------------------------------------
typedef const struct {
    WORD        Size;                               // Command size
    LPBYTE      Cmd;                                // Command buffer
} CMDDEF, FAR *LPCMDDEF;

//===================================================================================================
//    Command define
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//    Change mode
//---------------------------------------------------------------------------------------------------
static CMDDEF ModOrgIn =    { 4, "\x1b""z""\xd0\x01"};      // ESC/Page -> original
static CMDDEF ModOrgOut =   { 4, "\x1b""z""\x00\x01"};      // original -> ESC/Page
//---------------------------------------------------------------------------------------------------
//    Setting overwrite
//---------------------------------------------------------------------------------------------------
static CMDDEF CfgWrtMod =    { 6, "\x1d""%uowE"};           // Setting overwrite
//---------------------------------------------------------------------------------------------------
//    Setting spool positon
//---------------------------------------------------------------------------------------------------
static CMDDEF PosAbsHrz =    { 4, "\x1d""%dX"};             // Horizontal
static CMDDEF PosAbsVtc =    { 4, "\x1d""%dY"};             // Vertical
//---------------------------------------------------------------------------------------------------
//    Spool bitmap data
//---------------------------------------------------------------------------------------------------
static CMDDEF ImgDrw =       {16, "\x1d""%u;%u;%u;%dbi{I"}; // Spool bit image
static CMDDEF ImgRasStr =    {15, "\x1d""%u;%u;%u;%dbrI"};  // Start spool raster image
static CMDDEF ImgRasEnd =    { 4, "\x1d""erI"};             // End spool raster image
static CMDDEF ImgRasDrw =    { 6, "\x1d""%ur{I"};           // Spool raster image
static CMDDEF ImgRasNon =    { 6, "\x1d""%uu{I"};           // Spool raster image(Not press)
static CMDDEF ImgRasEpy =    { 5, "\x1d""%ueI"};            // Spool empty raster image
//---------------------------------------------------------------------------------------------------
//    CASIO original
//---------------------------------------------------------------------------------------------------
static CMDDEF OrgColCmy =    {15, "Cc,%u,%u,%u,%u*"};       // CMYK
static CMDDEF OrgDrwPln =    {15, "Da,%u,%u,%u,%u*"};       // Setting plane
static CMDDEF OrgImgCmy =    {26, "Cj%w,%u,%u,%u,%l,%l,%u,%u*"};   // CMYK bitimage

static BYTE OVERWRITE[] = 
    "\x1D" "1owE"                      //MOV1
    "\x1D" "0tsE";

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static WORD        PlaneCmdStore(PDEVOBJ, LPBYTE, WORD);
static void        BitImgImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE);
static BOOL        RasterImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE);
static WORD        RasterSize(WORD, WORD, WORD, WORD, LPBYTE);
static WORD        RasterComp(LPBYTE, WORD, LPBYTE, LPBYTE, LPWORD);
static void        CMYKImgCmd(PDEVOBJ, WORD, LONG, LONG, WORD, WORD, WORD, WORD, WORD, DWORD, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static WORD        CmdCopy(LPBYTE, LPCMDDEF);
static WORD        CmdStore(LPBYTE, LPCMDDEF, LPINT);
static WORD        INTtoASC(LPBYTE, int);
static WORD        USINTtoASC(LPBYTE, WORD);
static WORD        LONGtoASC(LPBYTE, LONG);
static WORD        USLONGtoASC(LPBYTE, DWORD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMP       lpBmp                                    // Pointer to DRWBMP structure
)
{
    WORD           siz,size;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;                               // byte
    LPBYTE         lpTmpBuf;
    LPBYTE         lpSchBit;
    LPBYTE         lpBit;                                   // Pointer to Bitmap data
    POINT          drwPos;
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;                                 // Width from the left edge
    WORD           widRCnt;                                 // Width from the right edge
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    WORD           img1st;                                  // Spool first image data?
    int            pam[4];
    int            palm[1];

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpTmpBuf = NULL;
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;

    MY_VERBOSE((" PB "));

    img1st = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {               // 1 Spool bitmap data
                                                          // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {
                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {                    // first line?
                        strHigCnt = higCnt;
                        invLft = widLCnt;                 // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;             // Renew invalid size from the left edge
                        }
                    }
                                                          // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {            // first line?
                                invRgt = widRCnt;         // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;     // Renew invalid size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                             // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                        // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {    // 1line all NULL data & There were data except NULL data in previous line
                break;                                    // Go to spool bitmap data
            }
        }
        if (higSiz != 0) {                                // There are data for spool?
            if (img1st == Yes) {                          // Spool for the first time
                                                          // Compress?
                if (pOEM->iCompress != XX_COMPRESS_OFF) {
                    if ((lpTmpBuf = MemAllocZ(widthByte * height)) != NULL) {
                        comp = Yes;
                    }
                }
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                // Color?
                if (pOEM->iColor == XX_COLOR_SINGLE 
                || pOEM->iColor == XX_COLOR_MANY
                || pOEM->iColor == XX_COLOR_MANY2) {
                    pam[0] = lpBmp->Color.Cyn;
                    pam[1] = lpBmp->Color.Mgt;
                    pam[2] = lpBmp->Color.Yel;
                    pam[3] = lpBmp->Color.Bla;
                    siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

                    siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                }
                // Original mode out
                siz += CmdCopy(CmdBuf + siz, &ModOrgOut);
                if (siz != 0) {                         // There are data for spool?
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                            // Not first time
            }

            drwPos.x = lpBmp->DrawPos.x + invLft * 8;   // x coordinates
            drwPos.y = lpBmp->DrawPos.y + strHigCnt;    // y coordinates
            palm[0] = drwPos.x;
            siz = CmdStore(CmdBuf, &PosAbsHrz, palm);
            palm[0] = drwPos.y;
            siz += CmdStore(CmdBuf + siz, &PosAbsVtc, palm);
            if (siz != 0) {                             // There are data for spool?
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            }

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
            if (comp == Yes) {                          // Compress?

                if (RasterImgCmd(pdevobj, pOEM->iCompress, width, higSiz,
                                 widthByte, 0, invLft, invRgt, lpBit, lpTmpBuf) == No) {
                    comp = No;                          // But compress rate is poor, no compress
                }
            }
            if (comp == No) {                           // Not compress

                BitImgImgCmd(pdevobj, width, higSiz, widthByte, 0, invLft, invRgt, lpBit);
            }
        }
    }
    if (lpTmpBuf) {
        MemFree(lpTmpBuf);
    }
    return;
}


//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMPCMYK   lpBmp                                    // Pointer to DRWBMPCMYK structure
)
{
    WORD           siz;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;
    LPBYTE         lpSchBit;                                // Pointer to bitmap data
    LPBYTE         lpBit;                                   // Pointer to bitmap data
    LONG           xPos;
    LONG           yPos;
    WORD           posClpLft;                               // Clipping dot size
    DWORD          posAdj;                                  // 1/7200inch
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;
    WORD           widRCnt;
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    DWORD          invLftBit;                               // Invalid bit size from the left edge
    DWORD          invRgtBit;                               // Invalid bit size from the right edge
    WORD           rgtBit;                                  // Valid bit size from the right edge
    WORD           img1st;                                  // Spool for the first time
    DWORD          dstSiz;
    LPBYTE         lpDst;
    LPBYTE         lpTmp;
    int            pam[1];
    WORD           img1st_2;                                // Spool for the first time

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE((" CM \n"));

// Check of zero divide 2002.3.23 >>>
    if (lpBmp->DataBit == 0) {
        ERR(("PrnBitmapCMYK() 0Div-Check [lpBmp->DataBit=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    lpTmp = NULL;
    posAdj = 7200 / pOEM->Col.wReso;                        // 1/7200inch
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;
    if (pOEM->iCompress != XX_COMPRESS_OFF) {
        if ((lpTmp = MemAllocZ(widthByte * height)) != NULL) {
            comp = Yes;
        }
    }
    img1st = Yes;
    img1st_2 = Yes;
    lpSchBit = lpBmp->lpBit;

    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {                // 1 Spool bitmap data
                                                           // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {

                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {
                        strHigCnt = higCnt;                // first line
                        invLft = widLCnt;                  // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;              // Renew invalid size from the left edge
                        }
                    }
                                                           // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {             // first line
                                invRgt = widRCnt;          // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;      // Renew size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                              // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                         // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {     // 1line all NULL data & There were data except NULL data in previous line
                break;                                     // goto spool
            }
        }
        if (higSiz != 0) {                                 // There are data for spool
            if (img1st_2 == Yes) {
                WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
                img1st_2 = No;
            }
            // When Colormode is XX_COLOR_MANY or XX_COLOR_MANY2 ,not compress
            if (comp == Yes) {
                if (pOEM->iColor == XX_COLOR_MANY || pOEM->iColor == XX_COLOR_MANY2) {
                    comp = No;
                }
            }
            if (comp == No && img1st == Yes) {
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                                                            // Plane
                siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                if (siz != 0) {                             // There are data for spool
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                                // not first
            }

            invLftBit = (DWORD)invLft * 8;
            if (invRgt != 0) {

                if ((rgtBit = (WORD)((DWORD)width * lpBmp->DataBit % 8)) == 0) {
                    rgtBit = 8;
                }
                if (rgtBit == 8) {
                    invRgtBit = (DWORD)invRgt * 8;
                } else {
                    invRgtBit = ((DWORD)invRgt - 1) * 8 + rgtBit;
                }
            } else {
                invRgtBit = 0;
            }
            posClpLft = (WORD)(invLftBit / lpBmp->DataBit);
                                                             // Start position of spooling
            xPos = ((LONG)lpBmp->DrawPos.x + posClpLft) * posAdj;
            yPos = ((LONG)lpBmp->DrawPos.y + strHigCnt) * posAdj;

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
                                                             // Spool CMYK bit image
            CMYKImgCmd(pdevobj, comp, xPos, yPos, lpBmp->Frame, lpBmp->DataBit, width, higSiz, widthByte,
                       invLftBit, invRgtBit, lpBit, lpTmp, (LONG)lpBmp->DrawPos.x + posClpLft, (LONG)lpBmp->DrawPos.y + strHigCnt);
        }
    }

    if (img1st == No) {                                      // Already spool 
        // Original mode out
        siz = CmdCopy(CmdBuf, &ModOrgOut);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    }
    if (lpTmp) {
        MemFree(lpTmp);
    }
    return;
}


//===================================================================================================
//    Spool plane command
//===================================================================================================
WORD PlaneCmdStore(                                         // Size of command
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPBYTE         lpDst,
    WORD           Plane
)
{
    int            pam[4];
    WORD           siz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (Plane & PLN_CYAN) {
        pam[0] = 0;                                         // Spool
    } else {
        pam[0] = 1;                                         // Not spool
    }
    if (Plane & PLN_MGENTA) {
        pam[1] = 0;                                         // Spool
    } else {
        pam[1] = 1;                                         // Not spool
    }
    if (Plane & PLN_YELLOW) {
        pam[2] = 0;                                         // Spool
    } else {
        pam[2] = 1;                                         // Not spool
    }
    if (Plane & PLN_BLACK) {
        pam[3] = 0;                                         // Spool
    } else {
        pam[3] = 1;                                         // Not spool
    }
    siz = CmdStore(lpDst, &OrgDrwPln, pam);
    return siz;
}


//===================================================================================================
//    Spool bitimage command data
//===================================================================================================
void BitImgImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotare(0fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit                                    // Bitmap data
)
{
    int            pam[10];
    WORD           siz;
    WORD           widByt;
    WORD           linCnt;

    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size
        pam[0] = WidthByte * Height;                        // Number of Data byte
        pam[1] = Width;
        pam[2] = Height;
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
    } else {                                                // There are invalid size
        widByt = WidthByte - InvLeft - InvRight;            // Width byte
        pam[0] = widByt * Height;
        if (InvRight == 0) {                                // There are no invalid size from the right edge
            pam[1] = Width - InvLeft * 8;                   // Width bit image
        } else {
            pam[1] = widByt * 8;                            // Width bit image
        }
        pam[2] = Height;                                    // Height bit image
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line
            lpBit += InvLeft;
            WRITESPOOLBUF(pdevobj, lpBit, widByt);
            lpBit += widByt;
            lpBit += InvRight;
        }
    }
    return;
}


//===================================================================================================
//    Spool raster image command data
//===================================================================================================
BOOL RasterImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotate(0:fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the left edge
    LPBYTE         lpBit,                                   // Pointer to bitmap data
    LPBYTE         lpBuf                                    // Pointer to raster image data buffer
)
{
    int            pam[4];
    WORD           siz;
    WORD           widByt;
    WORD           setCnt;
    WORD           ras;                                     // Type of raster image
    WORD           befRas;                                  // Type of raster image(Privious line)
    LPBYTE         lpLas;                                   // Privious raster data
    WORD           dstSiz;                                  // byte size
    WORD           rasSiz;                                  // Raster image data byte size
    WORD           rasEpy;

    MY_VERBOSE((" RAS "));

    widByt = WidthByte - InvLeft - InvRight;                // Width byte (Not include invalid size)
    if (Comp == XX_COMPRESS_AUTO) {
                                                            // Get raster image size
        rasSiz = RasterSize(Height, widByt, InvLeft, InvRight, lpBit);
        if (rasSiz > (widByt * Height / 5 * 4)) {           // Raster rate is more than 80%
            return No;                                      // Error
        }
    }
    pam[0] = 4;
    if (InvRight == 0) {                                    // No invalid size from the right edge
        pam[1] = Width - InvLeft * 8;                       // Width
    } else {
        pam[1] = widByt * 8;                                // Width
    }
    pam[2] = Height;                                        // Height
    pam[3] = Rotation;
    siz = CmdStore(CmdBuf, &ImgRasStr, pam);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    lpLas = NULL;
    rasSiz = 0;
    rasEpy = 0;
    for (setCnt = 0; setCnt < Height; setCnt++) {
        lpBit += InvLeft;
                                                            // Compress
        ras = RasterComp(lpBuf + rasSiz, widByt, lpBit, lpLas, &dstSiz);
        if (setCnt != 0 && befRas != ras) {                 // Not same as raster state of previous line
            if (befRas == RASTER_COMP) {
                pam[0] = rasSiz;
                siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);        // Spool command
                WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);      // Spool data
                rasSiz = 0;
            } else if (befRas == RASTER_EMPTY) {
                pam[0] = rasEpy;
                siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                rasEpy = 0;
            }
        }                                                   // Spool state of current line
        if (ras == RASTER_COMP) {
            rasSiz += dstSiz;
        } else if (ras == RASTER_EMPTY) {
            rasEpy++;
        } else {
            pam[0] = dstSiz;
            siz = CmdStore(CmdBuf, &ImgRasNon, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);            // Spool command
            WRITESPOOLBUF(pdevobj, lpBit, dstSiz);          // Spool data
        }
        befRas = ras;                                       // Renew
        lpLas = lpBit;                                      // Renew
        lpBit += widByt;                                    // Renew
        lpBit += InvRight;
    }
    if (rasSiz != 0) {                                      // There are raster data without spooling
        pam[0] = rasSiz;
        siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
        WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);              // Spool data
    } else if (rasEpy != 0) {                               // There are empty raster data without spooling
        pam[0] = rasEpy;
        siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
    }
    siz = CmdCopy(CmdBuf, &ImgRasEnd);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    return Yes;
}


//===================================================================================================
//    Get size of raster image
//===================================================================================================
WORD RasterSize(
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           InvLeft,
    WORD           InvRight,
    LPBYTE         lpBit
)
{
    WORD           rasSiz;
    WORD           chkCnt;
    WORD           rasEpy;
    LPBYTE         lpLas;
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;

    rasSiz = 0;
    rasEpy = 0;
    lpLas = NULL;
    for (chkCnt = 0; chkCnt < Height; chkCnt++) {           // Check size of raster image
        lpBit += InvLeft;
        srcCnt = WidthByte;
        for (; srcCnt != 0; srcCnt--) {
            if (lpBit[srcCnt - 1] != 0x00) {
                break;
            }
        }
        if (srcCnt == 0) {                                  // 1 line All white data?
            rasEpy++;
            lpLas = lpBit;
            lpBit += WidthByte;
            lpBit += InvRight;
            continue;
        }
        if (rasEpy != 0) {
            rasSiz += 8;
            rasEpy = 0;
        }
        empSiz = WidthByte - srcCnt;
        for (dstCnt = 0, srcCnt = 0; srcCnt < WidthByte; ) {
            if (lpLas != NULL) {
                if (lpLas[srcCnt] == lpBit[srcCnt]) {
                    equCnt = 1;
                    srcCnt++;
                    for (; srcCnt < WidthByte; srcCnt++) {

                        if (lpLas[srcCnt] != lpBit[srcCnt]) {
                            break;
                        }
                        equCnt++;
                    }
                    if (srcCnt == WidthByte) {
                        rasSiz++;
                        break;
                    }
                }
                rasSiz++;
                if (equCnt >= 63) {
                    rasSiz += ((equCnt / 255) + 1);
                }
            }

            if (srcCnt < (WidthByte - 1) && lpBit[srcCnt] == lpBit[srcCnt + 1]) {
                cmpDat = lpBit[srcCnt];
                equCnt = 2;

                for (srcCnt += 2; srcCnt < WidthByte; srcCnt++) {
                    if (cmpDat != lpBit[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                rasSiz += 2;
                if (equCnt >= 63) {
                    rasSiz += equCnt / 255 + 1;
                }
            } else {
                if (WidthByte < (dstCnt + 9)) {
                    rasSiz += WidthByte - empSiz + 9;
                    break;
                }
                if ((WidthByte - srcCnt) < 8) {
                    rasSiz += WidthByte - srcCnt + 1;
                    srcCnt += WidthByte - srcCnt;
                } else {
                    rasSiz += 9;
                    srcCnt += 8;
                }
            }
        }
        lpLas = lpBit;
        lpBit += WidthByte;
        lpBit += InvRight;
    }
    return rasSiz;
}


//===================================================================================================
//    Compress raster image
//===================================================================================================
WORD RasterComp(
    LPBYTE         lpDst,
    WORD           Siz,
    LPBYTE         lpSrc,
    LPBYTE         lpLas,
    LPWORD         lpDstSiz
)
{
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;
    WORD           setCnt;
    BYTE           flgByt;
    WORD           flgPnt;

    static const BYTE flgTbl[8] = {0x00, 0x01, 0x02, 0x04,
                                   0x08, 0x10, 0x20, 0x40};

    srcCnt = Siz;
    for (; srcCnt != 0; srcCnt--) {
        if (lpSrc[srcCnt - 1] != 0x00) {
            break;
        }
    }
    if (srcCnt == 0) {
        *lpDstSiz = 0;
        return RASTER_EMPTY;
    }
    empSiz = Siz - srcCnt;
    for (dstCnt = 0, srcCnt = 0; srcCnt < Siz; ) {
        if (lpLas != NULL) {
            if (lpLas[srcCnt] == lpSrc[srcCnt]) {
                equCnt = 1;
                srcCnt++;
                for (; srcCnt < Siz; srcCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                if (srcCnt == Siz) {
                    break;
                }
                if (Siz < (dstCnt + equCnt / 255 + 1)) {
                    *lpDstSiz = Siz - empSiz;
                    return RASTER_NONCOMP;
                }
                if (equCnt < 63) {
                    lpDst[dstCnt++] = 0x80 | (BYTE)equCnt;
                } else {
                    lpDst[dstCnt++] = 0x80 | 0x3f;
                    for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                        lpDst[dstCnt++] = 0xff;
                    }
                    lpDst[dstCnt++] = (BYTE)equCnt;
                }
            }
        }

        if (srcCnt < (Siz - 1) && lpSrc[srcCnt] == lpSrc[srcCnt + 1]) {
            cmpDat = lpSrc[srcCnt];
            equCnt = 2;
            for (srcCnt += 2; srcCnt < Siz; srcCnt++) {
                if (cmpDat != lpSrc[srcCnt]) {
                    break;
                }
                equCnt++;
            }
            if (Siz < (dstCnt + equCnt / 255 + 2)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            if (equCnt < 63) {
                lpDst[dstCnt++] = 0xc0 | (BYTE)equCnt;
            } else {
                lpDst[dstCnt++] = 0xc0 | 0x3f;
                for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                    lpDst[dstCnt++] = 0xff;
                }
                lpDst[dstCnt++] = (BYTE)equCnt;
            }
            lpDst[dstCnt++] = cmpDat;
        } else {
            if (Siz < (dstCnt + 9)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            flgPnt = dstCnt;
            dstCnt++;
            flgByt = 0x00;
            if (lpLas != NULL) {
                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        lpDst[dstCnt++] = lpSrc[srcCnt];
                        flgByt |= flgTbl[setCnt];
                    }
                }
            } else {

                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    lpDst[dstCnt++] = lpSrc[srcCnt];
                    flgByt |= flgTbl[setCnt];
                }
            }
            lpDst[flgPnt] = flgByt;
        }
    }
    if (Siz == dstCnt) {
        *lpDstSiz = Siz - empSiz;
        return RASTER_NONCOMP;
    }
    lpDst[dstCnt++] = 0x80;
    *lpDstSiz = dstCnt;
    return RASTER_COMP;
}


//===================================================================================================
//    Spool CMYK Bit image command
//===================================================================================================
void CMYKImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    LONG           XPos,
    LONG           YPos,
    WORD           Frame,
    WORD           DataBit,                                 // (1:2value 2:4value 4:16value)
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    DWORD          InvLeft,                                 // Invalid size from the left edge
    DWORD          InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit,
    LPBYTE         lpTmp,
    LONG           XPos_P,
    LONG           YPos_P
)
{
    int            pam[11];
    WORD           siz;
    WORD           widByt;                                  // Width byte(Not include invalid size)
    WORD           Plane;
    LPBYTE         lpDst;                                   // Memory copy
    LPBYTE         lpSrc;                                   // Memory copy
    WORD           linCnt;
    DWORD          widBit;                                  // Width bit(Not include invalid size)
    DWORD          dstSiz;
    DWORD          rasSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

// Check of zero divide 2002.3.23 >>>
    if (DataBit == 0) {
        ERR(("CMYKImgCmd() 0Div-Check [DataBit=0] \n"));
        return;
    }
// Check of zero divide 2002.3.23 <<<

    widBit = (DWORD)Width * DataBit - InvLeft - InvRight;

    if (Comp == Yes) {                                       // Compress
        siz = CmdCopy(CmdBuf, &ModOrgIn);                    // Original mode in

        if (pOEM->iColor == XX_COLOR_SINGLE 
        || pOEM->iColor == XX_COLOR_MANY
        || pOEM->iColor == XX_COLOR_MANY2) {
            pam[0] = 0;
            pam[1] = 0;
            pam[2] = 0;
            pam[3] = 0;
            if (Frame == 1) {
                pam[0] = 255;
                Plane = PLN_CYAN;
            }
            if (Frame == 2) {
                pam[1] = 255;
                Plane = PLN_MGENTA;
            }
            if (Frame == 3) {
                pam[2] = 255;
                Plane = PLN_YELLOW;
            }
            if (Frame == 0) {
                pam[3] = 255;
                Plane = PLN_BLACK;
            }
            siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

            siz += PlaneCmdStore(pdevobj, CmdBuf + siz, Plane);
        }
        siz += CmdCopy(CmdBuf + siz, &ModOrgOut);           // Original mode out
        if (siz != 0) {                                     // There are data for spool?

            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }
        pam[0] = XPos_P;
        siz = CmdStore(CmdBuf, &PosAbsHrz, pam);
        pam[0] = YPos_P;
        siz += CmdStore(CmdBuf + siz, &PosAbsVtc, pam);
        if (siz != 0) {                                     // There are data for spool
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }

        if (RasterImgCmd(pdevobj, pOEM->iCompress, Width, Height,
                         WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit, lpTmp) == No) {
            // Not compress because compress rate is poor
            BitImgImgCmd(pdevobj, Width, Height, WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit);
        }
    }

    if (Comp == No) {                                        // Not compress
        pam[2] = 0;
        pam[3] = Frame;
        pam[4] = DataBit;
        pam[5] = HIWORD(XPos);
        pam[6] = LOWORD(XPos);
        pam[7] = HIWORD(YPos);
        pam[8] = LOWORD(YPos);
        pam[10] = Height;
        if (InvLeft == 0 && InvRight == 0) {                 // Not include invalid size
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = WidthByte * Height;                     // Data byte size (low byte)
            pam[9] = Width;
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            WRITESPOOLBUF(pdevobj, lpBit, pam[1]);
        } else {                                             // Include invalid size
            widByt = (WORD)((widBit + 7) / 8);
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = widByt * Height;                        // Data byte size (low byte)
            pam[9] = (WORD)(widBit / DataBit);
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            for (linCnt = 0; linCnt < Height; linCnt++) {    // Spool bitmap data by 1 line
                WRITESPOOLBUF(pdevobj, lpBit + (WORD)(InvLeft / 8), widByt);
                lpBit += WidthByte;
            }
        }
    }
    return;
}


//===================================================================================================
//    Copy command buffer
//===================================================================================================
WORD CmdCopy(
    LPBYTE         lpDst,
    LPCMDDEF       lpCmdInf
)
{
    WORD           siz;
    LPBYTE         lpCmd;

    lpCmd = lpCmdInf->Cmd;
    for (siz = 0; siz < lpCmdInf->Size; siz++) {
        lpDst[siz] = lpCmd[siz];
    }
    return siz;
}


//===================================================================================================
//    Copy command data
//===================================================================================================
WORD CmdStore(
    LPBYTE         lpDst,
    LPCMDDEF       CmdInf,
    LPINT          lpPam
)
{
    LPBYTE         lpCmd;
    BYTE           cmdDat;
    WORD           cmdCnt;
    WORD           setCnt;
    WORD           pamCnt;
    WORD           upmDat;
    int            pamDat;
    DWORD          dDat;
    LONG           lDat;

    setCnt = 0;
    pamCnt = 0;
    lpCmd = CmdInf->Cmd;
    for (cmdCnt = 0; cmdCnt < CmdInf->Size; cmdCnt++) {     // Copy
        cmdDat = *lpCmd++;
        if (cmdDat != '%') {
            lpDst[setCnt++] = cmdDat;
        } else {
            cmdCnt++;
            switch (cmdDat = *lpCmd++) {                    // Type
                case 'u':
                    setCnt += USINTtoASC(&lpDst[setCnt], (WORD)lpPam[pamCnt++]);
                    break;
                case 'd':
                    setCnt += INTtoASC(&lpDst[setCnt], lpPam[pamCnt++]);
                    break;
#if 0   /* 441435: Currently Not used */
                case 'y':
                    upmDat = (WORD)lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat / 100));
                    }
                    if ((upmDat % 100) != 0) {
                        lpDst[setCnt++] = '.';

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat % 100));
                    }
                    break;
                case 'z':
                    pamDat = lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += INTtoASC(&lpDst[setCnt], (pamDat / 100));
                    }
                    if ((pamDat % 100) != 0) {
                        lpDst[setCnt++] = '.';
                        if (pamDat < 0) {
                            pamDat = 0 - pamDat;
                        }

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(pamDat % 100));
                    }
                    break;
#endif   /* 441435: Currently Not used */
                case 'w':
                    dDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += USLONGtoASC(&lpDst[setCnt], dDat);
                    pamCnt += 2;
                    break;
                case 'l':
                    lDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += LONGtoASC(&lpDst[setCnt], lDat);
                    pamCnt += 2;
                    break;
#if 0   /* 441435: Currently Not used */
                case 'b':
                    lpDst[setCnt++] = (BYTE)lpPam[pamCnt++];
                    break;
#endif   /* 441435: Currently Not used */
                case '%':
                    lpDst[setCnt++] = cmdDat;
                    break;
            }
        }
    }
    return setCnt;
}


//===================================================================================================
//    int -> ascii
//===================================================================================================
WORD INTtoASC(
    LPBYTE         lpDst,
    int            Dat                                      // Conversion data
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (int)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    usint -> ascii
//===================================================================================================
WORD USINTtoASC(
    LPBYTE         lpDst,
    WORD           Dat
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    long -> ascii
//===================================================================================================
WORD LONGtoASC(
    LPBYTE         lpDst,
    LONG           Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (LONG)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    uslong -> ascii
//===================================================================================================
WORD USLONGtoASC(
    LPBYTE         lpDst,
    DWORD          Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\prnctl.h ===
//***************************************************************************************************
//    PRNCTL.H
//
//    C Header(Functions of controlling printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Plane
//---------------------------------------------------------------------------------------------------
#define    PLN_CYAN        0x8000
#define    PLN_MGENTA      0x4000
#define    PLN_YELLOW      0x2000
#define    PLN_BLACK       0x1000

#define    PLN_ALL            (PLN_CYAN | PLN_MGENTA | PLN_YELLOW | PLN_BLACK)

//---------------------------------------------------------------------------------------------------
//    Structure of spooling bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    CMYK        Color;                                      // CMYK
    WORD        Diz;                                        // Type of dithering
    POINT       DrawPos;                                    // Start position of spooling
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // bitamp data
} DRWBMP, FAR *LPDRWBMP;

//---------------------------------------------------------------------------------------------------
//    Structure of spooling CMYK bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    WORD        Frame;                                      // Frame
    WORD        DataBit;                                    // Databit
    POINT       DrawPos;                                    // Start position of spool
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // Bitmap data
} DRWBMPCMYK, FAR *LPDRWBMPCMYK;


//***************************************************************************************************
//     Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(PDEVOBJ, LPDRWBMP);

//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(PDEVOBJ, LPDRWBMPCMYK);

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>

#include <prcomoem.h>
#include "COLMATCH.H"
#include "DEBUG2.H"

//
// For debugging.
//

#ifndef DEBUG2_FILE
//#define MY_VERBOSE(x) DBGPRINT(DBG_WARNING, x)
#define MY_VERBOSE VERBOSE
//#define DL_VERBOSE MY_VERBOSE
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE MY_VERBOSE
#define SC_VERBOSE VERBOSE
//#define CM_VERBOSE MY_VERBOSE
#define CM_VERBOSE VERBOSE

#else   // DEBUG2_FILE
#define DUMP_VERBOSE(p1,p2) DbgFDump(p1,p2);
#define SB_VERBOSE(no, msg) { DbgFPrint msg; }
#define MY_VERBOSE(msg) SB_VERBOSE(1, msg)
#define DL_VERBOSE(msg) SB_VERBOSE(1, msg)
#define SC_VERBOSE(msg) SB_VERBOSE(1, msg)
#define CM_VERBOSE(msg) SB_VERBOSE(1, msg)
#endif  // DEBUG2_FILE

//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define DRVGETGPDDATA(p, t, i, b, s, n) \
  ((p)->pDrvProcs->DrvGetGPDData(p, t, i, b, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

#define DEFAULT_PALETTE_INDEX   0

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD    fGeneral;
    int    iEscapement;
    short    sHeightDiv;
    short    iDevCharOffset;
    BYTE    iPaperSource;
    BYTE    iDuplex;
    BYTE    iTonerSave;
    BYTE    iOrientation;
    BYTE    iResolution; 
    BYTE    iColor;
    BYTE    iSmoothing;
    BYTE    iJamRecovery;
    BYTE    iMediaType;
    BYTE    iOutBin;             //+N5
    BYTE    iIcmMode;            //+N5
    BYTE    iUnitFactor;         // factor of master unit
    BYTE    iDithering;
    BYTE    iColorMatching;
    BYTE    iBitFont;
    BYTE    iCmyBlack;
    BYTE    iTone;
    BYTE    iPaperSize;
    BYTE    iCompress;
    WORD    Printer;
    DEVCOL  Col;
    WORD    wRectWidth, wRectHeight;

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;


#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    DWORD dwSelectedColor;     // Latest selected color descirbe as COLOR_SELECT_xxx
    BYTE iColorMayChange;    // 1 means called block data callback that may change color
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS        0x00000001
#define FG_VERT        0x00000002
#define FG_PROP        0x00000004
#define FG_DOUBLE      0x00000008
#define FG_NULL_PEN    0x00000010
#define FG_BOLD        0x00000020
#define FG_ITALIC      0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizpc.h ===
//***************************************************************************************************
//    N5DIZPC.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColDrwInfSet(LPDIZINF, LPDRWINF, DWORD);
#endif
VOID  WINAPI N501ColDizPrc(LPDIZINF, LPDRWINF);

//  End of N5DIZPC.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..
N5SRCDIR=..\..\casn5res

TARGETNAME=csn5res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),csn5res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\csn5res.rc \
    $(SRCDIR)\csn5res.c \
    $(SRCDIR)\prnctl.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\colmatch.c \
    $(SRCDIR)\N5colmh.c \
    $(SRCDIR)\N5colsb.c \
    $(SRCDIR)\N5dizmk.c \
    $(SRCDIR)\N5dizpc.c \
    $(SRCDIR)\debug2.c

MISCFILES=\
    $(SRCDIR)\csn5res.ini \
    $(SRCDIR)\lut\cpn5nml.diz \
    $(SRCDIR)\lut\cpn5rgb.lt3 \
    $(SRCDIR)\lut\cpn5rn10.icm \
    $(GPDDIR)\csn5j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\csn5res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
    "DrvGetGPDData",
    "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
    "ImageProcessing",
    "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.
#include "strsafe.h"    // Security-Code 2002.3.6

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>
#include "strsafe.h"         // Security-Code 2002.3.6

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinres.h ===
#ifndef _CSWINRES_H
#define _CSWINRES_H

// ===== Printer Model =====
#define MD_CP3250GTWM           0x01
#define MD_CP3500GTWM           0x02
#define MD_CP3800WM             0x03

// MPF Setting
#define OPT_NOSET               "Option1"
#define OPT_A3                  "Option2"
#define OPT_B4                  "Option3"
#define OPT_A4                  "Option4"
#define OPT_B5                  "Option5"
#define OPT_LETTER              "Option6"
#define OPT_POSTCARD            "Option7"
#define OPT_A5                  "Option8"

// Toner Save
#define OPT_TS_NORMAL           "Option1"
#define OPT_TS_LV1              "Option2"
#define OPT_TS_LV2              "Option3"
#define OPT_TS_LV3              "Option4"
#define OPT_TS_NOTSELECT        "Option5"

// Smoothing
#define OPT_SMOOTH_OFF          "Option1"
#define OPT_SMOOTH_ON           "Option2"
#define OPT_SMOOTH_NOTSELECT    "Option3"

// ===== AutoFeed =====
const
static BYTE AutoFeed[] = {        /* Auto Select */
                                  0x26,    /* A3 */
                                  0x29,    /* B4 */
                                  0x2b,    /* A4 */
                                  0x2c,    /* B5 */
                                  0x11,    /* Letter */
                                  0x2f,    /* PostCard */
                                  0x2d     /* A5 */
};

const
static BYTE AutoFeed_3800[] = {   /* For 3800 */
                                  0x26,    /* A3 */
                                  0x29,    /* B4 */
                                  0x2b,    /* A4 */
                                  0x2c,    /* B5 */
                                  0x11,    /* Letter */
                                  0x11,    /* PostCard */
                                  0x2d     /* A5 */
};

#define MASTER_UNIT 1200

// ===== JIS->ASCII Table =====
#if 0 // >>> Change UFM File(JIS->SJIS) >>>
const
static BYTE jJis2Ascii[][96] = {

/*++            0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
2120 --*/    {   0,  32, 164, 161,  44,  46, 165,  58,  59,  63,  33, 222, 223,   0,  96,   0,
/*++                SP   A   B   C   D   E   F   G   H   I   J   K   L   M   N
                    SP            ,    .        :    ;    ?    !                 `

2130 --*/       94, 126,  95,   0,   0,   0,   0,   0,   0,   0,   0,   0, 176,  45,   0,  47,
/*++           O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^
                ^    ~    _                                                     -         /

2140 --*/        0,   0,   0, 124,   0,   0,   0,  39,   0,  34,  40,  41,  91,  93,  91,  93,
/*++           _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n
                               |                   '         "     (   )    [    ]    [    ]

2150 --*/      123, 125,  60,  62,   0,   0, 162, 163,   0,   0,   0,   0,  43,  45,   0,   0,
/*++           o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
                {    }    <    >                                          +    -

2160 --*/        0,  61,   0,  60,  62,   0,   0,   0,   0,   0,   0, 223,  39,  34,   0,  92,
/*++                                                        
                     =         <    >                                      '    "         \

2170 --*/       36,   0,   0,  37,  35,  38,  42,  64,   0,   0,   0,   0,   0,   0,   0,   0 },
/*++                                                      
                $              %    #    &    *    @


2520 --*/    {   0, 167, 177, 168, 178, 169, 179, 170, 180, 171, 181, 182,   0, 183,   0, 184,
/*++                @   A   B   C   D   E   F   G   H   I   J   K   L   M   N
                                                                               

2530 --*/        0, 185,   0, 186,   0, 187,   0, 188,   0, 189,   0, 190,   0, 191,   0, 192,
/*++           O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^
                                                                                    

2540 --*/        0, 193,   0, 175, 194,   0, 195,   0, 196,   0, 197, 198, 199, 200, 201, 202,
/*++           _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n
                                                                                 

2550 --*/        0,   0, 203,   0,   0, 204,   0,   0, 205,   0,   0, 206,   0,   0, 207, 208,
/*++           o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
                                                                                      

2560 --*/      209, 210, 211, 172, 212, 173, 213, 174, 214, 215, 216, 217, 218, 219,   0, 220,
/*++                                                        
                                                                             

2570 --*/        0,   0, 166, 221,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }
/*++                             
                              
      --*/
};
#endif // <<< Change UFM File(JIS->SJIS) <<<


#endif //--- _CSWINRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinid.h ===
#ifndef _CSWINID_H
#define _CSWINID_H

// Callback ID's
#define RES_SENDBLOCK           12

#define RES_SELECTRES_240       14
#define RES_SELECTRES_400       15

#define CM_XM_ABS               20
#define CM_YM_ABS               22

#define CM_REL_LEFT             24
#define CM_REL_RIGHT            25
#define CM_REL_UP               26
#define CM_REL_DOWN             27

#define CM_FE_RLE               30
#define CM_DISABLECOMP          31

#define CSWM_CR                 40
#define CSWM_COPY               45
#define CSWM_FF                 47
#define CSWM_LF                 48

#define AUTOFEED                49

#define PS_SEGMENT              60
#define PS_A3                   60
#define PS_B4                   61
#define PS_A4                   62
#define PS_B5                   63
#define PS_LETTER               64
#define PS_POSTCARD             65
#define PS_A5                   66
#define PS_FREE                 67

#define PRN_3250GTWM           109
#define PRN_3500GTWM           110
#define PRN_3800WM             111

#define SBYTE                  120
#define DBYTE                  121
#define CM_BOLD_ON             122
#define CM_BOLD_OFF            123
#define CM_ITALIC_ON           124
#define CM_ITALIC_OFF          125
#define CM_WHITE_ON            126
#define CM_WHITE_OFF           127

#define START_DOC              130
#define END_DOC                131

#define DRW_WHITE_RECT         140
#define DRW_BLACK_RECT         141
#define DRW_GRAY_RECT          142
#define DRW_RECT_WIDTH         143
#define DRW_RECT_HEIGHT        144


#endif //_CSWINID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinres.c ===
// =========================================================================
//
//        CASIO PAGEPRESTO Universal Printer Driver for MS-Windows NT 5.0
//
// =========================================================================

//// CSWINRES.C file for Winmode Common DLL


#include "pdev.h"
#include "cswinres.h"
#include "cswinid.h"

#if DBG
#  include "mydbg.h"
#endif

#include <stdio.h>
#include "strsafe.h"         // Security-Code 2002.3.6
// Replacement of strsafe-api 2002.3.6 >>>
//#undef wsprintf
//#define wsprintf sprintf
// Replacement of strsafe-api 2002.3.6 <<<

#define CCHMAXCMDLEN 256
#define MAX_STRLEN 255

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define PARAM(p,n) \
    (*((p)+(n)))


BOOL
BInitOEMExtraData(
        POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.

    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}


BOOL
BMergeOEMExtraData(
        POEMUD_EXTRADATA pdmIn,
        POEMUD_EXTRADATA pdmOut)
{
    return TRUE;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;

    VERBOSE(("OEMEnablePDEV - %08x\n", pdevobj));

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    // misc initializations

    pOEM = (PMYPDEV)pdevobj->pdevOEM;
    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    VERBOSE(("OEMDisablePDEV - %08x\n", pdevobj));

    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOld, pNew;

    VERBOSE(("OEMResetPDEV - %08x, %08x\n", pdevobjOld, pdevobjNew));

    if (NULL == (pOld = (PMYPDEV)pdevobjOld->pdevOEM) ||
        NULL == (pNew = (PMYPDEV)pdevobjNew->pdevOEM)) {
        ERR(("Invalid PDEV\n"));
        return FALSE;
    }

    *pNew = *pOld;
    return TRUE;
}

static
VOID
LoadJobSetupCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM)
{
    BYTE ajOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;

    if (pOEM->dwGeneral & FG_HAS_TSAVE) {

        if(!DRVGETDRIVERSETTING(pdevobj, "TonerSave", ajOutput, 
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("DrvGetDriverSetting(1) Failed\n"));
            pOEM->jTonerSave = VAL_TS_NOTSELECT;
        } else {
            VERBOSE(("TonerSave:%s\n", ajOutput));
            if (!strcmp(ajOutput, OPT_TS_NORMAL)) {
                pOEM->jTonerSave = VAL_TS_NORMAL;
                VERBOSE(("VAL_TS_NORMAL\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV1)) {
                pOEM->jTonerSave = VAL_TS_LV1;
                VERBOSE(("VAL_TS_LV1\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV2)) {
                pOEM->jTonerSave = VAL_TS_LV2;
                VERBOSE(("VAL_TS_LV2\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV3)) {
                pOEM->jTonerSave = VAL_TS_LV3;
                VERBOSE(("VAL_TS_LV3\n"));
            } else {
                pOEM->jTonerSave = VAL_TS_NOTSELECT;
                VERBOSE(("VAL_TS_NOTSELECT\n"));
            }
        }
        VERBOSE(("jTonerSave:%x\n", pOEM->jTonerSave));
    }

    if (pOEM->dwGeneral & FG_HAS_SMOTH) {

        if (!DRVGETDRIVERSETTING(pdevobj, "Smoothing", ajOutput,
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("DrvGetDriverSetting(1) Failed\n"));
            pOEM->jSmoothing = VAL_SMOOTH_NOTSELECT;
        } else {
            VERBOSE(("Smoothing:%s\n", ajOutput));
            if (!strcmp(ajOutput, OPT_SMOOTH_OFF)) {
                pOEM->jSmoothing = VAL_SMOOTH_OFF;
                VERBOSE(("VAL_SMOOTH_OFF\n"));
            } else if (!strcmp(ajOutput, OPT_SMOOTH_ON)) {
                pOEM->jSmoothing = VAL_SMOOTH_ON;
                VERBOSE(("VAL_SMOOTH_ON\n"));
            } else {
                pOEM->jSmoothing = VAL_SMOOTH_NOTSELECT;
                VERBOSE(("VAL_SMOOTH_NOTSELECT\n"));
            }
        }
        VERBOSE(("jSmoothing:%x\n", pOEM->jSmoothing));
    }

    if (!DRVGETDRIVERSETTING(pdevobj, "MPFSetting", ajOutput,
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        WARNING(("DrvGetDriverSetting(1) Failed\n"));
        pOEM->jMPFSetting = MPF_NOSET;
    } else {
        VERBOSE(("MPFSetting:%s\n", ajOutput));
        if (!strcmp(ajOutput, OPT_A3)) {
            pOEM->jMPFSetting = MPF_A3;
            VERBOSE(("MPF_A3\n"));
        } else if (!strcmp(ajOutput, OPT_B4)) {
            pOEM->jMPFSetting = MPF_B4;
            VERBOSE(("MPF_B4\n"));
        } else if (!strcmp(ajOutput, OPT_A4)) {
            pOEM->jMPFSetting = MPF_A4;
            VERBOSE(("MPF_A4\n"));
        } else if (!strcmp(ajOutput, OPT_B5)) {
            pOEM->jMPFSetting = MPF_B5;
            VERBOSE(("MPF_B5\n"));
        } else if (!strcmp(ajOutput, OPT_A5)) {
            pOEM->jMPFSetting = MPF_A5;
            VERBOSE(("MPF_A5\n"));
        } else if (!strcmp(ajOutput, OPT_LETTER)) {
            pOEM->jMPFSetting = MPF_LETTER;
            VERBOSE(("MPF_LETTER\n"));
        } else if (!strcmp(ajOutput, OPT_POSTCARD)) {
            pOEM->jMPFSetting = MPF_POSTCARD;
            VERBOSE(("MPF_POSTCARD\n"));
        } else {
            pOEM->jMPFSetting = MPF_NOSET;
            VERBOSE(("MPF_NOSET\n"));
        }
    }
    VERBOSE(("jMPFSetting:%x\n", pOEM->jMPFSetting));

}

static
VOID
LoadPaperSelectCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM,
    INT iPaperID,
    WORD wPapSizeX,
    WORD wPapSizeY)
{
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen = 0;
    DWORD dwTemp;
    WORD wPapLenX;
    WORD wPapLenY;
    BYTE ajOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;
    BYTE bOrientation;
    
    switch (iPaperID) {
    case PS_LETTER:

        if (pOEM->jMPFSetting == MPF_LETTER) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    28h: Letter -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x28;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A3:

        if (pOEM->jMPFSetting == MPF_A3) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    1Fh: A3 |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x1F;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A4:

        if (pOEM->jMPFSetting == MPF_A4) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Ah: A4 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2A;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_B4:

        if (pOEM->jMPFSetting == MPF_B4) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)    Not Support Free
        // MS(MPF paper Size)    25h: B4 |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x25;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_B5:

        if (pOEM->jMPFSetting == MPF_B5) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Ch: B5 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2C;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A5:

        if (pOEM->jMPFSetting == MPF_A5) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Eh: A5 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2E;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_POSTCARD:

        if (pOEM->jMPFSetting == MPF_POSTCARD) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    31h: PostCard |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x31;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_FREE:
        pOEM->jAutoSelect = 0x11;    // MPF

        if(!DRVGETDRIVERSETTING(pdevobj, "Orientation", ajOutput, 
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("LoadPaperSelectCmd(1) Failed\n"));
            bOrientation = 1;
        } else {
            VERBOSE(("Orientation:%s\n", ajOutput));
            if (!strcmp(ajOutput, "PORTRAIT")) {
                bOrientation = 1;
            } else {
                bOrientation = 2;
            }
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     XSize,YSize mm (X[hi],X[lo],Y[hi],Y[lo])
        // MS(MPF paper Size)    FFh: FreePaper |

// 2001/02/27 ->
//      dwTemp = (wPapSizeX * 254) / MASTER_UNIT;                               // 0.1mm a unit
//      wPapLenX = (WORD)((dwTemp + 5) /10);                                    //   1mm a unit, round
        dwTemp = (wPapSizeX * 2540) / MASTER_UNIT;                              // 0.01mm a unit
        wPapLenX = (WORD)((dwTemp + 99) /100);                                  //    1mm a unit, roundup
//      dwTemp = (wPapSizeY * 254) / MASTER_UNIT;                               // 0.1mm a unit
//      wPapLenY = (WORD)((dwTemp + 5) /10);                                    //   1mm a unit, round
        dwTemp = (wPapSizeY * 2540) / MASTER_UNIT;                              // 0.01mm a unit
        wPapLenY = (WORD)((dwTemp + 99) /100);                                  //    1mm a unit, roundup
// 2001/02/27 <-
        if (bOrientation == 1) {
            cmdbuf[wlen++] = HIBYTE(wPapLenX);
            cmdbuf[wlen++] = LOBYTE(wPapLenX);
            cmdbuf[wlen++] = HIBYTE(wPapLenY);
            cmdbuf[wlen++] = LOBYTE(wPapLenY);
        } else {
            cmdbuf[wlen++] = HIBYTE(wPapLenY);
            cmdbuf[wlen++] = LOBYTE(wPapLenY);
            cmdbuf[wlen++] = HIBYTE(wPapLenX);
            cmdbuf[wlen++] = LOBYTE(wPapLenX);
        }
        cmdbuf[wlen++] = 0xFF;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;
    }
}

INT APIENTRY
OEMCommandCallback(
        PDEVOBJ pdevobj,
        DWORD   dwCmdCbID,
        DWORD   dwCount,
        PDWORD  pdwParams)
{
    PMYPDEV pOEM;

    BYTE            cmdbuf[CCHMAXCMDLEN];
    WORD            wlen, i, wRectCmdLen;
    WORD            wDestX, wDestY;
    BYTE            bGrayScale ;
    INT             iRet = 0;
    union _temp {
        DWORD   dwTemp;
        WORD    wTemp;
        BYTE    jTemp;
    } Temp;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

#if 0
#if DBG
{
    int i, max;
    for (i = 0; i < (max = sizeof(MyCallbackID) / sizeof(MyCallbackID[0])); i++) {
        if (MyCallbackID[i].dwID == dwCmdCbID){
            VERBOSE(("%s PARAMS: %d\n", MyCallbackID[i].S, dwCount));
            break;
        }
    }
    if (i == max)
        WARNING(("%d is Invalid ID\n", dwCmdCbID));
}
#endif

#endif

    ASSERT(VALID_PDEVOBJ(pdevobj));

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    wlen = 0;

    //
    // fill in printer commands
    //

    switch (dwCmdCbID) {
        case RES_SENDBLOCK:

            if (pOEM->dwGeneral & FG_COMP){
                Temp.dwTemp = PARAM(pdwParams, 0) + 8;    // 8: Parameter Lengeth (except ImageData)

                // 'c' LN X Y IW IH D
                // ~~~ ~~

                cmdbuf[wlen++] = 'c';
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 24);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 16);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 8);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp);
            } else {

                // 'b' X Y IW IH D
                // ~~~
                cmdbuf[wlen++] = 'b';
            }

            // 'c' LN X Y IW IH D
            //        ~ ~ ~~ ~~
            // 'b' X Y IW IH D
            //     ~ ~ ~~ ~~

            cmdbuf[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMXPosi);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMYPosi);

            cmdbuf[wlen++] = (BYTE)(PARAM(pdwParams, 1) >> 8);
            cmdbuf[wlen++] = (BYTE)PARAM(pdwParams, 1);
            cmdbuf[wlen++] = (BYTE)(PARAM(pdwParams, 2) >> 8);
            cmdbuf[wlen++] = (BYTE)PARAM(pdwParams, 2);

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case RES_SELECTRES_240:

            pOEM->sRes = RATIO_240;

            // ESC i | RT PF AJ PM MF MS PS PO CP OS
            //            ~~ ~~ ~~

            cmdbuf[wlen++] = 0x18;    // 18h -> 24d    Page Format
            cmdbuf[wlen++] = 0x10;    // Not Adjust
            cmdbuf[wlen++] = 0x10;    // cancell Page Marge

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case RES_SELECTRES_400:

            pOEM->sRes = RATIO_400;

            // ESC i | RT PF AJ PM MF MS PS PO CP OS
            //            ~~ ~~ ~~

            cmdbuf[wlen++] = 0x28;    // 28h -> 40d    Page Format
            cmdbuf[wlen++] = 0x10;    // Not Adjust
            cmdbuf[wlen++] = 0x10;    // cancell Page Marge

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case CM_XM_ABS:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.

            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("XMOVEABS:X=%d, Y=%d\n", iRet,
                                      (SHORT)(PARAM(pdwParams, 1) / pOEM->sRes)));

            pOEM->sWMXPosi = (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);

            break;

        case CM_YM_ABS:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            VERBOSE(("YMOVEABS:X=%d, Y=%d\n",
                            (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes), iRet));

            pOEM->sWMYPosi = (SHORT)(PARAM(pdwParams, 1) / pOEM->sRes);
            break;

        case CM_REL_LEFT:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_LEFT:%d\n", iRet));
            VERBOSE(("DestXRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMXPosi -= (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_RIGHT:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_RIGHT:%d\n", iRet));
            VERBOSE(("DestXRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMXPosi += (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_UP:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_UP:%d\n", iRet));
            VERBOSE(("DestYRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMYPosi -= (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_DOWN:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_DOWN:%d\n", iRet));
            VERBOSE(("DestYRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMYPosi += (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_FE_RLE:
            pOEM->dwGeneral |= FG_COMP;
            break;

        case CM_DISABLECOMP:
            pOEM->dwGeneral &= ~FG_COMP;
            break;

        case CSWM_CR:

            pOEM->sWMXPosi = 0;
            break;

        case CSWM_FF:

            pOEM->sWMXPosi = 0;
            pOEM->sWMYPosi = 0;

            cmdbuf[wlen++] = '3';

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case CSWM_LF:

            pOEM->sWMXPosi = 0;
            break;

        case CSWM_COPY:

            Temp.dwTemp = PARAM(pdwParams, 0);
            if (Temp.dwTemp > 255) Temp.dwTemp = 255;    // max
            if (Temp.dwTemp < 1) Temp.dwTemp = 1;        // min

            // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
            //                                     ~~ ~~

            cmdbuf[wlen++] = (BYTE)Temp.dwTemp;    // Copy
            cmdbuf[wlen++] = 0x80;            // character Offset All 0 

            if (pOEM->jModel == MD_CP3800WM) {
                // ESC 'i' 7Eh LG TS SM VS HS

                cmdbuf[wlen++] = 0x1B;
                cmdbuf[wlen++] = 'i';
                cmdbuf[wlen++] = 0x7E;
                cmdbuf[wlen++] = 0x04;                      // LG(command LenGth)
                cmdbuf[wlen++] = pOEM->jTonerSave;    // TS(Toner Save)
                cmdbuf[wlen++] = pOEM->jSmoothing;    // SM(SMoothing) 01h: ON
                cmdbuf[wlen++] = 0xFF;                      // VS(Vertical Shift)
                cmdbuf[wlen++] = 0xFF;                      // HS(Horizontal Shift)
            }

            // Winmode IN
            // ESC 'i' 'z'

            VERBOSE(("Enterning Win-mode\n"));

            pOEM->bWinmode = TRUE;

            cmdbuf[wlen++] = 0x1b;
            cmdbuf[wlen++] = 'i';
            cmdbuf[wlen++] = 'z';

            //Enginge Resolution Setting
            // '1' E

            cmdbuf[wlen++] = '1';
            if (pOEM->sRes == RATIO_400) {
                // 0190h->400d
                cmdbuf[wlen++] = 0x01;
                cmdbuf[wlen++] = 0x90;
            } else {
                // 00F0h->240d
                cmdbuf[wlen++] = 0x00;
                cmdbuf[wlen++] = 0xF0;
            }

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case AUTOFEED:

            // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
            //                               ~~
            // PS(Paper feed Select)

            cmdbuf[wlen++] = pOEM->jAutoSelect;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case PS_LETTER:
        case PS_A3:
        case PS_A4:
        case PS_B4:
        case PS_B5:
        case PS_A5:
        case PS_POSTCARD:
//            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID);
            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID, 0, 0);
            break;

        case PS_FREE:
            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID, 
                               (WORD)PARAM(pdwParams, 0), (WORD)PARAM(pdwParams, 1));
            break;

        case PRN_3250GTWM:

            VERBOSE(("CmdStartJob - CP3250GT\n"));

            pOEM->jModel = MD_CP3250GTWM;
            pOEM->dwGeneral &= ~FG_HAS_TSAVE;
            pOEM->dwGeneral &= ~FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case PRN_3500GTWM:

            VERBOSE(("CmdStartJob - CP-3500GT\n"));

            pOEM->jModel = MD_CP3500GTWM;
            pOEM->dwGeneral &= ~FG_HAS_TSAVE;
            pOEM->dwGeneral &= ~FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case PRN_3800WM:

            VERBOSE(("CmdStartJob - CP-3800\n"));

            pOEM->jModel = MD_CP3800WM;
            pOEM->dwGeneral |= FG_HAS_TSAVE;
            pOEM->dwGeneral |= FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case SBYTE:
            pOEM->dwGeneral &= ~FG_DOUBLE;
            break;

        case DBYTE:
            pOEM->dwGeneral |= FG_DOUBLE;
            break;

//+++ For character attribute switch

        case CM_BOLD_ON:
            pOEM->dwGeneral |= FG_BOLD;
            goto SET_ATTRIB;

        case CM_BOLD_OFF:
            pOEM->dwGeneral &= ~FG_BOLD;
            goto SET_ATTRIB;

        case CM_ITALIC_ON:
            pOEM->dwGeneral |= FG_ITALIC;
            goto SET_ATTRIB;

        case CM_ITALIC_OFF:
            pOEM->dwGeneral &= ~FG_ITALIC;
            goto SET_ATTRIB;

        case CM_WHITE_ON:
            // B CL
            cmdbuf[wlen++] = 'B';
            cmdbuf[wlen++] = 0x01;

            // G OL LW LV FP
            cmdbuf[wlen++] = 'G';
            cmdbuf[wlen++] = 0x00;
            cmdbuf[wlen++] = 0x00;
            cmdbuf[wlen++] = 0x01;
            cmdbuf[wlen++] = 0x01;
            cmdbuf[wlen++] = 0x00;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            pOEM->dwGeneral |= FG_WHITE;
            goto SET_ATTRIB;

        case CM_WHITE_OFF:
            // B CL
            cmdbuf[wlen++] = 'B';
            cmdbuf[wlen++] = 0x00;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            pOEM->dwGeneral &= ~FG_WHITE;
            goto SET_ATTRIB;

SET_ATTRIB: // 'C' As(Attribute Switch)
            if ((  Temp.jTemp = ((BYTE)(pOEM->dwGeneral & (FG_BOLD | FG_ITALIC | FG_WHITE)) ))
                                                                    != pOEM->jPreAttrib) {
                cmdbuf[wlen++] = 'C';
                cmdbuf[wlen++] = Temp.jTemp;

                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

                pOEM->jPreAttrib = Temp.jTemp;
            }
            break;
//---

        case START_DOC:

            VERBOSE(("CmdStartDoc\n"));

        // For Debug
        //*Cmd: "<1B>i|<04>"

            // If status is WINMODE IN, then output WINMODE OUT command
            if (pOEM->bWinmode) {

                VERBOSE(("Leave Win-mode to issue init comands.\n"));
                cmdbuf[wlen++] = '0';    // WINMODE OUT
                pOEM->bWinmode = FALSE;
            }

        /*
         *    The following command(Initialize) is invalid when it is WINMODE.
         *    WINMODE OUT command must be outputed in END_DOC before Initialize.
         *    Initialize(START DOC procsee) command must not be ouputed without END DOC process.
         *    Printer Rom of some version can use 07h command instead of WINMODE OUT.
         *                   ~~~~~~~~~~~~~
         *
         *    07h        WINMODE OUT command when it is Winmode
         *               NOP commnad in except when it is Winmode
         */
//          cmdbuf[wlen++] = 0x07;
            cmdbuf[wlen++] = 0x1B;
            cmdbuf[wlen++] = 'i';
            cmdbuf[wlen++] = '|';
            cmdbuf[wlen++] = 0x04;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case END_DOC:

            VERBOSE(("CmdEndDoc\n"));

            VERBOSE(("Exit Win-mode.\n"));

            pOEM->bWinmode = FALSE;
            cmdbuf[wlen++] = '0';    // WINMODE OUT

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case DRW_WHITE_RECT:
            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x00; //Pattern

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = 0x00; //Pattern //White
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = 0x00; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case DRW_BLACK_RECT:
            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x00; //Pattern

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = 0x01; //Pattern : black
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = 0x00; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case DRW_GRAY_RECT:

            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;
            bGrayScale = (BYTE)((WORD)PARAM(pdwParams, 2) * 255 / 100);

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x02; //GrayScale

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = bGrayScale; //Pattern
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = bGrayScale; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

           break;
        case DRW_RECT_WIDTH :
            pOEM->wRectWidth = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            break;

        case DRW_RECT_HEIGHT:
            pOEM->wRectHeight = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            break;

    }

    return iRet;
}


/*
 *
 * OEMSendFontCmd
 *
 */
VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ        pdevobj,
    PUNIFONTOBJ    pUFObj,
    PFINVOCATION   pFInv)
{
    PGETINFO_STDVAR    pSV;
    DWORD              adwStdVariable[2+2*4];
    DWORD              dwIn, dwOut;
    PBYTE              pubCmd;
    BYTE               aubCmd[128];
    PIFIMETRICS        pIFI;
    DWORD              dwHeight, dwWidth;
    PMYPDEV pOEM;
    BYTE               Cmd[128];
    WORD               wlen;
    DWORD              dwNeeded;

    VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI =   pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + (sizeof(DWORD) + sizeof(LONG)) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->dwGeneral |= FG_DOUBLE;
    else
        pOEM->dwGeneral &= ~FG_DOUBLE;

    pOEM->dwGeneral &=  ~FG_BOLD;
    pOEM->dwGeneral &=  ~FG_ITALIC;

    dwOut = 0;
    // 'L' CT
    // CT(Character Table)
    aubCmd[dwOut++] = 'L';

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName)) {
        pOEM->dwGeneral |= FG_VERT;
        aubCmd[dwOut++] = 0x01;
        aubCmd[dwOut++] = 'A';
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 0x5A;
        pOEM->dwGeneral |= FG_VERT_ROT;
    } else {
        pOEM->dwGeneral &= ~FG_VERT;
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 'A';
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 0x00;
        pOEM->dwGeneral &= ~FG_VERT_ROT;
    }
//  if (pIFI->jWinPitchAndFamily & 0x01)
    if (pIFI->jWinPitchAndFamily & FIXED_PITCH)
        pOEM->dwGeneral |= FG_PROP;
    else
        pOEM->dwGeneral &= ~FG_PROP;

//  pOEM->dwGeneral &= ~FG_DBCS;

    for ( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {

            dwHeight = pSV->StdVar[0].lStdVariable / pOEM->sRes;

            if (dwHeight < 16) dwHeight = 8;
            if (dwHeight > 2560) dwHeight = 2560;

            aubCmd[dwOut++] = (BYTE)(dwHeight >> 8);
            aubCmd[dwOut++] = (BYTE)dwHeight;
            VERBOSE(("Height=%d\n", dwHeight));
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'W') {
            if (pubCmd[dwIn+2] == 'S') {

                dwWidth = pSV->StdVar[1].lStdVariable / pOEM->sRes;

                if (dwWidth < 8) dwWidth = 8;
                if (dwWidth > 1280) dwWidth = 1280;

                aubCmd[dwOut++] = (BYTE)(dwWidth >> 8);
                aubCmd[dwOut++] = (BYTE)dwWidth;
                dwIn += 3;
            } else if (pubCmd[dwIn+2] == 'D') {

                dwWidth = (pSV->StdVar[1].lStdVariable / pOEM->sRes) * 2;

                if (dwWidth < 8) dwWidth = 8;
                if (dwWidth > 1280) dwWidth = 1280;

                aubCmd[dwOut++] = (BYTE)(dwWidth >> 8);
                aubCmd[dwOut++] = (BYTE)dwWidth;
                dwIn += 3;
            }
            VERBOSE(("Width=%d\n", dwWidth));
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

}



/*
 *
 * OEMOutputCharStr
 *
 */

#if 0 // >>> Change UFM File(JIS->SJIS) >>>
void jis2sjis(BYTE jJisCode[], BYTE jSjisCode[])
{
    BYTE jTmpM, jTmpL;

    jTmpM = jJisCode[0];
    jTmpL = jJisCode[1];

    if (jTmpM % 2)
        jTmpM++;
    else
        jTmpL += 0x5E;

    jTmpM = jTmpM/2 + 0x70;
    jTmpL += 0x1F;

    if (jTmpM > 0x9F) jTmpM += 0x40;
    if (jTmpL > 0x7E) jTmpL++;

    jSjisCode[0] = jTmpM;
    jSjisCode[1] = jTmpL;
}
#endif // <<< Change UFM File(JIS->SJIS) <<<

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING  GStr;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE                 aubBuff[1024];
    PBYTE                aubBuff;
    PTRANSDATA           pTrans;
    PDWORD               pdwGlyphID;
    PWORD                pwUnicode;
    DWORD                dwI;
    DWORD                dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS          pIFI;

    BYTE                 Cmd[256];

    WORD                 wlen;
#if 0 // >>> Change UFM File(JIS->SJIS) >>>
    BYTE                 ajConvertOut[2];
#endif // <<< Change UFM File(JIS->SJIS) <<<
    PGETINFO_STDVAR      pSV;
    DWORD                adwStdVariable[2+2*2];
    SHORT                sCP, sCP_Double, sCP_Vert;

    BYTE                 jTmp;
    LONG                 lFontHeight, lFontWidth;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    VERBOSE(("OEMOutputCharStr() entry.\n"));

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + (sizeof(DWORD) + sizeof(LONG)) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    lFontHeight = pSV->StdVar[0].lStdVariable / pOEM->sRes;
    lFontWidth  = pSV->StdVar[1].lStdVariable / pOEM->sRes;

// ---

    sCP = (SHORT)lFontWidth;
    sCP_Double = sCP * 2;
    sCP_Vert = (SHORT)lFontHeight;

    switch (dwType){
        case TYPE_GLYPHHANDLE:

            //
            // Call the Unidriver service routine to convert
            // glyph-handles into the character code data.
            //

// #333653: Change I/F for GETINFO_GLYPHSTRING
                GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
                GStr.dwCount   = dwCount;
                GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
                GStr.pGlyphIn  = pGlyph;
                GStr.dwTypeOut = TYPE_TRANSDATA;
                GStr.pGlyphOut = NULL;
                GStr.dwGlyphOutSize = 0;

                // pGlyph = (PVOID)((HGLYPH *)pGlyph + GStr.dwCount);

                VERBOSE(("Character Count = %d\n", GStr.dwCount));

                if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize) {
                    ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                    return;
                }

                if ((aubBuff = (PBYTE)MemAlloc(GStr.dwGlyphOutSize)) == NULL) {
                    ERR(("UNIFONTOBJ_GetInfo:MemAlloc failed.\n"));
                    return;
                }

                GStr.pGlyphOut = aubBuff;

                if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, GStr.dwSize, &dwNeeded)){
                    ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                    MemFree(aubBuff);
                    return;
                }

                pTrans = (PTRANSDATA)aubBuff;

            while (dwCount) {
                if (dwCount > MAX_STRLEN) {
                    GStr.dwCount = MAX_STRLEN;
                    dwCount -= MAX_STRLEN;
                } else {
                    GStr.dwCount = dwCount;
                    dwCount = 0;
                }

                wlen = 0;
                for (dwI = 0; dwI < GStr.dwCount; dwI++, pTrans++){
//                  VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n", pTrans->ubCodePageID));
//                  VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n", pTrans->ubType));

                    switch (pTrans->ubType & MTYPE_FORMAT_MASK){
                        case MTYPE_DIRECT: 
//                          VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n", pTrans->uCode.ubCode));

                            if (dwI == 0){

                                if('O' == *((LPSTR)pIFI+pIFI->dpwszFaceName)) {
                                    // OCR
                                    VERBOSE(("OCR\n"));
                                    if (GStr.dwCount > 1)
                                        Cmd[wlen++] = 'W';
                                    else
                                        Cmd[wlen++] = 'U';
                                } else {
                                    VERBOSE(("PICA\n"));
                                    if (GStr.dwCount > 1)
                                        Cmd[wlen++] = 'O';
                                    else
                                        Cmd[wlen++] = 'M';
                                }

                                Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;

                                if (GStr.dwCount > 1) {
                                    Cmd[wlen++] = 0x00;              // Draw Vector
                                    Cmd[wlen++] = (BYTE)(sCP >> 8);  // Character Pitch
                                    Cmd[wlen++] = (BYTE)sCP;
                                    Cmd[wlen++] = (BYTE)GStr.dwCount;
                                }
                            }

                            Cmd[wlen++] = pTrans->uCode.ubCode;

                            pOEM->sWMXPosi += sCP;
                            break;    // MTYPE_DIRECT

                        case MTYPE_PAIRED: 
//                          VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n", *(PWORD)(pTrans->uCode.ubPairs)));

                            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK){

#if 0 // >>> Change UFM File(JIS->SJIS) >>>
      // When JIS CODE
      //   In Case of 1byte character, passed MYTYPE_SINGLE
      //
      // When Shift-JIS CODE
      //   In Case of 1byte character, passed MTYPE_DIRECT

                                case MTYPE_SINGLE: 
                                    if ( (pOEM->dwGeneral & (FG_VERT | FG_VERT_ROT))
                                                                     == (FG_VERT | FG_VERT_ROT) ) {
                                        Cmd[wlen++] = 'A';
                                        Cmd[wlen++] = 0x00;
                                        Cmd[wlen++] = 0x00;
                                        pOEM->dwGeneral &= ~FG_VERT_ROT;
                                    }

                                    if (dwI == 0){
                                        if (GStr.dwCount > 1)
                                            Cmd[wlen++] = 'O';
                                        else
                                            Cmd[wlen++] = 'M';

                                        Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                        Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;

                                        if (GStr.dwCount > 1) {
                                            Cmd[wlen++] = 0x00;              // Draw Vector
                                            Cmd[wlen++] = (BYTE)(sCP >> 8);  // Character Pitch
                                            Cmd[wlen++] = (BYTE)sCP;
                                            Cmd[wlen++] = (BYTE)GStr.dwCount;
                                        }
                                    }

                                    // JIS -> ASCII
                                    switch (pTrans->uCode.ubPairs[0]) {
                                        case 0x21:
                                            if (Cmd[wlen] = jJis2Ascii[0][pTrans->uCode.ubPairs[1] - 0x20])
                                                wlen++;
                                            else    // If 0 (no entry), space
                                                Cmd[wlen++] = 0x20;
                                            break;

                                        case 0x23:
                                            Cmd[wlen++] = pTrans->uCode.ubPairs[1];
                                            break;

                                        case 0x25:
                                            if (Cmd[wlen] = jJis2Ascii[1][pTrans->uCode.ubPairs[1] - 0x20])
                                                wlen++;
                                            else    // If 0 (no entry), space
                                                Cmd[wlen++] = 0x20;
                                            break;

                                        default:    // If 0 (no entry), space
                                            Cmd[wlen++] = 0x20;
                                            break;
                                    }

                                    pOEM->sWMXPosi += sCP;
                                    break;    // MTYPE_SINGLE
#endif // <<< Change UFM File(JIS->SJIS) <<<

                                case MTYPE_DOUBLE:
                                    if( (pOEM->dwGeneral & (FG_VERT | FG_VERT_ROT)) == FG_VERT ) {
                                        Cmd[wlen++] = 'A';
                                        Cmd[wlen++] = 0x00;
                                        Cmd[wlen++] = 0x5A;
                                        pOEM->dwGeneral |= FG_VERT_ROT;
                                    }

                                    if (dwI == 0){
                                        if (GStr.dwCount > 1)
                                            Cmd[wlen++] = 'S';
                                        else
                                            Cmd[wlen++] = 'Q';

                                        Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                        if (pOEM->dwGeneral & FG_VERT) {
                                            Cmd[wlen++] = (BYTE)(
                                                            (pOEM->sWMYPosi + (SHORT)lFontWidth * 2) >> 8);
                                            Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi + (SHORT)lFontWidth * 2);
                                        } else {
                                            Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                            Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;
                                        }

                                        if (GStr.dwCount > 1) {
                                            Cmd[wlen++] = 0x00;                     // Draw Vector
                                            
                                            if (pOEM->dwGeneral & FG_VERT){  // Character Pitch
                                                Cmd[wlen++] = (BYTE)(sCP_Double >> 8);
                                                Cmd[wlen++] = (BYTE)sCP_Double;
                                            } else {
                                                Cmd[wlen++] = (BYTE)(sCP_Vert >> 8);
                                                Cmd[wlen++] = (BYTE)sCP_Vert;
                                            }

                                            Cmd[wlen++] = (BYTE)GStr.dwCount;
                                        }
                                    }

#if 0 // Change UFM File(JIS->SJIS)
                                    jis2sjis(pTrans->uCode.ubPairs, ajConvertOut);
                                    Cmd[wlen++] = ajConvertOut[0];
                                    Cmd[wlen++] = ajConvertOut[1];
#else
                                    Cmd[wlen++] = pTrans->uCode.ubPairs[0];
                                    Cmd[wlen++] = pTrans->uCode.ubPairs[1];
#endif
//                                  VERBOSE(("AfterConvert: %x%x\n",
//                                                                 ajConvertOut[0], ajConvertOut[1]));
                                    if (pOEM->dwGeneral & FG_VERT)
                                        pOEM->sWMXPosi += sCP_Double;
                                    else
                                        pOEM->sWMXPosi += sCP_Vert;

                                    break;    // MTYPE_DOUBLE
                            }

                            break;    // MTYPE_PAIRED
                    }
                    WRITESPOOLBUF(pdevobj, Cmd, wlen);
                    wlen = 0;

                }     // for
            }         // while
// #333653: Change I/F for GETINFO_GLYPHSTRING
            MemFree(aubBuff);
            break;    // TYPE_GLYPHHANDLE

#if 0
        case TYPE_GLYPHID:

            for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++){
                ERR(("TYEP_GLYPHID:0x%x\n", *(PDWORD)pGlyph));
            }
            break;
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\mydbg.h ===
#if DBG
#ifndef MYDBG_H_INCLUDED
#define MYDBG_H_INCLUDED


typedef struct _tblCallbackID {
    char*   S;
    DWORD   dwID;
} tblCallbackID;

static tblCallbackID MyCallbackID[] = {
    {"RES_SENDBLOCK",           12},
    {"RES_SELECTRES_240",       14},
    {"RES_SELECTRES_400",       15},
    {"CM_XM_ABS",               20},
    {"CM_YM_ABS",               22},
    {"CM_REL_LEFT",             24},
    {"CM_REL_RIGHT",            25},
    {"CM_REL_UP",               26},
    {"CM_REL_DOWN",             27},
    {"CM_FE_RLE",               30},
    {"CM_DISABLECOMP",          31},
    {"CSWM_CR",                 40},
    {"CSWM_COPY",               45},
    {"CSWM_FF",                 47},
    {"CSWM_LF",                 48},
    {"AUTOFEED",                49},
    {"PS_A3",                   60},
    {"PS_B4",                   61},
    {"PS_A4",                   62},
    {"PS_B5",                   63},
    {"PS_LETTER",               64},
    {"PS_POSTCARD",             65},
    {"PS_A5",                   66},
    {"PRN_3250GTWM",           109},
    {"PRN_3500GTWM",           110},
    {"PRN_3800WM",             111},
    {"SBYTE",                  120},
    {"DBYTE",                  121},
    {"CM_BOLD_ON",             122},
    {"CM_BOLD_OFF",            123},
    {"CM_ITALIC_ON",           124},
    {"CM_ITALIC_OFF",          125},
    {"CM_WHITE_ON",            126},
    {"CM_WHITE_OFF",           127},
    {"START_DOC",              130},
    {"END_DOC",                131}
};


#endif  // MYDBG_H_INCLUDED
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/
// NTRAID#NTBUG9-588589-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"
#include "strsafe.h"         // Security-Code 2002.3.6

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        //VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            //VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            //VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            //VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        //VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        //VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        //VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        //VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {

        //VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        //VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        //VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        //VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        //VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        //VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        //VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        //VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        //VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        //VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        //VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        //VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\code.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "DCLSRES";

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    dclsres.c

Abstract:

    Implementation of OEMFilterGraphics callback
        

Environment:

    Windows NT Unidrv driver

Revision History:

    22/10/97 -patryan-
        Port code to NT5.0
--*/

#include	<pdev.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'CPWN'      // CASIO Winmode
#define DLLTEXT(s)      "CSWN: " s
#define OEM_VERSION      0x00010000L


#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_CPPL_EXTRADATA {
    OEM_DMEXTRAHEADER    dmExtraHdr;
} CPPL_EXTRADATA, *PCPPL_EXTRADATA;
#define POEMUD_EXTRADATA PCPPL_EXTRADATA
#define OEMUD_EXTRADATA CPPL_EXTRADATA
	    
typedef struct {
    BYTE    jModel;
    DWORD   dwGeneral;
    BYTE    jPreAttrib;
    SHORT   sRes;
    SHORT   sWMXPosi;
    SHORT   sWMYPosi;
    BYTE    jAutoSelect;
    BYTE    jTonerSave;
    BYTE    jSmoothing;
    BYTE    jMPFSetting;
    WORD    wRectWidth;
    WORD    wRectHeight;
    BOOL    bWinmode;
    BOOL bHasTonerSave;
    BOOL bHasSmooth;
} MYPDEV, *PMYPDEV;

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

// Value for sRes
// The ratio MasterUnit to DeviceUnit
#define MASTERUNIT	1200
#define RATIO_240	(MASTERUNIT / 240)
#define RATIO_400	(MASTERUNIT / 400)

// Flags for dwGeneral
//+++ 0x000000xx(1byte) For character attribute switch
#define FG_BOLD         0x00000001
#define FG_ITALIC       0x00000002
#define FG_WHITE        0x00000008
// ---
#define FG_VERT	        0x00000100
#define FG_PROP	        0x00000200
#define FG_DOUBLE       0x00000400
#define FG_UNDERLINE	0x00000800
#define FG_STRIKETHRU	0x00001000
#define FG_COMP	        0x00010000
#define FG_VERT_ROT     0x00020000

#define FG_HAS_TSAVE    0x01000000
#define FG_HAS_SMOTH    0x02000000

// Value for byTonerSave
#define VAL_TS_NORMAL			0x00
#define VAL_TS_LV1				0x01
#define VAL_TS_LV2				0x02
#define VAL_TS_LV3				0x03
#define VAL_TS_NOTSELECT		0xFF

// Value for bySmoothing
#define VAL_SMOOTH_OFF			0x00
#define VAL_SMOOTH_ON			0x01
#define VAL_SMOOTH_NOTSELECT	0xFF

// Value for byMPFSetting
#define MPF_NOSET		0x00
#define MPF_A3			0x01
#define MPF_B4			0x02
#define MPF_A4			0x03
#define MPF_B5			0x04
#define MPF_LETTER		0x05
#define MPF_POSTCARD	0x06
#define MPF_A5			0x07



extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\cswinres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=cswinres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),cswinres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\cswinres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\cswinres.c

MISCFILES=\
    $(SRCDIR)\cswinres.ini \
    $(GPDDIR)\cscp32wj.gpd \
    $(GPDDIR)\cscp35wj.gpd \
    $(GPDDIR)\cscp38wj.gpd \
    $(GPDDIR)\cscp39wj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

//    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
//        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
//        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


//
// Functions for outputting debug messages
//

// VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
// {
//    va_list ap;
//
//    va_start(ap, pstrFormat);
//    EngDebugPrint("", (PCHAR) pstrFormat, ap);
//    va_end(ap);
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include "code.c"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "comoem.h"



///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////
//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

// Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return E_FAIL;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return E_FAIL;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {
            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/
{
    DWORD dwResult;
    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));

    BYTE  *lpSrc, *lpTgt;
    static BYTE  localBuf[1300];
    int  i,j, bytesRem,  nBytes;
    static  BYTE  Blk1[256] = {0};
    static  BYTE  Blk4[256] = {0};
    static  BYTE  Blk2Byt1[256] = {0};
    static  BYTE  Blk2Byt2[256] = {0};
    static  BYTE  Blk3Byt1[256] = {0};
    static  BYTE  Blk3Byt2[256] = {0};
    static  BYTE  BindBlk2[4][16] = {0};
    static  BYTE  BindBlk3[16][4] = {0};

    if (!Blk1[1])      //  need to initialize tables
       {
	   for(i = 0 ; i < 256 ; i++)
	   {
	       BYTE  rot;

	       //First Block , one byte only 123456XX to  00654321
	       rot = (BYTE)i;
	       Blk1[i]     = 0x10 & (rot <<=1);
	       Blk1[i]    |= 0x20 & (rot <<=2);
	       rot = (BYTE)i;
	       Blk1[i]    |= 0x08 & (rot >>=1);
	       Blk1[i]    |= 0x04 & (rot >>=2);
	       Blk1[i]    |= 0x02 & (rot >>=2);
	       Blk1[i]    |= 0x01 & (rot >>=2);
	       Blk1[i]     = Blk1[i]  + 0x3F;
	
	       //Second Block first byte  XXXXXX12 to 00000021
	       Blk2Byt1[i]  = 0x01 & (i >>1);
	       Blk2Byt1[i] |= 0x02 & (i <<1);   // i byte
	
	       //Second Block second byte  3456XXXX to 00006543
	       rot = (BYTE)i;
	       Blk2Byt2[i]  = 0x08 & (rot >>=1);
	       Blk2Byt2[i] |= 0x04 & (rot >>=2);
	       Blk2Byt2[i] |= 0x02 & (rot >>=2);
	       Blk2Byt2[i] |= 0x01 & (rot >>=2);   // j byte

	       //Third Block First byte  XXXX1234 to 00004321
	       rot =(BYTE)i;
	       Blk3Byt1[i]  = 0x02 & (rot >>=1);
	       Blk3Byt1[i] |= 0x01 & (rot >>=2);
	       rot = (BYTE)i;
	       Blk3Byt1[i] |= 0x04 & (rot <<=1);
	       Blk3Byt1[i] |= 0x08 & (rot <<=2);   //j byte

	       //Third Block Second byte  56XXXXXX to 00000065
	       rot = (BYTE)i;
	       Blk3Byt2[i]  = 0x02 & (rot >>=5);
	       Blk3Byt2[i] |= 0x01 & (rot >>=2);   //i byte
	
	       //Fourth Block, only byte  XX123456 to 00654321
	       rot = (BYTE)i;
	       Blk4[i]   = 0x08 & (rot <<=1);
	       Blk4[i]  |= 0x10 & (rot <<=2);
	       Blk4[i]  |= 0x20 & (rot <<=2);
	       rot = (BYTE)i;
	       Blk4[i]  |= 0x04 & (rot >>=1);
	       Blk4[i]  |= 0x02 & (rot >>=2);
	       Blk4[i]  |= 0x01 & (rot >>=2);
	       Blk4[i]   = Blk4[i]  + 0x3F;


	   }
	   for(i = 0 ; i < 4 ; i++)
	       for(j = 0 ; j < 16 ; j++)
	       {
		   // Bind 00000021 & 00006543  & add 3F
		   BindBlk2[i][j] = ( (j<< 2 ) | i) + 0x3F;
		   // Bind 00004321 & 00000065  & add 3F
		   BindBlk3[j][i] = ( (i<< 4 ) | j) + 0x3F;
	       }
       }

    bytesRem = dwLen;		
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = Blk1[*lpSrc];
	    lpSrc +=3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);

    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = BindBlk2[ Blk2Byt1[ *lpSrc] ][ Blk2Byt2[ *(lpSrc +1)] ];
	    lpSrc +=3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return

    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);
    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = BindBlk3[ Blk3Byt1[ *(lpSrc+1) ] ][ Blk3Byt2[ *(lpSrc +2)] ];
	    lpSrc +=3;
       }
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);

    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = Blk4[ *(lpSrc+2) ];
	    lpSrc += 3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }

    // End of final block send line feed  & End Block command
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x9C", 2, &dwResult);

    return  100;                /* Value not used AT PRESENT! */


    if (SUCCEEDED(FilterGraphics( pdevobj,  pBuf,  dwLen)))
        return S_OK;
    else
        return E_FAIL;
}

BOOL
CompressIt(
PDEVOBJ  pdevobj,
PBYTE  ExpBuf,
int   ExpLen,
IPrintOemDriverUni* pOEMHelp)
{
	static BYTE  CompBuf[1200]; //Max size before Compression is 1024
	BYTE  *lpSrc, *lpTgt;
	int InCompMode =0, count=0,i,FormatLen;
	BYTE FormatBuf[10];
	BYTE *pFormat;
	lpSrc = ExpBuf;
	lpTgt = CompBuf;
	DWORD dwResult;

	for (i=0; i < ExpLen; i++,lpSrc++)
	{
	    if ( *lpSrc != *(lpSrc +1))
	    {
            if (!InCompMode)
                *lpTgt++ = *lpSrc;
            else
            {
                InCompMode = 0;
                //Send the repeat char sequence - !#X
                pFormat = FormatBuf;
		FormatLen = sprintf((char *)pFormat,"!%d%c",count,*lpSrc);
                pOEMHelp->DrvWriteSpoolBuf(pdevobj, FormatBuf,FormatLen,&dwResult);
            }
	    }
	    else
	    {
            if (!InCompMode)
            {
                 InCompMode =1;
                 count =2;
                 pOEMHelp->DrvWriteSpoolBuf(pdevobj, CompBuf, (DWORD)(lpTgt - CompBuf), &dwResult);
                 lpTgt = CompBuf;
            }
            else
                 count++;
	     }
	}
	if (!InCompMode)
	     pOEMHelp->DrvWriteSpoolBuf(pdevobj, CompBuf, (DWORD)(lpTgt - CompBuf), &dwResult);
	else
	{
	     //Send the repeat char sequence - !#X
	     pFormat = FormatBuf;
	     FormatLen  = sprintf((char *)pFormat,"!%d%c",count-1,*lpSrc); 	
	     pOEMHelp->DrvWriteSpoolBuf(pdevobj, FormatBuf,FormatLen, &dwResult);
	}
 	return TRUE;

}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}

STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/


#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for Declasers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'DCLS'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("DCLSRES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H


#include <lib.h>

#include <PRINTOEM.H>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


#if 0
////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#endif // 0

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
// VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\dclsres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns E_FAIL if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() ;

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

// Prototype
BOOL CompressIt(PDEVOBJ, PBYTE, int, IPrintOemDriverUni* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

		98/9/3 v-yutah:
		Because of suggestion from ganeshp,
			Modified PublishDriverInterface(), and related to it,
			Modified EnableDriver(), DisableDriver()
		
        03/11/02 v-satois
        For security issues, addition null-checking of pointer.

--*/

// NTRAID#NTBUG9-588572-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        
        if (ppv == NULL) // Checking null-pointer.
        {
            return E_NOINTERFACE;
        }
        
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
 
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to return S_OK so that DisableDriver() will be called, which Releases
		// the reference to the Printer Driver's interface.
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Release reference to Printer Driver's interface.
		if (this->pOEMHelp)
		{
			this->pOEMHelp->Release();
			this->pOEMHelp = NULL;
		}
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        PDEVOEM pTemp;

        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        if (pDevOem == NULL) // Checking null-pointer.
        {
            return E_FAIL;
        }

        if ((pTemp = OEMEnablePDEV(pdevobj, pPrinterName,
                cPatterns, phsurfPatterns, cjGdiInfo,
                pGdiInfo, cjDevInfo, pDevInfo, pded))) {
            *pDevOem = pTemp;
            return S_OK;
        }
        return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
        
#if	1	// Suggested by ganeshp
		// Need to store pointer to Driver Helper functions, if we already haven't.
		if (this->pOEMHelp == NULL)
		{
			HRESULT hResult;
			// Get Interface to Helper Functions.
			
			if (pIUnknown == NULL) // Checking null-pointer.
			{
				return E_FAIL;
			}
			
			hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));
			if(!SUCCEEDED(hResult))
			{
				// Make sure that interface pointer reflects interface query failure.
				this->pOEMHelp = NULL;
				return E_FAIL;
			}
		}
		return S_OK;
#else	// Suggested by ganeshp
        if (this->pOEMHelp == NULL)
        {
            if (pIUnknown == NULL) // Checking null-pointer.
            {
                return E_FAIL;
            }
            
            pIUnknown->AddRef();
        }
        this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        INT retv;

        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        if (piResult == NULL) // Checking null-pointer.
        {
            return E_FAIL;
        }

        // Checking the return value.
        retv = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);
        if (retv < 0)
        {
            *piResult = 0;
            return E_FAIL;
        }
        else
        {
            *piResult = retv;
        }

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
    
        if (pdwResult == NULL) // Checking null-pointer.
        {
            return E_FAIL;
        }
    
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (pdwResult == NULL) // Checking null-pointer.
        {
            return E_FAIL;
        }

        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        if (pdwResult == NULL) // Checking null-pointer.
        {
            return E_FAIL;
        }

        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if (ppv == NULL) // Checking null-pointer.
        {
            return E_NOINTERFACE;
        }

        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\eprcid.h ===
// please keep consistency between GPDCMN.GPD with this file

// Font Resource (UFM)
#define	RC_FONT_ROMAN		1
#define RC_FONT_SANSRF		2
#define RC_FONT_COURIER		3
#define RC_FONT_COURIERI	4
#define RC_FONT_COURIERB	5
#define RC_FONT_COURIERZ	6
#define RC_FONT_SYMBOL		7
#define RC_FONT_SYMBOLIC	8
#define RC_FONT_DUTCH		33
#define RC_FONT_DUTCHI		34
#define RC_FONT_DUTCHB		35
#define RC_FONT_DUTCHZ		36
#define RC_FONT_SWISS		37
#define RC_FONT_SWISSI		38
#define RC_FONT_SWISSB		39
#define RC_FONT_SWISSZ		40
#define RC_FONT_MOREWB		43

// Font Resource (UFM):Japanese
#define RC_FONT_MINCHO		52
#define RC_FONT_MINCHOV		53
#define RC_FONT_KGOTHIC		54
#define RC_FONT_KGOTHICV	55
#define RC_FONT_MGOTHIC		56
#define RC_FONT_MGOTHICV	57
#define RC_FONT_KYOUKA		58
#define RC_FONT_KYOUKAV		59
#define RC_FONT_SHOUKAI		60
#define RC_FONT_SHOUKAIV	61
#define RC_FONT_MOUHITSU	62
#define RC_FONT_MOUHITSV	63
#define RC_FONT_FMINB		64
#define RC_FONT_FMINBV		65
#define RC_FONT_FGOB		66
#define RC_FONT_FGOBV		67
#define RC_FONT_FMGOT		68
#define RC_FONT_FMGOTV		69

// Font Resource (UFM):ChineseT
#define RC_FONT_SUNGC		70
#define RC_FONT_SUNGCV		71
#define RC_FONT_SUNGCL		72
#define RC_FONT_SUNGCLV		73
#define RC_FONT_SUNGCB		74
#define RC_FONT_SUNGCBV		75
#define RC_FONT_KAIC		76
#define RC_FONT_KAICV		77
#define RC_FONT_KAICL		78
#define RC_FONT_KAICLV		79
#define RC_FONT_KAICB		80
#define RC_FONT_KAICBV		81
#define RC_FONT_YUANGC		82
#define RC_FONT_YUANGCV		83
#define RC_FONT_YUANGCL		84
#define RC_FONT_YUANGCLV	85
#define RC_FONT_YUANGCB		86
#define RC_FONT_YUANGCBV	87
#define RC_FONT_HEIC		88
#define RC_FONT_HEICV		89
#define RC_FONT_HEICL		90
#define RC_FONT_HEICLV		91
#define RC_FONT_HEICB		92
#define RC_FONT_HEICBV		93
#define RC_FONT_LIC			94
#define RC_FONT_LICV		95
#define RC_FONT_FSUNGC		96
#define RC_FONT_FSUNGCV		97
#define RC_FONT_FSUNGCL		98
#define RC_FONT_FSUNGCLV	99
#define RC_FONT_FSUNGCB		100
#define RC_FONT_FSUNGCBV	101
#define RC_FONT_SHINGC		102
#define RC_FONT_SHINGCV		103
#define RC_FONT_SHINYIC		104
#define RC_FONT_SHINYICV	105

// Font Resource (UFM):ChineseS
#define RC_FONT_SONGK		106
#define RC_FONT_SONGKV		107
#define RC_FONT_HEIK		108
#define RC_FONT_HEIKV		109
#define RC_FONT_KAIK		110
#define RC_FONT_KAIKV		111
#define RC_FONT_FSONGK		112
#define RC_FONT_FSONGKV		113

// Font Resource (UFM):Korean
#define RC_FONT_MYUNGH		114
#define RC_FONT_MYUNGHV		115
#define RC_FONT_MYUNGHB		116
#define RC_FONT_MYUNGHBV	117
#define RC_FONT_GOTHIH		118
#define RC_FONT_GOTHIHV		119
#define RC_FONT_GOTHIHB		120
#define RC_FONT_GOTHIHBV	121
#define RC_FONT_DINARH		122
#define RC_FONT_DINARHV		123
#define RC_FONT_DINARHB		124
#define RC_FONT_DINARHBV	125
#define RC_FONT_GUNGH		126
#define RC_FONT_GUNGHV		127
#define RC_FONT_GUNGHB		128
#define RC_FONT_GUNGHBV		129
#define RC_FONT_SAMMUH		130
#define RC_FONT_SAMMUHV		131
#define RC_FONT_SAMMUHB		132
#define RC_FONT_SAMMUHBV	133
#define RC_FONT_PILGIH		134
#define RC_FONT_PILGIHV		135
#define RC_FONT_PILGIHB		136
#define RC_FONT_PILGIHBV	137
#define RC_FONT_YETCHH		138
#define RC_FONT_YETCHHV		139
#define RC_FONT_YETCHHB		140
#define RC_FONT_YETCHHBV	141

// TTFS:Latin; valid only when optional fonts(Swiss721, etc.) provided
#define RC_TTF_ARIAL		150
#define RC_DF_SWISS721		151
#define RC_TTF_COURIERNEW	152
#define RC_DF_COURIER		153
#define RC_TTF_SYMBOL		154
#define RC_DF_SYMBOLIC		156
#define RC_TTF_TIMESNR		157
#define RC_DF_DUTCH801		158
#define RC_TTF_WINGDINGS	159
#define RC_DF_MOREWINGBATS	160

// TTFS:Japanese
#define RC_TTF_MSMINCHO		180
#define RC_DF_MINCHO		181
#define RC_TTF_MSMINCHOV	182
#define RC_DF_MINCHOV		183
#define RC_TTF_MSGOTHIC		184
#define RC_DF_GOTHIC		185
#define RC_TTF_MSGOTHICV	186
#define RC_DF_GOTHICV		187

// TTFS:Japanese in English
#define RC_TTF_MSMINCHO_E   190
#define RC_TTF_MSMINCHOV_E  191
#define RC_TTF_MSGOTHIC_E   192
#define RC_TTF_MSGOTHICV_E  193

//@TTFS:ChineseT
#define RC_TTF_LMING		200
#define RC_DF_SUNGCL		201
#define RC_TTF_LMINGV		202
#define RC_DF_SUNGCLV		203

//@TTFS:ChineseT in English
#define RC_TTF_LMING_E		204
#define RC_TTF_LMINGV_E		205

// TTFS:Chinese
#define RC_TTF_SIMSUN		210
#define RC_DF_SONGK			211
#define RC_TTF_SIMSUNV		212
#define RC_DF_SONGKV		213
#define RC_TTF_SIMHEI		214
#define RC_DF_HEIK			215
#define RC_TTF_SIMHEIV		216
#define RC_DF_HEIKV			217

// TTFS:Chinese in English
#define RC_TTF_SIMSUN_E		218
#define RC_TTF_SIMSUNV_E	219
#define RC_TTF_SIMHEI_E		220
#define RC_TTF_SIMHEIV_E	221

// PaperSize
#define RC_STR_HLT			257
#define RC_STR_GLG			258
#define RC_STR_GLT			259
#define RC_STR_F4			260
#define RC_STR_C10			261
#define RC_STR_A3P			262

#define RC_STR_A3W			263
#define RC_STR_IB5			264

// PaperSize:ChineseT
#define RC_STR_8VO			265
#define RC_STR_16MO			266

// PaperSource:Japanese
#define RC_STR_CST			270
#define RC_STR_CST1			271
#define RC_STR_CST2			272
#define RC_STR_CST3			273
#define RC_STR_CST4			274
#define RC_STR_TRAY			275
#define RC_STR_MMFDR		276
#define RC_STR_LCST			277
#define RC_STR_AUTOCHG		278
#define RC_STR_FTRAY		279
#define RC_STR_AUTOSEL		280

#define RC_STR_MPTRAY		281

// FontCartridgeName:Japanese
#define RC_STR_MARUGOT		290
#define RC_STR_KYOKASHO		291
#define RC_STR_KAISHO		292
#define RC_STR_GYOSHO		293
#define RC_STR_FMINFKGOT	294
#define RC_STR_FMARUGOT		295

// FontCartridgeName:ChineseT
#define RC_STR_FSSSY		296
#define RC_STR_LI			297
#define RC_STR_FANSUNG		298
#define RC_STR_SHING		299

// FontCartridgeName:Korean
#define RC_STR_PLYTCH		300

// Custom Features
#define RC_STR_THICK		323
#define RC_STR_THICK_N		324
#define RC_STR_THIN			325
#define RC_STR_RECTFILL		385
#define RC_STR_ENABLED		386
#define RC_STR_DISABLED		387
#define RC_STR_OPTION_ON	388
#define RC_STR_OPTION_OFF	389

// Custom Features:Japanese
#define RC_STR_VPADJUST		391

// Custom Feature Duplex
#define RC_STR_DUPLEXUNIT	395
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\epageres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation
COPYRIGHT (C) 1997-1998  SEIKO EPSON CORP.

Module Name:

    epageres.c

Abstract:

    ESC/Page specific font metrics resource
    This file contains code for downloading bitmap TrueType fonts
    on Epson ESC/Page printers.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.
    07/../97 Epson
        Modofied to support ESC/Page
    .....
    02/26/98 Epson
        Font downloading memory usage legal calculation implemented
        TTF download range reduced
        Some cleanups
    03/04/02 Epson v-satois
        Changed "sprintf" to the function, which is defined strsafe.h, for security.
        (For the above purpose, EP_StringCbPrintf_with_int1, EP_StringCbPrintf_with_int2
         EP_StringCbPrintf_with_String are made.)
        Fixed and verified warnings of PREFAST and buffy.pl and MUNGE.EXE.
    03/11/02 Epson v-satois
        For security issues, addition null-checking of pointer.
        OEMSendFontCmd : Addition of checking remaining bytes of "pubCmd".

--*/

#include "pdev.h"

// DEBUG
// #define    DBGMSGBOX    1    // UNDEF:No MsgBox, 1:level=1, 2:level=2
#ifdef    DBGMSGBOX
#include "stdarg.h"
#endif
// DEBUG

//
// ---- M A C R O  D E F I N E ----
//
#define CCHMAXCMDLEN                    128
#define    MAX_GLYPHSTRLEN                    256        // maximum glyph string length can be passed from Unidrv
#define FONT_HEADER_SIZE                0x86    // format type 2

#define    DOWNLOAD_HEADER_MEMUSG            (56 + 256)
#define    DOWNLOAD_HDRTBL_MEMUSG            134
#define    DOWNLOAD_FNTHDR_MEMUSG            32
#define    DOWNLOAD_FONT_MEMUSG(w,h)        (((((DWORD)(w) + 31)/32)*4)*(DWORD)(h))
#define DOWNLOAD_MIN_FONT_ID            512
#define DOWNLOAD_NO_DBCS_OFFSET            1024
#define DOWNLOAD_MIN_FONT_ID_NO_DBCS    (DOWNLOAD_MIN_FONT_ID + DOWNLOAD_NO_DBCS_OFFSET)
#define DOWNLOAD_MIN_GLYPH_ID            32
#define DOWNLOAD_MAX_GLYPH_ID_J            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_C            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_K            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_H            (DOWNLOAD_MIN_GLYPH_ID + 256 - 1)
#define DOWNLOAD_MAX_FONTS                24
#define    DOWNLOAD_MAX_HEIGHT                600        // in 600 dpi

#define MASTER_X_UNIT                    1200
#define MASTER_Y_UNIT                    1200
#define MIN_X_UNIT_DIV                    2        // 600 dpi
#define MIN_Y_UNIT_DIV                    2        // 600 dpi

#define VERT_PRINT_REL_X                125
#define VERT_PRINT_REL_Y                125

// Make acess to the 2 byte character in a RISC portable manner.
// Note we treat the 2 byte data as BIG-endian short ingeger for
// convenience.

#define SWAPW(x) \
    ((WORD)(((WORD)(x) << 8) | ((WORD)(x) >> 8)))
#define GETWORD(p) \
    ((WORD)(((WORD)(*((PBYTE)(p))) << 8) + *((PBYTE)(p) + 1)))
#define PUTWORD(p,w) \
    (*((PBYTE)(p)) = HIBYTE(w), *((PBYTE)(p) + 1) = LOBYTE(w))
#define PUTWORDINDIRECT(p,pw) \
    (*((PBYTE)(p)) = *((PBYTE)(pw) + 1), *((PBYTE)(p) + 1) = *((PBYTE)(pw)))

#define WRITESPOOLBUF(p,s,n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf((p), (s), (n)))

// Internal Locale ID
#define LCID_JPN            0x00000000    // Japan; default
#define LCID_CHT            0x00010000    // Taiwan (ChineseTraditional)
#define LCID_CHS            0x00020000    // PRC (ChineseSimplified)
#define LCID_KOR            0x00030000    // Korea
#define LCID_USA            0x01000000    // US

// OEMCommandCallback callback function ordinal
#define    SET_LCID                    10                // ()
#define    SET_LCID_J                    (10 + LCID_JPN)    // ()
#define    SET_LCID_C                    (10 + LCID_CHT)    // ()
#define    SET_LCID_K                    (10 + LCID_CHS)    // ()
#define    SET_LCID_H                    (10 + LCID_KOR)    // ()
#define    SET_LCID_U                    (10 + LCID_USA)    // ()

#define TEXT_PRN_DIRECTION            20                // (PrintDirInCCDegrees)
#define TEXT_SINGLE_BYTE            21                // (FontBold,FontItalic)
#define TEXT_DOUBLE_BYTE            22                // (FontBold,FontItalic)
#define TEXT_BOLD                    23                // (FontBold)
#define TEXT_ITALIC                    24                // (FontItalic)
#define TEXT_HORIZONTAL                25                // ()
#define TEXT_VERTICAL                26                // ()
#define TEXT_NO_VPADJUST            27                // ()

#define DOWNLOAD_SELECT_FONT_ID        30                // (CurrentFontID)
#define DOWNLOAD_DELETE_FONT        31                // (CurrentFontID)
#define DOWNLOAD_DELETE_ALLFONT        32                // ()
#define DOWNLOAD_SET_FONT_ID        33                // (CurrentFontID)
#define DOWNLOAD_SET_CHAR_CODE        34                // (NextGlyph)

#define EP_FONT_EXPLICITE_ITALIC_FONT   (1 << 0)

//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef struct tagHEIGHTLIST {
    short   id;            // DWORD aligned for access optimization
    WORD    Height;
    WORD    fGeneral;    // DWORD aligned for access optimization
    WORD    Width;
} HEIGHTLIST, *LPHEIGHTLIST;

typedef struct tagEPAGEMDV {
    WORD    fGeneral;
    WORD    wListNum;
    HEIGHTLIST HeightL[DOWNLOAD_MAX_FONTS];
    DWORD    dwTextYRes;
    DWORD    dwTextXRes;
    DWORD    dwLCID;
    DWORD    dwMemAvailable;
    DWORD    dwMaxGlyph;
    DWORD    dwNextGlyph;
    DWORD    flAttribute;           // 2001/3/1     sid. To save italic attribute of some device font.
    int        iParamForFSweF;
    int        iCurrentDLFontID;
    int        iDevCharOffset;
    int        iSBCSX;
    int        iDBCSX;
    int        iSBCSXMove;
    int        iSBCSYMove;
    int        iDBCSXMove;
    int        iDBCSYMove;
    int        iEscapement;
} EPAGEMDV, *LPEPAGEMDV;

// fGeneral flags
#define FLAG_DBCS        0x0001
#define FLAG_VERT        0x0002
#define FLAG_PROP        0x0004
#define FLAG_DOUBLE      0x0008
#define FLAG_VERTPRN     0x0010
#define FLAG_NOVPADJ     0x0020
// DEBUG
#ifdef    DBGMSGBOX
#define    FLAG_SKIPMSG     0x8000
#endif
// DEBUG

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    DWORD CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;  // Line Width
   WORD wEscapement;  // Rotation
   WORD wItalic;  // Slant
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, *LPESCPAGEHEADER;

//
// ----- S T A T I C  D A T A ---
//
const int ESin[4] = { 0, 1, 0, -1 };
const int ECos[4] = { 1, 0, -1, 0 };

const char DLI_DNLD_HDR[]        = "\x1D%d;%ddh{F";
const char DLI_SELECT_FONT_ID[]    = "\x1D%ddcF\x1D" "0;0coP";
const char DLI_DELETE_FONT[]    = "\x1D%dddcF";
const char DLI_FONTNAME[]        = "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d";
const char DLI_SYMBOLSET[]        = "ESC_PAGE_DOWNLOAD_FONT_INDEX";
#define SYMBOLSET_LEN (sizeof(DLI_SYMBOLSET) - 1)    // adjust for terminating NULL
const char DLI_DNLD1CHAR_H[]    = "\x1D%d;";
const char DLI_DNLD1CHAR_P[]    = "%d;";
const char DLI_DNLD1CHAR_F[]    = "%dsc{F";

const char SET_SINGLE_BYTE[]    = "\x1D" "1;0mcF\x1D%d;%dpP";
const char SET_DOUBLE_BYTE[]    = "\x1D" "1;1mcF\x1D%d;%dpP";
const char CHAR_PITCH[]            = "\x1D" "0spF\x1D%d;%dpP";
const char PRNDIR_POSMOV[]        = "\x1D%dpmP";
const char PRN_DIRECTION[]        = "\x1D%droF";
const char SET_CHAR_OFFSET[]    = "\x1D" "0;%dcoP";
const char SET_CHAR_OFFSET_S[]    = "\x1D" "0;%scoP";
const char SET_CHAR_OFFSET_XY[]    = "\x1D%d;%dcoP";
const char SET_VERT_PRINT[]        = "\x1D%dvpC";

const char SET_BOLD[]              = "\x1D%dweF";
const char SET_ITALIC[]            = "\x1D%dslF";
const char SET_ITALIC_SINGLEBYTE[] = "\x1D%dstF";

const char SET_REL_X[]            = "\x1D%dH";
const char SET_REL_Y[]            = "\x1D%dV";

//
// ---- I N T E R N A L  F U N C T I O N  P R O T O T Y P E ----
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS);
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id);
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr, DWORD len);
WORD WConvDBCSCharCode(WORD cc, DWORD LCID);
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj);

// These function are substitutes of "sprintf" for security.
size_t EP_StringCbPrintf_with_int1(char *lpBuff, size_t buff_length, const char *pszFormat, int Arg_int1);
size_t EP_StringCbPrintf_with_int2(char *lpBuff, size_t buff_length, const char *pszFormat,
                                    int Arg_int1, int Arg_int2);
size_t EP_StringCbPrintf_with_String(char *lpBuff, size_t buff_length, const char *pszFormat, char *pArgS);

// DEBUG
#ifdef    DBGMSGBOX
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...);
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon);
#endif
// DEBUG

//
// ---- F U N C T I O N S ----
//
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//
//  Description:  OEM callback for DrvEnablePDEV;
//                  allocate OEM specific memory block
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ. pdevobj->pdevOEM is undefined.
//        pPrinterName    name of the current printer.
//        cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo:
//                        These parameters are identical to what's passed
//                        into DrvEnablePDEV.
//        pded            points to a function table which contains the
//                        system driver's implementation of DDI entrypoints.
//
//  Returns:
//        Pointer to the PDEVOEM
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns, HSURF* phsurfPatterns, ULONG cjGdiInfo, GDIINFO* pGdiInfo, ULONG cjDevInfo, DEVINFO* pDevInfo, DRVENABLEDATA * pded)
{
    LPEPAGEMDV lpEpage;
    if (pGdiInfo == NULL || pdevobj == NULL) // Checking null-pointer.
    {
        return NULL;
    }

    // allocate private data structure
    lpEpage = MemAllocZ(sizeof(EPAGEMDV));
    if (lpEpage)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMEnablePDEV() entry. PDEVOEM = %x, ulAspectX = %d, ulAspectY = %d\r\n"),
//            lpEpage, pGdiInfo->ulAspectX, pGdiInfo->ulAspectX));
        // save text resolution
        lpEpage->dwTextYRes = pGdiInfo->ulAspectY;
        lpEpage->dwTextXRes = pGdiInfo->ulAspectX;
        // save pointer to the data structure
        lpEpage->flAttribute = 0;
        pdevobj->pdevOEM = (PDEVOEM)lpEpage;
    }
    return (PDEVOEM)lpEpage;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//
//  Description:  OEM callback for DrvDisablePDEV;
//                  free all allocated OEM specific memory block(s)
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ.
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    LPEPAGEMDV lpEpage;
    
    if (pdevobj == NULL) // Checking null-pointer.
    {
        return;
    }

    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDisablePDEV() entry. PDEVOEM = %x\r\n"), lpEpage));
    if (lpEpage)
    {
        // free private data structure
        MemFree(lpEpage);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    LPEPAGEMDV lpEpageOld, lpEpageNew;

    if (pdevobjOld == NULL || pdevobjNew == NULL) // Checking null-pointer.
    {
        return FALSE;
    }

    lpEpageOld = (LPEPAGEMDV)pdevobjOld->pdevOEM;
    lpEpageNew = (LPEPAGEMDV)pdevobjNew->pdevOEM;

    if (lpEpageOld != NULL && lpEpageNew != NULL)
        *lpEpageNew = *lpEpageOld;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//
//  Description:  process Command Callback specified by GPD file
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        dwCmdCbID    CallbackID specified in GPD file
//        dwCount        Parameter count
//        pdwParams    Pointer to the parameters
//
//
//  Returns: 0 : Success,  -1 : Error
//
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

INT APIENTRY OEMCommandCallback(PDEVOBJ pdevobj, DWORD dwCmdCbID, DWORD dwCount, PDWORD pdwParams)
{
    LPEPAGEMDV    lpEpage;
    INT            i;
    size_t         cbCmd;
    int            id;
    int            hlx;
    BYTE        Cmd[256];
//  <buffy.pl, strsafe.h>
    size_t         Cmd_Size = sizeof(Cmd);

    if (pdevobj == NULL) // Checking null-pointer.
    {
        return -1;
    }
    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return -1;
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,%d,%d,) entry.\r\n"), dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    cbCmd = 0;
    switch (dwCmdCbID & 0xFFFF)
    {
    case  SET_LCID: // 10:()
        // set LCID for this job
        lpEpage->dwLCID = dwCmdCbID & 0xFFFF0000;
        break;

    case  TEXT_PRN_DIRECTION: // 20:(PrintDirInCCDegrees)
        if (dwCount >= 1)
        {
            int   iEsc90;

            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_PRN_DIRECTION,%d,[%d]) entry.\r\n"), dwCount, *pdwParams));

            lpEpage->iEscapement = (int)*pdwParams;
            iEsc90 = lpEpage->iEscapement/90;

            cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size, PRNDIR_POSMOV, iEsc90 ? 1 : 0); 

            lpEpage->iSBCSXMove =  lpEpage->iSBCSX * ECos[iEsc90];
            lpEpage->iSBCSYMove = -lpEpage->iSBCSX * ESin[iEsc90];
            if (lpEpage->fGeneral & FLAG_DBCS)
            {
                lpEpage->iDBCSXMove = lpEpage->iDBCSX * ECos[iEsc90];
                lpEpage->iDBCSYMove = -lpEpage->iDBCSX * ESin[iEsc90];
                cbCmd += EP_StringCbPrintf_with_int2(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                 SET_CHAR_OFFSET_XY,
                                 lpEpage->iDevCharOffset * ESin[iEsc90],
                                 lpEpage->iDevCharOffset * ECos[iEsc90]);
            }
            else if (lpEpage->iCurrentDLFontID > 0 && lpEpage->iEscapement)
            {
                WORD wHeight;
                short sXMove, sYMove;
                hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);
                
                if (hlx < 0) // Checking the return value.
                {
                    return -1;
                }

                wHeight = (hlx >= 0) ? lpEpage->HeightL[hlx].Height : 0;
                sXMove = -(short)wHeight * ESin[iEsc90];
                sYMove = -(short)wHeight * ECos[iEsc90];
                cbCmd += EP_StringCbPrintf_with_int2(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                SET_CHAR_OFFSET_XY, (int)sXMove, (int)sYMove);
            }
            else
            {
                cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                SET_CHAR_OFFSET, 0);
            }

            if (!(lpEpage->fGeneral & (FLAG_DBCS | FLAG_PROP)) ||
                ((lpEpage->fGeneral & FLAG_DBCS) &&
                 !(lpEpage->fGeneral & FLAG_DOUBLE)))
            {
                cbCmd += EP_StringCbPrintf_with_int2(&Cmd[cbCmd], Cmd_Size - cbCmd, CHAR_PITCH,
                                 lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);
            }
            else if ((FLAG_DBCS | FLAG_DOUBLE) ==
                     (lpEpage->fGeneral & (FLAG_DBCS | FLAG_DOUBLE)))
            {
                cbCmd += EP_StringCbPrintf_with_int2(&Cmd[cbCmd], Cmd_Size - cbCmd, CHAR_PITCH,
                                 lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);
            }
            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                 PRN_DIRECTION, lpEpage->iEscapement);
        }
        break;

    case TEXT_SINGLE_BYTE: // 21:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_SINGLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = EP_StringCbPrintf_with_int2(Cmd, Cmd_Size, SET_SINGLE_BYTE,
                                lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);

        cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                PRN_DIRECTION, lpEpage->iEscapement);

        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd, SET_VERT_PRINT, 0);
        }
        lpEpage->fGeneral &= ~FLAG_DOUBLE;
        goto SetBoldItalic;

    case TEXT_DOUBLE_BYTE: // 22:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_DOUBLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = EP_StringCbPrintf_with_int2(Cmd, Cmd_Size, SET_DOUBLE_BYTE,
                                lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);

        cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                PRN_DIRECTION, lpEpage->iEscapement);

        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                SET_VERT_PRINT, 1);
        }
        else
        {
            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                SET_VERT_PRINT, 0);
        }
        lpEpage->fGeneral |= FLAG_DOUBLE;
SetBoldItalic:
        if (dwCount >= 2)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Bold = %d, Italic = %d\r\n"), pdwParams[0], pdwParams[1]));
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd, SET_BOLD,
                             pdwParams[0] ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);

            // #517722: PREFAST
            if (!(lpEpage->flAttribute & EP_FONT_EXPLICITE_ITALIC_FONT))
            {
                cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd, SET_ITALIC,
                                 pdwParams[1] ? 346 : 0);
                cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                 SET_ITALIC_SINGLEBYTE, pdwParams[1] ? 1 : 0);
            }
        }
        break;

    case TEXT_BOLD: // 23:(FontBold)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_BOLD,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd, SET_BOLD,
                             (*pdwParams) ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);
        }
        break;

    case TEXT_ITALIC: // 24:(FontItalic)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_ITALIC,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            if (!(lpEpage->flAttribute & EP_FONT_EXPLICITE_ITALIC_FONT)) 
            {
                if (pdwParams == NULL) // Checking null-pointer.
                {
                    return -1;
                }

                cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd, SET_ITALIC,
                                (*pdwParams) ? 346 : 0);
                cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                                SET_ITALIC_SINGLEBYTE, (*pdwParams) ? 1 : 0);
            }
        }
        break;

    case TEXT_HORIZONTAL: // 25:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = Off");
#endif
// DEBUG
        cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size, SET_VERT_PRINT, 0);

        lpEpage->fGeneral &= ~FLAG_VERTPRN;
        break;

    case TEXT_VERTICAL: // 26:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = On");
#endif
// DEBUG
        cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size, SET_VERT_PRINT, 1);

        lpEpage->fGeneral |= FLAG_VERTPRN;
        break;

    case TEXT_NO_VPADJUST:    // 27:()
        lpEpage->fGeneral |= FLAG_NOVPADJ;
        break;

    case DOWNLOAD_SELECT_FONT_ID: // 30:(CurrentFontID)
        if (dwCount >= 1)
        {
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SELECT_FONT_ID:FontID=%d\r\n"), id));
                lpEpage->iCurrentDLFontID = id;
                lpEpage->fGeneral &= ~(FLAG_DBCS | FLAG_VERT | FLAG_DOUBLE);
                if (lpEpage->HeightL[hlx].fGeneral & FLAG_PROP)
                    lpEpage->fGeneral |= FLAG_PROP;
                else
                    lpEpage->fGeneral &= ~FLAG_PROP;
                lpEpage->iParamForFSweF = 0;
                lpEpage->iSBCSX = lpEpage->HeightL[hlx].Width;
                lpEpage->iDBCSX = 0;
                cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size,
                                DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);
            }
            else // Checking the return value.
            {
                return -1;
            }
        }
        break;

    case DOWNLOAD_DELETE_FONT:    // 31:(CurrentFontID)
        if (dwCount >= 1)
        {
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
                // set up font delete command
                cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size,
                                DLI_DELETE_FONT, id - DOWNLOAD_MIN_FONT_ID);

                // move HeightList table contents
                for (i = hlx; i + 1 < lpEpage->wListNum; i++)
                {
                    lpEpage->HeightL[i].id = lpEpage->HeightL[i + 1].id;
                    lpEpage->HeightL[i].fGeneral = lpEpage->HeightL[i + 1].fGeneral;
                    lpEpage->HeightL[i].Height = lpEpage->HeightL[i + 1].Height;
                    lpEpage->HeightL[i].Width = lpEpage->HeightL[i + 1].Width;
                }
                // decrease the total number
                lpEpage->wListNum--;
            }
            else // Checking the return value.
            {
                return -1;
            }
        }
        break;

    case DOWNLOAD_DELETE_ALLFONT: // 32:()
        for (i = 0; i < (int)lpEpage->wListNum ; i++)
        {
            cbCmd += EP_StringCbPrintf_with_int1(&Cmd[cbCmd], Cmd_Size - cbCmd,
                            DLI_DELETE_FONT, (WORD)lpEpage->HeightL[i].id - DOWNLOAD_MIN_FONT_ID);

            lpEpage->HeightL[i].id = 0;
        }
        lpEpage->wListNum = 0;
        break;

    case DOWNLOAD_SET_FONT_ID:        // 33:(CurrentFontID)
        if (dwCount >= 1)
        {
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0 && lpEpage->iCurrentDLFontID != id)
            {    // FontID registered && not active
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_FONT_ID:FontID=%d\r\n"), id));
                cbCmd = EP_StringCbPrintf_with_int1(Cmd, Cmd_Size,
                                DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);

                lpEpage->iParamForFSweF = 0;
                lpEpage->iCurrentDLFontID = id;
            }
            else if (hlx < 0) // Checking the return value.
            {
                return -1;
            }
        }
        break;

    case DOWNLOAD_SET_CHAR_CODE:    // 34:(NextGlyph)
        if (dwCount >= 1)
        {
            if (pdwParams == NULL) // Checking null-pointer.
            {
                return -1;
            }

// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_CHAR_CODE:NextGlyph=%Xh\r\n"), pdwParams[0]));
            // save next glyph
            lpEpage->dwNextGlyph = pdwParams[0];
        }
        break;

    default:
        ERR(("Unexpected OEMCommandCallback(,%d,%d,%.8lX)\r\n", dwCmdCbID, dwCount, pdwParams));
        break;
    }
    if (cbCmd)
    {
        WRITESPOOLBUF(pdevobj, Cmd, cbCmd);
    }
    return 0;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//
//  Description:  download font header of ESC/Page
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//
//  Returns:
//        required amount of memory
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadFontHeader(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    ESCPAGEHEADER FontHeader;
    BYTE Buff[64];  // buffy.pl : Increasing the size of "Buff"(56->64bytes).
    int  iSizeOfBuf;
    LPEPAGEMDV lpEpage;
    PIFIMETRICS pIFI;
    int id;
    int idx;
    BYTE bPS;
    BYTE bDBCS;
    DWORD adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD height, width, dwTemp;
    DWORD MemAvailable;

    if (pdevobj == NULL || pUFObj == NULL) // Checking null-pointer.
    {
        return 0;
    }
    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return 0;
    }
    pIFI = pUFObj->pIFIMetrics;
    if (pIFI == NULL) // Checking null-pointer.
    {
        return 0;
    }
    id = (int)(pUFObj->ulFontID);
    idx = id - DOWNLOAD_MIN_FONT_ID;
    bPS = (BYTE)((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH);
    bDBCS = (BYTE)IS_DBCSCHARSET(pIFI->jWinCharSet);

    // check FontID
    if (idx < 0)
        return 0;    // error for invalid FontID
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
        idx -= DOWNLOAD_NO_DBCS_OFFSET;
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadFontHeader(%S) entry. ulFontID=%d, bPS=%d, bDBCS=%d\r\n"),
//         ((pIFI->dpwszFaceName) ? (LPWSTR)((LPBYTE)pIFI + pIFI->dpwszFaceName) : L"?"), id, bPS, bDBCS));

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return 0;    // error
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));
    // preset character size
    // FontHeight, FontWidth set in Minimum Unit for ESC/Page
    height = pSV->StdVar[0].lStdVariable / MIN_Y_UNIT_DIV;
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;

    // get memory information
    MemAvailable = CheckAvailableMem(lpEpage, pUFObj);
// DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), MemAvailable));
    if (MemAvailable < DOWNLOAD_HEADER_MEMUSG)
    {
        ERR(("Insufficient memory for TTF download.\r\n"));
        return 0;    // error
    }
    // set dwMaxGlyph according to the dwRemainingMemory
    if (bDBCS &&
        ((long)MemAvailable >= 256 * (long)(DOWNLOAD_FNTHDR_MEMUSG +
                                            DOWNLOAD_FONT_MEMUSG(width, height))))
    {
        switch (lpEpage->dwLCID)
        {
        case LCID_JPN:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_J;
            break;
        case LCID_CHS:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_K;
            break;
        case LCID_CHT:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_C;
            break;
        case LCID_KOR:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_H;
            break;
        }
    }
    else
        lpEpage->dwMaxGlyph = 255;

    // fill FontHeader w/ 0 to optimize setting 0s
    ZeroMemory(&FontHeader, sizeof(ESCPAGEHEADER));

    if (bPS)    // VARIABLE_PITCH
        lpEpage->fGeneral |= FLAG_PROP;
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
    if (!BInsertHeightList(lpEpage, id, (WORD)height, (WORD)width, bPS, bDBCS))
    {
        ERR(("Can't register download font.\r\n"));
        return 0;    // error
    }
    lpEpage->iParamForFSweF = 0;
    lpEpage->iSBCSX = width;
    lpEpage->iDBCSX = 0;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(FONT_HEADER_SIZE);
//
// ALWAYS PROPORTINAL SPACING REQUIRED
//
// This resolves the following problems:
//    o    The width of Half-width DBCS fonts are doubled
//    o    Fixed picth fonts are shifted gradually
//
    // proportional spacing
    FontHeader.wCharSpace         = SWAPW(1);
    FontHeader.CharWidth.Integer  = (WORD)SWAPW(0x100);
//OK    FontHeader.CharWidth.Fraction = 0;

    FontHeader.CharHeight.Integer = SWAPW(height);
//OK    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID         = SWAPW(idx + (idx < 0x80 ? 0x80 : 0x00));
//OK    FontHeader.wWeight         = 0;
//OK    FontHeader.wEscapement     = 0;
//OK    FontHeader.wItalic         = 0;
    if (bDBCS)
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0xC000);    // idx + C000h for DBCS
        if (lpEpage->dwLCID == LCID_KOR)
        {
            FontHeader.wFirst        = SWAPW(0xA1A1);
            FontHeader.wLast        = SWAPW(0xA3FE);    // less than or equal to 282 chars
        }
        else
        {
            FontHeader.wFirst        = SWAPW(0x2121);
            FontHeader.wLast        = SWAPW((lpEpage->dwMaxGlyph > 255) ? 0x267E : 0x237E);
        }
    }
    else
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0x4000);    // idx + 4000h for SBCS
        FontHeader.wFirst        = SWAPW(32);
        FontHeader.wLast        = SWAPW(255);
    }
//OK    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
//OK    FontHeader.wOverline       = 0;
//OK    FontHeader.wOverlineWidth  = 0;
//OK    FontHeader.wStrikeOut      = 0;
//OK    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth      = SWAPW(width);
    FontHeader.wCellHeight     = SWAPW(height);
//OK    FontHeader.wCellLeftOffset = 0;
    dwTemp = height * pIFI->fwdWinAscender / (pIFI->fwdWinAscender + pIFI->fwdWinDescender);
    FontHeader.wCellAscender   = SWAPW(dwTemp);
    FontHeader.FixPitchWidth.Integer  = SWAPW(width);
//OK    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeOfBuf = EP_StringCbPrintf_with_int2(Buff, sizeof(Buff),
                                DLI_DNLD_HDR, FONT_HEADER_SIZE, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &FontHeader, sizeof(ESCPAGEHEADER));
    iSizeOfBuf = EP_StringCbPrintf_with_int1(Buff, sizeof(Buff), DLI_FONTNAME, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPBYTE)DLI_SYMBOLSET, SYMBOLSET_LEN);
    iSizeOfBuf = EP_StringCbPrintf_with_int1(Buff, sizeof(Buff), DLI_SELECT_FONT_ID, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    lpEpage->iCurrentDLFontID = id;
    dwTemp = DOWNLOAD_HEADER_MEMUSG;
    // management area required for every 32 header registration
    if ((lpEpage->wListNum & 0x1F) == 0x01)
        dwTemp += DOWNLOAD_HDRTBL_MEMUSG;
    return dwTemp;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//
//  Description:  download character glyph
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        pUFObj        Pointer to the UNIFONTOBJ.
//        hGlyph        Glyph handle to download
//        pdwWidth    Pointer to DWORD width buffer.
//                    Minidirer has to set the width of downloaded glyph data.
//
//  Returns:
//        Necessary amount of memory to download this character glyph in the printer.
//        If returning 0, UNIDRV assumes that this function failed.
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadCharGlyph(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, HGLYPH hGlyph, PDWORD pdwWidth)
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHBITS          *pgb;

    ESCPAGECHAR        ESCPageChar;
    int                iSizeOfBuf;
    int                hlx;
    DWORD            dwSize;
    LPEPAGEMDV        lpEpage;
    BYTE            Buff[32];
    int                id;
    WORD            cp;
    DWORD            CharIncX;
    DWORD            dwMemUsg;
    BYTE            bDBCS;

    if (pdevobj == NULL || pUFObj == NULL) // Checking null-pointer.
    {
        return 0;
    }
    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return 0;
    }
    id = (int)(pUFObj->ulFontID);

    // check FontID
    if (id < DOWNLOAD_MIN_FONT_ID)
        return 0;    // error for invalid FontID
    // validate Download FontID
    hlx = IGetHLIndex(lpEpage, id);
    if (hlx < 0)
    {
        ERR(("Invalid Download FontID(%d).\r\n", id));
        return 0;    // error
    }
    // cache DBCS flag
    bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
    }
    // check GlyphID range
    if (lpEpage->dwNextGlyph > lpEpage->dwMaxGlyph)
    {
        ERR(("No more TTF downloading allowed (GlyphID=%d).\r\n", lpEpage->dwNextGlyph));
        return 0;    // error
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadCharGlyph() entry. ulFontID = %d, hGlyph = %d\r\n"), id, hGlyph));

    //
    // Get the character information.
    //
    // Get Glyph Bitmap
    GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph     = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
        return 0;
    }
    pgb = GBmp.pGlyphData->gdf.pgb;
    
    if (pgb == NULL) // Checking null-pointer.
    {
        return 0;
    }

    // Note that ptqD.{x|y}.HighPart is 28.4 format;
    // i.e. device coord. multiplied by 16.
    CharIncX = (GBmp.pGlyphData->ptqD.x.HighPart + 15) >> 4;
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.x  = %d\n"), pgb->ptlOrigin.x));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.y  = %d\n"), pgb->ptlOrigin.y));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cx = %d\n"), pgb->sizlBitmap.cx));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cy = %d\n"), pgb->sizlBitmap.cy));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.x = %d\n"), CharIncX));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.y = %d\n"), (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4));

    dwMemUsg = DOWNLOAD_FNTHDR_MEMUSG + DOWNLOAD_FONT_MEMUSG(CharIncX, (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4);
    if (CheckAvailableMem(lpEpage, pUFObj) < dwMemUsg)
    {
        ERR(("Insufficient memory for OEMDownloadCharGlyph.\r\n"));
        return 0;    // error
    }

    // retrieve NextGlyph
    cp = (WORD)lpEpage->dwNextGlyph;
    // for DBCS, modify cp to printable char code
    if (bDBCS)
    {
        cp = WConvDBCSCharCode(cp, lpEpage->dwLCID);
    }

    //
    // Fill character header.
    //
    ZeroMemory(&ESCPageChar, sizeof(ESCPAGECHAR));    // Safe initial values

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
    ESCPageChar.wCharCode     = (bDBCS) ? SWAPW(cp) : LOBYTE(cp);
    ESCPageChar.wBitmapWidth  = SWAPW(pgb->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight = SWAPW(pgb->sizlBitmap.cy);
    ESCPageChar.wLeftOffset   = SWAPW(pgb->ptlOrigin.x);
    ESCPageChar.wAscent       = SWAPW(-pgb->ptlOrigin.y);    // negate (to be positive)
    ESCPageChar.CharWidth     = MAKELONG(SWAPW(CharIncX), 0);

    dwSize = pgb->sizlBitmap.cy * ((pgb->sizlBitmap.cx + 7) >> 3);
    iSizeOfBuf = EP_StringCbPrintf_with_int1(Buff, sizeof(Buff),
                                DLI_DNLD1CHAR_H, dwSize + sizeof(ESCPAGECHAR));
    if (bDBCS)  // for DBCS, set additional high byte
        iSizeOfBuf += EP_StringCbPrintf_with_int1(&Buff[iSizeOfBuf], sizeof(Buff) - iSizeOfBuf,
                                DLI_DNLD1CHAR_P, HIBYTE(cp));
    iSizeOfBuf += EP_StringCbPrintf_with_int1(&Buff[iSizeOfBuf], sizeof(Buff) - iSizeOfBuf,
                                DLI_DNLD1CHAR_F, LOBYTE(cp));
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &ESCPageChar, sizeof(ESCPAGECHAR));
    WRITESPOOLBUF(pdevobj, pgb->aj, dwSize);

    if (pdwWidth)
        *pdwWidth = CharIncX;

    return dwMemUsg;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//
//  Description:  determines TT font downloading method
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pFontObj    Pointer to the FONTOBJ.
//
//
//  Returns:  TTDOWNLOAD_???? flag: one of these
//        TTDOWNLOAD_DONTCARE        Minidriver doesn't care how this font is handled.
//        TTDOWNLOAD_GRAPHICS        Minidriver prefers printing this TT font as graphics.
//        TTDOWNLOAD_BITMAP        Minidriver prefers download this TT font as bitmap soft font.
//        TTDOWNLOAD_TTOUTLINE    Minidriver prefers downloading this TT fonta as TT outline soft font. This printer must have TT rasterizer support. UNIDRV will provide pointer to the memory mapped TT file, through callback. The minidriver has to parser the TT file by itself.
//
//
//  Comments:
//        The judgement is very unreliable !!!
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMTTDownloadMethod(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    DWORD ttdlf = TTDOWNLOAD_GRAPHICS;
//  LPEPAGEMDV lpEpage;  // (Delete) This variable is not used anywhere .
    DWORD adwStdVariable[2 + 2 * 1];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMTTDownloadMethod entry. jWinCharSet = %d\r\n"), pUFObj->pIFIMetrics->jWinCharSet));

//  lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (1 - 1);
    pSV->dwNumOfVariable = 1;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    
    if (pUFObj == NULL) // Checking null-pointer.
    {
        return ttdlf;
    }
    
    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL) &&
        pSV->StdVar[0].lStdVariable < DOWNLOAD_MAX_HEIGHT * MIN_Y_UNIT_DIV)
    {    // not so big font size
        ttdlf = TTDOWNLOAD_BITMAP;    // download bitmap font
    }
    else
    {
        WARNING(("OEMTTDownloadMethod returns TTDOWNLOAD_GRAPHICS. width = %d\n",
                 pSV->StdVar[0].lStdVariable));
    }
    return ttdlf;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//
//  Description:  convert character code
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        dwType        Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//
//        dwCount        Number of the glyph store in pGlyph
//
//        pGlyph        Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMOutputCharStr(,,%s,%d,) entry.\r\n")),
//         (dwType == TYPE_GLYPHHANDLE) ? "TYPE_GLYPHHANDLE" : "TYPE_GLYPHID", dwCount);

// DEBUG
// CheckAvailableMem((LPEPAGEMDV)(pdevobj->pdevOEM), pUFObj);
// DEBUG

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHHANDLE\n")));
// pdwGlyphID = (PDWORD)pGlyph;
// for (dwI = 0; dwI < dwCount; dwI++)
//  DBGPRINT(DBG_WARNING, (DLLTEXT("hGlyph[%d] = %x\r\n"), dwI, pdwGlyphID[dwI]));
        if (!BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph))
        {  // Checking the return value.
            return;
        }
        break;

    case TYPE_GLYPHID:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHID\n")));
        {
            LPEPAGEMDV    lpEpage;
            int hlx;

            if (pdevobj == NULL) // Checking null-pointer.
            {
                return;
            }
            
            lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
            if (lpEpage == NULL) // Checking null-pointer.
            {
                return;
            }

            hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);

            if (hlx >= 0)
            {    // TTF downloaded
                BYTE bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
                PDWORD pdwGlyphID;
                DWORD dwI;
                
                if (pGlyph == NULL) // Checking null-pointer.
                {
                    return;
                }

                for (dwI = 0, pdwGlyphID = pGlyph; dwI < dwCount; dwI++, pdwGlyphID++)
                {
                    if (bDBCS)
                    {
                        // for DBCS, modify cp to printable char code
                        WORD cc = WConvDBCSCharCode((WORD)*pdwGlyphID, lpEpage->dwLCID);
                        WORD cp = SWAPW(cc);
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%X, 0x%X (%.4X)\n"), dwI, LOBYTE(cp), HIBYTE(cp), (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)&cp, 2);
                    }
                    else
                    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%.4lX\n"), dwI, (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)pdwGlyphID, 1);
                    }
                }
            }
            else
            {    // download font not active
                if (!BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph))
                {
                    ERR(("TYPE_GLYPHID specified for device font.\r\n"));
                    return; // Checking the return value.
                }
            }
        }
        break;
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmd
//
//  Description:  Send scalable font download command
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        pFInv        Pointer to the FINVOCATION
//                    Command string template has been extracted from UFM file,
//                    which may contain "#V" and/or "#H[S|D]"
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv)
{
    DWORD        adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD        dwIn, dwOut;
    PBYTE        pubCmd;
    BYTE        aubCmd[CCHMAXCMDLEN];
//    GETINFO_FONTOBJ    FO;
    PIFIMETRICS    pIFI;
    DWORD         height100, width, charoff;

    LPEPAGEMDV    lpEpage;
    BYTE        Buff[16];

    LONG        ret; // buffy.pl : Addition for checking the return value of "LConvertFontSizeToStr".

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMSendFontCmd() entry. Font = %S\r\n"), (LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)));

    if (pdevobj == NULL || pUFObj == NULL) // Checking null-pointer.
    {
        return;
    }
    pIFI = pUFObj->pIFIMetrics;
    if (pIFI == NULL) // Checking null-pointer.
    {
        return;
    }
    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return;
    }

    pubCmd = pFInv->pubCommand;

    if (pubCmd == NULL) // Checking null-pointer.
    {
        return;
    }

//    //
//    // GETINFO_FONTOBJ
//    //
//    FO.dwSize = sizeof(GETINFO_FONTOBJ);
//    FO.pFontObj = NULL;
//
//    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &FO, 0, NULL))
//    {
//        ERR(("UFO_GETINFO_FONTOBJ failed.\r\n"));
//        return;
//    }

    //
    // Get standard variables.
    //
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));

    // Initialize lpEpage
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fGeneral = ")));
    if (IS_DBCSCHARSET(pIFI->jWinCharSet))
    {
        lpEpage->fGeneral |= FLAG_DOUBLE;
// DBGPRINT(DBG_WARNING, ("FLAG_DOUBLE "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_DOUBLE;

    if (L'@' == *((LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)))
    {
        lpEpage->fGeneral |= FLAG_VERT;
// DBGPRINT(DBG_WARNING, ("FLAG_VERT "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_VERT;

    if ((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH)
    {
        lpEpage->fGeneral |= FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("FLAG_PROP"));
    }
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("\r\n"));

    dwOut = 0;
    lpEpage->fGeneral &= ~FLAG_DBCS;

    // preset character height in Minimum Unit for ESC/Page
    height100 = (pSV->StdVar[0].lStdVariable * 100L) / MIN_Y_UNIT_DIV;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Height = %d\r\n"), height100));

    for (dwIn = 0; dwIn < pFInv->dwCount && dwOut < CCHMAXCMDLEN; )
    {
        // check for FS_n1_weF command
        // Addition of checking remaining bytes of "pubCmd".
        if ((dwIn + 3) < pFInv->dwCount && pubCmd[dwIn] == '\x1D' &&
            (!strncmp(&pubCmd[dwIn + 2], "weF", 3) ||
             !strncmp(&pubCmd[dwIn + 3], "weF", 3)))
        {
            // save n1 for the FS_n1_weF command
            
            // PREFAST : warning 31: Return value ignored:  'sscanf' could fail.
            // If sscanf do not succeed, it set the default value to "lpEpage->iParamForFSweF"
            if(1 != sscanf(&pubCmd[dwIn + 1], "%d", &lpEpage->iParamForFSweF)) {
                lpEpage->iParamForFSweF = 0;    // use default value.
            }
        }
        else if ((pubCmd[dwIn] == '\x1D') && ((dwIn + 5) <= pFInv->dwCount)
            && (pubCmd[dwIn+2] == 's') && (pubCmd[dwIn+3] == 't') && (pubCmd[dwIn+4] == 'F'))
        {
            if (pubCmd[dwIn+1] == '1') // This font is italic font like "Arial Italic"
            {
                lpEpage->flAttribute |= EP_FONT_EXPLICITE_ITALIC_FONT;
            }
            else { // Normal font
                lpEpage->flAttribute &= ~EP_FONT_EXPLICITE_ITALIC_FONT;
            }
        }
        // Addition of checking remaining bytes of "pubCmd".
        if ((dwIn + 1) < pFInv->dwCount && pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'V')
        {
            // buffy.pl : Addition of checking the return value of "LConvertFontSizeToStr".
            ret = LConvertFontSizeToStr(height100, &aubCmd[dwOut], sizeof(aubCmd) - dwOut);
            if(ret < 0)
                break;
            dwOut += ret;
            dwIn += 2;
        }
        // Addition of checking remaining bytes of "pubCmd".
        else if ((dwIn + 2) < pFInv->dwCount && pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'H')
        {
            // get width in MASTER_X_UNIT; no adjustment needed
            width = pSV->StdVar[1].lStdVariable;
            if (pubCmd[dwIn + 2] == 'S')
            {
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthS = ")));
            }
            else if (pubCmd[dwIn + 2] == 'D')
            {
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthD = ")));
            }
            else if (pubCmd[dwIn + 2] == 'K')
            {    // PAGE-C/K/H
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthK = ")));
            }
            else
            {
                dwIn += 2;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Width = ")));
            }
// DBGPRINT(DBG_WARNING, ("%d\r\n", width));
#if    1    // <FS> n1 wmF
            // use width in minimum unit
            width = (width * 100L) / MIN_Y_UNIT_DIV;
#else    // <FS> n1 wcF
            // get CPI (Char# per Inch)
            width = (MASTER_X_UNIT * 100L) / width;
#endif
// DBGPRINT(DBG_WARNING, (DLLTEXT("Width=%d\r\n"), width));

            // buffy.pl : Addition of checking the return value of "LConvertFontSizeToStr".
            ret = LConvertFontSizeToStr(width, &aubCmd[dwOut], sizeof(aubCmd) - dwOut);
            if(ret < 0)
                break;
            dwOut += ret;
        }
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("  iParamForFSweF = %d\r\n"), lpEpage->iParamForFSweF));

    // buffy.pl : Addition of checking if making the command string succeed or not.
    if(pFInv->dwCount <= dwIn)
    {
        WRITESPOOLBUF(pdevobj, aubCmd, dwOut);
    }

    lpEpage->iDevCharOffset = (height100 * pIFI->fwdWinDescender /
                               (pIFI->fwdWinAscender + pIFI->fwdWinDescender));

    // Checking the return value.
    ret = LConvertFontSizeToStr((lpEpage->fGeneral & FLAG_DBCS) ? lpEpage->iDevCharOffset : 0,
                                 Buff, sizeof(Buff));
    if (ret >= 0)
    {
        dwOut = EP_StringCbPrintf_with_String(aubCmd, sizeof(aubCmd), SET_CHAR_OFFSET_S, Buff);
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("  iDevCharOffset = %s\r\n"), Buff));

    if (lpEpage->fGeneral & FLAG_VERT)
    {
        int dx = (lpEpage->fGeneral & FLAG_DOUBLE) ? 1 : 0;
        dwOut += EP_StringCbPrintf_with_int1(&aubCmd[dwOut], sizeof(aubCmd) - dwOut,
                                SET_VERT_PRINT, dx);
    }
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    lpEpage->iCurrentDLFontID = -1;        // mark device font

    // save for SET_SINGLE_BYTE and SET_DOUBLE_BYTE
    // get width in Minimum Unit for ESC/Page
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;
    if (lpEpage->fGeneral & FLAG_DBCS)
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = width * 2;
    }
    else
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = 0;
    }
    lpEpage->iSBCSYMove = lpEpage->iDBCSYMove = 0;
}

// buffy.pl : Addition of checking the size of "pStr".
//
// LConvertFontSizeToStr : converts font size to string
//	params
//		size	:	font size (magnified by 100 times)
//		pStr	:	points string buffer
//		len		:	length of pStr buffer in byte
//	return
//		converted string length. If it failed converting, it returns negative value.
//	spec
//		converting format = "xx.yy"
//
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr, DWORD len)
{
    DWORD   figure = 1;
    LONG    rank = 10;
    LONG    n = size;

    if (pStr == NULL) // Checking null-pointer.
    {
        return -1;
    }

    while (n / rank)
    {
        figure ++;
        rank *= 10;
    }
    if (figure < 3) figure = 3;     // at least 3 figures exit.

    // adjust figure number to required size.
    if (size < 0) figure ++;        // for sign.
    figure += 2;                    // for point and NULL termination

    if (len < figure) return (-1);  // error.

    return (LONG)EP_StringCbPrintf_with_int2(pStr, len, "%d.%02d", size / 100, size % 100);
}


//
// BInsertHeightList : inserts HeightList data for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//        wHeight    :    font height
//        wWidth    :    font width
//        fProp    :    proportional spacing font flag
//        fDBCS    :    DBCS font flag
//    return
//        TRUE when succeeded, FALSE if failed (no more space)
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS)
{
// DBGPRINT(DBG_WARNING, (DLLTEXT("Registering download font (%d):\r\n"), id));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wHeight = %d\r\n"), (int)wHeight));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wWidth  = %d\r\n"), (int)wWidth));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fProp   = %d\r\n"), (int)fProp));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fDBCS   = %d\r\n"), (int)fDBCS));
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return FALSE;
    }

    if (lpEpage->wListNum < DOWNLOAD_MAX_FONTS)
    {
        LPHEIGHTLIST lpHeightList = lpEpage->HeightL;

        lpHeightList          += lpEpage->wListNum;
        lpHeightList->id       = (short)id;
        lpHeightList->Height   = wHeight;
        lpHeightList->Width    = wWidth;
        lpHeightList->fGeneral = ((fProp) ? FLAG_PROP : 0) | ((fDBCS) ? FLAG_DBCS : 0);
        lpEpage->wListNum++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// IGetHLIndex : gets HeightList index for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//    return
//        the HeghtList index if found, else -1 will be returned
//
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id)
{
    int iRet;
    
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return -1;
    }

    for (iRet = lpEpage->wListNum - 1;
         iRet >= 0 && (int)lpEpage->HeightL[iRet].id != id;
         iRet--)
        ;
    return iRet;
}


//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_PROP) : 0;
//}


//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_DBCS) : 0;
//}


//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Width : 0;
//}


//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Height : 0;
//}


//
// WConvDBCSCharCode : converts linear character code to printable range
//    params
//        cc        :    linear character code started at DOWNLOAD_MIN_GLYPH_ID
//        LCID    :    locale ID
//    return
//        WORD character code in printable range
//
//    Conversion spec:
//        cc                return
//    LCID = LCID_KOR:
//        0x20..0x7D    ->    0xA1A1..0xA1FE    (char count = 0xA1FE - 0xA1A1 + 1 = 0x5E)
//        0x7E..0xDB    ->    0xA2A1..0xA2FE    (char count = 0x5E)
//        0xDC..0x139    ->    0xA3A1..0xA3FE    (char count = 0x5E)
//        ...                ...
//    LCID != LCID_KOR:
//        0x20..0x7D    ->    0x2121..0x207E    (char count = 0x217E - 0x2121 + 1 = 0x5E)
//        0x7E..0xDB    ->    0x2221..0x227E    (char count = 0x5E)
//        0xDC..0x139    ->    0x2321..0x237E    (char count = 0x5E)
//        ...                ...
//
WORD WConvDBCSCharCode(WORD cc, DWORD LCID)
{
    WORD nPad, cc2;
    cc2 = cc - DOWNLOAD_MIN_GLYPH_ID;    // adjust to base 0
    nPad = cc2 / 0x5E;                    // get gap count
    cc2 += nPad * (0x100 - 0x5E);        // adjust for padding gaps
    // set the base code for the LCID
    switch (LCID)
    {
    case LCID_KOR:
        cc2 += (WORD)0xA1A1;
        break;
    default:
        cc2 += (WORD)0x2121;
        break;
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("WConvDBCSCharCode(%.4x,%d) = %.4x\r\n"), cc, LCID, cc2));
    return cc2;
}


//
// BConvPrint : converts glyph string and prints it
//    params
//        pdevobj    :    Pointer to the DEVOBJ.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//        dwType    :    Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//        dwCount    :    Number of the glyph store in pGlyph
//        pGlyph    :    Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//    return
//        TRUE when succeeded, FALSE if failed
//
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{
    TRANSDATA *aTrans;
    GETINFO_GLYPHSTRING GStr;
    LPEPAGEMDV lpEpage;

    DWORD    dwI;
    DWORD    adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV;
    BOOL    bGotStdVar;
    DWORD    dwFontSim[2];

    BYTE jType, *pTemp;
    WORD wLen;
    BOOL bRet;

    if (pdevobj == NULL || pUFObj == NULL) // Checking null-pointer.
    {
        return FALSE;
    }
    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage == NULL) // Checking null-pointer.
    {
        return FALSE;
    }

    // setup GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = dwType;
    GStr.pGlyphIn  = pGlyph;
    GStr.pGlyphOut = NULL;
    GStr.dwTypeOut = TYPE_TRANSDATA;

    GStr.dwGlyphOutSize = 0;
    GStr.pGlyphOut = NULL;

    if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
        || 0 == GStr.dwGlyphOutSize)
    {
        ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
            bRet, GStr.dwGlyphOutSize));
        return FALSE;
    }

    aTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
    if (NULL == aTrans)
    {
        ERR(("MemAlloc faild.\n"));
        return FALSE;
    }

    GStr.pGlyphOut = aTrans;

    // convert glyph string to TRANSDATA
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return FALSE;
    }

// Only LCID_JPN == 0, other LCIDs are not 0
//            if (lpEpage->dwLCID == LCID_CHT ||
//                lpEpage->dwLCID == LCID_CHS ||
//                lpEpage->dwLCID == LCID_KOR)
//            if (lpEpage->dwLCID && lpEpage->dwLCID != LCID_USA)
    if (lpEpage->dwLCID != LCID_USA)    //99/02/04
    {
        // prepare GETINFO_STDVAR
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTBOLD;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTITALIC;
        bGotStdVar = FALSE;
        // preset 0 to dwFontSim[]
        dwFontSim[0] = dwFontSim[1] = 0;
    }
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
// #441441: PREFIX: "pSV" does not initialized if dwLCID == LCID_USA
    else {
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        bGotStdVar = TRUE;
    }

    for (dwI = 0; dwI < dwCount; dwI++)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),aTrans[dwI].ubCodePageID));
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),aTrans[dwI].ubType));
        jType = (aTrans[dwI].ubType & MTYPE_FORMAT_MASK);

        switch (jType)
        {
        case MTYPE_DIRECT:
        case MTYPE_COMPOSE:

// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCode:0x%.2X\n"),aTrans[dwI].uCode.ubCode));
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // if (lpEpage->fGeneral & FLAG_DOUBLE)
                if ((lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }
            }

            switch(jType)
            {
            case MTYPE_DIRECT:
                WRITESPOOLBUF(pdevobj, &aTrans[dwI].uCode.ubCode, 1);
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(aTrans) + aTrans[dwI].uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                WRITESPOOLBUF(pdevobj, pTemp, wLen);
                break;
            }
            break;
        case MTYPE_PAIRED:
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
                if (!(lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectDoubleByteMode
                    OEMCommandCallback(pdevobj, TEXT_DOUBLE_BYTE, 2, dwFontSim);
                }
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
            }
            else
            {    // Jpn
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                // EPSON specific
                // vertical period and comma must be shifted to upper right.
                BOOL AdjPos;
                int adjx, adjy;
                BYTE buf[32];
                DWORD cb;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"Code = %.4x, Vertical = %d.\r\n",
       *((PWORD)aTrans[dwI].uCode.ubPairs), !!(lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)));
#endif
// DEBUG
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // 99/02/04
                // if ((lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                if (lpEpage->dwLCID != LCID_USA && (lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }

                AdjPos = (*((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2421 ||    // comma
                          *((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2521) &&    // period
                         (lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)) &&
                         !(lpEpage->fGeneral & FLAG_NOVPADJ);
                if (AdjPos)
                {
                    adjx = lpEpage->iSBCSX * VERT_PRINT_REL_X / 100;
                    adjy = lpEpage->iSBCSX * VERT_PRINT_REL_Y / 100;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_ICONINFORMATION, L"adjx = %d, adjy = %d.\r\n", adjx, adjy);
#endif
// DEBUG
                    cb = EP_StringCbPrintf_with_int1(buf, sizeof(buf), SET_REL_X, -adjx);
                    cb += EP_StringCbPrintf_with_int1(buf + cb, sizeof(buf) - cb, SET_REL_Y, -adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
                if (AdjPos)
                {
                    cb = EP_StringCbPrintf_with_int1(buf, sizeof(buf), SET_REL_X, adjx);
                    cb += EP_StringCbPrintf_with_int1(buf + cb, sizeof(buf) - cb, SET_REL_Y, adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
            }
            break;
        default:
            WARNING(("Unsupported TRANSDATA data type passed.\n"));
            WARNING(("jType=%02x, sCode=%x\n", aTrans[dwI].uCode.sCode, jType));
        }
    }

    if (NULL != aTrans)
    {
        MemFree(aTrans);
    }

    return TRUE;
}


//
// CheckAvailableMem : check available memory size
//    params
//        lpEpage    :    Pointer to the EPAGEMDV.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//    return
//        available memory size in bytes
//
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj)
{
    GETINFO_MEMORY meminfo;
    
    if (lpEpage == NULL || pUFObj == NULL) // Checking null-pointer.
    {
        return 0;
    }

    // get memory information
    meminfo.dwSize = sizeof(GETINFO_MEMORY);
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_MEMORY, &meminfo, 0, NULL))
    {
        ERR(("UFO_GETINFO_MEMORY failed.\r\n"));
        return 0;    // error
    }
    // DCR: Unidrv might return NEGATIVE value
    if ((long)meminfo.dwRemainingMemory < 0)
        meminfo.dwRemainingMemory = 0;
    if (lpEpage->dwMemAvailable != meminfo.dwRemainingMemory)
    {
        lpEpage->dwMemAvailable = meminfo.dwRemainingMemory;
//        DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), meminfo.dwRemainingMemory));
    }
    return meminfo.dwRemainingMemory;
}

// ----- These following functions are substitutes of "sprintf". -----
//
// EP_StringCbPrintf_with_int1 : The substitute of "sprintf" for using functions in "strsafe.h."
//                               This function has a parameter of int for formated string.
//    params
//        lpBuff      :  Storage location for output.
//        buff_length :  Size of lpBuff.
//        pszFormat   :  Format-control string.
//        Arg_int1    :  Parameter of the type of "int" for pszFormat.
//    return
//        the written size(bytes) in lpBuff.
//
size_t EP_StringCbPrintf_with_int1(char *lpBuff, size_t buff_length, const char *pszFormat, int Arg_int1)
{
    size_t remain_size;
    size_t written_size = 0;
    HRESULT hr;

     hr = StringCbPrintfExA(lpBuff, buff_length, NULL, &remain_size,
                            STRSAFE_FILL_ON_FAILURE, pszFormat, Arg_int1);
    if(SUCCEEDED(hr)) {
        written_size = buff_length - remain_size;
    }
    return written_size;
}
//
// EP_StringCbPrintf_with_int2 : The substitute of "sprintf" for using functions in "strsafe.h."
//                               This function has two parameters of int for formated string.
//    params
//        lpBuff      :  Storage location for output.
//        buff_length :  Size of lpBuff.
//        pszFormat   :  Format-control string.
//        Arg_int1    :  Parameter1 of the type of "int" for pszFormat.
//        Arg_int2    :  Parameter2 of the type of "int" for pszFormat.
//    return
//        the written size(bytes) in lpBuff.
//
size_t EP_StringCbPrintf_with_int2(char *lpBuff, size_t buff_length, const char *pszFormat,
                                int Arg_int1, int Arg_int2)
{
    size_t remain_size;
    size_t written_size = 0;
    HRESULT hr;

     hr = StringCbPrintfExA(lpBuff, buff_length, NULL, &remain_size,
                            STRSAFE_FILL_ON_FAILURE, pszFormat, Arg_int1, Arg_int2);
    if(SUCCEEDED(hr)) {
        written_size = buff_length - remain_size;
    }
    return written_size;
}
//
// EP_StringCbPrintf_with_int2 : The substitute of "sprintf" for using functions in "strsafe.h."
//                               This function has a parameter of string for formated string.
//    params
//        lpBuff      :  Storage location for output.
//        buff_length :  Size of lpBuff.
//        pszFormat   :  Format-control string.
//        pArgS       :  Parameter of the type of char-string for pszFormat.
//    return
//        the written size(bytes) in lpBuff.
//
size_t EP_StringCbPrintf_with_String(char *lpBuff, size_t buff_length, const char *pszFormat, char *pArgS)
{
    size_t remain_size;
    size_t written_size = 0;
    HRESULT hr;

    if(pArgS == NULL)
        return 0;

     hr = StringCbPrintfExA(lpBuff, buff_length, NULL, &remain_size,
                            STRSAFE_FILL_ON_FAILURE, pszFormat, pArgS);
    if(SUCCEEDED(hr)) {
        written_size = buff_length - remain_size;
    }
    return written_size;
}

// DEBUG
#ifdef    DBGMSGBOX
#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    // can't do anything against GUI
    return 0;
}
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    // can't do anything against GUI
    return 0;
}
#else    // Usermode
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    TCHAR buf[256];
    va_list va;
    va_start(va, msgfmt);
    StringCbVPrintfW(buf, msgfmt, va);
    va_end(va);
    return MsgBox(lpEpage, buf, mbicon);
}

int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    int rc = IDOK;
    if (mbicon != MB_OK)
        lpEpage->fGeneral &= ~FLAG_SKIPMSG;
    if (!(lpEpage->fGeneral & FLAG_SKIPMSG))
    {
        if (IDCANCEL ==
            (rc = MessageBox(GetDesktopWindow(), msg, L"EPAGCRES", mbicon|MB_OKCANCEL)))
        {
            lpEpage->fGeneral |= FLAG_SKIPMSG;
        }
    }
    return rc;
}
#endif
#endif    // #ifdef    DBGMSGBOX
// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#include <strsafe.h> // For privention of security isusues.

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs && \
         (pdevobj)->pdevOEM )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'EPAG'      // EPSPN ESC/Page series dll
// #define DLLTEXT(s)      __TEXT("EPAG:  ") __TEXT(s)
#define DLLTEXT(s)      "EPAG:  " s
#define OEM_VERSION      0x00010000L

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",	// Suggested by ganeshp
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",		// Suggested by ganeshp
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\epageres\sources.inc ===
#
# Common part of SOURCES file
#

MAJORCOMP=windows
MINORCOMP=md_epageres

#
# We assume PRNROOT is propery defined
#

!include $(PRNROOT)\print.inc

GPDLANG=$(ALT_PROJECT)

!ifndef DDKBUILDENV

GPDDIR=$(PRNROOT)\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\gpd\ricoh\$(GPDLANG)

!else

GPDDIR=$(PRNROOT)\mini\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\mini\gpd\ricoh\$(GPDLANG)

!endif

INCLUDES=$(PRNROOT)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),epageres
!else
DLLBASE=0x8000000
!endif

UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\eprstres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

!if "$(ALT_PROJECT)"=="CHP"
GPDLANG=CHS
!else
GPDLANG=$(ALT_PROJECT)
!endif

GPDDIR_EP=$(PRNROOT)\gpd\epson\$(GPDLANG)

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),eprstres
!else
DLLBASE=0x8000000
!endif

RESOURCE_ONLY_DLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

// NTRAID#NTBUG9-588573-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#ifdef USERMODE_DRIVER

#define INITGUID // for GUID one-time initialization

#include "fmlbp.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == pDevOem)
        return E_FAIL;

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                break;

            case (WCHAR)'I':
                break;

            case (WCHAR)'M':
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == piResult)
        return E_FAIL;

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Error handling
    if (bOEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph))
	    return S_OK;
	else
		return E_FAIL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Error handling
	if (bOEMSendFontCmd(pdevobj, pUFObj, pFInv))
	    return S_OK;
	else
	    return E_FAIL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == ppv)
        return E_NOINTERFACE;

    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//


//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#endif // USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmdebug.c ===
///////////////////////////////////////////////////
// fmdebug.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#if DBG

#include <minidrv.h>
#include "fmlbp.h"

void dbgPrintf(LPSTR pszMsg, ...)
{
	va_list arg;
	va_start(arg, pszMsg);
	// DbgPrint("[fmblpres]", pszMsg, arg);
	va_end(arg);
}


#endif // DBG

// end of fmdebug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmdebug.h ===
////////////////////////////////////////////////
// fudebug.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fudebug_h
#define	fudebug_h

// 
// #if DBG && defined(TRACE_DDI)
// #define	TRACEDDI(a)	dbgPrintf a;
// #else
// #define	TRACEDDI(a)
// #endif
// 
// 
// #if DBG && defined(TRACE_OUT)
// #define	TRACEOUT(a)	dbgPrintf a;
// #else
// #define	TRACEOUT(a)
// #endif
// 
// #if DBG
// void dbgPrintf(LPSTR pszMsg, ...);
// #endif
// 

#define DDI_VERBOSE VERBOSE

#endif // !fudebug_h

// end of fudebug.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbp.h ===
///////////////////////////////////////////////////////////////
// fmlbp.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

// NTRAID#NTBUG9-553888-2002/03/22-yasuho-: mandatory changes (strsafe.h)

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define	FUFM_OEM_SIGNATURE	'FUFM'
#define	FUFM_OEM_VERSION	0x00010000L


typedef	const BYTE FAR*	LPCBYTE;


typedef struct tag_FUFM_OEM_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} FUFM_OEM_EXTRADATA, *PFUFM_OEM_EXTRADATA;




#define WRITESPOOLBUF(pdevobj, s, n) \
	((pdevobj)->pDrvProcs->DrvWriteSpoolBuf((pdevobj), s, n))

#define	IS_VALID_FUFMPDEV(p) \
	((p) != NULL && (p)->dwSignature == FUFM_OEM_SIGNATURE)


#define	FUFM_MASTER_TO_DEVICE(p,d) \
	((p)->devData.dwResolution * (d) / FUFM_RESOLUTION_MASTER_UNIT)


// FUFMDATA.dwSizeReduction
#define	FUFM_SIZE_REDUCTION_100			0
#define	FUFM_SIZE_REDUCTION_75			1
#define	FUFM_SIZE_REDUCTION_70			2
#define	FUFM_SIZE_REDUCTION_UNKNOWN		((DWORD)-1)


// FUFMDATA.dwResolution
#define	FUFM_RESOLUTION_MASTER_UNIT		1200
#define	FUFM_RESOLUTION_240				240
#define	FUFM_RESOLUTION_400				400
#define	FUFM_RESOLUTION_UNKNOWN			((DWORD)-1)


// FUFMDATA.dwPaperSize
#define	FUFM_PAPERSIZE_A3					0x00000003
#define	FUFM_PAPERSIZE_A4					0x00000004
#define	FUFM_PAPERSIZE_A5					0x00000005
#define	FUFM_PAPERSIZE_B4					0x00010004
#define	FUFM_PAPERSIZE_B5					0x00010005
#define	FUFM_PAPERSIZE_LETTER				0x00030000
#define	FUFM_PAPERSIZE_LEGAL				0x00020000
#define	FUFM_PAPERSIZE_JAPANESE_POSTCARD	0x00040000
#define	FUFM_PAPERSIZE_CUSTOM_SIZE			0x00090000
#define	FUFM_PAPERSIZE_UNKNOWN				((DWORD)-1)


// FUFMDATA.dwPaperSource
#define	FUFM_PAPERSOURCE_AUTO				0x00010000
#define	FUFM_PAPERSOURCE_MANUAL				0x00000002
#define	FUFM_PAPERSOURCE_BIN1				0x00000000
#define	FUFM_PAPERSOURCE_BIN2				0x00000001
#define	FUFM_PAPERSOURCE_BIN3				0x00000003
#define	FUFM_PAPERSOURCE_UNKNOWN			((DWORD)-1)


// FUFMDATA.dwPaperOrientation
#define	FUFM_PAPERORIENTATION_PORTRAIT		0
#define	FUFM_PAPERORIENTATION_LANDSCAPE		1
#define	FUFM_PAPERORIENTATION_UNKNOWN		((DWORD)-1)


// FUFMDATA.dwFontAttributes
#define	FUFM_FONTATTR_BOLD					0x00000001
#define	FUFM_FONTATTR_ITALIC				0x00000002
#define	FUFM_FONTATTR_UNDERLINE				0x00000004
#define	FUFM_FONTATTR_STRIKEOUT				0x00000008


typedef struct tag_FUFMDATA {
	DWORD	dwSizeReduction;
	DWORD	dwResolution;
	DWORD	dwPaperSize;
	DWORD	dwPaperSource;
	DWORD	dwPaperOrientation;
	DWORD	dwCopies;
	DWORD	dwFontAttributes;
} FUFMDATA;


typedef	FUFMDATA*		PFUFMDATA;
typedef const FUFMDATA*	PCFUFMDATA;




// FUFMPDEV.dwEmMode
enum tag_FUFM_EMMODE {
	FUFM_EMMODE_FM,
	FUFM_EMMODE_ESCP
};

typedef	enum tag_FUFM_EMMODE	FUFM_EMMODE;


// FUFMPDEV.dwFlags
#define	FUFM_FLAG_SCALABLEFONT		0x0001
#define	FUFM_FLAG_QUICKRESET		0x0002
#define	FUFM_FLAG_PAPER3			0x0004

#define	FUFM_FLAG_START_JOB_0		0
#define	FUFM_FLAG_START_JOB_1		FUFM_FLAG_SCALABLEFONT
#define	FUFM_FLAG_START_JOB_2		(FUFM_FLAG_SCALABLEFONT | FUFM_FLAG_QUICKRESET)
#define	FUFM_FLAG_START_JOB_3		(FUFM_FLAG_SCALABLEFONT | FUFM_FLAG_QUICKRESET | FUFM_FLAG_PAPER3)
#define	FUFM_FLAG_START_JOB_4		FUFM_FLAG_PAPER3
// #251047: overlaps SBCS on vert mode
#define	FUFM_FLAG_VERTICALFONT		0x0008
// #284409: SBCS rotated on vert mode
#define	FUFM_FLAG_FONTROTATED 		0x0010



// FUFMPDEV.dwPosChanged
#define	FUFM_X_POSCHANGED			0x0001
#define	FUFM_Y_POSCHANGED			0x0002


typedef struct tag_FUFMPDEV {
	DWORD		dwSignature;
	FUFM_EMMODE	emMode;
	DWORD		dwFlags;

	DWORD		dwPosChanged;
	int			x;
	int			y;
	int			iLinefeedSpacing;
	int			cxfont;		//#144637

	DWORD		dwPaperWidth;
	DWORD		dwPaperLength;
	int			cyPage;

	FUFMDATA	devData;
	FUFMDATA	reqData;
} FUFMPDEV, *PFUFMPDEV;


// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		999
// @Aug/31/98 <-

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Error handling
// New interface functions with Unidrv callbacks.
#ifdef __cplusplus
extern "C" {
#endif
BOOL APIENTRY bOEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv);
BOOL APIENTRY bOEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
#ifdef __cplusplus
}
#endif

// end of fmlbp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbpres.c ===
/////////////////////////////////////////
// fmlbpres.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fmlbp.h"
#include "fmdebug.h"

// for lib.h debug
DWORD gdwDrvMemPoolTag = 'meoD';

enum FUFM_CEX_FLAGS {
    FUFM_CEX_CONTINUE    = 0x20,
    FUFM_CEX_SEPARATE    = 0x60,
    FUFM_CEX_TERMINATE    = 0x70
};


#define    CMDID_START_JOB_0                0
#define    CMDID_START_JOB_1                1
#define    CMDID_START_JOB_2                2
#define    CMDID_START_JOB_3                3
#define    CMDID_START_JOB_4                4

#define    CMDID_END_JOB                    9

#define    CMDID_EMMODE_FM                    10
#define    CMDID_EMMODE_ESCP                11

#define    CMDID_SIZE_REDUCTION_100        20
#define    CMDID_SIZE_REDUCTION_75            21
#define    CMDID_SIZE_REDUCITON_70            22

#define    CMDID_RESOLUTION_240            30
#define    CMDID_RESOLUTION_400            31

#define    CMDID_ORIENTATION_PORTRAIT        40
#define    CMDID_ORIENTATION_LANDSCAPE        41

#define    CMDID_PAPERSOURCE_AUTO            50
#define    CMDID_PAPERSOURCE_MANUAL        51
#define    CMDID_PAPERSOURCE_BIN1            52
#define    CMDID_PAPERSOURCE_BIN2            53
#define    CMDID_PAPERSOURCE_BIN3            54

#define    CMDID_FORM_A3                    60
#define    CMDID_FORM_A4                    61
#define    CMDID_FORM_A5                    62
#define    CMDID_FORM_B4                    63
#define    CMDID_FORM_B5                    64
#define    CMDID_FORM_LETTER                65
#define    CMDID_FORM_LEGAL                66
#define    CMDID_FORM_JAPANESE_POSTCARD    67
#define    CMDID_FORM_CUSTOM_SIZE            68

#define    CMDID_COPIES                    70

#define    CMDID_START_DOC                    80

#define    CMDID_START_PAGE                90

#define    CMDID_SET_LINEFEEDSPACING        100
#define    CMDID_FF                        101
#define    CMDID_CR                        102
#define    CMDID_LF                        103

#define    CMDID_X_MOVE                    110
#define    CMDID_Y_MOVE                    111

#define    CMDID_SEND_BLOCK                120


#define    CMDID_FONTATTR_BOLD_OFF            130
#define    CMDID_FONTATTR_BOLD_ON            131
#define    CMDID_FONTATTR_ITALIC_OFF        132
#define    CMDID_FONTATTR_ITALIC_ON        133
#define    CMDID_FONTATTR_UNDERLINE_OFF    134
#define    CMDID_FONTATTR_UNDERLINE_ON        135
#define    CMDID_FONTATTR_STRIKEOUT_OFF    136
#define    CMDID_FONTATTR_STRIKEOUT_ON        137

// #251047: overlaps SBCS on vert mode
#define    CMDID_SELECTSINGLE              140
#define    CMDID_SELECTDOUBLE              141



/////////////////////////////////////////////////

struct tag_FUFM_COMMAND{
    UINT    cbCommand;
    PBYTE    pbCommand;
};

typedef struct tag_FUFM_COMMAND            FUFM_COMMAND;
typedef    struct tag_FUFM_COMMAND*        PFUFM_COMMAND;
typedef    const struct tag_FUFM_COMMAND*    PCFUFM_COMMAND;

// KGS
const FUFM_COMMAND    g_cmd7Point            = { 6, "\x1C\x26\x27\x60\x27\x70" };
const FUFM_COMMAND    g_cmd9Point            = { 6, "\x1C\x26\x29\x60\x29\x70" };
const FUFM_COMMAND    g_cmd10halfPoint    = { 8, "\x1C\x26\x21\x20\x65\x21\x20\x75" };
const FUFM_COMMAND    g_cmd12Point        = { 8, "\x1C\x26\x21\x22\x60\x21\x22\x70" };

// TF + HSS2
const FUFM_COMMAND    g_cmdMinchou        = { 9, "\x1C\x28\x61\x70\x1BQ1 |" };
const FUFM_COMMAND    g_cmdGothic            = { 9, "\x1C\x28\x61\x71\x1BQ1 |" };

// HWF
const FUFM_COMMAND    g_cmdHWF            = { 2, "\x1CK" };

// VWF
const FUFM_COMMAND    g_cmdVWF            = { 7, "\x1CJ\x1BQ1 q" };

// #251047: overlaps SBCS on vert mode
const FUFM_COMMAND    g_cmdSingleMode     = { 3, "\x1B(H" };
const FUFM_COMMAND    g_cmdDoubleMode     = { 3, "\x1B$B" };


/////////////////////////////////////////////////

// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE fufmPutULONG(PBYTE pb, size_t cchDest, size_t* pcchRemaining, ULONG ulData)
{
	size_t	cchRemaining = cchDest;

	if (pb){
		if (cchDest > 0){
		    if(9 < ulData){
		        pb = fufmPutULONG(pb, cchRemaining, &cchRemaining, ulData / 10);
				if (NULL == pb)	goto stop;
		    }
		    *pb++ = (BYTE)('0' + ulData % 10);
			cchRemaining--;
		}else{
			pb = NULL;
		}

	}
	stop:

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

    return pb;
}

// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE fufmPutLONG(PBYTE pb, size_t cchDest, size_t* pcchRemaining, LONG lData)
{
	size_t	cchRemaining = cchDest;

	if (pb){
		if (cchDest > 0){
		    if(0 > lData){
		        *pb++ = '-';
		        lData = -lData;
				cchRemaining--;
		    }
		    pb = fufmPutULONG(pb, cchRemaining, &cchRemaining, (ULONG)lData);
		}else{
			pb = NULL;
		}
	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

	return pb;
}

BYTE fufmGetHEX(int hi, int low)
{
    DWORD dwData = 0;

    if('0' <= hi && hi <= '9')
        dwData += (hi - '0');
    else if('a' <= hi && hi <= 'f')
        dwData += (hi - 'a') + 10;
    else if('A' <= hi && hi <= 'F')
        dwData += (hi - 'A') + 10;

    dwData *= 10;

    if('0' <= low && low <= '9')
        dwData += (low - '0');
    else if('a' <= low && low <= 'f')
        dwData += (low - 'a') + 10;
    else if('A' <= low && low <= 'F')
        dwData += (low - 'A') + 10;

    return (BYTE)dwData;
}

// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE    fufmPutCexParam(PBYTE pb, size_t cchDest, size_t* pcchRemaining, int iParam, int iFlag)
{
	size_t	cchRemaining = cchDest;

	if (pb){
		if (cchDest > 0){
		    if(iParam > 9){
		        pb = fufmPutCexParam(pb, cchRemaining, &cchRemaining, iParam / 10, FUFM_CEX_CONTINUE);
		    }
		    *pb++ = (BYTE)((iParam % 10) | iFlag);
			cchRemaining--;
		}else{
			pb = NULL;
		}
	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

    return pb;
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE _cdecl fufmFormatCommand(PBYTE pbCmd, size_t cchDest, size_t* pcchRemaining, LPCSTR pszFmt, ...)
{
    LPCSTR    pch;
    LPBYTE    pb;
    size_t cchRemaining = cchDest;

    va_list arg;
    va_start(arg, pszFmt);
    pb = pbCmd;

	if (pb){
		if (cchDest > 0){
		    for(pch = pszFmt; *pch != '\0'; ++pch){

				// When an error occurs, set the null to pb.
				if (cchRemaining < (size_t)(pb - pbCmd)){
					pb = NULL; 
					break;
				}

		        if(*pch == '%'){
		            ++pch;
		            switch(*pch){
		              case 'd':
						pb = fufmPutLONG(pb, cchRemaining, &cchRemaining, va_arg(arg, LONG));
						break;
		              case 'u':
						pb = fufmPutULONG(pb, cchRemaining, &cchRemaining, va_arg(arg, ULONG));
						break;
		              case '%':
						*pb++ = '%';
						cchRemaining --;
						break;
		              default:
		                  VERBOSE(("[fufmFormatCommand]invalid seq. %%%c\r\n", *pch))
		                  break;
		            }
		        }
		        else{
		            *pb++ = *pch;
					cchRemaining --;
		        }
		    }

		}else{
			pb = NULL;
		}
	}

    va_end(arg);

	if (pb && (pb - pbCmd)){
		cchRemaining = cchDest - (pb - pbCmd);
	}else{
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

    return pb;
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE    fufmPutCP(PBYTE pb, size_t cchDest, size_t* pcchRemaining, int iPitch)
{
	size_t	cchRemaining = cchDest;

	if (pb){
	    // CP
		if (cchDest > 1){
		    *pb++ = 0x1c;
		    *pb++ = 0x24;
			cchRemaining-=2;
			pb = fufmPutCexParam(pb, cchRemaining, &cchRemaining, iPitch, FUFM_CEX_TERMINATE);
		}else{
			pb = NULL;
		}
	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

    return pb;
}

// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE    fufmPutCommand(PBYTE pb, size_t cchDest, size_t* pcchRemaining, const FUFM_COMMAND* pCmd)
{
	size_t	cchRemaining = cchDest;

	if (pb){
		if (cchDest > 0){

			if (cchDest < pCmd->cbCommand)	return NULL;

		    memcpy(pb, pCmd->pbCommand, pCmd->cbCommand);

			cchRemaining -= pCmd->cbCommand;

		    pb += pCmd->cbCommand;
		}else{
			pb = NULL;
		}
	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

	return pb;
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE fufmUpdatePosition(PBYTE pb, size_t cchDest, size_t* pcchRemaining, PFUFMPDEV pFufmPDEV)
{
    int        x;
    int        y;
	size_t		cchRemaining = cchDest;

	if (pb){

	    if(pFufmPDEV->dwPosChanged != 0){
	        x = pFufmPDEV->x + 1;
	        y = pFufmPDEV->y + 1;
	        switch(pFufmPDEV->dwPosChanged){
	          case FUFM_X_POSCHANGED:    // HPA command
	            VERBOSE(("[fufmUpdatePosition]HPA %d\r\n", x))

				if (cchRemaining > 1){
		            *pb++ = 0x1b;
		            *pb++ = 0x5b;
					cchRemaining-= 2;
				}else{
					pb = NULL;
					break;
				}

	            pb = fufmPutULONG(pb, cchRemaining, &cchRemaining, x);
				if (!pb){
					pb = NULL;
					break;
				}

				if (cchRemaining > 0){
	            	*pb++ = 0x60;
					cchRemaining--;
				}else{
					pb = NULL;
					break;
				}

	            break;
	          default:    // SAP command
	            VERBOSE(("[fufmUpdatePosition]SAP %d %d\r\n", x, y))

				if (cchRemaining > 1){
		            *pb++ = 0x1c;
		            *pb++ = 0x22;
					cchRemaining-= 2;
				}else{
					pb = NULL;
					break;
				}

	            pb = fufmPutCexParam(pb, cchRemaining, &cchRemaining, x, FUFM_CEX_SEPARATE);
				if (!pb){
					pb = NULL;
					break;
				}

	            pb = fufmPutCexParam(pb, cchRemaining, &cchRemaining, y, FUFM_CEX_TERMINATE);
				if (!pb){
					pb = NULL;
					break;
				}

	            break;
	        }
	        pFufmPDEV->dwPosChanged = 0;
	    }

	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }


    return pb;
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
PBYTE fufmUpdateFontAttributes(PBYTE pb, size_t cchDest, size_t* pcchRemaining, PFUFMPDEV pFufmPDEV)
{
    DWORD dwAttributes;
    DWORD dwParam;
	size_t	cchRemaining = cchDest;

	if (pb){
        if((pFufmPDEV->dwFlags & FUFM_FLAG_SCALABLEFONT) != 0){
            if(pFufmPDEV->devData.dwFontAttributes != pFufmPDEV->reqData.dwFontAttributes){
                pFufmPDEV->devData.dwFontAttributes = pFufmPDEV->reqData.dwFontAttributes;
                dwAttributes = pFufmPDEV->devData.dwFontAttributes;
                dwParam = 0;

				if (cchRemaining > 1){
	                *pb++ = 0x1c;
	                *pb++ = '*';
					cchRemaining-= 2;
				}else{
					return NULL;
				}

                if((dwAttributes & FUFM_FONTATTR_BOLD) != 0){
					if (cchRemaining > 0){
                    	*pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
					}else
						return NULL;
                    dwParam = 1;
                }
                if((dwAttributes & FUFM_FONTATTR_ITALIC) != 0){
					if (cchRemaining > 0){
                    	*pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
					}else
						return NULL;
                    dwParam = 3;
                }
                if((dwAttributes & FUFM_FONTATTR_UNDERLINE) != 0){
					if (cchRemaining > 0){
                    	*pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
					}else
						return NULL;
                    dwParam = 4;
                }
                if((dwAttributes & FUFM_FONTATTR_STRIKEOUT) != 0){
					if (cchRemaining > 0){
	                    *pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
					}else
						return NULL;
                    dwParam = 9;
                }
				if (cchRemaining > 0){
                	*pb++ = (BYTE)(FUFM_CEX_TERMINATE + dwParam);
				}else
					return NULL;
            }
        }

	}

	if (!pb){
		cchRemaining = 0;
	}

    if (pcchRemaining)
    {
       *pcchRemaining = cchRemaining;
    }

    return pb;
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Change the return value: void -> BOOL
BOOL fufmCmdStartDoc(PDEVOBJ pdevobj)
{
    PFUFMPDEV         pFufmPDEV;
    PCFUFMDATA        pReq;
    PFUFMDATA        pDev;
    PBYTE            pbCmd;
    BYTE            abCmd[256];
    BOOL            bResolutionCommandNeed;
    BOOL            bPaperCommandNeed;
    BOOL            bCopyCommandNeed;
    DWORD            dwPaperSize;
    DWORD            dwPaperWidth;
    DWORD            dwPaperLength;
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	size_t			sizeRem = sizeof(abCmd);

    VERBOSE(("[fufmCmdStartDoc]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pReq = &pFufmPDEV->reqData;
    pDev = &pFufmPDEV->devData;
    pbCmd = abCmd;

    bResolutionCommandNeed = TRUE;
    bPaperCommandNeed = FALSE;
    bCopyCommandNeed = TRUE;

    if(pDev->dwSizeReduction != pReq->dwSizeReduction){
        pDev->dwSizeReduction = pReq->dwSizeReduction;
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u!I", pDev->dwSizeReduction);
		if (NULL == pbCmd)	return FALSE;
        bResolutionCommandNeed = TRUE;
        bPaperCommandNeed = TRUE;
    }

    if(bResolutionCommandNeed != FALSE || pDev->dwResolution != pReq->dwResolution){
        pDev->dwResolution = pReq->dwResolution;
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u!A", pDev->dwResolution);
		if (NULL == pbCmd)	return FALSE;
        bPaperCommandNeed = TRUE;
        bCopyCommandNeed = TRUE;
        pDev->dwFontAttributes   = 0;
    }
 
     if(pDev->dwPaperSize != pReq->dwPaperSize){
         pDev->dwPaperSize = pReq->dwPaperSize;
         bPaperCommandNeed = TRUE;
     }
     if(pDev->dwPaperSource != pReq->dwPaperSource){
         pDev->dwPaperSource = pReq->dwPaperSource;
         bPaperCommandNeed = TRUE;
     }
     if(pDev->dwPaperOrientation != pReq->dwPaperOrientation){
         pDev->dwPaperOrientation = pReq->dwPaperOrientation;
         bPaperCommandNeed = TRUE;
     }
     if(bPaperCommandNeed != FALSE){
        dwPaperSize = pDev->dwPaperSize;
        if(dwPaperSize == FUFM_PAPERSIZE_CUSTOM_SIZE)
            dwPaperSize = FUFM_PAPERSIZE_A4;
        if(pDev->dwPaperSource != FUFM_PAPERSOURCE_AUTO){
            // PAPER command
			// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u;%u;%u;%u!@",
                                    HIWORD(dwPaperSize),
	                                LOWORD(dwPaperSize),
                                    LOWORD(pDev->dwPaperSource),
                                    pDev->dwPaperOrientation);
			if (NULL == pbCmd)	return FALSE;
        }
        else{
             // PAPER2 command
			// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u;%u;%u!F",
                                     HIWORD(dwPaperSize),
                                     LOWORD(dwPaperSize),
                                     pDev->dwPaperOrientation);
			if (NULL == pbCmd)	return FALSE;
         }
         if((pFufmPDEV->dwFlags & FUFM_FLAG_PAPER3) != 0 &&
                             pDev->dwPaperSize == FUFM_PAPERSIZE_CUSTOM_SIZE &&
                             pDev->dwPaperSource == FUFM_PAPERSOURCE_MANUAL){
             // PAPER3 command
			// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ9;%u;%u;%u!\\",
                                    pFufmPDEV->dwPaperWidth,
                                    pFufmPDEV->dwPaperLength,
                                    pDev->dwPaperOrientation);
			if (NULL == pbCmd)	return FALSE;

         }
     }
 
    if(bCopyCommandNeed != FALSE || pDev->dwCopies != pReq->dwCopies){
        pDev->dwCopies = pReq->dwCopies;
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u!D", pDev->dwCopies);
		if (NULL == pbCmd)	return FALSE;
    }

    if((pFufmPDEV->dwFlags & FUFM_FLAG_SCALABLEFONT) != 0){
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
        pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ1;0;1;1;0!Q\x1c*\x70");
		if (NULL == pbCmd)	return FALSE;
    }

    if(pbCmd > abCmd){
        WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));
    }
	return TRUE;
}



void fufmCmdEmMode(PDEVOBJ pdevobj, FUFM_EMMODE emMode)
{
    PFUFMPDEV    pFufmPDEV;

    VERBOSE(("[fufmCmdChangeEM]%d\r\n", emMode))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->emMode = emMode;
    if(pFufmPDEV->emMode == FUFM_EMMODE_ESCP){
        WRITESPOOLBUF(pdevobj, "\x1b/\xb2@\x7f", 5);
    }
}


void fufmCmdEndJob(PDEVOBJ pdevobj)
{
    PFUFMPDEV    pFufmPDEV;

    VERBOSE(("[fufmCmdEndJob]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(pFufmPDEV->emMode == FUFM_EMMODE_ESCP){
        WRITESPOOLBUF(pdevobj, "\x1b\x7f\x00\x00\x01\x05", 6);
    }
    else if((pFufmPDEV->dwFlags & FUFM_FLAG_QUICKRESET) == 0){
        WRITESPOOLBUF(pdevobj, "\x1bQ0!d", 5);
    }
    else{
        WRITESPOOLBUF(pdevobj, "\x1b\x63", 2);
    }
}



void fufmCmdStartPage(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdStartPage]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->y = 0;
    pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
}


void fufmCmdEndPage(PDEVOBJ pdevobj)
{
    VERBOSE(("[fufmCmdEndPage]\r\n"))
}



void fufmCmdFormFeed(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdFormFeed]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->y = 0;
    pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
    WRITESPOOLBUF(pdevobj, "\x0c", 1);
}



void fufmCmdCR(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdCR]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->dwPosChanged |= FUFM_X_POSCHANGED;
}


void fufmCmdSetLinefeedSpacing(PDEVOBJ pdevobj, int iLinefeedSpacing)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmSetLinefeedSpacing]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->iLinefeedSpacing = iLinefeedSpacing;
}



void fufmCmdLF(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdLF]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->y += pFufmPDEV->iLinefeedSpacing;
    pFufmPDEV->dwPosChanged |= FUFM_Y_POSCHANGED;
}



INT fufmCmdXMove(PFUFMPDEV pFufmPDEV, PDWORD pdwParams)
{
    INT    x;

    VERBOSE(("[fufmCmdXMove] %d\r\n", pdwParams[0]))

      x = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pdwParams[0]);
      if(x < 0)
          x = 0;
      if(x != pFufmPDEV->x){
          pFufmPDEV->x = x;
          pFufmPDEV->dwPosChanged |= FUFM_X_POSCHANGED;
      }
// #492286: Characters printed as wrong position.
      return (INT)pdwParams[0];
}



INT fufmCmdYMove(PFUFMPDEV pFufmPDEV, PDWORD pdwParams)
{
    INT    y;

      VERBOSE(("[fufmCmdYMove] %d\n", pdwParams[0]))

      y = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pdwParams[0]);
      if(y < 0)
          y = 0;
      if(y != pFufmPDEV->y){
          pFufmPDEV->y = y;
          pFufmPDEV->dwPosChanged |= FUFM_Y_POSCHANGED;
      }
// #492286: Characters printed as wrong position.
      return (INT)pdwParams[0];
}


// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Change the return value: void -> BOOL
BOOL fufmCmdSendBlock(PDEVOBJ pdevobj, PDWORD pdwParams)
{
    enum { FUFM_ZERO_DATA_SIZE = 512 };
    enum { FUFM_CY_BORDER = 180 };
    static BYTE abZeroData[FUFM_ZERO_DATA_SIZE];
    PFUFMPDEV    pFufmPDEV;
    DWORD        cbBlockData;
    DWORD        cBlockByteWidth;
    int            x;
    int            y;
    int            cyBorder;
    int            yBorder;
    int            cPadLine;
    int            cPadSize;
    PBYTE        pbCmd;
    BYTE        abCmd[64];
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	size_t		sizeRem = sizeof(abCmd);

    DDI_VERBOSE(("[fufmCmdSendBlock]\r\n"))

    pFufmPDEV = pdevobj->pdevOEM;
    cbBlockData = pdwParams[0];
    cBlockByteWidth = pdwParams[1];

    x = pFufmPDEV->x + 1;
    y = pFufmPDEV->y + 1;
    cyBorder = FUFM_MASTER_TO_DEVICE(pFufmPDEV, FUFM_CY_BORDER);
    yBorder = pFufmPDEV->cyPage - cyBorder;
    cPadLine = y - yBorder;
    if(cPadLine < 0)
        cPadLine = 0;
    VERBOSE(("y %d yBorder %d cPadLine %d\r\n", y, yBorder, cPadLine))
    cPadSize = cPadLine * cBlockByteWidth;

    pbCmd = abCmd;
    if(pFufmPDEV->dwPosChanged != 0 || cPadLine > 0){
        // SAP command

		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
		if (sizeRem > 1){		
	        *pbCmd++ = 0x1c;
	        *pbCmd++ = 0x22;
			sizeRem -= 2;			
		}else
			return FALSE;

        pbCmd = fufmPutCexParam(pbCmd, sizeRem, &sizeRem, x, FUFM_CEX_SEPARATE);
		if (!pbCmd) return FALSE;

        pbCmd = fufmPutCexParam(pbCmd, sizeRem, &sizeRem, y - cPadLine, FUFM_CEX_TERMINATE);
		if (!pbCmd) return FALSE;

        pFufmPDEV->dwPosChanged = 0;
    }
    // RTGIMG command
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
    pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1bQ%u;%u;0!a",
                            cbBlockData + cPadSize,
                            cBlockByteWidth * 8);
	if (NULL == pbCmd)	return FALSE;

    WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));

    if(cPadSize > 0){
        VERBOSE(("pad image %d lines\r\n", cPadLine))
        for(; cPadSize > FUFM_ZERO_DATA_SIZE; cPadSize -= FUFM_ZERO_DATA_SIZE)
            WRITESPOOLBUF(pdevobj, abZeroData, FUFM_ZERO_DATA_SIZE);
        WRITESPOOLBUF(pdevobj, abZeroData, cPadSize);
    }
	return TRUE;
}

// MINI5 Export func.
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD     dwCmdCbID,
    DWORD     dwCount,
    PDWORD     pdwParams)
{
    PFUFMPDEV pFufmPDEV;

    DDI_VERBOSE(("[OEMCommandCallback]dwCmdCbID %d\r\n", dwCmdCbID))

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("OEMCommandCallback: Invalid parameter(s).\n"));
        return 0;
    }

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return 0;

    switch(dwCmdCbID){
      case CMDID_FF:                        fufmCmdFormFeed(pdevobj);                                                    break;
      case CMDID_CR:                        fufmCmdCR(pdevobj);                                                            break;
      case CMDID_SET_LINEFEEDSPACING:
		// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
        if (!pdwParams)
            return 0;      // cannot do anything

        fufmCmdSetLinefeedSpacing(pdevobj, (int)pdwParams[0]);
        break;
      case CMDID_LF:                        fufmCmdLF(pdevobj);                                                            break;

      case CMDID_X_MOVE:
		// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
        if (!pdwParams)
            return 0;      // cannot do anything

        return fufmCmdXMove(pFufmPDEV, pdwParams);
        // no break

      case CMDID_Y_MOVE:
		// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
        if (!pdwParams)
            return 0;      // cannot do anything

        return fufmCmdYMove(pFufmPDEV, pdwParams);
        // no break

      case CMDID_SEND_BLOCK:
		// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
        if (!pdwParams)
            return 0;      // cannot do anything

        fufmCmdSendBlock(pdevobj, pdwParams);
        break;

      case CMDID_FONTATTR_BOLD_OFF:            pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_BOLD;                    break;
      case CMDID_FONTATTR_BOLD_ON:            pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_BOLD;                    break;
      case CMDID_FONTATTR_ITALIC_OFF:        pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_ITALIC;                break;
      case CMDID_FONTATTR_ITALIC_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_ITALIC;                break;
      case CMDID_FONTATTR_UNDERLINE_OFF:    pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_UNDERLINE;            break;
      case CMDID_FONTATTR_UNDERLINE_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_UNDERLINE;                break;
      case CMDID_FONTATTR_STRIKEOUT_OFF:    pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_STRIKEOUT;            break;
      case CMDID_FONTATTR_STRIKEOUT_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_STRIKEOUT;                break;

// #251047: overlaps SBCS on vert mode
      case CMDID_SELECTSINGLE: {
        PBYTE   pb;
        BYTE    ab[256];
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
		size_t	sizeRem = sizeof(ab);

        pb = ab;
        pb = fufmPutCommand(pb, sizeRem, &sizeRem, &g_cmdSingleMode);
		if (!pb) return 0;


// #284409: SBCS rotated on vert mode
//      if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT)
//          pb = fufmPutCommand(pb, &g_cmdHWF);
        if (pb > ab)
            WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
        break;
      }
      case CMDID_SELECTDOUBLE: {
        PBYTE   pb;
        BYTE    ab[256];
		// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
		size_t	sizeRem = sizeof(ab);


        pb = ab;
        pb = fufmPutCommand(pb, sizeRem, &sizeRem, &g_cmdDoubleMode);
		if (!pb)	return 0;

// #284409: SBCS rotated on vert mode
//      if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT)
//          pb = fufmPutCommand(pb, &g_cmdVWF);
        if (pb > ab)
            WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
        break;
      }

// PAGE_SETUP.1
      case CMDID_START_PAGE:                fufmCmdStartPage(pdevobj);                                                    break;

// DOC_SETUP.1
      case CMDID_SIZE_REDUCTION_100:        pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_100;                break;
      case CMDID_SIZE_REDUCTION_75:            pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_75;                break;
      case CMDID_SIZE_REDUCITON_70:            pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_70;                break;

// DOC_SETUP.2
      case CMDID_RESOLUTION_240:            pFufmPDEV->reqData.dwResolution = FUFM_RESOLUTION_240;                        break;
      case CMDID_RESOLUTION_400:            pFufmPDEV->reqData.dwResolution = FUFM_RESOLUTION_400;                        break;

// DOC_SETUP.3
      case CMDID_ORIENTATION_PORTRAIT:        pFufmPDEV->reqData.dwPaperOrientation = FUFM_PAPERORIENTATION_PORTRAIT;        break;
      case CMDID_ORIENTATION_LANDSCAPE:        pFufmPDEV->reqData.dwPaperOrientation = FUFM_PAPERORIENTATION_LANDSCAPE;    break;

// DOC_SETUP.4
      case CMDID_PAPERSOURCE_AUTO:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_AUTO;                    break;
      case CMDID_PAPERSOURCE_MANUAL:        pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_MANUAL;                    break;
      case CMDID_PAPERSOURCE_BIN1:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN1;                    break;
      case CMDID_PAPERSOURCE_BIN2:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN2;                    break;
      case CMDID_PAPERSOURCE_BIN3:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN3;                    break;
 
// DOC_SETUP.5
      case CMDID_FORM_A3:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A3;                            break;
      case CMDID_FORM_A4:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A4;                            break;
      case CMDID_FORM_A5:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A5;                            break;
      case CMDID_FORM_B4:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_B4;                            break;
      case CMDID_FORM_B5:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_B5;                            break;
      case CMDID_FORM_LETTER:                pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_LETTER;                        break;
      case CMDID_FORM_LEGAL:                pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_LEGAL;                        break;
      case CMDID_FORM_JAPANESE_POSTCARD:        pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_JAPANESE_POSTCARD;            break;

// DOC_SETUP.6
// @Aug/31/98 ->
    case CMDID_COPIES:
		// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
        if (!pdwParams)
            return 0;      // cannot do anything

        if (MAX_COPIES_VALUE < pdwParams[0]) {
            pFufmPDEV->reqData.dwCopies = MAX_COPIES_VALUE;
        }
        else if (1 > pdwParams[0]) {
            pFufmPDEV->reqData.dwCopies = 1;
        }
        else {
            pFufmPDEV->reqData.dwCopies = pdwParams[0];
        }
// @Aug/31/98 <-
break;

// DOC_SETUP.7
      case CMDID_START_DOC:                    fufmCmdStartDoc(pdevobj);                                                    break;

// JOB_SETUP.1
      case CMDID_START_JOB_0:                pFufmPDEV->dwFlags = 0;                                                        break;
      case CMDID_START_JOB_1:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_1;                                    break;
      case CMDID_START_JOB_2:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_2;                                    break;
      case CMDID_START_JOB_3:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_3;                                    break;
      case CMDID_START_JOB_4:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_4;                                    break;

// JOB_SETUP.2
      case CMDID_EMMODE_FM:                    fufmCmdEmMode(pdevobj, FUFM_EMMODE_FM);                                        break;
      case CMDID_EMMODE_ESCP:                fufmCmdEmMode(pdevobj, FUFM_EMMODE_ESCP);                                    break;

// JOB_FINISH.1
      case CMDID_END_JOB:                    fufmCmdEndJob(pdevobj);                                                        break;
    }
    return 0;
}



void fufmGetPaperSize(PFUFMPDEV pFufmPDEV, const GDIINFO* pGdiInfo)
{
    pFufmPDEV->dwPaperWidth = pGdiInfo->ulHorzSize;
    if((LONG)pFufmPDEV->dwPaperWidth < 0)
        pFufmPDEV->dwPaperWidth = (-(LONG)pFufmPDEV->dwPaperWidth + 500) / 1000;

    pFufmPDEV->dwPaperLength = pGdiInfo->ulVertSize;
    if((LONG)pFufmPDEV->dwPaperLength < 0)
        pFufmPDEV->dwPaperLength = (-(LONG)pFufmPDEV->dwPaperLength + 500) / 1000;

    VERBOSE(("paper size %u %u\r\n", pFufmPDEV->dwPaperWidth, pFufmPDEV->dwPaperLength))
    VERBOSE(("printable area %u %u\r\n", pGdiInfo->ulHorzRes, pGdiInfo->ulVertRes))

    pFufmPDEV->cyPage = (int)pGdiInfo->ulVertRes;
}



void fufmInitData(PFUFMDATA pDev)
{
    pDev->dwSizeReduction        = FUFM_SIZE_REDUCTION_UNKNOWN;
    pDev->dwResolution            = FUFM_RESOLUTION_UNKNOWN;
    pDev->dwPaperSize            = FUFM_PAPERSIZE_UNKNOWN;
    pDev->dwPaperSource            = FUFM_PAPERSOURCE_UNKNOWN;
    pDev->dwPaperOrientation    = FUFM_PAPERORIENTATION_UNKNOWN;
    pDev->dwCopies                = (DWORD)-1;        // UNKNOWN
    pDev->dwFontAttributes        = 0;
}




// MINI5 Export func.
PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ            pdevobj,
    PWSTR            pPrinterName,
    ULONG            cPatterns,
    HSURF*            phsurfPatterns,
    ULONG            cjGdiInfo,
    GDIINFO*        pGdiInfo,
    ULONG            cjDevInfo,
    DEVINFO*        pDevInfo,
    DRVENABLEDATA*    pded
    )
{
    PFUFMPDEV pFufmPDEV;

    DDI_VERBOSE(("[OEMEnablePDEV]" __DATE__ " " __TIME__ "\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("Invalid parameter(s).\n"));
        return NULL;
    }

    pFufmPDEV = (PFUFMPDEV)MemAlloc(sizeof(FUFMPDEV));
    if(pFufmPDEV != NULL){
        pFufmPDEV->dwSignature = FUFM_OEM_SIGNATURE;
        pFufmPDEV->emMode = FUFM_EMMODE_FM;
        pFufmPDEV->dwFlags = 0;

        pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
        pFufmPDEV->x = 0;
        pFufmPDEV->y = 0;
        pFufmPDEV->iLinefeedSpacing = 0;

VERBOSE(("paper size %u %u\r\n", pGdiInfo->szlPhysSize.cx, pGdiInfo->szlPhysSize.cy))
        fufmGetPaperSize(pFufmPDEV, pGdiInfo);
        fufmInitData(&pFufmPDEV->devData);
        fufmInitData(&pFufmPDEV->reqData);
    }
    return pFufmPDEV;
}



// MINI5 Export func.
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;
    DDI_VERBOSE(("[OEMDisablePDEV]\r\n"));

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobj)
    {
        ERR(("Invalid parameter(s).\n"));
        return;
    }

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return;

    MemFree(pdevobj->pdevOEM);
    pdevobj->pdevOEM = NULL;
}



// MINI5 Export func.
BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    PFUFMPDEV pFufmPDEVOld;
    PFUFMPDEV pFufmPDEVNew;

    DDI_VERBOSE(("[OEMResetPDEV]\r\n"))

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if (NULL == pdevobjOld || NULL == pdevobjNew)
    {
        ERR(("Invalid parameter(s).\n"));
        return FALSE;
    }

    pFufmPDEVOld = (PFUFMPDEV)pdevobjOld->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEVOld) == FALSE)
        return FALSE;

    pFufmPDEVNew = (PFUFMPDEV)pdevobjNew->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEVNew) == FALSE)
        return FALSE;

    pFufmPDEVNew->devData = pFufmPDEVOld->devData;

    return TRUE;
}


// MINI5 Export func.
// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Error handling
BOOL APIENTRY bOEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ    pUFObj,
    DWORD        dwType,
    DWORD        dwCount,
    PVOID        pGlyph
    )
{
    PFUFMPDEV        pFufmPDEV;
    GETINFO_GLYPHSTRING glyphStr;
    PBYTE        pb;
    BYTE        abBuff[256];
// #333653: Change I/F for GETINFO_GLYPHSTRING
    PTRANSDATA    pTrans, aTrans;
    DWORD        i;
    DWORD        cbNeeded;
    PDWORD        pdwGlyphID;
    INT        cxfont;        //#144637
// #284409: SBCS rotated on vert mode
    BYTE        ab[16];
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	size_t		sizeRem = sizeof(abBuff);

    DDI_VERBOSE(("[OEMOutputCharStr]\r\n"))

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj)
    {
        ERR(("bOEMOutputCharStr: Invalid parameter(s).\n"));
        return FALSE;
    }

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return FALSE;

    pb = abBuff;
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
    pb = fufmUpdatePosition(pb, sizeRem, &sizeRem, pFufmPDEV);
	if (!pb) return FALSE;

	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
    pb = fufmUpdateFontAttributes(pb, sizeRem, &sizeRem, pFufmPDEV);
	if (!pb) return FALSE;

    if(pb > abBuff){
        WRITESPOOLBUF(pdevobj, abBuff, (DWORD)(pb - abBuff));
    }

    switch(dwType){
      case TYPE_GLYPHHANDLE:
          VERBOSE(("TYPE_GLYPHHANDLE\r\n"))
          glyphStr.dwSize = sizeof(glyphStr);
          glyphStr.dwCount = dwCount;
          glyphStr.dwTypeIn = TYPE_GLYPHHANDLE;
          glyphStr.pGlyphIn = pGlyph;
          glyphStr.dwTypeOut = TYPE_TRANSDATA;
// #333653: Change I/F for GETINFO_GLYPHSTRING
          glyphStr.pGlyphOut = NULL;
          glyphStr.dwGlyphOutSize = 0;
          if(pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &glyphStr, sizeof(glyphStr), &cbNeeded) || !glyphStr.dwGlyphOutSize){
              VERBOSE(("UFO_GETINFO_GLYPHSTRING error\r\n"))
              return FALSE;
          }
          if((aTrans = (PTRANSDATA)MemAlloc(glyphStr.dwGlyphOutSize)) == NULL) {
              VERBOSE(("MemAlloc fail\r\n"))
              return FALSE;
          }
          glyphStr.pGlyphOut = aTrans;
          if(FALSE == pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &glyphStr, sizeof(glyphStr), &cbNeeded)){
              VERBOSE(("UFO_GETINFO_GLYPHSTRING error\r\n"))
              goto out;
          }
        pTrans = aTrans;
        cxfont = pFufmPDEV->cxfont;    //#144637
        for(i = dwCount; i > 0; --i){
            VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x ubType:0x%x\r\n", pTrans->ubCodePageID, pTrans->ubType))
            switch(pTrans->ubType & (MTYPE_FORMAT_MASK | MTYPE_DOUBLEBYTECHAR_MASK)){
              case MTYPE_DIRECT:
              case MTYPE_DIRECT | MTYPE_SINGLE:
              case MTYPE_DIRECT | MTYPE_DOUBLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED) {
						  // NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
                          pb = fufmPutCommand(ab, sizeRem, &sizeRem, &g_cmdHWF);
						  if (!pb) return FALSE;

                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
                pFufmPDEV->x += (cxfont / 2);    //#144637
                  break;
              case MTYPE_PAIRED:
              case MTYPE_PAIRED | MTYPE_DOUBLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (!(pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED)) {
						  // NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
                          pb = fufmPutCommand(ab, sizeRem, &sizeRem, &g_cmdVWF);
						  if (!pb) return FALSE;

                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags |= FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
                pFufmPDEV->x += cxfont;    //#144637
                  break;
              case MTYPE_PAIRED | MTYPE_SINGLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED) {
						  // NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf

                          pb = fufmPutCommand(ab, sizeRem, &sizeRem, &g_cmdHWF);
						  if (!pb) return FALSE;

                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubPairs[1], 1);
                pFufmPDEV->x += (cxfont / 2);    //#144637
                  break;
            }
            ++pTrans;
        }
out:
          MemFree(aTrans);
          break;
      case TYPE_GLYPHID:
          VERBOSE(("TYPE_GLYPHID\r\n"))
          pdwGlyphID = (PDWORD)pGlyph;
        for(i = dwCount; i > 0; --i){
            VERBOSE(("TYPE_GLYPHID:0x%x\r\n", *pdwGlyphID))
            WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
            ++pdwGlyphID;
        }
        break;
      case TYPE_TRANSDATA:
          VERBOSE(("TYPE_TRANSDATA\r\n"))
          break;
      case TYPE_UNICODE:
          VERBOSE(("TYPE_UNICODE\r\n"))
          break;
    }

	return TRUE;
}


// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Error handling
BOOL APIENTRY bOEMSendFontCmd(
    PDEVOBJ            pdevobj,
    PUNIFONTOBJ        pUFObj,
    PFINVOCATION    pFInv
    )
{
    PFUFMPDEV        pFufmPDEV;
    enum { CB_STDVAR_2 = sizeof(GETINFO_STDVAR) + sizeof(DWORD) * 2 * (2 - 1) };
    PGETINFO_STDVAR pSV;
    DWORD            adwStdVarBuff[(CB_STDVAR_2 + sizeof(DWORD) - 1) / sizeof(DWORD)];
    DWORD            cbNeeded;
    DWORD            i;
    LONG            cxFont;
    LONG            cyFont;
    DWORD            dwResolution;
    PBYTE            pbCmd;
    BYTE            abCmd[256];
    PIFIMETRICS		pIFI;
	// NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
	size_t			sizeRem = sizeof(abCmd);

	// NTRAID#NTBUG9-587382-2002/03/27-v-sueyas-: Check for illegal parameters
    if(NULL == pdevobj || NULL == pUFObj || NULL == pFInv)
    {
        ERR(("bOEMSendFontCmd: Invalid parameter(s).\n"));
        return FALSE;
    }

    pIFI = pUFObj->pIFIMetrics;

#define SV_HEIGHT (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH (pSV->StdVar[1].lStdVariable)

    DDI_VERBOSE(("[OEMSendFontCmd]FontID:%d dwFlags:%x\r\n", pUFObj->ulFontID, pUFObj->dwFlags))


    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return FALSE;

    pSV = (PGETINFO_STDVAR)adwStdVarBuff;
    pSV->dwSize = CB_STDVAR_2;
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &cbNeeded)) {
        VERBOSE(("UFO_GETINFO_STDVARIABLE failed.\r\n"))
        return FALSE;
    }

    VERBOSE(("FNT_INFO_FONTHEIGHT %d\r\n", pSV->StdVar[0].lStdVariable))
    VERBOSE(("FNT_INFO_FONTWIDTH  %d\r\n", pSV->StdVar[1].lStdVariable))

    // this printer requires DBCS cell (square, if not stretched)
    // X/Y sizes as X/Y values for scalable font command.

    cyFont = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pSV->StdVar[0].lStdVariable);
    cxFont = cyFont
        * SV_WIDTH * FH_IFI(pIFI) / SV_HEIGHT / FW_IFI(pIFI);

    pFufmPDEV->cxfont = cxFont;    //#144637

    dwResolution = pFufmPDEV->devData.dwResolution;

    VERBOSE(("dwResolution %u cxFont %u cyFont %u\r\n", dwResolution, cxFont, cyFont))

    pbCmd = abCmd;
    for(i = 0; i < pFInv->dwCount; ++i){
        switch(pFInv->pubCommand[i]){
          case 'a': // 7point non scalable font
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmd7Point);
			  if (!pbCmd)return FALSE;
              pbCmd = fufmPutCP(pbCmd, sizeRem, &sizeRem, (dwResolution != 400)? 24: 40);
			  if (!pbCmd)return FALSE;
              break;
          case 'b': // 9point non scalable font
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmd9Point);
			  if (!pbCmd)return FALSE;
              pbCmd = fufmPutCP(pbCmd, sizeRem, &sizeRem, (dwResolution != 400)? 30: 50);
			  if (!pbCmd)return FALSE;
              break;
          case 'c': // 10.5point non scalable font
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmd10halfPoint);
			  if (!pbCmd)return FALSE;
              pbCmd = fufmPutCP(pbCmd, sizeRem, &sizeRem, (dwResolution != 400)? 36: 60);
			  if (!pbCmd)return FALSE;
              break;
          case 'd':    // 12point non scalable font
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmd12Point);
			  if (!pbCmd)return FALSE;
              pbCmd = fufmPutCP(pbCmd, sizeRem, &sizeRem, (dwResolution != 400)? 40: 66);
			  if (!pbCmd)return FALSE;
              break;

          case 's':    // scalable font
              if (cyFont == cxFont) {
				  // NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
				  pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1BQ%u!R", cyFont);
				  if (NULL == pbCmd)	return FALSE;
              }
              else {
				  // NTRAID#NTBUG9-590135-2002/04/01-v-sueyas-: Possible buffer overrun risk similar to sprintf
				  pbCmd = fufmFormatCommand(pbCmd, sizeRem, &sizeRem, "\x1BQ%u;%u!R", cyFont, cxFont);
				  if (NULL == pbCmd)	return FALSE;
              }
              pbCmd = fufmPutCP(pbCmd, sizeRem, &sizeRem, cxFont);
			  if (!pbCmd)return FALSE;
              break;

          case 'H':    // HWF
              pFufmPDEV->dwFlags &= ~FUFM_FLAG_VERTICALFONT;
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmdHWF);
			  if (!pbCmd)return FALSE;
// #284409: SBCS rotated on vert mode
              pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
              break;
          case 'V':    // VWF
              pFufmPDEV->dwFlags |= FUFM_FLAG_VERTICALFONT;
// #284409: SBCS rotated on vert mode
              // pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmdVWF);
			  // if (!pbCmd)return FALSE;
              break;

          case 'M':    // Minchou
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmdMinchou);
			  if (!pbCmd)return FALSE;
              break;
          case 'G':    // Gothic
              pbCmd = fufmPutCommand(pbCmd, sizeRem, &sizeRem, &g_cmdGothic);
			  if (!pbCmd)return FALSE;
              break;
        }
    }
    if(pbCmd > abCmd)
        WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));

	return TRUE;
}


// end of fmlbpres.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbpdm.c ===
///////////////////////////////////////////////////
// fmlbpdm.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fmlbp.h"
#include "fmdebug.h"

#ifdef KERNEL_MODE

#define	SETLASTERROR(e)	EngSetLastError(e)

#else // !KERNEL_MODE

#define	SETLASTERROR(e)	SetLastError(e)

#endif // !KERNEL_MODE


// MINI5 Export func.
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
	VERBOSE(("[OEMGetInfo]\r\n"))

	if(pcbNeeded == NULL){
  		SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

  	*pcbNeeded = sizeof(DWORD);
  	if(NULL == pBuffer || sizeof(DWORD) > cbSize){
  		SETLASTERROR(ERROR_INSUFFICIENT_BUFFER);
  		return FALSE;
  	}

	switch(dwInfo){
	  case OEMGI_GETSIGNATURE:
		VERBOSE(("OEMGI_GETSIGNATURE\r\n"))
	  	*(LPDWORD)pBuffer = FUFM_OEM_SIGNATURE;
	  	break;
	  case OEMGI_GETINTERFACEVERSION:
		VERBOSE(("OEMGI_GETINTERFACEVERSION\r\n"))
	  	*(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
	  	break;
	  case OEMGI_GETVERSION:
		VERBOSE(("OEMGI_GETVERSION\r\n"))
	  	*(LPDWORD)pBuffer = FUFM_OEM_VERSION;
	  	break;
	  default:
		VERBOSE(("invalid dwInfo\r\n"))
	  	SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	return TRUE;
}



static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    if(NULL == pOEMDevModeParam){
    	VERBOSE(("pOEMDevModeParam is NULL\r\n"))
    	return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize){
    	VERBOSE(("pOEMDevModeParam->cbSize (%d) is less than sizeof(OEMDMPARAM)\r\n", pOEMDevModeParam->cbSize))
        return FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter){
		VERBOSE(("pOEMDevModeParam->hPrinter is NULL\r\n"))
		return FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule){
		VERBOSE(("pOEMDevModeParam->hModule is NULL\r\n"))
        return FALSE;
    }

    if((0 != pOEMDevModeParam->cbBufSize) && (NULL == pOEMDevModeParam->pOEMDMOut)){
		VERBOSE(("pOEMDevModeParam->cbBufSize is not 0, and, pOEMDMOut is NULL\r\n"))
		return FALSE;
    }

    if((OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn)){
		VERBOSE(("dwMode is OEMDM_MERGE && pOEMDMIn is NULL\r\n"))
		return FALSE;
    }

    return TRUE;
}



static void fufmInitOEMExtraData(PFUFM_OEM_EXTRADATA pFufmOEMExtra)
{
	pFufmOEMExtra->dmExtraHdr.dwSize = sizeof(FUFM_OEM_EXTRADATA);
	pFufmOEMExtra->dmExtraHdr.dwSignature = FUFM_OEM_SIGNATURE;
	pFufmOEMExtra->dmExtraHdr.dwVersion = FUFM_OEM_VERSION;
}



static void fufmMergeOEMExtraData(
	PFUFM_OEM_EXTRADATA pFufmOEMExtraIn,
	PFUFM_OEM_EXTRADATA pFufmOEMExtraOut)
{
}



// MINI5 Export func.
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
	VERBOSE(("[OEMDevMode]\r\n"))

	if(BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam) == FALSE){
		VERBOSE(("invalid OEMDevModeParam\r\n"))
		SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if(dwMode == OEMDM_SIZE){
		pOEMDevModeParam->cbBufSize = sizeof(FUFM_OEM_EXTRADATA);
		VERBOSE(("OEMDM_SIZE %d\r\n", pOEMDevModeParam->cbBufSize))
		return TRUE;
	}

	if(sizeof(FUFM_OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize){
		VERBOSE(("cbBufSize %d\r\n", pOEMDevModeParam->cbBufSize))
  		SETLASTERROR(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	switch(dwMode){
	  case OEMDM_DEFAULT:
		VERBOSE(("OEMDM_DEFAULT\r\n"));
	  	fufmInitOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_CONVERT:
		VERBOSE(("OEMDM_CONVERT\r\n"));
	  	fufmInitOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_MERGE:
		VERBOSE(("OEMDM_MERGE\r\n"));
		fufmMergeOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
							(PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  default:
		VERBOSE(("invalid dwMode\r\n"));
	  	SETLASTERROR(ERROR_INVALID_PARAMETER);
	  	return FALSE;
	  	break;
	}
	return TRUE;
}



// end of fmlbpdm.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\name.h ===
CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=fmlbpres
TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(PRNROOT)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),fmlbpres
!else
DLLBASE=0x8000000
!endif

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fmlbpres.rc \
    $(SRCDIR)\fmlbpres.c \
    $(SRCDIR)\fmlbpdm.c \
    $(SRCDIR)\fmdebug.c

MISCFILES=\
    $(SRCDIR)\fmlbpres.ini \
    $(GPDDIR)\fufm101j.gpd \
    $(GPDDIR)\fufm102j.gpd \
    $(GPDDIR)\fufm111j.gpd \
    $(GPDDIR)\fufm112j.gpd \
    $(GPDDIR)\fufm114j.gpd \
    $(GPDDIR)\fufm115j.gpd \
    $(GPDDIR)\fufm121j.gpd \
    $(GPDDIR)\fufm12aj.gpd \
    $(GPDDIR)\fufm14aj.gpd \
    $(GPDDIR)\fufm15aj.gpd \
    $(GPDDIR)\fufm212j.gpd \
    $(GPDDIR)\fufm21pj.gpd \
    $(GPDDIR)\fufm222j.gpd \
    $(GPDDIR)\fufm224j.gpd \
    $(GPDDIR)\fufm226j.gpd \
    $(GPDDIR)\fufm227j.gpd \
    $(GPDDIR)\fufm22aj.gpd \
    $(GPDDIR)\fufm23dj.gpd \
    $(GPDDIR)\fufm3d2j.gpd \
    $(GPDDIR)\fufmlbpj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\fuprjres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
// 08/08/94 Wrote it. by Hayakawa, Task.
//

#define _FUPRJRES_C
#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

/***************************************************************************
    Function Name : SheetFeed

    Parameters    : LPDV	lpdv		Private Device Structure

    Note          : Make this.                               09/13/94 Task
***************************************************************************/
void SheetFeed(
PDEVOBJ pdevobj
){
	USHORT 				bFirstPage;
	DEVICE_DATA *pOEM;
    DWORD dwResult;

	//
	// verify pdevobj okay
	//
	if( !VALID_PDEVOBJ(pdevobj) ) return;
	pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

	bFirstPage = (USHORT)pOEM->bFirstPage;

	if ((pOEM->wPaperSource == DMBIN_180BIN1) ||
		(pOEM->wPaperSource == DMBIN_180BIN2) ||
		(pOEM->wPaperSource == DMBIN_360BIN1) ||
		(pOEM->wPaperSource == DMBIN_360BIN2) ||
		(pOEM->wPaperSource == DMBIN_SUIHEI_BIN1) ||
		(pOEM->wPaperSource == DMBIN_TAMOKUTEKI_BIN1) ||
		(pOEM->wPaperSource == DMBIN_FI_FRONT)) {

		WRITESPOOLBUF(pdevobj, ecCSFBPAGE.pEscStr, ecCSFBPAGE.cbSize, &dwResult);

	} else if ((pOEM->wPaperSource == DMBIN_TRACTOR) ||
			(pOEM->wPaperSource == DMBIN_FI_TRACTOR)) {

		WRITESPOOLBUF(pdevobj, ecTRCTBPAGE.pEscStr, ecTRCTBPAGE.cbSize, &dwResult);

	} else if ((pOEM->wPaperSource == DMBIN_MANUAL) &&
						(!bFirstPage)) {

		WRITESPOOLBUF(pdevobj, ecManual2P.pEscStr, ecManual2P.cbSize, &dwResult);
		pOEM->bFirstPage = FALSE;

	}

	WRITESPOOLBUF(pdevobj,"\x0D", 1, &dwResult);
	if (bFirstPage) pOEM->bFirstPage = FALSE;
}
/***************************************************************************
    Function Name : OEMSendFontCmd

    Note          : Make this.                               09/26/97
***************************************************************************/
VOID APIENTRY OEMSendFontCmd(
PDEVOBJ			pdevobj,
PUNIFONTOBJ		pUFObj,
PFINVOCATION	pFInv)
{
    DWORD dwResult;

	WRITESPOOLBUF(pdevobj,pFInv->pubCommand, pFInv->dwCount, &dwResult);
}
/***************************************************************************
    Function Name : OEMCommandCallback

    Note          : Make this.                               09/26/97
***************************************************************************/
INT APIENTRY OEMCommandCallback(
PDEVOBJ pdevobj,
DWORD   dwCmdCbID,
DWORD   dwCount,
PDWORD  pdwParams
){
	USHORT 				bFirstPage;
	DEVICE_DATA *pOEM;
    DWORD dwResult;

	//
	// verify pdevobj okay
	//
	//ASSERT(VALID_PDEVOBJ(pdevobj));
	if( !VALID_PDEVOBJ(pdevobj) ) return 0;
	pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

	bFirstPage = (USHORT)pOEM->bFirstPage;

	switch (dwCmdCbID) {

	case CMDID_ENDDOC :
		WRITESPOOLBUF(pdevobj,ecFMEnddoc.pEscStr,ecFMEnddoc.cbSize, &dwResult);
		break;

	case CMDID_BEGINDOC :
		pOEM->bFirstPage   = 1;
		pOEM->wPaperSource = 0;
// NTRAID#NTBUG9-588420-2002/04/09-yasuho-: Device "Mincho" can not print out.
		pOEM->jColor = TEXT_COLOR_BANDW;
		break;

	case CMDID_MAN180 :
	case CMDID_MAN360 :
		pOEM->wPaperSource = DMBIN_MANUAL;
		SheetFeed(pdevobj);
		break;

	case CMDID_TRA180 :
		pOEM->wPaperSource = DMBIN_TRACTOR;
		SheetFeed(pdevobj);
		break;

	case CMDID_180BIN1 :
		if (pOEM->wPaperSource != DMBIN_180BIN1) {
			pOEM->wPaperSource = DMBIN_180BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_180BIN2 :
		if (pOEM->wPaperSource != DMBIN_180BIN2) {
			pOEM->wPaperSource = DMBIN_180BIN2;
			WRITESPOOLBUF(pdevobj, ecSelectBIN2.pEscStr, ecSelectBIN2.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_360BIN1 :
		if (pOEM->wPaperSource != DMBIN_360BIN1) {
			pOEM->wPaperSource = DMBIN_360BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_360BIN2 :
		if (pOEM->wPaperSource != DMBIN_360BIN2) {
			pOEM->wPaperSource = DMBIN_360BIN2;
			WRITESPOOLBUF(pdevobj, ecSelectBIN2.pEscStr, ecSelectBIN2.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_FI_TRACTOR :
		if (pOEM->wPaperSource != DMBIN_FI_TRACTOR) {
			pOEM->wPaperSource = DMBIN_FI_TRACTOR;
			WRITESPOOLBUF(pdevobj, ecSelectFTRCT.pEscStr, ecSelectFTRCT.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_FI_FRONT :
		if (pOEM->wPaperSource != DMBIN_FI_FRONT) {
			pOEM->wPaperSource = DMBIN_FI_FRONT;
			WRITESPOOLBUF(pdevobj, ecSelectFFRNT.pEscStr, ecSelectFFRNT.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_SUIHEI_BIN1 :
		if (pOEM->wPaperSource != DMBIN_SUIHEI_BIN1) {
			pOEM->wPaperSource = DMBIN_SUIHEI_BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_TAMOKUTEKI_BIN1 :
		if (pOEM->wPaperSource != DMBIN_TAMOKUTEKI_BIN1) {
			pOEM->wPaperSource = DMBIN_TAMOKUTEKI_BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_BEGINPAGE :
                // Assume it is not safe to think color settings
                // are carried over pages.
                SetRibbonColor(pdevobj, TEXT_COLOR_UNKNOWN);
		break;


	case CMDID_ENDPAGE :

		if ((pOEM->wPaperSource == DMBIN_180BIN1) ||
			(pOEM->wPaperSource == DMBIN_180BIN2) ||
			(pOEM->wPaperSource == DMBIN_360BIN1) ||
			(pOEM->wPaperSource == DMBIN_360BIN2) ||
			(pOEM->wPaperSource == DMBIN_SUIHEI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_TAMOKUTEKI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_FI_FRONT)) {
			WRITESPOOLBUF(pdevobj, ecCSFEPAGE.pEscStr, ecCSFEPAGE.cbSize, &dwResult);
		}
		break;
        case CMDID_SELECT_BLACK_COLOR:
            pOEM->jColor = TEXT_COLOR_BLACK;
            break;
        case CMDID_SELECT_BLUE_COLOR:
            pOEM->jColor = TEXT_COLOR_BLUE;
            break;
        case CMDID_SELECT_CYAN_COLOR:
            pOEM->jColor = TEXT_COLOR_CYAN;
            break;
        case CMDID_SELECT_GREEN_COLOR:
            pOEM->jColor = TEXT_COLOR_GREEN;
            break;
        case CMDID_SELECT_MAGENTA_COLOR:
            pOEM->jColor = TEXT_COLOR_MAGENTA;
            break;
        case CMDID_SELECT_RED_COLOR:
            pOEM->jColor = TEXT_COLOR_RED;
            break;
        case CMDID_SELECT_WHITE_COLOR:
            // Should not happen
            pOEM->jColor = TEXT_COLOR_UNKNOWN;
            break;
        case CMDID_SELECT_YELLOW_COLOR:
            pOEM->jColor = TEXT_COLOR_YELLOW;
            break;
        case CMDID_SEND_BLACK_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_BLACK);
            break;
        case CMDID_SEND_CYAN_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_CYAN);
            break;
        case CMDID_SEND_MAGENTA_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_MAGENTA);
            break;
        case CMDID_SEND_YELLOW_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_YELLOW);
            break;
	} /* end switch */

    return 0;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    DEVICE_DATA *pTemp;
    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));
	if(!pdevobj) return NULL;

    // Set minidriver PDEV address.

    pTemp = (DEVICE_DATA *)MemAllocZ(sizeof(DEVICE_DATA));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        return NULL;
    }
    pTemp->bFirstPage = TRUE;

    pdevobj->pdevOEM = (MINIDEV *)MemAllocZ(sizeof(MINIDEV));
    if (NULL == pdevobj->pdevOEM) {
        ERR(("Memory allocation failure.\n"));
		MemFree(pTemp);
        return NULL;
    }
    MINIDEV_DATA(pdevobj) = (PDEVOEM)pTemp;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

    if ( NULL != pdevobj->pdevOEM ) {

        if (MINIDEV_DATA(pdevobj)) {
            MemFree(MINIDEV_DATA(pdevobj));
        }
        MemFree( pdevobj->pdevOEM );
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    DEVICE_DATA *pOEMOld, *pOEMNew;

    pOEMOld = (DEVICE_DATA *)MINIDEV_DATA(pdevobjOld);
    pOEMNew = (DEVICE_DATA *)MINIDEV_DATA(pdevobjNew);

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

BOOL
myOEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               aubBuff;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    DEVICE_DATA *pOEM;
    DWORD dwResult;
    INT i;
    BYTE jColor;
    BOOL bBackTab;

    VERBOSE(("OEMOutputCharStr() entry.\n"));
	if( !VALID_PDEVOBJ(pdevobj) ) return FALSE;

    if(!pdevobj || !pUFObj || !pGlyph)
    {
        ERR(("OEMOutputCharStr: Invalid parameter.\n"));
        return FALSE;
    }

    pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        GStr.dwSize = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount = dwCount;
        GStr.dwTypeIn = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
//NTRAID#NTBUG9-333653-2002/03/25-hiroi-: Change I/F for GETINFO_GLYPHSTRING
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL) || !GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return FALSE;
        }
        if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)) )
        {
            ERR(("MemAlloc failed.\n"));
            return FALSE;
        }
        GStr.pGlyphOut = aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            goto out;
        }

        jColor = pOEM->jColor;

        VERBOSE(("jColor=%d\n", jColor));

// NTRAID#NTBUG9-588420-2002/04/09-yasuho-: Device "Mincho" can not print out.

        if (jColor == TEXT_COLOR_BANDW) {  // monochrome case.

            pTrans = (PTRANSDATA)aubBuff;

            // Send out text
            for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
            {
                switch (pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_DIRECT:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubCode, 1,
                        &dwResult);
                    break;

                case MTYPE_PAIRED:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[0], 1,
                        &dwResult);
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[1], 1,
                        &dwResult);
                    break;
                }
            }
            goto out;

        }

        // If old color can be used as it is,
        // use it first.

        jColor <<= 1;
        if (0 != (pOEM->jColor & pOEM->jOldColor)) {
            jColor &= ~(pOEM->jOldColor << 1);
            jColor |= 1;
        }

        for (i = 0; i < 5 && jColor > 0;
            i++, (jColor >>= 1)) {

            pTrans = (PTRANSDATA)aubBuff;

            // Check if we need to print this plane.
            if (!(jColor & 1))
                continue;

            // Check if we need to do back-tab
            bBackTab = (jColor > 1);
            if (bBackTab)
            {
                WRITESPOOLBUF(pdevobj,
                    "\x1BH", 2, &dwResult);
            }

            // Send out color select command
            switch (i)
            {
            case 0:
                // Same as before
                break;
            case 1:
                // Y
                SetRibbonColor(pdevobj, TEXT_COLOR_YELLOW);
                break;
            case 2:
                // M
                SetRibbonColor(pdevobj, TEXT_COLOR_MAGENTA);
                break;
            case 3:
                // C
                SetRibbonColor(pdevobj, TEXT_COLOR_CYAN);
                break;
            case 4:
                // K
                SetRibbonColor(pdevobj, TEXT_COLOR_BLACK);
                break;
            }

            // Send out text
            for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
            {
                switch (pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_DIRECT:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubCode, 1,
                        &dwResult);
                    break;

                case MTYPE_PAIRED:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[0], 1,
                        &dwResult);
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[1], 1,
                        &dwResult);
                    break;
                }
            }

            // Do back-tab for next plane
            if (bBackTab)
            {
                WRITESPOOLBUF(pdevobj,
                    "\x1C" "D\x1B[3g", 6,
                    &dwResult);
            }
        }
out:
        MemFree(aubBuff);
        break;
    }
    return TRUE;
}

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
	myOEMOutputCharStr(pdevobj,pUFObj,dwType,dwCount,pGlyph);
}

VOID
SetRibbonColor(
    PDEVOBJ pdevobj,
    BYTE jColor)
{
    DEVICE_DATA *pOEM;
    DWORD dwResult;

    pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

    switch (jColor)
    {
    case TEXT_COLOR_YELLOW:
        if (TEXT_COLOR_YELLOW != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                "\x1C*!s", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_YELLOW;
        }
        break;
    case TEXT_COLOR_MAGENTA:
        if (TEXT_COLOR_MAGENTA != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                 "\x1C*!u", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_MAGENTA;
        }
        break;
    case TEXT_COLOR_CYAN:
        if (TEXT_COLOR_CYAN != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                "\x1C*!v", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_CYAN;
        }
        break;
    case TEXT_COLOR_BLACK:
        if (TEXT_COLOR_BLACK != pOEM->jOldColor)
        {
             WRITESPOOLBUF(pdevobj,
                 "\x1C*!p", 4, &dwResult);
                 pOEM->jOldColor = TEXT_COLOR_BLACK;
        }
        break;
    case TEXT_COLOR_UNKNOWN:
        pOEM->jOldColor = TEXT_COLOR_UNKNOWN;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\common.c ===
#include "pdev.h" 

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//NOTICE-2002/03/25-hiroi-:
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/25-hiroi-:
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        bValid = FALSE;
    }

    return bValid;
}
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/25-hiroi-:
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
	// Initialize OEM Extra data.
	pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
	pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
	pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//NOTICE-2002/03/25-hiroi-:
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
	if(pdmIn) {
		//
		// copy over the private fields, if they are valid
		//
	}
	return TRUE;
}
/***************************************************************************
    Function Name : OEMGetInfo

    Note          : Make this.                               09/26/97
***************************************************************************/
BOOL APIENTRY OEMGetInfo(
DWORD dwInfo,
PVOID pBuffer,
DWORD cbSize,
PDWORD pcbNeeded
){
    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
	// wPaperSource + bFirstPage
    *pcbNeeded = sizeof(DWORD);

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (sizeof(DWORD) > cbSize) )
    {
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }
    return TRUE;
}
/***************************************************************************
    Function Name : OEMDevMode

    Note          : Make this.                               09/26/97
***************************************************************************/
BOOL APIENTRY OEMDevMode(
DWORD 			dwMode,
POEMDMPARAM 	pOEMDevModeParam
){
    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            return FALSE;
        }
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//

class IOemCB : public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        REFIID riid,
        PVOID *ppv)
    {
		if (NULL == ppv)
        	return E_NOINTERFACE;
        if (riid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown *>(this); 
        }
        else if (riid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni *>(this);
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (0 == InterlockedDecrement(&m_cRef))
        {
            delete this ;
            return 0;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\r\n")));
        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return E_FAIL;
    }

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\r\n")));
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemEngine methods
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\r\n")));

        return S_OK;
    }

    STDMETHODIMP
    DisableDriver()
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\r\n")));

        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
    }

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ pdevobj,
        PWSTR pPrinterName,
        ULONG cPatterns,
        HSURF *phsurfPatterns,
        ULONG cjGdiInfo,
        GDIINFO *pGdiInfo,
        ULONG cjDevInfo,
        DEVINFO *pDevInfo,
        DRVENABLEDATA *pded,
        PDEVOEM *pDevOem)
    {
        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj,
            pPrinterName, cPatterns, phsurfPatterns,
            cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //

        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;
        *pDevOem = pTemp;

        return S_OK;
    }

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE(((DLLTEXT("IOemCB::DisablePDEV() entry.\n"))));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n")));

        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(
                IID_IPrintOemDriverUni,
                (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }

        return S_OK;
    }

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
			(NULL == p1 ? "" : *((char **)p1)),
			(NULL == p2 ? "" : *((char **)p2)));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_FAIL;

		if (SUCCEEDED(StringCchLengthA(
             pMethodName, MAX_METHODNAME, NULL))) {
            PSTR pTemp;

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE(("GetImplementedMethod: %s - %d\n",
            pMethodName, lRet));

        return lRet;
    }

    STDMETHODIMP
    DriverDMS(
        PVOID pDevObj,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ     pdevobj,
        DWORD       dwCallbackID,
        DWORD       dwCount,
        PDWORD      pdwParams,
        OUT INT     *piResult)
    {
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\r\n")));
        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ pdevobj,
        PBYTE pSrcBitmap,
        PBITMAPINFOHEADER pBitmapInfoHeader,
        PBYTE pColorTable,
        DWORD dwCallbackID,
        PIPPARAMS pIPParams,
        PBYTE *ppbResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    Compression(
        PDEVOBJ pdevobj,
        PBYTE pInBuf,
        PBYTE pOutBuf,
        DWORD dwInLen,
        DWORD dwOutLen,
        INT *piResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ pdevobj,
        PBYTE pHTPattern,
        DWORD dwHTPatternX,
        DWORD dwHTPatternY,
        DWORD dwHTNumPatterns,
        DWORD dwCallbackID,
        PBYTE pResource,
        DWORD dwResourceSize)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ pdevobj,
        POEMMEMORYUSAGE pMemoryUsage)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ pdevobj,
        DWORD dwInfoIndex,
        PVOID pOutputBuf,
        DWORD dwSize,
        DWORD *pcbcNeeded)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH hGlyph,
        PDWORD pdwWidth,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD dwType,
        DWORD dwCount,
        PVOID pGlyph)
    {
        VERBOSE(("OutputCharStr\n"));
        if( myOEMOutputCharStr(pdevobj,pUFObj, dwType, dwCount, pGlyph) )
        	return S_OK;
		else
			return E_FAIL;
    }

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\r\n")));
        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    STDMETHODIMP
    TextOutAsBitmap(
       SURFOBJ *pso,
       STROBJ *pstro,
       FONTOBJ *pfo,
       CLIPOBJ *pco,
       RECTL *prclExtra,
       RECTL *prclOpaque,
       BRUSHOBJ *pboFore,
       BRUSHOBJ *pboOpaque,
       POINTL *pptlOrg,
       MIX mix)
    {
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};


//
// Make the Unidrv helper functions (defined in C++)
// accesible to C.
//

extern "C" {

    //
    // DrvWriteSpoolBuf()
    //
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pdevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult) {

            return ((IPrintOemDriverUni *)pIntf)->DrvWriteSpoolBuf(
                pdevobj,
                pBuffer,
                cbSize,
                pdwResult);
        }

}

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        REFIID riid,
        PVOID *ppv)
    {
	    if (NULL == ppv)
    	    return E_NOINTERFACE;
        if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (0 == InterlockedDecrement(&m_cRef))
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

    STDMETHODIMP
    CreateInstance(
        LPUNKNOWN pUnknownOuter,
        const IID& iid,
        void **ppv)
    {

        // Cannot aggregate.
        if (pUnknownOuter != NULL)
        {
            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (pOemCB == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr;
    }

    STDMETHODIMP
    LockServer(
        BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructors
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};


///////////////////////////////////////////////////////////
//
// Export functions
//

STDAPI
DllCanUnloadNow(
    VOID)
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
{
    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
    "CommandCallback",
    "DevMode",
    "DisableDriver",
    "DisablePDEV",
    "EnableDriver",
    "EnablePDEV",
    "GetImplementedMethod",
    "GetInfo",
    "OutputCharStr",
    "SendFontCmd",
};

// Maximum lenth of the method name which this plug-in has concern.
#define MAX_METHODNAME 21 // including terminating 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

MAJORCOMP=windows
MINORCOMP=md_fuprjres

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

RCCODEPAGE=932

TARGETNAME=fuprjres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fuprjres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fuprjres.rc \
    $(SRCDIR)\fuprjres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\fuprjres.ini \
    $(GPDDIR)\fuf180mj.gpd \
    $(GPDDIR)\fuf180cj.gpd \
    $(GPDDIR)\fuf372fj.gpd \
    $(GPDDIR)\fuf671fj.gpd \
    $(GPDDIR)\fuf371aj.gpd \
    $(GPDDIR)\fuf374fj.gpd \
    $(GPDDIR)\fuf672fj.gpd \
    $(GPDDIR)\fuf373mj.gpd \
    $(GPDDIR)\fuf373cj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuxlres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/
// NTRAID#NTBUG9-588590-2002/03/28-v-sueyas-: Correct the return values for each COM I/F methods

#define INITGUID // for GUID one-time initialization

#include "fuxl.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
#if 0
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
#if 0
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return E_FAIL;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return E_FAIL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    // OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    // OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\gpdres\fuprjres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

// NTRAID#NTBUG9-553889-2002/03/13-yasuho-: strsafe.h/PREFAST/buffy

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>
#include <strsafe.h>

#define OEM_DRIVER_VERSION 0x0500

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FMPR'      // FMPR printers
#define DLLTEXT(s)      "FMPR: " s
#define OEM_VERSION      0x00010000L

//------------------------------------------------------ FMPR private devmode

typedef struct tag_OEMUD_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    WORD wPaperSource;	// The current paper source
    BOOL bFirstPage;	// This is TRUE when First Page is Printing.
    BYTE jColor; // Current text color
    BYTE jOldColor; // Last ribbon color
} DEVICE_DATA;

//--------------------------------------------------------- command structure
typedef struct esccmd{
	WORD	cbSize;
	PBYTE	pEscStr;
} ESCCMD, FAR * PESCCMD;


#define LOCENTRY near pascal

//------------------------- Command callback id#s. for fmlbp GPC and PFM data
//------------------------- 1-255
#define CMDID_BEGINPAGE	1   // Entered in PAGECONTROL.PC_OCD_BEGINDOC as %1
#define CMDID_ENDPAGE	2
#define CMDID_BEGINDOC	3
#define CMDID_ENDDOC	4

#define CMDID_MIN24L	10
#define CMDID_MIN48H	11
#define CMDID_GOT48H	12
#define CMDID_MIN24LV	13
#define CMDID_U_MIN24LV	14
#define CMDID_MIN48HV	15
#define CMDID_U_MIN48HV	16
#define CMDID_GOT48HV	17
#define CMDID_U_GOT48HV	18

#define CMDID_MAN180	20
#define CMDID_TRA180	21
#define CMDID_180BIN1	22
#define CMDID_180BIN2	23
#define CMDID_MAN360	24
#define CMDID_360BIN1	25
#define CMDID_360BIN2	26
#define CMDID_FI_TRACTOR	27
#define CMDID_FI_FRONT		28
#define CMDID_SUIHEI_BIN1	29
#define CMDID_TAMOKUTEKI_BIN1	30

#define CMDID_SELECT_BLACK_COLOR 40
#define CMDID_SELECT_BLUE_COLOR 41
#define CMDID_SELECT_CYAN_COLOR 42
#define CMDID_SELECT_GREEN_COLOR 43
#define CMDID_SELECT_MAGENTA_COLOR 44
#define CMDID_SELECT_RED_COLOR 45
#define CMDID_SELECT_WHITE_COLOR 46
#define CMDID_SELECT_YELLOW_COLOR 47

#define CMDID_SEND_BLACK_COLOR 50
#define CMDID_SEND_CYAN_COLOR 51
#define CMDID_SEND_MAGENTA_COLOR 52
#define CMDID_SEND_YELLOW_COLOR 53

typedef unsigned short USHORT;
typedef WCHAR * PWSZ;     // pwsz, 0x0000 terminated UNICODE strings only

#ifdef _FUPRJRES_C
#define ESCCMDDEF(n,s) ESCCMD n = {sizeof(s)-1, s};
#else // _FUPRJRES_C
#define ESCCMDDEF(n,s) extern ESCCMD n;
#endif // _FUPRJRES_C

//------------------------------------------------- Paper Feed & Output Command
ESCCMDDEF(ecCSFBPAGE, "\x1BQ0 [")
ESCCMDDEF(ecCSFEPAGE, "\x1BQ1 [")
ESCCMDDEF(ecTRCTBPAGE, "\x1BQ22 B")
ESCCMDDEF(ecManual2P, "\x0C")

//--------------------------------------------------------- Char Select Command
ESCCMDDEF(ecDBCS, "\x1B$B")
ESCCMDDEF(ecSBCS, "\x1B(H")
ESCCMDDEF(ecVWF, "\x1CJ\x1BQ1 q")
ESCCMDDEF(ecHWF, "\x1CK")

//--------------------------------------------------------- mode change command
ESCCMDDEF(ecESCP2FM, "\x1B/\xB2@\x7F")
ESCCMDDEF(ecFM2ESCP, "\x1B\x7F\x00\x00\x01\x05")
ESCCMDDEF(ecFMEnddoc, "\x0D\x1B\x63")

//---------------------------------------------- font select & unselect command
ESCCMDDEF(ec24Min, "\x1C(a")
ESCCMDDEF(ec48Min, "\x1C(ap")
ESCCMDDEF(ec48Got, "\x1C(aq")
ESCCMDDEF(ec26Pitch, "\x1C$\x22v")
ESCCMDDEF(ec52Pitch, "\x1C$%r")
ESCCMDDEF(ecHankaku, "\x1BQ1\x20|")
ESCCMDDEF(ecTate1, "\x1CJ")
ESCCMDDEF(ecTate2, "\x1BQ1\x20q")
ESCCMDDEF(ecYoko, "\x1CK")

//---------------------------------------------- Paper Source Selection Command
ESCCMDDEF(ecSelectBIN1, "\x1BQ20\x20[")
ESCCMDDEF(ecSelectBIN2, "\x1BQ21\x20[")
ESCCMDDEF(ecSelectFTRCT, "\x1BQ10\x20\\")
ESCCMDDEF(ecSelectFFRNT, "\x1BQ11\x20