            12 // 0x40      
#define  SYNTAX_ID_MSMQ_NAME_STYLE                       8 // 0x1       
#define  SYNTAX_ID_MSMQ_NT4_FLAGS                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_NT4_STUB                         9 // 0x2       
#define  SYNTAX_ID_MSMQ_OS_TYPE                          9 // 0x2       
#define  SYNTAX_ID_MSMQ_OUT_ROUTING_SERVERS              1 // 0x7f      
#define  SYNTAX_ID_MSMQ_OWNER_ID                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_PREV_SITE_GATES                  1 // 0x7f      
#define  SYNTAX_ID_MSMQ_PRIVACY_LEVEL                    9 // 0xa       
#define  SYNTAX_ID_MSMQ_QM_ID                           10 // 0x4       
#define  SYNTAX_ID_MSMQ_QUEUE_JOURNAL_QUOTA              9 // 0x2       
#define  SYNTAX_ID_MSMQ_QUEUE_NAME_EXT                  12 // 0x40      
#define  SYNTAX_ID_MSMQ_QUEUE_QUOTA                      9 // 0x2       
#define  SYNTAX_ID_MSMQ_QUEUE_TYPE                      10 // 0x4       
#define  SYNTAX_ID_MSMQ_QUOTA                            9 // 0x2       
#define  SYNTAX_ID_MSMQ_RECIPIENT_FORMATNAME            12 // 0x40      
#define  SYNTAX_ID_MSMQ_ROUTING_SERVICE                  8 // 0x1       
#define  SYNTAX_ID_MSMQ_ROUTING_SERVICES                 8 // 0x1       
#define  SYNTAX_ID_MSMQ_SECURED_SOURCE                   8 // 0x1       
#define  SYNTAX_ID_MSMQ_SERVICE_TYPE                     9 // 0x2       
#define  SYNTAX_ID_MSMQ_SERVICES                         9 // 0x2       
#define  SYNTAX_ID_MSMQ_SIGN_CERTIFICATES               10 // 0x4       
#define  SYNTAX_ID_MSMQ_SIGN_CERTIFICATES_MIG           10 // 0x4       
#define  SYNTAX_ID_MSMQ_SIGN_KEY                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_SITE_1                           1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_2                           1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_FOREIGN                     8 // 0x1       
#define  SYNTAX_ID_MSMQ_SITE_GATES                       1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_GATES_MIG                   1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_ID                         10 // 0x4       
#define  SYNTAX_ID_MSMQ_SITE_NAME                        4 // 0x14      
#define  SYNTAX_ID_MSMQ_SITE_NAME_EX                    12 // 0x40      
#define  SYNTAX_ID_MSMQ_SITES                           10 // 0x4       
#define  SYNTAX_ID_MSMQ_TRANSACTIONAL                    8 // 0x1       
#define  SYNTAX_ID_MSMQ_USER_SID                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_VERSION                          9 // 0x2       
#define  SYNTAX_ID_MSNPALLOWDIALIN                       8 // 0x1       
#define  SYNTAX_ID_MSNPCALLEDSTATIONID                   5 // 0x16      
#define  SYNTAX_ID_MSNPCALLINGSTATIONID                  5 // 0x16      
#define  SYNTAX_ID_MSNPSAVEDCALLINGSTATIONID             5 // 0x16      
#define  SYNTAX_ID_MSRADIUSCALLBACKNUMBER                5 // 0x16      
#define  SYNTAX_ID_MSRADIUSFRAMEDIPADDRESS               9 // 0x2       
#define  SYNTAX_ID_MSRADIUSFRAMEDROUTE                   5 // 0x16      
#define  SYNTAX_ID_MSRADIUSSERVICETYPE                   9 // 0x2       
#define  SYNTAX_ID_MSRASSAVEDCALLBACKNUMBER              5 // 0x16      
#define  SYNTAX_ID_MSRASSAVEDFRAMEDIPADDRESS             9 // 0x2       
#define  SYNTAX_ID_MSRASSAVEDFRAMEDROUTE                 5 // 0x16      
#define  SYNTAX_ID_MUST_CONTAIN                          2 // 0x6       
#define  SYNTAX_ID_NAME_SERVICE_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_NC_NAME                               1 // 0x7f      
#define  SYNTAX_ID_NETBIOS_NAME                         12 // 0x40      
#define  SYNTAX_ID_NETBOOT_ALLOW_NEW_CLIENTS             8 // 0x1       
#define  SYNTAX_ID_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        8 // 0x1       
#define  SYNTAX_ID_NETBOOT_ANSWER_REQUESTS               8 // 0x1       
#define  SYNTAX_ID_NETBOOT_CURRENT_CLIENT_COUNT          9 // 0x2       
#define  SYNTAX_ID_NETBOOT_GUID                         10 // 0x4       
#define  SYNTAX_ID_NETBOOT_INITIALIZATION               12 // 0x40      
#define  SYNTAX_ID_NETBOOT_INTELLIMIRROR_OSES           12 // 0x40      
#define  SYNTAX_ID_NETBOOT_LIMIT_CLIENTS                 8 // 0x1       
#define  SYNTAX_ID_NETBOOT_LOCALLY_INSTALLED_OSES       12 // 0x40      
#define  SYNTAX_ID_NETBOOT_MACHINE_FILE_PATH            12 // 0x40      
#define  SYNTAX_ID_NETBOOT_MAX_CLIENTS                   9 // 0x2       
#define  SYNTAX_ID_NETBOOT_MIRROR_DATA_FILE             12 // 0x40      
#define  SYNTAX_ID_NETBOOT_NEW_MACHINE_NAMING_POLICY       12 // 0x40      
#define  SYNTAX_ID_NETBOOT_NEW_MACHINE_OU                1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SCP_BL                        1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SERVER                        1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SIF_FILE                     12 // 0x40      
#define  SYNTAX_ID_NETBOOT_TOOLS                        12 // 0x40      
#define  SYNTAX_ID_NETWORK_ADDRESS                       4 // 0x14      
#define  SYNTAX_ID_NEXT_LEVEL_STORE                      1 // 0x7f      
#define  SYNTAX_ID_NEXT_RID                              9 // 0x2       
#define  SYNTAX_ID_NON_SECURITY_MEMBER                   1 // 0x7f      
#define  SYNTAX_ID_NON_SECURITY_MEMBER_BL                1 // 0x7f      
#define  SYNTAX_ID_NOTIFICATION_LIST                     1 // 0x7f      
#define  SYNTAX_ID_NT_GROUP_MEMBERS                     10 // 0x4       
#define  SYNTAX_ID_NT_MIXED_DOMAIN                       9 // 0x2       
#define  SYNTAX_ID_NT_PWD_HISTORY                       10 // 0x4       
#define  SYNTAX_ID_NT_SECURITY_DESCRIPTOR               15 // 0x42      
#define  SYNTAX_ID_OBJ_DIST_NAME                         1 // 0x7f      
#define  SYNTAX_ID_OBJECT_CATEGORY                       1 // 0x7f      
#define  SYNTAX_ID_OBJECT_CLASS                          2 // 0x6       
#define  SYNTAX_ID_OBJECT_CLASS_CATEGORY                 9 // 0xa       
#define  SYNTAX_ID_OBJECT_CLASSES                       12 // 0x40      
#define  SYNTAX_ID_OBJECT_COUNT                          9 // 0x2       
#define  SYNTAX_ID_OBJECT_GUID                          10 // 0x4       
#define  SYNTAX_ID_OBJECT_SID                           17 // 0x4       
#define  SYNTAX_ID_OBJECT_VERSION                        9 // 0x2       
#define  SYNTAX_ID_OEM_INFORMATION                      12 // 0x40      
#define  SYNTAX_ID_OM_OBJECT_CLASS                      10 // 0x4       
#define  SYNTAX_ID_OM_SYNTAX                             9 // 0x2       
#define  SYNTAX_ID_OMT_GUID                             10 // 0x4       
#define  SYNTAX_ID_OMT_INDX_GUID                        10 // 0x4       
#define  SYNTAX_ID_OPERATING_SYSTEM                     12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_HOTFIX              12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_SERVICE_PACK        12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_VERSION             12 // 0x40      
#define  SYNTAX_ID_OPERATOR_COUNT                        9 // 0x2       
#define  SYNTAX_ID_OPTION_DESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_OPTIONS                               9 // 0x2       
#define  SYNTAX_ID_OPTIONS_LOCATION                      5 // 0x13      
#define  SYNTAX_ID_ORGANIZATION_NAME                    12 // 0x40      
#define  SYNTAX_ID_ORGANIZATIONAL_UNIT_NAME             12 // 0x40      
#define  SYNTAX_ID_ORGANIZATIONALSTATUS                 12 // 0x40      
#define  SYNTAX_ID_ORIGINAL_DISPLAY_TABLE               10 // 0x4       
#define  SYNTAX_ID_ORIGINAL_DISPLAY_TABLE_MSDOS         10 // 0x4       
#define  SYNTAX_ID_OTHER_LOGIN_WORKSTATIONS             12 // 0x40      
#define  SYNTAX_ID_OTHER_MAILBOX                        12 // 0x40      
#define  SYNTAX_ID_OTHER_NAME                           12 // 0x40      
#define  SYNTAX_ID_OTHER_WELL_KNOWN_OBJECTS              7 // 0x7f      
#define  SYNTAX_ID_OWNER                                 1 // 0x7f      
#define  SYNTAX_ID_PACKAGE_FLAGS                         9 // 0x2       
#define  SYNTAX_ID_PACKAGE_NAME                         12 // 0x40      
#define  SYNTAX_ID_PACKAGE_TYPE                          9 // 0x2       
#define  SYNTAX_ID_PARENT_CA                             1 // 0x7f      
#define  SYNTAX_ID_PARENT_CA_CERTIFICATE_CHAIN          10 // 0x4       
#define  SYNTAX_ID_PARENT_GUID                          10 // 0x4       
#define  SYNTAX_ID_PARTIAL_ATTRIBUTE_DELETION_LIST       10 // 0x4       
#define  SYNTAX_ID_PARTIAL_ATTRIBUTE_SET                10 // 0x4       
#define  SYNTAX_ID_PEK_KEY_CHANGE_INTERVAL              16 // 0x41      
#define  SYNTAX_ID_PEK_LIST                             10 // 0x4       
#define  SYNTAX_ID_PENDING_CA_CERTIFICATES              10 // 0x4       
#define  SYNTAX_ID_PENDING_PARENT_CA                     1 // 0x7f      
#define  SYNTAX_ID_PER_MSG_DIALOG_DISPLAY_TABLE         10 // 0x4       
#define  SYNTAX_ID_PER_RECIP_DIALOG_DISPLAY_TABLE       10 // 0x4       
#define  SYNTAX_ID_PERSONAL_TITLE                       12 // 0x40      
#define  SYNTAX_ID_PHONE_FAX_OTHER                      12 // 0x40      
#define  SYNTAX_ID_PHONE_HOME_OTHER                     12 // 0x40      
#define  SYNTAX_ID_PHONE_HOME_PRIMARY                   12 // 0x40      
#define  SYNTAX_ID_PHONE_IP_OTHER                       12 // 0x40      
#define  SYNTAX_ID_PHONE_IP_PRIMARY                     12 // 0x40      
#define  SYNTAX_ID_PHONE_ISDN_PRIMARY                   12 // 0x40      
#define  SYNTAX_ID_PHONE_MOBILE_OTHER                   12 // 0x40      
#define  SYNTAX_ID_PHONE_MOBILE_PRIMARY                 12 // 0x40      
#define  SYNTAX_ID_PHONE_OFFICE_OTHER                   12 // 0x40      
#define  SYNTAX_ID_PHONE_PAGER_OTHER                    12 // 0x40      
#define  SYNTAX_ID_PHONE_PAGER_PRIMARY                  12 // 0x40      
#define  SYNTAX_ID_PHOTO                                10 // 0x4       
#define  SYNTAX_ID_PHYSICAL_DELIVERY_OFFICE_NAME        12 // 0x40      
#define  SYNTAX_ID_PHYSICAL_LOCATION_OBJECT              1 // 0x7f      
#define  SYNTAX_ID_PICTURE                              10 // 0x4       
#define  SYNTAX_ID_PKI_CRITICAL_EXTENSIONS              12 // 0x40      
#define  SYNTAX_ID_PKI_DEFAULT_CSPS                     12 // 0x40      
#define  SYNTAX_ID_PKI_DEFAULT_KEY_SPEC                  9 // 0x2       
#define  SYNTAX_ID_PKI_ENROLLMENT_ACCESS                15 // 0x42      
#define  SYNTAX_ID_PKI_EXPIRATION_PERIOD                10 // 0x4       
#define  SYNTAX_ID_PKI_EXTENDED_KEY_USAGE               12 // 0x40      
#define  SYNTAX_ID_PKI_KEY_USAGE                        10 // 0x4       
#define  SYNTAX_ID_PKI_MAX_ISSUING_DEPTH                 9 // 0x2       
#define  SYNTAX_ID_PKI_OVERLAP_PERIOD                   10 // 0x4       
#define  SYNTAX_ID_PKT                                  10 // 0x4       
#define  SYNTAX_ID_PKT_GUID                             10 // 0x4       
#define  SYNTAX_ID_POLICY_REPLICATION_FLAGS              9 // 0x2       
#define  SYNTAX_ID_PORT_NAME                            12 // 0x40      
#define  SYNTAX_ID_POSS_SUPERIORS                        2 // 0x6       
#define  SYNTAX_ID_POSSIBLE_INFERIORS                    2 // 0x6       
#define  SYNTAX_ID_POST_OFFICE_BOX                      12 // 0x40      
#define  SYNTAX_ID_POSTAL_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_POSTAL_CODE                          12 // 0x40      
#define  SYNTAX_ID_PREFERRED_DELIVERY_METHOD             9 // 0xa       
#define  SYNTAX_ID_PREFERREDLANGUAGE                    12 // 0x40      
#define  SYNTAX_ID_PREFERRED_OU                          1 // 0x7f      
#define  SYNTAX_ID_PREFIX_MAP                           10 // 0x4       
#define  SYNTAX_ID_PRESENTATION_ADDRESS                 13 // 0x7f      
#define  SYNTAX_ID_PREVIOUS_CA_CERTIFICATES             10 // 0x4       
#define  SYNTAX_ID_PREVIOUS_PARENT_CA                    1 // 0x7f      
#define  SYNTAX_ID_PRIMARY_GROUP_ID                      9 // 0x2       
#define  SYNTAX_ID_PRIMARY_GROUP_TOKEN                   9 // 0x2       
#define  SYNTAX_ID_PRINT_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_PRINT_BIN_NAMES                      12 // 0x40      
#define  SYNTAX_ID_PRINT_COLLATE                         8 // 0x1       
#define  SYNTAX_ID_PRINT_COLOR                           8 // 0x1       
#define  SYNTAX_ID_PRINT_DUPLEX_SUPPORTED                8 // 0x1       
#define  SYNTAX_ID_PRINT_END_TIME                        9 // 0x2       
#define  SYNTAX_ID_PRINT_FORM_NAME                      12 // 0x40      
#define  SYNTAX_ID_PRINT_KEEP_PRINTED_JOBS               8 // 0x1       
#define  SYNTAX_ID_PRINT_LANGUAGE                       12 // 0x40      
#define  SYNTAX_ID_PRINT_MAC_ADDRESS                    12 // 0x40      
#define  SYNTAX_ID_PRINT_MAX_COPIES                      9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_RESOLUTION_SUPPORTED        9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_X_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_Y_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MEDIA_READY                    12 // 0x40      
#define  SYNTAX_ID_PRINT_MEDIA_SUPPORTED                12 // 0x40      
#define  SYNTAX_ID_PRINT_MEMORY                          9 // 0x2       
#define  SYNTAX_ID_PRINT_MIN_X_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MIN_Y_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_NETWORK_ADDRESS                12 // 0x40      
#define  SYNTAX_ID_PRINT_NOTIFY                         12 // 0x40      
#define  SYNTAX_ID_PRINT_NUMBER_UP                       9 // 0x2       
#define  SYNTAX_ID_PRINT_ORIENTATIONS_SUPPORTED         12 // 0x40      
#define  SYNTAX_ID_PRINT_OWNER                          12 // 0x40      
#define  SYNTAX_ID_PRINT_PAGES_PER_MINUTE                9 // 0x2       
#define  SYNTAX_ID_PRINT_RATE                            9 // 0x2       
#define  SYNTAX_ID_PRINT_RATE_UNIT                      12 // 0x40      
#define  SYNTAX_ID_PRINT_SEPARATOR_FILE                 12 // 0x40      
#define  SYNTAX_ID_PRINT_SHARE_NAME                     12 // 0x40      
#define  SYNTAX_ID_PRINT_SPOOLING                       12 // 0x40      
#define  SYNTAX_ID_PRINT_STAPLING_SUPPORTED              8 // 0x1       
#define  SYNTAX_ID_PRINT_START_TIME                      9 // 0x2       
#define  SYNTAX_ID_PRINT_STATUS                         12 // 0x40      
#define  SYNTAX_ID_PRINTER_NAME                         12 // 0x40      
#define  SYNTAX_ID_PRIOR_SET_TIME                       16 // 0x41      
#define  SYNTAX_ID_PRIOR_VALUE                          10 // 0x4       
#define  SYNTAX_ID_PRIORITY                              9 // 0x2       
#define  SYNTAX_ID_PRIVATE_KEY                          10 // 0x4       
#define  SYNTAX_ID_PRIVILEGE_ATTRIBUTES                  9 // 0x2       
#define  SYNTAX_ID_PRIVILEGE_DISPLAY_NAME               12 // 0x40      
#define  SYNTAX_ID_PRIVILEGE_HOLDER                      1 // 0x7f      
#define  SYNTAX_ID_PRIVILEGE_VALUE                      16 // 0x41      
#define  SYNTAX_ID_PRODUCT_CODE                         10 // 0x4       
#define  SYNTAX_ID_PROFILE_PATH                         12 // 0x40      
#define  SYNTAX_ID_PROXIED_OBJECT_NAME                   7 // 0x7f      
#define  SYNTAX_ID_PROXY_ADDRESSES                      12 // 0x40      
#define  SYNTAX_ID_PROXY_GENERATION_ENABLED              8 // 0x1       
#define  SYNTAX_ID_PROXY_LIFETIME                       16 // 0x41      
#define  SYNTAX_ID_PUBLIC_KEY_POLICY                    10 // 0x4       
#define  SYNTAX_ID_PURPORTED_SEARCH                     12 // 0x40      
#define  SYNTAX_ID_PWD_HISTORY_LENGTH                    9 // 0x2       
#define  SYNTAX_ID_PWD_LAST_SET                         16 // 0x41      
#define  SYNTAX_ID_PWD_PROPERTIES                        9 // 0x2       
#define  SYNTAX_ID_QUALITY_OF_SERVICE                    9 // 0x2       
#define  SYNTAX_ID_QUERY_FILTER                         12 // 0x40      
#define  SYNTAX_ID_QUERY_POLICY_BL                       1 // 0x7f      
#define  SYNTAX_ID_QUERY_POLICY_OBJECT                   1 // 0x7f      
#define  SYNTAX_ID_QUERYPOINT                           12 // 0x40      
#define  SYNTAX_ID_RANGE_LOWER                           9 // 0x2       
#define  SYNTAX_ID_RANGE_UPPER                           9 // 0x2       
#define  SYNTAX_ID_RDN                                  12 // 0x40      
#define  SYNTAX_ID_RDN_ATT_ID                            2 // 0x6       
#define  SYNTAX_ID_REGISTERED_ADDRESS                   10 // 0x4       
#define  SYNTAX_ID_REMOTE_SERVER_NAME                   12 // 0x40      
#define  SYNTAX_ID_REMOTE_SOURCE                        12 // 0x40      
#define  SYNTAX_ID_REMOTE_SOURCE_TYPE                    9 // 0x2       
#define  SYNTAX_ID_REMOTE_STORAGE_GUID                  12 // 0x40      
#define  SYNTAX_ID_REPL_PROPERTY_META_DATA              10 // 0x4       
#define  SYNTAX_ID_REPL_TOPOLOGY_STAY_OF_EXECUTION        9 // 0x2       
#define  SYNTAX_ID_REPL_UPTODATE_VECTOR                 10 // 0x4       
#define  SYNTAX_ID_REPLICA_SOURCE                       12 // 0x40      
#define  SYNTAX_ID_REPORTS                               1 // 0x7f      
#define  SYNTAX_ID_REPL_INTERVAL                         9 // 0x2       
#define  SYNTAX_ID_REPS_FROM                            10 // 0x7f      
#define  SYNTAX_ID_REPS_TO                              10 // 0x7f      
#define  SYNTAX_ID_REQUIRED_CATEGORIES                  10 // 0x4       
#define  SYNTAX_ID_RETIRED_REPL_DSA_SIGNATURES          10 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS                         17 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL       17 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS_NO_GC_ACCEPTABLE        17 // 0x4       
#define  SYNTAX_ID_REVISION                              9 // 0x2       
#define  SYNTAX_ID_RID                                   9 // 0x2       
#define  SYNTAX_ID_RID_ALLOCATION_POOL                  16 // 0x41      
#define  SYNTAX_ID_RID_AVAILABLE_POOL                   16 // 0x41      
#define  SYNTAX_ID_RID_MANAGER_REFERENCE                 1 // 0x7f      
#define  SYNTAX_ID_RID_NEXT_RID                          9 // 0x2       
#define  SYNTAX_ID_RID_PREVIOUS_ALLOCATION_POOL         16 // 0x41      
#define  SYNTAX_ID_RID_SET_REFERENCES                    1 // 0x7f      
#define  SYNTAX_ID_RID_USED_POOL                        16 // 0x41      
#define  SYNTAX_ID_RIGHTS_GUID                          12 // 0x40      
#define  SYNTAX_ID_ROLE_OCCUPANT                         1 // 0x7f      
#define  SYNTAX_ID_ROOMNUMBER                           12 // 0x40      
#define  SYNTAX_ID_ROOT_TRUST                            1 // 0x7f      
#define  SYNTAX_ID_RPC_NS_ANNOTATION                    12 // 0x40      
#define  SYNTAX_ID_RPC_NS_BINDINGS                      12 // 0x40      
#define  SYNTAX_ID_RPC_NS_CODESET                       12 // 0x40      
#define  SYNTAX_ID_RPC_NS_ENTRY_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_RPC_NS_GROUP                         12 // 0x40      
#define  SYNTAX_ID_RPC_NS_INTERFACE_ID                  12 // 0x40      
#define  SYNTAX_ID_RPC_NS_OBJECT_ID                     12 // 0x40      
#define  SYNTAX_ID_RPC_NS_PRIORITY                       9 // 0x2       
#define  SYNTAX_ID_RPC_NS_PROFILE_ENTRY                 12 // 0x40      
#define  SYNTAX_ID_RPC_NS_TRANSFER_SYNTAX               12 // 0x40      
#define  SYNTAX_ID_SAM_ACCOUNT_NAME                     12 // 0x40      
#define  SYNTAX_ID_SAM_ACCOUNT_TYPE                      9 // 0x2       
#define  SYNTAX_ID_SCHEDULE                             10 // 0x4       
#define  SYNTAX_ID_SCHEMA_FLAGS_EX                       9 // 0x2       
#define  SYNTAX_ID_SCHEMA_ID_GUID                       10 // 0x4       
#define  SYNTAX_ID_SCHEMA_INFO                          10 // 0x4       
#define  SYNTAX_ID_SCHEMA_UPDATE                        11 // 0x18      
#define  SYNTAX_ID_SCHEMA_VERSION                        9 // 0x2       
#define  SYNTAX_ID_SCOPE_FLAGS                           9 // 0x2       
#define  SYNTAX_ID_SCRIPT_PATH                          12 // 0x40      
#define  SYNTAX_ID_SD_RIGHTS_EFFECTIVE                   9 // 0x2       
#define  SYNTAX_ID_SEARCH_FLAGS                          9 // 0xa       
#define  SYNTAX_ID_SEARCH_GUIDE                         10 // 0x4       
#define  SYNTAX_ID_SECRETARY                             1 // 0x7f      
#define  SYNTAX_ID_SECURITY_IDENTIFIER                  17 // 0x4       
#define  SYNTAX_ID_SEE_ALSO                              1 // 0x7f      
#define  SYNTAX_ID_SEQ_NOTIFICATION                      9 // 0x2       
#define  SYNTAX_ID_SERIAL_NUMBER                         5 // 0x13      
#define  SYNTAX_ID_SERVER_NAME                          12 // 0x40      
#define  SYNTAX_ID_SERVER_REFERENCE                      1 // 0x7f      
#define  SYNTAX_ID_SERVER_REFERENCE_BL                   1 // 0x7f      
#define  SYNTAX_ID_SERVER_ROLE                           9 // 0x2       
#define  SYNTAX_ID_SERVER_STATE                          9 // 0x2       
#define  SYNTAX_ID_SERVICE_BINDING_INFORMATION          12 // 0x40      
#define  SYNTAX_ID_SERVICE_CLASS_ID                     10 // 0x4       
#define  SYNTAX_ID_SERVICE_CLASS_INFO                   10 // 0x4       
#define  SYNTAX_ID_SERVICE_CLASS_NAME                   12 // 0x40      
#define  SYNTAX_ID_SERVICE_DNS_NAME                     12 // 0x40      
#define  SYNTAX_ID_SERVICE_DNS_NAME_TYPE                12 // 0x40      
#define  SYNTAX_ID_SERVICE_INSTANCE_VERSION             10 // 0x4       
#define  SYNTAX_ID_SERVICE_PRINCIPAL_NAME               12 // 0x40      
#define  SYNTAX_ID_SETUP_COMMAND                        12 // 0x40      
#define  SYNTAX_ID_SHELL_CONTEXT_MENU                   12 // 0x40      
#define  SYNTAX_ID_SHELL_PROPERTY_PAGES                 12 // 0x40      
#define  SYNTAX_ID_SHORT_SERVER_NAME                    12 // 0x40      
#define  SYNTAX_ID_SHOW_IN_ADDRESS_BOOK                  1 // 0x7f      
#define  SYNTAX_ID_SHOW_IN_ADVANCED_VIEW_ONLY            8 // 0x1       
#define  SYNTAX_ID_SID_HISTORY                          17 // 0x4       
#define  SYNTAX_ID_SIGNATURE_ALGORITHMS                 12 // 0x40      
#define  SYNTAX_ID_SITE_GUID                            10 // 0x4       
#define  SYNTAX_ID_SITE_LINK_LIST                        1 // 0x7f      
#define  SYNTAX_ID_SITE_LIST                             1 // 0x7f      
#define  SYNTAX_ID_SITE_OBJECT                           1 // 0x7f      
#define  SYNTAX_ID_SITE_OBJECT_BL                        1 // 0x7f      
#define  SYNTAX_ID_SITE_SERVER                           1 // 0x7f      
#define  SYNTAX_ID_SMTP_MAIL_ADDRESS                    12 // 0x40      
#define  SYNTAX_ID_SPN_MAPPINGS                         12 // 0x40      
#define  SYNTAX_ID_STATE_OR_PROVINCE_NAME               12 // 0x40      
#define  SYNTAX_ID_STREET_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_STRUCTURAL_OBJECT_CLASS               2 // 0x6       
#define  SYNTAX_ID_SUB_CLASS_OF                          2 // 0x6       
#define  SYNTAX_ID_SUB_REFS                              1 // 0x7f      
#define  SYNTAX_ID_SUBSCHEMASUBENTRY                     1 // 0x7f      
#define  SYNTAX_ID_SUPER_SCOPE_DESCRIPTION              12 // 0x40      
#define  SYNTAX_ID_SUPER_SCOPES                          5 // 0x13      
#define  SYNTAX_ID_SUPERIOR_DNS_ROOT                    12 // 0x40      
#define  SYNTAX_ID_SUPPLEMENTAL_CREDENTIALS             10 // 0x4       
#define  SYNTAX_ID_SUPPORTED_APPLICATION_CONTEXT        10 // 0x4       
#define  SYNTAX_ID_SURNAME                              12 // 0x40      
#define  SYNTAX_ID_SYNC_ATTRIBUTES                       9 // 0x2       
#define  SYNTAX_ID_SYNC_MEMBERSHIP                       1 // 0x7f      
#define  SYNTAX_ID_SYNC_WITH_OBJECT                      1 // 0x7f      
#define  SYNTAX_ID_SYNC_WITH_SID                        17 // 0x4       
#define  SYNTAX_ID_SYSTEM_AUXILIARY_CLASS                2 // 0x6       
#define  SYNTAX_ID_SYSTEM_FLAGS                          9 // 0x2       
#define  SYNTAX_ID_SYSTEM_MAY_CONTAIN                    2 // 0x6       
#define  SYNTAX_ID_SYSTEM_MUST_CONTAIN                   2 // 0x6       
#define  SYNTAX_ID_SYSTEM_ONLY                           8 // 0x1       
#define  SYNTAX_ID_SYSTEM_POSS_SUPERIORS                 2 // 0x6       
#define  SYNTAX_ID_TELEPHONE_NUMBER                     12 // 0x40      
#define  SYNTAX_ID_TELETEX_TERMINAL_IDENTIFIER          10 // 0x4       
#define  SYNTAX_ID_TELEX_NUMBER                         10 // 0x4       
#define  SYNTAX_ID_TELEX_PRIMARY                        12 // 0x40      
#define  SYNTAX_ID_TEMPLATE_ROOTS                        1 // 0x7f      
#define  SYNTAX_ID_TERMINAL_SERVER                      10 // 0x4       
#define  SYNTAX_ID_TEXT_COUNTRY                         12 // 0x40      
#define  SYNTAX_ID_TEXT_ENCODED_OR_ADDRESS              12 // 0x40      
#define  SYNTAX_ID_TIME_REFRESH                         16 // 0x41      
#define  SYNTAX_ID_TIME_VOL_CHANGE                      16 // 0x41      
#define  SYNTAX_ID_TITLE                                12 // 0x40      
#define  SYNTAX_ID_TOMBSTONE_LIFETIME                    9 // 0x2       
#define  SYNTAX_ID_TRANSPORT_ADDRESS_ATTRIBUTE           2 // 0x6       
#define  SYNTAX_ID_TRANSPORT_DLL_NAME                   12 // 0x40      
#define  SYNTAX_ID_TRANSPORT_TYPE                        1 // 0x7f      
#define  SYNTAX_ID_TREAT_AS_LEAF                         8 // 0x1       
#define  SYNTAX_ID_TREE_NAME                            12 // 0x40      
#define  SYNTAX_ID_TRUST_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_TRUST_AUTH_INCOMING                  10 // 0x4       
#define  SYNTAX_ID_TRUST_AUTH_OUTGOING                  10 // 0x4       
#define  SYNTAX_ID_TRUST_DIRECTION                       9 // 0x2       
#define  SYNTAX_ID_TRUST_PARENT                          1 // 0x7f      
#define  SYNTAX_ID_TRUST_PARTNER                        12 // 0x40      
#define  SYNTAX_ID_TRUST_POSIX_OFFSET                    9 // 0x2       
#define  SYNTAX_ID_TRUST_TYPE                            9 // 0x2       
#define  SYNTAX_ID_UAS_COMPAT                            9 // 0x2       
#define  SYNTAX_ID_UID                                  12 // 0x40      
#define  SYNTAX_ID_UNC_NAME                             12 // 0x40      
#define  SYNTAX_ID_UNICODE_PWD                          10 // 0x4       
#define  SYNTAX_ID_UNIQUEIDENTIFIER                     12 // 0x40      
#define  SYNTAX_ID_UNIQUEMEMBER                          1 // 0x7f      
#define  SYNTAX_ID_UNSTRUCTUREDADDRESS                  12 // 0x40      
#define  SYNTAX_ID_UNSTRUCTUREDNAME                      5 // 0x16      
#define  SYNTAX_ID_UPGRADE_PRODUCT_CODE                 10 // 0x4       
#define  SYNTAX_ID_UPN_SUFFIXES                         12 // 0x40      
#define  SYNTAX_ID_USER_ACCOUNT_CONTROL                  9 // 0x2       
#define  SYNTAX_ID_USER_CERT                            10 // 0x4       
#define  SYNTAX_ID_USER_COMMENT                         12 // 0x40      
#define  SYNTAX_ID_USER_PARAMETERS                      12 // 0x40      
#define  SYNTAX_ID_USER_PASSWORD                        10 // 0x4       
#define  SYNTAX_ID_USERCLASS                            12 // 0x40      
#define  SYNTAX_ID_USERPKCS12                           10 // 0x4       
#define  SYNTAX_ID_USER_PRINCIPAL_NAME                  12 // 0x40      
#define  SYNTAX_ID_USER_SHARED_FOLDER                   12 // 0x40      
#define  SYNTAX_ID_USER_SHARED_FOLDER_OTHER             12 // 0x40      
#define  SYNTAX_ID_USER_SMIME_CERTIFICATE               10 // 0x4       
#define  SYNTAX_ID_USER_WORKSTATIONS                    12 // 0x40      
#define  SYNTAX_ID_USN_CHANGED                          16 // 0x41      
#define  SYNTAX_ID_USN_CREATED                          16 // 0x41      
#define  SYNTAX_ID_USN_DSA_LAST_OBJ_REMOVED             16 // 0x41      
#define  SYNTAX_ID_USN_INTERSITE                         9 // 0x2       
#define  SYNTAX_ID_USN_LAST_OBJ_REM                     16 // 0x41      
#define  SYNTAX_ID_USN_SOURCE                           16 // 0x41      
#define  SYNTAX_ID_VALID_ACCESSES                        9 // 0x2       
#define  SYNTAX_ID_VENDOR                               12 // 0x40      
#define  SYNTAX_ID_VERSION_NUMBER                        9 // 0x2       
#define  SYNTAX_ID_VERSION_NUMBER_HI                     9 // 0x2       
#define  SYNTAX_ID_VERSION_NUMBER_LO                     9 // 0x2       
#define  SYNTAX_ID_VOL_TABLE_GUID                       10 // 0x4       
#define  SYNTAX_ID_VOL_TABLE_IDX_GUID                   10 // 0x4       
#define  SYNTAX_ID_VOLUME_COUNT                          9 // 0x2       
#define  SYNTAX_ID_WBEM_PATH                            12 // 0x40      
#define  SYNTAX_ID_WELL_KNOWN_OBJECTS                    7 // 0x7f      
#define  SYNTAX_ID_WHEN_CHANGED                         11 // 0x18      
#define  SYNTAX_ID_WHEN_CREATED                         11 // 0x18      
#define  SYNTAX_ID_WINSOCK_ADDRESSES                    10 // 0x4       
#define  SYNTAX_ID_WWW_HOME_PAGE                        12 // 0x40      
#define  SYNTAX_ID_WWW_PAGE_OTHER                       12 // 0x40      
#define  SYNTAX_ID_X121_ADDRESS                          6 // 0x12      
#define  SYNTAX_ID_X500UNIQUEIDENTIFIER                 10 // 0x4       
#define  SYNTAX_ID_X509_CERT                            10 // 0x4       


#endif \\_ATTIDS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\bootopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bootopt.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module proto-types the functions exported by bootopt.lib

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

typedef enum
{
    eAddBootOption,
    eRemoveBootOption

} NTDS_BOOTOPT_MODTYPE;


DWORD
NtdspModifyDsRepairBootOption( 
    NTDS_BOOTOPT_MODTYPE Modification
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dbopen.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbopen.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file function prototypes that clients of the dbopen library can use
    to open/close a DS Jet database.

Environment:

    User Mode - Win32

Notes:

--*/

#ifndef __DBOPEN_H
#define __DBOPEN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <esent.h>


extern INT
DBInitializeJetDatabase(
    IN JET_INSTANCE* JetInst,
    IN JET_SESID* SesId,
    IN JET_DBID* DbId,
    IN const char *szDBPath,
    IN BOOL bLogSeverity
    );


extern void
DBSetRequiredDatabaseSystemParameters (
    JET_INSTANCE *jInstance
    );


extern void 
DBSetDatabaseSystemParameters ( 
    JET_INSTANCE *jInstance, 
    unsigned fInitAdvice 
    );


// Never, ever, change this.  see remarks in dbinit.c
//
#define JET_LOG_FILE_SIZE (10 * 1024)

// 8K pages.
//
#define JET_PAGE_SIZE     (8 * 1024)


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\base64.h ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.h

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#ifndef _BASE64_H_
#define _BASE64_H_

#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    );

NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pbDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // _BASE64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

/*  Debug output macros

    This is a simple debugging package for generating conditional
    printf output.

    AT RUN-TIME

    There are 2 run-time options:

    1 - A list of subsystems to be debugged.  Either a list of subsystem
        names delimited by a ":" or an "*" which means debug all
        (e.g. sub1:sub2: Sub3:).  (Names are case sensitive and spaces
        between names are ignored.)

    2 - A severity level (1-5) that indicates the level of detailed
        information to be produced.  (The higher the level, the more
        data produced.


    AT COMPILE-TIME

    Compile with the /DDBG=1 option to define the preprocessor variable
    DBG to 1.  This will generate debug source code.  For customer shipment,
    set /DDBG=0 and all debug code will be removed.  (Actually a
    ";" will be generated.)


    AT CODE-TIME

    1 - Include the DEBUG.H header at the top of your source listing.

    2 - #DEFINE DEBSUB to contain the name (a string delimited by a ":") of
        the software subsystem contained in this source (e.g. #define DEBSUB
        "MySub:") (You could optionally redefine DEBSUB for each function in
        your source to give you function-level debugging.)

    3 - Invoke the DEBUGINIT macro that calls the Debug function before any
        source debug statements are executed.  This funciton prompts STDIN for
        the user specified run-time options.  (Alternatively you could
        hardcode your own assignment of the DebugInfo data structure which
        holds the run-time options.)

    4 - Everywhere you want to a printf for debugging, put a DPRINT statement
        instead and specify a severity level with the statement.  The
        statement will be printed if the severity is this level or higher
        (assuming that the subsystem is to be debugged).  The severity level
        allows for different amounts of output to be generated if problem
        is very bad.

    For example, a severity of 1 DPRINT statement might just indicate that
    a certain function was entered while a severity of 5 might print
    information that is inside a tight loop.

    (Actually there are 6 DPRINT statements provided depending on the
    number of printf arguments.)


    NOTE

    All printf's are surrounded by semaphores.  Be careful not to invoke
    routines as parms to printf because you can have a deadlock situation.


    EXAMPLE PROGRAM

    **   include "debug.h"
    **   include "string.h"
    **
    **   #define DEBSUB "sub1:"
    **
    **   main()
    **   {
    **       DEBUGINIT;
    **
    **       DPRINT(4,"this is a sub1 debug of 4\n");
    **       DPRINT(1,"this is a sub1 debug of 1\n");
    **   }

*/


#ifndef _debug_h_
#define _debug_h_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LOADDS
# ifdef WIN32
#  define _LOADDS
# else
#  define _LOADDS _loadds
# endif
#endif



/* <DebugInfo>, of type DEBUGARG, contains the debug run-time settings.

   DebSubSystems contains a list of subsystem names to be debugged
   delimited by ":".  An "*" found in this array indicates that all
   subsystems are to be debugged.

   The severity indicates the amount of debug information to be produced.
   The higher the severity the more data that will be dumped.

   A specific thread can be traced by entering its ID.  An id of 0 means all.
*/

/*
    This pertains to the assert table information. 

*/

#define ASSERT_TABLE_SIZE               (20)

// Assert Table Flags    
#define ASSERT_DISABLED              (0x00000001)
#define ASSERT_PRINT                 (0x00000002)
#define ASSERT_FROM_REGISTRY         (0x00000004)

#define DSID_MASK_DIRNO              (0xFF000000)
#define DSID_MASK_FILENO             (0x00FF0000)
#define DSID_MASK_LINE               (0x0000FFFF)

typedef struct {
    DWORD     dwDSID;
    DWORD     dwFlags;
} ASSERT_TABLE_ENTRY;
       
typedef ASSERT_TABLE_ENTRY *  ASSERT_TABLE;


ULONG
GetBlankAssertEntry(
    ASSERT_TABLE   aAssertTable,
    DWORD          dwDSID
    );


/* values for <DEBUGARG.scope> */
#define DEBUG_LOCAL     1
#define DEBUG_REMOTE    2
#define DEBUG_ALL       3

typedef struct
{
    unsigned short scope;           /* when changing values, change local? */
    int severity;                   /* 1 - 5, (low - high) - on stdout */
    CRITICAL_SECTION sem;           /* single thread semaphore*/
    unsigned long  threadId;        /* a thread id to debug (0 - All)*/
    char DebSubSystems[144];        /* the list of subsystem to debug */
    CHAR LogFileName[MAX_PATH+1];   // name of the log file
    ASSERT_TABLE_ENTRY aAssertTable[ASSERT_TABLE_SIZE + 2]; /* the list of 
                                                     disabled asserts */
} DEBUGARG;

#if DBG

extern DEBUGARG DebugInfo;
extern BOOL     fProfiling;
extern BOOL     fEarlyXDS;

#define DEBUGTEST(sev)      DebugTest( sev, DEBSUB, DEBALL )

char *asciiz(char *var, unsigned short len);


#endif /* DBG */

// Free builds break if CreateErrorString is inside the #if block.

BOOL    CreateErrorString(UCHAR **ppBuf, DWORD *pcbBuf );

#if ( DBG  && (! defined(NONDEBUG)) && !defined(WIN16))

/*
**      forward declare actual functions used by DPRINT's
*/
void    DebPrint( USHORT, UCHAR *, CHAR *, unsigned, ... );
USHORT  DebugTest( USHORT, CHAR * );
void    DumpErrorInfo(UCHAR *, unsigned);
VOID    TerminateDebug(VOID);

/* These are used instead of printf statements.  Semaphores surround the
   printf and all output is proceeded by the subsystem.*/

// The DPRINT macros perform the output test in the macro in order to
// avoid costly and unnecessary evaluation of the arguments. They include
// the braces so that "if (a) MACRO(x, y); else b" will work correctly.

#define DPRINT(severity,str)              \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( (int)(severity), (PUCHAR)str, DEBSUB, __LINE__); \
}

#define DPRINT1(severity, str,p1)        \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1 ); \
}

#define DPRINT2(severity, str,p1,p2)   \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2 ); \
}

#define DPRINT3(severity, str,p1,p2,p3)     \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3 ); \
}

#define DPRINT4(severity, str,p1,p2,p3,p4)  \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4 ); \
}

#define DPRINT5(severity, str,p1,p2,p3,p4,p5)   \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5 ); \
}

#define DPRINT6(severity, str,p1,p2,p3,p4,p5,p6) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6 ); \
}

#define DPRINT7(severity, str,p1,p2,p3,p4,p5,p6,p7) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6, p7 ); \
}

#define DPRINT8(severity, str,p1,p2,p3,p4,p5,p6,p7,p8) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6, p7, p8 ); \
}

#define DUMP_ERROR_INFO() \
    DumpErrorInfo((PUCHAR)DEBSUB, __LINE__)

#else
#define DPRINT(severity, str)
#define DPRINT1(severity, str,p1)
#define DPRINT2(severity, str,p1,p2)
#define DPRINT3(severity, str,p1,p2,p3)
#define DPRINT4(severity, str,p1,p2,p3,p4)
#define DPRINT5(severity, str,p1,p2,p3,p4,p5)
#define DPRINT6(severity, str,p1,p2,p3,p4,p5,p6)
#define DPRINT7(severity, str,p1,p2,p3,p4,p5,p6,p7)
#define DPRINT8(severity, str,p1,p2,p3,p4,p5,p6,p7,p8)
#define DUMP_ERROR_INFO()
#endif


/* Define the debug initialization routine */

#if  DBG
void Debug(int argc, char *argv[], PCHAR Module );

#define DEBUGINIT(argc, argv, mod) Debug(argc, argv, mod)
#define DEBUGTERM() TerminateDebug()
#else
#define DEBUGINIT(argc, argv, mod)
#define DEBUGTERM()
#endif


/*  The following function is an additional debug-only DUAPI call which
    can be used to modify the debug settings at run-time.  The <scope>
    field in the <pDebugArg> parameter can be used to specify resetting
    the debug values on either the client or the server!
*/

#if  DBG

#ifdef PARANOID
// this is *really* slow, and should be turned on only in private builds

#define HEAPVALIDATE {                          \
    int __heaperr;                              \
    __heaperr = RtlValidateHeap(pTHStls->hHeap,0,NULL); \
    if (!__heaperr) {                           \
        DebugBreak();                           \
    }                                           \
    __heaperr = _heapchk();                     \
    if (__heaperr != _HEAPOK) {                 \
        DebugBreak();                           \
    }                                           \
}
#else // not paranoid
#define HEAPVALIDATE
#endif

#else // not debug
#define HEAPVALIDATE
#endif



/*
 * There are some conditions that the DS, as a loosely consistent system,
 * can only loosely guarantee. This LooseAssert will not fire if a global-knowledge
 * modifying operation (such as an NC or CR catalog update) has been recently
 * run. It is considered acceptable that the in-memory structures remain
 * out-of-sync with the DB for a short period of time after such an operation
 * has commited
 * Another kind of LooseAssert is related to replication delays. For example,
 * a subref can be replicated before a corresponding cross-ref is replicated
 * in the configuration container (see the LooseAssert in GeneratePOQ)
 */

// this is the period of time (in sec) after a global-knowledge modifying
// operation when the global caches are allowed to be inconsistent with the DB
#define GLOBAL_KNOWLEDGE_COMMIT_DELAY_MIN 10
#define GLOBAL_KNOWLEDGE_COMMIT_DELAY_MAX 60
extern ULONG GlobalKnowledgeCommitDelay;

// a period of time (in sec) allowed for crossref/subref replication to complete
#define SubrefReplicationDelay (3*3600)

// a period of time where a cross-ref delete has replicated in, but the KCC
// hasn't had time to run yet and clean up the appropriate NC.  KCC runs every
// 15 minues, so we'll give ourselves a little extra.
#define GLOBAL_KNOWLEDGE_KCC_PERIODIC_DELAY   (20 * 60)

#if  DBG

extern void DoAssert( char *, DWORD, char * );
extern DWORD gdwLastGlobalKnowledgeOperationTime; // in ticks

#ifndef Assert
#define Assert( exp )   { if (!(exp)) DoAssert(#exp, DSID(FILENO, __LINE__), __FILE__ ); }

// allowedDelay is the time (in seconds) that is allowed since
// the last global knowledge modifying operation
#define LooseAssert(exp, allowedDelay) { \
    if ((GetTickCount() - gdwLastGlobalKnowledgeOperationTime > (allowedDelay)*1000) && !(exp)) { \
        DoAssert(#exp, DSID(FILENO, __LINE__), __FILE__); \
    } \
}

DWORD
ReadRegDisabledAsserts(
    HKEY            hKey
    );


#endif

#else

#ifndef Assert
#define Assert( exp )
#define LooseAssert( exp, allowedDelay )
#endif

#endif

#define OWN_CRIT_SEC(x) \
    (GetCurrentThreadId() == HandleToUlong((x).OwningThread))
#define OWN_RESOURCE_EXCLUSIVE(x) (((x)->NumberOfActive == -1) &&              \
                                   (GetCurrentThreadId() ==                    \
                                    HandleToUlong((x)->ExclusiveOwnerThread)))
// This is a weak test, since it just tests if ANYONE owns the resource in a
// shared manner, not that the calling thread does so.
#define OWN_RESOURCE_SHARED(x) ((x)->NumberOfActive > 0)

#ifdef __cplusplus
}
#endif

// This provides a macro that will declare a local variable equal to
// pTHStls, since thread local variables can't be accessed by debuggers
#if DBG
#define DEBUGTHS THSTATE * _pTHS = pTHStls;
#else
#define DEBUGTHS
#endif

// A convenient expression that is true iff a block is allocated from
// the specified heap
#define IsAllocatedFrom(hHeap, pBlock) (0xffffffff != RtlSizeHeap((hHeap),0,(pBlock)))


// Routine to validate memory.
BOOL
IsValidReadPointer(
        IN PVOID pv,
        IN DWORD cb
        );


DWORD *
ReadDsidsFromRegistry (
    IN      HKEY    hKey,
    IN      PCSTR   pValue,
    IN      BOOL    fLogging,
    IN OUT  ULONG * pnMaxCount
    );

#endif /* _debug_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dnsresl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dnsresl.h
//
//--------------------------------------------------------------------------


#ifndef __DSLIB_H
#define __DSLIB_H

#define IPADDRSTR_SIZE 16

typedef struct _DNSRESL_GET_DNS_PD {
    INT                                iQueryBufferSize;
    PWSAQUERYSETW                      pQuery;
    HANDLE                             hWsaLookup;
} DNSRESL_GET_DNS_PD, *PDNSRESL_GET_DNS_PD;

DWORD GetIpAddrByDnsNameW(
    IN      LPWSTR                     pszHostName,
    OUT     LPWSTR                     pszIP);

DWORD GetDnsHostNameW(
    IN OUT  VOID **                    ppPrivData,
    IN      LPWSTR                     pszNameToLookup,
    OUT     LPWSTR *                   ppszDnsHostName);

DWORD GetDnsAliasNamesW(
    IN OUT  VOID **                    ppPrivData,
    OUT     LPWSTR *                   ppszDnsHostName);

VOID GetDnsFreeW(
    IN      VOID **                    ppPrivData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\draadmin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draadmin.h
//
//--------------------------------------------------------------------------

// Prototype for setup to DRA call ServerInstall

USHORT __stdcall ServerInstall (char * pszServerName,
			char * pszOrgName,
                        char * pszOrgUnitName,
                        ULONG ulOptions);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dbglobal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbglobal.h
//
//--------------------------------------------------------------------------


// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

#ifndef _dbglobal_h_
#define _dbglobal_h_

#include <filtypes.h>

#define NO_GRBIT            0

//  requires the local variable 'err' and the local
//  label 'HandleError' to be declared
//
#define Call( func )            CheckErr_( func, #func )
#define CheckErr( errT )        CheckErr_( errT, "CheckErr()" )
#define CheckErr_( errT, szT )                                                                  \
    {                                                                                           \
    if ( ( err = ( errT ) ) != JET_errSuccess )                                                 \
        {                                                                                       \
        DPRINT4( 0, "'%s' failed with error %d (%s@%d).\n", szT, err, __FILE__, __LINE__ );     \
        LogUnhandledError( err );                                                               \
        goto HandleError;                                                                       \
        }                                                                                       \
    }

#define MAXSYNTAX           18      // The largest number of att syntaxes.
#define INBUF_INITIAL       256     // The initial input buffer size
#define VALBUF_INITIAL      512     // The initial value work buffer size

#define DB_CB_MAX_KEY       255     // Maximum size of a JET key.

// Tuple index related defines.
#define DB_TUPLES_LEN_MIN        0x3     // The minimum length tuple to index in characters
#define DB_TUPLES_LEN_MAX        0xa     // The maximum length tuple to index in characters
#define DB_TUPLES_TO_INDEX_MAX   0x7fff  // The maximum number of tuples in a single
                                         // key, to index.


//  OPTIMISATION: We know that the primary key (DNT) is always a fixed
//  length, so whenever we need a buffer for the primary key, we can
//  allocate an appropriately-sized buffer.  Without this assumption, we
//  would have to allocate buffer a buffer sized to JET_cbPrimaryKeyMost.
//
#define cbDNTPrimaryKey     ( sizeof(ULONG) + 1 )   //  +1 for key prefix byte


// NTRAID#NTRAID-580234-2002/03/18-andygo:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
// REVIEW:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
//
// Comment this line out if the check for loss of administrator
// group membership is not needed. THis is to track down a self host
// corruption problem where the NTWKSTA domain loss all its admin
// group memberships
//

#define CHECK_FOR_ADMINISTRATOR_LOSS 1



// This structure is used to internally represent a Distname-String syntax
// and the Distname-Binary syntax

typedef struct {
   ULONG              tag;              // Internal distname
   STRING_LENGTH_PAIR data;             // data
} INTERNAL_SYNTAX_DISTNAME_STRING;

// This structure holds data about pending security descriptor propagation
// information
typedef struct _SDPropInfo {
    DWORD index;
    DWORD beginDNT;
    DWORD clientID;
    DWORD flags;
    PBYTE pCheckpointData;
    DWORD cbCheckpointData;
} SDPropInfo;

// The following structure is used to maintain a list of NCDNTs for notification
// after the current transaction completes.

typedef struct _NCnotification {
    ULONG ulNCDNT;
    BOOL fUrgent;
    struct _NCnotification *pNext;
} NCnotification, *PNCnotification;

//
// The following structure allows for maintaining linked lists of DNs being
// added. One global list, guaranteeing that 2 identical entries aren't being
// added simultaneously. Each DBPOS contains a list of DNs added using it. This
// list is cleared and removed from the global list at transaction end
// time. From then on, the responsibility of disallowing duplicates is in the
// hands of the database
//

#pragma warning (disable: 4200)
typedef struct _DNLIST
{
    struct _DNLIST *pNext;
    DWORD          dwFlags;
    DWORD          dwTid;
    BYTE           rgb[];
} DNList;
// Flags for DBLockDN.
// This flag means to lock the whole tree under the given DN.
#define DB_LOCK_DN_WHOLE_TREE        1
// Normal behaviour for locked DNs is that they are released automatically when
// the DBPOS they were locked on is DBClosed.  This flags means that the DN
// should remain locked on the global locked DN list until explicitly freed via
// DBUnlockStickyDN()
#define DB_LOCK_DN_STICKY            2

#pragma warning (default: 4200)

typedef struct _KEY_INDEX {
    ULONG           ulEstimatedRecsInRange;     // for the particular index
    union
    {
        BOOL        bFlags;
        struct
        {
            BOOL    bIsSingleValued:1;          // Is this a single valued index?
            BOOL    bIsEqualityBased:1;         // Are we walking this index for an equality test?
            BOOL    bIsForSort:1;               // Is this index here to satisfy a sorted
            BOOL    bIsPDNTBased:1;             // Index first column PDNT?
            BOOL    bIsTupleIndex:1;            // whether this is a tuple index
            BOOL    bIsIntersection:1;          // flag whether this is an intersection index search?
        BOOL    bIsUniqueRecord:1;          // Does this index point to only one record?
        };
    };

    UCHAR           *szIndexName;               // jet index name
    struct tagJET_INDEXID  *pindexid;           // pointer to jet indexid

    ULONG           cbDBKeyLower;               // size of the above (max DB_CB_MAX_KEY )
    ULONG           cbDBKeyUpper;               // size of the above (max DB_CB_MAX_KEY )
    BYTE            *rgbDBKeyLower;             // lower limit for jetkey in this query
    BYTE            *rgbDBKeyUpper;             // Upper limit for jetkey in this query

    ATTCACHE        *pAC;                       // possible ATTCACHE for the index

    JET_TABLEID     tblIntersection;            // the temp table used in the intersection
    JET_COLUMNID    columnidBookmark;           // the column id that identifies the bookmark in the intersect table

    struct _KEY_INDEX *pNext;
} KEY_INDEX;

// What kind of duplicate detection algorithm are we using?
#define DUP_NEVER       0
#define DUP_HASH_TABLE  1
#define DUP_MEMORY      2

// Index types
#define INVALID_INDEX_TYPE     0
#define UNSET_INDEX_TYPE       1
#define GENERIC_INDEX_TYPE     2
#define TEMP_TABLE_INDEX_TYPE  3
#define ANCESTORS_INDEX_TYPE   4
#define INTERSECT_INDEX_TYPE   5
#define TEMP_TABLE_MEMORY_ARRAY_TYPE  6
#define TUPLE_INDEX_TYPE       7

// For the in-memory duplicate detection, how many DNTs will we hold
#define DUP_BLOCK_SIZE 64

#define VLV_MOVE_FIRST     0x80000000
#define VLV_MOVE_LAST      0x7FFFFFFF
#define VLV_CALC_POSITION  1

typedef struct _VLV_SEARCH {
    VLV_REQUEST *pVLVRequest;           // VLV ARGUMENT supplied by client

    ULONG       positionOp;             // Position Operator for Fractional Positioning
                                        // VLV_MOVE_FIRST, VLV_MOVE_LAST, VLV_CALC_POSITION

    ULONG       clnCurrPos;             // client Current Position (Ci)
    ULONG       clnContentCount;        // client Estimate of Content Count (Cc)

    ULONG       currPosition;           // server Currect Position (Si)
    ULONG       contentCount;           // actual ContentCount (Sc)

    ULONG       requestedEntries;       // total Number Req Entries

    ATTRTYP     SortAttr;               // the sort attr of this VLV search
    DWORD       Err;                    // the VLV specific error code to return

    DWORD       cbCurrPositionKey;
    BYTE        rgbCurrPositionKey[DB_CB_MAX_KEY];

    BOOL        bUsingMAPIContainer;    // TRUE whether we are doing VLV on a MAPI container
    DWORD       MAPIContainerDNT;       // the DNT of the ABView container

} VLV_SEARCH;

// info about a search
typedef struct _KEY {
    FILTER                *pFilter;
    POBJECT_TYPE_LIST     pFilterSecurity;
    DWORD                 *pFilterResults;
    ULONG                 FilterSecuritySize;
    BOOL                  *pbSortSkip;
    // the following fields restrict the range of JET keys on searche (or list)

    DWORD    dupDetectionType;       // What kind of duplicate detection
                                     // algorithm are we using
    DWORD    cDupBlock;              // For the in-memory dup detection, how
                                     // many objects have we found?
    DWORD   *pDupBlock;              // Memory block for in-memory dup detection
    struct _LHT *plhtDup;            // Hash table for dup detection

    BOOL     fSearchInProgress;
    BOOL     bOnCandidate;           // Used to create restarts and for
                                     // repositioning after a timelimit has been
                                     // hit.  Is a marker for wether we are
                                     // positioned on an object that will match
                                     // the search if it matches the filter.
    BOOL     fChangeDirection;       // Used to change the direction of a
                                     // search if the descending sort order
                                     // requested was declined

    // pointer to the first index info for this search key
    KEY_INDEX *pIndex;

    // The following fields specify the search type
    ULONG   ulSearchType;            // SE_CHOICE_BASE_ONLY
                                     // SE_CHOICE_IMMED_CHILDREN
                                     // SE_CHOICE_WHOLE_SUBTREE

    ULONG   ulSearchRootDnt;         // Dnt of the root of the search
    ULONG   ulSearchRootPDNT;        // PDNT of the root of the search
    ULONG   ulSearchRootNcdnt;       // Ncdnt of the root of the search

    ULONG   ulSorted;                // Does this key describe a sorted search?
    BOOL    bOneNC;                  // Is the search limited to one NC?

    DWORD   indexType;

    ULONG   ulEntriesInTempTable;    // If this describes a TempTable,
                                     // the number of entries in this table
                                     // zero if not known

    // the following fields describe a VLV search
    VLV_SEARCH   *pVLV;

    // the following fields describe an ASQ search
    ASQ_REQUEST asqRequest;
    DWORD       asqMode;                // the ASQ mode (simple, sorted, paged, vlv)

    ULONG       ulASQLastUpperBound;    // the last entry retrieved from
                                        // the attribute specified in the ASQ
                                        // request
    ULONG       ulASQSizeLimit;         // number of entries requested


    // the following are used for VLV and ASQ searches
    DWORD        cdwCountDNTs;          // Number of entries in the DNT array
    DWORD        *pDNTs;                // all the entries in sorted order
    DWORD        currRecPos;            // the current position in the array
                                        // like a database cursor
                                        // valid values 1..cdwCountDNTs
                                        // 0 = BOF
                                        // cdwCountDNTs + 1 = EOF

    BOOL         fDontFreeFilter;       // flag whether to free the filter
                                        // needed if it is an ANR
} KEY;

// what kind of ASQ mode we are doing
#define ASQ_SIMPLE 0
#define ASQ_SORTED 1
#define ASQ_PAGED  2
#define ASQ_VLV    4

// The database anchor data structure pointed to by a database handle.
typedef struct DBPOS{
   struct _THSTATE *pTHS;               // Our thread state
   ULONG        valBufSize;
   UCHAR       *pValBuf;                // used when the att val is translated
   ULONG        DNT;                    // The current objects DNT
   ULONG        PDNT;                   // The current objects parent DNT
                    // (only if not root)
   ULONG        SDNT;                   // The current DNT for JetSearchTbl
   ULONG        NCDNT;                  // The NC master DNT
                    // This field has specialized use and
                    // is not generally maintained
   JET_DBID     JetDBID;
   JET_SESID    JetSessID;
   JET_TABLEID  JetSDPropTbl;           // Table for SD propagation events.
   JET_TABLEID  JetObjTbl;              // Main table ID
   JET_TABLEID  JetSearchTbl;           // Table id used with dbsubj.c
   JET_TABLEID  JetLinkTbl;             // Table for links and backlinks
   JET_TABLEID  JetLinkEnumTbl;         // Table id used to enum links and backlinks
   JET_TABLEID  JetSDTbl;               // Table for security descriptors
   JET_TABLEID  JetSortTbl;             // Temp table for sorting
   JET_COLUMNID SortColumns[3];         // ColumnIDs for the two columns in the
                    // sort table.
   JET_GRBIT    JetRetrieveBits;        // grbits for JetRetrieve Column
   int          SDEvents;               // Number of events queued/dequeued in
                                        // this dbpos.
   unsigned     transType:2;            // read, writ, or exclusive write
   BOOL         root:1;                 // indicates if the object is the root
   BOOL         JetCacheRec:1;          // indicates if the current record is cached in Jet
   BOOL         JetNewRec:1;            // Indicates if this is an insert
   BOOL         fIsMetaDataCached:1;    // Has pMetaDataVec been cached for this
                                        //   object?
   BOOL         fIsLinkMetaDataCached:1;  // Has pLinkMetaData been cached for this
                                        //   object?
   BOOL         fMetaDataWriteOptimizable:1; // Indicates if the meta data write
                                             // can be optimized; A meta data write
                                             // can be explicitly optimized only if
                                             // the meta data changes are in-place
                                             // (i.e. no inserts or deletes)
                                             // This flag is meaningful only if
                                             // fIsMetaDataCached is TRUE.
   BOOL         fHidden:1 ;             // Is this the Hidden record PDB. The hidden
                                        // record pDB is based on an  independant
                                        // jet session, that is unrelated to the
                                        // jet session on pTHStls. Therefore this
                                        // state needs to be maintained so that a
                                        // proper transaction level count can be
                                        // maintained.
   BOOL         fFlushCacheOnUpdate:1;  // Set when the update in progress in
                                        //   JetObjTbl includes a name, objflag,
                                        //   or other change that affects the
                                        //   DN read cache.  Forces a flush of
                                        //   the DNT from the read cache on
                                        //   DBUpdateRec().
   BOOL         fScopeLegacyLinks:1;    // When this flag is set, search for links
                                        // on special index that excludes metadata
   BOOL         fSkipMetadataUpdate:1;  // when this is set, we skip metadata update
                                        // this should olnly be set during
                                        // domain rename operation
   BOOL         fEnqueueSDPropOnUpdate:1; // Indicates that the update operation on the
                                        // current DNT has touched SD, PDNT or RDN.
                                        // If it did, then a non-trimmable SD propagation
                                        // will be enqueued for this DNT on DBUpdateRec().
   BOOL         fAncestryUpdated:1;     // Ancestry on the current object got updated in
                                        // this transaction. This flag is only set when
                                        // fEnqueueSDPropOnUpdate is also set.

   KEY          Key;                    // Search key associated with this pDB

   DNList  *pDNsAdded;                  // List of DNs added using this DBPOS

   DWORD        cbMetaDataVecAlloced;   // Allocated meta data vector size in
                                        //   bytes (if fIsMetaDataCached).
   PROPERTY_META_DATA_VECTOR *          // Per-property replication meta data
                pMetaDataVec;           //   for the object with currency (if
                                        //   fIsMetaDataCached).  Can be NULL.
   VALUE_META_DATA *rgLinkMetaData;     // Link value metadata
   ULONG        transincount;           // Current nesting level of DBtransIns
                                        // on this pDB.

   DWORD       *pAncestorsBuff;         // Buffer used to hold ancestors during
                                        // WHOLE_SUBTREE searches.  It's here
                                        // because down in the core of the
                                        // whole_subtree search, we read the
                                        // ancestors of search candidates.
                                        // Allocating and freeing a buff for
                                        // each one of these reads is really
                                        // painful. This is the only lasting
                                        // place to hang this buffer, without
                                        // forcing routines like LocalSearch to
                                        // be aware of this buffer.  This buffer
                                        // is not generally maintained; that is,
                                        // don't read the ancestors from here
                                        // unless you just put them there or you
                                        // will probably get some other objects
                                        // ancestors.
                                        // When allocated, it is THAllocOrg'ed
   DWORD        cbAncestorsBuff;        // Size in bytes of pAncestorsBuff

   PSECURITY_DESCRIPTOR pSecurity;      // The SD of the current object during
                                        // non-base searches.
                                        // This field is not generally maintained.
                                        // DBMatchSearchCriteria loads the SD and leaves
                                        // it in pDB->pSecurity. It is then used by
                                        // LocalSearch for passing to GetEntInf.
   BOOL        fSecurityIsGlobalRef;    // Is the security a ptr to the global SD cache data?
                                        // If not, then pSecurity is THAlloc'ed.

   DWORD       SearchEntriesVisited;    // number of entries visited during a search operation
   DWORD       SearchEntriesReturned;   // number of entries returned during a search operation
   ULONG       NewlyCreatedDNT;         // Last new row created in this transaction
   DWORD       cLinkMetaData;           // Count of link value meta data entries cached
   DWORD       cbLinkMetaDataAlloced;   // Size in bytes of rgLinkMetaData

   // NOTE: If you add new elements to this structure after the last non-DBG
   // element, you'll need to change the non-DBG DBPOS size calculation in
   // Dump_DBPOS() in dsexts\md.c.

   // Put all DBG components at end of structure so that dsexts routines
   // can easily ignore them (and get all other fields right) in both
   // debug and free builds.

#if DBG
   ULONG        TransactionLevelAtOpen; // This is the transaction level in the
                                        // thread state when the DBOpen was done.
                                        // DBTransOut's assert that the commit is always
                                        // to a level less than this transaction level.

   DWORD       numTempTablesOpened;     // count number of temporary tables opened
                                        // (used for sorting, intersecting)
#endif

}DBPOS, *PDBPOS;

extern BOOL  gfDoingABRef;

extern BOOL IsValidDBPOS(DBPOS * pDB);


__inline
BOOL
IsExactMatch(DBPOS *pDB) {

    // Test to see if we are doing an Exact Match query
    if ( (pDB->Key.pFilter) &&
         (pDB->Key.pFilter->choice == FILTER_CHOICE_ITEM) &&
         (pDB->Key.pFilter->FilterTypes.Item.choice == FI_CHOICE_EQUALITY) &&
         (!pDB->Key.pFilter->pNextFilter) ) {

        // We are doing an exact match.
        // Now test to make sure we have a unique record on the given Index.
        return ( (pDB->Key.pIndex) &&
                 (pDB->Key.pIndex->bIsEqualityBased) &&
                 (pDB->Key.pIndex->bIsUniqueRecord) &&
                 (!pDB->Key.pIndex->pNext) );
    }

    return FALSE;
}


#if DBG

#define VALID_DBPOS(pDB) IsValidDBPOS(pDB)

#else

#define VALID_DBPOS(pDB) (TRUE)

#endif

#if DBG

#define VALID_TRIBOOL(retval) \
        (( (retval) >= eFALSE) && ( (retval) <= eUNDEFINED))

#else

#define VALID_TRIBOOL(retval) (TRUE)

#endif


// Typedef for return codes.
typedef long DB_ERR;                    // same as JET_ERR

// Structure for composite index values
typedef struct {
    void *pvData;
    ULONG cbData;
} INDEX_VALUE;

// Some globals that define how we do ANR.  Default value of these is FALSE.
extern BOOL gfSupressFirstLastANR;
extern BOOL gfSupressLastFirstANR;

// Index ids for DBSetCurrentIndex.
typedef enum _eIndexId {
    Idx_Proxy = 1,
    Idx_MapiDN,
    Idx_Dnt,
    Idx_Pdnt,
    Idx_Rdn,
    Idx_DraUsn,
    Idx_DsaUsn,
    Idx_ABView,
    Idx_Phantom,
    Idx_Sid,
    Idx_Del,
    Idx_NcAccTypeName,
    Idx_NcAccTypeSid,
    Idx_LinkDraUsn,
    Idx_LinkAttrUsn,
    Idx_DraUsnCritical,
    Idx_LinkDel,
    Idx_Clean,
    Idx_InvocationId,
    Idx_ObjectGuid,
    Idx_NcGuid
  } eIndexId;

// The DNT of the root object
#define ROOTTAG 2

// DNT of the place holder "NOT AN OBJECT" object.
#define NOTOBJECTTAG 1

// An invalid DNT
#define INVALIDDNT 0xFFFFFFFF

//
// Some error returns
#define DB_success                       0
#define DB_ERR_UNKNOWN_ERROR             1 // catch those return 1;'s
#define DB_ERR_NO_CHILD                  2
#define DB_ERR_NEXTCHILD_NOTFOUND        3
#define DB_ERR_CANT_SORT                 4
#define DB_ERR_TIMELIMIT                 5
#define DB_ERR_NO_VALUE                  6
#define DB_ERR_BUFFER_INADEQUATE         7
//unused                                 8
#define DB_ERR_VALUE_TRUNCATED           9
#define DB_ERR_ATTRIBUTE_EXISTS         10
#define DB_ERR_ATTRIBUTE_DOESNT_EXIST   11
#define DB_ERR_VALUE_EXISTS             12
#define DB_ERR_SYNTAX_CONVERSION_FAILED 13
#define DB_ERR_NOT_ON_BACKLINK          14
#define DB_ERR_VALUE_DOESNT_EXIST       15
#define DB_ERR_NO_PROPAGATIONS          16
#define DB_ERR_DATABASE_ERROR           17
#define DB_ERR_CANT_ADD_DEL_KEY         18
#define DB_ERR_DSNAME_LOOKUP_FAILED     19
#define DB_ERR_NO_MORE_DEL_RECORD       20
#define DB_ERR_NO_SORT_TABLE            21
#define DB_ERR_NOT_OPTIMIZABLE          22
#define DB_ERR_BAD_INDEX                23
//unused                                24
#define DB_ERR_TOO_MANY                 25
#define DB_ERR_SYSERROR                 26
#define DB_ERR_BAD_SYNTAX               27
//unused                                28
#define DB_ERR_NOT_ON_CORRECT_VALUE     29
#define DB_ERR_ONLY_ON_LINKED_ATTRIBUTE 30
#define DB_ERR_EXCEPTION                31 // something blew up
#define DB_ERR_SHUTTING_DOWN            32
#define DB_ERR_WRITE_CONFLICT           33
#define DB_ERR_VLV_CONTROL              34
#define DB_ERR_NOT_AN_OBJECT            35
#define DB_ERR_ALREADY_INSERTED         JET_errKeyDuplicate
#define DB_ERR_NO_CURRENT_RECORD        JET_errNoCurrentRecord
#define DB_ERR_RECORD_NOT_FOUND         JET_errRecordNotFound
// NOTE: If you add an error to this list, you MUST add a corresponding
// DIRMSG_DB_ERR_* in mdcodes.mc.

DB_ERR
DBErrFromJetErr(
    IN  DWORD   jetErr
    );

extern DWORD
DBRenameInstallDIT (
    DBPOS *pDB,
    BOOL fAddWhenCreated,
    SZ   szEnterpriseName,
    SZ   szSiteName,
    SZ   szServerName
    );


extern int
DBInit ( void );

extern void
DBPrepareEnd( void );

extern void
DBQuiesce( void );

extern void
DBEnd (
       void
       );

extern USHORT
DBTransIn(
    DBPOS FAR *pDB
    );

extern USHORT
DBTransOut(DBPOS FAR *pDB,
       BOOL fCommit,
       BOOL fLazy
       );

extern USN
DBGetLowestUncommittedUSN (
    void
    );

extern USN
DBGetHighestCommittedUSN (
    void
    );

//
// Setting Flags stored in the database
//
extern CHAR gdbFlags[200];
// indexes used into this array
#define DBFLAGS_AUXCLASS 0

// flag that is set if the SDs need to be updated
// it is only set when an old DIT is detected (without SD table)
#define DBFLAGS_SD_CONVERSION_REQUIRED 1

// Root DNT GUID was updated
#define DBFLAGS_ROOT_GUID_UPDATED 2


// WARNING: The gdbFlags global and the DBUpdateHiddenFlags() is not 
// multi-thread safe, make sure you're only using this in a single 
// thread scenario like boot/dcpromo/etc...
ULONG DBUpdateHiddenFlags();


ULONG
DBGetOrResetBackupExpiration(
    DSTIME *  pllExpiration
    );

extern USHORT
DBGetHiddenRec (
    DSNAME **ppDSA,
    USN *pusnInit
    );

extern ULONG
DBReplaceHiddenDSA (
    DSNAME *pDSA
    );

extern ULONG
DBReplaceHiddenUSN (
    USN usnInit
    );

extern VOID
DBForceDurableCommit(
    VOID
    );

/*

DITSTATE - all you wanted to know

    Also see comments in the "switch(dstate)" in dsamain.c:DoInitialize()
    
        
    Main transitions happen in these functions:
    
        DoInitialize()      ->    (most setting of DitState happens here)
        
        InitInvocationID()  -> sets to eRestoredPhaseI  (on completion of restore phase I (snapshot only))
        
        ClearBackupState()  -> sets to eRunning         (on successful restore)
                            -> sets to eIfmDit          (on successful "restore" during a IFM DcPromo)
                            
        DBReplaceHiddenTableBackupCols()
                            -> sets to eBackedupDit     (on snapshot backup (OnPrepareSnapshotBegin())
                            -> sets to eRunning         (on snapshot cleanup (OnThaw() or OnAbort())

        
    Valid Transition sequences are:

        Snapshot Backup
            eRunning -> eBackedupDit -> (snapshot copy of DIT) -> (running DC) eRunning
                                                               -> (backedup DIT) stays eBackedupDit
                  
        Snapshot Restore
            eBackedupDit -> eRestoredPhaseI -> eRunning
            
                       
        Regular DCPromo (all cases root domain, replica, child, etc)
            eBootDit -> (at/near end of DCPromo) eRealInstalledDit -> (on reboot from dcpromo) eRunning
            
        
        IFM DCPromo off Legacy Backup
            eRunningDit -> (at restore end) eIfmDit -> eRealInstalledDit -> (on reboot from dcpromo) eRunning
        
        
        IFM DCPromo off Snapshot Backup
            eBackedupDit -> eRestoredPhaseI -> (at restore end) eIfmDit
                -> eRealInstalledDit -> (on reboot from dcpromo) eRunning
         
        
        Upgrade, also any not previously upgraded DIT will transition itself to the new set of DitStates 
        from eInstalledDit.  Please don't use eInstalledDit to mean anything:
            eInstalledDit -> eRunningDit
        
        
        mkdit.exe ... and finally don't forget that mkdit.exe which makes our original install DITs does this:
            eInitialDit -> eBootDit

*/
typedef enum
{
    eInitialDit,        // The initial DIT made by mkdit.exe starts in this state.
    eBootDit,           // All "new" DITs have this state, mkdit.exe sets this state by the time it finishes.
    eInstalledDit,      //   deprecated state, please don't use (this was win2k's running state)
    eRunningDit,        // A running .NET DC will have it's DIT in this state.
    eBackedupDit,       // When a DIT is backed up (only via snapshot not legacy) it's put in this state.
    eErrorDit,          // Something bad happened during dcpromo/mkdit.exe and now the DIT is unuseable, and unrecoverable.
    eRestoredPhaseI,    // If the first phase of restore completed, we get set to this state.
    eRealInstalledDit,  // State used to indicate that dcpromo completed on this DIT.
    eIfmDit,            // This is the state immediately post "restore" during an IFM DcPromo

    // New states should be inserted here.

    eMaxDit // Invalid value, don't use this state.
}DITSTATE;

ULONG
DBReplaceHiddenTableBackupCols(
    BOOL        fSetUsnAtBackup,
    BOOL        fSetBackedupDitState,
    BOOL        fUnSetBackupState,
    DSTIME      dstimeBackupExpiration,
    USN         usnAtBackup
    );

ULONG DBGetHiddenStateInt(
    DBPOS * pDB, 
    DITSTATE* pState
    );

extern ULONG
DBGetHiddenState(
    DITSTATE* pState
    );

extern ULONG
DBSetHiddenState(
    DITSTATE State
    );

// This quasi-function sets the DITSTATE column with a normal DBPOS.  Note must use global 
// hidden db columnids from dbinit.c and the passed in value, must actually be a variable, 
// not a value in the enum itself.
#define DBSetHiddenDitStateAlt(pDB, eDitState)  DBSetHiddenTableStateAlt(pDB, dsstateid, &eDitState, sizeof(eDitState))
ULONG 
DBSetHiddenTableStateAlt(
    DBPOS *         pDBNonHidden,
    JET_COLUMNID    jcidStateType,
    void *          pvStateValue,
    DWORD           cbStateValue
    );

// GetSecondsSince1601 defined in taskq.lib.
extern DSTIME
GetSecondsSince1601();

#define DBTime GetSecondsSince1601

typedef struct _THSTATE THSTATE;
DWORD DBInitThread( THSTATE* pTHS );
DWORD DBCloseThread( THSTATE* pTHS );
void DBDestroyThread( THSTATE* pTHS );

DWORD DBInitQuotaTable();

void
DBOpen2 (
    BOOL fNewTransaction,
    DBPOS FAR **ppDB
    );

#define DBOpen(ppDB) DBOpen2(TRUE, ppDB)

extern DWORD
DBClose (
    DBPOS *pDB,
    BOOL fCommit
    );


// DBCloseSafe is the same as DBClose, except that it is guaranteed never to
// raise an exception (more precisely, that it will catch any that are raised
// and convert them to error codes.)
extern DWORD
DBCloseSafe (
    DBPOS *pDB,
    BOOL fCommit
    );


// this is the number of entries to be sorted for which it is economical to use
// a forward-only sort table.  forward-only sorts allocate large chunks of
// virtual address space during processing while normal sorts only use space
// in the database cache like any other table
#define MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT 100

// Some flags for sort table creation.
#define DB_SORT_DESCENDING 0x1
#define DB_SORT_ASCENDING  0x0
#define DB_SORT_FORWARDONLY 0x2
extern DB_ERR
DBOpenSortTable (DBPOS *pDB,
                 ULONG SortLocale,
                 DWORD flags,
                 ATTCACHE *pAC);

extern DB_ERR
DBCloseSortTable (DBPOS *pDB);

extern DB_ERR
DBInsertSortTable (DBPOS *pDB,
           CHAR * TextBuff,
           DWORD cb,
           DWORD DNT);

DB_ERR
DBDeleteFromSortTable (
        DBPOS *pDB
        );

extern DB_ERR
DBGetDNTSortTable (
        DBPOS *pDB,
        DWORD *pvData
        );

extern DWORD
DBPositionVLVSearch (
    DBPOS *pDB,
    SEARCHARG *pSearchArg
    );

// Some flags for DBMove
#define DB_MoveNext     0x00000001
#define DB_MovePrevious 0xFFFFFFFF
#define DB_MoveFirst    0x80000000
#define DB_MoveLast     0x7FFFFFFF
extern DB_ERR
DBMove (
    DBPOS * pDB,
    BOOL UseSortTable,
    LONG Distance
    );

DB_ERR
DBMoveEx (
       DBPOS * pDB,
       JET_TABLEID Cursor,
       LONG Distance
       );

extern DB_ERR
DBMovePartial (
       DBPOS * pDB,
       LONG Distance
       );

DWORD __fastcall
DBMakeCurrent(DBPOS *pDB);

extern DB_ERR
DBSetFractionalPosition(DBPOS *pDB,
            DWORD Numerator,
            DWORD Denominator);

extern void
DBGetFractionalPosition (DBPOS * pDB,
             DWORD * Numerator,
             DWORD * Denominator);

extern DB_ERR
DBSetCurrentIndex(DBPOS *pDB,
                  eIndexId indexid,
                  ATTCACHE * pAC,
                  BOOL MaintainCurrency);

DB_ERR
DBSetLocalizedIndex(
        DBPOS *pDB,
        eIndexId IndexId,
        unsigned long ulLangId,
        INDEX_VALUE *pIV,
        BOOL MaintainCurrency);

typedef struct _DBBOOKMARK {
    DWORD cbPrimaryBookMark;
    void *pvPrimaryBookMark;
    DWORD cbSecondaryBookMark;
    void *pvSecondaryBookMark;
} DBBOOKMARK;

extern void
DBGetBookMark (
        DBPOS *pDB,
        DBBOOKMARK *pBookMark);

extern void
DBGotoBookMark (
        DBPOS *pDB,
        DBBOOKMARK BookMark
        );

void
DBGetBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark);

void
DBGotoBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark
        );

void
DBFreeBookMark(THSTATE *pTHS,
               DBBOOKMARK *pBookMark
               );

// Some flags for DBSeek
#define DB_SeekLT       0x00000001
#define DB_SeekLE       0x00000002
#define DB_SeekEQ       0x00000004
#define DB_SeekGE       0x00000008
#define DB_SeekGT       0x00000010
extern DB_ERR
DBSeek (
    DBPOS *pDB,
    INDEX_VALUE *pIV,
    DWORD nVals,
    DWORD SeekType
    );

DB_ERR
DBSeekEx (
       DBPOS *pDB,
       JET_TABLEID Cursor,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      );

DWORD
DBGetNCSizeExSlow(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    );

DWORD
DBGetApproxNCSizeEx(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    );

DWORD
DBGetEstimatedNCSizeEx(
    IN DBPOS *pDB,
    IN ULONG dntNC
    );


typedef enum
{
    eFALSE = 2,
    eTRUE = 3,
    eUNDEFINED = 4,
} TRIBOOL;


extern TRIBOOL
DBEval (
    DBPOS FAR *pDB,
    UCHAR Operation,
    ATTCACHE *pAC,
    ULONG valLenFilter,
    UCHAR *pValFilter
    );


extern DWORD
DBCompareABViewDNTs(DBPOS *pDB,
              DWORD lcid,
              DWORD DNT1,
              DWORD DNT2,
              LONG *pResult);

extern DWORD
DBSetIndexRange (
    DBPOS *pDB,
    INDEX_VALUE *pIV,
    DWORD nVals);

#define DBGetIndexSize(pDB, pSize) DBGetIndexSizeEx(pDB, pDB->JetObjTbl, pSize, FALSE)

extern void
DBGetIndexSizeEx(
        DBPOS *pDB,
        JET_TABLEID Cursor,
        ULONG *pSize,
        BOOL  fGetRoughEstimate
        );

DWORD
DBFindComputerObj(
        DBPOS *pDB,
        DWORD cchComputerName,
        WCHAR *pComputerName
        );

// In flag
#define DBCHOOSEINDEX_fUSEFILTER             0x01
#define DBCHOOSEINDEX_fREVERSE_SORT          0x02
#define DBCHOOSEINDEX_fPAGED_SEARCH          0x04
#define DBCHOOSEINDEX_fUSETEMPSORTEDTABLE    0x08
#define DBCHOOSEINDEX_fVLV_SEARCH            0x10
#define DBCHOOSEINDEX_fDELETIONS_VISIBLE     0x20

extern void
DBSetVLVArgs (
    DBPOS        *pDB,
    VLV_REQUEST  *pVLVrequest,
    ATTRTYP       SortAtt
    );

extern void
DBSetVLVResult (
        DBPOS       *pDB,
        VLV_REQUEST *pVLVRequest,
        PRESTART     pResRestart
    );

extern void
DBSetASQArgs (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest,
    COMMARG     *pCommArg
    );

extern void
DBSetASQResult (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest
    );


extern DWORD
DBChooseIndex (
    IN DBPOS  *pDB,
    IN DWORD   StartTick,
    IN DWORD   DeltaTick,
    IN ATTRTYP SortAttr,
    IN ULONG   SortType,
    IN DWORD   Flags,
    IN DWORD   MaxTempTableSize
    );

extern void
DBSetFilter (
    DBPOS FAR *pDB,
    FILTER *pFil,
    POBJECT_TYPE_LIST pFilSec,
    DWORD *pResults,
    ULONG FilSecSize,
    BOOL *pbSortSkip
    );

extern DWORD
DBRepositionSearch (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        DWORD StartTick,
        DWORD DeltaTick,
        ULONG Flags
        );

extern DWORD
DBMakeFilterInternal (
    DBPOS FAR *pDB,
    FILTER *pFil,
    PFILTER *pOutFil,
    ATTRTYP  *pErrAttrTyp
    );

extern TRIBOOL
DBEvalFilter(
    IN  DBPOS *   pDB,
    IN  BOOL      fUseObjTbl,
    IN  FILTER *  pFil
    );

extern void
DBGetKeyFromObjTable (
    DBPOS *pDB,
    BYTE  *ppb,
    ULONG *pcb
    );



// Some flags for DBGetNextSearchObject
#define DB_SEARCH_DELETIONS_VISIBLE         1
#define DB_SEARCH_FORWARD                   2
#define DB_SEARCH_DONT_EVALUATE_SECURITY    4
#define DB_SEARCH_OPT_EXACT_MATCH           8

extern DWORD
DBGetNextSearchObject (
    DBPOS *pDB,
    DWORD StartTick,
    DWORD DeltaTick,
    ULONG Flags
    );


extern DWORD
DBSetSearchScope (
    DBPOS *pDB,
    ULONG ulSearchType,
    BOOL  bOneNC,
struct _RESOBJ *pResRoot
    );




DWORD
DBFindChildAnyRDNType (
        DBPOS *pDB,
        DWORD PDNT,
        WCHAR *pRDN,
        DWORD ccRDN
        );

// Return Values for DBFind are from direrr.h
extern DWORD
DBFindDSNameAnyRDNType (
        DBPOS FAR *pDB,
        const DSNAME *pDN
        );

extern DWORD
DBFindDSName (
    DBPOS FAR *pDB,
    const DSNAME *pDN
    );

extern DWORD
DBFindGuid (
    DBPOS FAR *pDB,
    const DSNAME *pDN
    );

extern DWORD
DBFindObjectWithSid(
    DBPOS FAR *pDB,
    DSNAME * pDN,
    DWORD iObject
    );

extern DWORD
DBFindDNT (
    DBPOS FAR *pDB,
    ULONG Tag
    );

extern DWORD
DBTryToFindDNT (
    DBPOS FAR *pDB,
    ULONG Tag
    );

extern DWORD
DBFindBestMatch(
    DBPOS FAR *pDB,
    DSNAME *pDN,
        DSNAME **ppDN
    );



extern BOOL
DBHasValues(DBPOS *pDB,
        ATTRTYP Att
        );

extern BOOL
DBHasValues_AC(DBPOS *pDB,
           ATTCACHE *pAC
           );


extern DWORD
DBGetValueCount_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    );

// Flags for DBGetMultipleAtts
#define DBGETMULTIPLEATTS_fGETVALS     0x1
// The fEXTERNAL flag implies fGETVALS
#define DBGETMULTIPLEATTS_fEXTERNAL    0x3
#define DBGETMULTIPLEATTS_fREPLICATION 0x4
#define DBGETMULTIPLEATTS_fSHORTNAMES  0x8
#define DBGETMULTIPLEATTS_fMAPINAMES   0x10
#define DBGETMULTIPLEATTS_fREPLICATION_PUBLIC 0x20
#define DBGETMULTIPLEATTS_fOriginalValues 0x40

VOID
DBFreeMultipleAtts (
    DBPOS *pDB,
    ULONG *attrCount,
    ATTR **ppAttr
    );

// QUOTA_UNDONE: adding a "2" version of
// this function is a huge HACK to be able
// to pass the quota-trustee ldap control
// all the way down to dbGetConstructedAtt()
//
DWORD
DBGetMultipleAtts2 (
    DBPOS *pDB,
    ULONG cReqAtts,
    ATTCACHE *pReqAtts[],
    RANGEINFSEL *pRangeSel,
    RANGEINF *pRangeInf,
    ULONG *attrCount,
    ATTR **ppAttr,
    DWORD Flags,
    ULONG SecurityDescriptorFlags,
    PSID psidQuotaTrustee
    );

__inline DWORD
DBGetMultipleAtts (
    DBPOS *pDB,
    ULONG cReqAtts,
    ATTCACHE *pReqAtts[],
    RANGEINFSEL *pRangeSel,
    RANGEINF *pRangeInf,
    ULONG *attrCount,
    ATTR **ppAttr,
    DWORD Flags,
    ULONG SecurityDescriptorFlags )
{
    return DBGetMultipleAtts2(
					pDB,
                    cReqAtts,
                    pReqAtts,
                    pRangeSel,
                    pRangeInf,
                    attrCount,
                    ppAttr,
                    Flags,
                    SecurityDescriptorFlags,
                    NULL );
}

extern DWORD
DBFillGuidAndSid (
        DBPOS *pDB,
        DSNAME *pDN
        );

DWORD
DBFillDSName(
    DBPOS *    pDB,
    DSNAME **  ppDN,
    BOOL       fReAlloc
    );

VOID
DBFillResObj (
    DBPOS* pDB,
    DSNAME *pObj,
    ATTRTYP* pMSOC,
    ULONG* pIT,
    ULONG* pIsDel
    );


#define DBGETATTVAL_fINTERNAL   1       // Want data in internal format
#define DBGETATTVAL_fCONSTANT   2       // Caller is supplying a constant buf
#define DBGETATTVAL_fREALLOC    4       // Caller gives a THReallocable  bu
#define DBGETATTVAL_fSHORTNAME  8       // Caller wants names without strings
#define DBGETATTVAL_fMAPINAME  0x10     // Caller wants names in mapi format
#define DBGETATTVAL_fUSESEARCHTABLE 0x20 // Caller wants value read from search
                                         // table
#define DBGETATTVAL_fDONT_FIX_MISSING_SD 0x40 // Caller does not want to fix SD
                                              // if found missing
#define DBGETATTVAL_fINCLUDE_ABSENT_VALUES  0x80     // Include absent values
#define DBGETATTVAL_fDONT_EXCEPT_ON_CONVERSION_ERRORS 0x100 // don't except on syntax conversion errors

// Default is for return of value in external format in a freshly THAlloced buf
extern DWORD
DBGetAttVal (
    DBPOS FAR *pDB,
    ULONG N,
    ATTRTYP  aType,
    DWORD Flags,
    ULONG InBufSize,
    ULONG *pLen,
    UCHAR **pVal
    );

extern DWORD
DBGetAttVal_AC (
    DBPOS FAR *pDB,
    ULONG N,
    ATTCACHE *pAC,
    DWORD Flags,
    ULONG InBufSize,
    ULONG *pLen,
    UCHAR **pVal
    );

extern DB_ERR
DBGetNextLinkVal_AC (
        DBPOS FAR *pDB,
        BOOL bFirst,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        );

extern DB_ERR
DBGetNextLinkValEx_AC (
    DBPOS FAR *pDB,
    BOOL bFirst,
    DWORD Sequence,
    ATTCACHE **pAC,
    DWORD Flags,
    ULONG InBuffSize,
    ULONG *pLen,
    UCHAR **ppVal
    );

extern DB_ERR
DBGetNextLinkValForLogon(
        DBPOS   FAR * pDB,
        BOOL    bFirst,
        ATTCACHE * pAC,
        PULONG  pulDNTNext
        );

extern DB_ERR
DBGetSingleValue(DBPOS *pDB,
         ATTRTYP Att,
         void * pvData,
         DWORD cbData,
         DWORD *pReturnedSize);
extern DB_ERR
DBGetSingleValueFromIndex (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pReturnedSize);


extern DWORD
DBResetRDN (
    DBPOS *pDB,
    ATTRVAL *pAVal
    );

DB_ERR
DBMangleRDNforPhantom(
        IN OUT  DBPOS * pDB,
        IN      MANGLE_FOR eMangleFor,
        IN      GUID *  pGuid
        );

int
ExtIntDist (
        DBPOS FAR *pDB,
        USHORT extTableOp,
        ULONG extLen,
        UCHAR *pExtVal,
        ULONG *pIntLen,
        UCHAR **ppIntVal,
        ULONG ulUpdateDnt,
        JET_TABLEID jTbl,
        ULONG flags
        );

// Flags for DBResetParent().
#define DBRESETPARENT_CreatePhantomParent   ( 1 )
#define DBRESETPARENT_SetNullNCDNT          ( 2 )

extern DWORD
DBResetParent (
    DBPOS *pDB,
    DSNAME *pName,
        ULONG ulFlags
    );

ULONG
DBResetDN(
    IN  DBPOS *     pDB,
    IN  DSNAME *    pParentDN,
    IN  ATTRVAL *   pAttrValRDN
    );

void
DBCoalescePhantoms(
    IN OUT  DBPOS * pDB,
    IN      ULONG   dntRefPhantom,
    IN      ULONG   dntStructPhantom
    );

extern DWORD
DBAddAtt (
    DBPOS FAR *pDB,
    ATTRTYP aType,
    UCHAR syntax
    );

extern DWORD
DBAddAtt_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    UCHAR syntax
    );

extern DWORD
DBAddAttVal(
    DBPOS FAR *pDB,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBAddAttVal_AC(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBAddAttValEx_AC(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal,
    VALUE_META_DATA *pRemoteValueMetaData
    );

extern DWORD
DBRemAtt(
    DBPOS FAR *pDB,
    ATTRTYP aType
    );

extern DWORD
DBRemAtt_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC
    );


extern DWORD
DBRemAttVal (
    DBPOS FAR *pDB,
    ATTRTYP aType,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBRemAttVal_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBRemAttValEx_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal,
    VALUE_META_DATA *pRemoteValueMetaData
    );

extern DWORD
DBReplaceAttVal (
    DBPOS FAR *pDB,
    ULONG N,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal);

extern DWORD
DBReplaceAttVal_AC (
    DBPOS FAR *pDB,
    ULONG N,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal);

extern DWORD
DBReplaceAtt_AC(
        PDBPOS  pDB,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal,
        BOOL         *pfChanged
        );

DWORD
DBFindAttLinkVal_AC(
    IN  DBPOS FAR *pDB,
    IN  ATTCACHE *pAC,
    IN  ULONG extLen,
    IN  void *pExtVal,
    OUT BOOL *pfPresent
    );

// Flags for DBRepl
#define DBREPL_fADD                     0x1
#define DBREPL_fROOT                    0x2
#define DBREPL_fRESET_DEL_TIME          0x4
#define DBREPL_fKEEP_WAIT               0x8     // Don't awaken ds_waiters
extern DWORD
DBRepl(
       DBPOS FAR *pDB,
       BOOL fDRA,
       DWORD fAddFlags,
       PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
       DWORD dwMetaDataFlags
       );

extern VOID
DBResetAtt (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG len,
    void *pVal,
    UCHAR syntax
    );

extern DWORD
DBResetAttLVOptimized (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG ulOffset,
    ULONG lenSegment,
    void *pValSegment,
    UCHAR syntax
    );

extern DWORD
DBPhysDel (
    DBPOS FAR *pDB,
    BOOL fGarbCollectASAP,
    ATTCACHE *pACDel
    );

DWORD
DBPhysDelLinkVal(
    IN DBPOS *pDB,
    IN ULONG ulObjectDnt,
    IN ULONG ulValueDnt
    );

extern BOOL
DBCheckToGarbageCollect (
    DBPOS FAR *pDB,
    ATTCACHE *pAC
    );

extern USHORT
DBUpdateRec (
    DBPOS FAR *pDB
    );

extern DWORD
DBInitObj (
    DBPOS FAR *pDB
    );

extern DWORD
__fastcall
DBInitRec (
    DBPOS* pDB
    );

#define DB_LOCK_DN_CONFLICT_NODE       1
#define DB_LOCK_DN_CONFLICT_TREE_ABOVE 2
#define DB_LOCK_DN_CONFLICT_TREE_BELOW 4
#define DB_LOCK_DN_CONFLICT_STICKY     8
#define DB_LOCK_DN_CONFLICT_UNKNOWN    16
extern DWORD
DBLockDN (
    DBPOS  *pDB,
    DWORD   dwFlags,
    DSNAME *pDN
    );

DWORD
DBUnlockStickyDN (
        PDSNAME pObj
        );

extern USN
DBGetNewUsn (
    void
    );


extern DWORD
DBAddDelIndex(
    DBPOS *pDB,
        BOOL fGarbCollectASAP
    );

extern void
DBGetAncestors(
        IN      DBPOS *  pDB,
        IN OUT  DWORD *  pcbAncestorsSize,
        IN OUT  ULONG ** ppdntAncestors,
        OUT     DWORD *  pcNumAncestors
        );

void
DBGetAncestorsFromCache(
    IN      DBPOS *  pDB,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    );

#define DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE   0
#define DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE   1
#define DBGETOBJECTSECURITYINFO_fSEEK_ROW           2
#define DBGETOBJECTSECURITYINFO_fDONT_EXCEPT_ON_MISSING_DNT 4

extern DWORD
DBGetObjectSecurityInfo(
    PDBPOS pDB,
    DWORD dnt,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *ppNTSD,
    CLASSCACHE **ppCC,
    PDSNAME pDN,
    char    *pObjFlag,
    DWORD   flags,
    BOOL    *pfSDIsGlobalSDRef
    );

extern DWORD
DBGetParentSecurityInfo (
    PDBPOS pDB,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *pNTSD,
    CLASSCACHE **ppCC,
    PDSNAME pDN,
    BOOL*   pfSDIsGlobalSDRef
    );

extern VOID
DBAddSDPropTime (
     DBPOS * pDB,
     BYTE flags
     );

#define DBEnqueueSDPropagation(pDB, bTrimmable) DBEnqueueSDPropagationEx(pDB, bTrimmable, 0)

// SD prop flags
// force SD update even if it seems the SD data has not changed
#define SD_PROP_FLAG_FORCEUPDATE 1

extern DWORD
DBEnqueueSDPropagationEx(
        DBPOS * pDB,
        BOOL bTrimmable,
        DWORD dwFlags
        );

extern DWORD
DBGetNextPropEvent(
        DBPOS * pDB,
        SDPropInfo *pInfo
        );

extern DWORD
DBGetLastPropIndex(
        DBPOS * pDB,
        DWORD *pdwIndex
        );

extern DWORD
DBThinPropQueue (
        DBPOS * pDB,
        DWORD   DNT
        );

extern DWORD
DBPopSDPropagation (
        DBPOS * pDB,
        DWORD index
        );

DWORD
DBSDPropagationInfo (
        DBPOS * pDB,
        DWORD dwClientID,
        DWORD *pdwSize,
        SDPropInfo **ppInfo
        );

extern  DWORD
DBSDPropInitClientIDs (
        DBPOS * pDB
        );

// This is the count of the number of links that must be able to be
// removed immediately when an object is deleted.  We want to set this
// conservatively so that it isn't an impediment under low-memory/
// high load conditions.

#define DB_COUNT_LINKS_PROCESSED_IMMEDIATELY 1000

extern DWORD
DBRemoveLinks(
    DBPOS *pDB
    );

DWORD APIENTRY
DBRemoveLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    );

void
DBRemoveAllLinks(
        DBPOS *pDB,
        DWORD DNT,
        BOOL fIsBacklink
        );

DWORD
DBRemoveAllLinksHelp_AC(
        DBPOS *pDB,
        DWORD DNT,
        ATTCACHE *pAC,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        );

DWORD APIENTRY
DBTouchLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC,
    BOOL fIsBacklink
    );

DWORD
DBTouchAllLinksHelp_AC(
        DBPOS *pDB,
        ATTCACHE *pAC,
        USN usnEarliest,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        );

BOOL
DBHasLinks(
    DBPOS *pDB,
    DWORD DNT,
    BOOL fIsBacklink
    );

BOOL
DBHasLinkedValuesWithMetadata(
    DBPOS *pDB,
    ATTCACHE *pAC
    );

DWORD DBGetNextDelRecord (
    DBPOS FAR *     pDB,
    DSTIME          ageOutDate,
    DSNAME **       ppRetBuf,
    BYTE *          pbSecondaryKey,
    const ULONG     cbSecondaryKey,
    BYTE *          pbPrimaryBookmark,
    const ULONG     cbPrimaryBookmark,
    BOOL *          pfObject
    );

DWORD DBGetNextEntryTTLRecord(
    IN  DBPOS       *pDB,
    IN  DSTIME      ageOutDate,
    IN  ATTCACHE    *pAC,
    IN  ULONG       ulNoDelDnt,
    OUT DSNAME      **ppRetBuf,
    OUT DSTIME      *pulLastTime,
    OUT BOOL        *pfObject,
    OUT ULONG       *pulNextSecs
    );

DWORD
DBGetNextDelLinkVal(
    IN DBPOS FAR *pDB,
    IN DSTIME ageOutDate,
    IN OUT DSTIME *ptLastTime,
    IN OUT ULONG *pulObjectDnt,
    IN OUT ULONG *pulValueDnt
    );

DWORD
DBGetNextObjectNeedingCleaning(
    DBPOS FAR *pDB
    );

void
DBNotifyReplicasCurrDbObj (
                           DBPOS *pDB,
                           BOOL fUrgent
                           );
void
DBNotifyReplicas (
                  DSNAME *pObj,
                  BOOL fUrgent
                  );

BOOL DBGetIndexName (ATTCACHE *pAC,
                     DWORD flags,
                     DWORD dwLcid,
                     CHAR *szIndexName,
                     DWORD cchIndexName);

VOID
DBSetObjectNeedsCleaning(
    DBPOS *pDB,
    BOOL fNeedsCleaning
    );

// Debugging routines
#if DBG
void DprintName(DSNAME  *pN);
void DprintAddr(UNALIGNED SYNTAX_ADDRESS *pAddr);

#define DPRINTNAME(pN) DprintName(pN)
#define DPRINTADDR(pAddr) DprintAddr(pAddr)

#else

#define DPRINTNAME(pN)
#define DPRINTADDR(pAddr)

#endif

// Useful macros for looking at link/backlink attributes
// Warning: The code for AutoLinkId assumes forward
// links are even and the corresponding backlink is (+1)
// and the next forward link is (+2).
#define FIsBacklink(linkid)             ((linkid) & 1)
#define FIsLink(linkid)                 ((linkid) && !FIsBacklink(linkid))
#define MakeLinkBase(linkid)            ((linkid) >> 1)
#define MakeLinkId(linkbase)            ((linkbase) << 1)
#define MakeBacklinkId(linkbase)        (((linkbase) << 1) | 1)
#define MakeMatchingLinkId(linkid)      ((linkid) ? ((linkid)^1) : (linkid))

// AutoLinkId
// Automatically generate a linkid when the user specifies a special,
// reserved linkid value.  The only interoperability issue with existing
// schemas is that a user cannot define a backlink for an existing
// forward link whose id is RESERVED_AUTO_LINK_ID. Considered not a problem
// because 1) microsoft has not allocated linkid -2 to anyone and
// 2) practically and by convention, forward links and back links
// are created at the same time. If a user did generate this unsupported
// config, then the user must create a new link/backlink pair and fix
// up the affected objects.
//
// The ldap head cooperates in this venture by translating the ldapDisplayName
// or OID for a LinkId attribute into the corresponding schema cache entry
// and:
//      1) If the schema cache entry is for ATT_LINK_ID, then the caller's
//      linkid is set to RESERVED_AUTO_LINK_ID. Later, underlying code
//      automatically generates a linkid in the range
//      MIN_RESERVED_AUTO_LINK_ID to MAX_RESERVED_AUTO_LINK_ID.
//
//      2) If the schema cache entry is for a for an existing forward link,
//      then the caller's linkid is set to the corresponding backlink value.
//
//      3) Otherwise, the caller's linkid is set to RESERVED_AUTO_NO_LINK_ID
//      and later, underlying code generates a ERROR_DS_BACKLINK_WITHOUT_LINK
//      error.
//
// An error ERROR_DS_RESERVED_LINK_ID is returned if the user specifies
// linkid in the reserved range MIN... to MAX... The range reserves 1G-2
// linkids. Should be enough. At whistler, less than 200 linkids are in use.
// Existing schemas, or schemas modified on W2K DCs, may use linkids in
// this range without affecting the functionality except as noted above.
#define MIN_RESERVED_AUTO_LINK_ID       ((ULONG)0xc0000000)
#define MAX_RESERVED_AUTO_LINK_ID       ((ULONG)0xFFFFFFFC)
#define RESERVED_AUTO_LINK_ID           ((ULONG)0xFFFFFFFE)
#define RESERVED_AUTO_NO_LINK_ID        ((ULONG)0xFFFFFFFF)

// These are only used by scache.c
#define SZDATATABLE             "datatable"      // name of JET data table
#define SZLCLINDEXPREFIX        "LCL_"
#define SZATTINDEXPREFIX        "INDEX_"
#define SZATTINDEXKEYPREFIX     "ATT"
#define CHATTSYNTAXPREFIX       'a'
#define CHPDNTATTINDEX_PREFIX   'P'
#define CHTUPLEATTINDEX_PREFIX  'T'

//  AttributeIndexRebuild table
//
#define g_szIdxRebuildTable             "AttributeIndexRebuild"
#define g_szIdxRebuildColumnIndexName   "Index Name"
#define g_szIdxRebuildColumnAttrName    "Attribute Name"
#define g_szIdxRebuildColumnType        "Type"
#define g_szIdxRebuildIndexName         "Index Name"


typedef struct _INDEX_INFO {
    DWORD attrType;
    int   syntax;
    DWORD indexType;
}  INDEX_INFO;
extern INDEX_INFO IndicesToKeep[];
extern DWORD cIndicesToKeep;

extern BOOL
AttInIndicesToKeep (
    ULONG id
    );

extern INDEX_INFO * PindexinfoAttInIndicesToKeep( const ULONG attid );

extern int
DBAddColIndex (
    ATTCACHE *pAC,
    DWORD eSearchFlags,
    JET_GRBIT CommonGrbit
    );

extern int
DBDeleteColIndex (
    ATTRTYP aid,
    DWORD eSearchFlags
    );

extern int
DBRecreateRequiredIndices(JET_SESID sesid,
                       JET_DBID dbid);

extern int
DBAddCol (
    ATTCACHE *pAC
    );

extern int
DBDeleteCol (
    ATTRTYP aid,
    unsigned syntax
    );

extern void
DBCreateRestart(
        DBPOS *pDB,
        PRESTART *ppRestart,
        DWORD SearchFlags,
        DWORD problem,
        struct _RESOBJ   *pResObj
        );

DWORD
DBCreateRestartForSAM(
        DBPOS    *pDB,
        PRESTART *ppRestart,
        eIndexId  idIndexForRestart,
        struct _RESOBJ  *pResObj,
        DWORD     SamAccountType
        );

struct _RESOBJ *
ResObjFromRestart(
        struct _THSTATE  *pTHS,
        DSNAME   *pDN,
        RESTART  *pRestart
        );

void
DBTouchMetaData(
        DBPOS * pDB,
        ATTCACHE * pAC
        );

extern
VOID
DBAdjustRefCount(
        DBPOS *pDB,
        DWORD DNT,
        long  delta);

extern
VOID
DBAdjustABRefCount(
        DBPOS *pDB,
        DWORD DNT,
        long  delta);

extern USHORT
DBCancelRec(
        DBPOS * pDB
        );

extern char
DBCheckObj(
        DBPOS FAR *pDB
        );

extern DWORD
DBMapiNameFromGuid_W (
        wchar_t *pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        );

extern DWORD
DBMapiNameFromGuid_A (
        PUCHAR pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        );

extern DWORD
DBGetGuidFromMAPIDN (
        PUCHAR pStringDN,
        GUID *pGuid
        );

extern BOOL
DBIsObjDeleted(DBPOS *pDB);

extern void
DBDefrag(DBPOS * pDB, ULONG durationInSeconds);

// NTRAID#NTRAID-580234-2002/03/18-andygo:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
// REVIEW:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
#ifdef  CHECK_FOR_ADMINISTRATOR_LOSS
VOID
DBCheckForAdministratorLoss(
     ULONG ulDNTObject,
     ULONG ulDNTAttribute
     );


VOID
DBGetAdministratorAndAdministratorsDNT();
#endif


DWORD
DBGetChildrenDNTs(
        DBPOS  *pDB,
        DWORD  ParentDNT,
        DWORD  **ppDNTs,
        DWORD  *pDNTsLength,
        DWORD  *pDNTsCount,
        BOOL   *pfMoreChildren,
        DWORD  dwBatchSize,
        PWCHAR pLastRDNLoaded,
        DWORD* pcbLastRDNLoaded
        );

DWORD
DBGetDepthFirstChildren (
        DBPOS   *pDB,
        PDSNAME **ppNames,
        DWORD   *iLastName,
        DWORD   *cMaxNames,
        BOOL    *fWrapped,
        BOOL    fPhantomizeSemantics
        );


ULONG
DBMetaDataModifiedList(
    DBPOS *pDB,
    ULONG *pCount,
    ATTRTYP **ppAttList);

DWORD
MakeInternalValue (
        DBPOS *pDB,
        int syntax,
        ATTRVAL *pInAVal,
        ATTRVAL *pOutAVal
        );


extern HANDLE hevDBLayerClear;
DWORD
DBCreatePhantomIndex(
        DBPOS *pDB
        );

DWORD
DBUpdateUsnChanged(
        DBPOS *pDB
        );


PDSNAME
DBGetCurrentDSName(
        DBPOS *pDB
        );

PDSNAME
DBGetDSNameFromDnt(
        DBPOS *pDB,
        ULONG ulDnt
        );
ULONG
DBGetDntFromDSName(
        DBPOS *pDB,
        PDSNAME pName
        );
void
DBReleaseSession(DBPOS *pDB);

void
DBClaimSession(DBPOS *pDB);

ULONG
DBClaimReadLock(DBPOS *pDB);

ULONG
DBClaimWriteLock(DBPOS *pDB);

void
InPlaceSwapSid(PSID pSid);

BOOL
__fastcall
DBIsSecretData(ATTRTYP attrType);

BOOL
__fastcall
DBIsHiddenData(ATTRTYP attrType);

DWORD
DBGetExtraHackyFlags(ATTRTYP attrType);

DWORD
DBResetParentByDNT (
        DBPOS *pDB,
        DWORD  dwNewParentDNT,
        BOOL  fTouchMetadata
        );

DWORD
DBFindBestProxy(
    DBPOS   *pDB,
    BOOL    *pfFound,
    DWORD   *pdwEpoch);

DWORD
DBGetIndexHint(
    IN  char * pszIndexName,
    OUT struct tagJET_INDEXID **ppidxHint);

void
DBGetLinkValueMetaData(
    IN  DBPOS *pDB,
    ATTCACHE *pAC,
    OUT VALUE_META_DATA *pMetaDataLocal
    );

// Determine if this value metadata was derived from a legacy value
#define IsLegacyValueMetaData( p ) ((p)->MetaData.dwVersion == 0)

void
DBSetDelTimeTo(
    DBPOS *             pDB,
    LONGLONG            llDelTime
    );

void
DBGetLinkTableData(
    PDBPOS           pDB,
    DWORD           *pulObjectDnt,
    DWORD           *pulValueDnt,
    DWORD           *pulRecLinkBase
    );

void
DBGetLinkTableDataDel (
        PDBPOS           pDB,
        DSTIME          *ptimeDeleted
        );

void
DBGetLinkTableDataUsn (
        PDBPOS           pDB,
        DWORD           *pulNcDnt,
        USN             *pusnChanged,
        DWORD           *pulDnt
        );

UCHAR *
DBGetExtDnFromDnt(
    DBPOS *pDB,
    ULONG ulDnt
    );

void
DBLogLinkValueMetaData(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN USN *pUsn,
    IN VALUE_META_DATA_EXT *pMetaDataExt
    );

VOID
DBSearchCriticalByDnt(
    DBPOS *pDB,
    DWORD dntObject,
    BOOL *pCritical
    );

BOOL
DBSearchHasValuesByDnt(
    IN DBPOS        *pDB,
    IN DWORD        DNT,
    IN JET_COLUMNID jColid
    );

void
DBGetObjectTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt,
    USN             *pusnChanged,
    DWORD           *pulDnt
    );

VOID
DBImproveAttrMetaDataFromLinkMetaData(
    IN DBPOS *pDB,
    IN OUT PROPERTY_META_DATA_VECTOR ** ppMetaDataVec,
    IN OUT DWORD * pcbMetaDataVecAlloced
    );

DWORD
DBMoveObjectDeletionTimeToInfinite(
    DSNAME * pdsa
    );

void
DBCreateSearchPerfLogData (
    DBPOS*      pDB,
    FILTER*     pFilter,
    BOOL        fFilterIsInternal,
    ENTINFSEL*  pSelection,
    COMMARG*    pCommArg,
    PWCHAR*     pszFilter,
    PWCHAR*     pszRequestedAttributes,
    PWCHAR*     pszCommArg);

void DBGenerateLogOfSearchOperation (DBPOS *pDB);

VOID
DBGetValueLimits (
        ATTCACHE *pAC,
        RANGEINFSEL *pRangeSel,
        DWORD *pStartIndex,
        DWORD *pNumValues,
        BOOL  *pDefault
        );

DB_ERR
DBMatchSearchCriteria (
        DBPOS FAR *pDB,
        BOOL  fDontEvaluateSecurity,
        BOOL *pbIsMatch);

DB_ERR
DBTrimDSNameBy(
    DBPOS *pDB,
    DSNAME *pDNSrc,
    ULONG cava,
    DSNAME **ppDNDst
    );

DB_ERR
DBRefreshDSName(
    DBPOS *pDB,
    DSNAME *pDNSrc,
    DSNAME **ppDNDst
    );

BOOL
DBHasChildren(
    DBPOS *pDB,
    DWORD  pdnt,
    BOOL   fIncludeDel
    );

DB_ERR
DBGetFreeSpace(
    DBPOS *pDB,
    ULONG* pulFreeMB,
    ULONG* pulAllocMB
    );

DWORD DBUpdateRootGuid(
    THSTATE* pTHS
    );

DWORD
DBPropExists (
    DBPOS * pDB,
    DWORD DNT,
    DWORD dwExcludeIndex,
    BOOL* pfExists
    );

DWORD
DBSDPropSaveCheckpoint(
    DBPOS * pDB,
    DWORD dwIndex,
    PVOID pCheckpointData,
    DWORD cbCheckpointData
    );

#endif  // _db_global_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dracheck.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dracheck.h
//
//--------------------------------------------------------------------------

/*****************************************************************************/
/* EMS DRA Consistency external declarations                                 */
/*****************************************************************************/
/* Comands to consistency checker                               	     */
/*****************************************************************************/

enum KCC_COMMAND {
    KCC_CHECK = 2,
    KCC_QUIT
};
/*****************************************************************************/
/* FLags to modify operation		                               	     */
/*****************************************************************************/
#define KCC_ASYNC_OP	1	// Run check asynchronously
#define	KCC_NO_WAIT	0x2	// Don't wait if check is already running

/*****************************************************************************/
/* Entry points exported by DRA Consistency DLL                               */
/*****************************************************************************/
typedef DWORD (WINAPI *DRACheck_DLL_INITFN)
		(LPCSTR szEnt, LPCSTR szSite, LPCSTR szServer);
DWORD WINAPI KccInit(LPCSTR szEnt, LPCSTR szSite, LPCSTR szServer);
typedef DWORD (WINAPI *DRACheck_DLL_ENTRYFN) (enum KCC_COMMAND command, DWORD ulFlag);
DWORD WINAPI KccCommand(enum KCC_COMMAND command, DWORD ulFlag);

/*****************************************************************************/
/* Return code from DLL export                                               */
/*****************************************************************************/
#define		SUCCESS			0

/*****************************************************************************/
/* Name of DRACHECK DLL and entry point                                           */
/*****************************************************************************/
#define DRACHECK_DLL_NAME    "DRACHECK.DLL"
#if defined (_X86_)
#define DRACHECK_DLL_INIT    "KccInit@12"
#define DRACHECK_DLL_ENTRY   "KccCommand@8"
#else
#define DRACHECK_DLL_INIT    "KccInit"
#define DRACHECK_DLL_ENTRY   "KccCommand"
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsaalloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsaalloc.h
//
//--------------------------------------------------------------------------

/*

Description:
    Contains declarations of routines used to allocate memory for
    the RPC runtime.
*/

#ifndef _dsaalloc_h_
#define _dsaalloc_h_

#ifdef __cplusplus
extern "C" {
#endif

extern void* __RPC_USER MIDL_user_allocate( size_t bytes);
extern void __RPC_USER MIDL_user_free( void* memory);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\drax400.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drax400.h
//
//--------------------------------------------------------------------------

// Defines of error codes returned from the DRA X400 DLL

#define MAIL_SUCCESS 0
#define MAIL_SRC_NAME_ERROR 2
#define MAIL_DEST_NAME_ERROR 3
#define MAIL_OPEN_ERROR 4
#define MAIL_NO_MAIL 5
#define MAIL_REC_ERROR 6
#define MAIL_REC_ERROR_F 7
#define MAIL_NO_MEMORY 8
#define MAIL_LOAD_ERROR 9
#define MAIL_SEND_ERROR 10
#define MAIL_SEND_ERROR_F 10
#define MAIL_NDR_RCVD 11
#define MAIL_V2_EXCEPTION 12

// Define the MTS id structure passed between DRA and DLL

// The array sizes are from xmhp.h. That file cannot be included here
// because that requires a huge tree of further includes.

// Defines are 
#define ADMD_NAME_LEN 16        // MH_VL_ADMD_NAME 
#define COUNTRY_NAME_LEN 3      // MH_VL_COUNTRY_NAME
#define LOCAL_ID_LEN 32         // MH_VL_LOCAL_IDENTIFIER
#define PRMD_ID_LEN 16          // MH_VL_PRMD_IDENTIFIER

typedef struct _MTSID {
    char AdmdName[ADMD_NAME_LEN+1];           // Allow for termination
    char CountryName[COUNTRY_NAME_LEN+1];
    char LocalIdentifier[LOCAL_ID_LEN+1];
    char PrmdIdentifier[PRMD_ID_LEN+1];
} MTSID;
    

// This is the stucture to hold information from an NDR.

typedef struct _NDR_DATA {
    long Diagnostic;
    long Reason;
} NDR_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\drserr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drserr.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Replication error codes

Author:

Environment:

Notes:

    These errors are returned by the replica rpc functions, and are part of the
    formal wire interface between DSAs.  Do not change these values.

April 23, 1998  wlees
These values were once small constants.  Now they refer to standard Win32
values.  This file is effectively obsolete.  Do not add new values to this
file.  Instead, reference the ERROR_DS values directly.

Revision History:

--*/

#ifndef _drserr_
#define _drserr_

#define DRSERR_BASE                     0
#define DRAERR_Success                  0
#define DRAERR_Generic                  ERROR_DS_DRA_GENERIC
#define DRAERR_InvalidParameter         ERROR_DS_DRA_INVALID_PARAMETER
// ERROR_BUSY?
#define DRAERR_Busy                     ERROR_DS_DRA_BUSY
#define DRAERR_BadDN                    ERROR_DS_DRA_BAD_DN
#define DRAERR_BadNC                    ERROR_DS_DRA_BAD_NC
#define DRAERR_DNExists                 ERROR_DS_DRA_DN_EXISTS
#define DRAERR_InternalError            ERROR_DS_DRA_INTERNAL_ERROR
#define DRAERR_InconsistentDIT          ERROR_DS_DRA_INCONSISTENT_DIT
// DRAERR_ConnectionFailed/ERROR_DS_DRA_CONNECTION_FAILED not used anymore
#define DRAERR_BadInstanceType          ERROR_DS_DRA_BAD_INSTANCE_TYPE
// ERROR_NOT_ENOUGH_MEMORY?
#define DRAERR_OutOfMem                 ERROR_DS_DRA_OUT_OF_MEM
#define DRAERR_MailProblem              ERROR_DS_DRA_MAIL_PROBLEM
// DRAERR_ExtnConnectionFailed/ERROR_DS_DRA_EXTN_CONNECTION_FAILED not used
#define DRAERR_RefAlreadyExists         ERROR_DS_DRA_REF_ALREADY_EXISTS
#define DRAERR_RefNotFound              ERROR_DS_DRA_REF_NOT_FOUND
#define DRAERR_ObjIsRepSource           ERROR_DS_DRA_OBJ_IS_REP_SOURCE
#define DRAERR_DBError                  ERROR_DS_DRA_DB_ERROR
#define DRAERR_NoReplica                ERROR_DS_DRA_NO_REPLICA
// ERROR_ACCESS_DENIED?
#define DRAERR_AccessDenied             ERROR_DS_DRA_ACCESS_DENIED
#define DRAERR_SchemaMismatch           ERROR_DS_DRA_SCHEMA_MISMATCH
#define DRAERR_SchemaInfoShip           ERROR_DS_DRA_SCHEMA_INFO_SHIP
#define DRAERR_SchemaConflict           ERROR_DS_DRA_SCHEMA_CONFLICT
#define DRAERR_EarlierSchemaConflict    ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT
#define DRAERR_RPCCancelled             ERROR_DS_DRA_RPC_CANCELLED
#define DRAERR_SourceDisabled           ERROR_DS_DRA_SOURCE_DISABLED
#define DRAERR_SinkDisabled             ERROR_DS_DRA_SINK_DISABLED
#define DRAERR_NameCollision            ERROR_DS_DRA_NAME_COLLISION
#define DRAERR_SourceReinstalled        ERROR_DS_DRA_SOURCE_REINSTALLED
#define DRAERR_IncompatiblePartialSet   ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
#define DRAERR_SourceIsPartialReplica   ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
// ERROR_NOT_SUPPORTED?
#define DRAERR_NotSupported             ERROR_DS_DRA_NOT_SUPPORTED

// TODO: Need to make error codes in WINERROR.H
#define DRAERR_CryptError               ERROR_ENCRYPTION_FAILED
#define DRAERR_MissingObject            ERROR_OBJECT_NOT_FOUND
#define DRAERR_NotEnoughAttrs           ERROR_DS_NO_SUCH_OBJECT

// ** See note on adding new DRS errors above. **

// These errors are now obsolete.  Generate a compile-time syntax error
#undef ERROR_DS_DRA_CONNECTION_FAILED
#undef ERROR_DS_DRA_EXTN_CONNECTION_FAILED

// The folllowing errors are used within the DRA and will not be returned
// from the DRA API.

#define DRAERR_MissingParent    ERROR_DS_DRA_MISSING_PARENT

// The following are warning errors, which means that they may occur in
// normal operation. They are also logged in blue instead of yellow

#define DRAERR_Preempted        ERROR_DS_DRA_PREEMPTED
#define DRAERR_AbandonSync      ERROR_DS_DRA_ABANDON_SYNC

// The following are informational errors, which means that they may occur in
// normal operation. They are also logged in blue instead of yellow

#define DRAERR_Shutdown         ERROR_DS_DRA_SHUTDOWN


#endif /* ifndef _drserr_ */

/* end drserr.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\drsuapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drsuapi.h
//
//--------------------------------------------------------------------------

#ifndef _drsuapi_
#define _drsuapi_

/*
 * Historical Note: The I_DRSBlahBlahBlah naming convention was put in to
 * distinguish the top level replicators functions (DRS...) from their
 * IDL-friendly wrappers (I_DRS...), which took modified versions of many
 * data structures, because not all of the core data structures were
 * describable in IDL syntax, and to distinguish the server versions and
 * client versions of the API, which had to be embedded in the same module,
 * because the DS is both client and server for the replicator API.
 *
 *    DRSBlah     - The local DRS Blah function, took core structures
 *    IDL_DRSBlah - The server side stub for the RPC'ed Blah function,
 *                  which takes IDL structures, converts them to core,
 *                  and calls DRSBlah
 *    _IDL_DRSBlah - The client side stub for Blah, which takes IDL structures
 *    I_DRSBlah   - A wrapper around _IDL_DRSBlah which takes core structures
 *                  and takes a server name instead of an RPC handle.
 *
 * Please do not extend this confusing naming practice to functions other
 * than those described in the IDL interface itself.
 */

#include <mdglobal.h>         // THSTATE
#include <drs.h>              // DRS_MSG_*

typedef void * handle_t;

// Async RPC function call types.
typedef enum {
    DRS_ASYNC_CALL_NONE = 0,
    DRS_ASYNC_CALL_GET_CHANGES,
    DRS_ASYNC_CALL_MAX
} DRS_CALL_TYPE;

// Defined in drsuapi.c -- contents opaque here.
struct _DRS_CONTEXT_INFO;

typedef struct _DRS_ASYNC_RPC_ARGS {
    LPWSTR                      pszServerName;
    LPWSTR                      pszDomainName;
    union {
        struct {
            DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn;
            DWORD                         dwOutVersion;
            DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut;
            BYTE *                        pSchemaInfo;
        } GetChg;
    };
} DRS_ASYNC_RPC_ARGS;

// Async RPC state.
typedef struct _DRS_ASYNC_RPC_STATE {
    LIST_ENTRY                  ListEntry;
    DSTIME                      timeInitialized;
    RPC_ASYNC_STATE             RpcState;
    DWORD                       dwCallerTID;
    DRS_CALL_TYPE               CallType;
    DRS_ASYNC_RPC_ARGS          CallArgs;
    SESSION_KEY                 SessionKey;
    struct _DRS_CONTEXT_INFO *  pContextInfo;
    ULONG                       RpcCallReturn;
    unsigned                    fIsCallInProgress : 1;
} DRS_ASYNC_RPC_STATE;

// Synchronous Context call types
typedef enum {
    DRS_CALL_NONE = 0,
    DRS_CALL_NO_CALL,
    DRS_CALL_BIND,
    DRS_CALL_UNBIND,
    DRS_CALL_REPLICA_SYNC,
    DRS_CALL_GET_NC_CHANGES,
    DRS_CALL_UPDATE_REFS,
    DRS_CALL_REPLICA_ADD,
    DRS_CALL_REPLICA_DEL,
    DRS_CALL_VERIFY_NAMES,
    DRS_CALL_GET_MEMBERSHIPS,
    DRS_CALL_INTER_DOMAIN_MOVE,
    DRS_CALL_GET_NT4_CHANGE_LOG,
    DRS_CALL_CRACK_NAMES,
    DRS_CALL_ADD_ENTRY,
    DRS_CALL_GET_MEMBERSHIPS2,
    DRS_CALL_GET_OBJECT_EXISTENCE,
    DRS_CALL_GET_REPL_INFO,
    DRS_CALL_MAX
} DRS_CONTEXT_CALL_TYPE;

#ifdef INCLUDE_CALL_TABLES
LPWSTR rgCallTypeNameTable[] = {
    L"DRS_CALL_NONE",
    L"DRS_CALL_NO_CALL",
    L"DRS_CALL_BIND",
    L"DRS_CALL_UNBIND",
    L"DRS_CALL_REPLICA_SYNC",
    L"DRS_CALL_GET_NC_CHANGES",
    L"DRS_CALL_UPDATE_REFS",
    L"DRS_CALL_REPLICA_ADD",
    L"DRS_CALL_REPLICA_DEL",
    L"DRS_CALL_VERIFY_NAMES",
    L"DRS_CALL_GET_MEMBERSHIPS",
    L"DRS_CALL_INTER_DOMAIN_MOVE",
    L"DRS_CALL_GET_NT4_CHANGE_LOG",
    L"DRS_CALL_CRACK_NAMES",
    L"DRS_CALL_ADD_ENTRY",
    L"DRS_CALL_GET_MEMBERSHIPS2",
    L"DRS_CALL_GET_OBJECT_EXISTENCE",
    L"DRS_CALL_GET_REPL_INFO"
};
#endif

#ifndef NOPROCS

VOID
RpcCancelAll();

// Initialize/shutdown client binding handle cache for I_DRS* functions.
void DRSClientCacheInit(
    void
    );
void DRSClientCacheUninit(
    void
    );

// Get remote machine principal name.
DWORD
DRSMakeMutualAuthSpn(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszTargetServerName,
    IN  LPWSTR      pszTargetDomainName,    OPTIONAL
    OUT LPWSTR *    ppszSpn
    );

// Register DRS interface extensions to be advertised to server-side DSAs.
ULONG
DRSClientSetExtensions(
    IN  DRS_EXTENSIONS * pext   OPTIONAL
    );


//
// Function to set credentials; once set all I_DRS* calls use these credentials
// to set the credentials to NULL, pass in NULL for all values.
//
ULONG
DRSSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength   // number of characters NOT including terminating
                               // NULL
    );

void
DRSDestroyAsyncRpcState(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    );

BOOL
DRSIsRegisteredAsyncRpcState(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    );

#ifdef DRA
ULONG
_IDL_DRSBind(
    IN  handle_t            rpc_handle,
    IN  UUID *              puuidClientDsa,
    IN  DRS_EXTENSIONS *    pextClient,
    OUT DRS_EXTENSIONS **   ppextServer,
    OUT DRS_HANDLE *        phDrs
    );

ULONG
_IDL_DRSUnbind(
    IN OUT  DRS_HANDLE *    phDrs
    );
#endif /* DRA */

#ifdef DRA
ULONG
_IDL_DRSReplicaSync(
   DRS_HANDLE               hDrs,
   DWORD                    dwMsgVersion,
   DRS_MSG_REPSYNC *        pmsgSync
   );
#endif /* DRA */

ULONG
I_DRSReplicaSync(
    THSTATE *   pTHS,
    LPWSTR      pszDestinationDSA,
    DSNAME *    pNC,
    LPWSTR      pszSourceDSA,
    UUID *      puuidSourceDSA,
    ULONG       ulOptions
    );

#ifdef DRA
ULONG
_IDL_DRSGetNCChanges(
    RPC_ASYNC_STATE *       pAsyncState,
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_GETCHGREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_GETCHGREPLY *   pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetNCChanges(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      LPWSTR                        pszServerDnsDomainName,     OPTIONAL
    IN      DSNAME *                      pNC,
    IN      DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT     DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOutV1,
    OUT     PBYTE                         pSchemaInfo,
    IN OUT  DRS_ASYNC_RPC_STATE *         pAsyncState,                OPTIONAL
    OUT     BOOL *                        pfBindSuccess               OPTIONAL
    );

ULONG
I_DRSGetNCChangesComplete(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState,
    OUT     BOOL *                  pfBindSuccess OPTIONAL
    );

#ifdef DRA
ULONG
_IDL_DRSUpdateRefs(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_UPDREFS *   pmsgUpdRefs
    );
#endif /* DRA */

//
// Wrapper version of this call which does not take the call completed arg
//

#define I_DRSUpdateRefs(   pTHS, pszDSA, pNC, pszRepsToDSA, puuidRepsToDSA, ulOptions ) \
I_DRSUpdateRefsEx( pTHS, pszDSA, pNC, pszRepsToDSA, puuidRepsToDSA, ulOptions, NULL )

ULONG
I_DRSUpdateRefsEx(
    THSTATE *   pTHS,
    LPWSTR      pszDSA,
    DSNAME *    pNC,
    LPWSTR      pszRepsToDSA,
    UUID *      puuidRepsToDSA,
    ULONG       ulOptions,
    PULONG      pfCallCompleted
    );

#ifdef DRA
ULONG
_IDL_DRSReplicaAdd(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPADD *    pmsgAdd
    );
#endif /* DRA */

//
// Wrapper function to provide access to old interface without the call
// completed flag
//
#define I_DRSReplicaAdd(   pTHS, pszServerName, pNCName, pSourceDsaDN, pTransportDN, pszSourceDsaAddress, pSyncSchedule, ulOptions ) \
        I_DRSReplicaAddEx( pTHS, pszServerName, pNCName, pSourceDsaDN, pTransportDN, pszSourceDsaAddress, pSyncSchedule, ulOptions, NULL )

ULONG
I_DRSReplicaAddEx(
    THSTATE *pTHS,
    LPWSTR szDestinationDSA,
    PDSNAME pNCName,
    PDSNAME pSourceDsaDN,
    PDSNAME pTransportDN,
    LPWSTR szSourceDSA,
    REPLTIMES *pSyncSchedule,
    ULONG ulOptions,
    PULONG pfCallCompleted
    );

#ifdef DRA
ULONG
_IDL_DRSReplicaDel(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPDEL *    pmsgDel
    );
#endif /* DRA */

ULONG
I_DRSReplicaDel(
    THSTATE *   pTHS,
    LPWSTR      szDestinationDSA,
    PDSNAME     pNCName,
    LPWSTR      szSourceDSA,
    ULONG       ulOptions
    );

#ifdef DRA
ULONG
_IDL_DRSVerifyNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSVerifyNames(
    THSTATE                 *pTHS,
    LPWSTR                  szDestinationDSA,
    LPWSTR                  pszDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut
    );

ULONG
I_DRSVerifyNamesFindGC(
    THSTATE                 *pTHS,
    LPWSTR                  pszPreferredDestGC,
    LPWSTR                  pszPreferredDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut,
    DWORD                   dwFindGCFlags
    );

ULONG
I_DRSGetMemberships(
    THSTATE     *pTHS,
    LPWSTR      pszServerName,
    LPWSTR      pszServerDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      pErrCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory
    );

ULONG
I_DRSGetMembershipsFindGC(
    THSTATE *   pTHS,
    LPWSTR      pszPreferredDestGC,
    LPWSTR      pszPreferredDestDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      pErrCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory,
    DWORD       dwFindGCFlags
    );

#ifdef DRA
ULONG
_IDL_DRSGetMemberships(
   DRS_HANDLE hDrs,
   DWORD dwInVersion,
   DRS_MSG_REVMEMB_REQ *pmsgIn,
   DWORD *pdwOutVersion,
   DRS_MSG_REVMEMB_REPLY *pmsgOut
   );
#endif


ULONG
I_DRSGetMemberships2(
    THSTATE                       *pTHS,
    LPWSTR                         pszServerName,
    LPWSTR                         pszServerDnsDomainName,
    DWORD                          dwMsgInVersion,
    DRS_MSG_GETMEMBERSHIPS2_REQ   *pmsgIn,
    DWORD                         *pdwMsgOutVersion,
    DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
    );

#ifdef DRA
ULONG
_IDL_DRSGetMemberships2(
   DRS_HANDLE hDrs,
   DWORD dwInVersion,
   DRS_MSG_GETMEMBERSHIPS2_REQ *pmsgIn,
   DWORD *pdwOutVersion,
   DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
   );
#endif


#ifdef DRA
ULONG
_IDL_DRSInterDomainMove(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    OUT DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSInterDomainMove(
    IN  THSTATE             *pTHS,
    IN  LPWSTR              pDestinationDSA,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    OUT DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    );

#ifdef DRA

ULONG
_IDL_DRSGetNT4ChangeLog(
   DRS_HANDLE          hDrs,
   DWORD               dwInVersion,
   DRS_MSG_NT4_CHGLOG_REQ *pmsgIn,
   DWORD*              pdwOutVersion,
   DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut
   );

#endif

ULONG
I_DRSGetNT4ChangeLog(
    THSTATE *pTHS,
    LPWSTR  pszServerName,
    DWORD  dwFlags,
    ULONG   PreferredMaximumLength,
    PVOID   * ppRestart,
    PULONG  pcbRestart,
    PVOID   * ppLog,
    PULONG  pcbLog,
    NT4_REPLICATION_STATE * ReplicationState,
    NTSTATUS *ActualNtStatus
    );

#ifdef DRA
// Returns WIN32 errors, not DRAERR_*.
ULONG
_IDL_DRSCrackNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSCrackNames(
    THSTATE *               pTHS,
    LPWSTR                  szDestinationDSA,
    LPWSTR                  pszDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut
    );

ULONG
I_DRSCrackNamesFindGC(
    THSTATE *               pTHS,
    LPWSTR                  pszPreferredDestGC,
    LPWSTR                  pszPreferredDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut,
    DWORD                   dwFindGCFlags
    );

#ifdef DRA
ULONG
_IDL_DRSAddEntry(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_ADDENTRYREQ    *pmsgIn,
    DWORD                  *pdwMsgOutVersion,
    DRS_MSG_ADDENTRYREPLY  *pmsgOut
);
#endif

struct _DRS_SecBufferDesc;

ULONG
I_DRSAddEntry(
    IN  THSTATE *                   pTHS,
    IN  LPWSTR                      pszServerName,
    IN  struct _DRS_SecBufferDesc * pClientCreds,   OPTIONAL
    IN  DRS_MSG_ADDENTRYREQ_V2 *    pReq,
    OUT DWORD *                     pdwReplyVer,
    OUT DRS_MSG_ADDENTRYREPLY *     pReply
    );

#ifdef DRA
ULONG
_IDL_DRSGetObjectExistence(
    IN  DRS_HANDLE           hDrs,
    IN  DWORD                dwInVersion,
    IN  DRS_MSG_EXISTREQ *   pmsgIn,
    OUT DWORD *              pdwOutVersion,
    OUT DRS_MSG_EXISTREPLY * pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetObjectExistence(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DRS_MSG_EXISTREQ *            pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_EXISTREPLY *          pmsgOut
    );

#ifdef DRA
ULONG
_IDL_DRSGetReplInfo(
    IN      DRS_HANDLE           hDrs,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetReplInfo(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    );

ULONG
I_DRSIsExtSupported(
    THSTATE                *pTHS,
    LPWSTR                  pszServerName,
    ULONG                   Ext
    );


BOOL
I_DRSIsIntraSiteServer(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName
    );

ULONG
draGetServerOutgoingCalls(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_SERVER_OUTGOING_CALLS **  ppCalls
    );

#endif /* ifndef NOPROCS */
#endif /* ifndef _drsuapi_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\draasync.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       draasync.h
//
//--------------------------------------------------------------------------

/* draasync.h - Directory Replication Service Async Operations.

	Async Operations are handled in the following manor.

	1). The DRA recieves an RPC request through one of the IDL_DRS...
	functions. This function then builds a AO (Async Op) structure for
	all APIs that can be async (even if this call isnt an async one).

	2). The AO structure is then either placed on the AO list (if this
	operation is an async one) or passed to the async op distpatcher
	routine (DispatchPao) immediately if it is not.

	2.1). A separate thread services the AO list, taking the first
	item from it and calling DispatchPao, on returning from DispatchPao
	the status is set in the AO structure and the next (uncompleted)
	operation in the list is serviced.

	3). The DispatchPao routine unpacks the AO structure and calls the
	appropriate DRS_... function.
	
	NOTES:

	a). We always build the AO structure (even if not an aync op)
	because it reduces the number of paths through the code and makes
	testing easier. It also requires less code overall.

	b). When we build the AO structure we must remember to make COPIES of
	all the parameters. We do this because if this is an async op RPC will
	have deallocated the originals before we get to use them.
*/

#ifndef DRSASYNC_H_INCLUDED
#define DRSASYNC_H_INCLUDED

// If you add to this list, be sure and add the corresponding #undef below.
#ifdef MIDL_PASS
#define SWITCH_TYPE(x)  [switch_type(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define CASE(x)         [case(x)]
#else
#define SWITCH_TYPE(x)
#define SWITCH_IS(x)
#define CASE(x)
#endif

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_add {
    DSNAME          *pNC;
    DSNAME          *pSourceDsaDN;
    DSNAME          *pTransportDN;
    MTX_ADDR        *pDSASMtx_addr;
    LPWSTR          pszSourceDsaDnsDomainName;
    REPLTIMES       *preptimesSync;
} ARGS_REP_ADD;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_del {
    DSNAME          *pNC;
    MTX_ADDR        *pSDSAMtx_addr;
} ARGS_REP_DEL;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_sync {
    DSNAME          *pNC;
    UUID            invocationid;
    LPWSTR          pszDSA;
} ARGS_REP_SYNC;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_upd_refs {
    DSNAME          *pNC;
    MTX_ADDR        *pDSAMtx_addr;
    UUID            invocationid;
} ARGS_UPD_REFS;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_mod {
    DSNAME *        pNC;
    UUID *          puuidSourceDRA;
    UUID            uuidSourceDRA;
    UUID *          puuidTransportObj;
    UUID            uuidTransportObj;
    MTX_ADDR *      pmtxSourceDRA;
    REPLTIMES       rtSchedule;
    ULONG           ulReplicaFlags;
    ULONG           ulModifyFields;
} ARGS_REP_MOD;

#define AO_OP_REP_ADD	1
#define AO_OP_REP_DEL	2
#define AO_OP_REP_MOD   4
#define AO_OP_REP_SYNC	5
#define AO_OP_UPD_REFS	6

// Read NOTE below if you're considering adding a new member to the union.
typedef SWITCH_TYPE(ULONG) union {
    CASE(AO_OP_REP_ADD ) ARGS_REP_ADD    rep_add;
    CASE(AO_OP_REP_DEL ) ARGS_REP_DEL    rep_del;
    CASE(AO_OP_REP_MOD ) ARGS_REP_MOD    rep_mod;
    CASE(AO_OP_REP_SYNC) ARGS_REP_SYNC   rep_sync;
    CASE(AO_OP_UPD_REFS) ARGS_UPD_REFS   upd_refs;
} ARGS_REP;

typedef struct _ao {
    struct _ao *paoNext;        /* Used to chain AO structures */
    DSTIME      timeEnqueued;   /* time at which the operation was enqueued */
    ULONG       ulSerialNumber; /* ID of this op; unique per machine per boot */
    ULONG       ulOperation;    /* Which Async op */
    ULONG       ulOptions;
    ULONG       ulPriority;     /* Is this a priority operation? */
    ULONG       ulResult;       /* if synchronous, holds result code when done*/
    HANDLE      hDone;          /* if synchronous, signalled when complete */
    SWITCH_IS(ulOperation)
        ARGS_REP args;
} AO;


DWORD DoOpDRS(AO *pao);
void GetDRASyncLock();
void FreeDRASyncLock ();
extern DWORD TidDRAAsync;
#define OWN_DRA_LOCK() (GetCurrentThreadId() == TidDRAAsync)

BOOL IsHigherPriorityDraOpWaiting(void);
BOOL IsDraOpWaiting(void);
void InitDraQueue(void);

extern BOOL gfDRABusy;

// CONFIG here means a system paritition, Config or Schema
// DOMAIN here means a non-system partition, domain or NDNC

typedef enum {                                              // lowest priority
    AOPRI_ASYNC_DELETE                                                   = 10,
    AOPRI_UPDATE_REFS_VERIFY                                             = 20,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE              = 30,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED    = 40,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY                        = 50,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_PREEMPTED              = 60,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE             = 70,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED   = 80,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE                       = 90,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_PREEMPTED             = 100,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE              = 110,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE_PREEMPTED    = 120,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY                        = 130,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_PREEMPTED              = 140,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE             = 150,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED   = 160,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE                       = 170,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_PREEMPTED             = 180,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE              = 190,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE_PREEMPTED    = 200,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY                        = 210,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_PREEMPTED              = 220,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE             = 230,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED   = 240,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE                       = 250,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_PREEMPTED             = 260,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE              = 270,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE_PREEMPTED    = 280,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY                        = 290,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_PREEMPTED              = 300,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE             = 310,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED   = 320,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE                       = 330,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED             = 340,
    AOPRI_ASYNC_MODIFY                                                   = 350,
    AOPRI_SYNC_DELETE                                                    = 360,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE               = 370,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED     = 380,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY                         = 390,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_PREEMPTED               = 400,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE              = 410,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED    = 420,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE                        = 430,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_PREEMPTED              = 440,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE               = 450,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE_PREEMPTED     = 460,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY                         = 470,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_PREEMPTED               = 480,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE              = 490,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED    = 500,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE                        = 510,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_PREEMPTED              = 520,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE               = 530,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE_PREEMPTED     = 540,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY                         = 550,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_PREEMPTED               = 560,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE              = 570,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED    = 580,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE                        = 590,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_PREEMPTED              = 600,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE               = 610,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE_PREEMPTED     = 620,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY                         = 630,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_PREEMPTED               = 640,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE              = 650,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED    = 660,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE                        = 670,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED              = 680,
    AOPRI_SYNC_MODIFY                                                    = 690,
    AOPRI_UPDATE_REFS                                                    = 700
} AO_PRIORITY;                                              // highest priority

// Base priority for sync operations (before addition of applicable
// AOPRI_BOOST_SYNCHRONIZE_*'s).
#define AOPRI_SYNCHRONIZE_BASE  AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE

// Priority boost for incremental syncs (vs. syncs from sources we've never
// completed a sync from before).
#define AOPRI_SYNCHRONIZE_BOOST_INCREMENTAL         \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE               \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE)

// Priority boost for syncs of writeable NCs (vs. read-only NCs). 
#define AOPRI_SYNCHRONIZE_BOOST_WRITEABLE   \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY)

// Priority boost for synchronous sync requests (vs. asynchronous syncs).
#define AOPRI_SYNCHRONIZE_BOOST_SYNC        \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE)

// Priority boost for preempted sync requests.
#define AOPRI_SYNCHRONIZE_BOOST_PREEMPTED       \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE)

// Priority boost for being in the same site
#define AOPRI_SYNCHRONIZE_BOOST_INTRASITE \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE)

// Priority boost for being a system NC
#define AOPRI_SYNCHRONIZE_BOOST_SYSTEM_NC \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE)

#ifndef MIDL_PASS
extern CRITICAL_SECTION csAOList;

ULONG
draGetPendingOps(
    IN  struct _THSTATE *               pTHS,
    IN  struct DBPOS *                  pDB,
    OUT struct _DS_REPL_PENDING_OPSW ** ppPendingOps
    );

ULONG
DraSetQueueLock(
    IN  BOOL  fEnable
    );

ULONG
draGetQueueStatistics(
    IN  struct _THSTATE *                    pTHS,
    OUT struct _DS_REPL_QUEUE_STATISTICSW ** ppQueueStats);

VOID
DraRemovePeriodicSyncsFromQueue(
    UUID *uuidDsa
    );

#if DBG
BOOL
DraIsValidLongRunningTask();
#endif // #if DBG

#endif // #ifndef MIDL_PASS

#undef SWITCH_TYPE
#undef SWITCH_IS
#undef CASE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\draatt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       draatt.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Replication flag definitions.

DETAILS:

These flags are passed in the options parameter to the RPC replica functions,
and are thus part of the formal interface between DSAs. Do not change these
values.

These flags are for internal use only. For most of these functions, there is
a corresponding public version of the option flag.  If you add new options
that would be relevant to public calls, please add the tranlation in
sdk\public\inc\ntdsapi.h and ds\src\ntdsapi\replica.c.

Documentation for many of these flags can be found in
ds\src\dsamain\dra\dradir.c.  When adding new flags, please update the
commentary in dradir.c, as well as other modules where the flag is used.

CREATED:

REVISION HISTORY:

--*/

// general
#define DRS_ASYNC_OP                   (0x0001L)

// Replica option flags
#define DRS_WRIT_REP                   (0x0010L)       // Writeable replica
#define DRS_INIT_SYNC                  (0x0020L)       // Sync replica at startup
#define DRS_PER_SYNC                   (0x0040L)       // Sync replica periodically
#define DRS_MAIL_REP                   (0x0080L)       // Mail replica
#define DRS_ASYNC_REP                  (0x0100L)       // Complete replica asyncly
#define DRS_TWOWAY_SYNC                (0x0200L)       // At end of sync, force sync
                                                       //   in opposite direction
#define DRS_CRITICAL_ONLY              (0x0400L)       // Sync critical objects
#define DRS_NEVER_SYNCED             (0x200000L)       // Sync from this source
                                                       //   never completed
                                                       //   successfully
                             // Shared by ReplicaAdd and ReplicaSync

// Replica deletion flags
#define DRS_IGNORE_ERROR               (0x0100L)       // Ignore error if replica
                                                       // source DSA unvaialable
#define DRS_LOCAL_ONLY                 (0x1000L)       // Don't try and contact
                                                       // other DRA
#define DRS_DEL_SUBREF                 (0x2000L)       // Delete subref (nw replicas
                                                       // only)
#define DRS_REF_OK                     (0x4000L)       // Allow deletion even if
                                                       // NC has repsto
#define DRS_NO_SOURCE                  (0x8000L)       // Replica has no repsfrom


// syncing flags (also passed to GetNcChanges)
//above DRS_ASYNC_OP                   (0x0001L)
#define DRS_UPDATE_NOTIFICATION	       (0x0002L) // set by notify caller
//below DRS_ADD_REF                    (0x0004L) // Add a reference on source
#define DRS_SYNC_ALL                   (0x0008L) // sync replica from all sources
//above DRS_WRIT_REP                   (0x0010L) // Writeable replica
//above DRS_INIT_SYNC                  (0x0020L) // Sync replica at startup
//above DRS_PER_SYNC                   (0x0040L) // Sync replica periodically
//above DRS_MAIL_REP                   (0x0080L) // Mail replica
//above DRS_ASYNC_REP                  (0x0100L) // Complete replica asyncly
//above DRS_TWOWAY_SYNC                (0x0200L) // At end of sync, force sync in opp dir
//above DRS_CRITICAL_ONLY              (0x0400L) // Sync critical objects
//below DRS_GET_ANC                    (0x0800L) // Include ancestors
//below DRS_GET_NC_SIZE                (0x1000L) // Return size of NC
//OPEN                                 (0x2000L)
#define DRS_SYNC_BYNAME                (0x4000L) // Sync by name, not UUID
#define DRS_FULL_SYNC_NOW              (0x8000L) // Sync from scratch.
#define DRS_FULL_SYNC_IN_PROGRESS     (0x10000L) // Full sync is in progress,
#define DRS_FULL_SYNC_PACKET          (0x20000L) // temp mode to req all attr
#define DRS_SYNC_REQUEUE              (0x40000L) // requeued sync request of any type
#define DRS_SYNC_URGENT               (0x80000L) // Sync repsto immediately
#define DRS_NO_DISCARD               (0x100000L) // Always q, never discard.
//above DRS_NEVER_SYNCED             (0x200000L) // Sync never completed successfully
#define DRS_ABAN_SYNC                (0x400000L) // Sync abandoned due to lack of progress
#define DRS_INIT_SYNC_NOW            (0x800000L) // Performing initial sync now.
#define DRS_PREEMPTED               (0x1000000L) // Sync attempt was preempted
#define DRS_SYNC_FORCED             (0x2000000L) // Force the sync even if repl disabled
#define DRS_DISABLE_AUTO_SYNC       (0x4000000L) // Disable notification-triggered syncs
#define DRS_DISABLE_PERIODIC_SYNC   (0x8000000L) // Disable periodic syncs
#define DRS_USE_COMPRESSION        (0x10000000L) // Compress repl messages when possible
#define DRS_NEVER_NOTIFY           (0x20000000L) // Don't use change notifications
#define DRS_SYNC_PAS               (0x40000000L) // Marks PAS replication (PAS - Partial Attribute Set)
//OPEN                             (0x80000000L)

// flags to UpdateRefs when replicas added or deleted
#define DRS_ADD_REF                    (0x0004L) // when nc replicated
#define DRS_DEL_REF                    (0x0008L) // when replica nc deleted
#define DRS_GETCHG_CHECK               (0x0002L) // when done as a result of servicing
                                                 // a GetNCChanges request

// GetNcChanges flags
// Any flag valid for ReplicaSync may be passed to GetNcChanges
// DRS_CRITICAL_ONLY
// DRS_SYNC_FORCED
#define DRS_GET_ANC                    (0x0800L)       // Include ancestors
#define DRS_GET_NC_SIZE                (0x1000L)       // Return size of NC


// DirSync control flags
// These are passed separate from the replication flags
// These flags are obsolete and are retained for old callers
// The authoritative copy of these flags are in ntldap.h
#define DRS_DIRSYNC_OBJECT_SECURITY             (0x1)
#define DRS_DIRSYNC_ANCESTORS_FIRST_ORDER    (0x0800)
#define DRS_DIRSYNC_PUBLIC_DATA_ONLY         (0x2000)
#define DRS_DIRSYNC_INCREMENTAL_VALUES   (0x80000000)

// [wlees] The state of options in the system is a real mess. In the future we
// ought to consider dividing the options into groups, as follows:
//
// o The mechanics of the operation request
// (ASYNC_OP, NO_DISCARD)
//
// o Flags that are stored on the persistent state of the replica
//   (use compression) See RFR_FLAGS
//   These are divided into static descriptive flags (write, periodic, etc)
//   and internal state flags that describe a mode across a series of calls
//   (FULL_SYNC_IN_PROGRESS, SYNC_PAS, INIT_SYNC_NOW, SYNC_REQUEUE)
//   The former may generally be set by the user, while the latter may not.
//
// o Flags that are operation specific and are single-shot modifiers
//   to the current request but are not persistant.
//   (critical only, ignore error)

// These are the flags that are used in calculating queue priority
// DRS_ASYNC_OP is also relevent for priority, but it is not in RFR_FLAGS
// so is not relevent here.
#define AO_PRIORITY_FLAGS ( DRS_WRIT_REP \
                            | DRS_NEVER_SYNCED \
                            | DRS_PREEMPTED \
                            | DRS_NEVER_NOTIFY )

// These are the flags that may be set on the repsfromref attribute
// Note, any restartable (persistent) state bits that need to be preserved
// across a reboot need to be part of this mask.
#define RFR_FLAGS (RFR_SYSTEM_FLAGS | RFR_USER_FLAGS)

// This is the subset of the RFR_FLAGS that may only be set or cleared
// by the system.  Obviously this should not appears in REPADD_OPTIONS
// or REPMOD_REPLICA_FLAGS.
// Note that
// DRS_INIT_SYNC_NOW
// DRS_ABAN_SYNC
// DRS_SYNC_REQUEUE
// would fit the category, but do not need to be persisted
#define RFR_SYSTEM_FLAGS ( DRS_WRIT_REP         \
                   | DRS_FULL_SYNC_IN_PROGRESS  \
                   | DRS_FULL_SYNC_PACKET       \
                   | DRS_NEVER_SYNCED           \
                   | DRS_PREEMPTED              \
                   | DRS_SYNC_PAS )

// This is the subset of the RFR_FLAGS that may be set by a user
#define RFR_USER_FLAGS (DRS_INIT_SYNC                \
                   | DRS_PER_SYNC               \
                   | DRS_MAIL_REP               \
                   | DRS_DISABLE_AUTO_SYNC      \
                   | DRS_DISABLE_PERIODIC_SYNC  \
                   | DRS_USE_COMPRESSION        \
                   | DRS_NEVER_NOTIFY           \
                   | DRS_TWOWAY_SYNC)

// These are the valid options for the DirReplicaAdd call
// We add in DRS_WRIT_REP here since it is permitted on add.
#define REPADD_OPTIONS ( DRS_ASYNC_OP   \
                         | DRS_CRITICAL_ONLY          \
                         | DRS_ASYNC_REP              \
                         | DRS_WRIT_REP               \
                         | RFR_USER_FLAGS )

// These are the valid flags for the ReplicateNC call when called
// from ReplicaAdd
#define REPADD_REPLICATE_FLAGS ( DRS_CRITICAL_ONLY  \
                                 | DRS_ASYNC_REP     \
                                 | RFR_FLAGS )

// These are the valid options for the DirReplicaModify call
#define REPMOD_OPTIONS ( DRS_ASYNC_OP )

// These are the valid options for the DirReplicaDelete call
// WRIT_REP and MAIL_REP are not read, but are permitted because
// legacy clients still pass them in.
#define REPDEL_OPTIONS (  DRS_ASYNC_OP                 \
                          | DRS_WRIT_REP               \
                          | DRS_MAIL_REP               \
                          | DRS_ASYNC_REP              \
                          | DRS_IGNORE_ERROR           \
                          | DRS_LOCAL_ONLY             \
                          | DRS_NO_SOURCE              \
                          | DRS_REF_OK)

// These are the valid options for the DirReplicaUpdateRef call
#define REPUPDREF_OPTIONS (  DRS_ASYNC_OP              \
                             | DRS_GETCHG_CHECK        \
                             | DRS_WRIT_REP            \
                             | DRS_DEL_REF             \
                             | DRS_ADD_REF)

// These are the valid options for the IDL_DRSReplicaSync RPC call
#define REPSYNC_RPC_OPTIONS ( DRS_ASYNC_OP             \
                              | RFR_USER_FLAGS         \
                              | DRS_WRIT_REP           \
                              | DRS_CRITICAL_ONLY      \
                              | DRS_UPDATE_NOTIFICATION \
                              | DRS_ADD_REF             \
                              | DRS_SYNC_ALL            \
                              | DRS_SYNC_BYNAME         \
                              | DRS_FULL_SYNC_NOW       \
                              | DRS_SYNC_URGENT         \
                              | DRS_SYNC_FORCED )

// Flags preserved when DRA_ReplicaSync() reenqueues the sync operation due to
// schema mismatch, preemption, etc.
// Flags relevent to priority are included via AO_PRIORITY_FLAGS
// The flag DRS_INIT_SYNC_NOW is handled specially by the caller if needed
#define REPSYNC_REENQUEUE_FLAGS ( AO_PRIORITY_FLAGS     \
                                 | DRS_SYNC_BYNAME      \
                                 | DRS_FULL_SYNC_NOW    \
                                 | DRS_NO_DISCARD       \
                                 | DRS_PER_SYNC         \
                                 | DRS_ADD_REF          \
                                 | DRS_TWOWAY_SYNC      \
                                 | DRS_SYNC_PAS         \
                                 | DRS_SYNC_REQUEUE     \
                                 | DRS_SYNC_FORCED)

// Same as above, but allow for the init sync in progress indicator
// to be preserved because an init sync is being requeued
#define REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED \
    ( DRS_INIT_SYNC_NOW | REPSYNC_REENQUEUE_FLAGS )

// On a ReplicaSync doing a sync-all operation, this mask defines the flags
// that are kept that the requestor passed in.
#define REPSYNC_SYNC_ALL_FLAGS (DRS_FULL_SYNC_NOW \
                                | DRS_PER_SYNC \
                                | DRS_NO_DISCARD \
                                | DRS_SYNC_FORCED \
                                | DRS_SYNC_URGENT \
                                | DRS_ADD_REF)

// On a ReplicaSync doing a normal rpc-based sync using ReplicateNC.
// This mask defines the flags that are kept that the requestor passed in.
// Long-lived descriptive flags that are peristed in the reps-from, such
// as RFR_USER_FLAGS, should not be included here. They will always come
// from the reps-from which is added separately.
#define REPSYNC_REPLICATE_FLAGS (DRS_ABAN_SYNC \
                                 | DRS_INIT_SYNC_NOW \
                                 | DRS_ASYNC_OP \
                                 | DRS_FULL_SYNC_NOW \
                                 | DRS_SYNC_FORCED \
                                 | DRS_SYNC_URGENT \
                                 | DRS_ADD_REF )

// This is the filter on the options which go in a mail request to get changes
// Some extra may be or'd in after the fact in draConstructGetChgReq
#define GETCHG_REQUEST_FLAGS (DRS_ABAN_SYNC           \
                              | DRS_INIT_SYNC_NOW     \
                              | DRS_ASYNC_OP          \
                              | DRS_PER_SYNC          \
                              | DRS_FULL_SYNC_NOW     \
                              | DRS_SYNC_FORCED       \
                              | DRS_SYNC_URGENT       \
                              | DRS_FULL_SYNC_PACKET  \
                              | DRS_SYNC_PAS         \
                              | DRS_USE_COMPRESSION)

// Option translation table entry
typedef struct _OPTION_TRANSLATION {
    DWORD PublicOption;
    DWORD InternalOption;
    LPWSTR pwszPublicOption;
} OPTION_TRANSLATION, *POPTION_TRANSLATION;

#ifdef INCLUDE_OPTION_TRANSLATION_TABLES

#ifndef _MAKE_WIDE
#define _MAKE_WIDE(x)  L ## x
#endif

// Macros to make entering option name entries easier
#define REPSYNC_OPTION( x, y ) { DS_REPSYNC_##x,   DRS_##y, _MAKE_WIDE( #x ) }
#define REPADD_OPTION( x, y )  { DS_REPADD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPDEL_OPTION( x, y )  { DS_REPDEL_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPMOD_OPTION( x, y )  { DS_REPMOD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPUPD_OPTION( x, y )  { DS_REPUPD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPNBR_OPTION( x, y )  { DS_REPL_NBR_##x,  DRS_##y, _MAKE_WIDE( #x ) }

// Note that these option translation tables are used for option conversion,
// not for validation of which options are permissible.  Also note that these
// tables are used for the setting and displaying of operation states.  Thus
// while a subset of these options may be specified when the operation is
// requested, they all may be needed when showing an operation request in the
// queue.

//*******************
// ReplicaSync options
//*******************
OPTION_TRANSLATION RepSyncOptionToDra[] = {
    REPSYNC_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP      ),
    REPSYNC_OPTION( WRITEABLE             , WRIT_REP      ),
    REPSYNC_OPTION( PERIODIC              , PER_SYNC      ),
    REPSYNC_OPTION( INTERSITE_MESSAGING   , MAIL_REP      ),
    REPSYNC_OPTION( ALL_SOURCES           , SYNC_ALL      ),
    REPSYNC_OPTION( FULL                  , FULL_SYNC_NOW ),
    REPSYNC_OPTION( URGENT                , SYNC_URGENT   ),
    REPSYNC_OPTION( NO_DISCARD            , NO_DISCARD    ),
    REPSYNC_OPTION( FORCE                 , SYNC_FORCED   ),
    REPSYNC_OPTION( ADD_REFERENCE         , ADD_REF       ),
    REPSYNC_OPTION( TWO_WAY               , TWOWAY_SYNC   ),
    REPSYNC_OPTION( NEVER_COMPLETED       , NEVER_SYNCED  ),
    REPSYNC_OPTION( NEVER_NOTIFY          , NEVER_NOTIFY  ),
    REPSYNC_OPTION( INITIAL               , INIT_SYNC     ),
    REPSYNC_OPTION( USE_COMPRESSION       , USE_COMPRESSION  ),
    REPSYNC_OPTION( ABANDONED             , ABAN_SYNC     ),
    REPSYNC_OPTION( INITIAL_IN_PROGRESS   , INIT_SYNC_NOW ),
    REPSYNC_OPTION( PARTIAL_ATTRIBUTE_SET , SYNC_PAS      ),
    REPSYNC_OPTION( REQUEUE               , SYNC_REQUEUE  ),
    REPSYNC_OPTION( NOTIFICATION          , UPDATE_NOTIFICATION ),
    REPSYNC_OPTION( ASYNCHRONOUS_REPLICA  , ASYNC_REP ),
    REPSYNC_OPTION( CRITICAL              , CRITICAL_ONLY ),
    REPSYNC_OPTION( FULL_IN_PROGRESS      , FULL_SYNC_IN_PROGRESS ),
    REPSYNC_OPTION( PREEMPTED             , PREEMPTED ),
    {0}
};

//*******************
// ReplicaAdd options
//*******************
OPTION_TRANSLATION RepAddOptionToDra[] = {
    REPADD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP                 ),
    REPADD_OPTION( WRITEABLE             , WRIT_REP                 ),
    REPADD_OPTION( INITIAL               , INIT_SYNC                ),
    REPADD_OPTION( PERIODIC              , PER_SYNC                 ),
    REPADD_OPTION( INTERSITE_MESSAGING   , MAIL_REP                 ),
    REPADD_OPTION( ASYNCHRONOUS_REPLICA  , ASYNC_REP                ),
    REPADD_OPTION( DISABLE_NOTIFICATION  , DISABLE_AUTO_SYNC        ),
    REPADD_OPTION( DISABLE_PERIODIC      , DISABLE_PERIODIC_SYNC    ),
    REPADD_OPTION( USE_COMPRESSION       , USE_COMPRESSION          ),
    REPADD_OPTION( NEVER_NOTIFY          , NEVER_NOTIFY             ),
    REPADD_OPTION( TWO_WAY               , TWOWAY_SYNC              ),
    REPADD_OPTION( CRITICAL              , CRITICAL_ONLY            ),
    {0}
};

//*******************
// ReplicaDelete options
//*******************
OPTION_TRANSLATION RepDelOptionToDra[] = {
    REPDEL_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP     ),
    REPDEL_OPTION( WRITEABLE             , WRIT_REP     ), // legacy
    REPDEL_OPTION( INTERSITE_MESSAGING   , MAIL_REP     ), // legacy
    REPDEL_OPTION( IGNORE_ERRORS         , IGNORE_ERROR ),
    REPDEL_OPTION( LOCAL_ONLY            , LOCAL_ONLY   ),
    REPDEL_OPTION( NO_SOURCE             , NO_SOURCE    ),
    REPDEL_OPTION( REF_OK                , REF_OK       ),
    {0}
};

//*******************
// ReplicaModify options
//*******************
OPTION_TRANSLATION RepModOptionToDra[] = {
    REPMOD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP ),
    {0}
};

//*******************
// ReplicaModify field names
//*******************
OPTION_TRANSLATION RepModFieldsToDra[] = {
    REPMOD_OPTION( UPDATE_FLAGS     , UPDATE_FLAGS      ),
    REPMOD_OPTION( UPDATE_ADDRESS   , UPDATE_ADDRESS    ),
    REPMOD_OPTION( UPDATE_SCHEDULE  , UPDATE_SCHEDULE   ),
    REPMOD_OPTION( UPDATE_RESULT    , UPDATE_RESULT     ),
    REPMOD_OPTION( UPDATE_TRANSPORT , UPDATE_TRANSPORT  ),
    {0}
};

//*******************
// UpdateRefs option names
//*******************
OPTION_TRANSLATION UpdRefOptionToDra[] = {
    REPUPD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP ),
    REPUPD_OPTION( WRITEABLE             , WRIT_REP ),
    REPUPD_OPTION( ADD_REFERENCE         , ADD_REF  ),
    REPUPD_OPTION( DELETE_REFERENCE      , DEL_REF  ),
    {0}
};

//*******************
// Replica flag names
//*******************
// This flags are stored in the reps-from.  They are retrieved by the
// Get Neighbors information type, and set in the Modify Replica
// call under the replica flags argument.  These are not the same
// as the options which may be passed to Sync Replica. This table
// is not used to decode flags in the Get Pending Queue function.

// This list should match the contents of RFR_FLAGS

OPTION_TRANSLATION RepNbrOptionToDra[] = {
    REPNBR_OPTION( SYNC_ON_STARTUP,               INIT_SYNC ),
    REPNBR_OPTION( DO_SCHEDULED_SYNCS,            PER_SYNC ),
    REPNBR_OPTION( WRITEABLE,                     WRIT_REP ),
    REPNBR_OPTION( USE_ASYNC_INTERSITE_TRANSPORT, MAIL_REP ),
    REPNBR_OPTION( IGNORE_CHANGE_NOTIFICATIONS,   DISABLE_AUTO_SYNC ),
    REPNBR_OPTION( DISABLE_SCHEDULED_SYNC,        DISABLE_PERIODIC_SYNC ),
    REPNBR_OPTION( FULL_SYNC_IN_PROGRESS,         FULL_SYNC_IN_PROGRESS ),
    REPNBR_OPTION( FULL_SYNC_NEXT_PACKET,         FULL_SYNC_PACKET ),
    REPNBR_OPTION( COMPRESS_CHANGES,              USE_COMPRESSION ),
    REPNBR_OPTION( NO_CHANGE_NOTIFICATIONS,       NEVER_NOTIFY ),
    REPNBR_OPTION( NEVER_SYNCED,                  NEVER_SYNCED ),
    REPNBR_OPTION( TWO_WAY_SYNC,                  TWOWAY_SYNC ),
    REPNBR_OPTION( PARTIAL_ATTRIBUTE_SET,         SYNC_PAS ),
    REPNBR_OPTION( PREEMPTED,                     PREEMPTED ),
    {0}
};

#undef _MAKE_WIDE
#else

extern OPTION_TRANSLATION RepSyncOptionToDra[];
extern OPTION_TRANSLATION RepAddOptionToDra[];
extern OPTION_TRANSLATION RepDelOptionToDra[];
extern OPTION_TRANSLATION RepModOptionToDra[];
extern OPTION_TRANSLATION RepModFieldsToDra[];
extern OPTION_TRANSLATION UpdRefOptionToDra[];
extern OPTION_TRANSLATION RepNbrOptionToDra[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsconfig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsconfig.h
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  GetConfigParam()
 *
 *      PCHAR   parameter       - item for which we want the value
 *      PVOID   value       - pointer to variable in which to
 *                    place the value
 *      DWORD   dwSize      - size of value in bytes
 */

DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize);

DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize);

DWORD
GetConfigParamA(
    char * parameter,
    void * value,
    DWORD dwSize);

/*
 *  GetConfigParamAlloc()
 *
 *      PCHAR   parameter    - item for which we want the value
 *      PVOID   *value       - pointer to variable in which to
 *                             store a pointer to the newly malloced buffer
 *                             containing the value.
 *      PDWORD   dwSize      - pointer to a variable in which to store the size
 *                             of the buffer.
 */

DWORD
GetConfigParamAlloc(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
GetConfigParamAllocA(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
SetConfigParam(
    char * parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize);

DWORD
DeleteConfigParam(
    char * parameter);

// For normalizing paths, before storing in the registry.
BOOL
DsNormalizePathName(
    char * szPath
    );

//
// This macro will make any of the below constants a wide char
// constant.  Note that the indirection of the macros is necessary
// to get the desired effect. This macros only make sense in a
// non-UNICODE environment.
//
#define _MAKE_WIDE(x)  L ## x
#define MAKE_WIDE(x)   _MAKE_WIDE(x)

/*
 *  Following is the list keys defined for use by the DSA and
 *  utilities.  First, the sections.
 */
#define SERVICE_NAME            "NTDS"
#define SERVICE_LONG_NAME       "Microsoft NTDS"
#define DSA_CONFIG_ROOT         "System\\CurrentControlSet\\Services\\NTDS"
#define DSA_CONFIG_SECTION      "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
#define DSA_PERF_SECTION        "System\\CurrentControlSet\\Services\\NTDS\\Performance"
#define DSA_EVENT_SECTION       "System\\CurrentControlSet\\Services\\NTDS\\Diagnostics"
#define DSA_LOCALE_SECTION      "SOFTWARE\\Microsoft\\NTDS\\Language"
#define DSA_SECURITY_SECTION    "SOFTWARE\\Microsoft\\NTDS\\Security"
#define SETUP_SECTION           "SOFTWARE\\Microsoft\\NTDS\\Setup"
#define BACKUP_EXCLUSION_SECTION "System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"

/*
 * NTDS key for excluding DS specific files from being backed up as part of filesystem backup
 */
#define NTDS_BACKUP_EXCLUSION_KEY "NTDS"    // REG_MULTI_SZ specifying list of directories to be excluded

/*
 * NTDS SETUP KEYS
*/

#define NTDSINIFILE                  "NTDS Init File"
#define MACHINEDNNAME                "Machine DN Name"
#define REMOTEMACHINEDNNAME          "Remote Machine DN Name"
#define SCHEMADNNAME                 "Schema DN Name"
#define SCHEMADNNAME_W               L"Schema DN Name"

#define ROOTDOMAINDNNAME             "Root Domain"
#define ROOTDOMAINDNNAME_W           L"Root Domain"
#define X500ROOT                     "X500 Root"

#define CONFIGNCDNNAME               "Configuration NC"
#define CONFIGNCDNNAME_W             L"Configuration NC"

#define SRCCONFIGNCSRV               "Src Config NC   Srv"
#define SRCROOTDOMAINSRV             "Src Root Domain Srv"
#define SETUPINITIALREPLWITH         "SetupInitialReplWith"
#define SOURCEDSADNSDOMAINNAME       "Src Srv DNS Domain Name"
#define SOURCEDSAOBJECTGUID          "Src Srv objectGuid"

#define LOCALCONNECTIONDNNAME        "Local Connection DN Name"
#define REMOTECONNECTIONDNNAME       "Remote Connection DN Name"
#define NEWDOMAINCROSSREFDNNAME      "New Domain Cross-Ref DN Name"

#define INIDEFAULTCONFIGNCDIT        "DEFAULTCONFIGNC"
#define INIDEFAULTROOTDOMAINDIT      "DEFAULTROOTDOMAIN"
#define INIDEFAULTMACHINE            "DEFAULTMACHINE"
#define INIDEFAULTSCHEMANCDIT        "DEFAULTSCHEMANC"
#define INIDEFAULTLOCALCONNECTION    "DEFAULTLOCALCONNECTION"
#define INIDEFAULTREMOTECONNECTION   "DEFAULTREMOTECONNECTION"
#define INIDEFAULTNEWDOMAINCROSSREF  "DEFAULTNEWDOMAINCROSSREF"
#define DNSROOT                      "DNS Root"
#define NETBIOSNAME                  "Netbios Name"
#define INSTALLSITENAME              "InstallSiteName"
#define SCHEMAVERSION                "Schema Version"
#define INSTALLSITEDN                "InstallSiteDn"
#define ROOTDOMAINSID                "RootDomainSid"
#define ROOTDOMAINDNSNAME            "RootDomainDnsName"
#define TRUSTEDCROSSREF              "TrustedCrossRef"
#define LOCALMACHINEACCOUNTDN        "Local Machine Account DN"
#define FORESTBEHAVIORVERSION        "InstallForestBehaviorVersion"
#define DEBUG_REMOVE_HAS_MASTER_NCS  "Remove Original Has Master NCs (Debug)"

/* Parameters keys */

#define PHANTOM_SCAN_RATE       "Days per Database Phantom Scan"
#define MAPI_ON_KEY             "Initialize MAPI interface"
#define DO_LIST_OBJECT_KEY      "Enforce LIST_OBJECTS rights"
#define DSA_HEURISTICS          "DSA Heuristics"
#define FILEPATH_KEY            "DSA Database file"
#define JETSYSTEMPATH_KEY       "DSA Working Directory"
#define CRITICAL_OBJECT_INSTALL "Critical Object Installation"
#define DSA_DRIVE_MAPPINGS      "DS Drive Mappings"
#define DSA_RESTORE_COUNT_KEY   "DSA Previous Restore Count"
#define TOMB_STONE_LIFE_TIME    "TombstoneLifeTime"
#define DB_MAX_OPEN_TABLES      "Maximum Open Tables"
#define DB_MAX_TRANSACTION_TIME "Max Transaction Time(secs)"
#define DB_CACHE_RECORDS        "Cache database records"
#define DSA_UNLOCK_SYSTEM_SUBTREE "Unlock system subtree"
#define DB_DELETE_UNICODE_INDEXES "Delete Unicode Indices"
#define SYSTEM_SCHEMA_VERSION   "System Schema Version"

#define DRSUAPI_INTERFACE_PROTSEQ "Drsuapi interface protocol sequences"
#define DSAOP_INTERFACE_PROTSEQ   "Dsaop interface protocol sequences"
#define NSPI_INTERFACE_PROTSEQ    "Nspi interface protocol sequences"

// This key is set by ntdsutil to indicate that NTDSA must update folder
// security on to the default settings from %windir%\inf\defltdc.inf
// The key is immediately removed by NTDSA.
#define DSA_UPDATE_FOLDER_SECURITY "Update folder security"

// Garbage collect expired dynamic objects (entryTTL == 0)
#define DSA_DELETE_EXPIRED_ENTRYTTL_SECS        "Delete expired entryTTL (secs)"
#define DSA_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS   "Delete next expired entryTTL (secs)"
#define DSA_SCHEMA_FSMO_LEASE_SECS              "Schema FSMO lease (secs)"
#define DSA_SCHEMA_FSMO_LEASE_MAX_SECS          "Schema FSMO maximum lease (secs)"
// See dsamain.c useage for description.
#define DSA_REGISTER_NDNC_SPNS     "Register Application Directory Partition SPNs"

// This is currently used for checked builds only.
#define DSA_THREAD_STATE_HEAP_LIMIT                "Thread State Heap Limit"

//
//  !!! DO NOT CHANGE !!!
//
// These are absolutely immuteable, set for all time.  Must not change these.
#define WIN2K_DEFAULT_DRA_START_PAUSE      (300)
#define WIN2K_DEFAULT_DRA_INTERDSA_PAUSE   (30)
//
//  !!! END OF DO NOT CHANGE SECTION !!!
//

// These are the normal defaults
#define DRA_NOTIFY_START_PAUSE  "Replicator notify pause after modify (secs)"
#define DRA_NOTIFY_INTERDSA_PAUSE "Replicator notify pause between DSAs (secs)"
#define DRA_INTRA_PACKET_OBJS   "Replicator intra site packet size (objects)"
#define DRA_INTRA_PACKET_BYTES  "Replicator intra site packet size (bytes)"
#define DRA_INTER_PACKET_OBJS   "Replicator inter site packet size (objects)"
#define DRA_INTER_PACKET_BYTES  "Replicator inter site packet size (bytes)"
#define DRA_ASYNC_INTER_PACKET_OBJS   "Replicator async inter site packet size (objects)"
#define DRA_ASYNC_INTER_PACKET_BYTES  "Replicator async inter site packet size (bytes)"
#define DRA_MAX_GETCHGTHRDS     "Replicator maximum concurrent read threads"
#define DRA_AOQ_LIMIT           "Replicator operation backlog limit"
#define DRA_THREAD_OP_PRI_THRESHOLD "Replicator thread op priority threshold"
#define DRA_CTX_LIFETIME_INTRA  "Replicator intra site RPC handle lifetime (secs)"
#define DRA_CTX_LIFETIME_INTER  "Replicator inter site RPC handle lifetime (secs)"
#define DRA_CTX_EXPIRY_CHK_INTERVAL "Replicator RPC handle expiry check interval (secs)"
#define DRA_MAX_WAIT_FOR_SDP_LOCK "Replicator maximum wait for SDP lock (msecs)"
#define DRA_MAX_WAIT_MAIL_SEND_MSG "Replicator maximum wait mail send message (msecs)"
#define DRA_MAX_WAIT_SLOW_REPL_WARN "Replicator maximum wait too slow warning (mins)"
#define DRA_THREAD_PRI_HIGH     "Replicator thread priority high"
#define DRA_THREAD_PRI_LOW      "Replicator thread priority low"
#define DRA_REPL_QUEUE_CHECK_TIME "Replicator queue check time (mins)"
#define DRA_REPL_LATENCY_CHECK_INTERVAL "Replicator latency check interval (days)"
#define DRA_REPL_LATENCY_ERROR_INTERVAL "Replicator latency error interval (hours)"
#define DRA_REPL_COMPRESSION_LEVEL "Replicator compression level"
#define DRA_REPL_COMPRESSION_ALG "Replicator compression algorithm"

#define DB_EXPENSIVE_SEARCH_THRESHOLD   "Expensive Search Results Threshold"
#define DB_INEFFICIENT_SEARCH_THRESHOLD "Inefficient Search Results Threshold"
#define DB_INTERSECT_THRESHOLD          "Intersect Threshold"
#define DB_INTERSECT_RATIO              "Intersect Ratio"

#define DRSRPC_BIND_TIMEOUT            "RPC Bind Timeout (mins)"
#define DRSRPC_REPLICATION_TIMEOUT     "RPC Replication Timeout (mins)"
#define DRSRPC_GCLOOKUP_TIMEOUT        "RPC GC Lookup Timeout (mins)"
#define DRSRPC_MOVEOBJECT_TIMEOUT      "RPC Move Object Timeout (mins)"
#define DRSRPC_NT4CHANGELOG_TIMEOUT    "RPC NT4 Change Log Timeout (mins)"
#define DRSRPC_OBJECTEXISTENCE_TIMEOUT "RPC Object Existence Timeout (mins)"
#define DRSRPC_GETREPLINFO_TIMEOUT     "RPC Get Replica Information Timeout (mins)"

#define LDAP_INTEGRITY_POLICY_KEY   "LdapServerIntegrity"

#define BACKUPPATH_KEY          "Database backup path"
#define BACKUPINTERVAL_KEY      "Database backup interval (hours)"
#define LOGPATH_KEY             "Database log files path"
#define RECOVERY_KEY            "Database logging/recovery"
#define HIERARCHY_PERIOD_KEY    "Hierarchy Table Recalculation interval (minutes)"
#define DSA_RESTORED_DB_KEY     "Database restored from backup"
#define MAX_BUFFERS             "EDB max buffers"
#define MAX_LOG_BUFFERS         "EDB max log buffers"
#define LOG_FLUSH_THRESHOLD     "EDB log buffer flush threshold"
#define BUFFER_FLUSH_START      "EDB buffer flush start"
#define BUFFER_FLUSH_STOP       "EDB buffer flush stop"
#define SPARE_BUCKETS           "EDB max ver pages (increment over the minimum)"
#define DELETE_OUTOFRANGE_LOGS  "EDB delete out of range logs"
#define SERVER_FUNCTION_KEY     "Server Functionality"
#define TCPIP_PORT              "TCP/IP Port"
#define RESTORE_TRIGGER         "Restore from disk backup"
#define PERF_COUNTER_VERSION    "Performance Counter Version"
#define MAILPATH_KEY            "Mail-based replication drop directory"
#define ISM_ALTERNATE_DIRECTORY_SERVER "ISM Alternate Directory Server"
#define ISM_THREAD_PRIORITY     "ISM thread priority"

#define KCC_UPDATE_TOPL_DELAY       "Repl topology update delay (secs)"
#define KCC_UPDATE_TOPL_PERIOD      "Repl topology update period (secs)"
#define KCC_RUN_AS_NTDSDSA_DN       "KCC run as ntdsDsa DN"     // debug only
#define KCC_CRIT_FAILOVER_TRIES     "CriticalLinkFailuresAllowed"
#define KCC_CRIT_FAILOVER_TIME      "MaxFailureTimeForCriticalLink (sec)"
#define KCC_NONCRIT_FAILOVER_TRIES  "NonCriticalLinkFailuresAllowed"
#define KCC_NONCRIT_FAILOVER_TIME   "MaxFailureTimeForNonCriticalLink (sec)"
#define KCC_INTERSITE_FAILOVER_TRIES "IntersiteFailuresAllowed"
#define KCC_INTERSITE_FAILOVER_TIME "MaxFailureTimeForIntersiteLink (sec)"
#define KCC_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN \
                                    "Allow asynchronous replication of writeable domain NCs"
#define KCC_THREAD_PRIORITY         "KCC thread priority"
#define KCC_CONNECTION_PROBATION_TIME "Connection Probation Time (sec)"
#define KCC_CONNECTION_RETENTION_TIME "Connection Deletion Retention Time (sec)"
#define KCC_CONN_REPEAT_DEL_TOLERANCE "Repeated Connection Deletion Tolerance"
#define KCC_REPSTO_FAILURE_TIME     "RepsTo Failure Time (sec)"
#define KCC_TASK_DAMPENING_TIME     "Task Dampening Time (sec)"
#define KCC_CONNECTION_FAILURE_KEY  "KCC connection failures"   // debug only
#define KCC_LINK_FAILURE_KEY        "KCC link failures"         // debug only

#ifdef INCLUDE_UNIT_TESTS
// For testing the buffer-overrun handler
#define KCC_BO_TEST                 "KCC BO Test"               // unit test only
#endif

#define GC_DELAY_ADVERTISEMENT      "Global Catalog Delay Advertisement (sec)"
#define DRA_PERFORM_INIT_SYNCS      "Repl Perform Initial Synchronizations"
#define GC_OCCUPANCY                "Global Catalog Partition Occupancy"
#define GC_PROMOTION_COMPLETE       "Global Catalog Promotion Complete"
#define DRA_SPN_FALLBACK            "Replicator Allow SPN Fallback"
#define LINKED_VALUE_REPLICATION_KEY "Linked Value Replication"
#define DRA_STRICT_REPLICATION_CONSISTENCY \
                                    "Strict Replication Consistency"
#define DRA_OVERRIDE_TOMBSTONE_LIMIT "Allow Replication With Divergent and Corrupt Partner"
#define DRA_STRICT_SCHEDULE_WINDOW "Strict Replication Schedule Window"

#define GPO_DOMAIN_FILE_PATH    "GPODomainFilePath"
#define GPO_DOMAIN_LINK         "GPODomainLink"
#define GPO_DC_FILE_PATH        "GPODCFilePath"
#define GPO_DC_LINK             "GPODCLink"
#define GPO_USER_NAME           "GPOUserName"

#define DEBUG_SYSTEMS           "Debug Systems"
#define DEBUG_SEVERITY          "Severity"
#define DEBUG_LOGGING           "Debug Logging"

// No GC logon keys
#define GCLESS_SITE_STICKINESS   "Cached Membership Site Stickiness (minutes)"
#define GCLESS_STALENESS         "Cached Membership Staleness (minutes)"
#define GCLESS_REFRESH_INTERVAL  "Cached Membership Refresh Interval (minutes)"
#define GCLESS_REFRESH_LIMIT     "Cached Membership Refresh Limit"


/* Event Category Keys */

#define KCC_KEY                     "1 Knowledge Consistency Checker"
#define SECURITY_KEY                "2 Security Events"
#define XDS_INTERFACE_KEY           "3 ExDS Interface Events"
#define MAPI_KEY                    "4 MAPI Interface Events"
#define REPLICATION_KEY             "5 Replication Events"
#define GARBAGE_COLLECTION_KEY      "6 Garbage Collection"
#define INTERNAL_CONFIGURATION_KEY  "7 Internal Configuration"
#define DIRECTORY_ACCESS_KEY        "8 Directory Access"
#define INTERNAL_PROCESSING_KEY     "9 Internal Processing"
#define PERFORMANCE_KEY             "10 Performance Counters"
#define STARTUP_SHUTDOWN_KEY        "11 Initialization/Termination"
#define SERVICE_CONTROL_KEY         "12 Service Control"
#define NAME_RESOLUTION_KEY         "13 Name Resolution"
#define BACKUP_KEY                  "14 Backup"
#define FIELD_ENGINEERING_KEY       "15 Field Engineering"
#define LDAP_INTERFACE_KEY          "16 LDAP Interface Events"
#define SETUP_KEY                   "17 Setup"
#define GC_KEY                      "18 Global Catalog"
#define ISM_KEY                     "19 Inter-site Messaging"
#define GROUP_CACHING_KEY           "20 Group Caching"
#define LVR_KEY                     "21 Linked-Value Replication"
#define DS_RPC_CLIENT_KEY           "22 DS RPC Client"
#define DS_RPC_SERVER_KEY           "23 DS RPC Server"
#define DS_SCHEMA_KEY               "24 DS Schema"
#define PRIVACYON_KEY               "Obscure wire data format"

#define LOGGING_OVERRIDE_KEY        "Logging Override"
#define ASSERT_OVERRIDE_KEY         "Assert Override"

#define GCVERIFY_FORCE_REDISCOVERY_WINDOW_KEY       "GC Force Rediscovery Window (sec)"
#define GCVERIFY_FORCE_WAIT_EXPIRED_KEY             "GC Force Wait Expired (sec)"
#define GCVERIFY_HONOR_FAILURE_WINDOW_KEY           "GC Honor Failure Window (sec)"
#define GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME_KEY   "GC Offsite Failback time (min)"
#define GCVERIFY_DC_INVALIDATION_PERIOD_KEY         "GC Invalidation Period (sec)"

/* Values for the keys, and defaults */

#define DSA_MESSAGE_DLL "ntdsmsg.dll"         // messages DLL
#define ESE_MESSAGE_DLL "esent.dll"
#define DSA_PERF_DLL    "ntdsperf.dll"
#define INVALID_REPL_NOTIFY_VALUE   -1 // This is a invalid value for the notification delays.
#define DEFAULT_DRA_START_PAUSE 15     // Pause before notifying after modify, seconds
#define DEFAULT_DRA_INTERDSA_PAUSE 3           // Pause between notifying DSAs, seconds
#define DEFAULT_GARB_COLLECT_PERIOD 12      // Pause between collections, hours
#define DEFAULT_HIERARCHY_PERIOD 720        // Pause between hierarchy recalcs, minutes
#define DEFAULT_TOMBSTONE_LIFETIME 60          // Tombstone lifetime, days
#define DRA_CONFLICT_LT_MIN 1                   // Minimum, 1 day
#define DRA_TOMBSTONE_LIFE_MIN 2                // Minimum 2 days
#define DEFAULT_SERVER_THREADS  15
#define DEFAULT_DRA_AOQ_LIMIT   10
#define DEFAULT_STAY_OF_EXECUTION 14          // Stay of execution, days
            // DRA_TOMBSTONE_LIFE_MIN/2 <= DEFAULT_STAY_OF_EXECUTION <= tombstone-lifetime/2
#define DEFAULT_DRA_CTX_LIFETIME_INTRA          (0)         // never expire
#define DEFAULT_DRA_CTX_LIFETIME_INTER          (5 * 60)
#define DEFAULT_DRA_CTX_EXPIRY_CHK_INTERVAL     (3 * 60)
#define DEFAULT_DRA_THREAD_OP_PRI_THRESHOLD     (AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED)
#define DEFAULT_DRSRPC_BIND_TIMEOUT             (5)      // bind & unbind
#define DEFAULT_DRSRPC_REPLICATION_TIMEOUT      (5)      // legacy replication traffic
#define DEFAULT_DRSRPC_GCLOOKUP_TIMEOUT         (5)      // simple lookup calls
#define DEFAULT_DRSRPC_MOVEOBJECT_TIMEOUT       (5)      // might be cross-site
#define DEFAULT_DRSRPC_NT4CHANGELOG_TIMEOUT     (15)      // always within site
#define DEFAULT_DRSRPC_OBJECTEXISTENCE_TIMEOUT  (45)   // potential very expensive
#define DEFAULT_DRSRPC_GETREPLINFO_TIMEOUT      (5)       // simple calls?
#define DEFAULT_GC_DELAY_ADVERTISEMENT          (0xffffffffUL)   // Forever in seconds
#define DEFAULT_DRA_MAX_WAIT_SLOW_REPL_WARN     (5) // in mins
#define DEFAULT_DRA_THREAD_PRI_HIGH             (THREAD_PRIORITY_NORMAL)
#define DRA_THREAD_PRI_HIGH_MIN                 (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_HIGH_MAX                 (THREAD_PRIORITY_HIGHEST)
#define DEFAULT_DRA_THREAD_PRI_LOW              (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_LOW_MIN                  (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_LOW_MAX                  (THREAD_PRIORITY_HIGHEST)
#define DRA_MAX_GETCHGREQ_OBJS_MIN              (100)
#define DRA_MAX_GETCHGREQ_BYTES_MIN             (1024*1024)
#define DEFAULT_DRA_REPL_QUEUE_CHECK_TIME       (60*12) //12 hours in minutes
#define DEFAULT_DRA_REPL_LATENCY_CHECK_INTERVAL (1) //1 day
#define DEFAULT_DRA_REPL_COMPRESSION_LEVEL      3
#define DEFAULT_DRA_REPL_COMPRESSION_ALG        DRS_COMP_ALG_XPRESS
#define DEFAULT_THREAD_STATE_HEAP_LIMIT         (100L * 1024L * 1024L)
#define DRA_REPSTO_UPDATE_PERIOD                (60 * 60) //1 hour in seconds

// What priority does the ISM thread run at? The thread priorities
// are values in the range (-2,..,2), but the registry can only store DWORDs, so
// we bias the stored priority values with ISM_THREAD_PRIORITY_BIAS.
#define ISM_DEFAULT_THREAD_PRIORITY 2
#define ISM_MIN_THREAD_PRIORITY     0
#define ISM_MAX_THREAD_PRIORITY     4
#define ISM_THREAD_PRIORITY_BIAS    2

// Delete expired dynamic objects (entryTTL == 0) every 900 secs
// or at the next expiration time plus 30 secs, whichever is less.
#define DEFAULT_DELETE_EXPIRED_ENTRYTTL_SECS        (900)
#define DEFAULT_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS   (30)

// the schema fsmo cannot be transferred for a few seconds after
// it has been transfered or after a schema change (excluding
// replicated or system changes). This gives the schema admin a
// chance to change the schema before having the fsmo pulled away
// by a competing schema admin who also wants to make schema
// changes.
#define DEFAULT_SCHEMA_FSMO_LEASE_SECS          (60)
#define DEFAULT_SCHEMA_FSMO_LEASE_MAX_SECS      (900)

// Performance advisor timeouts
// Define more generous timeouts for the checked build and stress
#if DBG
#define DEFAULT_DRA_MAX_WAIT_FOR_SDP_LOCK   (90 * 1000)  // 90 sec in ms
#define DEFAULT_DRA_MAX_WAIT_MAIL_SEND_MSG  (10 * 60 * 1000) // 10 min in ms
#else
#define DEFAULT_DRA_MAX_WAIT_FOR_SDP_LOCK   (30 * 1000)  // 30 sec in ms
#define DEFAULT_DRA_MAX_WAIT_MAIL_SEND_MSG  (60 * 1000) // 1 min in ms
#endif

#define DEFAULT_DB_EXPENSIVE_SEARCH_THRESHOLD   10000   // evaluated entries >= x
#define DEFAULT_DB_INEFFICIENT_SEARCH_THRESHOLD 1000    // returned entries <= 10% of x visited entries
#define DEFAULT_DB_INTERSECT_THRESHOLD          20
#define DEFAULT_DB_INTERSECT_RATIO              100

//
// DEFAULT GCverify time intervals
//
#define DEFAULT_GCVERIFY_FORCE_REDISCOVERY_WINDOW       60      // Force DC rediscovery if two failed DsrGetDcNameEx2 within one minute.
#define DEFAULT_GCVERIFY_FORCE_WAIT_EXPIRED             (5*60)  // Force rediscovry if no GC and more than five minutes since invalidation.
#define DEFAULT_GCVERIFY_HONOR_FAILURE_WINDOW           60      // Honor FIND_DC_USE_CACHED_FAILURES for 1 minute, then cause DsrGetDcNameEx2.
#define DEFAULT_GCVERIFY_FINDGC_OFFSITE_FAILBACK_TIME   30      // Failback time if we failed to an offsite GC -- 30 mins
#define DEFAULT_GCVERIFY_DC_INVALIDATION_PERIOD         (5*60)  // Time interval before an invalidated GC is removed from the invalidated list (5 minutes)

//
// LDAP limits
//

#define DEFAULT_LDAP_SIZE_LIMIT                             1000
#define DEFAULT_LDAP_CONNECTIONS_LIMIT                      1000
#define DEFAULT_LDAP_TIME_LIMIT                             120
#define DEFAULT_LDAP_NOTIFICATIONS_PER_CONNECTION_LIMIT     5
#define DEFAULT_LDAP_INIT_RECV_TIMEOUT                      120
#define DEFAULT_LDAP_ALLOW_DEEP_SEARCH                      FALSE
#define DEFAULT_LDAP_MAX_CONN_IDLE                          900
#define DEFAULT_LDAP_MAX_REPL_SIZE                          2000
#define DEFAULT_LDAP_MAX_TEMP_TABLE                         10000
#define DEFAULT_LDAP_MAX_RESULT_SET                         (256*1024)
#define DEFAULT_LDAP_MAX_DGRAM_RECV                         (4*1024)
#define DEFAULT_LDAP_MAX_RECEIVE_BUF                        (10*1024*1024)
#define DEFAULT_LDAP_MAX_VAL_RANGE                          (1500)

//
// Service-wide settings
//
// Update schema.ini and sch14.ldf when altering these EntryTTL values
#define DEFAULT_DYNAMIC_OBJECT_DEFAULT_TTL                  86400
#define DEFAULT_DYNAMIC_OBJECT_MIN_TTL                      900

//
//
//
#define WEEK_IN_HOURS (7 * 24)
#define DAYS_IN_HOURS (24)

#define DAYS_IN_SECS (24*60*60)
#define HOURS_IN_SECS (60*60)
#define MINS_IN_SECS (60)
#define SECS_IN_SECS (1)
#define RECOVERY_ON             "ON"

/* Service defined service controll must be in range 128-255 */
#define DS_SERVICE_CONTROL_RECALC_HIERARCHY ((DWORD) 129)
#define DS_SERVICE_CONTROL_DO_GARBAGE_COLLECT   ((DWORD) 130)
#define DS_SERVICE_CONTROL_CANCEL_ASYNC     ((DWORD) 131)

/* Flag in ContainerInfo attribute meaning "Show-up-in-hierarchy-table"
 * Admin needs this.
 */
#define VISIBLE_IN_HIERARCHY_TABLE_MASK         0x80000000

//
//The limit of the number of standard servers that can be in
//an enterprise.
#define MAX_STANDARD_SERVERS        2


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsexcept.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsexcept.h
//
//--------------------------------------------------------------------------

//
// Exceptions raised by the Exchange Directory Service
//
// This is a validly formed exception
// 0xE = (binary 1110), where the first two bits are the severity
//
//     Sev - is the severity code
//
//         00 - Success
//         01 - Informational
//         10 - Warning
//         11 - Error
//
//    and the third bit is the Customer flag (1=an app, 0=the OS)
//
// The rest of the high word is the facility, and the low word
// is the code.  For now, I have stated that the DSA is facility 1,
// and the only exception code we have is 1.
//

#define DSA_EXCEPTION 		    0xE0010001
#define DRA_GEN_EXCEPTION   	0xE0010002
#define DSA_MEM_EXCEPTION	    0xE0010003
#define DSA_DB_EXCEPTION	    0xE0010004
#define DSA_BAD_ARG_EXCEPTION	0xE0010005
#define DSA_CRYPTO_EXCEPTION    0xE0010006

#define NUM_DSA_EXCEPT_ARGS     3

// exception generating / filtering / handling function prototypes


DWORD GetDraException (EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret);

DWORD
GetExceptionData(EXCEPTION_POINTERS* pExceptPtrs,
                 DWORD *pdwException,
                 PVOID * pExceptionAddress,
                 ULONG *pulErrorCode,
                 ULONG *pdsid);

// Trap only replicated object string name collisions.
#define GetDraNameException( pExceptPtrs, pret )                              \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
      && ( DRAERR_NameCollision == *pret )                                    \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap only busy errors.
#define GetDraBusyException( pExceptPtrs, pret )                              \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
      && ( DRAERR_Busy == *pret )                                             \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap only replicated object record too big condition
#define GetDraRecTooBigException( pExceptPtrs, pret )                         \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
     && ( ERROR_DS_MAX_OBJ_SIZE_EXCEEDED == *pret )                           \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap one condition
#define GetDraAnyOneWin32Exception( pExceptPtrs, pret, code )                       \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
     && ( (code) == *pret )                                                   \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Exception macro


#define RaiseDsaException(dwException, ulErrorCode, ul2, \
                          usFileNo, nLine , ulSeverity)  \
        RaiseDsaExcept(dwException, ulErrorCode, ul2,   \
                       ((usFileNo << 16L) | nLine), ulSeverity)

void RaiseDsaExcept (DWORD dwException, ULONG ulErrorCode, ULONG_PTR ul2,
		     DWORD dwId , ULONG ulSeverity);

void DraExcept (ULONG ulErrorCode, ULONG_PTR ul2, DWORD dwId,
                        ULONG ulSeverity);

#define	DsaExcept(exception, p1, p2)	\
        RaiseDsaExcept(exception, p1, p2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT(ul1, ul2)      	\
    DraExcept (ul1, ul2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT_DSID(ul1, ul2, dsid) \
    DraExcept (ul1, ul2, dsid, DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT_NOLOG(ul1, ul2)      	\
    DraExcept (ul1, ul2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_NO_LOGGING)

/*
 * filter expression to handle most exception. Others (access violation, 
 * breakpoint) are not handled and result in a crash
 */
DWORD DoHandleMostExceptions(EXCEPTION_POINTERS* pExceptPtrs, DWORD dwException,
	ULONG ulInternalId);
#define HandleMostExceptions(code)	\
    DoHandleMostExceptions(GetExceptionInformation(), code, \
    (FILENO << 16L) + __LINE__)

/*
 * filter expression to handle all exceptions
 */
DWORD DoHandleAllExceptions(EXCEPTION_POINTERS* pExceptPtrs, DWORD dwException,
	ULONG ulInternalId);
#define HandleAllExceptions(code)	\
    DoHandleAllExceptions(GetExceptionInformation(), code, \
    (FILENO << 16L) + __LINE__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsconlib.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   dsconlib.h - DS Console Library Header Files

Abstract:

   This is the main interface header for the dsconlib.lib library, which provides
   a library for helping console applications internationalize/localize their 
   output.

Author:

    Brett Shirley (BrettSh)

Environment:

    Single threaded utility environment.  (NOT Multi-thread safe)
    
    tapicfg.exe, dcdiag.exe, repadmin.exe, ntdsutil.exe so far
    
    This will require the user to link with this library (which is just a private
    export version of kernel32.dll):
    
	    $(SDK_LIB_PATH)\kernl32p.lib
    
    There are two versions to this library, the CRT version, and the Win32
    version.  It's important to distinguish which one the utility is using, and
    it's important not to mix the two versions of the library.  See NOTES below
    for more details.

Notes:

Revision History:

    Brett Shirley   BrettSh     Aug 4th, 2002
        Created file.

--*/

/*

NOTES:

    There are two versions to this library, the CRT version, and the Win32
    version.  It's important to distinguish which one the utility is using.  
    
    It is also very important to not mix the two versions of the library,
    because according to the experts, the Win32 (WriteConsole()) type APIs
    and the CRT (wprintf()) type APIs may not be mixed with predictable
    results.
    
    The Win32 Version is assumed, because this is the suggested API to use
    for writing new console apps.  Note, however the Win32 Version isn't
    yet implemented.  To use the CRT version, define DS_CON_LIB_CRT_VERSION
    before including the header.
    
    Currently, this library only helps CRT type apps perform proper localized
    initialization.
    
*/

#ifdef __cplusplus
extern "C" {
#endif

// -------------------------------------------------------
//   Globals
// -------------------------------------------------------

typedef struct {   

    BOOL    bStdOutIsFile;
    FILE *  sStdOut;

    FILE *  sStdErr;

    SHORT   wScreenWidth;
} DS_CONSOLE_INFO;

// FUTURE-2002/08/15-BrettSh - This really deserves to be protected,
// and the printing functions can then use it, but for now we'll expose
// it so repadmin can use it.
extern DS_CONSOLE_INFO  gConsoleInfo;


#ifdef DS_CON_LIB_CRT_VERSION

// -------------------------------------------------------
//   CRT Version
// -------------------------------------------------------

void
DsConLibInitCRT(
   void
   );

#define DsConLibInit()      DsConLibInitCRT()

#else

// -------------------------------------------------------
//   Win32 Version
// -------------------------------------------------------

#error "This code is not yet implemented"

void
DsConLibInitWin32(
    void
    );

#define DsConLibInit()      DsConLibInitWin32()

#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsjet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsjet.h
//
//--------------------------------------------------------------------------

#include "esent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsevent.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       dsevent.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This is the main include file that handles the DS logging stuff.


    SHARING LOGGING INFRASTRUCTURE EX-MODULE, IN-PROCESS
    ====================================================
    [2000-02-15 JeffParh]

    It's relatively easy to share event logging code across DLL (or even EXE)
    boundaries within a single process to reduce code/data footprint and
    alleviate the need to have multiple threads waiting for changes in event
    logging levels:

    1. In the module you wish to export logging from, export the following
       functions:
            DoLogEvent
            DoLogEventAndTrace
            DoLogOverride
            DoLogUnhandledError
            DsGetEventConfig

    2. In the module(s) to which you wish to import logging, create the global
       variable DS_EVENT_CONFIG * gpDsEventConfig and assign it the value
       returned from DsGetEventConfig before any event logging macros are
       invoked.

    See ntdsa (supplier) and ntdskcc (consumer) for an example of exporting
    logging from a DLL, and ismserv (supplier) and ismip/ismsmtp (consumers)
    for an example of exporting logging from an EXE.

[Environment:]

    User Mode - Win32

--*/


#ifndef DSEVENT_H_
#define DSEVENT_H

#include <wmistr.h>
#include <evntrace.h>
#include <crypto\md5.h>

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors fix this code.
//

#pragma warning(disable:4296)

#ifdef __cplusplus
extern "C" {
#endif

#define DS_EVENT_MAX_CATEGORIES     24L
#define ESE_EVENT_MAX_CATEGORIES    12L

/* Event categories */

#define DS_EVENT_CAT_KCC                                0
#define DS_EVENT_CAT_SECURITY                           1
#define DS_EVENT_CAT_XDS_INTERFACE                      2
#define DS_EVENT_CAT_MAPI                               3
#define DS_EVENT_CAT_REPLICATION                        4
#define DS_EVENT_CAT_GARBAGE_COLLECTION                 5
#define DS_EVENT_CAT_INTERNAL_CONFIGURATION             6
#define DS_EVENT_CAT_DIRECTORY_ACCESS                   7
#define DS_EVENT_CAT_INTERNAL_PROCESSING                8
#define DS_EVENT_CAT_PERFORMANCE_MONITOR                9   /* also in perfutil.c */
#define DS_EVENT_CAT_STARTUP_SHUTDOWN                   10
#define DS_EVENT_CAT_SERVICE_CONTROL                    11
#define DS_EVENT_CAT_NAME_RESOLUTION                    12
#define DS_EVENT_CAT_BACKUP                             13
#define DS_EVENT_CAT_FIELD_ENGINEERING                  14
#define DS_EVENT_CAT_LDAP_INTERFACE                     15
#define DS_EVENT_CAT_SETUP                              16
#define DS_EVENT_CAT_GLOBAL_CATALOG                     17
#define DS_EVENT_CAT_ISM                                18
#define DS_EVENT_CAT_GROUP_CACHING                      19
#define DS_EVENT_CAT_LVR                                20
#define DS_EVENT_CAT_RPC_CLIENT                         21
#define DS_EVENT_CAT_RPC_SERVER                         22
#define DS_EVENT_CAT_SCHEMA                             23

//
// BOGUS ALERT: You can change this value to anything invalid. Bugus category used to
// force logging to the system log if we fail eventlog initialization
//
#define DS_EVENT_CAT_NETEVENT                      8888888

/* Event severity constants */
#define DS_EVENT_SEV_ALWAYS                             0
#define DS_EVENT_SEV_MINIMAL                            1
#define DS_EVENT_SEV_BASIC                              2
#define DS_EVENT_SEV_EXTENSIVE                          3
#define DS_EVENT_SEV_VERBOSE                            4
#define DS_EVENT_SEV_INTERNAL                           5
#define DS_EVENT_SEV_NO_LOGGING                         128

// Event log name and event sources.  DO NOT CHANGE THESE as they are
// carefully chosen not to conflict with other apps' values.

#define pszNtdsEventLogName         "Directory Service"
#define pszNtdsSourceReplication    "NTDS Replication"
#define pszNtdsSourceDatabase       "NTDS Database"
#define pszNtdsSourceGeneral        "NTDS General"
#define pszNtdsSourceMapi           "NTDS MAPI"
#define pszNtdsSourceXds            "NTDS XDS"
#define pszNtdsSourceSecurity       "NTDS Security"
#define pszNtdsSourceSam            "NTDS SAM"
#define pszNtdsSourceLdap           "NTDS LDAP"
#define pszNtdsSourceSdprop         "NTDS SDPROP"
#define pszNtdsSourceKcc            "NTDS KCC"
#define pszNtdsSourceIsam           "NTDS ISAM"
#define pszNtdsSourceIsm            "NTDS Inter-site Messaging"
#define pszNtdsSourceSetup          "NTDS Setup"
#define pszNtdsSourceRpcClient      "NTDS RPC Client"
#define pszNtdsSourceRpcServer      "NTDS RPC Server"
#define pszNtdsSourceSchema         "NTDS Schema"
#define pszNtdsSourceNtdsapi        "NTDS API"
#define pszNtdsSourceNtdsScript     "NTDS Scripting"
#define pszNtdsSourceJetBack        "NTDS Backup"


typedef struct DS_EVENT_CATEGORY
    {
    MessageId   midCategory;
    ULONG       ulLevel;
    char        *szRegistryKey;
    } DSEventCategory;

typedef struct _DS_EVENT_CONFIG {
    BOOL            fTraceEvents;
    BOOL            fLogOverride;
    DSEventCategory rgEventCategories[DS_EVENT_MAX_CATEGORIES];
    BOOL            fCriticalSectionInitialized;
    CRITICAL_SECTION csLogEvent;
    BYTE             rgbLastEventHash[MD5DIGESTLEN]; // protected by cs
    DWORD            cSuppressedEvents;              // protected by cs
    DWORD            dwSuppressedEventId;            // protected by cs
} DS_EVENT_CONFIG;

extern DS_EVENT_CONFIG * gpDsEventConfig;

extern HANDLE hServDoneEvent;

typedef struct EventSourceMapping {
    DWORD       dirNo;
    CHAR        *pszEventSource;
} EventSourceMapping;

extern EventSourceMapping   rEventSourceMappings[];
extern DWORD                cEventSourceMappings;
extern DWORD                iDefaultEventSource;

#ifndef CP_TELETEX
#define CP_TELETEX  20261
#endif


/* Macros for alerting and logging */

#if DBG
#define LogEventWouldLogFileNo( cat, sev, fileno ) \
    ((NULL == gpDsEventConfig) \
     ? (DoAssert("Event logging not initialized, can't log event!", \
                 DSID(fileno, __LINE__), __FILE__), \
        FALSE) \
     : ((((LONG) (sev)) <= (LONG)gpDsEventConfig->rgEventCategories[cat].ulLevel) \
        || (gpDsEventConfig->fLogOverride \
            && DoLogOverride((fileno),((ULONG)(sev))))))
#else
#define LogEventWouldLogFileNo( cat, sev, fileno ) \
    ((NULL != gpDsEventConfig) \
     && ((((LONG) (sev)) <= (LONG)gpDsEventConfig->rgEventCategories[cat].ulLevel) \
         || (gpDsEventConfig->fLogOverride \
             && DoLogOverride((fileno),((ULONG)(sev))))))
#endif

#define LogEventWouldLog(cat, sev) LogEventWouldLogFileNo(cat, sev, FILENO)

#define AlertEvent(cat, sev, msg, arg1, arg2, arg3)  {              \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        LOG_PARAM_BLOCK logBlock;                                      \
        logBlock.nInsert = 0;                                      \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                   \
        logBlock.mid = msg;                                        \
        logBlock.traceFlag = 0;                                    \
        logBlock.fLog = FALSE;                     \
        (arg1); (arg2); (arg3);                     \
        logBlock.pData = NULL;                     \
        logBlock.cData = 0;                        \
        logBlock.fIncludeName = TRUE;              \
        logBlock.fAlert = TRUE;                    \
        logBlock.fileNo = FILENO;                  \
        logBlock.TraceHeader = NULL;               \
        logBlock.ClientID = 0;                     \
        DoLogEventAndTrace(&logBlock);              \
    } \
}


#define LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6,   \
                          arg7, arg8, cbData, pvData)  {                       \
    if (LogEventWouldLog((cat), (sev))) { \
        LOG_PARAM_BLOCK logBlock;                                         \
        logBlock.nInsert = 0;                                                 \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;               \
        logBlock.severity = sev;                                              \
        logBlock.mid = msg;                                                   \
        logBlock.traceFlag = 0;                                               \
        logBlock.fLog = TRUE;                                                 \
        (arg1); (arg2); (arg3); (arg4); (arg5); (arg6); (arg7); (arg8);        \
        logBlock.pData = pvData;                    \
        logBlock.cData = cbData;                    \
        logBlock.fIncludeName = TRUE;               \
        logBlock.fAlert = FALSE;                    \
        logBlock.fileNo = FILENO;                   \
        logBlock.TraceHeader = NULL;                \
        logBlock.ClientID = 0;                      \
        DoLogEventAndTrace(&logBlock);                \
    }                                                \
}

#define LogEventWithFileNo(cat, sev, msg, arg1, arg2, arg3, _FileNo) \
    LogEvent8WithFileNo(cat, sev, msg,  arg1, arg2, arg3, 0, 0, 0, 0, 0, _FileNo)

#define LogEvent8WithFileNo(cat, sev, msg,  arg1, arg2, arg3, arg4, arg5, arg6,   \
                            arg7, arg8, _FileNo ) {        \
    if (LogEventWouldLogFileNo((cat), (sev), (_FileNo))) { \
        LOG_PARAM_BLOCK logBlock;                                                 \
        logBlock.nInsert = 0;                                                 \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;               \
        logBlock.severity = sev;                                              \
        logBlock.mid = msg;                                                   \
        logBlock.traceFlag = 0;                                               \
        logBlock.fLog = TRUE;                                                 \
        (arg1); (arg2); (arg3); (arg4); (arg5); (arg6); (arg7); (arg8);       \
        logBlock.pData = NULL;                      \
        logBlock.cData = 0;                         \
        logBlock.fIncludeName = TRUE;               \
        logBlock.fAlert = FALSE;                    \
        logBlock.fileNo = (_FileNo);                \
        logBlock.TraceHeader = NULL;                \
        logBlock.ClientID = 0;                      \
        DoLogEventAndTrace(&logBlock);                \
    }                                                \
}

#define LogSystemEvent(msg, arg1, arg2, arg3) { \
    LOG_PARAM_BLOCK logBlock;                  \
    logBlock.nInsert = 0;                       \
    logBlock.category = 0;                      \
    logBlock.severity = DS_EVENT_SEV_ALWAYS;    \
    logBlock.mid = msg;                         \
    logBlock.traceFlag = 0;                     \
    logBlock.fLog = TRUE;                       \
    (arg1); (arg2); (arg3);                      \
    logBlock.pData = NULL;                      \
    logBlock.cData = 0;    ;                    \
    logBlock.fIncludeName = FALSE;              \
    logBlock.fAlert = FALSE;                    \
    logBlock.fileNo = DIRNO_NETEVENT;           \
    logBlock.TraceHeader = NULL;                \
    logBlock.ClientID = 0;                      \
    DoLogEventAndTrace(&logBlock);                \
}


typedef
VOID
(*TRACE_EVENT_FN)(
    IN MessageId Mid,
    IN DWORD    WmiEventType,
    IN DWORD    TraceGuid,
    IN PEVENT_TRACE_HEADER TraceHeader,
    IN DWORD    ClientID,
    IN PWCHAR    Arg1,
    IN PWCHAR    Arg2,
    IN PWCHAR    Arg3,
    IN PWCHAR    Arg4,
    IN PWCHAR    Arg5,
    IN PWCHAR    Arg6,
    IN PWCHAR    Arg7,
    IN PWCHAR    Arg8
    );


typedef struct _INSERT_PARAMS {

    DWORD   InsertType;
    PVOID   pInsert;
    DWORD   InsertLen;
    DWORD_PTR   tmpDword;

} INSERT_PARAMS, *PINSERT_PARAMS;


typedef struct _LOG_PARAM_BLOCK {

    DWORD       nInsert;
    MessageId   mid;
    MessageId   category;
    DWORD       severity;
    DWORD       event;
    DWORD       traceFlag;
    BOOL        fLog;
    BOOL        fIncludeName;
    BOOL        fAlert;
    DWORD       fileNo;
    DWORD       cData;
    PVOID       pData;
    DWORD       TraceGuid;
    PEVENT_TRACE_HEADER TraceHeader;
    DWORD               ClientID;

    TRACE_EVENT_FN  TraceEvent;
    INSERT_PARAMS   params[8];

} LOG_PARAM_BLOCK, *PLOG_PARAM_BLOCK;

enum {
    inSz,
    inWC,
    inWCCounted,
    inInt,
    inHex,
    inUL,
    inDN,
    inNT4SID,
    inUUID,
    inDsMsg,
    inWin32Msg,
    inUSN,
    inHex64,
    inJetErrMsg,
    inDbErrMsg,
    inThStateErrMsg
};

/* Macros for inserting parameters into messages */

#define szInsertSz(x)  (logBlock.params[logBlock.nInsert].InsertType = inSz,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertWC(x)  (logBlock.params[logBlock.nInsert].InsertType = inWC,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertWC2(x,len)  (logBlock.params[logBlock.nInsert].InsertType = inWCCounted,\
                            logBlock.params[logBlock.nInsert].InsertLen = (len),\
                            logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertInt(x) (logBlock.params[logBlock.nInsert].InsertType = inInt, \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD)x,\
                        logBlock.params[logBlock.nInsert++].pInsert =         \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertHex(x) (logBlock.params[logBlock.nInsert].InsertType = inHex,   \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD)x,  \
                        logBlock.params[logBlock.nInsert++].pInsert =           \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#ifdef _WIN64
#define szInsertPtr(x) (logBlock.params[logBlock.nInsert].InsertType = inHex64,  \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD_PTR)x, \
                        logBlock.params[logBlock.nInsert++].pInsert =           \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )
#else // _WIN64
#define szInsertPtr(x) szInsertHex(x)
#endif // _WIN64

#define szInsertUL(x)  (logBlock.params[logBlock.nInsert].InsertType = inUL,\
                        logBlock.params[logBlock.nInsert].tmpDword = x,     \
                        logBlock.params[logBlock.nInsert++].pInsert =       \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertUSN(x) (logBlock.params[logBlock.nInsert].InsertType = inUSN,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)&(x))

#define szInsertDN(x)  (logBlock.params[logBlock.nInsert].InsertType = inDN,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x))

#define szInsertMTX(x) szInsertSz((x) ? (PCHAR)(x)->mtx_name : "[]")

#define szInsertUUID(x) (logBlock.params[logBlock.nInsert].InsertType = inUUID,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x))

#define szInsertAttrType(x,buf) szInsertSz(ConvertAttrTypeToStr((x),(buf)))

// If you use this, you must include dsutil.h first
// Note must not allocate this buf, must use an array of chars.
#define szInsertDSTIME(x,buf) szInsertSz( DSTimeToDisplayStringCch((x),(buf),(sizeof(buf)/sizeof((buf)[0]))) )

#define szInsertDsMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inDsMsg, \
                          logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                          logBlock.params[logBlock.nInsert++].pInsert =       \
                              (void *)&logBlock.params[logBlock.nInsert].tmpDword )


// Operators for inserting error messages and error codes

#define szInsertWin32Msg(x) (logBlock.params[logBlock.nInsert].InsertType = inWin32Msg,\
                             logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                             logBlock.params[logBlock.nInsert++].pInsert =       \
                                 (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertJetErrMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inJetErrMsg,\
                           logBlock.params[logBlock.nInsert].tmpDword = (DWORD) (x), \
                           logBlock.params[logBlock.nInsert++].pInsert =       \
                                (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertDbErrMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inDbErrMsg,\
                             logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                             logBlock.params[logBlock.nInsert++].pInsert =       \
                                 (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertThStateErrMsg() (logBlock.params[logBlock.nInsert++].InsertType = inThStateErrMsg)

#define szInsertLdapErrMsg(x) szInsertWC(ldap_err2stringW(x))

#define szInsertNtStatusMsg(x) szInsertWin32Msg(RtlNtStatusToDosError(x))

#define szInsertHResultMsg(x) szInsertWin32Msg(x)

// Hide the default radix of various types of errors
#define szInsertWin32ErrCode(x) szInsertUL(x)
#define szInsertJetErrCode(x) szInsertInt(x)
#define szInsertDbErrCode(x) szInsertInt(x)
// This is also known as the "DirError" as returned from the DirXXX API.
// For example attributeError, nameError, etc.
#define szInsertThStateErrCode(x) szInsertInt(x)
#define szInsertLdapErrCode(x) szInsertHex(x)
#define szInsertNtStatusCode(x) szInsertHex(x)
#define szInsertHResultCode(x) szInsertHex(x)
#define szInsertDSID(x) szInsertHex(x)

DWORD
DsGetEventTraceFlag();

#define LogAndTraceEventWithHeader(_log, cat, sev, msg, _evt, _guid, _TraceHeader, _ClientID,                 \
                                   a1, a2, a3, a4, a5, a6, a7, a8)                    \
{                                                                                   \
    Assert(NULL != gpDsEventConfig); \
    if ((NULL != gpDsEventConfig) \
        && (gpDsEventConfig->fTraceEvents \
            || ((_log) && LogEventWouldLog((cat), (sev))))) { \
        LOG_PARAM_BLOCK logBlock;                                                   \
        logBlock.nInsert = 0;                                                       \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                                   \
        logBlock.mid = msg;                                                        \
        logBlock.event = _evt;                                                     \
        logBlock.traceFlag = gpDsEventConfig->fTraceEvents;                        \
        logBlock.TraceEvent = DsTraceEvent;                                        \
        logBlock.TraceGuid = (DWORD)_guid;                                         \
        logBlock.fLog = ((_log) && LogEventWouldLog((cat), (sev))); \
        (a1); (a2); (a3); (a4); (a5); (a6); (a7); (a8);                             \
        logBlock.pData = NULL;                                                     \
        logBlock.cData = 0;                                                        \
        logBlock.fIncludeName = TRUE;                                              \
        logBlock.fAlert = FALSE;                                                   \
        logBlock.fileNo = FILENO;                                                  \
        logBlock.TraceHeader = _TraceHeader;                                       \
        logBlock.ClientID = _ClientID;                                             \
        DoLogEventAndTrace(&logBlock);                                               \
    }                                                                               \
}

#define LogAndTraceEvent(_log, cat, sev, msg, _evt, _guid, a1, a2, a3, a4, a5, a6, a7, a8) \
    LogAndTraceEventWithHeader(_log, cat, sev, msg, _evt, _guid, NULL, 0, a1, a2, a3, a4, a5, a6, a7, a8)

VOID
DoLogEventAndTrace(PLOG_PARAM_BLOCK LogBlock);

BOOL
DoLogOverride(DWORD file, ULONG sev);

#define LogEvent8(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
    LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, \
                      arg6, arg7, arg8, 0, NULL)

#define LogEvent(cat, sev, msg, arg1, arg2, arg3)           \
    LogEvent8(cat, sev, msg, arg1, arg2, arg3, NULL, NULL, NULL, NULL, NULL)

#define LogAndAlertEvent(cat, sev, msg, arg1, arg2, arg3) {\
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        LOG_PARAM_BLOCK logBlock;                                      \
        logBlock.nInsert = 0;                                      \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                   \
        logBlock.mid = msg;                                        \
        logBlock.traceFlag = 0;                                    \
        logBlock.fLog = LogEventWouldLog((cat), (sev)); \
        (arg1); (arg2); (arg3);                     \
        logBlock.pData = NULL;                     \
        logBlock.cData = 0;                        \
        logBlock.fIncludeName = TRUE;              \
        logBlock.fAlert = TRUE;                    \
        logBlock.fileNo = FILENO;                  \
        logBlock.TraceHeader = NULL;               \
        logBlock.ClientID = 0;                     \
        DoLogEventAndTrace(&logBlock);              \
    } \
}

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName);

#define LogUnhandledError(err)                      \
    DoLogUnhandledError(((FILENO << 16) | __LINE__), (err), TRUE)

//  For errors where we can't obtain the users name.
#define LogUnhandledErrorAnonymous(err)                      \
    DoLogUnhandledError(((FILENO << 16) | __LINE__), (err), FALSE)

#define MemoryPanic(size) { \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        char szSize[12];                        \
        char szID[9];                           \
        _itoa(size, szSize, 16);                    \
        _ultoa((FILENO << 16) | __LINE__, szID, 16);            \
        DoLogEvent(                         \
            FILENO,                         \
            gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory, \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_MALLOC_FAILURE,                  \
            TRUE,                                   \
            szSize, szID, NULL, NULL, NULL, NULL,   \
                NULL, NULL, 0, NULL);               \
    } \
}

#define LogAndAlertUnhandledError(err) LogAndAlertUnhandledErrorDSID(err, (FILENO << 16) | __LINE__)

#define LogAndAlertUnhandledErrorDSID(err, dsid) { \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        char szErr[12];                             \
        char szHexErr[12];                          \
        char szID[9];                               \
        _itoa(err, szHexErr, 16);                   \
        _itoa(err, szErr, 10);                      \
        _ultoa(dsid, szID, 16);\
        DoLogEvent(                                 \
            FILENO,                                 \
            gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory, \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_INTERNAL_FAILURE,                \
            TRUE,                                   \
            szErr, szHexErr, szID, NULL, NULL, NULL, NULL, NULL, 0, NULL);   \
        AlertEvent(DS_EVENT_CAT_FIELD_ENGINEERING,  \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_INTERNAL_FAILURE,                \
            szErr, szHexErr, szID );                \
    } \
}

PSID GetCurrentUserSid(void);
BOOL DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
          MessageId midEvent, ... );
BOOL DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
          MessageId midEvent, ... );
BOOL DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
        MessageId midEvent, int iIncludeName,
        char *arg1, char *arg2, char *arg3, char *arg4,
        char *arg5, char *arg6, char *arg7, char *arg8,
        DWORD cbData, VOID * pvData);
BOOL DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
        MessageId midEvent, int iIncludeName,
        WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
        WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
        DWORD cbData, VOID * pvData);

HANDLE LoadEventTable(void);
void UnloadEventTable(void);


typedef void (__cdecl *LoadParametersCallbackFn)(void)  ;
void SetLoadParametersCallback (LoadParametersCallbackFn pFn);

HANDLE LoadParametersTable(void);
void UnloadParametersTable(void);


DWORD
ImpersonateAnyClient(void);

VOID
UnImpersonateAnyClient(void);

PCHAR
ConvertAttrTypeToStr(
    IN ATTRTYP AttributeType,
    IN OUT PCHAR OutBuffer
    );

ULONG
AuthenticateSecBufferDesc(VOID *pv);

DS_EVENT_CONFIG *
DsGetEventConfig(void);

DWORD
InitializeEventLogging();

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // DSEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dststlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dststlog.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file exports the ds test logger

Revision History:

--*/

#ifndef _DSTSTLOG_H_
#define _DSTSTLOG_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef
BOOL
(*DS_PRINTLOG)(
    IN DWORD Flags,
    IN LPSTR Format,
    ...
    );

#define DSLOG_FLAG_OPEN     0x00000001
#define DSLOG_FLAG_NOTIME   0x00000002
#define DSLOG_FLAG_TAG_CNPN 0x00000004  // add computername and process nametags

#define DEFINE_DSLOG        HINSTANCE hDsLog=NULL;DS_PRINTLOG pfnDsPrintLog=NULL;
#define DECLARE_DSLOG       extern HINSTANCE hDsLog;extern DS_PRINTLOG pfnDsPrintLog;

#if DBG
#define DSINITLOG() {    \
    hDsLog = LoadLibrary(TEXT("ntdsapi.dll"));     \
    if ( hDsLog != NULL ) {                         \
        pfnDsPrintLog=(DS_PRINTLOG)GetProcAddress(hDsLog,"DsLogEntry");   \
    }     \
}

#define DSLOG(_x)       if (pfnDsPrintLog != NULL) {pfnDsPrintLog _x;}
#define DSLOG_ACTIVE    (pfnDsPrintLog != NULL)
#else
#define DSLOG(_x)
#define DSLOG_ACTIVE    FALSE
#define DSINITLOG()
#endif

extern HINSTANCE hDsLog;
extern DS_PRINTLOG pfnDsPrintLog;

#ifdef __cplusplus
}
#endif


#endif // _DSTSTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dstrace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dstrace.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Include file to contain variables required for event tracing of DS

Author:

    26-Mar-1998  JohnsonA, JeePang

Revision History:

--*/

#ifndef _DSTRACE_H
#define _DSTRACE_H

#include <wmistr.h>
#include <evntrace.h>
#include "dstrguid.h"

extern TRACEHANDLE      DsTraceRegistrationHandle;
extern TRACEHANDLE      DsTraceLoggerHandle;
extern PCHAR            DsCallerType[];
extern PCHAR            DsSearchType[];

#define DS_TRACE_VERSION            3

PCHAR
GetCallerTypeString(
    IN THSTATE *pTHS
    );

#define SEARCHTYPE_STRING(i)   DsSearchType[i]

//
// Do the actual trace logs
//

VOID
DsTraceEvent(
    IN MessageId Event,
    IN DWORD    WmiEventType,
    IN DWORD    TraceGuid,
    IN PEVENT_TRACE_HEADER TraceHeader,
    IN DWORD    ClientID,
    IN PWCHAR    Arg1,
    IN PWCHAR    Arg2,
    IN PWCHAR    Arg3,
    IN PWCHAR    Arg4,
    IN PWCHAR    Arg5,
    IN PWCHAR    Arg6,
    IN PWCHAR    Arg7,
    IN PWCHAR    Arg8
    );

#endif /* _DSTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dstrguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dstrguid.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Contains the trace guid used by the DS

Author:

    26-Mar-1998  JohnsonA, JeePang

Revision History:

--*/

#ifndef _DSTRGUID_H
#define _DSTRGUID_H

#include <guiddef.h>

//
// This is the control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 1c83b2fc-c04f-11d1-8afc-00c04fc21914 */
    DsControlGuid,
    0x1c83b2fc,
    0xc04f,
    0x11d1,
    0x8a, 0xfc, 0x00, 0xc0, 0x4f, 0xc2, 0x19, 0x14
  );

//
// Traceable Guids start here
//

DEFINE_GUID ( /* 05acd000-daeb-11d1-be80-00c04fadfff5 */
    DsDirSearchGuid,
    0x05acd000,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd001-daeb-11d1-be80-00c04fadfff5 */
    DsDirAddEntryGuid,
    0x05acd001,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd002-daeb-11d1-be80-00c04fadfff5 */
    DsDirModEntryGuid,
    0x05acd002,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd003-daeb-11d1-be80-00c04fadfff5 */
    DsDirDelEntryGuid,
    0x05acd003,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd004-daeb-11d1-be80-00c04fadfff5 */
    DsDirCompareGuid,
    0x05acd004,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd005-daeb-11d1-be80-00c04fadfff5 */
    DsDirModDNGuid,
    0x05acd005,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd006-daeb-11d1-be80-00c04fadfff5 */
    DsDirGetNcChangesGuid,
    0x05acd006,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsDirReplicaSyncGuid,
    0x05acd007,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsDirFind,
    0x05acd008,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsLdapBind,
    0x05acd009,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* b9d4702a-6a98-11d2-b710-00c04fb998a2 */
    DsLdapRequestGuid,
    0xb9d4702a,
    0x6a98,
    0x11d2,
    0xb7, 0x10, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
);

DEFINE_GUID ( /* 14f8aa22-7f4b-11d2-b389-0000f87a46c8 */
    DsKccTaskGuid,
    0x14f8aa22,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa23-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaSyncGuid,
    0x14f8aa23,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa24-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaGetChgGuid,
    0x14f8aa24,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa25-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsUpdateRefsGuid,
    0x14f8aa25,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa26-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaAddGuid,
    0x14f8aa26,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa27-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaModifyGuid,
    0x14f8aa27,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa28-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaDelGuid,
    0x14f8aa28,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa29-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsVerifyNamesGuid,
    0x14f8aa29,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2a-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsInterDomainMoveGuid,
    0x14f8aa2a,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2b-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsAddEntryGuid,
    0x14f8aa2b,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2c-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsExecuteKccGuid,
    0x14f8aa2c,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2d-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetReplInfoGuid,
    0x14f8aa2d,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2e-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetNT4ChgLogGuid,
    0x14f8aa2e,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2f-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsCrackNamesGuid,
    0x14f8aa2f,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa30-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsWriteSPNGuid,
    0x14f8aa30,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa31-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsDCInfoGuid,
    0x14f8aa31,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa32-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetMembershipsGuid,
    0x14f8aa32,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );


DEFINE_GUID ( /* f5075994-b9e2-4e51-88f1-e5c43a3cfd9a */
    DsDrsGetMembershipsGuid2,
    0xf5075994,
    0xb9e2,
    0x4e51,
    0x88, 0xf1, 0xe5, 0xc4, 0x3a, 0x3c, 0xfd, 0x9a
  );


DEFINE_GUID( /* D01B04CF-240E-11d3-ACBE-00C04F68A51D */
    DsNspiUpdateStatGuid, 
    0xd01b04cf, 
    0x240e, 
    0x11d3, 
    0xac, 0xbe, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d
  );



DEFINE_GUID( // {4D63B05C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiCompareDNTsGuid, 
    0x4d63b05c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {61569D69-2502-11d3-ACC1-00C04F68A51D}
    DsNspiQueryRowsGuid, 
    0x61569d69, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiSeekEntriesGuid, 
    0x6f370d3c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3D-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetMatchesGuid, 
    0x6f370d3d, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3E-2502-11d3-ACC1-00C04F68A51D}
    DsNspiResolveNamesGuid, 
    0x6f370d3e, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189A-2502-11d3-ACC1-00C04F68A51D}
    DsNspiDNToEphGuid, 
    0x7842189a, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189B-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetHierarchyInfoGuid, 
    0x7842189b, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiResortRestrictionGuid, 
    0x7842189c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {80AD666A-2502-11d3-ACC1-00C04F68A51D}
    DsNspiBindGuid, 
    0x80ad666a, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {873BDDEA-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetNamesFromIDsGuid, 
    0x873bddea, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {873BDDEB-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetIDsFromNamesGuid, 
    0x873bddeb, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5846-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetPropListGuid, 
    0x8d8c5846, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5847-2502-11d3-ACC1-00C04F68A51D}
    DsNspiQueryColumnsGuid, 
    0x8d8c5847, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5848-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetPropsGuid, 
    0x8d8c5848, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {96EF9AA6-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetTemplateInfoGuid, 
    0x96ef9aa6, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {96EF9AA7-2502-11d3-ACC1-00C04F68A51D}
    DsNspiModPropsGuid, 
    0x96ef9aa7, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {380D48A4-2506-11d3-ACC1-00C04F68A51D}
    DsNspiModLinkAttGuid, 
    0x380d48a4, 0x2506, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {380D48A5-2506-11d3-ACC1-00C04F68A51D}
    DsNspiDeleteEntriesGuid, 
    0x380d48a5, 0x2506, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);

DEFINE_GUID( // {E357DC53-B6FC-48e0-8189-C9D2AB2A8F16}
    DsTaskQueueExecuteGuid, 
    0xe357dc53, 0xb6fc, 0x48e0, 0x81, 0x89, 0xc9, 0xd2, 0xab, 0x2a, 0x8f, 0x16);

DEFINE_GUID ( /* 0c685beb-377e-4d09-b360-161f49e14348 */
    DsDrsQuerySitesByCostGuid,
    0x0c685beb,
    0x377e,
    0x4d09,
    0xb3, 0x60, 0x16, 0x1f, 0x49, 0xe1, 0x43, 0x48
  );


// ------------------------- Add your new GUIDs here ---------------------------
//
// Don't forget to include them into the array of registered trace GUIDs.
// See DsTraceGuids[] in dstrace.c. Also, include an enum value for your GUID
// into the enum below. It is EXTREMELY IMPORTANT to have the enums in
// EXACTLY the same order as guids appearing in the DsTraceGuids array in
// dstrace.c. This is because the enum is used as an XLAT index: index of
// GUID to the GUID itself (see DoLogEventAndTrace in dsevent.c)

typedef enum _DSTRACE_GUIDS {

    DsGuidSearch,
    DsGuidAdd,
    DsGuidModify,
    DsGuidModDN,
    DsGuidDelete,
    DsGuidCompare,
    DsGuidGetNcChanges,
    DsGuidReplicaSync,
    DsGuidFind,
    DsGuidLdapBind,
    DsGuidLdapRequest,
    DsGuidKccTask,
    DsGuidDrsReplicaSync,
    DsGuidDrsReplicaGetChg,
    DsGuidDrsUpdateRefs,
    DsGuidDrsReplicaAdd,
    DsGuidDrsReplicaModify,
    DsGuidDrsReplicaDel,
    DsGuidDrsVerifyNames,
    DsGuidDrsInterDomainMove,
    DsGuidDrsAddEntry,
    DsGuidDrsExecuteKcc,
    DsGuidDrsGetReplInfo,
    DsGuidDrsGetNT4ChgLog,
    DsGuidDrsCrackNames,
    DsGuidDrsWriteSPN,
    DsGuidDrsDCInfo,
    DsGuidDrsGetMemberships,
    DsGuidDrsGetMemberships2,
    DsGuidNspiUpdateStat,
    DsGuidNspiCompareDNTs,
    DsGuidNspiQueryRows,
    DsGuidNspiSeekEntries,
    DsGuidNspiGetMatches,
    DsGuidNspiResolveNames,
    DsGuidNspiDNToEph,
    DsGuidNspiGetHierarchyInfo,
    DsGuidNspiResortRestriction,
    DsGuidNspiBind,
    DsGuidNspiGetNamesFromIDs,
    DsGuidNspiGetIDsFromNames,
    DsGuidNspiGetPropList,
    DsGuidNspiQueryColumns,
    DsGuidNspiGetProps,
    DsGuidNspiGetTemplateInfo,
    DsGuidNspiModProps,
    DsGuidNspiModLinkAtt,
    DsGuidNspiDeleteEntries,
    DsGuidTaskQueueExecute,
    DsGuidDrsQuerySitesByCost
} DSTRACE_GUID;

#endif /* _DSTRGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\filtypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       filtypes.h
//
//--------------------------------------------------------------------------

#define FI_CHOICE_EQUALITY        ((UCHAR) 0x00)
#define FI_CHOICE_SUBSTRING       ((UCHAR) 0x01)
#define FI_CHOICE_GREATER	  ((UCHAR) 0x02)
#define FI_CHOICE_GREATER_OR_EQ   ((UCHAR) 0x03)
#define FI_CHOICE_LESS            ((UCHAR) 0x04)
#define FI_CHOICE_LESS_OR_EQ      ((UCHAR) 0x05)
#define FI_CHOICE_NOT_EQUAL	  ((UCHAR) 0x06)
#define FI_CHOICE_PRESENT         ((UCHAR) 0x07)
#define FI_CHOICE_TRUE            ((UCHAR) 0x08)
#define FI_CHOICE_FALSE           ((UCHAR) 0x09)
#define FI_CHOICE_BIT_AND         ((UCHAR) 0x0A)
#define FI_CHOICE_BIT_OR          ((UCHAR) 0x0B)
#define FI_CHOICE_UNDEFINED       ((UCHAR) 0x0C)


// bitmap table of valid relational operators indexed by syntax
extern WORD  rgValidOperators[];

// macros for setting checking relational operator validity
#define RelOpMask(relop)		((WORD) (1 << (relop)))
#define FLegalOperator(syntax, relop)	(rgValidOperators[syntax] & RelOpMask(relop))

#define FILTER_CHOICE_ITEM    'I'
#define FILTER_CHOICE_AND     'A'
#define FILTER_CHOICE_OR      'O'
#define FILTER_CHOICE_NOT     'N'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for directory server c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define DSID(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to ds\src\util\dsid\dsid.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsevent\dsevent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_COMMON    (0)                             // src\common
#define DIRNO_DRA       (1 << 8)                        // \ntdsa\dra
#define DIRNO_DBLAYER   (2 << 8)                        // \ntdsa\dblayer
#define DIRNO_SRC       (3 << 8)                        // \ntdsa\src
#define DIRNO_NSPIS     (4 << 8)                        // \ntdsa\nspis
#define DIRNO_DRS       (5 << 8)                        // \ntdsa\drs
#define DIRNO_XDS       (6 << 8)                        // \ntdsa\xdsserv
#define DIRNO_BOOT      (7 << 8)                        // \ntdsa\boot
#define DIRNO_PERMIT    (8 << 8)                        // \src\permit
#define DIRNO_ALLOCS    (9 << 8)                        // \dsamain\allocs
#define DIRNO_LIBXDS    (10 << 8)                       // \src\libxds
#define DIRNO_SAM       (11 << 8)                       // SAM
#define DIRNO_LDAP      (12 << 8)                       // src\ntdsa\ldap
#define DIRNO_SDPROP    (13 << 8)                       // src\ntdsa\sdprop
#define DIRNO_TASKQ     (14 << 8)                       // src\taskq
#define DIRNO_KCC       (15 << 8)                       // src\kcc
// Define a DIRNO so that we can make Jet's event log entries go to
// the Directory Service log instead of the Application log.
#define DIRNO_ISAM      (16 << 8)                       // JET
#define DIRNO_ISMSERV   (17 << 8)                       // src\ism\server
#define DIRNO_PEK       (18 << 8)                       // dsamain\src\pek
#define DIRNO_NTDSETUP  (19 << 8)                       // src\ntdsetup
#define DIRNO_NTDSAPI   (20 << 8)                     // src\ntdsapi
#define DIRNO_NTDSCRIPT (21 << 8)                     // util\ntdscript
#define DIRNO_JETBACK   (22 << 8)                       // Jet backup
#define DIRNO_KCCSIM    (23 << 8)                       // the KCC simulator
#define DIRNO_UTIL	(24 << 8)			// generic util directory stuff
#define DIRNO_TEST      (25 << 8)                       // test directory
#define DIRNO_NETEVENT  (0xFF << 8)                     // bogus

// common directory
#define FILENO_ALERT            (DIRNO_COMMON + 0)      // alert.c
#define FILENO_DEBUG            (DIRNO_COMMON + 0)      // debug.c
#define FILENO_DSCONFIG         (DIRNO_COMMON + 1)      // dsconfig.c
#define FILENO_DSEVENT          (DIRNO_COMMON + 2)      // dsevent.c
#define FILENO_DSEXCEPT         (DIRNO_COMMON + 3)      // dsexcept.c
#define FILENO_DBOPEN           (DIRNO_COMMON + 4)      // dbopen.c
#define FILENO_NTUTILS          (DIRNO_COMMON + 5)      // ntutils.c
#define FILENO_DSLOGEVT         (DIRNO_COMMON + 6)      // dsevent\dslogevt.cxx
#define FILENO_DSUTIL           (DIRNO_COMMON + 7)      // dsutil.c
#define FILENO_QTCOMMON         (DIRNO_COMMON + 8)      // qtcommon.c

// nspis directory
#define FILENO_NSPSERV          (DIRNO_NSPIS + 0)       // nspserv.c
#define FILENO_MODPROP          (DIRNO_NSPIS + 1)       // modprop.c
#define FILENO_DETAILS          (DIRNO_NSPIS + 2)       // details.c
#define FILENO_ABTOOLS          (DIRNO_NSPIS + 3)       // abtools.c
#define FILENO_ABBIND           (DIRNO_NSPIS + 4)       // abbind.c
#define FILENO_ABSEARCH         (DIRNO_NSPIS + 5)       // absearch.c
#define FILENO_ABNAMEID         (DIRNO_NSPIS + 6)       // abnameid.c
#define FILENO_NSPNOTIF         (DIRNO_NSPIS + 7)       // nspnotif.c
#define FILENO_ABSERV           (DIRNO_NSPIS + 8)       // abserv.c
#define FILENO_MSDSSERV         (DIRNO_NSPIS + 9)       // msdsserv.c
#define FILENO_MSNOTIF          (DIRNO_NSPIS + 10)      // msnotif.c

// dra directory
#define FILENO_DIRTY            (DIRNO_DRA + 0)         // dirty.c
#define FILENO_DRAASYNC         (DIRNO_DRA + 1)         // draasync.c
#define FILENO_DRAERROR         (DIRNO_DRA + 2)         // draerror.c
#define FILENO_DRAGTCHG         (DIRNO_DRA + 3)         // dragtchg.c
#define FILENO_DRAINST          (DIRNO_DRA + 4)         // drainst.c
#define FILENO_DRAMAIL          (DIRNO_DRA + 5)         // dramail.c
#define FILENO_DRANCADD         (DIRNO_DRA + 6)         // drancadd.c
#define FILENO_DRANCDEL         (DIRNO_DRA + 7)         // drancdel.c
#define FILENO_DRANCREP         (DIRNO_DRA + 8)         // drancrep.c
#define FILENO_DRASERV          (DIRNO_DRA + 9)         // draserv.c
#define FILENO_DRASYNC          (DIRNO_DRA + 10)        // drasync.c
#define FILENO_DRAUPDRR         (DIRNO_DRA + 11)        // draupdrr.c
#define FILENO_DRAUTIL          (DIRNO_DRA + 12)        // drautil.c
#define FILENO_PICKEL           (DIRNO_DRA + 13)        // pickel.c
#define FILENO_DRAXUUID         (DIRNO_DRA + 14)        // draxuuid.c
#define FILENO_DRAUPTOD         (DIRNO_DRA + 15)        // drauptod.c
#define FILENO_DRAMETA          (DIRNO_DRA + 16)        // drameta.c
#define FILENO_DRARFMOD         (DIRNO_DRA + 17)        // drarfmod.c
#define FILENO_DRADIR           (DIRNO_DRA + 18)        // dradir.c
#define FILENO_GCLOGON          (DIRNO_DRA + 19)        // gclogon.c
#define FILENO_DRASCH           (DIRNO_DRA + 20)        // drasch.c
#define FILENO_DRACHKPT         (DIRNO_DRA + 21)        // drachkpt.c
#define FILENO_NTDSAPI          (DIRNO_DRA + 22)        // ntdsapi.c
#define FILENO_SPNOP            (DIRNO_DRA + 23)        // spnop.c
#define FILENO_DRACRYPT         (DIRNO_DRA + 24)        // dracrypt.c
#define FILENO_DRAINFO          (DIRNO_DRA + 25)        // drainfo.c
#define FILENO_ADDSID           (DIRNO_DRA + 26)        // addsid.c
#define FILENO_DRAINIT          (DIRNO_DRA + 27)        // drainit.c
#define FILENO_DRADEMOT         (DIRNO_DRA + 28)        // drademot.c
#define FILENO_DRAMSG           (DIRNO_DRA + 29)        // dramsg.c
#define FILENO_NTDSCRIPT        (DIRNO_DRA + 30)        // script.cxx
#define FILENO_DRARPC           (DIRNO_DRA + 31)        // drarpc.c
#define FILENO_DRAMDERR	        (DIRNO_DRA + 32)        // dramderr.c
#define FILENO_DRAEXIST         (DIRNO_DRA + 33)        // draexist.c
#define FILENO_DRAAUDIT         (DIRNO_DRA + 34)        // draaudit.c
#define FILENO_DRASIG           (DIRNO_DRA + 35)        // drasig.c

// dblayer directory

#define FILENO_DBEVAL           (DIRNO_DBLAYER + 0)     // dbeval.c
#define FILENO_DBINDEX          (DIRNO_DBLAYER + 1)     // dbindex.c
#define FILENO_DBINIT           (DIRNO_DBLAYER + 2)     // dbinit.c
#define FILENO_DBISAM           (DIRNO_DBLAYER + 3)     // dbisam.c
#define FILENO_DBJETEX          (DIRNO_DBLAYER + 4)     // dbjetex.c
#define FILENO_DBOBJ            (DIRNO_DBLAYER + 5)     // dbobj.c
#define FILENO_DBSUBJ           (DIRNO_DBLAYER + 6)     // dbsubj.c
#define FILENO_DBSYNTAX         (DIRNO_DBLAYER + 7)     // dbsyntax.c
#define FILENO_DBTOOLS          (DIRNO_DBLAYER + 8)     // dbtools.c
#define FILENO_DBPROP           (DIRNO_DBLAYER + 9)     // dbprop.c
#define FILENO_DBSEARCH         (DIRNO_DBLAYER + 10)    // dbsearch.c
#define FILENO_DBMETA           (DIRNO_DBLAYER + 11)    // dbmeta.c
#define FILENO_DBESCROW         (DIRNO_DBLAYER + 12)    // dbescrow.c
#define FILENO_DBCACHE          (DIRNO_DBLAYER + 13)    // dbache.c
#define FILENO_DBCONSTR         (DIRNO_DBLAYER + 14)    // dbconstr.c
#define FILENO_DBLINK           (DIRNO_DBLAYER + 15)    // dblink.c
#define FILENO_DBFILTER         (DIRNO_DBLAYER + 16)    // dbfilter.c

// drsserv directory
#define FILENO_DRSUAPI          (DIRNO_DRS + 0)         // drsuapi.c
#define FILENO_IDLNOTIF         (DIRNO_DRS + 1)         // idlnotif.c
#define FILENO_IDLTRANS         (DIRNO_DRS + 2)         // idltrans.c

// xdsserv directory
#define FILENO_ATTRLIST         (DIRNO_XDS + 0)         // attrlist.c
#define FILENO_COMPRES          (DIRNO_XDS + 1)         // compres.c
#define FILENO_CONTEXT          (DIRNO_XDS + 2)         // context.c
#define FILENO_DSWAIT           (DIRNO_XDS + 3)         // dswait.c
#define FILENO_INFSEL           (DIRNO_XDS + 4)         // infsel.c
#define FILENO_LISTRES          (DIRNO_XDS + 5)         // listres.c
#define FILENO_MODIFY           (DIRNO_XDS + 6)         // modify.c
#define FILENO_OMTODSA          (DIRNO_XDS + 7)         // omtodsa.c
#define FILENO_READRES          (DIRNO_XDS + 8)         // readres.c
#define FILENO_SEARCHR          (DIRNO_XDS + 9)         // searchr.c
#define FILENO_SYNTAX           (DIRNO_XDS + 10)        // syntax.c
#define FILENO_XDSAPI           (DIRNO_XDS + 11)        // xdsapi.c
#define FILENO_XDSNOTIF         (DIRNO_XDS + 12)        // xdsnotif.c

// src directory

#define FILENO_DSAMAIN      (DIRNO_SRC + 0)         // dsamain.c
#define FILENO_DSANOTIF     (DIRNO_SRC + 1)         // dsanotif.c
#define FILENO_DSATOOLS     (DIRNO_SRC + 2)         // dsatools.c
#define FILENO_DSTASKQ      (DIRNO_SRC + 3)         // dstaskq.c
#define FILENO_HIERTAB      (DIRNO_SRC + 4)         // hiertab.c
#define FILENO_MDADD        (DIRNO_SRC + 5)         // mdadd.c
#define FILENO_MDBIND       (DIRNO_SRC + 6)         // mdbind.c
#define FILENO_MDCHAIN      (DIRNO_SRC + 7)         // mdchain.c
#define FILENO_MDCOMP       (DIRNO_SRC + 8)         // mdcomp.c
#define FILENO_MDDEL        (DIRNO_SRC + 9)         // mddel.c
#define FILENO_MDDIT        (DIRNO_SRC + 10)        // mddit.c
#define FILENO_MDERRMAP     (DIRNO_SRC + 11)        // mderrmap.c
#define FILENO_MDERROR      (DIRNO_SRC + 12)        // mderror.c
#define FILENO_MDINIDSA     (DIRNO_SRC + 13)        // mdinidsa.c
#define FILENO_MDLIST       (DIRNO_SRC + 14)        // mdlist.c
#define FILENO_MDMOD        (DIRNO_SRC + 15)        // mdmod.c
#define FILENO_MDNAME       (DIRNO_SRC + 16)        // mdname.c
#define FILENO_MDNOTIFY     (DIRNO_SRC + 17)        // mdnotify.c
#define FILENO_MDREAD       (DIRNO_SRC + 18)        // mdread.c
#define FILENO_MDREMOTE     (DIRNO_SRC + 19)        // mdremote.c
#define FILENO_MDSEARCH     (DIRNO_SRC + 20)        // mdsearch.c
#define FILENO_MDUPDATE     (DIRNO_SRC + 21)        // mdupdate.c
#define FILENO_MSRPC        (DIRNO_SRC + 22)        // msrpc.c
#define FILENO_SCACHE       (DIRNO_SRC + 23)        // scache.c
#define FILENO_X500PERM     (DIRNO_SRC + 24)        // x500perm.c
#define FILENO_LOOPBACK     (DIRNO_SRC + 25)        // loopback.c
#define FILENO_MAPPINGS     (DIRNO_SRC + 26)        // mappings.c
#define FILENO_MDMODDN      (DIRNO_SRC + 27)        // mdmoddn.c
#define FILENO_SAMLOGON     (DIRNO_SRC + 28)        // samlogon.c
#define FILENO_SAMWRITE     (DIRNO_SRC + 29)        // samwrite.c
#define FILENO_CRACKNAM     (DIRNO_SRC + 30)        // cracknam.c
#define FILENO_DOMINFO      (DIRNO_SRC + 31)        // dominfo.c
#define FILENO_GCVERIFY     (DIRNO_SRC + 32)        // gcverify.c
#define FILENO_MDCTRL       (DIRNO_SRC + 33)        // mdctrl.c
#define FILENO_PERMIT       (DIRNO_SRC + 34)        // permit.c
#define FILENO_DISKBAK      (DIRNO_SRC + 35)        // diskbak.c
#define FILENO_PARSEDN      (DIRNO_SRC + 36)        // parsedn.c
#define FILENO_MDFIND       (DIRNO_SRC + 37)        // mdfind.c
#define FILENO_SCCHK        (DIRNO_SRC + 38)        // scchk.c
#define FILENO_RPCCANCL     (DIRNO_SRC + 39)        // rpccancl.c
#define FILENO_GTCACHE      (DIRNO_SRC + 40)        // gtcache.c
#define FILENO_DSTRACE      (DIRNO_SRC + 41)        // dstrace.c
#define FILENO_FPOCLEAN     (DIRNO_SRC + 42)        // fpoclean.c
#define FILENO_SERVINFO     (DIRNO_SRC + 43)        // servinfo.c
#define FILENO_PHANTOM      (DIRNO_SRC + 44)        // phantom.c
#define FILENO_XDOMMOVE     (DIRNO_SRC + 45)        // xdommove.c
#define FILENO_IMPERSON     (DIRNO_SRC + 46)        // imperson.c
#define FILENO_MAPSPN       (DIRNO_SRC + 47)        // mapspn.c
#define FILENO_SECADMIN     (DIRNO_SRC + 48)        // secadmin.c
#define FILENO_SAMCACHE     (DIRNO_SRC + 49)        // samcache.c
#define FILENO_LINKCLEAN    (DIRNO_SRC + 50)        // linkclean.c
#define FILENO_MDNDNC       (DIRNO_SRC + 51)        // mdndnc.c
#define FILENO_LHT          (DIRNO_SRC + 52)        // lht.c
#define FILENO_SYNC         (DIRNO_SRC + 53)        // sync.c
#define FILENO_MDDEBUG      (DIRNO_SRC + 54)        // mddebug.c
#define FILENO_QUOTA        (DIRNO_SRC + 55)        // quota.c

// bootstrapping files
#define FILENO_ADDSERV      (DIRNO_BOOT + 0)        // addserv.c
#define FILENO_INSTALL      (DIRNO_BOOT + 1)        // install.cxx
#define FILENO_ADDOBJ       (DIRNO_BOOT + 2)        // addobj.cxx
#define FILENO_BOOT_PARSEINI (DIRNO_BOOT + 3)	    // parseini.cxx

// permit files
#define FILENO_CHECKSD          (DIRNO_PERMIT + 0)      // checksd.c

// allocs files
#define FILENO_ALLOCS           (DIRNO_ALLOCS + 0)      // allocs.c

// libxds files
#define FILENO_CLIENT           (DIRNO_LIBXDS + 0)      // client.c

//newsam2
#define FILENO_SAM              (DIRNO_SAM + 0)         // SAM

//ldap
#define FILENO_LDAP_GLOBALS     (DIRNO_LDAP + 0)        // global.cxx
#define FILENO_LDAP_CONN        (DIRNO_LDAP + 1)        // connect.cxx
#define FILENO_LDAP_INIT        (DIRNO_LDAP + 2)        // init.cxx
#define FILENO_LDAP_LDAP        (DIRNO_LDAP + 3)        // ldap.cxx
#define FILENO_LDAP_CONV        (DIRNO_LDAP + 4)        // ldapconv.cxx
#define FILENO_LDAP_REQ         (DIRNO_LDAP + 5)        // request.cxx
#define FILENO_LDAP_USER        (DIRNO_LDAP + 6)        // userdata.cxx
#define FILENO_LDAP_CORE        (DIRNO_LDAP + 7)        // ldapcore.cxx
#define FILENO_LDAP_LDAPBER     (DIRNO_LDAP + 8)        // ldapber.cxx
#define FILENO_LDAP_COMMAND     (DIRNO_LDAP + 9)        // command.cxx
#define FILENO_LDAP_LIMITS      (DIRNO_LDAP +10)        // limits.cxx
#define FILENO_LDAP_MISC        (DIRNO_LDAP +11)        // misc.cxx
#define FILENO_LDAP_DECODE      (DIRNO_LDAP +12)        // decode.cxx
#define FILENO_LDAP_ENCODE      (DIRNO_LDAP +13)        // encode.cxx
#define FILENO_LDAP_SECURE      (DIRNO_LDAP +14)        // secure.cxx
#define FILENO_LDAP_REQUEST_HXX (DIRNO_LDAP +15)        // request.hxx
#define FILENO_LDAP_USERDATA_HXX (DIRNO_LDAP +16)	// userdata.hxx
#define FILENO_LDAP_GLOBALS_HXX	(DIRNO_LDAP +17)	// globals.hxx

//sdprop
#define FILENO_PROPDMON         (DIRNO_SDPROP + 0)      // propdmon.c
#define FILENO_PROPQ            (DIRNO_SDPROP + 1)      // propq.c
#define FILENO_SDPGATE          (DIRNO_SDPROP + 2)      // sdpgate.c


//taskq
#define FILENO_TASKQ_TASKQ      (DIRNO_TASKQ + 0)       // taskq.c
#define FILENO_TASKQ_TIME       (DIRNO_TASKQ + 1)       // time.c

//kcc
#define FILENO_KCC_KCCMAIN      (DIRNO_KCC + 0)         // kccmain.cxx
#define FILENO_KCC_KCCLINK      (DIRNO_KCC + 1)         // kcclink.cxx
#define FILENO_KCC_KCCCONN      (DIRNO_KCC + 2)         // kccconn.cxx
#define FILENO_KCC_KCCCREF      (DIRNO_KCC + 3)         // kcccref.cxx
#define FILENO_KCC_KCCDSA       (DIRNO_KCC + 4)         // kccdsa.cxx
#define FILENO_KCC_KCCDUAPI     (DIRNO_KCC + 5)         // kccduapi.cxx
#define FILENO_KCC_KCCTASK      (DIRNO_KCC + 6)         // kcctask.cxx
#define FILENO_KCC_KCCTOPL      (DIRNO_KCC + 7)         // kcctopl.cxx
#define FILENO_KCC_KCCSITE      (DIRNO_KCC + 8)         // kccsite.cxx
#define FILENO_KCC_KCCTOOLS     (DIRNO_KCC + 9)         // kcctools.cxx
#define FILENO_KCC_KCCNCTL      (DIRNO_KCC + 10)        // kccnctl.cxx
#define FILENO_KCC_KCCDYNAR     (DIRNO_KCC + 11)        // kccdynar.cxx
#define FILENO_KCC_KCCSTETL     (DIRNO_KCC + 12)        // kccstetl.cxx
#define FILENO_KCC_KCCSCONN     (DIRNO_KCC + 13)        // kccsconn.cxx
#define FILENO_KCC_KCCTRANS     (DIRNO_KCC + 14)        // kcctrans.cxx
#define FILENO_KCC_KCCCACHE_HXX (DIRNO_KCC + 15)        // kcccache.hxx
#define FILENO_KCC_KCCCACHE     (DIRNO_KCC + 16)        // kcccache.cxx
#define FILENO_KCC_KCCSITELINK  (DIRNO_KCC + 17)        // kccsitelink.cxx
#define FILENO_KCC_KCCBRIDGE    (DIRNO_KCC + 18)        // kccbridge.cxx

#define FILENO_KCC_KCCDSA_HXX   (DIRNO_KCC + 19)        // kccdsa.hxx
#define FILENO_KCC_KCCDYNAR_HXX (DIRNO_KCC + 20)        // kccdynar.hxx
#define FILENO_KCC_KCCSCONN_HXX (DIRNO_KCC + 21)        // kccsconn.hxx
#define FILENO_KCC_KCCSTALE_HXX (DIRNO_KCC + 22)        // kccstale.hxx
#define FILENO_KCC_KCCTRANS_HXX (DIRNO_KCC + 23)        // kcctrans.hxx
#define FILENO_KCC_KCCCONN_HXX  (DIRNO_KCC + 24)        // kccconn.hxx
#define FILENO_KCC_KCCCREF_HXX  (DIRNO_KCC + 25)        // kcccref.hxx
#define FILENO_KCC_KCCSITE_HXX  (DIRNO_KCC + 26)        // kccsite.hxx

#define FILENO_KCC_KCCWALG      (DIRNO_KCC + 27)        // kccwalg.cxx

//kcc/sim
#define FILENO_KCCSIM_BUILDCFG	(DIRNO_KCCSIM + 0)	// sim\buildcfg.c
#define FILENO_KCCSIM_BUILDMAK	(DIRNO_KCCSIM + 1)	// sim\buildmak.c
#define FILENO_KCCSIM_DIR	(DIRNO_KCCSIM + 2)	// sim\dir.c
#define FILENO_KCCSIM_KCCSIM	(DIRNO_KCCSIM + 3)	// sim\kccsim.c
#define FILENO_KCCSIM_LDIF	(DIRNO_KCCSIM + 4)	// sim\ldif.c
#define FILENO_KCCSIM_SIMDSAPI	(DIRNO_KCCSIM + 5)	// sim\simdsapi.c
#define FILENO_KCCSIM_SIMISM	(DIRNO_KCCSIM + 6)	// sim\simism.c
#define FILENO_KCCSIM_SIMMDNAM	(DIRNO_KCCSIM + 7)	// sim\simmdnam.c
#define FILENO_KCCSIM_SIMMDREP 	(DIRNO_KCCSIM + 8)	// sim\simmdrep.c
#define FILENO_KCCSIM_SIMMDWT	(DIRNO_KCCSIM + 9)	// sim\simmdmt.c
#define FILENO_KCCSIM_SIMTIME	(DIRNO_KCCSIM + 10)	// sim\simtime.c
#define FILENO_KCCSIM_STATE	(DIRNO_KCCSIM + 11)	// sim\state.c
#define FILENO_KCCSIM_USER	(DIRNO_KCCSIM + 12)	// sim\user.c
#define FILENO_KCCSIM_UTIL	(DIRNO_KCCSIM + 13)	// sim\util.c


//ism\server
#define FILENO_ISMSERV_TRANSPRT (DIRNO_ISMSERV + 0)     // transprt.cxx
#define FILENO_ISMSERV_PENDING  (DIRNO_ISMSERV + 1)     // pending.cxx
#define FILENO_ISMSERV_LDAPOBJ  (DIRNO_ISMSERV + 2)     // ldapobj.cxx
#define FILENO_ISMSERV_ISMAPI   (DIRNO_ISMSERV + 3)     // ismapi.cxx
#define FILENO_ISMSERV_SERVICE  (DIRNO_ISMSERV + 4)     // service.cxx
#define FILENO_ISMSERV_MAIN     (DIRNO_ISMSERV + 5)     // main.cxx
#define FILENO_ISMSERV_IPSEND   (DIRNO_ISMSERV + 6)     // ip\sendrecv.c
#define FILENO_ISMSERV_XMITRECV (DIRNO_ISMSERV + 7)     // smtp\xmitrecv.cxx
#define FILENO_ISMSERV_ROUTE    (DIRNO_ISMSERV + 8)     // route.c
#define FILENO_ISMSERV_ADSISUPP (DIRNO_ISMSERV + 9)     // smtp\adsisupp.cxx
#define FILENO_ISMSERV_ISMSMTP  (DIRNO_ISMSERV + 10)    // smtp\ismsmtp.c
#define FILENO_ISMSERV_CDOSUPP  (DIRNO_ISMSERV + 11)    // smtp\cdosupp.c
#define FILENO_ISMSERV_ISMIP    (DIRNO_ISMSERV + 12)    // ip\ismip.c
#define FILENO_ISMSERV_ISMSERV_HXX	(DIRNO_ISMSERV + 13)	// server\service.hxx
#define FILENO_ISMSERV_MEMORY	(DIRNO_ISMSERV + 14)	// trnsprts\common\memory.c
#define FILENO_ISMSERV_LIST	(DIRNO_ISMSERV + 15)	// trnsprts\common\list.c
#define FILENO_ISMSERV_TABLE	(DIRNO_ISMSERV + 16)	// trnsprts\common\table.c
#define FILENO_ISMSERV_SIMISM	(DIRNO_ISMSERV + 17)	// trnsprts\common\simlib\simism.c
#define FILENO_ISMSERV_SIMISMT	(DIRNO_ISMSERV + 18)	// trnsprts\common\simlib\simismt.c
#define FILENO_ISMSERV_GRAPH	(DIRNO_ISMSERV + 19)	// trnsprts\common\graph.c

//pek
#define FILENO_PEK              (DIRNO_PEK+0)           // pek.c

// ntsetup
#define FILENO_NTDSETUP_NTDSETUP (DIRNO_NTDSETUP+0)     // ntdsetup.c

// ntdsapi
#define FILENO_NTDSAPI_REPLICA  (DIRNO_NTDSAPI + 0)     // replica.c
#define FILENO_NTDSAPI_SPN	(DIRNO_NTDSAPI + 1)	// spn.c
#define FILENO_NTDSAPI_DSRSA	(DIRNO_NTDSAPI + 2)	// dsrsa.c
#define FILENO_NTDSAPI_SITEINFO_POSTXP	(DIRNO_NTDSAPI + 3)	// siteinfo-postxp.c
#define FILENO_NTDSAPI_BIND_POSTXP	(DIRNO_NTDSAPI + 4)	// bind-postxp.c

// ntdscript
#define FILENO_NTDSCRIPT_NTDSCONTENT  (DIRNO_NTDSCRIPT + 0)     // NTDSConent.cxx
#define FILENO_NTDSCRIPT_LOG          (DIRNO_NTDSCRIPT + 1)     // log.cxx
#define FILENO_NTDSCRIPT_PARSERMAIN   (DIRNO_NTDSCRIPT + 2)     // parsermain.cxx

// Jetback
#define FILENO_JETBACK		(DIRNO_JETBACK + 0)               // jetback.c
#define FILENO_JETREST		(DIRNO_JETBACK + 1)               // jetrest.c
#define FILENO_SNAPSHOT		(DIRNO_JETBACK + 2)               // snapshot.cxx
#define FILENO_DIRAPI		(DIRNO_JETBACK + 3)               // dirapi.c
#define FILENO_JETBACK_COMMON	(DIRNO_JETBACK + 4)	// common.c
#define FILENO_JETBACK_JETBCLI_JETBCLI  (DIRNO_JETBACK + 5) 	// jetbcli\jetbcli.c
#define FILENO_JETBACK_JETBCLI_JETRCLI  (DIRNO_JETBACK + 6) 	// jetbcli\jetrcli.c
#define FILENO_JETBACK_JETBACK	(DIRNO_JETBACK + 7) 	// jetback\jetback.c
#define FILENO_JETBACK_JETREST	(DIRNO_JETBACK + 8)	// jetback\jetrest.c

// Generic stuff in the ds\src\util directory, where a single
// directory really doesn't justify it's own DIRNO, because there
// is only one or two files in it, but it should have it's own
// FILENO
#define FILENO_UTIL_DNSRESL_DNS		(DIRNO_UTIL + 0)	// dnsresl\dns.c
#define FILENO_UTIL_BASE64_BASE64	(DIRNO_UTIL + 1)	// base64\base64.c
#define FILENO_UTIL_REPLSTRUCT_REPLDEMARSHAL	(DIRNO_UTIL + 2)	// replstruct\repldemarshal.cxx
#define FILENO_UTIL_REPLSTRUCT_REPLMARSHALBLOB	(DIRNO_UTIL + 3)	// replstruct\replmarshalblob.cxx
#define FILENO_UTIL_REPLSTRUCT_REPLMARSHALXML	(DIRNO_UTIL + 4)	// replstruct\replmarshalxml.cxx
#define FILENO_UTIL_REPLSTRUCT_REPLSTRUCTINFO	(DIRNO_UTIL + 5)	// replstruct\replstructinfo.cxx
#define FILENO_UTIL_XLIST_UTIL		        (DIRNO_UTIL + 6)	// x_list\util.c
#define FILENO_UTIL_XLIST_LDAP		        (DIRNO_UTIL + 7)	// x_list\x_list_ldap.c
#define FILENO_UTIL_XLIST_ERR		        (DIRNO_UTIL + 8)	// x_list\x_list_err.c
#define FILENO_UTIL_XLIST_DCLIST		(DIRNO_UTIL + 9)	// x_list\dc_list.c
#define FILENO_UTIL_XLIST_SITELIST		(DIRNO_UTIL + 10)	// x_list\site_list.c
#define FILENO_UTIL_XLIST_OBJLIST		(DIRNO_UTIL + 11)	// x_list\obj_list.c
#define FILENO_UTIL_XLIST_OBJDUMP		(DIRNO_UTIL + 12)	// x_list\obj_dump.c

// Test
#define FILENO_TEST_REPLCTRL    (DIRNO_TEST + 0) // replctrl.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\dsutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsutil.h
//
//  Contents:  Common Utility Routines
//
//  Functions:
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LARGE_INTEGER
atoli
(
    char* Num
);

char *
litoa
(
    LARGE_INTEGER value,
    char *string,
    int radix
);

#if 0
VOID
IntializeCommArg(
    IN OUT COMMARG *pCommArg
);

VOID
InitializeDsName(
    IN DSNAME *pDsName,
    IN WCHAR *NamePrefix,
    IN ULONG NamePrefixLen,
    IN WCHAR *Name,
    IN ULONG NameLength
);
#endif

void
FileTimeToDSTime(
    IN  FILETIME        filetime,
    OUT DSTIME *        pDstime
    );

void
DSTimeToFileTime(
    IN  DSTIME          dstime,
    OUT FILETIME *      pFiletime
    );

void
DSTimeToUtcSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    );

void
DSTimeToLocalSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    );

// See dsatools.h for the two different SZUUID_LEN's depending on if CACHE_UUID
// is defined.  The routine will now be well behaved no matter what the client
// passes in, so if you compiled with CACHE_UUID on in dscommon, but not in 
// ntdsa, there would be no buffer overflows.
UCHAR *
UuidToStr(
    const UUID* pUuid, 
    UCHAR *szOutUuid, 
    const ULONG cchOutUuid );

ULONG
SidToStr(
    const PUCHAR pSid, 
    DWORD SidLen, 
    PUCHAR pOutSid, 
    ULONG cchOutSid );

#define SZDSTIME_LEN (20)
LPSTR
DSTimeToDisplayStringCch(
    IN  DSTIME  dstime,
    OUT LPSTR   pszTime,
    IN  ULONG   cchTime
    );

// This function formats a uuid in the official way www-xxx-yyy-zzz
LPSTR
DsUuidToStructuredStringCch(
    const UUID * pUuid,
    LPSTR pszUuidBuffer,
    ULONG cchUuidBuffer );


LPWSTR
DsUuidToStructuredStringCchW(
    const UUID * pUuid,
    LPWSTR pszUuidBuffer,
    ULONG  cchUuidBuffer );


// These functions are deprecated, please use the counted functions above, 
// useage of these #define assumes that buf is an array of chars, not a 
// pointer to a buffer.  If it is a pointer to a buffer the function will 
// simply fail and assert in debug builds.  Nearly all existing usage used
// an array of chars, so there was very little to change to make these
// #defines work.
#define DSTimeToDisplayString(dstime, buf)  DSTimeToDisplayStringCch(dstime, buf, sizeof(buf)/sizeof((buf)[0]))
#define DsUuidToStructuredString(uuid, buf)  DsUuidToStructuredStringCch((uuid), (buf), sizeof(buf)/sizeof((buf)[0]))
#define DsUuidToStructuredStringW(uuid, buf)  DsUuidToStructuredStringCchW((uuid), (buf), sizeof(buf)/sizeof((buf)[0]))

// I_RpcGetExtendedError is not available on Win95/WinNt4 
// (at least not initially) so we make MAP_SECURITY_PACKAGE_ERROR
// a no-op for that platform.

BOOL
fNullUuid (
    const UUID *pUuid);

#if !WIN95 && !WINNT4

DWORD
MapRpcExtendedHResultToWin32(
    HRESULT hrCode
    );

// Get extended security error from RPC; Handle HRESULT values
// I_RpcGetExtendedError can return 0 if the error occurred remotely.

#define MAP_SECURITY_PACKAGE_ERROR( status ) \
if ( ( status == RPC_S_SEC_PKG_ERROR ) ) { \
    DWORD secondary; \
    secondary = I_RpcGetExtendedError(); \
    if (secondary) { \
        if (IS_ERROR(secondary)) {\
            status = MapRpcExtendedHResultToWin32( secondary ); \
        } else { \
            status = secondary; \
        } \
    } \
}

#else

#define MAP_SECURITY_PACKAGE_ERROR( status )

#endif

DWORD
AdvanceTickTime(
    DWORD BaseTick,
    DWORD Delay
    );

DWORD
CalculateFutureTickTime(
    IN DWORD Delay
    );

DWORD
DifferenceTickTime(
    DWORD GreaterTick,
    DWORD LesserTick
    );

int
CompareTickTime(
    DWORD Tick1,
    DWORD Tick2
    );

BOOLEAN
DsaWaitUntilServiceIsRunning(
    CHAR *ServiceName
    );

BOOL IsSetupRunning();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ldapagnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldapagnt.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file exports the LDAP server to the rest of the NT5 Directory Service.

Author:

    Colin Watson     [ColinW]    09-Jul-1996

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
DoLdapInitialize();

VOID
TriggerLdapStop();

VOID
WaitLdapStop();

BOOL 
LdapStartGCPort( VOID );

VOID 
LdapStopGCPort( VOID );        

VOID 
DisableLdapLimitsChecks( VOID );        

DWORD
LdapEnumConnections(
    IN THSTATE *pTHS,
    IN PDWORD Count,
    IN PVOID *Buffer
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\mdglobal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mdglobal.h
//
//--------------------------------------------------------------------------

#ifndef _mdglobal_h_
#define _mdglobal_h_


#include "msrpc.h"
#include "ntsam.h"
#include <align.h>          // alignment macros

#include <authz.h>          // Authz framework
#include <authzi.h>          // Authz framework


#define DEFS_ONLY
#include <draatt.h>
#undef DEFS_ONLY

/**************************************************************************
The following constants define the DS behavior version this binary supports, 
DS_BEHAVIOR_VERSION_CURRENT is the current version, DS_BEHAVIOR_VERSION_MIN 
defines the lowest version that this binary supports.  

If any change is to be made to these constants, the "msDs-Behavior-Version"
attributes in schema.ini need to be updated manually. As shown below, you have
to change all the x's to the value of DS_BEHAVIOR_VERSION_MIN and all the y's
to the value of DS_BEHAVIOR_VERSION_CURRENT in their respective sections.

[DEFAULTROOTDOMAIN]
ms-Ds-Behavior-Version=x
......
[PARTITIONS]
ms-Ds-Behavior-Version=x
......
[DEFAULTFIRSTMACHINE]
ms-Ds-Behavior-Version=y
......
[DEFAULTADDLMACHINE]
ms-Ds-Behavior-Version=y
......
[DEFAULTADDLMACHINEREPLICA]
ms-Ds-Behavior-Version=y
***************************************************************************/

#define DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS
#define DS_BEHAVIOR_WIN_DOT_NET                    DS_BEHAVIOR_WIN2003

#define DS_BEHAVIOR_VERSION_CURRENT   DS_BEHAVIOR_WIN_DOT_NET
#define DS_BEHAVIOR_VERSION_MIN       DS_BEHAVIOR_WIN2000

// The new schema reuse, defunct, and delete behavior is enabled
// by setting the forest version to DS_BEHAVIOR_SCHEMA_REUSE.
// aka BETA3.
//
// Schema reuse (aka schema delete) is only enabled in later forests
// because downrev binaries will stop replicating and can't be demoted
// or recovered once msDS-IntIds are allocated to new attributes!
// All DCs must support schema-reuse before setting the forest
// version to DS_BEHAVIOR_SCHEMA_REUSE.
#define DS_BEHAVIOR_SCHEMA_REUSE      DS_BEHAVIOR_WIN_DOT_NET

// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

/**************************************************************************
 *   Miscellaneous Common Data Structures
 **************************************************************************/

typedef DSNAME NAMING_CONTEXT;

typedef struct _CROSS_REF {
    NAMING_CONTEXT *pNC;         /* NC this CR is for */
    ATTRBLOCK      *pNCBlock;    /* NC, in predigested block format */
    DSNAME         *pObj;        /* Object holding info for this CR */
    LPWSTR          NetbiosName; /* if ntds domain, netbios name of domain, NULL otherwise */
    LPWSTR          DnsName;     /* if ntds domain or ndnc, dns name of nc, NULL otherwise */
    LPWSTR          DnsAliasName;/* if ntds domain or ndnc, alias dns name of nc, NULL otherwise */
    DWORD           flags;       /* Cross-Ref object's FLAG_CR_* bits */
    DWORD           dwFirstNotifyDelay;       /* This is the delay before notifying the
                                               first DSA replication partner of changes. */
    DWORD           dwSubsequentNotifyDelay;  /* This is the delay between notifying a
                                               subsequent DSA repl partners of changes */
    DSNAME *        pdnSDRefDom;        /* This is the Security Descriptor Reference
                                           Domain for NDNCs.  It's SDRefDom for short. */
    PSID            pSDRefDomSid;       /* All access to this variable should be done through
                                           GetSDRefDomSid().  This variable may or may not
                                           be filled in. */
    // All values from ATT_DNS_ROOT. DnsName (above) is a copy of the
    // first value. A copy is used to avoid confusing the old code that
    // thinks a cross ref has one and only one dns name. Which is true
    // for Active Directory's NC cross refs although it might not be
    // true for the user-created cross refs. At any rate, the code will
    // use DnsName above when a DNS name is needed and will use the values
    // stored here when generating a referral.
    ATTRVALBLOCK    DnsReferral;
    DWORD           bEnabled; // ATT_ENABLED (TRUE if not present)
} CROSS_REF;


#define PAS_DATA_VER               VERSION_V1
typedef struct _PAS_Data {
    SHORT                version;       // structure version
    SHORT                size;          // structure size
    DWORD                flag;          // current PAS replication state. Used only for Assert at the moment.
    PARTIAL_ATTR_VECTOR  PAS;           // additional attributes required for PAS cycle
} PAS_DATA, *PPAS_DATA;


typedef struct _ReplicaLink_V1 {
    ULONG       cb;                     // total size of this structure
    ULONG       cConsecutiveFailures;   // * number of consecutive call failures along
                                        //    this link; used by the KCC to route around
                                        //    servers that are temporarily down
    DSTIME       timeLastSuccess;      // (Reps-From) time of last successful replication or
                                        //    (Reps-To) time at which Reps-To was added or updated
    DSTIME       timeLastAttempt;      // * time of last replication attempt
    ULONG       ulResultLastAttempt;    // * result of last replication attempt (DRSERR_*)
    ULONG       cbOtherDraOffset;       // offset (from struct *) of other-dra MTX_ADDR
    ULONG       cbOtherDra;             // size of other-dra MTX_ADDR
    ULONG       ulReplicaFlags;         // zero or more DRS_* flags
    REPLTIMES   rtSchedule;             // * periodic replication schedule
                                        //    (valid only if ulReplicaFlags & DRS_PER_SYNC)
    USN_VECTOR  usnvec;                 // * propagation state
    UUID        uuidDsaObj;             // objectGUID of other-dra's ntdsDSA object
    UUID        uuidInvocId;            // * invocation id of other-dra
    UUID        uuidTransportObj;       // * objectGUID of interSiteTransport object
                                        //      corresponding to the transport by which we
                                        //      communicate with the source DSA
    DWORD       dwReserved1;            // * Was used for a brief period. Available for re-use.
    ULONG       cbPASDataOffset;        // * offset from beginning of struct to PAS_DATA section
                                        // WARNING: if you extend this struct make sure it is always aligned at
                                        // ALIGN_DWORD boundaries. (since PASDataOfffset must align correctly).
    BYTE        rgb[];                  // storage for the rest of the structure
                                        // * indicates valid only on Reps-From
} REPLICA_LINK_V1;

typedef struct _ReplicaLink {
    DWORD       dwVersion;
    union
    {
        REPLICA_LINK_V1 V1;
    };
} REPLICA_LINK;

// return the address of other dra (as an MTX_ADDR *) embedded in a REPLICA_LINK
#define RL_POTHERDRA(prl)       ((MTX_ADDR *) ((prl)->V1.cbOtherDraOffset+ (BYTE *)(prl)))

// Validate macro for currently supported replica link version
#define VALIDATE_REPLICA_LINK_VERSION(prl) Assert(VERSION_V1 == (prl)->dwVersion);

// return address of PAS_DATA
#define RL_PPAS_DATA(prl)       ((PPAS_DATA) ((prl)->V1.cbPASDataOffset + (BYTE *)(prl)))

// PAS alignment
#define RL_ALIGN_PAS_DATA(prl) {                                            \
    if (!COUNT_IS_ALIGNED((prl)->V1.cbPASDataOffset, ALIGN_DWORD)) {        \
        DWORD offset = (prl)->V1.cbPASDataOffset;                           \
        (prl)->V1.cbPASDataOffset =                                         \
                ROUND_UP_COUNT((prl)->V1.cbPASDataOffset, ALIGN_DWORD);     \
        offset = (prl)->V1.cbPASDataOffset - offset;                        \
        Assert(offset < sizeof(DWORD));                                     \
        (prl)->V1.cb += offset;                                             \
        Assert(COUNT_IS_ALIGNED((prl)->V1.cbPASDataOffset, ALIGN_DWORD))    \
    }                                                                       \
}

// calculates REPLICA_LINK size
// size := struct_length + <dynamic_data> where,
// <dynamic_data> := OtherDra_length + optional{<alignment_offset> + PAS_data_length}
// where,
// <alignment_offset := cbPASDataOffset - (cbOtherDraOffset+cbOtherDra)
// Note: there's room to optimize this, but since it is only used in asserts
// we'll leave in this form. To optimize, get rid of the +/- of cbOtherDra.
#define RL_SIZE(prl)                                    \
            (sizeof(REPLICA_LINK) +                     \
             (prl)->V1.cbOtherDra +                     \
             ((prl)->V1.cbPASDataOffset ?               \
              ((prl)->V1.cbPASDataOffset -              \
               (prl)->V1.cbOtherDraOffset -             \
               (prl)->V1.cbOtherDra       +             \
               RL_PPAS_DATA(prl)->size) : 0) )

// validate PAS size
#define VALIDATE_REPLICA_LINK_SIZE(prl) Assert( (prl)->V1.cb == RL_SIZE(prl) )

//
// Used to compare guids
//

#define DsIsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

/*
 * These structures are used to cache information in the DNRead call
 * in the file dbsubj.c.  They need to be here so that the cache can
 * live on the THSTATE, since the cache is specific to a thread.
 */

// Struct holding info about a name part
typedef struct
{
   ULONG   PDNT;                        // parent's tag
   ATTRTYP rdnType;                     // Type of rdn (msDS-IntId)
   ULONG   cbRdn;                       // Count of bytes of RDN (remember RDNs
                                        // are unicode)
   WCHAR  *pRdn;                        // rdn (it's unicode)

} d_tagname;

typedef LONGLONG SDID;

// Full name info structure (used for dnread cache, etc.)
typedef struct _d_memname
{
    ULONG     DNT;                     // data file tag for this entry
    ULONG     NCDNT;                   // raw NCDNT data this entry
    d_tagname tag;                     // name part info
    GUID      Guid;                    // Guid of this object (may be null)
    NT4SID    Sid;                     // Sid of this object (may be null)
    ULONG     SidLen;                  // How much sid info exists
    BOOL      objflag;                 // 0 if record is a phantom
    DWORD     cAncestors;
    DWORD    *pAncestors;
    SDID      sdId;                    // sd id for this DNT
    DWORD     dwObjectClass;           // raw object class value
} d_memname;

typedef struct _LOCALDNREADCACHE_SLOT {
    d_memname*      pName;
    DWORD           hitCount;
} LOCALDNREADCACHESLOT;

#define LOCALDNREADCACHE_SLOT_NUM 8
typedef struct _LOCALDNREADCACHE_BUCKET {
    DWORD                       rgDNT[LOCALDNREADCACHE_SLOT_NUM];
    DWORD                       rgdwHashKey[LOCALDNREADCACHE_SLOT_NUM];
    LOCALDNREADCACHESLOT        slot[LOCALDNREADCACHE_SLOT_NUM];
} LOCALDNREADCACHEBUCKET;

#define LOCALDNREADCACHE_BUCKET_NUM 32
typedef struct _LOCALDNREADCACHE {
    DWORD                       nextSlot[LOCALDNREADCACHE_BUCKET_NUM];
    LOCALDNREADCACHEBUCKET      bucket[LOCALDNREADCACHE_BUCKET_NUM];
} LOCALDNREADCACHE;

// SD cache is implemented as a hash table with link-list chains.
// SD cache entry. 
typedef struct _SDCACHE_ENTRY {
    struct _SDCACHE_ENTRY *pNext; // ptr to the next SD in the chain
    SDID    sdID;   // id
    DWORD   cbSD;   // SD length
    BYTE    SD[1];  // the SD is stored starting from here 
} SDCACHE_ENTRY, *PSDCACHE_ENTRY;

typedef struct _GLOBALDNREADCACHESLOT{
    BOOL                  valid;
    d_memname             name;
    DWORD                 dwHashKey;
} GLOBALDNREADCACHESLOT;

typedef struct _GLOBALDNREADCACHE {
    DWORD refCount;
    DWORD count;
    GLOBALDNREADCACHESLOT *pData;
    DWORD sdHashTableSize;
    PSDCACHE_ENTRY *pSDHashTable;   // array of SDCACHE_ENTRY pointers
} GLOBALDNREADCACHE;

/* Values for the "mark" field in the previous structure */
#define DNREAD_NOMARK       0
#define DNREAD_MARK         1
#define DNREAD_COMMON       2

// Structs for cache of parents and their list children security state
#define VIEW_SECURITY_CACHE_SIZE 64
// valid states for the next structure.
#define LIST_CONTENTS_UNKNOWN    0
#define LIST_CONTENTS_ALLOWED    1
#define LIST_CONTENTS_DENIED     2
#define LIST_CONTENTS_AMBIGUOUS  3
typedef struct _VIEW_SECURITY_CACHE_ELEMENT {
    DWORD dnt;
    DWORD State;
} VIEW_SECURITY_CACHE_ELEMENT;

typedef struct _VIEW_SECURITY_CACHE {
    DWORD index;
    VIEW_SECURITY_CACHE_ELEMENT CacheVals[VIEW_SECURITY_CACHE_SIZE];
} VIEW_SECURITY_CACHE;



/*-------------------------------------------------------------------------*/
/* This structure holds the state information for a single thread.
This state information is valid during the course of a single transaction,
where a transaction is servicing one DSA call.
*/

typedef enum {

    ImpersonateNone = 0,
    ImpersonateRpcClient = 1,
    ImpersonateNullSession = 2,
    ImpersonateSspClient = 3,
    ImpersonateDelegatedClient = 4

} ImpersonationState;

///////////////////////////////////////////////////////////////////////
//                                                                   //
//                                                                   //
//  IndexType Definitions                                            //
//                                                                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define SAM_SEARCH_SID                          0
#define SAM_SEARCH_NC_ACCTYPE_NAME              1
#define SAM_SEARCH_NC_ACCTYPE_SID               2
#define SAM_SEARCH_PRIMARY_GROUP_ID             3

//
// Structure Which Holds search hints for SAM
//
typedef struct _SAMP_SEARCH_INFORMATION
{
    ULONG   IndexType;
    ULONG   HighLimitLength1;
    PVOID   HighLimit1;
    ULONG   HighLimitLength2;
    PVOID   HighLimit2;
    ULONG   LowLimitLength1;
    PVOID   LowLimit1;
    ULONG   LowLimitLength2;
    PVOID   LowLimit2;
    BOOLEAN bRootOfSearchIsNcHead;
} SAMP_SEARCH_INFORMATION;


typedef enum _DS_DB_OBJECT_TYPE {

    DsDbObjectSam = 1,
    DsDbObjectLsa
} DS_DB_OBJECT_TYPE, *PDS_DB_OBJECT_TYPE;


typedef struct _SAMP_AUDIT_NOTIFICATION
{
    struct _SAMP_AUDIT_NOTIFICATION *Next;
    ULONG                        iClass;
    DS_DB_OBJECT_TYPE            ObjectType;
    SECURITY_DB_DELTA_TYPE       DeltaType;
    PSID                         Sid;
    PUNICODE_STRING              AccountName;
    ULONG                        AccountControl;
    ULONG                        GroupType;
    PPRIVILEGE_SET               Privileges;
    ULONG                        AuditType;
    PVOID                        TypeSpecificInfo;  
} SAMP_AUDIT_NOTIFICATION;


//
// Structure which holds notification information For SAM
//
typedef struct _SAMP_NOTIFICATION_INFORMATION
{
    struct _SAMP_NOTIFICATION_INFORMATION * Next;
    ULONG                   iClass;
    DS_DB_OBJECT_TYPE       ObjectType;
    SECURITY_DB_DELTA_TYPE  DeltaType;
    NT4SID                  Sid;
    PUNICODE_STRING         AccountName;
    ULONG                   AccountControl;
    NT4SID                  UserSid;
    LUID                    UserAuthenticationId;
    DSNAME                 *Object;
    BOOL                    RoleTransfer;
    DOMAIN_SERVER_ROLE      NewRole;
    BOOL                    MixedModeChange;
    ULONG                   GroupType;
    BOOL                    UserAccountControlChange;
} SAMP_NOTIFICATION_INFORMATION;


typedef enum
{
    // Dir* depends on pTHS->SchemaUpdate being initialized to 
    // eNotSchemaOp by create_thread_state. create_thread_state
    // initializes pTHS->SchemaUpdate by effectively clearing
    // THSTATE. Specifically define eNotSchemaOp to 0 to highlight
    // the dependency.
    eNotSchemaOp = 0,

    // In most cases, eSchemaAttAdd and eSchemaAttUndefunct should be
    // treated the same. The one known exception is when undefuncting
    // an attribute with an auto-generated linkid (see AutoLinkId()).
    eSchemaAttAdd,  
    eSchemaAttMod,
    eSchemaAttDel,

    eSchemaClsAdd,
    eSchemaClsMod,
    eSchemaClsDel,

    // In most cases, eSchemaAttAdd and eSchemaAttUndefunct should be
    // treated the same. The one known exception is when undefuncting
    // an attribute with an auto-generated linkid (see AutoLinkId()).
    eSchemaAttUndefunct,

}SCENUM;

//
// A bunch of data structures used to track info that must be
// acted upon when committing to transaction level 0.
//
typedef struct _ESCROWITEM {
    DWORD   DNT;
    long    delta;
    long    ABRefdelta;
} ESCROWITEM;

typedef struct _ESCROWINFO {
    DWORD               cItems;     // elements in use in rItems
    DWORD               cItemsMax;  // max elements in rItems
    ESCROWITEM          *rItems;
} ESCROWINFO;

#define MODIFIED_OBJ_INFO_NUM_OBJS 6
//
// The following structure is used for tracking all DNTs and their PDNTs and
// NCDNTS  that are modified durring a transaction. This is used for a variety
// of things, including notifying waiting threads when these changes are
// committed, and invalidating objects in the gtcache.
//

#define MODIFIED_OBJ_modified       0
#define MODIFIED_OBJ_intrasite_move 1
#define MODIFIED_OBJ_intersite_move 2

typedef struct _MODIFIED_OBJ_FIELDS
{
    ULONG *pAncestors;
    ULONG cAncestors;
    ULONG ulNCDNT;
    BOOL  fNotifyWaiters;
    DWORD fChangeType;
} MODIFIED_OBJ_FIELDS;


typedef struct _MODIFIED_OBJ_INFO {
    DWORD cItems;
    MODIFIED_OBJ_FIELDS Objects[MODIFIED_OBJ_INFO_NUM_OBJS];
    struct _MODIFIED_OBJ_INFO *pNext;
} MODIFIED_OBJ_INFO;

typedef struct _HIERARCHYTABLEINFO {
    DWORD Count;
    DWORD *pABConts;
    int    adjustment;
    struct _HIERARCHYTABLEINFO *Next;
} HIERARCHYTABLEINFO, *PHIERARCHYTABLEINFO;

typedef struct _LOOPBACKTASKINFO
{
    struct _LOOPBACKTASKINFO *Next;
    PVOID                     TaskInfo;
} LOOPBACKTASKINFO, *PLOOPBACKTASKINFO;

#define OBJCACHE_ADD 1
#define OBJCACHE_DEL 2
typedef struct _OBJCACHE_DATA {
    DWORD           type;
    struct CROSS_REF_LIST *pCRL;
    MTX_ADDR       *pMTX;
    WCHAR          *pRootDNS;
    DSNAME         *pDN;
    struct _OBJCACHE_DATA *pNext;
} OBJCACHE_DATA;

/* This typedef describes a Linked-list of naming contexts;  A NC is the
   node name of a subtree root in this DSA.  Note that the NC must be the
   last element in the array because it is actually variable length and
   extends contiguously below its definition.
*/

typedef struct NAMING_CONTEXT_LIST {
   struct NAMING_CONTEXT_LIST *pNextNC;           /*Next Naming context*/
   NAMING_CONTEXT             *pNC;               /*Naming Context     */
   ATTRBLOCK                  *pNCBlock;          /*pre-parsed NC name */
   DWORD                       NCDNT;             /*NC DNT */
   BOOL                        fReplNotify;       /* must we notify others? */
   DWORD                       DelContDNT;        /*DNT of deleted ojbects   */
                                                  /*contaner (or INVALIDDNT) */
                                                  /* for this NC.            */
                                                  /* Not always maintained   */
   DWORD                       LostAndFoundDNT;   /*DNT of lost and found    */
                                                  /*contaner (or INVALIDDNT) */
                                                  /* for this NC.            */
                                                  /* Not always maintained   */

   ULONG                       ulEstimatedSize;  /* Estimated number of       */
                                                 /* entries in this NC        */
                                                 /* 0=not cestimated          */
   DWORD                       cbAncestors;      /* bytes in pAncestors     */
   DWORD                      *pAncestors;       /* DNTs of DSName's ancestors*/

   DSNAME                      *pNtdsQuotasDN;   /* DN of the NTDS Quotas object */
   ULONG                       ulDefaultQuota;   /* default quota for this NC */
   ULONG                       ulTombstonedQuotaWeight;
                                                 /* weight of tombstoned objects for
                                                    quota calculation purposes (expressed
                                                    as a percent from 0 to 100) */
} NAMING_CONTEXT_LIST;

typedef struct _CATALOG_UPDATES {
    NAMING_CONTEXT_LIST *pAddedEntries;     // ptr to the linked list of added entries
    NAMING_CONTEXT_LIST **pDeletedEntries;  // array of deleted entry pointers
                                            // (can not use linked list since they are still in the global list!)
    DWORD               dwDelCount;         // count of entries in the above array
    DWORD               dwDelLength;        // length of the currently allocated array
} CATALOG_UPDATES;

typedef struct _DSA_DEL_INFO {
    LPWSTR  pDnsDomainName;
    GUID    DomainGuid;
    GUID    DsaGuid;
    LPWSTR  pDnsHostName;
    struct _DSA_DEL_INFO *pNext;
} DSA_DEL_INFO;

typedef struct _OBJCACHINGINFO
{
    BOOL fRecalcMapiHierarchy:1;
    BOOL fSignalSCache:1;
    BOOL fNotifyNetLogon:1;
    BOOL fSignalGcPromotion:1;
    BOOL fUpdateScriptChanged:1;    // Was msDs-UpdateScript changed in this transaction?
    BOOL fEnableLVR:1;              // Do we need to enable LVR on commit?
    OBJCACHE_DATA *pData;
    CATALOG_UPDATES masterNCUpdates;
    CATALOG_UPDATES replicaNCUpdates;
    DSA_DEL_INFO *pDsaDelInfo;      // If a dsa object was deleted in this transaction, then we
                                    // need to notify net logon on commit.
} OBJCACHINGINFO;


// The data type to wrap up all these.
typedef struct _NESTED_TRANSACTIONAL_DATA {
    BOOL                preProcessed;
    struct _NESTED_TRANSACTIONAL_DATA *pOuter; // points to outer level transaction.
    ESCROWINFO          escrowInfo;
    MODIFIED_OBJ_INFO  *pModifiedObjects;
    HIERARCHYTABLEINFO *pHierarchyTableInfo;
    LOOPBACKTASKINFO   *pLoopbackTaskInfo;
    OBJCACHINGINFO      objCachingInfo;
} NESTED_TRANSACTIONAL_DATA;



typedef struct _SESSIONCACHE {
    JET_SESID       sesid;
    JET_DBID        dbid;
    JET_TABLEID     objtbl;
    JET_TABLEID     searchtbl;
    JET_TABLEID     linktbl;
    JET_TABLEID     sdproptbl;
    JET_TABLEID     sdtbl;
    BOOL            tablesInUse:1;
    BOOL            sessionInUse:1;
    ULONG           transLevel;     // see transactionlevel below
    ULONG           cTickTransLevel1Started;    // tick at which transaction
                                                // level 1 was started
    NESTED_TRANSACTIONAL_DATA *dataPtr;
} SESSIONCACHE;

#define MAX_PDB_COUNT 8           // Better not open more that 8 PDB's

typedef struct _MEMZONE {
    PUCHAR Base;                // ptr to base of mem zone
    PUCHAR Cur;                 // ptr to next block to be allocated
    BOOL   Full;                // TRUE if no free space remains in zone
} MEMZONE;

#define ZONEBLOCKSIZE 16
#define ZONETOTALSIZE (ZONEBLOCKSIZE*1024)


typedef struct _SESSION_KEY {
    ULONG  SessionKeyLength;
    PUCHAR SessionKey;
} SESSION_KEY;

typedef struct _SEARCH_LOGGING {
    DWORD SearchEntriesVisited;    // number of entries visited during a search operation
    DWORD SearchEntriesReturned;   // number of entries returned during a search operation
    PWCHAR pszFilter;              // the filter (processed) used for searching
    PCHAR pszIndexes;              // the indexes that the optimizer decided to use
} SEARCH_LOGGING;


typedef struct _LIST_OF_ERRORS {
    DWORD dsid;
    DWORD dwErr;
    DWORD data;
    WCHAR *pMessage;
    struct _LIST_OF_ERRORS *pPrevError;
} LIST_OF_ERRORS;


// cached effective quota
//
typedef struct _EFFECTIVE_QUOTA {
    DWORD                       ncdnt;
    ULONG                       ulEffectiveQuota;
    struct _EFFECTIVE_QUOTA *   pEffectiveQuotaNext;
} *PEFFECTIVE_QUOTA, EFFECTIVE_QUOTA;

typedef struct _AUTHZ_CLIENT_CONTEXT_INFO {
    AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzContext;      // authz context
    EFFECTIVE_QUOTA *               pEffectiveQuota;    // list of effective quotas for this client context
} *PAUTHZ_CLIENT_CONTEXT_INFO, AUTHZ_CLIENT_CONTEXT_INFO;
	

// CLIENT_CONTEXT struct.
//  ClientContext struct contains a hAuthzContext handle
//  The authz  context is created from the client token. The handle is created on-demand
//
//  The struct can be shared between an LDAP connection object and a thread.
//  Therefore, it is refcounted. NEVER assign a pointer to the struct directly,
//  use AssignClientContext function istead. To destroy context, assign NULL
//  to the variable that contains a reference.
//  NEVER use handle directly, instead, use access function: it ensures that
//  the handle is created (this is done on-demand).
//
//  The CLIENT_CONTEXTs stored in LDAP connections can
//  be reused by threads spawned by the same LDAP connection. Note that an LDAP
//  connection can change a context due to a BIND operation. If there are running
//  threads that were spawned previously by the same LDAP thread (such as a long
//  running search op), they will still use the original CLIENT_CONTEXT which will
//  be released automatically when they finish the job.
//

typedef struct _AUTHZ_CLIENT_CONTEXT {
    PAUTHZ_CLIENT_CONTEXT_INFO  pAuthzContextInfo;
    LONG                        lRefCount;          // ref count
} *PAUTHZ_CLIENT_CONTEXT, AUTHZ_CLIENT_CONTEXT;


// TRANSACTIONS AND THREAD STATE.
//  Jet Transactions are on a per Jet Session basis. We always have one Jet
//  session per thread state. A DBOpen will obtain a new set of Jet cursors and
//  optionally begin a Jet Transaction. However note that Jet transaction
//  levels are cumulative on the Jet session. It is for this reason that we
//  must maintain state regarding transaction levels in the thread state.
//  Similarly any logic that requires state and needs to come in to play
//  conditionally on a transaction commit to level 0 needs to maintain its
//  state in the thread state.  Exceptions are CheckNameForRename and
//  CheckNameForAdd. They begin transactions on a fresh jet session after
//  resetting parameters in the thread state. Since they care to perform a
//  careful cleanup, the transaction in the thread state is not altered
//  after they have finished executing.  This has been made slightly easier by
//  associating transaction level and escrow information with a session cache
//  entry.

#define INVALID_TS_INDEX ((DWORD) -1)

typedef struct _THSTATE {

    HANDLE      hHeap;          // handle to per-thread heap
    MEMZONE     Zone;           // small block heap cache
    DWORD       dwClientID;     // Unique ID used by heads to identify specific
                                // connections. Set to 0 if no specific identity
                                // is required.
    ULONG       errCode;        // Identifies a Directory error
    DIRERR      *pErrInfo;      // full error information

    struct DBPOS *pDB;          // Holds a DB handle (NULL if not used)
    SESSIONCACHE JetCache;      // Jet handles of various sorts
#define transactionlevel JetCache.transLevel
    VIEW_SECURITY_CACHE * ViewSecurityCache;
    HANDLE      hThread;        // thread handle - see create_thread_state

    //BITFIELD BLOCK.  Please add all new booleans and bitfields here

    unsigned    transType:2;    // Indicates if this transaction is a
                                // reader, a writer or a writer that
                                // allows reads.  Set by Sync calls
                                // at the start of each transaction.
    unsigned    transControl:2; // one of DirTransactionControl values
    BOOL        fSyncSet:1;     // A sync point is active (the usual case)
    BOOL        fCatalogCacheTouched:1; //Indicates that the catalog information has been updated
    BOOL        fRebuildCatalogOnCommit:1; // need to rebuild the NC catalog on commit. Can be triggered by Quota updates.
    BOOL        fSDP:1;         // TRUE if this is a SD propagator thread.
    BOOL        fDRA:1;         // TRUE if this is a replicator thread.
    BOOL        fEOF:1;         // End Of File flag (used by Nspi)
    BOOL        fLazyCommit:1;  // should we commit lazily?
    BOOL        fDSA:1;         // TRUE if the thread is acting on behalf of
                                // the DSA itself (e.g. during startup), FALSE
                                // if the thread is acting on behalf of an RPC
                                // client.
    BOOL        fSAM:1;         // TRUE if this thread is from SAM.
    BOOL        fSamDoCommit:1; // TRUE if SAM commit should commit DS too.
    BOOL        fSamWriteLockHeld:1; // TRUE if the DS has acquired the SAM
                                // write lock
    BOOL        UpdateDITStructure:1; // TRUE if Schema Recalculation also
                                // results in a DIT update
    BOOL        RecalcSchemaNow:1;    // TRUE if we want the schema update
                                // immediately.
    BOOL        fLsa:1;         // Call was originated by the Lsa
    BOOL        fAccessChecksCompleted:1;// Set By Loopback to indicate that
                                // access checks have completed and the
                                // core DS need not bother doing access
                                // checks
    BOOL        fGCLocalCleanup:1;  // Set if the thread is performing local
                                    // cleanup on a GC to purge attributes
                                    // removed from the partial attribute set
    BOOL        fDidInvalidate:1;   // Set if any attempt to invalidate an
                                    // object in the dnread cache (local or
                                    // global) was made.
    BOOL        fBeginDontEndHoldsSamLock:1;    // See SET_SAM_LOCK_TRACKING
                                                // in dsatools.c

    BOOL        fCrossDomainMove:1; // Enable exceptions for X-dom move.

    BOOL        fNlSubnetNotify:1; // Tell NetLogon about subnet change
    BOOL        fNlSiteObjNotify:1;// Tell NetLogon about site object change
    BOOL        fNlSiteNotify:1;   // Tell NetLogon that we changed sites
    BOOL        fDefaultLcid:1;    // Is the LCID in the dwLcid field default?
    BOOL        fPhantomDaemon:1;  // TRUE if this is the phantom daemon.
    BOOL        fAnchorInvalidated:1; // TRUE if a change in the open transaction
                                   // has invalidated a portion of the anchor
    BOOL        fSchemaConflict:1; // Used by DRA to indicate that a conflict
                                   // is detected while replicating in the
                                   // schema NC, so all later updates in the
                                   // in the packet should not be committed
                                   // (but still process to find any further
                                   // conflicts)
    BOOL        fExecuteKccOnCommit:1; // TRUE if kcc run should be triggered
                                   // on successful commit of 0th trans
    BOOL        fLinkedValueReplication:1; // TRUE if this feature is enabled
                                  // This feature requires forest-wide upgrade
                        // FALSE in W2K, and may be enabled in W2K+1 or greater
    BOOL        fNlDnsRootAliasNotify:1; // Notify NetLogon the DnsRootAlias is changed
    BOOL        fSingleUserModeThread:1; // TRUE if this is the thread for the
                                       // single user mode dealing with
                                       // high risk stuff
    BOOL        fDeletingTree:1;    // TRUE if a tree is being deleted. No permission checks
                                    // are done, just audits for deleting objects.
    BOOL        fBehaviorVersionUpdate:1; //invoke behaviorversionUpdate thread
                                          //after the transaction 
    BOOL        fIsValidLongRunningTask:1; // This tells the DS that this is a long
                                           // running thread, that should be immune
                                           // to the assert on long running threads.
    BOOL        fDRAAuditEnabled:1; // Is replication security auditing enabled?
    BOOL        fDRAAuditEnabledForAttr:1; // Is replication security auditing enabled down to the attr/value level?
    // end OF BITFIELD BLOCK

    SAMP_NOTIFICATION_INFORMATION
                * pSamNotificationTail;
    SAMP_NOTIFICATION_INFORMATION
                * pSamNotificationHead; // Holds Information for Notification
                                        // for downlevel replication. Changes are
                                        // added to the tail of the list. While notifications
                                        // are issued from the Head. Maintaining 2 pointers provides
                                        // quick access while preserving the order of notifications.
    SAMP_AUDIT_NOTIFICATION
                *pSamAuditNotificationHead;
    SAMP_AUDIT_NOTIFICATION
                *pSamAuditNotificationTail; // Ordered list of audits
    
    USN         UnCommUsn;      // Lowest uncommited usn
    HANDLE      hHeapOrg;       // for use by TH_mark and TH_free_to_mark
    MEMZONE     ZoneOrg;        // for use by TH_mark and TH_free_to_mark
    struct _THSTATE *   pSpareTHS; // for use by TH_mark and TH_free_to_mark
    ULONG       cAllocs;        // count of outstanding allocs from the heap
    ULONG       cAllocsOrg;     // for use by TH_mark and TH_free_to_mark
    LCID        dwLcid;         // Locale to use for Unicode compares.  Null
                                // means to use a default sort
    VOID        *pSamLoopback;  // SAM loopback argument block.
    SAMP_SEARCH_INFORMATION
                *pSamSearchInformation; // SAM search information block
    BOOL        NTDSErrorFlag;  // Output Error Info on Dir Call Failures.

    VOID        *phSecurityContext; // When non-null gives SSP context
    ImpersonationState impState;// Client type we're currently impersonating
    FILETIME    TimeCreated;    // When this THSTATE was created
    ULONG       ulTickCreated;  // TickCount when this THSTATE was created
    struct _schemaptr *CurrSchemaPtr;  // SchemaPtr
    SCENUM      SchemaUpdate;   // It is a Schema Update (set to eNotSchemaOp
                                // by RecycleHeap and GrabHeap
    PVOID       NewPrefix;         // Pointer to any new prefix added that is still not in the global prefix table
    ULONG       cNewPrefix;        // No. of new prefixes added by this thread
    PVOID       pClassPtr;      // To keep a pointer to the pre-updated copy of a
                                // class-schema object during class-modify so that
                                // a comparison can be done later with the updated version
    PVOID       pCachedSDInfo;   // To cache last default SD converted to allow
                                // caching during default SD conversions during schema cache load
    VOID        *GCVerifyCache; // cache of names successfully verified
                                // against the GC.

    DRS_EXTENSIONS *pextRemote; // DRS interface extensions supported by the
                                // current client (set only if DRA thread)

    ULONG       opendbcount;     // open dbpos count for this thread

    PVOID       pNotifyNCs;     // List of NCDNTs to notify on commit (see dbtools.c\DbTransOut)

    DWORD       CallerType;     // Used for directory usage statistics

    DWORD       CipherStrength; // strength of cipher encoding in bits
                                // 0 if not secure link

    DWORD       spaceHolder;    // TO BE REUSED / REMOVED

    GLOBALDNREADCACHE *Global_DNReadCache;   // The LocalDNReadCache.
    DWORD        cGlobalCacheHits;
    DWORD        *pGlobalCacheHits; // Track hot objects in the Global Cache.
    DSTIME       DNReadOriginSequence;
                                // When was the LocalDNReadCache last reset?
                                // This tracks the invalidate sequence number
                                // used by the global dnread cache.
    LOCALDNREADCACHE  LocalDNReadCache;

    PVOID       TraceHeader;    // WMI trace header
    DWORD       ClientIP;       // IP address of LDAP client

    PLOOPBACKTASKINFO
                SamTaskList;    // List of to do items for SAM once when
                                // a transaction commits

    // Items for delegated impersonation.
    VOID          *pCtxtHandle;     // Original client ctxt when impersonating.
    // End items for delegated impersonation.
    DWORD       ClientContext;  // Context that uniquely identifies a client. Used by WMI to
                                // track client activity

    DWORD       dsidOrigin;     // DSID of InitTHSTATE which made this THSTATE

    SESSION_KEY SessionKey;     // For a replicator thread, this is the
                                // the session key established between
                                // this DC and the remote DC.

    PAUTHZ_CLIENT_CONTEXT       pAuthzCC;               // AUTHZ_CLIENT_CONTEXT ptr (initially NULL)
    AUTHZ_AUDIT_EVENT_HANDLE     hAuthzAuditInfo;        // audit info handle (created on demand)

    SEARCH_LOGGING searchLogging; // performance logging for search operations

    UUID        InvocationID;   // Invocation ID at the time our thread/
                                // transaction was created
    PVOID       pExtSchemaPtr;  // extended SchemaPtr

    LIST_OF_ERRORS *pErrList;   // used to keep track of erros in the script processing
    
#if DBG
    ULONG       Size;           // The running total of memory allocated
    ULONG       SizeOrg;        // for use by TH_mark and TH_free_to_mark
    ULONG       Totaldbpos;     // Total number of dbpos's opened so far. Statistic for
                                // performance tracking
    struct DBPOS *pDBList[MAX_PDB_COUNT]; // Array of all the DBPOS's that are currently
                                          // opened on this thread state. This is used
                                          // to keep track of all opened DBPoses by this
                                          // thread and can be used to verify DBPoses in
                                          // the debugger.
    PVOID       pRpcSecurityContext; // Pointer to the security context
                                     // that we actually recieved in a callback
                                     // from RPC . This is useful in tracking
                                     // any password encryption problems when
                                     // replicating
    PVOID       pRpcCallHandle;  // Pointer to the actual RPC call handle that
                                 // was actually recieved in a callback from
                                 // RPC. This is useful in tracking any password
                                 // encryption system problems when replicating
#endif

#ifdef USE_THALLOC_TRACE
    HANDLE      hDebugMemHeap;     // Heap used for debugging purposes
    HANDLE      hDebugMemHeapOrg;  // Heap used for debugging purposes
    PVOID       pDebugHeapLog;
#endif

}THSTATE;


// This macro checks to make sure a THSTATE seems valid.  We check to see
// that it has a non-null address, that it has a non-null heap, that
// the THSTATE seems to have been allocated from its heap, and that
// (since THSTATEs are supposed to be short lived) the THSTATE was
// initialized within the last hour.  In real life I'd expect a THSTATE to
// be recycled within seconds, but under a debugger I can imagine slow step
// throughs taking quite a while.  Since the goal of this clause is to
// catch internal callers who create a THSTATE at IPL time and then
// (incorrectly) never free it, we have the limit set to be long enough
// to not falsely trigger under a slow debug session, but short enough
// to get caught during normal test passes.

extern BOOL IsValidTHSTATE(THSTATE *, ULONG);

#define VALID_THSTATE(pTHS)                     \
    IsValidTHSTATE(                             \
        pTHS,                                   \
        GetTickCount()                          \
        )


// Verify if the caller is a member of one of the groups 
// passed in. If the security context is unavailable, then
// it will be obtained by impersonating the client.
DWORD
CheckGroupMembershipAnyClient(
    IN THSTATE* pTHS,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PSID *pGroupSids,
    IN DWORD cGroupSids,
    OUT BOOL *bResult
    );

// assign a client context ptr to a variable
// IMPORTANT: NEVER copy pointers to CLIENT_CONTEXT directly, always
// use this function. This ensures that they are properly refcounted.
VOID AssignAuthzClientContext(
    IN PAUTHZ_CLIENT_CONTEXT *var,
    IN PAUTHZ_CLIENT_CONTEXT value
    );

// get AuthzContext from thread state. If the context has not yet been allocated
// then the client will get impersonated, token grabbed and Authz context created.
// Then the client is unimpersonated again.
DWORD
GetAuthzContextInfo(
    IN THSTATE *pTHS,
    OUT AUTHZ_CLIENT_CONTEXT_INFO **ppAuthzContextInfo
    );

__inline DWORD
GetAuthzContextHandle(
    IN THSTATE *pTHS,
    OUT AUTHZ_CLIENT_CONTEXT_HANDLE *phAuthzContext
    )
{
    AUTHZ_CLIENT_CONTEXT_INFO   *pAuthzContextInfo  = NULL;
    const DWORD                 dwError             = GetAuthzContextInfo( pTHS, &pAuthzContextInfo );

    *phAuthzContext = ( 0 == dwError ? pAuthzContextInfo->hAuthzContext : NULL );

    return dwError;
}

typedef struct _RESOBJ {
    DSNAME       *pObj;
    DWORD        InstanceType;
    ATTRTYP      MostSpecificObjClass;
    DWORD        DNT;
    DWORD        PDNT;
    DWORD        NCDNT;
    BOOL         IsDeleted;
} RESOBJ;

// Macros to answer queries on a RESOBJ without exposing internal details
#define RESOBJ_IS_PHANTOM( pro ) \
( ((pro)->InstanceType == IT_UNINSTANT) && ((pro)->DNT != INVALIDDNT) )
#define RESOBJ_IS_PURE_SUBREF( pro ) \
( ((pro)->InstanceType == SUBREF) && ((pro)->DNT != INVALIDDNT) )
#define RESOBJ_IS_NOT_FOUND( pro ) ((pro)->DNT == INVALIDDNT)


// This is some types to support creating an NC head in an add operation.
typedef struct _CREATENCINFO {
    INT               iKind;   // This is whether it is a Config, Schema,
                               //     Domain, or Non-Domain NC from the
                               //     constants below this struct.
    BOOL              fNcAbove:1; // This flag indicates that the parent
                                  //     object is a local NC.
    BOOL              fTestAdd:1; // This flag is used to indicate we're
                                  //     testing an add, to see if we
                                  //     should add a cross-ref.
    BOOL              fNullNcGuid:1; // This tells us whether the GUID
                                     // of the NC was on the cross-ref,
                                     // if not, we need to create an
                                     // infrastructure update object.
    BOOL              fSetRefDom:1;  // Set if we need to set the reference
                                     // domain on the cross-ref, typically
                                     // the case, as usually the ref dom
                                     // isn't preset.
    CROSS_REF *       pCR;           // This is the crossRef cache's cross-ref
                                     // object, so we don't have to find it 
                                     // later.
    CROSS_REF *       pSDRefDomCR; // This is a pointer to the crossRef of
                                   // of the reference domain for SDs in
                                   // the NDNC being created.
} CREATENCINFO;

#define   CREATE_DOMAIN_NC            0x00000001
#define   CREATE_SCHEMA_NC            0x00000002
#define   CREATE_CONFIGURATION_NC     0x00000004
#define   CREATE_NONDOMAIN_NC         0x00000008

#define   CREATE_NC_TYPES             (CREATE_DOMAIN_NC | CREATE_SCHEMA_NC | CREATE_CONFIGURATION_NC | CREATE_NONDOMAIN_NC)

#define   CHECK_ONE_BIT_SET(dwFlags)     ( (dwFlags) && (((dwFlags) & ((dwFlags) - 1)) == 0) ) )
#define VALID_CREATENCINFO(x)         ( (x) && (CHECK_ONE_BIT_SET( (((x)->iKind)&(CREATE_NC_TYPES)) ) )

typedef struct _ADDCROSSREFINFO {
    DSNAME *          pdnNcName;       // This is the name of the nCName attr of
                                       // the crossRef that we're trying to add.
    BOOL              bEnabled;        // This is the enabled attr of the crossRef
                                       // we're trying to add.
    ULONG             ulSysFlags;      // This is the systemFlags attr of the
                                       // crossRef that we're trying to add.
    ULONG             ulDsCrackChild;  // Result of the DsCrackNames() for the
                                       // modulated canonical name of the child
                                       // check.
    ULONG             ulChildCheck;    // Independant name specific result of the
                                       // child check we usually expect an error
                                       // for this.
    WCHAR *           wszChildCheck;   // The DN we retrieved for the child check,
                                       // typically this will be a NULL.
    ULONG             ulDsCrackParent; // Result of the DsCrackNames() for the
                                       // Parent DN, we expect this to be 0.
    ULONG             ulParentCheck;   // This is the independant name specific
                                       // error for the DN parent check.  We expect
                                       // this to be 0.
    GUID              ParentGuid;      // This is the GUID retrived for the parent
                                       // DN, we expect this to be !fNullUuid()
} ADDCROSSREFINFO;

VOID
SetCommArgDefaults(
    IN DWORD MaxTempTableSize
    );

// returns info about the RDN in a DSNAME
unsigned GetRDNInfo(THSTATE *pTHS,
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype);

extern DWORD     NTDSErrorFlag;

//
// Valid definitions for NTDSErrorFlag
//

#define NTDSERRFLAG_DISPLAY_ERRORS           0x00000001
#define NTDSERRFLAG_DUMP_TOKEN               0x00000002

//
// Add More Flag Definitions in here.
//

#define NTDSERRFLAG_DISPLAY_ERRORS_AND_BREAK 0x80000000

//
// Macro for testing ntdserror flag
//

#define TEST_ERROR_FLAG(_Value) \
            ((NTDSErrorFlag|pTHStls->NTDSErrorFlag) & _Value)

extern BOOL gUpdatesEnabled;
extern DWORD dwTSindex;
extern BOOL gfRunningInsideLsa;
extern volatile BOOL fAssertLoop;
extern volatile ULONG ulcActiveReplicationThreads;
extern BOOL gfUserPasswordSupport;

typedef enum {
    eRunning = 0,
    eRemovingClients = 1,
    eSecuringDatabase = 2,
    eFreeingResources = 3,
    eStopped = 4
} SHUTDOWN;
extern volatile SHUTDOWN eServiceShutdown;


#define LOCALE_SENSITIVE_COMPARE_FLAGS  (NORM_IGNORECASE     |   \
                                         NORM_IGNOREKANATYPE |   \
                                         NORM_IGNORENONSPACE |   \
                                         NORM_IGNOREWIDTH    |   \
                                         NORM_IGNORESYMBOLS  |   \
                                         SORT_STRINGSORT)

/* Floating Single Master Operation (FSMO) functions and defines */

/* Extended operations and FSMO functions */
ULONG ReqFSMOOp(THSTATE *        pTHS,
                DSNAME  *        pFSMO,
                ULONG            RepFlags,
                ULONG            ulOp,
                ULARGE_INTEGER * pllFsmoInfo,
                ULONG   *        pulRet);

ULONG
ReqExtendedOpAux(THSTATE *        pTHS,
                 DSNAME  *        pFSMO,
                 DSNAME  *        pNC,
                 DSNAME  *        pTarget,
                 ULONG            RepFlags,
                 ULONG            ulOp,
                 ULARGE_INTEGER * pliInfo,
                 ULONG   *        pulRet);

ULONG
ReqFsmoGiveaway(THSTATE *pTHS,
                DSNAME  *pFSMO,
                DSNAME  *pTarget,
                ULONG   *pExtendedRet);

/* Extended Replication Operations */
#define EXOP_FSMO_REQ_ROLE       1   /* Request Role-Owner transfer */
#define EXOP_FSMO_REQ_RID_ALLOC  2   /* Request RID allocation */
#define EXOP_FSMO_RID_REQ_ROLE   3   /* Request RID Role-Owner transfer */
#define EXOP_FSMO_REQ_PDC        4   /* Request PDC Role-Owner transfer */
#define EXOP_FSMO_ABANDON_ROLE   5   /* Tells Callee to call back and request */
                                     /* a role transfer for this role */
#define EXOP_REPL_OBJ            6   /* Replicate a single object */
// NOTE: If you add more codes to this list, please also update the debugger
// extensions translation code in dsexts\dra.c.

/* Extended Replication Operation Errors */
/* 0 deliberately left unused to distinguish Extended and non-Extended replies */
#define EXOP_ERR_SUCCESS        1
#define EXOP_ERR_UNKNOWN_OP     2   /* unrecognized request */
#define EXOP_ERR_FSMO_NOT_OWNER 3   /* callee was not role-owner */
#define EXOP_ERR_UPDATE_ERR     4   /* could not modify objects to be returned */
#define EXOP_ERR_EXCEPTION      5   /* callee blew up */
#define EXOP_ERR_UNKNOWN_CALLER 6   /* caller's object not present on owner */
#define EXOP_ERR_RID_ALLOC      7   /* unable to alloc RID pool to a DSA */
#define EXOP_ERR_FSMO_OWNER_DELETED  8   /* owning DSA object is deleted */
#define EXOP_ERR_FSMO_PENDING_OP     9   /* operation in progress on owning DSA */
#define EXOP_ERR_MISMATCH      10   /* caller/callee have different notion of
                                       the object */

#define EXOP_ERR_COULDNT_CONTACT 11 /* can't reach requested server via rpc */
#define EXOP_ERR_FSMO_REFUSING_ROLES  12 /* currently giving away fsmo's */
#define EXOP_ERR_DIR_ERROR       13 /* DbFindDSName failed */
#define EXOP_ERR_FSMO_MISSING_SETTINGS 14 /* Can't find ATT_FSMO_ROLE_OWNER */
#define EXOP_ERR_ACCESS_DENIED   15 /* control access is not granted */
#define EXOP_ERR_PARAM_ERR       16 /* bad param to extende operation */

// NOTE: If you add more codes to this list, please also update the debugger
// extensions translation code in dsexts\dra.c.

#endif  /* _mdglobal_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\heurist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       heurist.h
//
//--------------------------------------------------------------------------

/*
 * This file contains the global flags controlled by the 
 * DSA heuristics key.
 */
/* heuristic[0]
 * Flag to ask the DS to allow write caching on disks where
 * we have our dits and log files.
 */
#define AllowWriteCaching               0
extern DWORD gulAllowWriteCaching;
 
/* heuristic[1]
 * Flag which instructs SD propagator to perform additional
 * sanity checks on all SDs it is propagating.
 */
#define ValidateSDHeuristic                 1
extern ULONG gulValidateSDs;

/* heuristic[2]
 * This is to tell the ldap head not to enforce these policies: maxsearches,
 * max connections, and ip deny lists.  This is to enable admins to fixup
 * the policy stuff in case they shoots themselves on the foot, i.e., set
 * maxconn to zero, setting 0 ip 0 mask, maxqueries to zero. 
 */

#define BypassLimitsChecks                   2

/* heuristic[3]
 * Formerly. Whether or not to do exact match on 
 * Mail-Nickname first for ANR.  Currently unused
 */


/* heuristic[4]
 * Whether or not to do compression of 
 * intersite replication mail. 
 * Since compression can now be disabled on a per-site link basis,
 * this heuristic is obsolete.
 */
#define DoMailCompressionHeuristic		4

/* heuristic[5]
 * If set, suppresses many useful but not vital background activities.
 * Used for repeatable performance measurements.
 */
#define SuppressBackgroundTasksHeuristic    5

/* heuristic[6]
 * If set, allows schema cache load to ignore default SD conversion failures
 * so that the system can go ahead and boot at least. Any bad default SDs
 * can then be corrected
 */
#define IgnoreBadDefaultSD  6
extern ULONG gulIgnoreBadDefaultSD;

/* heurusitic[7]
 * If set, forces sequential instead of circular logging in Jet
 */
#define SuppressCircularLogging 7
extern ULONG gulCircularLogging;

/* heuristic[8]
 * If set, the LDAP head will return an error on searches through the GC when 
 * an attempt is made to either filter on a non-GC att, or the list of Atts to
 * return contains a non-GC att.
 */
#define ReturnErrOnGCSearchesWithNonGCAtts 8
extern ULONG gulGCAttErrorsEnabled;

/* heuristic[9]
 * If set, the online defrag will be detached from the garbage collection
 * task.  */
#define DecoupleDefragFromGarbageCollection 9
extern ULONG gulDecoupleDefragFromGarbageCollection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\msdstag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1986 - 1999
//
//  File:       msdstag.h
//
//--------------------------------------------------------------------------

/*
** ---------------------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)
#define PR_EMS_AB_ALL_CHILDREN                PROP_TAG(PT_OBJECT,       0xFFF7)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF7

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

// pre-defined, but not in the schema
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING     , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8     , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE     , 0x39FF)

#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_OBJECT      , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8     , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE     , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT      , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING     , 0x803C)

#include <MSDSMapi.h>

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\mdschema.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       mdschema.h
//
//--------------------------------------------------------------------------



/*++
 File:    MDS.H
 Purpose: Contains the OID Definition for DS Pkg.
 Creator: Automatically Generated on
 Date:    Wed Jun 26 10:50:15 2002

 ** This is a Generated File From Schema.INI **
 ** DO NOT MODIFY  DIRECTLY  **
 ** DO NOT INCLUDE DIRECTLY  **

--*/
//
//Attribute Definitions
//
#define OMP_O_DX_A_ACCOUNT_EXPIRES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1F"
#define OMP_O_DX_A_ACCOUNT_NAME_HISTORY                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1B"
#define OMP_O_DX_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x78"
#define OMP_O_DX_A_ACS_ALLOCABLE_RSVP_BANDWIDTH             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7E"
#define OMP_O_DX_A_ACS_CACHE_TIMEOUT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0B"
#define OMP_O_DX_A_ACS_DIRECTION                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x75"
#define OMP_O_DX_A_ACS_DSBM_DEADTIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0A"
#define OMP_O_DX_A_ACS_DSBM_PRIORITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x08"
#define OMP_O_DX_A_ACS_DSBM_REFRESH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x09"
#define OMP_O_DX_A_ACS_ENABLE_ACS_SERVICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x02"
#define OMP_O_DX_A_ACS_ENABLE_RSVP_ACCOUNTING               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x03"
#define OMP_O_DX_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x00"
#define OMP_O_DX_A_ACS_EVENT_LOG_LEVEL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x01"
#define OMP_O_DX_A_ACS_IDENTITY_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x10"
#define OMP_O_DX_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x01"
#define OMP_O_DX_A_ACS_MAX_DURATION_PER_FLOW                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x79"
#define OMP_O_DX_A_ACS_MAX_NO_OF_ACCOUNT_FILES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x05"
#define OMP_O_DX_A_ACS_MAX_NO_OF_LOG_FILES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x06"
#define OMP_O_DX_A_ACS_MAX_PEAK_BANDWIDTH                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7F"
#define OMP_O_DX_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x77"
#define OMP_O_DX_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x06"
#define OMP_O_DX_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x07"
#define OMP_O_DX_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x21"
#define OMP_O_DX_A_ACS_MAX_TOKEN_RATE_PER_FLOW              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x76"
#define OMP_O_DX_A_ACS_MAXIMUM_SDU_SIZE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x22"
#define OMP_O_DX_A_ACS_MINIMUM_DELAY_VARIATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x25"
#define OMP_O_DX_A_ACS_MINIMUM_LATENCY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x24"
#define OMP_O_DX_A_ACS_MINIMUM_POLICED_SIZE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x23"
#define OMP_O_DX_A_ACS_NON_RESERVED_MAX_SDU_SIZE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x28"
#define OMP_O_DX_A_ACS_NON_RESERVED_MIN_POLICED_SIZE        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x29"
#define OMP_O_DX_A_ACS_NON_RESERVED_PEAK_RATE               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x26"
#define OMP_O_DX_A_ACS_NON_RESERVED_TOKEN_SIZE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x27"
#define OMP_O_DX_A_ACS_NON_RESERVED_TX_LIMIT                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0C"
#define OMP_O_DX_A_ACS_NON_RESERVED_TX_SIZE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x02"
#define OMP_O_DX_A_ACS_PERMISSION_BITS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7D"
#define OMP_O_DX_A_ACS_POLICY_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x04"
#define OMP_O_DX_A_ACS_PRIORITY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7C"
#define OMP_O_DX_A_ACS_RSVP_ACCOUNT_FILES_LOCATION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x04"
#define OMP_O_DX_A_ACS_RSVP_LOG_FILES_LOCATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x05"
#define OMP_O_DX_A_ACS_SERVICE_TYPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7A"
#define OMP_O_DX_A_ACS_TIME_OF_DAY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x74"
#define OMP_O_DX_A_ACS_TOTAL_NO_OF_FLOWS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7B"
#define OMP_O_DX_A_ACS_SERVER_LIST                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x20"
#define OMP_O_DX_A_ADDITIONAL_INFORMATION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x09"
#define OMP_O_DX_A_ADDITIONAL_TRUSTED_SERVICE_NAMES         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x79"
#define OMP_O_DX_A_ADDRESS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x00"
#define OMP_O_DX_A_ADDRESS_BOOK_ROOTS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5C"
#define OMP_O_DX_A_ADDRESS_ENTRY_DISPLAY_TABLE              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x44"
#define OMP_O_DX_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x10"
#define OMP_O_DX_A_ADDRESS_HOME                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x69"
#define OMP_O_DX_A_ADDRESS_SYNTAX                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x7F"
#define OMP_O_DX_A_ADDRESS_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x5E"
#define OMP_O_DX_A_ADMIN_CONTEXT_MENU                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x66"
#define OMP_O_DX_A_ADMIN_COUNT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x16"
#define OMP_O_DX_A_ADMIN_DESCRIPTION                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x62"
#define OMP_O_DX_A_ADMIN_DISPLAY_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x42"
#define OMP_O_DX_A_ADMIN_MULTISELECT_PROPERTY_PAGES         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1A"
#define OMP_O_DX_A_ADMIN_PROPERTY_PAGES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x32"
#define OMP_O_DX_A_ALLOWED_ATTRIBUTES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x11"
#define OMP_O_DX_A_ALLOWED_ATTRIBUTES_EFFECTIVE             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x12"
#define OMP_O_DX_A_ALLOWED_CHILD_CLASSES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0F"
#define OMP_O_DX_A_ALLOWED_CHILD_CLASSES_EFFECTIVE          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x10"
#define OMP_O_DX_A_ALT_SECURITY_IDENTITIES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x63"
#define OMP_O_DX_A_ANR                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x38"
#define OMP_O_DX_A_APP_SCHEMA_VERSION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x50"
#define OMP_O_DX_A_APPLICATION_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5A"
#define OMP_O_DX_A_APPLIES_TO                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x55"
#define OMP_O_DX_A_ASSET_NUMBER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1B"
#define OMP_O_DX_A_ASSISTANT                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0C"
#define OMP_O_DX_A_ASSOC_NT_ACCOUNT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x3D"
#define OMP_O_L0_A_ASSOCIATEDDOMAIN                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x25"
#define OMP_O_L0_A_ASSOCIATEDNAME                           "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x26"
#define OMP_O_DX_A_ATTRIBUTE_DISPLAY_NAMES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6C"
#define OMP_O_DX_A_ATTRIBUTE_ID                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x1E"
#define OMP_O_DX_A_ATTRIBUTE_SECURITY_GUID                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x15"
#define OMP_O_DX_A_ATTRIBUTE_SYNTAX                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x20"
#define OMP_O_L0_A_AUDIO                                    "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x37"
#define OMP_O_DX_A_AUDITING_POLICY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4A"
#define OMP_O_DX_A_AUTHENTICATION_OPTIONS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0B"
#define OMP_O_DX_A_AUXILIARY_CLASS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x5F"
#define OMP_O_DX_A_BAD_PASSWORD_TIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x31"
#define OMP_O_DX_A_BAD_PWD_COUNT                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0C"
#define OMP_O_DX_A_BIRTH_LOCATION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4C"
#define OMP_O_DX_A_BRIDGEHEAD_SERVER_LIST_BL                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x34"
#define OMP_O_DX_A_BRIDGEHEAD_TRANSPORT_LIST                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x33"
#define OMP_O_L0_A_BUILDINGNAME                             "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x30"
#define OMP_O_DX_A_BUILTIN_CREATION_TIME                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0D"
#define OMP_O_DX_A_BUILTIN_MODIFIED_COUNT                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0E"
#define OMP_O_DX_A_BYTES_PER_MINUTE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1C"
#define OMP_O_DX_A_CA_CERTIFICATE_DN                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x39"
#define OMP_O_DX_A_CA_CONNECT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2F"
#define OMP_O_DX_A_CA_USAGES                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x32"
#define OMP_O_DX_A_CA_WEB_URL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x30"
#define OMP_O_DX_A_CAN_UPGRADE_SCRIPT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2F"
#define OMP_O_DX_A_CANONICAL_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x14"
#define OMP_O_L1_A_CARLICENSE                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x01"
#define OMP_O_DX_A_CATALOGS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x23"
#define OMP_O_DX_A_CATEGORIES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x20"
#define OMP_O_DX_A_CATEGORY_ID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x42"
#define OMP_O_DX_A_CERTIFICATE_AUTHORITY_OBJECT             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2C"
#define OMP_O_DX_A_CERTIFICATE_TEMPLATES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x37"
#define OMP_O_DX_A_CLASS_DISPLAY_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x62"
#define OMP_O_DX_A_CODE_PAGE                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x10"
#define OMP_O_DX_A_COM_CLASSID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x13"
#define OMP_O_DX_A_COM_CLSID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x79"
#define OMP_O_DX_A_COM_INTERFACEID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x14"
#define OMP_O_DX_A_COM_OTHER_PROG_ID                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7D"
#define OMP_O_DX_A_COM_PROGID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x15"
#define OMP_O_DX_A_COM_TREAT_AS_CLASS_ID                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7B"
#define OMP_O_DX_A_COM_TYPELIB_ID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7E"
#define OMP_O_DX_A_COM_UNIQUE_LIBID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7A"
#define OMP_O_DX_A_COMMENT                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x51"
#define OMP_O_DX_A_COMPANY                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x12"
#define OMP_O_DX_A_CONTENT_INDEXING_ALLOWED                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x18"
#define OMP_O_DX_A_CONTEXT_MENU                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x73"
#define OMP_O_DX_A_CONTROL_ACCESS_RIGHTS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x48"
#define OMP_O_DX_A_COST                                     "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x07"
#define OMP_O_DX_A_COUNTRY_CODE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x19"
#define OMP_O_DX_A_CREATE_DIALOG                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2A"
#define OMP_O_DX_A_CREATE_WIZARD_EXT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2C"
#define OMP_O_DX_A_CREATION_TIME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1A"
#define OMP_O_DX_A_CREATION_WIZARD                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x72"
#define OMP_O_DX_A_CREATOR                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x27"
#define OMP_O_DX_A_CRL_OBJECT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x31"
#define OMP_O_DX_A_CRL_PARTITIONED_REVOCATION_LIST          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2B"
#define OMP_O_DX_A_CURR_MACHINE_ID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x51"
#define OMP_O_DX_A_CURRENT_LOCATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4F"
#define OMP_O_DX_A_CURRENT_PARENT_CA                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x38"
#define OMP_O_DX_A_CURRENT_VALUE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1B"
#define OMP_O_DX_A_DBCS_PWD                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x37"
#define OMP_O_DX_A_DEFAULT_CLASS_STORE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x55"
#define OMP_O_DX_A_DEFAULT_GROUP                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x60"
#define OMP_O_DX_A_DEFAULT_HIDING_VALUE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x06"
#define OMP_O_DX_A_DEFAULT_LOCAL_POLICY_OBJECT              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x39"
#define OMP_O_DX_A_DEFAULT_OBJECT_CATEGORY                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0F"
#define OMP_O_DX_A_DEFAULT_PRIORITY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x68"
#define OMP_O_DX_A_DEFAULT_SECURITY_DESCRIPTOR              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x60"
#define OMP_O_DX_A_DEPARTMENT                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x0D"
#define OMP_O_L1_A_DEPARTMENTNUMBER                         "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x02"
#define OMP_O_DX_A_DESKTOP_PROFILE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x5A"
#define OMP_O_DX_A_DHCP_CLASSES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4B"
#define OMP_O_DX_A_DHCP_FLAGS                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3C"
#define OMP_O_DX_A_DHCP_IDENTIFICATION                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3D"
#define OMP_O_DX_A_DHCP_MASK                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x42"
#define OMP_O_DX_A_DHCP_MAXKEY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4F"
#define OMP_O_DX_A_DHCP_OBJ_DESCRIPTION                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3F"
#define OMP_O_DX_A_DHCP_OBJ_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3E"
#define OMP_O_DX_A_DHCP_OPTIONS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4A"
#define OMP_O_DX_A_DHCP_PROPERTIES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4E"
#define OMP_O_DX_A_DHCP_RANGES                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x43"
#define OMP_O_DX_A_DHCP_RESERVATIONS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x45"
#define OMP_O_DX_A_DHCP_SERVERS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x40"
#define OMP_O_DX_A_DHCP_SITES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x44"
#define OMP_O_DX_A_DHCP_STATE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4D"
#define OMP_O_DX_A_DHCP_SUBNETS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x41"
#define OMP_O_DX_A_DHCP_TYPE                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3B"
#define OMP_O_DX_A_DHCP_UNIQUE_KEY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3A"
#define OMP_O_DX_A_DHCP_UPDATE_TIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x50"
#define OMP_O_DX_A_DISPLAY_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0D"
#define OMP_O_DX_A_DISPLAY_NAME_PRINTABLE                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x61"
#define OMP_O_DX_A_DIVISION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x05"
#define OMP_O_DX_A_DMD_LOCATION                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x24"
#define OMP_O_DX_A_DMD_NAME                                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x56"
#define OMP_O_DX_A_DN_REFERENCE_UPDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5A"
#define OMP_O_DX_A_DNS_ALLOW_DYNAMIC                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7A"
#define OMP_O_DX_A_DNS_ALLOW_XFR                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7B"
#define OMP_O_DX_A_DNS_HOST_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6B"
#define OMP_O_DX_A_DNS_NOTIFY_SECONDARIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7D"
#define OMP_O_DX_A_DNS_PROPERTY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1A"
#define OMP_O_DX_A_DNS_RECORD                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7E"
#define OMP_O_DX_A_DNS_ROOT                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1C"
#define OMP_O_DX_A_DNS_SECURE_SECONDARIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7C"
#define OMP_O_DX_A_DNS_TOMBSTONED                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x06"
#define OMP_O_L0_A_DOCUMENTAUTHOR                           "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0E"
#define OMP_O_L0_A_DOCUMENTIDENTIFIER                       "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0B"
#define OMP_O_L0_A_DOCUMENTLOCATION                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0F"
#define OMP_O_L0_A_DOCUMENTPUBLISHER                        "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x38"
#define OMP_O_L0_A_DOCUMENTTITLE                            "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0C"
#define OMP_O_L0_A_DOCUMENTVERSION                          "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0D"
#define OMP_O_DX_A_DOMAIN_CERTIFICATE_AUTHORITIES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1C"
#define OMP_O_L0_A_DOMAIN_COMPONENT                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19"
#define OMP_O_DX_A_DOMAIN_CROSS_REF                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x58"
#define OMP_O_DX_A_DOMAIN_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2E"
#define OMP_O_DX_A_DOMAIN_IDENTIFIER                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x73"
#define OMP_O_DX_A_DOMAIN_POLICY_OBJECT                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x20"
#define OMP_O_DX_A_DOMAIN_POLICY_REFERENCE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x26"
#define OMP_O_DX_A_DOMAIN_REPLICA                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1E"
#define OMP_O_DX_A_DOMAIN_WIDE_POLICY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x25"
#define OMP_O_L0_A_DRINK                                    "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x05"
#define OMP_O_DX_A_DRIVER_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x65"
#define OMP_O_DX_A_DRIVER_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x14"
#define OMP_O_DX_A_DS_CORE_PROPAGATION_DATA                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4D"
#define OMP_O_DX_A_DS_HEURISTICS                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x54"
#define OMP_O_DX_A_DS_UI_ADMIN_MAXIMUM                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x40"
#define OMP_O_DX_A_DS_UI_ADMIN_NOTIFICATION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x3F"
#define OMP_O_DX_A_DS_UI_SHELL_MAXIMUM                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x41"
#define OMP_O_DX_A_DSA_SIGNATURE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x4A"
#define OMP_O_DX_A_DYNAMIC_LDAP_SERVER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x19"
#define OMP_O_L0_A_E_MAIL_ADDRESSES                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x03"
#define OMP_O_DX_A_EFSPOLICY                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0C"
#define OMP_O_DX_A_EMPLOYEE_ID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x23"
#define OMP_O_DX_A_EMPLOYEE_NUMBER                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x62"
#define OMP_O_DX_A_EMPLOYEE_TYPE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x65"
#define OMP_O_DX_A_ENABLED                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x2D"
#define OMP_O_DX_A_ENABLED_CONNECTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x24"
#define OMP_O_DX_A_ENROLLMENT_PROVIDERS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x39"
#define OMP_O_DX_A_EXTENDED_ATTRIBUTE_INFO                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0D"
#define OMP_O_DX_A_EXTENDED_CHARS_ALLOWED                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x7C"
#define OMP_O_DX_A_EXTENDED_CLASS_INFO                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0C"
#define OMP_O_DX_A_EXTENSION_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x63"
#define OMP_O_DX_A_EXTRA_COLUMNS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x17"
#define OMP_O_DX_A_FILE_EXT_PRIORITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x30"
#define OMP_O_DX_A_FLAGS                                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x26"
#define OMP_O_DX_A_FLAT_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7F"
#define OMP_O_DX_A_FORCE_LOGOFF                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x27"
#define OMP_O_DX_A_FOREIGN_IDENTIFIER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x64"
#define OMP_O_DX_A_FRIENDLY_NAMES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2A"
#define OMP_O_DX_A_FROM_ENTRY                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0E"
#define OMP_O_DX_A_FROM_SERVER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x28"
#define OMP_O_DX_A_FRS_COMPUTER_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x65"
#define OMP_O_DX_A_FRS_COMPUTER_REFERENCE_BL                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x66"
#define OMP_O_DX_A_FRS_CONTROL_DATA_CREATION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x67"
#define OMP_O_DX_A_FRS_CONTROL_INBOUND_BACKLOG              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x68"
#define OMP_O_DX_A_FRS_CONTROL_OUTBOUND_BACKLOG             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x69"
#define OMP_O_DX_A_FRS_DIRECTORY_FILTER                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x64"
#define OMP_O_DX_A_FRS_DS_POLL                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6A"
#define OMP_O_DX_A_FRS_EXTENSIONS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x18"
#define OMP_O_DX_A_FRS_FAULT_CONDITION                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6B"
#define OMP_O_DX_A_FRS_FILE_FILTER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x63"
#define OMP_O_DX_A_FRS_FLAGS                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6A"
#define OMP_O_DX_A_FRS_LEVEL_LIMIT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x16"
#define OMP_O_DX_A_FRS_MEMBER_REFERENCE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6B"
#define OMP_O_DX_A_FRS_MEMBER_REFERENCE_BL                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6C"
#define OMP_O_DX_A_FRS_PARTNER_AUTH_LEVEL                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6D"
#define OMP_O_DX_A_FRS_PRIMARY_MEMBER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6E"
#define OMP_O_DX_A_FRS_REPLICA_SET_GUID                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x15"
#define OMP_O_DX_A_FRS_REPLICA_SET_TYPE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1F"
#define OMP_O_DX_A_FRS_ROOT_PATH                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x67"
#define OMP_O_DX_A_FRS_ROOT_SECURITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x17"
#define OMP_O_DX_A_FRS_SERVICE_COMMAND                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x74"
#define OMP_O_DX_A_FRS_SERVICE_COMMAND_STATUS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6F"
#define OMP_O_DX_A_FRS_STAGING_PATH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x68"
#define OMP_O_DX_A_FRS_TIME_LAST_COMMAND                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x70"
#define OMP_O_DX_A_FRS_TIME_LAST_CONFIG_CHANGE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x71"
#define OMP_O_DX_A_FRS_UPDATE_TIMEOUT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x65"
#define OMP_O_DX_A_FRS_VERSION                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x72"
#define OMP_O_DX_A_FRS_VERSION_GUID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2B"
#define OMP_O_DX_A_FRS_WORKING_PATH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x66"
#define OMP_O_DX_A_FSMO_ROLE_OWNER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x71"
#define OMP_O_DX_A_GARBAGE_COLL_PERIOD                      "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x2D"
#define OMP_O_DX_A_GENERATED_CONNECTION                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x29"
#define OMP_O_DX_A_GLOBAL_ADDRESS_LIST                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5D"
#define OMP_O_DX_A_GOVERNS_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x16"
#define OMP_O_DX_A_GP_LINK                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7B"
#define OMP_O_DX_A_GP_OPTIONS                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7C"
#define OMP_O_DX_A_GPC_FILE_SYS_PATH                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7E"
#define OMP_O_DX_A_GPC_FUNCTIONALITY_VERSION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7D"
#define OMP_O_DX_A_GPC_MACHINE_EXTENSION_NAMES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x44"
#define OMP_O_DX_A_GPC_USER_EXTENSION_NAMES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x45"
#define OMP_O_DX_A_GPC_WQL_FILTER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1E"
#define OMP_O_DX_A_GROUP_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x18"
#define OMP_O_DX_A_GROUP_MEMBERSHIP_SAM                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x26"
#define OMP_O_DX_A_GROUP_PRIORITY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x59"
#define OMP_O_DX_A_GROUP_TYPE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6E"
#define OMP_O_DX_A_GROUPS_TO_IGNORE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x58"
#define OMP_O_DX_A_HAS_MASTER_NCS                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0E"
#define OMP_O_DX_A_HAS_PARTIAL_REPLICA_NCS                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0F"
#define OMP_O_DX_A_HELP_DATA16                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x12"
#define OMP_O_DX_A_HELP_DATA32                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x09"
#define OMP_O_DX_A_HELP_FILE_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x47"
#define OMP_O_DX_A_HIDE_FROM_AB                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x74"
#define OMP_O_DX_A_HOME_DIRECTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2C"
#define OMP_O_DX_A_HOME_DRIVE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2D"
#define OMP_O_L0_A_HOST                                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x09"
#define OMP_O_DX_A_ICON_PATH                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5B"
#define OMP_O_DX_A_IMPLEMENTED_CATEGORIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x40"
#define OMP_O_DX_A_INDEXEDSCOPES                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x29"
#define OMP_O_DX_A_INITIAL_AUTH_INCOMING                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1B"
#define OMP_O_DX_A_INITIAL_AUTH_OUTGOING                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1C"
#define OMP_O_DX_A_INSTALL_UI_LEVEL                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4F"
#define OMP_O_DX_A_INSTANCE_TYPE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x01"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_FAILOVER             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x60"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_GENERATOR            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5E"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_RENEW                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5F"
#define OMP_O_DX_A_INVOCATION_ID                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x73"
#define OMP_O_DX_A_IPSEC_DATA                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6F"
#define OMP_O_DX_A_IPSEC_DATA_TYPE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6E"
#define OMP_O_DX_A_IPSEC_FILTER_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x75"
#define OMP_O_DX_A_IPSEC_ID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6D"
#define OMP_O_DX_A_IPSEC_ISAKMP_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x72"
#define OMP_O_DX_A_IPSEC_NAME                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6C"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_ACTION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x78"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_REFERENCE       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x74"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_TYPE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x77"
#define OMP_O_DX_A_IPSEC_NFA_REFERENCE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x73"
#define OMP_O_DX_A_IPSEC_OWNERS_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x70"
#define OMP_O_DX_A_IPSEC_POLICY_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x05"
#define OMP_O_DX_A_IS_CRITICAL_SYSTEM_OBJECT                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x64"
#define OMP_O_DX_A_IS_DEFUNCT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x15"
#define OMP_O_DX_A_IS_DELETED                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x30"
#define OMP_O_DX_A_IS_EPHEMERAL                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x3C"
#define OMP_O_DX_A_IS_MEMBER_OF_DL                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x66"
#define OMP_O_DX_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7F"
#define OMP_O_DX_A_IS_PRIVILEGE_HOLDER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7E"
#define OMP_O_DX_A_IS_SINGLE_VALUED                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x21"
#define OMP_O_L0_A_JPEGPHOTO                                "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x3C"
#define OMP_O_DX_A_KEYWORDS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x30"
#define OMP_O_DX_A_LAST_BACKUP_RESTORATION_TIME             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x07"
#define OMP_O_DX_A_LAST_CONTENT_INDEXED                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x32"
#define OMP_O_DX_A_LAST_KNOWN_PARENT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0D"
#define OMP_O_DX_A_LAST_LOGOFF                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x33"
#define OMP_O_DX_A_LAST_LOGON                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x34"
#define OMP_O_DX_A_LAST_LOGON_TIMESTAMP                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x20"
#define OMP_O_DX_A_LAST_SET_TIME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x35"
#define OMP_O_DX_A_LAST_UPDATE_SEQUENCE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4A"
#define OMP_O_DX_A_LDAP_ADMIN_LIMITS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4B"
#define OMP_O_DX_A_LDAP_DISPLAY_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x4C"
#define OMP_O_DX_A_LDAP_IPDENY_LIST                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4C"
#define OMP_O_DX_A_LEGACY_EXCHANGE_DN                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0F"
#define OMP_O_DX_A_LINK_ID                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x32"
#define OMP_O_DX_A_LINK_TRACK_SECRET                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0D"
#define OMP_O_DX_A_LM_PWD_HISTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x20"
#define OMP_O_DX_A_LOCAL_POLICY_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x38"
#define OMP_O_DX_A_LOCAL_POLICY_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x49"
#define OMP_O_DX_A_LOCALE_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3A"
#define OMP_O_DX_A_LOCALIZED_DESCRIPTION                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x31"
#define OMP_O_DX_A_LOCALIZATION_DISPLAY_ID                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x49"
#define OMP_O_DX_A_LOCATION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5E"
#define OMP_O_DX_A_LOCK_OUT_OBSERVATION_WINDOW              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3D"
#define OMP_O_DX_A_LOCKOUT_DURATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3C"
#define OMP_O_DX_A_LOCKOUT_THRESHOLD                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x49"
#define OMP_O_DX_A_LOCKOUT_TIME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x16"
#define OMP_O_L1_A_LOGO                                     "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x24"
#define OMP_O_DX_A_LOGON_COUNT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x29"
#define OMP_O_DX_A_LOGON_HOURS                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x40"
#define OMP_O_DX_A_LOGON_WORKSTATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x41"
#define OMP_O_DX_A_LSA_CREATION_TIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x42"
#define OMP_O_DX_A_LSA_MODIFIED_COUNT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x43"
#define OMP_O_DX_A_MACHINE_ARCHITECTURE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x44"
#define OMP_O_DX_A_MACHINE_PASSWORD_CHANGE_INTERVAL         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x08"
#define OMP_O_DX_A_MACHINE_ROLE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x47"
#define OMP_O_DX_A_MACHINE_WIDE_POLICY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x4B"
#define OMP_O_DX_A_MANAGED_BY                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0D"
#define OMP_O_DX_A_MANAGED_OBJECTS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0E"
#define OMP_O_L0_A_MANAGER                                  "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0A"
#define OMP_O_DX_A_MAPI_ID                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x31"
#define OMP_O_DX_A_MARSHALLED_INTERFACE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x48"
#define OMP_O_DX_A_MASTERED_BY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x01"
#define OMP_O_DX_A_MAX_PWD_AGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4A"
#define OMP_O_DX_A_MAX_RENEW_AGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4B"
#define OMP_O_DX_A_MAX_STORAGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4C"
#define OMP_O_DX_A_MAX_TICKET_AGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4D"
#define OMP_O_DX_A_MAY_CONTAIN                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x19"
#define OMP_O_DX_A_MEETINGADVERTISESCOPE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x46"
#define OMP_O_DX_A_MEETINGAPPLICATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3D"
#define OMP_O_DX_A_MEETINGBANDWIDTH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4D"
#define OMP_O_DX_A_MEETINGBLOB                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4E"
#define OMP_O_DX_A_MEETINGCONTACTINFO                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x42"
#define OMP_O_DX_A_MEETINGDESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x37"
#define OMP_O_DX_A_MEETINGENDTIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4C"
#define OMP_O_DX_A_MEETINGID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x35"
#define OMP_O_DX_A_MEETINGIP                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x44"
#define OMP_O_DX_A_MEETINGISENCRYPTED                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x49"
#define OMP_O_DX_A_MEETINGKEYWORD                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x38"
#define OMP_O_DX_A_MEETINGLANGUAGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3E"
#define OMP_O_DX_A_MEETINGLOCATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x39"
#define OMP_O_DX_A_MEETINGMAXPARTICIPANTS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x40"
#define OMP_O_DX_A_MEETINGNAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x36"
#define OMP_O_DX_A_MEETINGORIGINATOR                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x41"
#define OMP_O_DX_A_MEETINGOWNER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x43"
#define OMP_O_DX_A_MEETINGPROTOCOL                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3A"
#define OMP_O_DX_A_MEETINGRATING                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x48"
#define OMP_O_DX_A_MEETINGRECURRENCE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4A"
#define OMP_O_DX_A_MEETINGSCOPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x45"
#define OMP_O_DX_A_MEETINGSTARTTIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4B"
#define OMP_O_DX_A_MEETINGTYPE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3B"
#define OMP_O_DX_A_MEETINGURL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x47"
#define OMP_O_DX_A_MHS_OR_ADDRESS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0A"
#define OMP_O_DX_A_MIN_PWD_AGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4E"
#define OMP_O_DX_A_MIN_PWD_LENGTH                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4F"
#define OMP_O_DX_A_MIN_TICKET_AGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x50"
#define OMP_O_DX_A_MODIFIED_COUNT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x28"
#define OMP_O_DX_A_MODIFIED_COUNT_AT_LAST_PROM              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x51"
#define OMP_O_DX_A_MONIKER                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x52"
#define OMP_O_DX_A_MONIKER_DISPLAY_NAME                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x53"
#define OMP_O_DX_A_MOVE_TREE_STATE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x19"
#define OMP_O_DX_A_MS_COM_DEFAULTPARTITIONLINK              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x13"
#define OMP_O_DX_A_MS_COM_OBJECTID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x14"
#define OMP_O_DX_A_MS_COM_PARTITIONLINK                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x0F"
#define OMP_O_DX_A_MS_COM_PARTITIONSETLINK                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x10"
#define OMP_O_DX_A_MS_COM_USERLINK                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x11"
#define OMP_O_DX_A_MS_COM_USERPARTITIONSETLINK              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x12"
#define OMP_O_DX_A_MS_DRM_IDENTITY_CERTIFICATE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x33"
#define OMP_O_DX_A_MS_DS_ADDITIONAL_DNS_HOST_NAME           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x35"
#define OMP_O_DX_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x36"
#define OMP_O_DX_A_MS_DS_ALL_USERS_TRUST_QUOTA              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7D"
#define OMP_O_DX_A_MS_DS_ALLOWED_DNS_SUFFIXES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2E"
#define OMP_O_DX_A_MS_DS_ALLOWED_TO_DELEGATE_TO             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7B"
#define OMP_O_DX_A_MS_DS_AUXILIARY_CLASSES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x32"
#define OMP_O_DX_A_MS_DS_APPROX_IMMED_SUBORDINATES          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x05"
#define OMP_O_DX_A_MS_DS_AZ_APPLICATION_DATA                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1B"
#define OMP_O_DX_A_MS_DS_AZ_APPLICATION_NAME                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x06"
#define OMP_O_DX_A_MS_DS_AZ_APPLICATION_VERSION             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x19"
#define OMP_O_DX_A_MS_DS_AZ_BIZ_RULE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x09"
#define OMP_O_DX_A_MS_DS_AZ_BIZ_RULE_LANGUAGE               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x0A"
#define OMP_O_DX_A_MS_DS_AZ_CLASS_ID                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x18"
#define OMP_O_DX_A_MS_DS_AZ_DOMAIN_TIMEOUT                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x03"
#define OMP_O_DX_A_MS_DS_AZ_GENERATE_AUDITS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x0D"
#define OMP_O_DX_A_MS_DS_AZ_LAST_IMPORTED_BIZ_RULE_PATH     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x0B"
#define OMP_O_DX_A_MS_DS_AZ_LDAP_QUERY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x00"
#define OMP_O_DX_A_MS_DS_AZ_MAJOR_VERSION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x20"
#define OMP_O_DX_A_MS_DS_AZ_MINOR_VERSION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x21"
#define OMP_O_DX_A_MS_DS_AZ_OPERATION_ID                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x08"
#define OMP_O_DX_A_MS_DS_AZ_SCOPE_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x07"
#define OMP_O_DX_A_MS_DS_AZ_SCRIPT_ENGINE_CACHE_MAX         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x04"
#define OMP_O_DX_A_MS_DS_AZ_SCRIPT_TIMEOUT                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x05"
#define OMP_O_DX_A_MS_DS_AZ_TASK_IS_ROLE_DEFINITION         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1A"
#define OMP_O_DX_A_MS_DS_BEHAVIOR_VERSION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x33"
#define OMP_O_DX_A_MS_DS_BYTE_ARRAY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x27"
#define OMP_O_DX_A_MS_DS_CACHED_MEMBERSHIP                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x21"
#define OMP_O_DX_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x22"
#define OMP_O_DX_A_MS_DS_CONSISTENCY_GUID                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x50"
#define OMP_O_DX_A_MS_DS_CONSISTENCY_CHILD_COUNT            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x51"
#define OMP_O_DX_A_MS_DS_CREATOR_SID                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x02"
#define OMP_O_DX_A_MS_DS_DATE_TIME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x28"
#define OMP_O_DX_A_MS_DS_DEFAULT_QUOTA                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x36"
#define OMP_O_DX_A_MS_DS_DNSROOTALIAS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x37"
#define OMP_O_DX_A_MS_DS_ENTRY_TIME_TO_DIE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x56"
#define OMP_O_DX_A_MS_DS_EXECUTESCRIPTPASSWORD              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x77"
#define OMP_O_DX_A_MS_DS_EXTERNAL_KEY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x29"
#define OMP_O_DX_A_MS_DS_EXTERNAL_STORE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x2A"
#define OMP_O_DX_A_MS_DS_FILTER_CONTAINERS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x27"
#define OMP_O_DX_A_MS_DS_HAS_INSTANTIATED_NCS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2D"
#define OMP_O_DX_A_MS_DS_HAS_DOMAIN_NCS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1C"
#define OMP_O_DX_A_MS_DS_HAS_MASTER_NCS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x2C"
#define OMP_O_DX_A_MS_DS_INTEGER                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x2B"
#define OMP_O_DX_A_MS_DS_INTID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x34"
#define OMP_O_DX_A_MS_DS_KEYVERSIONNUMBER                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x76"
#define OMP_O_DX_A_MS_DS_LOGON_TIME_SYNC_INTERVAL           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x78"
#define OMP_O_DX_A_MS_DS_MASTERED_BY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x2D"
#define OMP_O_DX_A_MS_DS_MAX_VALUES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x32"
#define OMP_O_DX_A_MS_DS_MEMBERS_FOR_AZ_ROLE                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x0E"
#define OMP_O_DX_A_MS_DS_MEMBERS_FOR_AZ_ROLE_BL             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x0F"
#define OMP_O_DX_A_MS_DS_NON_MEMBERS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x01"
#define OMP_O_DX_A_MS_DS_NON_MEMBERS_BL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x02"
#define OMP_O_DX_A_MS_DS_TRUST_FOREST_TRUST_INFO            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x26"
#define OMP_O_DX_A_MS_DS_TOMBSTONE_QUOTA_FACTOR             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x37"
#define OMP_O_DX_A_MS_DS_TOP_QUOTA_USAGE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x3A"
#define OMP_O_DX_A_MS_DS_MACHINE_ACCOUNT_QUOTA              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x03"
#define OMP_O_DX_A_MS_DS_OBJECT_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x30"
#define OMP_O_DX_A_MS_DS_OBJECT_REFERENCE_BL                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x31"
#define OMP_O_DX_A_MS_DS_OPERATIONS_FOR_AZ_ROLE             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x14"
#define OMP_O_DX_A_MS_DS_OPERATIONS_FOR_AZ_ROLE_BL          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x15"
#define OMP_O_DX_A_MS_DS_OPERATIONS_FOR_AZ_TASK             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x10"
#define OMP_O_DX_A_MS_DS_OPERATIONS_FOR_AZ_TASK_BL          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x11"
#define OMP_O_DX_A_MS_DS_OTHER_SETTINGS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x55"
#define OMP_O_DX_A_MS_DS_QUOTA_AMOUNT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x35"
#define OMP_O_DX_A_MS_DS_QUOTA_EFFECTIVE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x38"
#define OMP_O_DX_A_MS_DS_QUOTA_TRUSTEE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x34"
#define OMP_O_DX_A_MS_DS_QUOTA_USED                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x39"
#define OMP_O_DX_A_MS_DS_NC_REPL_CURSORS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x28"
#define OMP_O_DX_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x29"
#define OMP_O_DX_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2A"
#define OMP_O_DX_A_MS_DS_NC_REPLICA_LOCATIONS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x7D"
#define OMP_O_DX_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x19"
#define OMP_O_DX_A_MS_DS_PER_USER_TRUST_QUOTA               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7C"
#define OMP_O_DX_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7E"
#define OMP_O_DX_A_MS_DS_PREFERRED_GC_SITE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x24"
#define OMP_O_DX_A_MS_DS_REPL_ATTRIBUTE_META_DATA           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2B"
#define OMP_O_DX_A_MS_DS_REPL_VALUE_META_DATA               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2C"
#define OMP_O_DX_A_MS_DS_REPLICATES_NC_REASON               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x00"
#define OMP_O_DX_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x7F"
#define OMP_O_DX_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_ "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x00"
#define OMP_O_DX_A_MS_DS_REPLICATIONEPOCH                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x38"
#define OMP_O_DX_A_MS_DS_RETIRED_REPL_NC_SIGNATURES         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x22"
#define OMP_O_DX_A_MS_DS_SCHEMA_EXTENSIONS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x20"
#define OMP_O_DX_A_MS_DS_SD_REFERENCE_DOMAIN                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2F"
#define OMP_O_DX_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x18"
#define OMP_O_DX_A_MS_DS_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x21"
#define OMP_O_DX_A_MS_DS_SITE_AFFINITY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x23"
#define OMP_O_DX_A_MS_DS_SPN_SUFFIXES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x33"
#define OMP_O_DX_A_MS_DS_TASKS_FOR_AZ_ROLE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x16"
#define OMP_O_DX_A_MS_DS_TASKS_FOR_AZ_ROLE_BL               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x17"
#define OMP_O_DX_A_MS_DS_TASKS_FOR_AZ_TASK                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x12"
#define OMP_O_DX_A_MS_DS_TASKS_FOR_AZ_TASK_BL               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x13"
#define OMP_O_DX_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x34"
#define OMP_O_DX_A_MS_DS_UPDATESCRIPT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x39"
#define OMP_O_DX_A_MS_EXCH_ASSISTANT_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x3C"
#define OMP_O_DX_A_MS_EXCH_HOUSE_IDENTIFIER                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x54"
#define OMP_O_DX_A_MS_EXCH_LABELEDURI                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x51"
#define OMP_O_DX_A_MS_EXCH_OWNER_BL                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x68"
#define OMP_O_DX_A_MS_FRS_HUB_MEMBER                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1D"
#define OMP_O_DX_A_MS_FRS_TOPOLOGY_PREF                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1C"
#define OMP_O_DX_A_MS_IEEE_80211_DATA                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1D"
#define OMP_O_DX_A_MS_IEEE_80211_DATA_TYPE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1E"
#define OMP_O_DX_A_MS_IEEE_80211_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8E\x1F"
#define OMP_O_DX_A_MS_IIS_FTP_DIR                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7A"
#define OMP_O_DX_A_MS_IIS_FTP_ROOT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x79"
#define OMP_O_DX_A_MS_PKI_CERT_TEMPLATE_OID                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1C"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0A"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_NAME_FLAG             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x18"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_POLICY                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1F"
#define OMP_O_DX_A_MS_PKI_ENROLLMENT_FLAG                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x16"
#define OMP_O_DX_A_MS_PKI_MINIMAL_KEY_SIZE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x19"
#define OMP_O_DX_A_MS_PKI_OID_ATTRIBUTE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x07"
#define OMP_O_DX_A_MS_PKI_OID_CPS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x08"
#define OMP_O_DX_A_MS_PKI_OID_LOCALIZEDNAME                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x30"
#define OMP_O_DX_A_MS_PKI_OID_USER_NOTICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x09"
#define OMP_O_DX_A_MS_PKI_PRIVATE_KEY_FLAG                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x17"
#define OMP_O_DX_A_MS_PKI_SUPERSEDE_TEMPLATES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1D"
#define OMP_O_DX_A_MS_PKI_TEMPLATE_MINOR_REVISION           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1B"
#define OMP_O_DX_A_MS_PKI_TEMPLATE_SCHEMA_VERSION           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1A"
#define OMP_O_DX_A_MS_PKI_RA_APPLICATION_POLICIES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0B"
#define OMP_O_DX_A_MS_PKI_RA_POLICIES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1E"
#define OMP_O_DX_A_MS_PKI_RA_SIGNATURE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x15"
#define OMP_O_DX_A_MS_RRAS_ATTRIBUTE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x74"
#define OMP_O_DX_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x73"
#define OMP_O_DX_A_MS_SQL_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x53"
#define OMP_O_DX_A_MS_SQL_REGISTEREDOWNER                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x54"
#define OMP_O_DX_A_MS_SQL_CONTACT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x55"
#define OMP_O_DX_A_MS_SQL_LOCATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x56"
#define OMP_O_DX_A_MS_SQL_MEMORY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x57"
#define OMP_O_DX_A_MS_SQL_BUILD                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x58"
#define OMP_O_DX_A_MS_SQL_SERVICEACCOUNT                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x59"
#define OMP_O_DX_A_MS_SQL_CHARACTERSET                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5A"
#define OMP_O_DX_A_MS_SQL_SORTORDER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5B"
#define OMP_O_DX_A_MS_SQL_UNICODESORTORDER                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5C"
#define OMP_O_DX_A_MS_SQL_CLUSTERED                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5D"
#define OMP_O_DX_A_MS_SQL_NAMEDPIPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5E"
#define OMP_O_DX_A_MS_SQL_MULTIPROTOCOL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5F"
#define OMP_O_DX_A_MS_SQL_SPX                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x60"
#define OMP_O_DX_A_MS_SQL_TCPIP                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x61"
#define OMP_O_DX_A_MS_SQL_APPLETALK                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x62"
#define OMP_O_DX_A_MS_SQL_VINES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x63"
#define OMP_O_DX_A_MS_SQL_STATUS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x64"
#define OMP_O_DX_A_MS_SQL_LASTUPDATEDDATE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x65"
#define OMP_O_DX_A_MS_SQL_INFORMATIONURL                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x66"
#define OMP_O_DX_A_MS_SQL_CONNECTIONURL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x67"
#define OMP_O_DX_A_MS_SQL_PUBLICATIONURL                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x68"
#define OMP_O_DX_A_MS_SQL_GPSLATITUDE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x69"
#define OMP_O_DX_A_MS_SQL_GPSLONGITUDE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6A"
#define OMP_O_DX_A_MS_SQL_GPSHEIGHT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6B"
#define OMP_O_DX_A_MS_SQL_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6C"
#define OMP_O_DX_A_MS_SQL_LANGUAGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6D"
#define OMP_O_DX_A_MS_SQL_DESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6E"
#define OMP_O_DX_A_MS_SQL_TYPE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6F"
#define OMP_O_DX_A_MS_SQL_INFORMATIONDIRECTORY              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x70"
#define OMP_O_DX_A_MS_SQL_DATABASE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x71"
#define OMP_O_DX_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x72"
#define OMP_O_DX_A_MS_SQL_ALIAS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x73"
#define OMP_O_DX_A_MS_SQL_SIZE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x74"
#define OMP_O_DX_A_MS_SQL_CREATIONDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x75"
#define OMP_O_DX_A_MS_SQL_LASTBACKUPDATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x76"
#define OMP_O_DX_A_MS_SQL_LASTDIAGNOSTICDATE                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x77"
#define OMP_O_DX_A_MS_SQL_APPLICATIONS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x78"
#define OMP_O_DX_A_MS_SQL_KEYWORDS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x79"
#define OMP_O_DX_A_MS_SQL_PUBLISHER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7A"
#define OMP_O_DX_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7B"
#define OMP_O_DX_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTIO "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7C"
#define OMP_O_DX_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7D"
#define OMP_O_DX_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7E"
#define OMP_O_DX_A_MS_SQL_THIRDPARTY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7F"
#define OMP_O_DX_A_MS_TAPI_CONFERENCE_BLOB                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x24"
#define OMP_O_DX_A_MS_TAPI_IP_ADDRESS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x25"
#define OMP_O_DX_A_MS_TAPI_PROTOCOL_ID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x23"
#define OMP_O_DX_A_MS_TAPI_UNIQUE_IDENTIFIER                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x22"
#define OMP_O_DX_A_MS_WMI_AUTHOR                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x57"
#define OMP_O_DX_A_MS_WMI_CHANGEDATE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x58"
#define OMP_O_DX_A_MS_WMI_CLASS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0C"
#define OMP_O_DX_A_MS_WMI_CLASSDEFINITION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x59"
#define OMP_O_DX_A_MS_WMI_CREATIONDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5A"
#define OMP_O_DX_A_MS_WMI_GENUS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0D"
#define OMP_O_DX_A_MS_WMI_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5B"
#define OMP_O_DX_A_MS_WMI_INTDEFAULT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5C"
#define OMP_O_DX_A_MS_WMI_INTFLAGS1                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0E"
#define OMP_O_DX_A_MS_WMI_INTFLAGS2                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0F"
#define OMP_O_DX_A_MS_WMI_INTFLAGS3                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x10"
#define OMP_O_DX_A_MS_WMI_INTFLAGS4                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x11"
#define OMP_O_DX_A_MS_WMI_INTMAX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5D"
#define OMP_O_DX_A_MS_WMI_INTMIN                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5E"
#define OMP_O_DX_A_MS_WMI_INTVALIDVALUES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5F"
#define OMP_O_DX_A_MS_WMI_INT8DEFAULT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x60"
#define OMP_O_DX_A_MS_WMI_INT8MAX                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x61"
#define OMP_O_DX_A_MS_WMI_INT8MIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x62"
#define OMP_O_DX_A_MS_WMI_INT8VALIDVALUES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x63"
#define OMP_O_DX_A_MS_WMI_MOF                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x66"
#define OMP_O_DX_A_MS_WMI_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x67"
#define OMP_O_DX_A_MS_WMI_NORMALIZEDCLASS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x68"
#define OMP_O_DX_A_MS_WMI_PARM1                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x12"
#define OMP_O_DX_A_MS_WMI_PARM2                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x13"
#define OMP_O_DX_A_MS_WMI_PARM3                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x14"
#define OMP_O_DX_A_MS_WMI_PARM4                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x15"
#define OMP_O_DX_A_MS_WMI_PROPERTYNAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x69"
#define OMP_O_DX_A_MS_WMI_QUERY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6A"
#define OMP_O_DX_A_MS_WMI_QUERYLANGUAGE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6B"
#define OMP_O_DX_A_MS_WMI_SCOPEGUID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x16"
#define OMP_O_DX_A_MS_WMI_SOURCEORGANIZATION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6C"
#define OMP_O_DX_A_MS_WMI_STRINGDEFAULT                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x64"
#define OMP_O_DX_A_MS_WMI_STRINGVALIDVALUES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x65"
#define OMP_O_DX_A_MS_WMI_TARGETCLASS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6D"
#define OMP_O_DX_A_MS_WMI_TARGETNAMESPACE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6E"
#define OMP_O_DX_A_MS_WMI_TARGETOBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6F"
#define OMP_O_DX_A_MS_WMI_TARGETPATH                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x70"
#define OMP_O_DX_A_MS_WMI_TARGETTYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x71"
#define OMP_O_DX_A_MSCOPE_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4C"
#define OMP_O_DX_A_MSI_FILE_LIST                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1F"
#define OMP_O_DX_A_MSI_SCRIPT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2E"
#define OMP_O_DX_A_MSI_SCRIPT_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4D"
#define OMP_O_DX_A_MSI_SCRIPT_PATH                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0F"
#define OMP_O_DX_A_MSI_SCRIPT_SIZE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4E"
#define OMP_O_DX_A_MSMQ_AUTHENTICATE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1B"
#define OMP_O_DX_A_MSMQ_BASE_PRIORITY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x18"
#define OMP_O_DX_A_MSMQ_COMPUTER_TYPE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x25"
#define OMP_O_DX_A_MSMQ_COMPUTER_TYPE_EX                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x09"
#define OMP_O_DX_A_MSMQ_COST                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x32"
#define OMP_O_DX_A_MSMQ_CSP_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2C"
#define OMP_O_DX_A_MSMQ_DEPENDENT_CLIENT_SERVICE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x57"
#define OMP_O_DX_A_MSMQ_DEPENDENT_CLIENT_SERVICES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4A"
#define OMP_O_DX_A_MSMQ_DIGESTS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x34"
#define OMP_O_DX_A_MSMQ_DIGESTS_MIG                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x46"
#define OMP_O_DX_A_MSMQ_DS_SERVICE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x56"
#define OMP_O_DX_A_MSMQ_DS_SERVICES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4C"
#define OMP_O_DX_A_MSMQ_ENCRYPT_KEY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x28"
#define OMP_O_DX_A_MSMQ_FOREIGN                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x26"
#define OMP_O_DX_A_MSMQ_IN_ROUTING_SERVERS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x21"
#define OMP_O_DX_A_MSMQ_INTERVAL1                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1C"
#define OMP_O_DX_A_MSMQ_INTERVAL2                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1D"
#define OMP_O_DX_A_MSMQ_JOURNAL                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x16"
#define OMP_O_DX_A_MSMQ_JOURNAL_QUOTA                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x19"
#define OMP_O_DX_A_MSMQ_LABEL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1A"
#define OMP_O_DX_A_MSMQ_LABEL_EX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x07"
#define OMP_O_DX_A_MSMQ_LONG_LIVED                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2D"
#define OMP_O_DX_A_MSMQ_MIGRATED                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x38"
#define OMP_O_DX_A_MSMQ_MULTICAST_ADDRESS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x32"
#define OMP_O_DX_A_MSMQ_NAME_STYLE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2B"
#define OMP_O_DX_A_MSMQ_NT4_FLAGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x44"
#define OMP_O_DX_A_MSMQ_NT4_STUB                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x40"
#define OMP_O_DX_A_MSMQ_OS_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x27"
#define OMP_O_DX_A_MSMQ_OUT_ROUTING_SERVERS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x20"
#define OMP_O_DX_A_MSMQ_OWNER_ID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1D"
#define OMP_O_DX_A_MSMQ_PREV_SITE_GATES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x49"
#define OMP_O_DX_A_MSMQ_PRIVACY_LEVEL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1C"
#define OMP_O_DX_A_MSMQ_QM_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x37"
#define OMP_O_DX_A_MSMQ_QUEUE_JOURNAL_QUOTA                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x43"
#define OMP_O_DX_A_MSMQ_QUEUE_NAME_EXT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5B"
#define OMP_O_DX_A_MSMQ_QUEUE_QUOTA                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x42"
#define OMP_O_DX_A_MSMQ_QUEUE_TYPE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x15"
#define OMP_O_DX_A_MSMQ_QUOTA                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x17"
#define OMP_O_DX_A_MSMQ_RECIPIENT_FORMATNAME                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1F"
#define OMP_O_DX_A_MSMQ_ROUTING_SERVICE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x55"
#define OMP_O_DX_A_MSMQ_ROUTING_SERVICES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4B"
#define OMP_O_DX_A_MSMQ_SECURED_SOURCE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x31"
#define OMP_O_DX_A_MSMQ_SERVICE_TYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x22"
#define OMP_O_DX_A_MSMQ_SERVICES                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x36"
#define OMP_O_DX_A_MSMQ_SIGN_CERTIFICATES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x33"
#define OMP_O_DX_A_MSMQ_SIGN_CERTIFICATES_MIG               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x47"
#define OMP_O_DX_A_MSMQ_SIGN_KEY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x29"
#define OMP_O_DX_A_MSMQ_SITE_1                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2F"
#define OMP_O_DX_A_MSMQ_SITE_2                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x30"
#define OMP_O_DX_A_MSMQ_SITE_FOREIGN                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x41"
#define OMP_O_DX_A_MSMQ_SITE_GATES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x31"
#define OMP_O_DX_A_MSMQ_SITE_GATES_MIG                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1E"
#define OMP_O_DX_A_MSMQ_SITE_ID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x39"
#define OMP_O_DX_A_MSMQ_SITE_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x45"
#define OMP_O_DX_A_MSMQ_SITE_NAME_EX                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x08"
#define OMP_O_DX_A_MSMQ_SITES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1F"
#define OMP_O_DX_A_MSMQ_TRANSACTIONAL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1E"
#define OMP_O_DX_A_MSMQ_USER_SID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x39"
#define OMP_O_DX_A_MSMQ_VERSION                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2E"
#define OMP_O_DX_A_MSNPALLOWDIALIN                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x5F"
#define OMP_O_DX_A_MSNPCALLEDSTATIONID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x63"
#define OMP_O_DX_A_MSNPCALLINGSTATIONID                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x64"
#define OMP_O_DX_A_MSNPSAVEDCALLINGSTATIONID                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x6A"
#define OMP_O_DX_A_MSRADIUSCALLBACKNUMBER                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x79"
#define OMP_O_DX_A_MSRADIUSFRAMEDIPADDRESS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x01"
#define OMP_O_DX_A_MSRADIUSFRAMEDROUTE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x06"
#define OMP_O_DX_A_MSRADIUSSERVICETYPE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x13"
#define OMP_O_DX_A_MSRASSAVEDCALLBACKNUMBER                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x25"
#define OMP_O_DX_A_MSRASSAVEDFRAMEDIPADDRESS                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x26"
#define OMP_O_DX_A_MSRASSAVEDFRAMEDROUTE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x27"
#define OMP_O_DX_A_MUST_CONTAIN                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x18"
#define OMP_O_DX_A_NAME_SERVICE_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x71"
#define OMP_O_DX_A_NC_NAME                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x10"
#define OMP_O_DX_A_NETBIOS_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x57"
#define OMP_O_DX_A_NETBOOT_ALLOW_NEW_CLIENTS                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x51"
#define OMP_O_DX_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x56"
#define OMP_O_DX_A_NETBOOT_ANSWER_REQUESTS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x55"
#define OMP_O_DX_A_NETBOOT_CURRENT_CLIENT_COUNT             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x54"
#define OMP_O_DX_A_NETBOOT_GUID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x67"
#define OMP_O_DX_A_NETBOOT_INITIALIZATION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x66"
#define OMP_O_DX_A_NETBOOT_INTELLIMIRROR_OSES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x59"
#define OMP_O_DX_A_NETBOOT_LIMIT_CLIENTS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x52"
#define OMP_O_DX_A_NETBOOT_LOCALLY_INSTALLED_OSES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5B"
#define OMP_O_DX_A_NETBOOT_MACHINE_FILE_PATH                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x69"
#define OMP_O_DX_A_NETBOOT_MAX_CLIENTS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x53"
#define OMP_O_DX_A_NETBOOT_MIRROR_DATA_FILE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x59"
#define OMP_O_DX_A_NETBOOT_NEW_MACHINE_NAMING_POLICY        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x57"
#define OMP_O_DX_A_NETBOOT_NEW_MACHINE_OU                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x58"
#define OMP_O_DX_A_NETBOOT_SCP_BL                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x60"
#define OMP_O_DX_A_NETBOOT_SERVER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5C"
#define OMP_O_DX_A_NETBOOT_SIF_FILE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x58"
#define OMP_O_DX_A_NETBOOT_TOOLS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5A"
#define OMP_O_DX_A_NETWORK_ADDRESS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x4B"
#define OMP_O_DX_A_NEXT_LEVEL_STORE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x56"
#define OMP_O_DX_A_NEXT_RID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x58"
#define OMP_O_DX_A_NON_SECURITY_MEMBER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x12"
#define OMP_O_DX_A_NON_SECURITY_MEMBER_BL                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x13"
#define OMP_O_DX_A_NOTIFICATION_LIST                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2F"
#define OMP_O_DX_A_NT_GROUP_MEMBERS                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x59"
#define OMP_O_DX_A_NT_MIXED_DOMAIN                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x65"
#define OMP_O_DX_A_NT_PWD_HISTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5E"
#define OMP_O_DX_A_NT_SECURITY_DESCRIPTOR                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x19"
#define OMP_O_DX_A_OBJECT_CATEGORY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0E"
#define OMP_O_DX_A_OBJECT_CLASS_CATEGORY                    "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x72"
#define OMP_O_DX_A_OBJECT_COUNT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7A"
#define OMP_O_DX_A_OBJECT_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x02"
#define OMP_O_DX_A_OBJECT_SID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x12"
#define OMP_O_DX_A_OBJECT_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x4C"
#define OMP_O_DX_A_OEM_INFORMATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x17"
#define OMP_O_DX_A_OM_OBJECT_CLASS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x5A"
#define OMP_O_DX_A_OM_SYNTAX                                "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x67"
#define OMP_O_DX_A_OMT_GUID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x79"
#define OMP_O_DX_A_OMT_INDX_GUID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4D"
#define OMP_O_DX_A_OPERATING_SYSTEM                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6B"
#define OMP_O_DX_A_OPERATING_SYSTEM_HOTFIX                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x1F"
#define OMP_O_DX_A_OPERATING_SYSTEM_SERVICE_PACK            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6D"
#define OMP_O_DX_A_OPERATING_SYSTEM_VERSION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6C"
#define OMP_O_DX_A_OPERATOR_COUNT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x10"
#define OMP_O_DX_A_OPTION_DESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x48"
#define OMP_O_DX_A_OPTIONS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x33"
#define OMP_O_DX_A_OPTIONS_LOCATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x49"
#define OMP_O_L0_A_ORGANIZATIONALSTATUS                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x2D"
#define OMP_O_DX_A_ORIGINAL_DISPLAY_TABLE                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x3D"
#define OMP_O_DX_A_ORIGINAL_DISPLAY_TABLE_MSDOS             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x56"
#define OMP_O_DX_A_OTHER_LOGIN_WORKSTATIONS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5B"
#define OMP_O_DX_A_OTHER_MAILBOX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0B"
#define OMP_O_L1_A_OTHER_NAME                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x22"
#define OMP_O_DX_A_OTHER_WELL_KNOWN_OBJECTS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4F"
#define OMP_O_DX_A_PACKAGE_FLAGS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x47"
#define OMP_O_DX_A_PACKAGE_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x46"
#define OMP_O_DX_A_PACKAGE_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x44"
#define OMP_O_DX_A_PARENT_CA                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x2D"
#define OMP_O_DX_A_PARENT_CA_CERTIFICATE_CHAIN              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2D"
#define OMP_O_DX_A_PARENT_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x48"
#define OMP_O_DX_A_PARTIAL_ATTRIBUTE_DELETION_LIST          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x17"
#define OMP_O_DX_A_PARTIAL_ATTRIBUTE_SET                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x00"
#define OMP_O_DX_A_PEK_KEY_CHANGE_INTERVAL                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x62"
#define OMP_O_DX_A_PEK_LIST                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x61"
#define OMP_O_DX_A_PENDING_CA_CERTIFICATES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x35"
#define OMP_O_DX_A_PENDING_PARENT_CA                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x37"
#define OMP_O_DX_A_PER_MSG_DIALOG_DISPLAY_TABLE             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x45"
#define OMP_O_DX_A_PER_RECIP_DIALOG_DISPLAY_TABLE           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x46"
#define OMP_O_DX_A_PERSONAL_TITLE                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x67"
#define OMP_O_DX_A_PHONE_FAX_OTHER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x06"
#define OMP_O_DX_A_PHONE_HOME_OTHER                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x15"
#define OMP_O_L0_A_PHONE_HOME_PRIMARY                       "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x14"
#define OMP_O_DX_A_PHONE_IP_OTHER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x52"
#define OMP_O_DX_A_PHONE_IP_PRIMARY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x51"
#define OMP_O_DX_A_PHONE_ISDN_PRIMARY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x09"
#define OMP_O_DX_A_PHONE_MOBILE_OTHER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x07"
#define OMP_O_L0_A_PHONE_MOBILE_PRIMARY                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x29"
#define OMP_O_DX_A_PHONE_OFFICE_OTHER                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x12"
#define OMP_O_DX_A_PHONE_PAGER_OTHER                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x76"
#define OMP_O_L0_A_PHONE_PAGER_PRIMARY                      "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x2A"
#define OMP_O_L0_A_PHOTO                                    "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x07"
#define OMP_O_DX_A_PHYSICAL_LOCATION_OBJECT                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x02"
#define OMP_O_L1_A_PICTURE                                  "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x23"
#define OMP_O_DX_A_PKI_CRITICAL_EXTENSIONS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x32"
#define OMP_O_DX_A_PKI_DEFAULT_CSPS                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x36"
#define OMP_O_DX_A_PKI_DEFAULT_KEY_SPEC                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x2F"
#define OMP_O_DX_A_PKI_ENROLLMENT_ACCESS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x37"
#define OMP_O_DX_A_PKI_EXPIRATION_PERIOD                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x33"
#define OMP_O_DX_A_PKI_EXTENDED_KEY_USAGE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x35"
#define OMP_O_DX_A_PKI_KEY_USAGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x30"
#define OMP_O_DX_A_PKI_MAX_ISSUING_DEPTH                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x31"
#define OMP_O_DX_A_PKI_OVERLAP_PERIOD                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x34"
#define OMP_O_DX_A_PKT                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4E"
#define OMP_O_DX_A_PKT_GUID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4D"
#define OMP_O_DX_A_POLICY_REPLICATION_FLAGS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x79"
#define OMP_O_DX_A_PORT_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x64"
#define OMP_O_DX_A_POSS_SUPERIORS                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x08"
#define OMP_O_DX_A_POSSIBLE_INFERIORS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x13"
#define OMP_O_L1_A_PREFERREDLANGUAGE                        "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x27"
#define OMP_O_DX_A_PREFERRED_OU                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x61"
#define OMP_O_DX_A_PREFIX_MAP                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1A"
#define OMP_O_DX_A_PREVIOUS_CA_CERTIFICATES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x34"
#define OMP_O_DX_A_PREVIOUS_PARENT_CA                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x36"
#define OMP_O_DX_A_PRIMARY_GROUP_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x62"
#define OMP_O_DX_A_PRIMARY_GROUP_TOKEN                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x04"
#define OMP_O_DX_A_PRINT_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x77"
#define OMP_O_DX_A_PRINT_BIN_NAMES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6D"
#define OMP_O_DX_A_PRINT_COLLATE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x72"
#define OMP_O_DX_A_PRINT_COLOR                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x73"
#define OMP_O_DX_A_PRINT_DUPLEX_SUPPORTED                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1F"
#define OMP_O_DX_A_PRINT_END_TIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6A"
#define OMP_O_DX_A_PRINT_FORM_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6B"
#define OMP_O_DX_A_PRINT_KEEP_PRINTED_JOBS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x13"
#define OMP_O_DX_A_PRINT_LANGUAGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x76"
#define OMP_O_DX_A_PRINT_MAC_ADDRESS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x20"
#define OMP_O_DX_A_PRINT_MAX_COPIES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x71"
#define OMP_O_DX_A_PRINT_MAX_RESOLUTION_SUPPORTED           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6E"
#define OMP_O_DX_A_PRINT_MAX_X_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x15"
#define OMP_O_DX_A_PRINT_MAX_Y_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x16"
#define OMP_O_DX_A_PRINT_MEDIA_READY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x21"
#define OMP_O_DX_A_PRINT_MEDIA_SUPPORTED                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2B"
#define OMP_O_DX_A_PRINT_MEMORY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1A"
#define OMP_O_DX_A_PRINT_MIN_X_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x17"
#define OMP_O_DX_A_PRINT_MIN_Y_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x18"
#define OMP_O_DX_A_PRINT_NETWORK_ADDRESS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1F"
#define OMP_O_DX_A_PRINT_NOTIFY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x10"
#define OMP_O_DX_A_PRINT_NUMBER_UP                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x22"
#define OMP_O_DX_A_PRINT_ORIENTATIONS_SUPPORTED             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x70"
#define OMP_O_DX_A_PRINT_OWNER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0F"
#define OMP_O_DX_A_PRINT_PAGES_PER_MINUTE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x77"
#define OMP_O_DX_A_PRINT_RATE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1D"
#define OMP_O_DX_A_PRINT_RATE_UNIT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1E"
#define OMP_O_DX_A_PRINT_SEPARATOR_FILE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x66"
#define OMP_O_DX_A_PRINT_SHARE_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0E"
#define OMP_O_DX_A_PRINT_SPOOLING                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x12"
#define OMP_O_DX_A_PRINT_STAPLING_SUPPORTED                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x19"
#define OMP_O_DX_A_PRINT_START_TIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x69"
#define OMP_O_DX_A_PRINT_STATUS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x11"
#define OMP_O_DX_A_PRINTER_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2C"
#define OMP_O_DX_A_PRIOR_SET_TIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x63"
#define OMP_O_DX_A_PRIOR_VALUE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x64"
#define OMP_O_DX_A_PRIORITY                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x67"
#define OMP_O_DX_A_PRIVATE_KEY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x65"
#define OMP_O_DX_A_PRIVILEGE_ATTRIBUTES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7C"
#define OMP_O_DX_A_PRIVILEGE_DISPLAY_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7A"
#define OMP_O_DX_A_PRIVILEGE_HOLDER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7D"
#define OMP_O_DX_A_PRIVILEGE_VALUE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7B"
#define OMP_O_DX_A_PRODUCT_CODE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x32"
#define OMP_O_DX_A_PROFILE_PATH                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0B"
#define OMP_O_DX_A_PROXIED_OBJECT_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x61"
#define OMP_O_DX_A_PROXY_ADDRESSES                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x52"
#define OMP_O_DX_A_PROXY_GENERATION_ENABLED                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x0B"
#define OMP_O_DX_A_PROXY_LIFETIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x67"
#define OMP_O_DX_A_PUBLIC_KEY_POLICY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x24"
#define OMP_O_DX_A_PURPORTED_SEARCH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x76"
#define OMP_O_DX_A_PWD_HISTORY_LENGTH                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5F"
#define OMP_O_DX_A_PWD_LAST_SET                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x60"
#define OMP_O_DX_A_PWD_PROPERTIES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5D"
#define OMP_O_DX_A_QUALITY_OF_SERVICE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x4A"
#define OMP_O_DX_A_QUERY_FILTER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4B"
#define OMP_O_DX_A_QUERY_POLICY_BL                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x60"
#define OMP_O_DX_A_QUERY_POLICY_OBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x5F"
#define OMP_O_DX_A_QUERYPOINT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x28"
#define OMP_O_DX_A_RANGE_LOWER                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x22"
#define OMP_O_DX_A_RANGE_UPPER                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x23"
#define OMP_O_DX_A_RDN                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x01"
#define OMP_O_DX_A_RDN_ATT_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x1A"
#define OMP_O_DX_A_REMOTE_SERVER_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x69"
#define OMP_O_DX_A_REMOTE_SOURCE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6B"
#define OMP_O_DX_A_REMOTE_SOURCE_TYPE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6C"
#define OMP_O_DX_A_REMOTE_STORAGE_GUID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x29"
#define OMP_O_DX_A_REPL_PROPERTY_META_DATA                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x03"
#define OMP_O_DX_A_REPL_TOPOLOGY_STAY_OF_EXECUTION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x25"
#define OMP_O_DX_A_REPL_UPTODATE_VECTOR                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x04"
#define OMP_O_DX_A_REPLICA_SOURCE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6D"
#define OMP_O_DX_A_REPORTS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x34"
#define OMP_O_DX_A_REPL_INTERVAL                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x38"
#define OMP_O_DX_A_REPS_FROM                                "\x2A\x86\x48\x86\xF7\x14\x01\x02\x5B"
#define OMP_O_DX_A_REPS_TO                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x53"
#define OMP_O_DX_A_REQUIRED_CATEGORIES                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x41"
#define OMP_O_DX_A_RETIRED_REPL_DSA_SIGNATURES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x21"
#define OMP_O_DX_A_TOKEN_GROUPS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x15"
#define OMP_O_DX_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x0A"
#define OMP_O_DX_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x17"
#define OMP_O_DX_A_REVISION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x11"
#define OMP_O_DX_A_RID                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x19"
#define OMP_O_DX_A_RID_ALLOCATION_POOL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x73"
#define OMP_O_DX_A_RID_AVAILABLE_POOL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x72"
#define OMP_O_DX_A_RID_MANAGER_REFERENCE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x70"
#define OMP_O_DX_A_RID_NEXT_RID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x76"
#define OMP_O_DX_A_RID_PREVIOUS_ALLOCATION_POOL             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x74"
#define OMP_O_DX_A_RID_SET_REFERENCES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1D"
#define OMP_O_DX_A_RID_USED_POOL                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x75"
#define OMP_O_DX_A_RIGHTS_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x54"
#define OMP_O_L0_A_ROOMNUMBER                               "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x06"
#define OMP_O_DX_A_ROOT_TRUST                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x22"
#define OMP_O_DX_A_RPC_NS_ANNOTATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6E"
#define OMP_O_DX_A_RPC_NS_BINDINGS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x71"
#define OMP_O_DX_A_RPC_NS_CODESET                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6F"
#define OMP_O_DX_A_RPC_NS_ENTRY_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x72"
#define OMP_O_DX_A_RPC_NS_GROUP                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x72"
#define OMP_O_DX_A_RPC_NS_INTERFACE_ID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x73"
#define OMP_O_DX_A_RPC_NS_OBJECT_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x38"
#define OMP_O_DX_A_RPC_NS_PRIORITY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x75"
#define OMP_O_DX_A_RPC_NS_PROFILE_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x76"
#define OMP_O_DX_A_RPC_NS_TRANSFER_SYNTAX                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x3A"
#define OMP_O_DX_A_SAM_ACCOUNT_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5D"
#define OMP_O_DX_A_SAM_ACCOUNT_TYPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2E"
#define OMP_O_DX_A_SCHEDULE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x53"
#define OMP_O_DX_A_SCHEMA_FLAGS_EX                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x78"
#define OMP_O_DX_A_SCHEMA_ID_GUID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x14"
#define OMP_O_DX_A_SCHEMA_INFO                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4E"
#define OMP_O_DX_A_SCHEMA_UPDATE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x61"
#define OMP_O_DX_A_SCHEMA_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x57"
#define OMP_O_DX_A_SCOPE_FLAGS                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4A"
#define OMP_O_DX_A_SCRIPT_PATH                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3E"
#define OMP_O_DX_A_SD_RIGHTS_EFFECTIVE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x18"
#define OMP_O_DX_A_SEARCH_FLAGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x4E"
#define OMP_O_L0_A_SECRETARY                                "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x15"
#define OMP_O_DX_A_SECURITY_IDENTIFIER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x79"
#define OMP_O_DX_A_SEQ_NOTIFICATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x78"
#define OMP_O_DX_A_SERVER_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5F"
#define OMP_O_DX_A_SERVER_REFERENCE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x03"
#define OMP_O_DX_A_SERVER_REFERENCE_BL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x04"
#define OMP_O_DX_A_SERVER_ROLE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1D"
#define OMP_O_DX_A_SERVER_STATE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1A"
#define OMP_O_DX_A_SERVICE_BINDING_INFORMATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7E"
#define OMP_O_DX_A_SERVICE_CLASS_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7A"
#define OMP_O_DX_A_SERVICE_CLASS_INFO                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7B"
#define OMP_O_DX_A_SERVICE_CLASS_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7D"
#define OMP_O_DX_A_SERVICE_DNS_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x11"
#define OMP_O_DX_A_SERVICE_DNS_NAME_TYPE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x13"
#define OMP_O_DX_A_SERVICE_INSTANCE_VERSION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x47"
#define OMP_O_DX_A_SERVICE_PRINCIPAL_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x03"
#define OMP_O_DX_A_SETUP_COMMAND                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x45"
#define OMP_O_DX_A_SHELL_CONTEXT_MENU                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x67"
#define OMP_O_DX_A_SHELL_PROPERTY_PAGES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x33"
#define OMP_O_DX_A_SHORT_SERVER_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x39"
#define OMP_O_DX_A_SHOW_IN_ADDRESS_BOOK                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x04"
#define OMP_O_DX_A_SHOW_IN_ADVANCED_VIEW_ONLY               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x29"
#define OMP_O_DX_A_SID_HISTORY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x61"
#define OMP_O_DX_A_SIGNATURE_ALGORITHMS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x38"
#define OMP_O_DX_A_SITE_GUID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6A"
#define OMP_O_DX_A_SITE_LINK_LIST                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x36"
#define OMP_O_DX_A_SITE_LIST                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x35"
#define OMP_O_DX_A_SITE_OBJECT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x00"
#define OMP_O_DX_A_SITE_OBJECT_BL                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x01"
#define OMP_O_DX_A_SITE_SERVER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6E"
#define OMP_O_DX_A_SMTP_MAIL_ADDRESS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x12"
#define OMP_O_DX_A_SPN_MAPPINGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x43"
#define OMP_O_DX_A_SUB_CLASS_OF                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x15"
#define OMP_O_DX_A_SUB_REFS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x07"
#define OMP_O_DX_A_SUPER_SCOPE_DESCRIPTION                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x47"
#define OMP_O_DX_A_SUPER_SCOPES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x46"
#define OMP_O_DX_A_SUPERIOR_DNS_ROOT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x14"
#define OMP_O_DX_A_SUPPLEMENTAL_CREDENTIALS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7D"
#define OMP_O_DX_A_SYNC_ATTRIBUTES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1A"
#define OMP_O_DX_A_SYNC_MEMBERSHIP                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x19"
#define OMP_O_DX_A_SYNC_WITH_OBJECT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x18"
#define OMP_O_DX_A_SYNC_WITH_SID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1B"
#define OMP_O_DX_A_SYSTEM_AUXILIARY_CLASS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x46"
#define OMP_O_DX_A_SYSTEM_FLAGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x77"
#define OMP_O_DX_A_SYSTEM_MAY_CONTAIN                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x44"
#define OMP_O_DX_A_SYSTEM_MUST_CONTAIN                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x45"
#define OMP_O_DX_A_SYSTEM_ONLY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x2A"
#define OMP_O_DX_A_SYSTEM_POSS_SUPERIORS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x43"
#define OMP_O_DX_A_TELEX_PRIMARY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x08"
#define OMP_O_DX_A_TEMPLATE_ROOTS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x42"
#define OMP_O_DX_A_TERMINAL_SERVER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x75"
#define OMP_O_DX_A_TEXT_COUNTRY                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x03"
#define OMP_O_L0_A_TEXT_ENCODED_OR_ADDRESS                  "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x02"
#define OMP_O_DX_A_TIME_REFRESH                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x77"
#define OMP_O_DX_A_TIME_VOL_CHANGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x76"
#define OMP_O_DX_A_TOMBSTONE_LIFETIME                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x36"
#define OMP_O_DX_A_TRANSPORT_ADDRESS_ATTRIBUTE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7F"
#define OMP_O_DX_A_TRANSPORT_DLL_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x15"
#define OMP_O_DX_A_TRANSPORT_TYPE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x17"
#define OMP_O_DX_A_TREAT_AS_LEAF                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x26"
#define OMP_O_DX_A_TREE_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x14"
#define OMP_O_DX_A_TRUST_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x56"
#define OMP_O_DX_A_TRUST_AUTH_INCOMING                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x01"
#define OMP_O_DX_A_TRUST_AUTH_OUTGOING                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x07"
#define OMP_O_DX_A_TRUST_DIRECTION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x04"
#define OMP_O_DX_A_TRUST_PARENT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x57"
#define OMP_O_DX_A_TRUST_PARTNER                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x05"
#define OMP_O_DX_A_TRUST_POSIX_OFFSET                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x06"
#define OMP_O_DX_A_TRUST_TYPE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x08"
#define OMP_O_DX_A_UAS_COMPAT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1B"
#define OMP_O_L0_A_UID                                      "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x01"
#define OMP_O_DX_A_UNC_NAME                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x09"
#define OMP_O_DX_A_UNICODE_PWD                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5A"
#define OMP_O_L0_A_UNIQUEIDENTIFIER                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x2C"
#define OMP_O_DX_A_UPGRADE_PRODUCT_CODE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2D"
#define OMP_O_DX_A_UPN_SUFFIXES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7A"
#define OMP_O_DX_A_USER_ACCOUNT_CONTROL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x08"
#define OMP_O_DX_A_USER_CERT                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x05"
#define OMP_O_DX_A_USER_COMMENT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1C"
#define OMP_O_DX_A_USER_PARAMETERS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0A"
#define OMP_O_L0_A_USERCLASS                                "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x08"
#define OMP_O_L1_A_USERPKCS12                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x81\x58"
#define OMP_O_DX_A_USER_PRINCIPAL_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x10"
#define OMP_O_DX_A_USER_SHARED_FOLDER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6F"
#define OMP_O_DX_A_USER_SHARED_FOLDER_OTHER                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x70"
#define OMP_O_L1_A_USER_SMIME_CERTIFICATE                   "\x60\x86\x48\x01\x86\xF8\x42\x03\x81\x0C"
#define OMP_O_DX_A_USER_WORKSTATIONS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x56"
#define OMP_O_DX_A_USN_CHANGED                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x78"
#define OMP_O_DX_A_USN_CREATED                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x13"
#define OMP_O_DX_A_USN_DSA_LAST_OBJ_REMOVED                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x0B"
#define OMP_O_DX_A_USN_INTERSITE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x55"
#define OMP_O_DX_A_USN_LAST_OBJ_REM                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x79"
#define OMP_O_DX_A_USN_SOURCE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x00"
#define OMP_O_DX_A_VALID_ACCESSES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4C"
#define OMP_O_DX_A_VENDOR                                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7F"
#define OMP_O_DX_A_VERSION_NUMBER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0D"
#define OMP_O_DX_A_VERSION_NUMBER_HI                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x48"
#define OMP_O_DX_A_VERSION_NUMBER_LO                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x49"
#define OMP_O_DX_A_VOL_TABLE_GUID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x50"
#define OMP_O_DX_A_VOL_TABLE_IDX_GUID                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4E"
#define OMP_O_DX_A_VOLUME_COUNT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7B"
#define OMP_O_DX_A_WBEM_PATH                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2D"
#define OMP_O_DX_A_WELL_KNOWN_OBJECTS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6A"
#define OMP_O_DX_A_WHEN_CHANGED                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x03"
#define OMP_O_DX_A_WHEN_CREATED                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x02"
#define OMP_O_DX_A_WINSOCK_ADDRESSES                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0E"
#define OMP_O_DX_A_WWW_HOME_PAGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x50"
#define OMP_O_DX_A_WWW_PAGE_OTHER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6D"
//
//Class Definitions
//
#define OMP_O_L0_O_ACCOUNT                                  "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x05"
#define OMP_O_DX_O_ACS_POLICY                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x09"
#define OMP_O_DX_O_ACS_RESOURCE_LIMITS                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3F"
#define OMP_O_DX_O_ACS_SUBNET                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0A"
#define OMP_O_DX_O_ADDRESS_BOOK_CONTAINER                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x7D"
#define OMP_O_DX_O_ADDRESS_TEMPLATE                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x3A"
#define OMP_O_DX_O_APPLICATION_SETTINGS                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x31"
#define OMP_O_DX_O_APPLICATION_SITE_SETTINGS                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x44"
#define OMP_O_DX_O_APPLICATION_VERSION                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x58"
#define OMP_O_DX_O_ATTRIBUTE_SCHEMA                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0E"
#define OMP_O_DX_O_BUILTIN_DOMAIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x04"
#define OMP_O_DX_O_CATEGORY_REGISTRATION                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4A"
#define OMP_O_DX_O_CLASS_REGISTRATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0A"
#define OMP_O_DX_O_CLASS_SCHEMA                             "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0D"
#define OMP_O_DX_O_CLASS_STORE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2C"
#define OMP_O_DX_O_COM_CONNECTION_POINT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0B"
#define OMP_O_DX_O_COMPUTER                                 "\x2A\x86\x48\x86\xF7\x14\x01\x03\x1E"
#define OMP_O_DX_O_CONFIGURATION                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0C"
#define OMP_O_DX_O_CONNECTION_POINT                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0E"
#define OMP_O_DX_O_CONTACT                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0F"
#define OMP_O_DX_O_CONTAINER                                "\x2A\x86\x48\x86\xF7\x14\x01\x03\x17"
#define OMP_O_DX_O_CONTROL_ACCESS_RIGHT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4D"
#define OMP_O_DX_O_CROSS_REF                                "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0B"
#define OMP_O_DX_O_CROSS_REF_CONTAINER                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x35"
#define OMP_O_DX_O_DFS_CONFIGURATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2A"
#define OMP_O_DX_O_DHCP_CLASS                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x04"
#define OMP_O_DX_O_DISPLAY_SPECIFIER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x54"
#define OMP_O_DX_O_DISPLAY_TEMPLATE                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x3B"
#define OMP_O_DX_O_DMD                                      "\x2A\x86\x48\x86\xF7\x14\x01\x03\x09"
#define OMP_O_DX_O_DNS_NODE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x56"
#define OMP_O_DX_O_DNS_ZONE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x55"
#define OMP_O_L0_O_DOCUMENT                                 "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x06"
#define OMP_O_L0_O_DOCUMENTSERIES                           "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x09"
#define OMP_O_DX_O_DOMAIN                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x42"
#define OMP_O_DX_O_DOMAIN_DNS                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x43"
#define OMP_O_DX_O_DOMAIN_POLICY                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x12"
#define OMP_O_L0_O_DOMAINRELATEDOBJECT                      "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x11"
#define OMP_O_DX_O_DS_UI_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x37"
#define OMP_O_DX_O_FILE_LINK_TRACKING                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x34"
#define OMP_O_DX_O_FILE_LINK_TRACKING_ENTRY                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x3B"
#define OMP_O_DX_O_FOREIGN_SECURITY_PRINCIPAL               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4C"
#define OMP_O_L0_O_FRIENDLYCOUNTRY                          "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x12"
#define OMP_O_DX_O_FT_DFS                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2B"
#define OMP_O_DX_O_GROUP                                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x08"
#define OMP_O_DX_O_GROUP_POLICY_CONTAINER                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1D"
#define OMP_O_DX_O_INDEX_SERVER_CATALOG                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x02"
#define OMP_O_L1_O_INETORGPERSON                            "\x60\x86\x48\x01\x86\xF8\x42\x03\x02\x02"
#define OMP_O_DX_O_INFRASTRUCTURE_UPDATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x2F"
#define OMP_O_DX_O_INTELLIMIRROR_GROUP                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x18"
#define OMP_O_DX_O_INTELLIMIRROR_SCP                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x17"
#define OMP_O_DX_O_INTER_SITE_TRANSPORT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0D"
#define OMP_O_DX_O_INTER_SITE_TRANSPORT_CONTAINER           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0C"
#define OMP_O_DX_O_IPSEC_BASE                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x38"
#define OMP_O_DX_O_IPSEC_FILTER                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x76"
#define OMP_O_DX_O_IPSEC_ISAKMP_POLICY                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x78"
#define OMP_O_DX_O_IPSEC_NEGOTIATION_POLICY                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x77"
#define OMP_O_DX_O_IPSEC_NFA                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x79"
#define OMP_O_DX_O_IPSEC_POLICY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x62"
#define OMP_O_DX_O_LEAF                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x14"
#define OMP_O_DX_O_LICENSING_SITE_SETTINGS                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4E"
#define OMP_O_DX_O_LINK_TRACK_OBJECT_MOVE_TABLE             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5B"
#define OMP_O_DX_O_LINK_TRACK_OMT_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5D"
#define OMP_O_DX_O_LINK_TRACK_VOL_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5C"
#define OMP_O_DX_O_LINK_TRACK_VOLUME_TABLE                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5A"
#define OMP_O_DX_O_LOST_AND_FOUND                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0B"
#define OMP_O_DX_O_MAIL_RECIPIENT                           "\x2A\x86\x48\x86\xF7\x14\x01\x03\x2E"
#define OMP_O_DX_O_MEETING                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x68"
#define OMP_O_DX_O_MS_COM_PARTITION                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x41"
#define OMP_O_DX_O_MS_COM_PARTITIONSET                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x42"
#define OMP_O_DX_O_MS_DS_APP_CONFIGURATION                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5C"
#define OMP_O_DX_O_MS_DS_APP_DATA                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x71"
#define OMP_O_DX_O_MS_DS_AZ_ADMIN_MANAGER                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6A"
#define OMP_O_DX_O_MS_DS_AZ_APPLICATION                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6B"
#define OMP_O_DX_O_MS_DS_AZ_OPERATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6C"
#define OMP_O_DX_O_MS_DS_AZ_ROLE                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6F"
#define OMP_O_DX_O_MS_DS_AZ_SCOPE                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6D"
#define OMP_O_DX_O_MS_DS_AZ_TASK                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x6E"
#define OMP_O_DX_O_MS_DS_QUOTA_CONTAINER                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x72"
#define OMP_O_DX_O_MS_DS_QUOTA_CONTROL                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x73"
#define OMP_O_DX_O_MS_EXCH_CONFIGURATION_CONTAINER          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x30"
#define OMP_O_DX_O_MS_IEEE_80211_POLICY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x70"
#define OMP_O_DX_O_MS_PKI_ENTERPRISE_OID                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x44"
#define OMP_O_DX_O_MS_PKI_KEY_RECOVERY_AGENT                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x43"
#define OMP_O_DX_O_MS_SQL_SQLSERVER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x38"
#define OMP_O_DX_O_MS_SQL_OLAPSERVER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x39"
#define OMP_O_DX_O_MS_SQL_SQLREPOSITORY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3A"
#define OMP_O_DX_O_MS_SQL_SQLPUBLICATION                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3B"
#define OMP_O_DX_O_MS_SQL_SQLDATABASE                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3C"
#define OMP_O_DX_O_MS_SQL_OLAPDATABASE                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3D"
#define OMP_O_DX_O_MS_SQL_OLAPCUBE                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3E"
#define OMP_O_DX_O_MS_TAPI_RT_CONFERENCE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5D"
#define OMP_O_DX_O_MS_TAPI_RT_PERSON                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5E"
#define OMP_O_DX_O_MS_WMI_INTRANGEPARAM                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4D"
#define OMP_O_DX_O_MS_WMI_INTSETPARAM                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4E"
#define OMP_O_DX_O_MS_WMI_MERGEABLEPOLICYTEMPLATE           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4A"
#define OMP_O_DX_O_MS_WMI_OBJECTENCODING                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x59"
#define OMP_O_DX_O_MS_WMI_POLICYTEMPLATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x48"
#define OMP_O_DX_O_MS_WMI_POLICYTYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x53"
#define OMP_O_DX_O_MS_WMI_RANGEPARAM                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4B"
#define OMP_O_DX_O_MS_WMI_REALRANGEPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x51"
#define OMP_O_DX_O_MS_WMI_RULE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x56"
#define OMP_O_DX_O_MS_WMI_SHADOWOBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x54"
#define OMP_O_DX_O_MS_WMI_SIMPLEPOLICYTEMPLATE              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x49"
#define OMP_O_DX_O_MS_WMI_SOM                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x55"
#define OMP_O_DX_O_MS_WMI_STRINGSETPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x52"
#define OMP_O_DX_O_MS_WMI_UINTRANGEPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4F"
#define OMP_O_DX_O_MS_WMI_UINTSETPARAM                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x50"
#define OMP_O_DX_O_MS_WMI_UNKNOWNRANGEPARAM                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4C"
#define OMP_O_DX_O_MS_WMI_WMIGPO                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x57"
#define OMP_O_DX_O_MSMQ_CONFIGURATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x22"
#define OMP_O_DX_O_MSMQ_CUSTOM_RECIPIENT                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5A"
#define OMP_O_DX_O_MSMQ_ENTERPRISE_SETTINGS                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x23"
#define OMP_O_DX_O_MSMQ_GROUP                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5B"
#define OMP_O_DX_O_MSMQ_MIGRATED_USER                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x33"
#define OMP_O_DX_O_MSMQ_QUEUE                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x21"
#define OMP_O_DX_O_MSMQ_SETTINGS                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x25"
#define OMP_O_DX_O_MSMQ_SITE_LINK                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x24"
#define OMP_O_DX_O_NTDS_CONNECTION                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x47"
#define OMP_O_DX_O_NTDS_DSA                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x2F"
#define OMP_O_DX_O_NTDS_SERVICE                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x48"
#define OMP_O_DX_O_NTDS_SITE_SETTINGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x45"
#define OMP_O_DX_O_NTFRS_MEMBER                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x19"
#define OMP_O_DX_O_NTFRS_REPLICA_SET                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x66"
#define OMP_O_DX_O_NTFRS_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x59"
#define OMP_O_DX_O_NTFRS_SUBSCRIBER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1B"
#define OMP_O_DX_O_NTFRS_SUBSCRIPTIONS                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1A"
#define OMP_O_DX_O_PACKAGE_REGISTRATION                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x31"
#define OMP_O_DX_O_PHYSICAL_LOCATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x61"
#define OMP_O_DX_O_PKI_CERTIFICATE_TEMPLATE                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x31"
#define OMP_O_DX_O_PKI_ENROLLMENT_SERVICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x32"
#define OMP_O_DX_O_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5F"
#define OMP_O_DX_O_PRINT_QUEUE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x17"
#define OMP_O_DX_O_QUERY_POLICY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x6A"
#define OMP_O_DX_O_REMOTE_MAIL_RECIPIENT                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x18"
#define OMP_O_DX_O_REMOTE_STORAGE_SERVICE_POINT             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x12"
#define OMP_O_L0_O_RFC822LOCALPART                          "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x0E"
#define OMP_O_DX_O_RID_MANAGER                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x53"
#define OMP_O_DX_O_RID_SET                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x01"
#define OMP_O_L0_O_ROOM                                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x07"
#define OMP_O_DX_O_RPC_CONTAINER                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x08"
#define OMP_O_DX_O_RPC_ENTRY                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1B"
#define OMP_O_DX_O_RPC_GROUP                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x50"
#define OMP_O_DX_O_RPC_PROFILE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x52"
#define OMP_O_DX_O_RPC_PROFILE_ELEMENT                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1A"
#define OMP_O_DX_O_RPC_SERVER                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x51"
#define OMP_O_DX_O_RPC_SERVER_ELEMENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x49"
#define OMP_O_DX_O_RRAS_ADMINISTRATION_CONNECTION_POINT     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x16"
#define OMP_O_DX_O_RRAS_ADMINISTRATION_DICTIONARY           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1C"
#define OMP_O_DX_O_SAM_DOMAIN                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x03"
#define OMP_O_DX_O_SAM_DOMAIN_BASE                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x02"
#define OMP_O_DX_O_SAM_SERVER                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x05"
#define OMP_O_DX_O_SECRET                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1C"
#define OMP_O_DX_O_SECURITY_OBJECT                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x01"
#define OMP_O_DX_O_SECURITY_PRINCIPAL                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x06"
#define OMP_O_DX_O_SERVER                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x11"
#define OMP_O_DX_O_SERVERS_CONTAINER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x30"
#define OMP_O_DX_O_SERVICE_ADMINISTRATION_POINT             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5E"
#define OMP_O_DX_O_SERVICE_CLASS                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1D"
#define OMP_O_DX_O_SERVICE_CONNECTION_POINT                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x7E"
#define OMP_O_DX_O_SERVICE_INSTANCE                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1E"
#define OMP_O_L0_O_SIMPLESECURITYOBJECT                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04\x13"
#define OMP_O_DX_O_SITE                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1F"
#define OMP_O_DX_O_SITE_LINK                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x13"
#define OMP_O_DX_O_SITE_LINK_BRIDGE                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x14"
#define OMP_O_DX_O_SITES_CONTAINER                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x6B"
#define OMP_O_DX_O_STORAGE                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x21"
#define OMP_O_DX_O_SUBNET                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x60"
#define OMP_O_DX_O_SUBNET_CONTAINER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5F"
#define OMP_O_DX_O_TRUSTED_DOMAIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x22"
#define OMP_O_DX_O_TYPE_LIBRARY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x35"
#define OMP_O_DX_O_USER                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x09"
#define OMP_O_DX_O_VOLUME                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x24"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\msdsmapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       msdsmapi.h
//
//--------------------------------------------------------------------------

/*++
 File:    MSDSMAPI.H
 Purpose: Contains the MAPI Definition .
 Creator: Automatically Generated on
 Date:    Thu Dec 21 10:55:04 2000

 ** This is a Generated File From Schema.INI **
 ** DO NOT MODIFY  DIRECTLY  **
 ** DO NOT INCLUDE DIRECTLY  **

--*/
#define PR_EMS_AB_ADDRESS                                       PROP_TAG(PT_TSTRING            , 0x3A29)
#define PR_EMS_AB_ADDRESS_A                                     PROP_TAG(PT_STRING8            , 0x3A29)
#define PR_EMS_AB_ADDRESS_W                                     PROP_TAG(PT_UNICODE            , 0x3A29)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE                   PROP_TAG(PT_BINARY             , 0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS             PROP_TAG(PT_BINARY             , 0x8047)
#define PR_EMS_AB_ADDRESS_HOME                                  PROP_TAG(PT_TSTRING            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_HOME_A                                PROP_TAG(PT_STRING8            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_HOME_W                                PROP_TAG(PT_UNICODE            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_SYNTAX                                PROP_TAG(PT_BINARY             , 0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                                  PROP_TAG(PT_TSTRING            , 0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A                                PROP_TAG(PT_STRING8            , 0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W                                PROP_TAG(PT_UNICODE            , 0x8048)
#define PR_EMS_AB_ADMIN_DESCRIPTION                             PROP_TAG(PT_TSTRING            , 0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A                           PROP_TAG(PT_STRING8            , 0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W                           PROP_TAG(PT_UNICODE            , 0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME                            PROP_TAG(PT_TSTRING            , 0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A                          PROP_TAG(PT_STRING8            , 0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W                          PROP_TAG(PT_UNICODE            , 0x804B)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST                     PROP_TAG(PT_MV_BINARY          , 0x8026)
#define PR_EMS_AB_BUSINESS_CATEGORY                             PROP_TAG(PT_MV_TSTRING         , 0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A                           PROP_TAG(PT_MV_STRING8         , 0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W                           PROP_TAG(PT_MV_UNICODE         , 0x8057)
#define PR_EMS_AB_CA_CERTIFICATE                                PROP_TAG(PT_MV_BINARY          , 0x8003)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST                   PROP_TAG(PT_BINARY             , 0x8016)
#define PR_EMS_AB_COMMENT                                       PROP_TAG(PT_TSTRING            , 0x3004)
#define PR_EMS_AB_COMMENT_A                                     PROP_TAG(PT_STRING8            , 0x3004)
#define PR_EMS_AB_COMMENT_W                                     PROP_TAG(PT_UNICODE            , 0x3004)
#define PR_EMS_AB_COMMON_NAME                                   PROP_TAG(PT_TSTRING            , 0x3A0F)
#define PR_EMS_AB_COMMON_NAME_A                                 PROP_TAG(PT_STRING8            , 0x3A0F)
#define PR_EMS_AB_COMMON_NAME_W                                 PROP_TAG(PT_UNICODE            , 0x3A0F)
#define PR_EMS_AB_COMPANY                                       PROP_TAG(PT_TSTRING            , 0x3a16)
#define PR_EMS_AB_COMPANY_A                                     PROP_TAG(PT_STRING8            , 0x3a16)
#define PR_EMS_AB_COMPANY_W                                     PROP_TAG(PT_UNICODE            , 0x3a16)
#define PR_EMS_AB_COST                                          PROP_TAG(PT_LONG               , 0x8068)
#define PR_EMS_AB_COUNTRY_NAME                                  PROP_TAG(PT_TSTRING            , 0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A                                PROP_TAG(PT_STRING8            , 0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W                                PROP_TAG(PT_UNICODE            , 0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR                        PROP_TAG(PT_MV_BINARY          , 0x8025)
#define PR_EMS_AB_DELTA_REVOCATION_LIST                         PROP_TAG(PT_MV_BINARY          , 0x8C46)
#define PR_EMS_AB_DEPARTMENT                                    PROP_TAG(PT_TSTRING            , 0x3A18)
#define PR_EMS_AB_DEPARTMENT_A                                  PROP_TAG(PT_STRING8            , 0x3A18)
#define PR_EMS_AB_DEPARTMENT_W                                  PROP_TAG(PT_UNICODE            , 0x3A18)
#define PR_EMS_AB_DESCRIPTION                                   PROP_TAG(PT_MV_TSTRING         , 0x806F)
#define PR_EMS_AB_DESCRIPTION_A                                 PROP_TAG(PT_MV_STRING8         , 0x806F)
#define PR_EMS_AB_DESCRIPTION_W                                 PROP_TAG(PT_MV_UNICODE         , 0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR                         PROP_TAG(PT_MV_TSTRING         , 0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A                       PROP_TAG(PT_MV_STRING8         , 0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W                       PROP_TAG(PT_MV_UNICODE         , 0x8070)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE                        PROP_TAG(PT_TSTRING            , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A                      PROP_TAG(PT_STRING8            , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W                      PROP_TAG(PT_UNICODE            , 0x39FF)
#define PR_EMS_AB_DMD_NAME                                      PROP_TAG(PT_TSTRING            , 0x8C56)
#define PR_EMS_AB_DMD_NAME_A                                    PROP_TAG(PT_STRING8            , 0x8C56)
#define PR_EMS_AB_DMD_NAME_W                                    PROP_TAG(PT_UNICODE            , 0x8C56)
#define PR_EMS_AB_DSA_SIGNATURE                                 PROP_TAG(PT_BINARY             , 0x8077)
#define PR_EMS_AB_E_MAIL_ADDRESSES                              PROP_TAG(PT_TSTRING            , 0x39FE)
#define PR_EMS_AB_E_MAIL_ADDRESSES_A                            PROP_TAG(PT_STRING8            , 0x39FE)
#define PR_EMS_AB_E_MAIL_ADDRESSES_W                            PROP_TAG(PT_UNICODE            , 0x39FE)
#define PR_EMS_AB_EMPLOYEE_NUMBER                               PROP_TAG(PT_TSTRING            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_NUMBER_A                             PROP_TAG(PT_STRING8            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_NUMBER_W                             PROP_TAG(PT_UNICODE            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_TYPE                                 PROP_TAG(PT_TSTRING            , 0x8C69)
#define PR_EMS_AB_EMPLOYEE_TYPE_A                               PROP_TAG(PT_STRING8            , 0x8C69)
#define PR_EMS_AB_EMPLOYEE_TYPE_W                               PROP_TAG(PT_UNICODE            , 0x8C69)
#define PR_EMS_AB_ENABLED                                       PROP_TAG(PT_BOOLEAN            , 0x8C21)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED                        PROP_TAG(PT_BOOLEAN            , 0x80A7)
#define PR_EMS_AB_EXTENSION_NAME                                PROP_TAG(PT_MV_TSTRING         , 0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A                              PROP_TAG(PT_MV_STRING8         , 0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W                              PROP_TAG(PT_MV_UNICODE         , 0x80A9)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER                    PROP_TAG(PT_TSTRING            , 0x3a23)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER_A                  PROP_TAG(PT_STRING8            , 0x3a23)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER_W                  PROP_TAG(PT_UNICODE            , 0x3a23)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD                           PROP_TAG(PT_LONG               , 0x80AF)
#define PR_EMS_AB_GENERATION_QUALIFIER                          PROP_TAG(PT_TSTRING            , 0x8C53)
#define PR_EMS_AB_GENERATION_QUALIFIER_A                        PROP_TAG(PT_STRING8            , 0x8C53)
#define PR_EMS_AB_GENERATION_QUALIFIER_W                        PROP_TAG(PT_UNICODE            , 0x8C53)
#define PR_EMS_AB_GIVEN_NAME                                    PROP_TAG(PT_TSTRING            , 0x3A06)
#define PR_EMS_AB_GIVEN_NAME_A                                  PROP_TAG(PT_STRING8            , 0x3A06)
#define PR_EMS_AB_GIVEN_NAME_W                                  PROP_TAG(PT_UNICODE            , 0x3A06)
#define PR_EMS_AB_HAS_MASTER_NCS                                PROP_TAG(PT_MV_OBJECT          , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A                              PROP_TAG(PT_MV_STRING8         , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W                              PROP_TAG(PT_MV_UNICODE         , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O                              PROP_TAG(PT_MV_OBJECT          , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T                              PROP_TAG(PT_MV_TSTRING         , 0x80B6)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS                       PROP_TAG(PT_MV_OBJECT          , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_A                     PROP_TAG(PT_MV_STRING8         , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_W                     PROP_TAG(PT_MV_UNICODE         , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_O                     PROP_TAG(PT_MV_OBJECT          , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_T                     PROP_TAG(PT_MV_TSTRING         , 0x80B5)
#define PR_EMS_AB_HELP_DATA16                                   PROP_TAG(PT_BINARY             , 0x803A)
#define PR_EMS_AB_HELP_DATA32                                   PROP_TAG(PT_BINARY             , 0x8010)
#define PR_EMS_AB_HELP_FILE_NAME                                PROP_TAG(PT_TSTRING            , 0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A                              PROP_TAG(PT_STRING8            , 0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W                              PROP_TAG(PT_UNICODE            , 0x803B)
#define PR_EMS_AB_INITIALS                                      PROP_TAG(PT_TSTRING            , 0x3A0A)
#define PR_EMS_AB_INITIALS_A                                    PROP_TAG(PT_STRING8            , 0x3A0A)
#define PR_EMS_AB_INITIALS_W                                    PROP_TAG(PT_UNICODE            , 0x3A0A)
#define PR_EMS_AB_INSTANCE_TYPE                                 PROP_TAG(PT_LONG               , 0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER                     PROP_TAG(PT_MV_TSTRING         , 0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A                   PROP_TAG(PT_MV_STRING8         , 0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W                   PROP_TAG(PT_MV_UNICODE         , 0x80BE)
#define PR_EMS_AB_INVOCATION_ID                                 PROP_TAG(PT_BINARY             , 0x80BF)
#define PR_EMS_AB_IS_DELETED                                    PROP_TAG(PT_BOOLEAN            , 0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL                               PROP_TAG(PT_MV_OBJECT          , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A                             PROP_TAG(PT_MV_STRING8         , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W                             PROP_TAG(PT_MV_UNICODE         , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O                             PROP_TAG(PT_MV_OBJECT          , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T                             PROP_TAG(PT_MV_TSTRING         , 0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED                              PROP_TAG(PT_BOOLEAN            , 0x80C1)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION                         PROP_TAG(PT_MV_TSTRING         , 0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A                       PROP_TAG(PT_MV_STRING8         , 0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W                       PROP_TAG(PT_MV_UNICODE         , 0x80C3)
#define PR_EMS_AB_LDAP_DISPLAY_NAME                             PROP_TAG(PT_TSTRING            , 0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A                           PROP_TAG(PT_STRING8            , 0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W                           PROP_TAG(PT_UNICODE            , 0x8171)
#define PR_EMS_AB_LINK_ID                                       PROP_TAG(PT_LONG               , 0x80C5)
#define PR_EMS_AB_LOCALITY_NAME                                 PROP_TAG(PT_TSTRING            , 0x3A27)
#define PR_EMS_AB_LOCALITY_NAME_A                               PROP_TAG(PT_STRING8            , 0x3A27)
#define PR_EMS_AB_LOCALITY_NAME_W                               PROP_TAG(PT_UNICODE            , 0x3A27)
#define PR_EMS_AB_MANAGED_BY                                    PROP_TAG(PT_OBJECT             , 0x800C)
#define PR_EMS_AB_MANAGED_BY_A                                  PROP_TAG(PT_STRING8            , 0x800C)
#define PR_EMS_AB_MANAGED_BY_W                                  PROP_TAG(PT_UNICODE            , 0x800C)
#define PR_EMS_AB_MANAGED_BY_O                                  PROP_TAG(PT_OBJECT             , 0x800C)
#define PR_EMS_AB_MANAGED_BY_T                                  PROP_TAG(PT_TSTRING            , 0x800C)
#define PR_EMS_AB_MANAGED_OBJECTS                               PROP_TAG(PT_MV_OBJECT          , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_A                             PROP_TAG(PT_MV_STRING8         , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_W                             PROP_TAG(PT_MV_UNICODE         , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_O                             PROP_TAG(PT_MV_OBJECT          , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_T                             PROP_TAG(PT_MV_TSTRING         , 0x8024)
#define PR_EMS_AB_MANAGER                                       PROP_TAG(PT_OBJECT             , 0x8005)
#define PR_EMS_AB_MANAGER_A                                     PROP_TAG(PT_STRING8            , 0x8005)
#define PR_EMS_AB_MANAGER_W                                     PROP_TAG(PT_UNICODE            , 0x8005)
#define PR_EMS_AB_MANAGER_O                                     PROP_TAG(PT_OBJECT             , 0x8005)
#define PR_EMS_AB_MANAGER_T                                     PROP_TAG(PT_TSTRING            , 0x8005)
#define PR_EMS_AB_MAPI_ID                                       PROP_TAG(PT_LONG               , 0x80CE)
#define PR_EMS_AB_MEMBER                                        PROP_TAG(PT_MV_OBJECT          , 0x8009)
#define PR_EMS_AB_MEMBER_A                                      PROP_TAG(PT_MV_STRING8         , 0x8009)
#define PR_EMS_AB_MEMBER_W                                      PROP_TAG(PT_MV_UNICODE         , 0x8009)
#define PR_EMS_AB_MEMBER_O                                      PROP_TAG(PT_MV_OBJECT          , 0x8009)
#define PR_EMS_AB_MEMBER_T                                      PROP_TAG(PT_MV_TSTRING         , 0x8009)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME                        PROP_TAG(PT_TSTRING            , 0x896)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME_A                      PROP_TAG(PT_STRING8            , 0x896)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME_W                      PROP_TAG(PT_UNICODE            , 0x896)
#define PR_EMS_AB_MS_EXCH_LABELEDURI                            PROP_TAG(PT_MV_TSTRING         , 0x921)
#define PR_EMS_AB_MS_EXCH_LABELEDURI_A                          PROP_TAG(PT_MV_STRING8         , 0x921)
#define PR_EMS_AB_MS_EXCH_LABELEDURI_W                          PROP_TAG(PT_MV_UNICODE         , 0x921)
#define PR_EMS_AB_NETWORK_ADDRESS                               PROP_TAG(PT_MV_TSTRING         , 0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A                             PROP_TAG(PT_MV_STRING8         , 0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W                             PROP_TAG(PT_MV_UNICODE         , 0x8170)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR                        PROP_TAG(PT_BINARY             , 0x8013)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY                         PROP_TAG(PT_LONG               , 0x80F6)
#define PR_EMS_AB_OBJECT_GUID                                   PROP_TAG(PT_BINARY             , 0x8C6D)
#define PR_EMS_AB_OBJECT_SID                                    PROP_TAG(PT_BINARY             , 0x8027)
#define PR_EMS_AB_OBJECT_VERSION                                PROP_TAG(PT_LONG               , 0x80F7)
#define PR_EMS_AB_OM_OBJECT_CLASS                               PROP_TAG(PT_BINARY             , 0x80FD)
#define PR_EMS_AB_OM_SYNTAX                                     PROP_TAG(PT_LONG               , 0x80FE)
#define PR_EMS_AB_ORGANIZATION_NAME                             PROP_TAG(PT_MV_TSTRING         , 0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A                           PROP_TAG(PT_MV_STRING8         , 0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W                           PROP_TAG(PT_MV_UNICODE         , 0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME                      PROP_TAG(PT_MV_TSTRING         , 0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A                    PROP_TAG(PT_MV_STRING8         , 0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W                    PROP_TAG(PT_MV_UNICODE         , 0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE                        PROP_TAG(PT_BINARY             , 0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS                  PROP_TAG(PT_BINARY             , 0x8104)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE                  PROP_TAG(PT_BINARY             , 0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE                PROP_TAG(PT_BINARY             , 0x8109)
#define PR_EMS_AB_PERSONAL_TITLE                                PROP_TAG(PT_TSTRING            , 0x8C6B)
#define PR_EMS_AB_PERSONAL_TITLE_A                              PROP_TAG(PT_STRING8            , 0x8C6B)
#define PR_EMS_AB_PERSONAL_TITLE_W                              PROP_TAG(PT_UNICODE            , 0x8C6B)
#define PR_EMS_AB_PHONE_HOME_OTHER                              PROP_TAG(PT_MV_TSTRING         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_OTHER_A                            PROP_TAG(PT_MV_STRING8         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_OTHER_W                            PROP_TAG(PT_MV_UNICODE         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_PRIMARY                            PROP_TAG(PT_TSTRING            , 0x3A09)
#define PR_EMS_AB_PHONE_HOME_PRIMARY_A                          PROP_TAG(PT_STRING8            , 0x3A09)
#define PR_EMS_AB_PHONE_HOME_PRIMARY_W                          PROP_TAG(PT_UNICODE            , 0x3A09)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY                          PROP_TAG(PT_TSTRING            , 0x3A1C)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY_A                        PROP_TAG(PT_STRING8            , 0x3A1C)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY_W                        PROP_TAG(PT_UNICODE            , 0x3A1C)
#define PR_EMS_AB_PHONE_OFFICE_OTHER                            PROP_TAG(PT_MV_TSTRING         , 0x3A1B)
#define PR_EMS_AB_PHONE_OFFICE_OTHER_A                          PROP_TAG(PT_MV_STRING8         , 0x3A1B)
#define PR_EMS_AB_PHONE_OFFICE_OTHER_W                          PROP_TAG(PT_MV_UNICODE         , 0x3A1B)
#define PR_EMS_AB_PHONE_PAGER_OTHER                             PROP_TAG(PT_MV_TSTRING         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_OTHER_A                           PROP_TAG(PT_MV_STRING8         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_OTHER_W                           PROP_TAG(PT_MV_UNICODE         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY                           PROP_TAG(PT_TSTRING            , 0x3A21)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY_A                         PROP_TAG(PT_STRING8            , 0x3A21)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY_W                         PROP_TAG(PT_UNICODE            , 0x3A21)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME                 PROP_TAG(PT_TSTRING            , 0x3A19)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME_A               PROP_TAG(PT_STRING8            , 0x3A19)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME_W               PROP_TAG(PT_UNICODE            , 0x3A19)
#define PR_EMS_AB_POST_OFFICE_BOX                               PROP_TAG(PT_MV_TSTRING         , 0x3A2B)
#define PR_EMS_AB_POST_OFFICE_BOX_A                             PROP_TAG(PT_MV_STRING8         , 0x3A2B)
#define PR_EMS_AB_POST_OFFICE_BOX_W                             PROP_TAG(PT_MV_UNICODE         , 0x3A2B)
#define PR_EMS_AB_POSTAL_ADDRESS                                PROP_TAG(PT_MV_TSTRING         , 0x810c)
#define PR_EMS_AB_POSTAL_ADDRESS_A                              PROP_TAG(PT_MV_STRING8         , 0x810c)
#define PR_EMS_AB_POSTAL_ADDRESS_W                              PROP_TAG(PT_MV_UNICODE         , 0x810c)
#define PR_EMS_AB_POSTAL_CODE                                   PROP_TAG(PT_TSTRING            , 0x3A2A)
#define PR_EMS_AB_POSTAL_CODE_A                                 PROP_TAG(PT_STRING8            , 0x3A2A)
#define PR_EMS_AB_POSTAL_CODE_W                                 PROP_TAG(PT_UNICODE            , 0x3A2A)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD                     PROP_TAG(PT_MV_LONG            , 0x810D)
#define PR_EMS_AB_PROXY_ADDRESSES                               PROP_TAG(PT_MV_TSTRING         , 0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A                             PROP_TAG(PT_MV_STRING8         , 0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W                             PROP_TAG(PT_MV_UNICODE         , 0x800F)
#define PR_EMS_AB_PROXY_GENERATION_ENABLED                      PROP_TAG(PT_BOOLEAN            , 0x81B1)
#define PR_EMS_AB_RANGE_LOWER                                   PROP_TAG(PT_LONG               , 0x8113)
#define PR_EMS_AB_RANGE_UPPER                                   PROP_TAG(PT_LONG               , 0x8114)
#define PR_EMS_AB_RDN                                           PROP_TAG(PT_TSTRING            , 0x8202)
#define PR_EMS_AB_RDN_A                                         PROP_TAG(PT_STRING8            , 0x8202)
#define PR_EMS_AB_RDN_W                                         PROP_TAG(PT_UNICODE            , 0x8202)
#define PR_EMS_AB_REGISTERED_ADDRESS                            PROP_TAG(PT_MV_BINARY          , 0x8119)
#define PR_EMS_AB_REPORTS                                       PROP_TAG(PT_MV_OBJECT          , 0x800E)
#define PR_EMS_AB_REPORTS_A                                     PROP_TAG(PT_MV_STRING8         , 0x800E)
#define PR_EMS_AB_REPORTS_W                                     PROP_TAG(PT_MV_UNICODE         , 0x800E)
#define PR_EMS_AB_REPORTS_O                                     PROP_TAG(PT_MV_OBJECT          , 0x800E)
#define PR_EMS_AB_REPORTS_T                                     PROP_TAG(PT_MV_TSTRING         , 0x800E)
#define PR_EMS_AB_ROLE_OCCUPANT                                 PROP_TAG(PT_MV_OBJECT          , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A                               PROP_TAG(PT_MV_STRING8         , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W                               PROP_TAG(PT_MV_UNICODE         , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O                               PROP_TAG(PT_MV_OBJECT          , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T                               PROP_TAG(PT_MV_TSTRING         , 0x8125)
#define PR_EMS_AB_SCHEMA_VERSION                                PROP_TAG(PT_MV_LONG            , 0x817C)
#define PR_EMS_AB_SEARCH_FLAGS                                  PROP_TAG(PT_LONG               , 0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                                  PROP_TAG(PT_MV_BINARY          , 0x812E)
#define PR_EMS_AB_SEE_ALSO                                      PROP_TAG(PT_MV_OBJECT          , 0x812F)
#define PR_EMS_AB_SEE_ALSO_A                                    PROP_TAG(PT_MV_STRING8         , 0x812F)
#define PR_EMS_AB_SEE_ALSO_W                                    PROP_TAG(PT_MV_UNICODE         , 0x812F)
#define PR_EMS_AB_SEE_ALSO_O                                    PROP_TAG(PT_MV_OBJECT          , 0x812F)
#define PR_EMS_AB_SEE_ALSO_T                                    PROP_TAG(PT_MV_TSTRING         , 0x812F)
#define PR_EMS_AB_SERIAL_NUMBER                                 PROP_TAG(PT_MV_TSTRING         , 0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A                               PROP_TAG(PT_MV_STRING8         , 0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W                               PROP_TAG(PT_MV_UNICODE         , 0x8130)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME                        PROP_TAG(PT_TSTRING            , 0x3A28)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME_A                      PROP_TAG(PT_STRING8            , 0x3A28)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME_W                      PROP_TAG(PT_UNICODE            , 0x3A28)
#define PR_EMS_AB_STREET_ADDRESS                                PROP_TAG(PT_TSTRING            , 0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A                              PROP_TAG(PT_STRING8            , 0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W                              PROP_TAG(PT_UNICODE            , 0x813A)
#define PR_EMS_AB_SUB_REFS                                      PROP_TAG(PT_MV_OBJECT          , 0x813B)
#define PR_EMS_AB_SUB_REFS_A                                    PROP_TAG(PT_MV_STRING8         , 0x813B)
#define PR_EMS_AB_SUB_REFS_W                                    PROP_TAG(PT_MV_UNICODE         , 0x813B)
#define PR_EMS_AB_SUB_REFS_O                                    PROP_TAG(PT_MV_OBJECT          , 0x813B)
#define PR_EMS_AB_SUB_REFS_T                                    PROP_TAG(PT_MV_TSTRING         , 0x813B)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT                 PROP_TAG(PT_MV_BINARY          , 0x813D)
#define PR_EMS_AB_SURNAME                                       PROP_TAG(PT_TSTRING            , 0x3A11)
#define PR_EMS_AB_SURNAME_A                                     PROP_TAG(PT_STRING8            , 0x3A11)
#define PR_EMS_AB_SURNAME_W                                     PROP_TAG(PT_UNICODE            , 0x3A11)
#define PR_EMS_AB_TELEPHONE_NUMBER                              PROP_TAG(PT_TSTRING            , 0x3A08)
#define PR_EMS_AB_TELEPHONE_NUMBER_A                            PROP_TAG(PT_STRING8            , 0x3A08)
#define PR_EMS_AB_TELEPHONE_NUMBER_W                            PROP_TAG(PT_UNICODE            , 0x3A08)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER                   PROP_TAG(PT_MV_BINARY          , 0x8143)
#define PR_EMS_AB_TELEX_NUMBER                                  PROP_TAG(PT_MV_BINARY          , 0x3A2C)
#define PR_EMS_AB_TEXT_COUNTRY                                  PROP_TAG(PT_TSTRING            , 0x3A26)
#define PR_EMS_AB_TEXT_COUNTRY_A                                PROP_TAG(PT_STRING8            , 0x3A26)
#define PR_EMS_AB_TEXT_COUNTRY_W                                PROP_TAG(PT_UNICODE            , 0x3A26)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS                       PROP_TAG(PT_TSTRING            , 0x8C81)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS_A                     PROP_TAG(PT_STRING8            , 0x8C81)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS_W                     PROP_TAG(PT_UNICODE            , 0x8C81)
#define PR_EMS_AB_TITLE                                         PROP_TAG(PT_TSTRING            , 0x3A17)
#define PR_EMS_AB_TITLE_A                                       PROP_TAG(PT_STRING8            , 0x3A17)
#define PR_EMS_AB_TITLE_W                                       PROP_TAG(PT_UNICODE            , 0x3A17)
#define PR_EMS_AB_TOMBSTONE_LIFETIME                            PROP_TAG(PT_LONG               , 0x8145)
#define PR_EMS_AB_USER_CERT                                     PROP_TAG(PT_BINARY             , 0x3A22)
#define PR_EMS_AB_USER_PASSWORD                                 PROP_TAG(PT_MV_BINARY          , 0x8153)
#define PR_EMS_AB_USER_SMIME_CERTIFICATE                        PROP_TAG(PT_MV_BINARY          , 0x3a70)
#define PR_EMS_AB_USN_INTERSITE                                 PROP_TAG(PT_LONG               , 0x817A)
#define PR_EMS_AB_WHEN_CHANGED                                  PROP_TAG(PT_SYSTIME            , 0x3008)
#define PR_EMS_AB_WHEN_CREATED                                  PROP_TAG(PT_SYSTIME            , 0x3007)
#define PR_EMS_AB_WWW_PAGE_OTHER                                PROP_TAG(PT_MV_TSTRING         , 0x8175)
#define PR_EMS_AB_WWW_PAGE_OTHER_A                              PROP_TAG(PT_MV_STRING8         , 0x8175)
#define PR_EMS_AB_WWW_PAGE_OTHER_W                              PROP_TAG(PT_MV_UNICODE         , 0x8175)
#define PR_EMS_AB_X121_ADDRESS                                  PROP_TAG(PT_MV_TSTRING         , 0x8158)
#define PR_EMS_AB_X121_ADDRESS_A                                PROP_TAG(PT_MV_STRING8         , 0x8158)
#define PR_EMS_AB_X121_ADDRESS_W                                PROP_TAG(PT_MV_UNICODE         , 0x8158)
#define PR_EMS_AB_X509_CERT                                     PROP_TAG(PT_MV_BINARY          , 0x8c6a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ndnc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    This module defines the functions for Appication Directory
    Partitions, aka NDNCs, or Non-Domain Naming Contexts, or 
    Application Partitions.  Note: Often Application is replaced
    with some application, such as "TAPI Directory Partition".

Author:

    Brett Shirley (BrettSh) 20-Feb-2000

Revision History:

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new a new library ndnc.lib.  This is so
        it can be used by ntdsutil and tapicfg commands.  The  old
        source location: \nt\ds\ds\src\util\ntdsutil\ndnc.h.                                    


--*/

#ifndef _NDNC_H_
#define _NDNC_H_

#ifdef __cplusplus
extern "C" {
#endif
// --------------------------------------
// Data Types.
 
typedef struct _optional_value {
    BOOL fPresent;
    DWORD dwValue;
} OPTIONAL_VALUE, *LPOPTIONAL_VALUE;

// enums for the FSMO chasing code.
#define E_DNM    (1)
#define E_SCHEMA (2)
#define E_IM     (3)
#define E_PDC    (4)
#define E_RID    (5)
#define E_ISTG   (6)



// --------------------------------------
// Helper Routines.

WCHAR *
wcsistr(
    IN      WCHAR *            wszStr,
    IN      WCHAR *            wszTarget
    );

ULONG
GetRootAttr(
    IN  LDAP *       hld,
    IN  WCHAR *      wszAttr,
    OUT WCHAR **     pwszOut
    );

ULONG
GetPartitionsDN(
    IN  LDAP *       hld,
    OUT WCHAR **     pwszPartitionsDn
    );

#define GetCrossRefDNFromNCDN(a, b, c)      GetCrossRefDNFromPartitionDN(a, b, c)
ULONG
GetCrossRefDNFromPartitionDN(
    IN  LDAP *       hld, 
    IN  WCHAR *      wszNCDN,
    OUT WCHAR **     pwszCrossRefDn
    );

ULONG
GetServerNtdsaDnFromServerDns(
    IN LDAP *        hld,                   
    IN WCHAR *       wszServerDNS,
    OUT WCHAR **     pwszServerDn
    );

ULONG
GetServerDnsFromServerNtdsaDn(
    IN LDAP *        hld,                   
    IN WCHAR *       wszServerDn,
    OUT WCHAR **     pwszServerDNS
    );


ULONG
GetCrossRefDNFromNDNCDNS(
    IN LDAP *        hldDC, 
    IN WCHAR *       wszNDNCDNS,
    OUT WCHAR **     wszCrossRefDN
    );

ULONG
GetServerDNFromServerDNS(
    IN LDAP *        hldDC, 
    IN WCHAR *       wszServerDNS,
    OUT WCHAR **      wszServerDN
    );

BOOL
SetIscReqDelegate(
    LDAP *  hld
    );

ULONG
GetFsmoDsaDn(
    IN  LDAP *       hld,
    IN  ULONG        eFsmoType,
    IN  WCHAR *      wszFsmoDn,
    OUT WCHAR **     pwszDomainNamingFsmoDn
    );

ULONG
GetDomainNamingFsmoDn(
    IN  LDAP *       hld,
    OUT WCHAR **     pwszDomainNamingFsmoDn
    );

#define GetDomNameFsmoLdapBinding(init, ref, creds, pdwret)  GetFsmoLdapBinding(init, E_DNM, NULL, ref, creds, pdwret)

LDAP *
GetFsmoLdapBinding(
    WCHAR *          wszInitialServer,
    ULONG            eFsmoType,
    WCHAR *          wszFsmoBaseDn,
    void *           fReferrals,
    SEC_WINNT_AUTH_IDENTITY_W   * pCreds,
    DWORD *          pdwRet
    );

#define GetNdncLdapBinding(server, pret, fref, pcreds)   GetLdapBinding(server, pret, fref, TRUE, pcreds)

LDAP *
GetLdapBinding(
    WCHAR *          pszServer,
    DWORD *          pdwRet,
    BOOL             fReferrals,
    BOOL             fDelegation,
    SEC_WINNT_AUTH_IDENTITY_W   * pCreds
    );

BOOL
CheckDnsDn(
    IN   WCHAR       * wszDnsDn
    );

DWORD
GetDnsFromDn(
    IN   WCHAR       * wszDn,
    IN   WCHAR **      pwszDns
    );

DWORD
GetWellKnownObject (
    LDAP  *ld,
    WCHAR *pHostObject,
    WCHAR *pWellKnownGuid,
    WCHAR **ppObjName
    );

// --------------------------------------
// Main Routines.

#define CreateNDNC(a, b, c)                CreateAppDirPart(a, b, c)
ULONG
CreateAppDirPart(
    IN LDAP *        hldNDNCDC,
    const IN WCHAR *  wszNDNC,
    const IN WCHAR *  wszShortDescription
    );

#define RemoveNDNC(a, b)                   RemoveAppDirPart(a, b)
ULONG
RemoveAppDirPart(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC
    );

#define ModifyNDNCReplicaSet(a, b, c, d)   ModifyAppDirPartReplicaSet(a, b, c, d)
ULONG
ModifyAppDirPartReplicaSet(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReplicaNtdsaDn,
    IN BOOL          fAdd // Else it is considered a delete
    );

#define SetNDNCSDReferenceDomain(a, b, c)  SetAppDirPartSDReferenceDomain(a, b, c)
ULONG
SetAppDirPartSDReferenceDomain(
    IN LDAP *        hldDomainNamingFsmo,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReferenceDomain
    );


WCHAR * 
GetWinErrMsg(
    DWORD winError
    );

void
GetLdapErrorMessages(
    IN          LDAP *     pLdap,
    IN          DWORD      dwLdapErr,
    OUT         LPWSTR *   pszLdapErr,
    OUT         DWORD *    pdwWin32Err, 
    OUT         LPWSTR *   pszWin32Err,
    OUT         LPWSTR *   pszExtendedErr
    );

void
FreeLdapErrorMessages(
    IN          LPWSTR      szWin32Err,
    IN          LPWSTR      szExtendedErr
    );

ULONG
GetNCReplicationDelays(
    IN LDAP *               hld,
    IN WCHAR *              wszNC,
    OUT LPOPTIONAL_VALUE    pFirstDSADelay,  
    OUT LPOPTIONAL_VALUE    pSubsequentDSADelay
  );

ULONG
SetNCReplicationDelays(
    IN LDAP *            hldDomainNamingFsmo,
    IN WCHAR *           wszNC,
    IN LPOPTIONAL_VALUE  pFirstDSADelay,
    IN LPOPTIONAL_VALUE  pSubsequentDSADelay
    );

#ifdef __cplusplus
}
#endif

#endif // _NDNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdsa.h ===
/* Copyright 1989-1999 Microsoft Corporation, All Rights Reserved */

#ifndef _ntdsa_h_
#define _ntdsa_h_
#include "ntdsadef.h"


// If you add to this list, be sure and add the corresponding #undef below.
#ifdef MIDL_PASS
#define SIZE_IS(x)      [size_is(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define SWITCH_TYPE(x)  [switch_type(x)]
#define CASE(x)         [case(x)]
#define RANGE(x,y)      [range(x,y)]
#define VAR_SIZE_ARRAY
#else
#define SIZE_IS(x)
#define SWITCH_IS(x)
#define SWITCH_TYPE(x)
#define CASE(x)
#define VAR_SIZE_ARRAY  (1)
#define RANGE(x,y)
#endif

#ifdef MIDL_PASS
typedef [string] char * SZ;
#else
typedef char * SZ;
#endif

/***************************************************************************
    General Size Limits
***************************************************************************/

#define MAX_ADDRESS_SIZE                   256   /* The max size of a DNS address (we hope) */

#define TEN_THOUSAND_B 10000
#define ONE_MB 1024*1024
#define TEN_MB 10*ONE_MB

#define TEN_THOUSAND_VALUES 10000
#define ONE_MB_VALUES ONE_MB
#define TEN_MB_VALUES TEN_MB

#define MAX_UCHAR_IN_ATTVALS               TEN_MB                   // max size of an attribute
#define MAX_ATTRVAL_IN_ATTRVALBLOCK        TEN_MB_VALUES            // max number of attribute values (including linked values)
#define MAX_ATTR_IN_ATTRBLOCK              ONE_MB_VALUES            // max number of attributes on an object
#define MAX_WCHAR_IN_DSNAME                TEN_MB_VALUES            // max size of a dsname string
#define MAX_PUCHAR_IN_OCTET                TEN_THOUSAND_VALUES      // max number of pointers in an octet
#define MAX_CHAR_IN_MTX_NAME               MAX_ADDRESS_SIZE         // max size of mtx name (which is a DNS addr) 
#define MAX_PROP_META_IN_PROP_META_VEC_V1  MAX_ATTR_IN_ATTRBLOCK    // max number of meta data for an object              
#define MAX_PROP_META_IN_PROP_META_VEC     MAX_ATTR_IN_ATTRBLOCK    
#define MAX_ATTRTYP_IN_PARTIAL_ATTR_VEC_V1 ONE_MB_VALUES            // max number of attributes in partial attribute vector (internal)
#define MAX_ATTRTYP_IN_PARTIAL_ATTR_VEC_V1_EXT MAX_ATTRTYP_IN_PARTIAL_ATTR_VEC_V1
                                                                    // max number of attributes in partial attribute vector (external)
#define MAX_UTD_CURS_V1_IN_UTD_VEC_V1      ONE_MB_VALUES            // max number of entries in UTD vector (internal)
#define MAX_UTD_CURS_V2_IN_UTD_VEC_V2      MAX_UTD_CURS_V1_IN_UTD_VEC_V1
#define MAX_UTD_CURS_V1_IN_UTD_VEC_V1_EXT  MAX_UTD_CURS_V1_IN_UTD_VEC_V1
                                                                    // max number of entries in UTD vector (external)
#define MAX_UTD_CURS_V2_IN_UTD_VEC_V2_EXT  MAX_UTD_CURS_V1_IN_UTD_VEC_V1_EXT
#define MAX_CB_OF_DRS_EXTS                 TEN_THOUSAND_B           // maximum bytes of drs extensions
#define MAX_CB_OID_ELEMS                   TEN_THOUSAND_B           // maximum bytes of schema prefix table (OID) elements
#define MAX_PREFIX_TAB_ENT_IN_SCHEMA_PREFIX_TAB ONE_MB_VALUES
                                                                    // maximum number of entries in the schema prefix table

/*
**  SECURITY NOTE:  RPC input validation security is done with [unique],[ref],etc.  
**  In order to make the security more explicit, don't leave any MIDL datatypes 
**  as a default.  All DRS_HANDLES should be of type [ref], and all MSG types
**  should also be [ref].  Ideally, datatypes should be declared so that
**  all validation can be done by RPC.  Regardless, if you extend or add to an interface
**  you must create corresponding validation functions.  Use IDL_DRSReplicaSync, 
**  DRSReplicaSync_InputValidate, DRS_MSG_REPSYNC_V1_Validate, etc as a guide and
**  template if you add a new interface function or datatype.  If you modify
**  an interface function or datatype, you may need to modify the corresponding
**  validation functions.
*/

/***************************************************************************
 *    OSI defs (things to define attributes.)
 ***************************************************************************/

/*
 * Identifies an attribute
 */

typedef ULONG  ATTRTYP;

/*
 * A single attribute value.  This value is set according to the data type
 */

typedef struct ATTVAL{
    RANGE(0,MAX_UCHAR_IN_ATTVALS) ULONG     valLen;                  /* length of attribute value        */
    SIZE_IS(valLen) UCHAR *pVal;     /* value.  May be of any predefined
                                      * type                             */
}ATTRVAL;

/*
 * A bunch of attribute values
 */
typedef struct ATTRVALBLOCK{
    RANGE(0,MAX_ATTRVAL_IN_ATTRVALBLOCK) ULONG valCount;                      /* count of values */
    SIZE_IS(valCount) ATTRVAL *pAVal;  /* attribute values */
}ATTRVALBLOCK;



/*
 * An attribute is composed of an attribute type and one
 * or more attribute values.
 */

typedef struct ATTR{
    ATTRTYP   attrTyp;                 /* the attribute type               */
    ATTRVALBLOCK AttrVal;              /* the values */
}ATTR;

/*
 * A block of attributes
 */

typedef struct ATTRBLOCK{
    RANGE(0,MAX_ATTR_IN_ATTRBLOCK) ULONG attrCount;
    SIZE_IS(attrCount) ATTR *pAttr;
}ATTRBLOCK;

typedef ATTR RDN;

#define MAX_NT4_SID_SUBAUTHORITY_COUNT 5
// MAX_NT4_SID_SIZE == (offsetof(SID, SubAuthority) + MAX_NT4_SID_SUBAUTHORITY_COUNT*sizeof(ULONG))
// It should always be 28.
#define MAX_NT4_SID_SIZE 28

typedef struct _NT4SID {
    char Data[MAX_NT4_SID_SIZE];
} NT4SID;

typedef NT4SID *PNT4SID;

/* The Distinguished Name.  The full path name of a directory object,
 * consisting of an ordered sequence of RDNs, stored in accordance with
 * RFC 1779 string DN format (e.g., CN=donh,OU=BSD,O=Microsoft,C=US).
 *
 * To facilitate identity based and security operations, the object's
 * GUID and SID are optionally present in the DSNAME structure.  If
 * present, the GUID is assumed to take precedence over the string name.
 *
 * The NameLen includes all the non-null characters in the string name,
 * but specifically does NOT include the trailing NULL.  However, the
 * total structure size as specified by the structLen should include
 * enough storage for a trailing NULL after the string name.  This means
 * that StringName[NameLen] will always be NULL, and that
 * StringName[NameLen-1] will never be NULL.  Please don't try to compute
 * structure sizes on your own, but instead use the DSNameSizeFromLen
 * macro provided below.
 */

/*
 * The combination ID/name structure
 *
 * Note:  In terms of rpc data marshalling, structLen is simply a ULONG value.  RPC
 * doesn't validate it's correctness, and in fact, some legitimate callers don't set
 * it correctly, and we are forced (for backwards compatibility) to "fix" this value
 * after we recieve it.  Technically, it's not needed, since it can be so easily
 * calculated from the NameLen variable (see DSNameSizeFromLen Macro).  What about
 * SidLen you ask?  That's a variable size Sid, but the structure that holds it isn't.
 * The structure is static with MAX_NT4_SID_SIZE bytes.  See definition of NT4SID.  Also
 * note the strange form of the StringName attribute.  We can't get rpc to validate if it's
 * honestly NULL terminated or not - for example, if I had a string DC=greg,DC=Johnson,DC=com and
 * I built a dsname out of it, I could change that DSNAME to DC=greg,DC=Johnson by simply
 * nulling out the guid, and changing NameLen from 25 to 18.  But then, when RPC marshalls
 * that name, instead of begin DC=greg,DC=johnson[NULL] it'll be DC=greg,DC=johnson, with
 * no NULL terminator.  Therefore, we verify NULL termination after these structures are 
 * recieved.
 */
typedef struct _DSNAME {
    ULONG structLen;                                         /* length of entire DSNAME, in bytes
                                                                no need to range this value since RPC/MIDL
                                    doesn't understand it's relevance */
    ULONG SidLen;                                            /* length of the SID, in bytes (0 = none)
                                                                cannot be greater than fixed size array used
                                        to hold the SID, but Win2k clients sometimes
                                send garbage values in this field, so we 
                                can't range it like we should:
                                RANGE(0, MAX_NT4_SID_SIZE).  Instead the 
                                validation functions will deal with it. */
    GUID Guid;                                               /* id of this object */
    NT4SID Sid;                                              /* SID for this object, if present */
    RANGE(0,MAX_WCHAR_IN_DSNAME) ULONG NameLen;              /* length of the StringName, in chars */
    SIZE_IS(NameLen+1) WCHAR StringName[VAR_SIZE_ARRAY];     /* Unicode string name - Adding one so that */   
                                 /*   terminating NULL is also sent */
} DSNAME;

typedef DSNAME *PDSNAME;

/*
 * The SizeFromLen macro is a sad commentary on the state of the sizeof
 * operator (which rounds up to allow for padding) and the IDL compiler
 * (which munges empty arrays into 1 sized arrays).
 */
#define DSNameSizeFromLen(x) \
    (sizeof(GUID) + 3*sizeof(ULONG) + sizeof(WCHAR) + sizeof(NT4SID) \
     + (x)*sizeof(WCHAR))
#define DNTFromShortDSName(x) (*((DWORD *)((x)->StringName)))

/*
 * A Generic sized buffer of bytes.
 */

typedef struct OCTET{
    RANGE(0,MAX_PUCHAR_IN_OCTET) USHORT     len;     /* length */
    SIZE_IS(len) PUCHAR pVal;                        /* pointer to value */
}OCTET;

// The time/date type used by the DS.
typedef LONGLONG DSTIME;

// ENTINF flags

// Read from a writeable copy
#define ENTINF_FROM_MASTER        0x00000001

// Dynamic Object (new in Whistler)
// Only available when fDRA is set (see mdread.c)
#define ENTINF_DYNAMIC_OBJECT     0x00000002

typedef struct _ENTINF
{
    DSNAME           *pName;            // Object name and identity
    ULONG            ulFlags;           // Entry flags
    ATTRBLOCK        AttrBlock;         // The attributes returned.
} ENTINF;

typedef struct _ENTINFLIST
{
    struct _ENTINFLIST   *pNextEntInf;  // linked-list to next entry of info
                                        
                                        // ISSUE:  we can't range, size_is or ref on this structure
                                        // this has denial of service implications
                                        
                    // For example, a caller could send a list with
                                        // a loop (this is theoretical, it's not obvious if such 
                    // a structure is expressible in RPC's marshalled
                    // data representation) - this would probably cause RPC to 
                                        // infinite loop and to make one of the finite number
                                        // of rpc threads permenantly busy, but if
                                        // rpc was prepared for this, it would infinite loop
                                        // us in IDL_DRSAddEntry (for example).

                                        // Another method to take advantage of this structure
                                        // for DOS purposes is for the caller to send an unending
                                        // list.  The caller could continually send packet after
                                        // packet of ENTINFLISTs and RPC would demarshall and allocate
                                        // space for them - causing us to eventually run out
                                        // of memory.  We can't do anything to protect against this,
                                        // and currently RPC doesn't either.  The solution would
                                        // be to get rid of this structure and replace it with 
                                        // one that has an array of Entinf's that we can use
                                        // RANGE(0,MAX_ENTINF_IN_ENTINFLIST) on.  (then there'd be 
                                        // no need for loop detection above either)

    ENTINF           Entinf;            // information about this entry
} ENTINFLIST;


// UTF8-encoded, transport-specific DSA address.
typedef struct{
    RANGE(1,MAX_CHAR_IN_MTX_NAME) ULONG  mtx_namelen;          /* Length of the name, incl. null terminator */
    SIZE_IS(mtx_namelen) char mtx_name[VAR_SIZE_ARRAY];
} MTX_ADDR;
#define MTX_TSIZE(pmtx) (offsetof(MTX_ADDR, mtx_name) + (pmtx)->mtx_namelen)
// NOTE: cch does _not_ include null terminator.
#define MTX_TSIZE_FROM_LEN(cch) (offsetof(MTX_ADDR, mtx_name) + (cch) + 1)


/* An attribute value assertion is composed of an attribute type and value*/

typedef struct AVA{
    ATTRTYP  type;                       /* attribute type           */
    ATTRVAL  Value;                      /* a single attribute value */
}AVA;



/* A list of AVA's */

typedef struct AVALIST{
   struct AVALIST FAR *pNextAVAVal;      // linked list of AVA's   

                                         // ISSUE:  See security comments on ENTINFLIST

   AVA                  AVAVal;          /* The AVA type and value */
}AVALIST;


/***************************************************************************
 *    Replication-specific structures
 ***************************************************************************/

// Property-Meta-Data:
//      This contains all the replication meta-data associated with a single
//      property of an object.  This data is required for incremental
//      replication as well as per-property propagation dampening.
//
//      attrType - identifies the attribute whose meta-data rest of fields
//          represent.
//      usnProperty - USN corresponding to the last change on the property.
//      dwVersion - Version of the property.
//      timeChanged - Time stamp corresponding to the last change to the
//          property.
//      uuidDsaOriginating - uuid of the DSA that did the last originating
//          write on the property.
//      usnOriginating - USN corresponding to the last originating write in
//          the originating DSA's USN space.


typedef struct _PROPERTY_META_DATA {
    ATTRTYP             attrType;
    DWORD               dwVersion;
    DSTIME              timeChanged;
    UUID                uuidDsaOriginating;
    USN                 usnOriginating;
    USN                 usnProperty;
} PROPERTY_META_DATA;

// Property-Meta-Data-Vector:
//      This is a vector of property-meta-data which holds the meta-data for
//      one or more properties of an object.

typedef struct _PROPERTY_META_DATA_VECTOR_V1 {
    RANGE(1,MAX_PROP_META_IN_PROP_META_VEC_V1)
        DWORD               cNumProps;
    SIZE_IS(cNumProps)
        PROPERTY_META_DATA  rgMetaData[VAR_SIZE_ARRAY];
} PROPERTY_META_DATA_VECTOR_V1;

typedef struct _PROPERTY_META_DATA_VECTOR {
    DWORD               dwVersion;
    SWITCH_IS(dwVersion) union {
        CASE(1) PROPERTY_META_DATA_VECTOR_V1 V1;
    };
} PROPERTY_META_DATA_VECTOR;

#define MetaDataVecV1SizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA))

#define MetaDataVecV1Size(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + ((pMetaDataVec)->V1.cNumProps)*sizeof(PROPERTY_META_DATA))

#define VALIDATE_META_DATA_VECTOR_VERSION(pVec)         \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }

// Value-Meta-Data
//      This contains all the replication meta-data associated with a single
//      value of a property of an object.  This is the internal version of the
//      metadata: it is not written to disk or transmitted across the wire.
//      Use the EXT form for that.
typedef struct _VALUE_META_DATA {
    DSTIME             timeCreated;
    PROPERTY_META_DATA MetaData;
} VALUE_META_DATA;

// Property-Meta-Data-Ext:
//      This is a trimmed version of property meta data containing only the
//      fields that are required by the remote DSA as part of the replication
//      packet.
typedef struct _PROPERTY_META_DATA_EXT {
    DWORD   dwVersion;
    DSTIME  timeChanged;
    UUID    uuidDsaOriginating;
    USN     usnOriginating;
} PROPERTY_META_DATA_EXT;

// Value-Meta-Data-Ext
// This structure contains the trimmed version of the value meta data
// This structure does not have a version number because it is a fixed
// size: versions may be distinguished by checking the size of the
// structure.
typedef struct _VALUE_META_DATA_EXT_V1 {
    DSTIME                 timeCreated;
    PROPERTY_META_DATA_EXT MetaData;
} VALUE_META_DATA_EXT_V1;

// Shorthand for most current version of structure
typedef VALUE_META_DATA_EXT_V1 VALUE_META_DATA_EXT;

// Property-Meta-Data-Ext-Vector:
//      This is a vector of property-meta-data-ext which holds the trimmed
//      property meta data for one or more properties of an object.
typedef struct _PROPERTY_META_DATA_EXT_VECTOR {
    RANGE(0,MAX_PROP_META_IN_PROP_META_VEC) 
         DWORD                   cNumProps;
    SIZE_IS(cNumProps)
         PROPERTY_META_DATA_EXT  rgMetaData[VAR_SIZE_ARRAY];
} PROPERTY_META_DATA_EXT_VECTOR;


#define MetaDataExtVecSizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA_EXT))

#define MetaDataExtVecSize(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + ((pMetaDataVec)->cNumProps)*sizeof(PROPERTY_META_DATA_EXT))


// PARTIAL_ATTR_VECTOR - represents the partial attribute set. This is an array of
//      sorted attids that make the partial set.

typedef struct _PARTIAL_ATTR_VECTOR_V1 {
    RANGE(1,MAX_ATTRTYP_IN_PARTIAL_ATTR_VEC_V1) DWORD cAttrs;    // count of partial attributes in the array
    SIZE_IS(cAttrs) ATTRTYP rgPartialAttr[VAR_SIZE_ARRAY];
} PARTIAL_ATTR_VECTOR_V1;

// We need to make sure the start of the union is aligned at an 8 byte
// boundary so that we can freely cast between internal and external
// formats.
typedef struct _PARTIAL_ATTR_VECTOR_INTERNAL {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) PARTIAL_ATTR_VECTOR_V1 V1;
    };
} PARTIAL_ATTR_VECTOR_INTERNAL;

typedef PARTIAL_ATTR_VECTOR_INTERNAL PARTIAL_ATTR_VECTOR;

#define PartialAttrVecV1SizeFromLen(cAttrs) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + (cAttrs)*sizeof(ATTRTYP))

#define PartialAttrVecV1Size(pPartialAttrVec) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + ((pPartialAttrVec)->V1.cAttrs) * sizeof(ATTRTYP))

typedef struct _PARTIAL_ATTR_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    RANGE(1,MAX_ATTRTYP_IN_PARTIAL_ATTR_VEC_V1_EXT)
         DWORD          cAttrs;
    SIZE_IS(cAttrs) 
         ATTRTYP        rgPartialAttr[VAR_SIZE_ARRAY];
} PARTIAL_ATTR_VECTOR_V1_EXT;

#define VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(pVec)      \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }


// USN Vector.  Replication session state.  Tracks the state of the last
//      replication session between a given pair of DSAs.

typedef struct _USN_VECTOR {
    USN         usnHighObjUpdate;
    USN         usnReserved;    // was usnHighObjCreate; not used post beta-2
    USN         usnHighPropUpdate;
} USN_VECTOR;


// Up-to-date vector.  This vector indicates the last changes each side of a
//      GetNCChanges() call saw from its neighbors.  This information, in turn,
//      is used to filter out items that do not need to be transmitted.

typedef struct _UPTODATE_CURSOR_V1 {
    UUID uuidDsa;
    USN  usnHighPropUpdate;
} UPTODATE_CURSOR_V1;

#ifdef __cplusplus
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // genuine C++ inheritance.
    typedef struct _UPTODATE_CURSOR_V2 : _UPTODATE_CURSOR_V1 {
#else
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // Microsoft's "Anonymous Structure" C language extension.
    typedef struct _UPTODATE_CURSOR_V2 {
        #ifdef MIDL_PASS
            struct  _UPTODATE_CURSOR_V1 v1;
        #else
            struct  _UPTODATE_CURSOR_V1;
        #endif
#endif
        DSTIME  timeLastSyncSuccess;
    } UPTODATE_CURSOR_V2;

typedef struct _UPTODATE_VECTOR_V1 {
    RANGE(0,MAX_UTD_CURS_V1_IN_UTD_VEC_V1)
         DWORD          cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) 
         UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1;

typedef struct _UPTODATE_VECTOR_V2 {
    RANGE(0,MAX_UTD_CURS_V2_IN_UTD_VEC_V2)
     DWORD          cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) 
         UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2;

typedef struct _UPTODATE_VECTOR {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) UPTODATE_VECTOR_V1 V1;
        CASE(2) UPTODATE_VECTOR_V2 V2;
    };
} UPTODATE_VECTOR;

#define UpToDateVecV1SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecV1Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + ((putodvec)->V1.cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + ((putodvec)->V2.cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecSize(putodvec) \
    ((2 == (putodvec)->dwVersion) \
     ? UpToDateVecV2Size(putodvec) \
     : UpToDateVecV1Size(putodvec))

// Native UTD types/macros.  These must be updated if the native (internally
// used) type is changed from Vx to Vy.
typedef UPTODATE_CURSOR_V2 UPTODATE_CURSOR_NATIVE;
typedef UPTODATE_VECTOR_V2 UPTODATE_VECTOR_NATIVE;
#define UPTODATE_VECTOR_NATIVE_VERSION (2)
#define UpToDateVecVNSizeFromLen(cNumCursors) UpToDateVecV2SizeFromLen(cNumCursors)
    

// MIDL doesn't like marshalling the definition of UPTODATE_VECTOR. So, we are
// keeping strucurally identical but a simpler looking version-specific
// definitions of UPTODATE_VECTOR for marshalling.  Castings between
// UPTODATE_VECTOR and UPTODATE_VECTOR_Vx_EXT are perfectly valid as long as
// dwVersion == x.
// Note:-
// We need the Reserved1 & Reserved2 variables to account for alignment.
// The internal form gets an 8 byte alignment due to the _int64 field in
// the UPTODATE_CURSOR. So, unless we account for this alignment through
// dummy variables, we can't freely cast back & forth between the internal
// and external versions.
typedef struct _UPTODATE_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    RANGE(0,MAX_UTD_CURS_V1_IN_UTD_VEC_V1_EXT)
         DWORD          cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) 
         UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1_EXT;

typedef struct _UPTODATE_VECTOR_V2_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    RANGE(0,MAX_UTD_CURS_V2_IN_UTD_VEC_V2_EXT)
         DWORD          cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) 
         UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2_EXT;

#ifdef MIDL_PASS
typedef UPTODATE_VECTOR_V1_EXT UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR_V2_EXT UPTODATE_VECTOR_V2_WIRE;
#else
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V2_WIRE;
#endif


#define IS_VALID_UPTODATE_VECTOR(x) \
    ((1 == (x)->dwVersion) || (2 == (x)->dwVersion))

#define IS_NULL_OR_VALID_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_UPTODATE_VECTOR(x))

#define IS_VALID_NATIVE_UPTODATE_VECTOR(x) \
    (UPTODATE_VECTOR_NATIVE_VERSION == (x)->dwVersion)

#define IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_NATIVE_UPTODATE_VECTOR(x))


// Following version definitions are probably unnecessary. But it shows
// explicitly through a constant that our versions start from 1 not 0.
#define VERSION_V1 (1)
#define VERSION_V2 (2)
#define VERSION_V3 (3)


// This is the structure used to set periodic replication times, each bit
// represents a 15 minute period, 8 bits* 84 bytes * 15 mins = a week
typedef struct _repltimes {
    UCHAR rgTimes[84];
} REPLTIMES;


// REPLENTINFLIST:  Similar to ENTINFLIST except it also has additional fields
//      for holding incremental replication and name space reconciliation
//      fields.
typedef struct _REPLENTINFLIST {
    struct _REPLENTINFLIST *
                pNextEntInf;    // linked-list to the next entry info

                                // ISSUE:  See security comments on ENTINFLIST

    ENTINF      Entinf;         // all the old repl info alongwith shipped
                                //      attributes
    BOOL        fIsNCPrefix;    // is this object the NC prefix?
    GUID *      pParentGuid;    // points to parent guid while replicating
                                //      renames; NULL otherwise
    PROPERTY_META_DATA_EXT_VECTOR *
                pMetaDataExt;   // pointer to the meta-data to be shipped
} REPLENTINFLIST;

// REPLVALINF: describe a single value change for replication
typedef struct _REPLVALINF {
    PDSNAME pObject;                // containing object
    ATTRTYP attrTyp;                // containing attribute
    ATTRVAL Aval;                   // The value itself
    BOOL fIsPresent;                // adding or removing?
    VALUE_META_DATA_EXT MetaData;   // Originating info
} REPLVALINF;


// DRS_EXTENSIONS is an arbitrary byte array describing the capabilities and
// other state information for a particular server.  Exchanged at bind
// time, the structure allows client and server to negotiate a compatible
// protocol.
typedef struct _DRS_EXTENSIONS {
    RANGE(1,MAX_CB_OF_DRS_EXTS) DWORD cb;    // length of rgb field (not of entire struct)
    SIZE_IS(cb) BYTE rgb[VAR_SIZE_ARRAY];
} DRS_EXTENSIONS, *PDRS_EXTENSIONS;


// DRS_EXTENSIONS_INT is the data structure described by the DRS_EXTENSIONS byte
// array.  This array can be safely extended by adding additional fields onto
// the end (but not anywhere else).
//
// Parts of the extension are carried in the variable-length mail-based
// replication header. If you extend this structure, please examine
// dramail.h structure definition and dramail.c get/set extensions routines
// and consider whether your new information should be carried there as well.
//
// PORTABILITY WARNING: Since this structure is marshalled as a byte array,
// big-endian machines will need to do local byte-swapping.
typedef struct _DRS_EXTENSIONS_INT {
    DWORD cb;           // set to sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD)
    DWORD dwFlags;      // various DRS_EXT_* bits
    UUID  SiteObjGuid;  // objectGuid of owning DSA's site object
    INT   pid;          // process id of client (used to facilitate leak trking)
    DWORD dwReplEpoch;  // replication epoch (for domain rename)

    // If you extend this structure, see SITE_GUID_FROM_DRS_EXT() for an example
    // of how to safely extract your new field's data.
} DRS_EXTENSIONS_INT;

// To define an extension, add an entry to the following enumeration just
// above DRS_EXT_MAX.

// NOTE: If you add/remove extensions, please make corresponding updates to the
// structure in Dump_BHCache() in dsexts\md.c.
typedef enum {
    DRS_EXT_BASE = 0,

    // Bits for DRS_EXTENSIONS_DATA Flags field.
    DRS_EXT_ASYNCREPL,      // supports DRS_MSG_REPADD_V2, DRS_MSG_GETCHGREQ_V2
    DRS_EXT_REMOVEAPI,      // supports RemoveDsServer, RemoveDsDomain
    DRS_EXT_MOVEREQ_V2,     // supports DRS_MOVEREQ_V2
    DRS_EXT_GETCHG_COMPRESS,// supports DRS_MSG_GETCHGREPLY_V2
    DRS_EXT_DCINFO_V1,      // supports DS_DOMAIN_CONTROLLER_INFO_1
    DRS_EXT_RESTORE_USN_OPTIMIZATION,
        // supports bookmark optimizations on restore to avoid full syncs
    DRS_EXT_ADDENTRY,       // supports remoted AddEntry, v1
    DRS_EXT_KCC_EXECUTE,    // supports IDL_DRSExecuteKCC
    DRS_EXT_ADDENTRY_V2,    // supports remoted AddEntry, v2
    DRS_EXT_LINKED_VALUE_REPLICATION, // LVR supported AND enabled
    DRS_EXT_DCINFO_V2,      // supports DS_DOMAIN_CONTROLLER_INFO_2
    DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD,
        // inbound repl doesn't require instance type in repl stream for mods
    DRS_EXT_CRYPTO_BIND,    // supports RPC session key setup on bind
    DRS_EXT_GET_REPL_INFO,  // supports IDL_DRSGetReplInfo
    DRS_EXT_STRONG_ENCRYPTION,
        // supports additional 128 bit encryption for passwords over the wire
    DRS_EXT_DCINFO_VFFFFFFFF,
        // supports DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF
    DRS_EXT_TRANSITIVE_MEMBERSHIP,
        // supports transitive membership expansion at G.C
    DRS_EXT_ADD_SID_HISTORY,// supports DRS_MSG_ADDSIDREQ
    DRS_EXT_POST_BETA3,     // supports sending/receiving schema info,
                            //  DS_REPL_INFO_KCC_DSA_*_FAILURES,
                            //  and DS_REPL_PENDING_OPSW
    DRS_EXT_GETCHGREQ_V5,   // supports DRS_MSG_GETCHGREQ_V5
    DRS_EXT_GETMEMBERSHIPS2,   // supports DRS_MSG_GETMEMBERSHIPS2
    DRS_EXT_GETCHGREQ_V6,   // supports DRS_MSG_GETCHGREQ_V6
    DRS_EXT_NONDOMAIN_NCS,  // understands non-domain NCs
    DRS_EXT_GETCHGREQ_V8,   // supports DRS_MSG_GETCHGREQ_V8
    DRS_EXT_GETCHGREPLY_V5, // supports DRS_MSG_GETCHGREPLY_V5
    DRS_EXT_GETCHGREPLY_V6, // supports DRS_MSG_GETCHGREPLY_V6   
    DRS_EXT_WHISTLER_BETA3, // supports DRS_MSG_ADDENTRYREPLY_V3, 
                            //          DRS_MSG_REPVERIFYOBJ
                            //          DRS_MSG_GETCHGREPLY_V7
    DRS_EXT_XPRESS_COMPRESSION, // supports the Xpress compression library
    //    NO MORE BITS AVAILABLE
    // BUGBUG Either this flag DRS_EXT_RESERVED_FOR_WIN2K_PART2 or the 
    //        DRS_EXT_LAST_FLAG (preferred if it can be used) will need
    //        to be used to signal to use the extended extension bits
    //        that you'll have to create if you want a new extension bit! :)
    DRS_EXT_RESERVED_FOR_WIN2K_PART1,
    DRS_EXT_RESERVED_FOR_WIN2K_PART2, // 30
    //
    // AND DON'T FORGET TO UPDATE UTIL\REPADMIN\REPDSREP.C and DSEXTS\MD.C!
    //
    DRS_EXT_LAST_FLAG = 31,

    // Bits to hold site guid.
    DRS_EXT_SITEGUID_BEGIN = 32,
    DRS_EXT_SITEGUID_END = DRS_EXT_SITEGUID_BEGIN + sizeof(GUID)*8 - 1,

    // Bits to hold client process ID (to facilitate leak tracking).
    DRS_EXT_PID_BEGIN,
    DRS_EXT_PID_END = DRS_EXT_PID_BEGIN + sizeof(int)*8 - 1,

    // Bits to hold replication epoch.
    DRS_EXT_EPOCH_BEGIN,
    DRS_EXT_EPOCH_END = DRS_EXT_EPOCH_BEGIN + sizeof(DWORD)*8 - 1,

    DRS_EXT_MAX
} DRS_EXT;

// We decided that it'd be better self-documenting code if we tied
// this paticular bit BETA3 to conceptual bits describing what they
// do.  This makes code/repadmin/dsexts/everything much more clear.
// If someone is passionate enough, they could make DRS_EXT_POST_BETA2
// into a similar breakdown.
#define DRS_EXT_ADDENTRYREPLY_V3    DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_GETCHGREPLY_V7      DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_VERIFY_OBJECT       DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_QUERYSITESBYCOST_V1 DRS_EXT_WHISTLER_BETA3


// Maximum length in bytes of an extensions _string_ containing any bits we care
// about.  (Incoming strings can be longer if they come from an up-level DSA,
// but if so the extra bytes contain bits for extensions we don't know about, so
// we need not store them.)
#define CURR_MAX_DRS_EXT_FIELD_LEN (1 + ((DRS_EXT_MAX - 1)/ sizeof(BYTE)))

// Maximum length in bytes of an extensions _structure_ containing any bits we
// care about.
#define CURR_MAX_DRS_EXT_STRUCT_SIZE \
    (sizeof(DWORD) + CURR_MAX_DRS_EXT_FIELD_LEN)

// Length in bytes of the given extensions structure.
#define DrsExtSize(pext) ((pext) ? sizeof(DWORD) + (pext)->cb : 0)

// Is the specified extension supported in the given DRS_EXTENSIONS set?
#define IS_DRS_EXT_SUPPORTED(pext, x)                   \
    ((NULL != (pext))                                   \
     && ( (pext)->cb >= 1+((x)/8) )                     \
     && ( 0 != ( (pext)->rgb[(x)/8] & (1<<((x)%8) ))))

// Get a pointer to the dwReplEpoch for a DSA given its DRS_EXTENSIONS, or 0
// if unavailable.
#define REPL_EPOCH_FROM_DRS_EXT(pext)                               \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, dwReplEpoch)    \
                       + sizeof(DWORD)   /* dwReplEpoch */          \
                       - sizeof(DWORD))) /* cb */                   \
     ? 0                                                            \
     : ((DRS_EXTENSIONS_INT *)(pext))->dwReplEpoch)

// Get a pointer to the site objectGuid for a DSA given its DRS_EXTENSIONS, or
// NULL if unavailable.
#define SITE_GUID_FROM_DRS_EXT(pext)                                \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, SiteObjGuid)    \
                       + sizeof(GUID)    /* SitObjGuid */           \
                       - sizeof(DWORD))) /* cb */                   \
     ? NULL                                                         \
     : &((DRS_EXTENSIONS_INT *)(pext))->SiteObjGuid)

// Given the DRS extensions for a given DSA, determine whether it's in the
// given site.  If a definite determination cannot be made, errs on the side
// of "same site."
#define IS_REMOTE_DSA_IN_SITE(pext, pSiteDN)        \
    ((NULL == (pSiteDN))                            \
     || fNullUuid(&(pSiteDN)->Guid)                 \
     || fNullUuid(SITE_GUID_FROM_DRS_EXT(pext))     \
     || (0 == memcmp(&(pSiteDN)->Guid,              \
                     SITE_GUID_FROM_DRS_EXT(pext),  \
                     sizeof(GUID))))



// Destination can support linked value replication data
// Does the DSA support linked value replication
#define IS_LINKED_VALUE_REPLICATION_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_LINKED_VALUE_REPLICATION)

// Safely set extension as supported
#define SET_DRS_EXT_SUPPORTED(pext, x) \
{ \
      if ( (NULL != (pext)) && ( (pext)->cb >= 1+((x)/8) ) )  \
            (pext)->rgb[(x)/8] |= (1<<((x)%8)); \
      }


// Schema prefix table.

typedef struct OID_s {
    RANGE(0,MAX_CB_OID_ELEMS) unsigned length;
    SIZE_IS(length) BYTE * elements;
} OID_t;

typedef struct {
    DWORD       ndx;
    OID_t       prefix;
} PrefixTableEntry;

typedef struct {
    RANGE(0,MAX_PREFIX_TAB_ENT_IN_SCHEMA_PREFIX_TAB)
        DWORD PrefixCount;
    SIZE_IS(PrefixCount)
        PrefixTableEntry *  pPrefixEntry;
} SCHEMA_PREFIX_TABLE;

//
// This begins the on the wire representation of the thread state error
// NOTE: if the DIRERR struct is changed then you should increment the
// version of the DRS_Error_Data_V1 and make a function that can convert
// and package and unpackage the error state.  See:
//      DRS_SetDirErr_SemiDeepCopy() and
//      DRS_THError_SemiDeepCopy()
//

typedef struct _NAMERESOP_DRS_WIRE_V1
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP_DRS_WIRE_V1;

typedef struct ANYSTRINGLIST_DRS_WIRE_V1{       /* A list of substrings to match */
    struct ANYSTRINGLIST_DRS_WIRE_V1 FAR *pNextAnyVal;

                                   // ISSUE:  See security comments on ENTINFLIST

    ATTRVAL AnyVal;
}ANYSTRINGLIST_DRS_WIRE_V1;

typedef struct SUBSTRING_DRS_WIRE_V1{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal_DRS_WIRE_V1{
    USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST_DRS_WIRE_V1 FirstAnyVal; /* a list of substrings to match */

                               // ISSUE:  BAD FORM:  if we know "count", then
                   // why use a linked list, why not an array?
                               // with the linked list we can't get RPC to
                               // validate size for us.  So we have to do this
                               // ourselves in the server code (ie count=
                   // number of elements(FirstAnyVal))

    }AnyVal_DRS_WIRE_V1;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING_DRS_WIRE_V1;

/**************************************************************************
 *    Error Data Structures
 **************************************************************************/

// Obviously this is now an external format error.
typedef struct INTERNAL_FORMAT_PROBLEM_DRS_WIRE_V1
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB_DRS_WIRE_V1;

typedef struct _PROBLEMLIST_DRS_WIRE_V1
{
    struct _PROBLEMLIST_DRS_WIRE_V1 FAR *pNextProblem; /* linked-list to next prob att */

                                       // ISSUE:  See security comments on ENTINFLIST 

    INTFORMPROB_DRS_WIRE_V1 intprob;
} PROBLEMLIST_DRS_WIRE_V1;



/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

typedef UNICODE_STRING DSA_ADDRESS;
typedef struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 {
    struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pNextAddress;

                      // ISSUE:  See security comments on ENTINFLIST 

    // For ease marshalling I turned this into a pointer, so this is
    // not exactly like the original.
    
    // ISSUE:  This should have been [ref] - but we can't change without breaking backward compat
    DSA_ADDRESS *                            pAddress;
} DSA_ADDRESS_LIST_DRS_WIRE_V1;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

#define CH_REFTYPE_SUPERIOR     0
#define CH_REFTYPE_SUBORDINATE  1
#define CH_REFTYPE_NSSR         2
#define CH_REFTYPE_CROSS        3

typedef struct CONTREF_DRS_WIRE_V1
{
    PDSNAME                         pTarget;        /* target name in continuing operation */
    NAMERESOP_DRS_WIRE_V1           OpState;        /* operation status */
    USHORT                          aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT                          RDNsInternal;   /* reserved */
    USHORT                          refType;        /* reserved */
    USHORT                          count;          /* number of access points */

                            // ISSUE:  See bad form comments on SUBSTRING_DRS_WIRE_V1

    DSA_ADDRESS_LIST_DRS_WIRE_V1 *  pDAL;           /* linked list of access points */      

    struct CONTREF_DRS_WIRE_V1 *    pNextContRef;   /* linked list of CRs */

                            // ISSUE:  See security comments on ENTINFLIST 
    
    // NOTE: This is assumed to be NULL, and is skipped.  For the purposes
    // of IDL_DRSAddEntry() we won't get a referral with a Filter.  However, if
    // someone did a remote search type thing, then they could get a filter in
    // the thread state error, and then they'd have to update the existing DRS
    // thread state packaging routines to account for and package up the filter.
    // PFILTER_DRS_WIRE_V1             pNewFilter;     /* new filter (optional) */

    BOOL                            bNewChoice;     /* is a new choice present? */
    UCHAR                           choice;         /* new search choice (optional) */
} CONTREF_DRS_WIRE_V1;

/* These are the seven problem types wire versions, for more   */ 
/* information about each kind look lower to the type without  */
/* the _DRS_WIRE_V1 appended                                   */

typedef struct ATRERR_DRS_WIRE_V1
{
    PDSNAME                    pObject;        /* name of the offending object */
    ULONG                      count;          /* the number of attribute errors */

                           // ISSUE:  See bad form comments on SUBSTRING_DRS_WIRE_V1

    PROBLEMLIST_DRS_WIRE_V1    FirstProblem;   /* a linked-list of attribute errors */     
} ATRERR_DRS_WIRE_V1;

typedef struct NAMERR_DRS_WIRE_V1
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above. */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR_DRS_WIRE_V1;

typedef struct REFERR_DRS_WIRE_V1
{
    DWORD                dsid;
    DWORD                extendedErr;        /* Non-standard error code */
    DWORD                extendedData;   /* extra data to go with it */
    CONTREF_DRS_WIRE_V1  Refer;                 /* alternate DSAs to contact */
} REFERR_DRS_WIRE_V1;

typedef struct _SECERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR_DRS_WIRE_V1;

typedef struct _SVCERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR_DRS_WIRE_V1;

typedef struct _UPDERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR_DRS_WIRE_V1;

typedef struct _SYSERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR_DRS_WIRE_V1;


/* This is the number of errors alloted per return code type. */

#define   DIR_ERROR_BASE      1000

/* These error defines correspond to API return codes. */

#define attributeError      1   /* attribute error */
#define nameError           2   /* name error */
#define referralError       3   /* referral error */
#define securityError       4   /* security error */
#define serviceError        5   /* service error */
#define updError            6   /* update error */
#define systemError         7   /* system error */

/*

    This is the wire version of the mail DIRERR info for transfering the
    thread state error.  If changes need to be made, then all structures
    above the structure will need to change to a version 2.  So for 
    instances if you changed the referral error to include the pFilter
    which it doesn't (in V1) have, then the below RefErr element would be
    of type REFERR_DRS_WIRE_V2, while the rest could remain unchanged.  
    CONTREF_DRS_WIRE_V1 would goto V2 as well.
    
    Then the encoding and decoding routines in dramderr.c would need to
    be updated to handle the different versions, and set the dwErrVer 
    correctly in the using routines, and marshall/translate/set the
    pErrData correctly depending on the new version.
    
*/    
typedef SWITCH_TYPE(DWORD) union _DIRERR_DRS_WIRE_V1
{
    CASE(attributeError) ATRERR_DRS_WIRE_V1  AtrErr;  /* attribute error */
    CASE(nameError)      NAMERR_DRS_WIRE_V1  NamErr;  /* name error      */
    CASE(referralError)  REFERR_DRS_WIRE_V1  RefErr;  /* referral error  */
    CASE(securityError)  SECERR_DRS_WIRE_V1  SecErr;  /* security error  */
    CASE(serviceError)   SVCERR_DRS_WIRE_V1  SvcErr;  /* service error   */
    CASE(updError)       UPDERR_DRS_WIRE_V1  UpdErr;  /* update error    */
    CASE(systemError)    SYSERR_DRS_WIRE_V1  SysErr;  /* system error    */
} DIRERR_DRS_WIRE_V1;


/***************************************************************************

    NOTHING BELOW THIS LINE WILL BE INCLUDED IN THE MIDL COMPILATION STAGE!

 ***************************************************************************/
#ifndef MIDL_PASS

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)




/***************************************************************************
 *    Filter Definitions
 ***************************************************************************/


typedef struct ANYSTRINGLIST{       /* A list of substrings to match */
    struct ANYSTRINGLIST FAR *pNextAnyVal;

    ATTRVAL AnyVal;
}ANYSTRINGLIST;

typedef struct SUBSTRING{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal{
        USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST FirstAnyVal; /* a list of substrings to match */
    }AnyVal;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING;


/* A filter item indicates a logical test of an AVA.  This means that
 * the provided attribute value should have one of these test performed
 * against the attribute value found on the directory object.
 */

typedef struct FILITEM{
    UCHAR   choice;                /* The type of operator:
                                    * Valid values defined in filtypes.h
                                    */
    struct FilTypes{
        AVA           ava;         /* contain the value for all binary relops */
        SUBSTRING FAR *pSubstring; /* substring match             */
        ATTRTYP       present;     /* attribute presence on entry */
        BOOL          *pbSkip;     /* when evaling filter, dont read from DB */
                                   /* Set to false for security purposes */
    }FilTypes;

    DWORD             expectedSize; /* The estimated size of this Filter Item */
                                    /* Zero means not estimated */
}FILITEM;



/* This is a linked list of filters that are either Anded or Orded together.*/

struct FilterSet{
    USHORT              count;         /* number of items in linked-set */
    struct FILTER FAR * pFirstFilter;  /* first filter in set */
};




/* The filter is used to construct an arbitrary logical test of a
 *   directory object.  It consists of either a single item (see
 *   FILIITEM above) which is a test of a single attribute,
 *   a set of attribute tests (FilterSet) Anded or Ored together,
 *   or a negation of a test or an attribute set.
 *
 *   The following examples should illustrate how filter structures work.
 *   Actual attribute names and values are omitted to simplify the examples.
 *
 *   EXAMPLE:
 *
 *        A = 5
 *
 *        item
 *        ------
 *       | A=5  |
 *        ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and (b = ab) and (c = 2)
 *
 *        AND set            item            item            item
 *        -------- first    ------ next     ------ next     ------
 *       | 3 items|---->   | A=5  |---->   | b=ab |---->   | c=2  |
 *        -------- filter   ------ filter   ------ filter   ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and ((b = "abc") or (c = 2)) and (d <=1)
 *
 *        AND set            item           OR set           item
 *        -------- first    ------ next     -------- next    ------
 *       | 3 items|---->   | A=5  |---->   | 2 items|--->   | d<=1 |
 *        -------- filter   ------ filter   -------- filter  ------
 *                                                 |
 *                                           first | filter
 *                                                 V
 *                                                item          item
 *                                             -------- next    ------
 *                                            | b="abc"|---->  | c=2  |
 *                                             -------- filter  ------
 *
 */

typedef struct FILTER{
    struct FILTER FAR *pNextFilter;  /* points to next filter in set */
    UCHAR   choice;                      /* filter type
                                          * Valid values defined in filtypes.h
                                          */
    struct _FilterTypes{                          /* based on the choice */
        FILITEM           Item;
        struct FilterSet  And;
        struct FilterSet  Or;
        struct FILTER FAR *pNot;
    }FilterTypes;
}FILTER;

typedef FILTER FAR *PFILTER;

typedef ULONG MessageId;

/* The service control structure allows the client to control how
 *    directory operations are performed.
 *
 * Prefer chaining indicates that the client perfers that distributed
 *    operations are chained rather than referred.  This does not guarantee
 *    what type of distribution may actually be used.
 *
 * ChainingProhibited stops the DSA from contacting other DSA's if the
 *    information needed to satisfy the operation resides in another DSA.
 *    Instead it will construct a referral list of DSA's for the
 *    client to contact directly. This gives the client control over the cost
 *    of a distributed operation.
 *
 * Local scope tells the DSA to only contact DSA's that are nearby
 *    (perhaps even on the same subnet) if it can't complete
 *    an operation alone.  The client may receive a referral list
 *    of other DSA's to contact if the operation couldn't be satisfied by
 *    the local set of DSA's.  This flag lets the client limit the cost of
 *    an operation by prohibiting contact to DSA's that are expensive to reach.
 *
 * DontUseCopy tells the directory that the target of the operation
 *    is the master object.  This is used when the client (usually an
 *    administrator) needs the up-to-date version of a directory object.
 *
 * DerefAliasFlag tells the directory what kind of aliases to dereference.
 *    Valid values are:
 *    DA_NEVER - never deref aliases
 *    DA_SEARCHING - deref when searching, but not for locating the base
 *                   of the search.
 *    DA_BASE - deref in locating the base of the search, but not while s
 *              searching
 *    DA_ALWAYS - always deref aliases.
 *
 * MakeDeletionsAvail is used by the internal synchronization process only.
 *    It makes visible objects that have been deleted but not yet physically
 *    removed from the system.
 *
 * DontPerformSearchOp is used to get Search Statistics from the DS using the
 *    LDAP STATS control. There are two options:
 *      a) optimize the search query and return expected number of operations
 *         without visiting the actual entries on the disk
 *      b) perform the query, but instead of returning the real data, return
 *         statistics for the query performed
 *
 * pGCVerifyHint - The DS verifies all DSNAME-valued properties for existence
 *    either against itself if it holds the naming context in question, or
 *    against a GC if not.  There are cases where apps need to add an object O1
 *    on machine M1 and then immediately thereafter add a reference to O1 on
 *    object O2 on machine M2.  M2 will fail the O1 verification check if
 *    it doesn't hold O1's NC and its choice of GC is not M1, or if it does
 *    hold O1's NC but isn't the replica where O1 was just added.  This field
 *    allows a client to tell the DS which machine to perform DSNAME
 *    verification against.  This hint is unilateral and unconditional in that
 *    if specified, all DSNAME-valued properties will be verified at the
 *    specified machine and no where else, not even locally.  Best results
 *    are obtained when the value is the DNS host name for a DC, though other
 *    forms of names may work in certain environments.
 *
 *   NOTE: The omission of the SVCCNTL (null pointer) parameter will default
 *   to no preference for chaining, chaining not prohibited, no limit on the
 *   scope of operation, use of a copy permitted, aliases will be dereferenced,
 *   a copy can not be updated and deletions will not be visible.
 *
 * fAllowIntraForestFPO -- allows an FPO to be created even if the SID is from
 *                         a domain in the forest.  The FPO task will clean
 *                         this up.  This is unused during installation when
 *                         a GC may not be available to find the object's GUID.
 */


typedef struct SVCCNTL
{
    ULONG SecurityDescriptorFlags;    /*  flags describing what part  */
                                      /*  of the SD to read.          */
    unsigned DerefAliasFlag:2;        /*  don't dereference an alias  */
    BOOL preferChaining:1;            /*  chaining is preferred       */
    BOOL chainingProhibited:1;        /*  chaining prohibited         */
    BOOL localScope:1;                /*  local scope chaining only   */
    BOOL dontUseCopy:1;               /*  dont use copy               */

    /* Non standard extensions.  Set to TRUE */
    // None yet.

    /* Non standard extensions.  Set to FALSE */
    BOOL makeDeletionsAvail:1;
    BOOL fAllowIntraForestFPO:1;      /* allow FPO for intra forest SID */
    BOOL fStringNames:1;
    BOOL fSDFlagsNonDefault:1;
    BOOL fPermissiveModify:1;         /* don't err on update errors that   */
                                      /* do not affect the final object    */
                                      /* (e.g., remove of non-extant value */
    BOOL fUrgentReplication:1;        /* Skip wait to being replication */
    BOOL fAuthoritativeModify:1;      /* Change made is authoritative   */
                                      /* and wins against any other     */
                                      /* version that currently exists  */
                                      /* in the enterprise              */
    BOOL fMaintainSelOrder:1;         /* Don't reorder selection list   */
    BOOL fDontOptimizeSel:1;          /* Don't touch selection list     */
    BOOL fGcAttsOnly:1;               /* Only request for GC Partial Atts */

    BOOL fMissingAttributesOnGC:1;    /* Client requested attributes that */
                                      /* were not visible on the GC port */

    unsigned DontPerformSearchOp:2;   /* Do not perform actual search Op */

    WCHAR *pGCVerifyHint;             /* See description above          */

} SVCCNTL;

#define DA_NEVER     0
#define DA_SEARCHING 1
#define DA_BASE      2
#define DA_ALWAYS    (DA_SEARCHING | DA_BASE)

#define SO_NORMAL        0
#define SO_STATS         1
#define SO_ONLY_OPTIMIZE 2

/*  This structure is used by the client to continue an ongoing
 *   operation with a different DSA.  This occurs when a DSA does not have
 *   the information needed to complete an operation but knows of other
 *   DSA's that may be able to perform the operation that it can not
 *   contact for various reasons (e.g SVCCNTL's).  The information that is
 *   returned from the DSA is used to set this data structure (see REFERR
 *   error).
 *
 *   The nameRes filed is usually set to OP_NAMERES_NOT_STARTED.
 */

#define OP_NAMERES_NOT_STARTED          'S'
#define OP_NAMERES_PROCEEDING           'P'
#define OP_NAMERES_COMPLETED            'C'

typedef struct _NAMERESOP
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP;

typedef unsigned char BYTE;


/*
local_extension

A local_extension is similar to the X.500 extension object.
It provides a method for extending the protocol. Local extensions
are Microsoft specific.

Each extension is identified by an OID. In addition, the
extension has a critical boolean, which is true if the extension
is critical (i.e. must be supported for the call to be properly
serviced). The item element points to extension specific
data.
*/

/*
Paged Results

Although technically a local extension, Paged Results is made a
permanent part of the common arguments structure.  It is intended
to work like this:

The common argument structure contains a pointer to the PR restart
data structure provided by the user, if present.  The possible
conditions are:

fPresent FALSE => user didn't request PR; pRestart set to NULL

fPresent TRUE, pRestart NULL => first call (not a restart), PR requested

fPresent TRUE, pRestart != NULL => restart (cotinue) PR call

*/

/*
Unicode strings
Unicode strings is another microsoft extension that allows clients to request
strings of syntax OM_S_UNICODE_STRING to be returned as such. by default,
such strings are translated to OM_S_TELETEX_STRING.
*/

//
// Possible values of the restartType variable in a RESTART struct.
//
#define NTDS_RESTART_PAGED 1
#define NTDS_RESTART_VLV   2

typedef struct _RESTART
{
    // !! Any changes to this struct must leave !!
    // !! the 'data' member 8 byte aligned      !!
    ULONG       restartType;            // Is this a paged search restart or vlv.
    ULONG       structLen;              // The size of this whole structure.
    BYTE        CRC[20];                // the CRC of this whole structure -- size should
                                        // match sizeof(STRONG_CHECKSUM) from pek.h!!!
    GUID        serverGUID;             // the GUID of the server that created this structure
    union {
        __int64 _align64[];             // forces 8-byte alignment of data[]
        DWORD   data[];                 // Hand marshalled data holding the
                                        // restart information.  We use DWORDs
                                        // because most of the packed data is
                                        // DWORD and I want to encourange
                                        // alignment.
    };
} RESTART, * PRESTART;

typedef struct
{
    PRESTART    pRestart;       /* restart data */
    BOOL        fPresent:1;
} PAGED_RESULT;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for VLV results)
    BOOL           fseekToValue:1;    // flag whether we navigate using seekValue or
                                      // targetPosition
    IN ULONG       beforeCount;       // number of entries before target
    IN ULONG       afterCount;        // number of entries after target
    IN OUT ULONG   targetPosition;    // target position (offset from start)
                                      // in = Ci, out = Si
    IN OUT ULONG   contentCount;      // size of container
                                      // in = Cc, out = Sc
    IN ATTRVAL     seekValue;         // the value we seek From

    IN OUT PRESTART pVLVRestart;      // Restart Argument

    DWORD           Err;              // VLV Specific Service Error

} VLV_REQUEST, * PVLV_REQUEST;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for ASQ results)
    BOOL           fMissingAttributesOnGC:1; // Flag whether the search operation
                                             // references attributes that are
                                             // not part of the GC partial attr set


    ATTRTYP        attrType;

    DWORD          Err;               // ASQ Specific Service Error

} ASQ_REQUEST, * PASQ_REQUEST;


/*  These common input arguments are supplied with most directory
    calls.  The service controls provide client options that govern the
    operation.  The operation state specifies if this is  a new or
    continued operation (see OPERATION above).  The aliasRDN is only set
    if this is a continuation of a referral (see REFERR).  It is  set
    from the aliasRDN of the continuation referrence of the referral.

    Note that pReserved must be set to NULL!
*/


typedef struct _COMMARG
{
    SVCCNTL         Svccntl;     /* service controls */
    NAMERESOP       Opstate;     /* the state of the operation */
    ULONG         * pReserved;   /* Must be set to NULL*/
    ULONG           ulSizeLimit; /* size limit */
    ATTRTYP         SortAttr;    /* Attribute to sort on. */
    int             Delta;       /* Number of objects to skip on a list or
                                    search. Negative means walk backwards.  */
    ULONG           StartTick;   /* Tick count of the start of this operation
                                    0 means no time limit.                  */
    ULONG           DeltaTick;   /* Number of ticks to let this operation run.*/
    USHORT          aliasRDN;    /* number of RDN's produced by alias dereferencing */
    ULONG           SortType;    /* 0 - none, 1 - optional sort, 2-mandatory */
    BOOL            fForwardSeek:1;/* should the results of a list or search be
                                      constructed from the next objects, or the
                                      previous objects in whatever index we
                                      use. */
    BOOL            fLazyCommit:1; /* Can JET commit lazily? */
    BOOL            fFindSidWithinNc:1; /* Tells Do Name Res, to find a DS Name
                                         with only a Sid specified to be in
                                         the NC of authoritative Domain for
                                         the domain controller */

    DWORD           MaxTempTableSize;   // max entries per temp table

    PAGED_RESULT    PagedResult; /* Paged Results local extension */
    VLV_REQUEST     VLVRequest;  /* VLV Request local extension   */
    ASQ_REQUEST     ASQRequest;  /* ASQ Request local extension */
    PSID            pQuotaSID;   /* SID to be used for returning quota info */

//  QUOTA_UNDONE: because multiple modules (ntdsa, samsrv, etc.), use this
//  structure, a full timebuild is required or else there will be size
//  mismatches when this struct is passed from one module to the next
//
//  PSID            pQuotaSID;   /* SID to be used for returning quota info */

} COMMARG;

/* ...and a routine to give you default values.  Use it! */
VOID InitCommarg(COMMARG *pCommArg);

typedef struct _COMMRES {
    BOOL            aliasDeref;
    ULONG           errCode;
    union _DIRERR  *pErrInfo;
} COMMRES;

// Values for SortType
#define SORT_NEVER     0
#define SORT_OPTIONAL  1
#define SORT_MANDATORY 2

/*  This data structure is used on DirRead and DirSearch operations
 *  to specify the type of information the directory should return.  The
 *  client must specify the return of some or all of the object
 *  attributes found.  If only some attributes are to be returned, the
 *  client must provide a list of the desired attribute types.  An
 *  indication of some attributes together with a NULL attribute list
 *  indicates that no attributes are to be returned.  Attributes are
 *  returned only if they are present.  An attributeError with the
 *  PR_PROBLEM_NO_ATTRIBUTE designation will be returned if none of the
 *  selected attributes are present.
 *
 *  The client also specifies whether the attribute types or both the
 *  types and values should be returned.
 */

#define EN_ATTSET_ALL            'A'  /* get all atts                        */
#define EN_ATTSET_ALL_WITH_LIST  'B'  /* get all atts and list               */
#define EN_ATTSET_LIST           'L'  /* get selected atts                   */
#define EN_ATTSET_LIST_DRA       'E'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA        'D'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_EXT   'F'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA_EXT    'G'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_PUBLIC   'H'  /* get selected atts, deny special DRA, deny secret */
#define EN_ATTSET_ALL_DRA_PUBLIC    'I'  /* get all atts except special DRA, deny secret     */

#define EN_INFOTYPES_TYPES_ONLY  'T'  /* return att types only               */
#define EN_INFOTYPES_TYPES_MAPI  't'  /* types only, obj name in MAPI form   */
#define EN_INFOTYPES_TYPES_VALS  'V'  /* return types and values             */
#define EN_INFOTYPES_SHORTNAMES  'S'  /* Types + values, short DSName format */
#define EN_INFOTYPES_MAPINAMES   'M'  /* Types + values, MAPI DSName format  */

typedef struct _ENTINFSEL
{
    UCHAR        attSel;      /*  Retrieve all or a list of selected atts:
                               *  Valid values:
                               *    see EN_ATTSET_* defines above
                               */
    ATTRBLOCK    AttrTypBlock; /*  counted block of attribute types */
    UCHAR        infoTypes;    /*  Retrieve attribute types or types and values
                                *  Valid values:
                                *     see EN_INFOTYPES_* defines above
                                */
} ENTINFSEL;



/**************************************************************************
 *    Attribute Value Syntax Data Types
 **************************************************************************/

#define SYNTAX_UNDEFINED_TYPE           0
#define SYNTAX_DISTNAME_TYPE            1
#define SYNTAX_OBJECT_ID_TYPE           2
#define SYNTAX_CASE_STRING_TYPE         3
#define SYNTAX_NOCASE_STRING_TYPE       4
#define SYNTAX_PRINT_CASE_STRING_TYPE   5
#define SYNTAX_NUMERIC_STRING_TYPE      6
#define SYNTAX_DISTNAME_BINARY_TYPE     7
#define SYNTAX_BOOLEAN_TYPE             8
#define SYNTAX_INTEGER_TYPE             9
#define SYNTAX_OCTET_STRING_TYPE        10
#define SYNTAX_TIME_TYPE                11
#define SYNTAX_UNICODE_TYPE             12

/* MD specific attribute syntaxes. */
#define SYNTAX_ADDRESS_TYPE             13
#define SYNTAX_DISTNAME_STRING_TYPE    14
#define SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE 15
#define SYNTAX_I8_TYPE                  16
#define SYNTAX_SID_TYPE                 17


/*  All attribute syntaxes are represented as a linear values.  This  means
 *  that an entire attribute value is stored in a contiguous set of bytes
 *  that contain no pointers.  Valid comparisons are defined in dbsyntax.c
 */

typedef UCHAR    SYNTAX_UNDEFINED;
typedef DSNAME   SYNTAX_DISTNAME;
typedef ULONG    SYNTAX_OBJECT_ID;
typedef UCHAR    SYNTAX_CASE_STRING;
typedef UCHAR    SYNTAX_NOCASE_STRING;
typedef UCHAR    SYNTAX_PRINT_CASE_STRING;
typedef UCHAR    SYNTAX_NUMERIC_STRING;
typedef BOOL     SYNTAX_BOOLEAN;
typedef long     SYNTAX_INTEGER;
typedef UCHAR    SYNTAX_OCTET_STRING;
typedef DSTIME   SYNTAX_TIME;
typedef wchar_t  SYNTAX_UNICODE;
typedef UCHAR    SYNTAX_NT_SECURITY_DESCRIPTOR;
typedef LARGE_INTEGER SYNTAX_I8;
typedef UCHAR    SYNTAX_SID;


typedef struct _SYNTAX_ADDR
{
    ULONG structLen;                    // Total length of this structure,
                                        // in BYTES!!!

    union {
        BYTE    byteVal[1];
        wchar_t uVal[1];
    };

} SYNTAX_ADDRESS;

typedef SYNTAX_ADDRESS STRING_LENGTH_PAIR;

/*
 * The following macro's can be used to correctly calculate the structlen
 * of a SYNTAX_ADDRESS from the payload length, or vice versa.
 */
#define PAYLOAD_LEN_FROM_STRUCTLEN( structLen ) \
    ((structLen) - sizeof(ULONG))

#define STRUCTLEN_FROM_PAYLOAD_LEN( stringLen ) \
    ((stringLen) + sizeof(ULONG))


/*  Note: In general, the <String> field of the following structure
 *  should not be directly referenced since the preceding <Name> field
 *  is variable-sized.  Also, one should not should not rely on the
 *  "sizeof()" operator's evaluation of the size of the structure since
 *  the size of the SYNTAX_DISTNAME <Name> will usually be larger than
 *  "sizeof(SYNTAX_DISTNAME)."
 */

typedef struct _SYNTAX_DISTNAME_DATA
{
    DSNAME         Name;                // the Distinguished Name
    SYNTAX_ADDRESS Data;                // The data
} SYNTAX_DISTNAME_STRING, SYNTAX_DISTNAME_BINARY;


/*  The following defines can be used to find <Name> and <Data>
 *  fields and otherwise manipulate _SYNTAX_DISTNAME_BLOB attributes.
 */

/* produce a pointer to the <Name> field: */

#define NAMEPTR( pDN_Blob ) \
    ((DSNAME *) (&(pDN_Blob)->Name))


// Produce the size of a given DISTNAME, padded to the nearest 4 bytes.
#define PADDEDNAMEMASK (~3)
#define PADDEDNAMESIZE(pDN) \
    (((pDN)->structLen + 3) & PADDEDNAMEMASK)

/* produce a pointer to the <Address> field: */
#define DATAPTR( pDN_Blob ) \
    ((SYNTAX_ADDRESS *)(PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + (char *)(pDN_Blob)))

/* find the combined size of the <Name> and <Data> structures: */
#define NAME_DATA_SIZE( pDN_Blob ) \
    (PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + DATAPTR(pDN_Blob)->structLen)

/* given a DSNAME and a SYNTAX_ADDRESS, find their combined size: */
#define DERIVE_NAME_DATA_SIZE( pDN, pData ) \
    (PADDEDNAMESIZE(pDN) + (pData)->structLen)

/*  Given a SYNTAX_DISTNAME, a STRING_LENGTH_PAIR, and pre-allocated space
    of the appropriate size, build a _SYNTAX_DISTNAME_BLOB attribute
    by copying in its component parts:
*/

#define BUILD_NAME_DATA( pDN_Blob, pDN, pData ) \
    memcpy( NAMEPTR(pDN_Blob), (pDN)  , (pDN)->structLen ); \
    memcpy( DATAPTR(pDN_Blob), (pData), (pData)->structLen );


/**************************************************************************
 *    Error Data Structures
 **************************************************************************/


/* An ATRERR reports an attribute related problem */

#define ATRERR_BASE                     ( attributeError * DIR_ERROR_BASE )

#define PR_PROBLEM_NO_ATTRIBUTE_OR_VAL      ( ATRERR_BASE + 1 )
#define PR_PROBLEM_INVALID_ATT_SYNTAX       ( ATRERR_BASE + 2 )
#define PR_PROBLEM_UNDEFINED_ATT_TYPE       ( ATRERR_BASE + 3 ) /*DirAddEntry &
                                                                 * DirModEntry
                                                                 * only
                                                                 */
#define PR_PROBLEM_WRONG_MATCH_OPER         ( ATRERR_BASE + 4 )
#define PR_PROBLEM_CONSTRAINT_ATT_TYPE      ( ATRERR_BASE + 5 )
#define PR_PROBLEM_ATT_OR_VALUE_EXISTS      ( ATRERR_BASE + 6 )

/*

   Most of the error data structures (like the ones below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct INTERNAL_FORMAT_PROBLEM
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB;

typedef struct PROBLEMLIST
{
    struct PROBLEMLIST FAR *pNextProblem; /* linked-list to next prob att */
    INTFORMPROB intprob;      
} PROBLEMLIST;

typedef struct ATRERR
{
    PDSNAME     pObject;        /* name of the offending object */
    ULONG       count;          /* the number of attribute errors */
    PROBLEMLIST FirstProblem;   /* a linked-list of attribute errors */
} ATRERR;




/*  A NAMERR reports a problem with a name provided as an operation argument.
 *  Note that a problem with the attribute types and/or values in a DistName
 *  used as an operation argument is reported via a NAMERR with problem
 *  NA_PROBLEM_BAD_ATT_SYNTAX rather than as an ATRERR or an UPDERR
 */

#define NAMERR_BASE                         ( nameError * DIR_ERROR_BASE )

#define NA_PROBLEM_NO_OBJECT                ( NAMERR_BASE + 1 )
#define NA_PROBLEM_NO_OBJ_FOR_ALIAS         ( NAMERR_BASE + 2 )
#define NA_PROBLEM_BAD_ATT_SYNTAX           ( NAMERR_BASE + 3 )
#define NA_PROBLEM_ALIAS_NOT_ALLOWED        ( NAMERR_BASE + 4 )
#define NA_PROBLEM_NAMING_VIOLATION         ( NAMERR_BASE + 5 )
#define NA_PROBLEM_BAD_NAME                 ( NAMERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct NAMERR
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above.
                                 */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR;


/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

/*  The access point is the name and address of a DSA to contact.
 *  This is returned from a DSA referral and is used to bind to a
 *  referred DSA (see DirBind).
 */

typedef SYNTAX_DISTNAME_STRING ACCPNT;

/* A list of access points is returned on referrals. */
typedef struct ACCPNTLIST
{
    struct ACCPNTLIST  * pNextAccPnt;     /* linked-list to next ACCPNT */
    ACCPNT             * pAccPnt;         /* this access point */
} ACCPNTLIST;

/* Access Points seem excessively ISO specific, and since everyone on
 * the planet seems to be using TCP/IP and DNS, which use a simple
 * string representation of an address rather than an ISO Presentation
 * Address, we are migrating data structures this way.
 */

// moved up to above the IDL line: typedef UNICODE_STRING DSA_ADDRESS;

typedef struct _DSA_ADDRESS_LIST {
    struct _DSA_ADDRESS_LIST * pNextAddress;
    DSA_ADDRESS              Address;
} DSA_ADDRESS_LIST;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

// The CH_REFTYPE_XXXXX were moved up to the CONTREF_DRS_WIRE_V1 area. 

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct CONTREF
{
    PDSNAME     pTarget;        /* target name in continuing operation */
    NAMERESOP   OpState;        /* operation status */
    USHORT      aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT      RDNsInternal;   /* reserved */
    USHORT      refType;        /* reserved */
    USHORT      count;          /* number of access points */
    DSA_ADDRESS_LIST *pDAL;     /* linked list of access points */
    struct CONTREF *pNextContRef; /* linked list of CRs */
    PFILTER     pNewFilter;     /* new filter (optional) */
    BOOL        bNewChoice;     /* is a new choice present? */
    UCHAR       choice;         /* new search choice (optional) */
} CONTREF;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct REFERR
{
    DWORD      dsid;
    DWORD      extendedErr;        /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    CONTREF Refer;                 /* alternate DSAs to contact */
} REFERR;


/*  A SECERR reports a problem in carrying out an operation because of
 *  security reasons.
 *
 *  NOTE: for this release only SE_PROBLEM_INSUFF_ACCESS_RIGHTS will be
 *        returned on a security error
 */

#define SECERR_BASE                         ( securityError * DIR_ERROR_BASE )

#define SE_PROBLEM_INAPPROPRIATE_AUTH       ( SECERR_BASE + 1 )
#define SE_PROBLEM_INVALID_CREDENTS         ( SECERR_BASE + 2 )
#define SE_PROBLEM_INSUFF_ACCESS_RIGHTS     ( SECERR_BASE + 3 )
#define SE_PROBLEM_INVALID_SIGNATURE        ( SECERR_BASE + 4 )
#define SE_PROBLEM_PROTECTION_REQUIRED      ( SECERR_BASE + 5 )
#define SE_PROBLEM_NO_INFORMATION           ( SECERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SECERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR;


/* Service errors */

#define SVCERR_BASE                         ( serviceError * DIR_ERROR_BASE )

#define SV_PROBLEM_BUSY                     ( SVCERR_BASE + 1  )
#define SV_PROBLEM_UNAVAILABLE              ( SVCERR_BASE + 2  )
#define SV_PROBLEM_WILL_NOT_PERFORM         ( SVCERR_BASE + 3  )
#define SV_PROBLEM_CHAINING_REQUIRED        ( SVCERR_BASE + 4  )
#define SV_PROBLEM_UNABLE_TO_PROCEED        ( SVCERR_BASE + 5  )
#define SV_PROBLEM_INVALID_REFERENCE        ( SVCERR_BASE + 6  )
#define SV_PROBLEM_TIME_EXCEEDED            ( SVCERR_BASE + 7  )
#define SV_PROBLEM_ADMIN_LIMIT_EXCEEDED     ( SVCERR_BASE + 8  )
#define SV_PROBLEM_LOOP_DETECTED            ( SVCERR_BASE + 9  )
#define SV_PROBLEM_UNAVAIL_EXTENSION        ( SVCERR_BASE + 10 )
#define SV_PROBLEM_OUT_OF_SCOPE             ( SVCERR_BASE + 11 )
#define SV_PROBLEM_DIR_ERROR                ( SVCERR_BASE + 12 )


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SVCERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR;



/* Update errors */

#define UPDERR_BASE                         ( updError * DIR_ERROR_BASE )

#define UP_PROBLEM_NAME_VIOLATION           ( UPDERR_BASE + 1 )
#define UP_PROBLEM_OBJ_CLASS_VIOLATION      ( UPDERR_BASE + 2 )
#define UP_PROBLEM_CANT_ON_NON_LEAF         ( UPDERR_BASE + 3 )
#define UP_PROBLEM_CANT_ON_RDN              ( UPDERR_BASE + 4 )
#define UP_PROBLEM_ENTRY_EXISTS             ( UPDERR_BASE + 5 )
#define UP_PROBLEM_AFFECTS_MULT_DSAS        ( UPDERR_BASE + 6 )
#define UP_PROBLEM_CANT_MOD_OBJ_CLASS       ( UPDERR_BASE + 7 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct UPDERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR;


/* problem codes are from errno.h */

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct _SYSERR
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef union _DIRERR
{
    ATRERR  AtrErr;             /* attribute error */
    NAMERR  NamErr;             /* name error      */
    REFERR  RefErr;             /* referral error  */
    SECERR  SecErr;             /* security error  */
    SVCERR  SvcErr;             /* service error   */
    UPDERR  UpdErr;             /* update error    */
    SYSERR  SysErr;             /* system error    */
} DIRERR;

#define DBDsReplBackupSnapshotPrepare(expiration)   DBDsReplBackupUpdate(TRUE, TRUE, FALSE, expiration, DSID(FILENO, __LINE__))
#define DBDsReplBackupSnapshotEnd()                 DBDsReplBackupUpdate(FALSE, FALSE, TRUE, 0, DSID(FILENO, __LINE__))
#define DBDsReplBackupLegacyPrepare()               DBDsReplBackupUpdate(TRUE, FALSE, FALSE, 0, DSID(FILENO, __LINE__))

ULONG 
DBDsReplBackupUpdate(
    BOOL        fSetUsnAtBackup,
    BOOL        fUnSetBackupState,
    BOOL        fSetChangeInvocId,
    DSTIME      dstimeBackupExpiration,
    DWORD       dwDSID
    );

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

/* From mdlocal.h */

unsigned AttrTypeToKey(ATTRTYP attrtyp, WCHAR *pOutBuf);
ATTRTYP KeyToAttrTypeLame(WCHAR * pKey, unsigned cc);

unsigned QuoteRDNValue(const WCHAR * pVal,
                       unsigned ccVal,
                       WCHAR * pQuote,
                       unsigned ccQuoteBufMax);

unsigned UnquoteRDNValue(const WCHAR * pQuote,
                         unsigned ccQuote,
                         WCHAR * pVal);

unsigned GetRDN(const WCHAR **ppDN,
                unsigned *pccDN,
                const WCHAR **ppKey,
                unsigned *pccKey,
                const WCHAR **ppVal,
                unsigned *pccVal);

unsigned GetDefaultSecurityDescriptor(
        ATTRTYP classID,
        ULONG   *pLen,
        PSECURITY_DESCRIPTOR *ppSD
        );

DWORD
UserFriendlyNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        );


// This function trims a Dsname by the given number of avas.
DWORD TrimDSNameBy(
        DSNAME *pDNSrc,
        ULONG cava,
        DSNAME *pDNDst);


// returns info about the RDN in a DSNAME. This is the external version
// of GetRDNInfo to be called outside of ntdsa
unsigned GetRDNInfoExternal(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype);

// Tests if the RDN is indeed mangled. This is the external version to be
// called outside of ntdsa
BOOL IsMangledRDNExternal(
                    WCHAR * pszRDN,  // Pointer to the RDN
                    ULONG   cchRDN,  // Length of the RDN
                    PULONG  pcchUnmangled OPTIONAL); // Offset in the RDN
                                                     // where mangling
                                                     // starts



// Append an RDN to an existing DSNAME.  Return value is 0 on success.
// A non-zero return value is the size, in bytes, that would have been
// required to hold the output name.  A return of -1 indicates that one
// of the input values was bad (most likely the Attid)
unsigned AppendRDN(DSNAME *pDNBase, // Base name to append from
                   DSNAME *pDNNew,  // Buffer to hold results
                   ULONG ulBufSize, // Size of pDNNew buffer, in bytes
                   WCHAR *pRDNVal,  // RDN value to append
                   ULONG RDNlen,    // length of RDN val, in characters
                                    // 0 means NULL terminated string
                   ATTRTYP AttId);  // RDN attribute type

// Determines the count of name parts (i.e., the level),
// returns 0 or error code
unsigned CountNameParts(const DSNAME *pName, unsigned *pCount);

// Reasons for mangling an RDN.
typedef enum {
    MANGLE_OBJECT_RDN_FOR_DELETION = 0,
    MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
    MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
    MANGLE_PHANTOM_RDN_FOR_DELETION
} MANGLE_FOR;

// Mangle an RDN to avoid name conflicts.  NOTE: pszRDN must be pre-allocated
// to hold at least MAX_RDN_SIZE WCHARs.
DWORD
MangleRDNWithStatus(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    );

// Detect and decode previously mangled RDN. peMangleFor is optional
BOOL
IsMangledRDN(
    IN           WCHAR      *pszRDN,
    IN           DWORD       cchRDN,
    OUT          GUID       *pGuid,
    OUT OPTIONAL MANGLE_FOR *peMangleFor
    );

BOOL
IsMangledDSNAME(
    DSNAME *pDSName,
    MANGLE_FOR *peMangleFor
    );

/* End: From mdlocal.h */

typedef struct _ServerSitePair {
    WCHAR *         wszDnsServer;
    WCHAR *         wszSite;
} SERVERSITEPAIR;

VOID
DsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    );

NTSTATUS
DsGetServersAndSitesForNetLogon(
    IN   WCHAR *         pNCDNS,
    OUT  SERVERSITEPAIR ** ppaRes
    );

NTSTATUS
CrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       dwFlags,                // DS_NAME_FLAG mask
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr);                 // one of DS_NAME_ERROR in ntdsapi.h

typedef enum
{
    DSCONFIGNAME_DMD = 1,   // Hint: this is the Schema NC.
    DSCONFIGNAME_DSA = 2,
    DSCONFIGNAME_DOMAIN = 3,
    DSCONFIGNAME_CONFIGURATION = 4,
    DSCONFIGNAME_ROOT_DOMAIN = 5,
    DSCONFIGNAME_LDAP_DMD = 6,
    DSCONFIGNAME_PARTITIONS = 7,
    DSCONFIGNAME_DS_SVC_CONFIG = 8,
    DSCONFIGNAMELIST_NCS = 9, // extended command, must use GetConfigurationNamesList().
    DSCONFIGNAME_DOMAIN_CR = 10,
    DSCONFIGNAME_ROOT_DOMAIN_CR = 11
} DSCONFIGNAME;

typedef enum{
    DSCONFIGINFO_FORESTVERSION = 1,
    DSCONFIGINFO_DOMAINVERSION = 2
} DSCONFIGINFO;


// The Following are the flags needed to provide the
// GetConfigurationNamesList() more parameters with which to run by.
// The flags differ for each command differ from command to command.

// DSCNL_NCS_ flags have to do with which NCS to get, you will need
// at least one flag from the type of NCs and one from the locality of
// the NCs.

// Note that _NCS_NDNCS does not include Config or Schema NCs, making
// these first 6 flags mututally exclusive, and a complete set for all
// NCs the AD could be aware of.  This is more convient for getting 
// any list of NCs you want.
#define DSCNL_NCS_DOMAINS         0x00000001
#define DSCNL_NCS_CONFIG          0x00000002
#define DSCNL_NCS_SCHEMA          0x00000004
#define DSCNL_NCS_NDNCS           0x00000008
#define DSCNL_NCS_DISABLED        0x00000010
#define DSCNL_NCS_FOREIGN         0x00000020
// #define DSCNL_NCS_NOT_USED        0x00000040

// This flag is the same kind of flag, but not mututally exclusive of the others
#define DSCNL_NCS_ROOT_DOMAIN     0x00000080

// combos of above flags
// All Active Directory NCs internal to this forest
#define DSCNL_NCS_ALL_AD_NCS      (DSCNL_NCS_DOMAINS | DSCNL_NCS_CONFIG | DSCNL_NCS_SCHEMA | DSCNL_NCS_NDNCS)
// All NCs that aren't native NCs of this forest.
#define DSCNL_NCS_ALL_NON_AD_NCS  (DSCNL_NCS_DISABLED | DSCNL_NCS_FOREIGN)
// All NCs that this DC is aware of.
#define DSCNL_NCS_ALL_NCS         (DSCNL_NCS_ALL_AD_NCS | DSCNL_NCS_ALL_NON_AD_NCS)

// This set of three flags also forms a mututally exclusive set of sets, that
// together form the whole.  These flags can give modify the list of NCs
// for NCs instantiated locally, or NCs that are read only, or NCs in
// the forest.
#define DSCNL_NCS_LOCAL_MASTER    0x00000100
#define DSCNL_NCS_LOCAL_READONLY  0x00000200
#define DSCNL_NCS_REMOTE          0x00000400
// combo of above flags
#define DSCNL_NCS_ALL_LOCALITIES  (DSCNL_NCS_LOCAL_MASTER | DSCNL_NCS_LOCAL_READONLY | DSCNL_NCS_REMOTE)

// This flag is useable in the DSCONFIGNAMELIST_NCS command, and tells
// the API to return pairs of DNs with the NC name DN in the first DN of
// the pair, and the CR DN of that NC in the 2nd DN of the pair.  With
// this flag specified, the API will always return an even number of
// DNs, and the array will still be NULL terminated like before.
#define DSCNL_NCS_CROSS_REFS_TOO  0x00000800

NTSTATUS
GetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    DWORD *     pcbNames,
    DSNAME **   padsNames);

NTSTATUS
GetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias);

NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName);

NTSTATUS
GetConfigurationInfo(
    DWORD       which,
    DWORD       *pcbSize,
    VOID        *pBuff);


/* From dsatools.h */

void * THAlloc(DWORD size);

void * THReAlloc(void *, DWORD size);

void THFree(void *buff);

// returns TRUE if the two names match (refer to the same object)
extern int
NameMatched(const DSNAME *pDN1, const DSNAME *pDN2);
extern int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2);

// helper function which takes a DSNAME and returns its hashkey
extern DWORD DSNAMEToHashKeyExternal(const DSNAME *pDN);

// helper function which takes a DSNAME and returns its LCMapped version
// this can be used in string comparisons using strcmp
extern CHAR* DSNAMEToMappedStrExternal(const DSNAME *pDN);

// helper function which takes a WCHAR and returns its hashkey
extern DWORD DSStrToHashKeyExternal(const WCHAR *pStr, int cchLen);

// helper function that takes a WCHAR string and returns the LCMapped version
// cchMaxStr is the maximum expected size of the passed in string
extern CHAR * DSStrToMappedStrExternal(const WCHAR *pStr, int cchMaxStr);


/* End: From dsatools.h */

/* New */

// Any change to this enum must be reflected both in the array DsCallerType
// in src\dstrace.c and in the Dump_THSTATE routine in dsexts\md.c
typedef enum _CALLERTYPE {
    CALLERTYPE_NONE = 0,
    CALLERTYPE_SAM,
    CALLERTYPE_DRA,
    CALLERTYPE_LDAP,
    CALLERTYPE_LSA,
    CALLERTYPE_KCC,
    CALLERTYPE_NSPI,
    CALLERTYPE_INTERNAL,
    CALLERTYPE_NTDSAPI
} CALLERTYPE;

#define IsCallerTypeValid( x )  ( ( ( x ) >= CALLERTYPE_SAM ) && ( ( x ) <= CALLERTYPE_NTDSAPI ) )

ULONG THCreate(DWORD);     /* returns 0 on success */
ULONG THDestroy(void);          /* returns 0 on success */
BOOL  THQuery(void);            /* returns 1 if THSTATE exists, 0 if not */
PVOID THSave();
VOID THRestore(PVOID);
VOID THClearErrors();
VOID THRefresh();

// Returns error string associated with THSTATE error; free with THFree().
LPSTR THGetErrorString();

BOOL THVerifyCount(unsigned count);  /* Returns TRUE if thread has exactly   */
                                     /* count thread states, FALSE if not.   */
                                     /* Only works if thread state mapping   */
                                     /* is enabled (chk or under debug),     */
                                     /* returns TRUE if disabled.            */

// obsolete; use THClearErrors() instead
#define SampClearErrors THClearErrors

VOID
SampSetDsa(
   BOOLEAN DsaFlag);

VOID
SampSetLsa(
   BOOLEAN DsaFlag);

/*++

    This routine gets the requested property of the class schema object, for the
    Class specified in ClassId.
Parameters:
    ClassId  The ClassId of the class that we are interseted in
    AttributeId The attribute of the class schema object that we want
    attLen    The length of the attribute value is present in here .
              Caller allocates the buffer in pAttVal and passes its length
              in attLen. If the buffer required is less than the buffer supplied
              then the data is returned in pattVal. Else  the required size is
              returned in attLen.
    pattVal      The value of the attribute is returned in here.

    Security Descriptors returned by this routine are always in a format that
    can be used by the RTL routines.
Return Values:
    STATUS_SUCCESS
    STATUS_NOT_FOUND
    STATUS_BUFFER_TOO_SMALL
--*/
extern
NTSTATUS
SampGetClassAttribute(
     IN     ULONG    ClassId,
     IN     ULONG    Attribute,
     OUT    PULONG   attLen,
     OUT    PVOID    pattVal
     );


/* End: New */

/*************************************************************************
    MINI-DIRECTORY API - MINI-DIRECTORY API - MINI-DIRECTORY API
*************************************************************************/


// All the Dir APIs requires a valid thread state and are atomic.
// I.e. They implicitly begin/end a transaction.  Some in-process
// clients like the LSA wish to perform multi-object transactions,
// AND PLEDGE TO KEEP TRANSACTIONS SHORT!!!  The following defines
// and routines can be used to perform multi-object transactions.
// DirTransactControl() must be called with a valid thread state.
// By default, a thread's transaction control is TRANSACT_BEGIN_END.
// A transaction is ended on error.  It must explicitly be ended via a
// TRANSACT_BEGIN_END or TRANSACT_DONT_BEGIN_END transaction state

typedef enum DirTransactionOption
{
    TRANSACT_BEGIN_END              = 0,
    TRANSACT_DONT_BEGIN_END         = 1,
    TRANSACT_BEGIN_DONT_END         = 2,
    TRANSACT_DONT_BEGIN_DONT_END    = 3
} DirTransactionOption;

VOID
DirTransactControl(
    DirTransactionOption    option);

/*
 * There are some controls that we need to send directly to a DSA that
 * have no correlation to any directory object.  For example, we might
 * need to tell a DSA to recals its hierarchy table, or force it to run
 * garbage collection now, or initiate some FSMO request.  These operation
 * controls are bundled together in this API.  Some operation controls take
 * values as arguments, those are passed through the sized buffer.
 */
typedef enum _OpType {
    OP_CTRL_INVALID = 0,
    OP_CTRL_RID_ALLOC = 1,
    OP_CTRL_BECOME_RID_MASTER = 2,
    OP_CTRL_BECOME_SCHEMA_MASTER = 3,
    OP_CTRL_GARB_COLLECT = 4,
    OP_CTRL_RECALC_HIER = 5,
    OP_CTRL_REPL_TEST_HOOK = 6,
    OP_CTRL_BECOME_DOM_MASTER = 7,
//    OP_CTRL_DECLARE_QUIESCENCE = 8,
    OP_CTRL_SCHEMA_UPDATE_NOW = 9,
    OP_CTRL_BECOME_PDC = 10,
    OP_CTRL_FIXUP_INHERITANCE = 11,
    OP_CTRL_FSMO_GIVEAWAY = 12,
    OP_CTRL_INVALIDATE_RID_POOL = 13,
    OP_CTRL_DUMP_DATABASE = 14,
    OP_CTRL_CHECK_PHANTOMS = 15,
    OP_CTRL_BECOME_INFRASTRUCTURE_MASTER = 16,
    OP_CTRL_BECOME_PDC_WITH_CHECKPOINT = 17,
    OP_CTRL_UPDATE_CACHED_MEMBERSHIPS = 18,
    OP_CTRL_ENABLE_LVR = 19,
    OP_CTRL_LINK_CLEANUP = 20,
    OP_CTRL_SCHEMA_UPGRADE_IN_PROGRESS = 21,
    OP_CTRL_DYNAMIC_OBJECT_CONTROL = 22,
    OP_CTRL_REPLICATE_OBJECT = 23,
    OP_CTRL_REMOVE_LINGERING_OBJECT = 24,
    OP_CTRL_ONLINE_DEFRAG = 25,
    // Following for test purposes in debug builds only.

#ifdef INCLUDE_UNIT_TESTS
    OP_CTRL_REFCOUNT_TEST = 10000,
    OP_CTRL_TAKE_CHECKPOINT=10001,
    OP_CTRL_ROLE_TRANSFER_STRESS=10002,
    OP_CTRL_ANCESTORS_TEST=10003,
    OP_CTRL_BHCACHE_TEST=10004,
    OP_SC_CACHE_CONSISTENCY_TEST=10005,
    OP_CTRL_PHANTOMIZE=10006,
    OP_CTRL_REMOVE_OBJECT = 10007,
    OP_CTRL_GENERIC_CONTROL = 10008,
    OP_CTRL_PROTECT_OBJECT = 10009,
#endif
#ifdef DBG
    OP_CTRL_EXECUTE_SCRIPT = 10010,
#endif
} OpType;

typedef struct _OPARG {
    OpType     eOp;
    char      *pBuf;            /* optional value */
    ULONG      cbBuf;           /* size of value buffer */
} OPARG;

typedef struct _OPRES {
    COMMRES    CommRes;
    ULONG      ulExtendedRet;
} OPRES;

typedef struct _FSMO_GIVEAWAY_DATA_V1 {

    ULONG Flags;

    ULONG NameLen;
    WCHAR StringName[1];  // variable sized array

} FSMO_GIVEAWAY_DATA_V1, *PFSMO_GIVEAWAY_DATA_V1;

typedef struct _FSMO_GIVEAWAY_DATA_V2 {

    ULONG Flags;

    ULONG NameLen;          // length of DSA DN, excluding null terminator
                            //   (which is required); may be 0

    ULONG NCLen;            // length of NC DN, excluding null terminator
                            //   (which is required); may be 0

    WCHAR Strings[1];       // variable sized array; DSA DN (or '\0' if none)
                            // followed by NC DN (or '\0' if none)

} FSMO_GIVEAWAY_DATA_V2, *PFSMO_GIVEAWAY_DATA_V2;

typedef struct _FSMO_GIVEAWAY_DATA {

    DWORD Version;
    union {
        FSMO_GIVEAWAY_DATA_V1 V1;
        FSMO_GIVEAWAY_DATA_V2 V2;
    };

} FSMO_GIVEAWAY_DATA, *PFSMO_GIVEAWAY_DATA;


//
// Flags for FSMO_GIVEAWAY_DATA_V1
//
#define FSMO_GIVEAWAY_DOMAIN       0x01
#define FSMO_GIVEAWAY_ENTERPRISE   0x02
#define FSMO_GIVEAWAY_NONDOMAIN    0x04


ULONG
DirOperationControl(
                    OPARG   * pOpArg,
                    OPRES  ** ppOpRes
);

/*++
  DirBind
--*/

typedef struct _BINDARG {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The user name
                             */
} BINDARG;


/* The output data structs carries a little more info */

typedef struct _BINDRES {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The DSA name.
                             */
    COMMRES     CommRes;
} BINDRES;

ULONG
DirBind (
    BINDARG               * pBindArg,    /* binding credentials            */
    BINDRES              ** ppBindRes    /* binding results                */
);

/*++
  DirUnBind - currently a placeholder
--*/
ULONG DirUnBind
(
    void
);


/*++
  DirRead
--*/
// These structures holds information about range limits for values on
// attributes in a search.
typedef struct _RANGEINFOITEM {
    ATTRTYP   AttId;
    DWORD     lower;
    DWORD     upper;
} RANGEINFOITEM;

typedef struct _RANGESEL {
    DWORD valueLimit;
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINFSEL;

typedef struct _RANGEINF {
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINF;

typedef struct _RANGEINFLIST {
    struct _RANGEINFLIST *pNext;
    RANGEINF              RangeInf;
} RANGEINFLIST;

typedef struct _READARG
{
    DSNAME        * pObject;    /* object name                           */
    ENTINFSEL FAR * pSel;       /* entry information selection           */
                                /* (null means read all atts and values) */
    RANGEINFSEL   * pSelRange;  /* range information (i.e. max number of */
                                /* values or subrange of values to read  */
                                /* for a given attribute) null = all     */

    COMMARG         CommArg;    /* common arguments                      */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} READARG;

typedef struct _READRES
{
    ENTINF  entry;               /* entry information                    */
    RANGEINF range;
    COMMRES     CommRes;
} READRES;


ULONG
DirRead (
    READARG FAR   * pReadArg,       /* Read argument                        */
    READRES      ** ppReadRes
);


/*++
  DirCompare
--*/

typedef struct _COMPAREARG
{
    PDSNAME     pObject;        /* object name                             */
    AVA         Assertion;      /*  The specified attribute to match       */
    COMMARG     CommArg;        /*  common arguments                       */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} COMPAREARG;

typedef struct _COMPARERES
{
    PDSNAME     pObject;        /* Name provided if an alias was
                                 *  dereferrenced.
                                 */
    BOOL        fromMaster;     /* TRUE if the object is from the master   */
    BOOL        matched;        /* True if the match was successful        */
    COMMRES     CommRes;
} COMPARERES;

ULONG
DirCompare(
    COMPAREARG        * pCompareArg, /* Compare argument                   */
    COMPARERES       ** ppCompareRes
);



/*++
  DirList

    This API is used to list the object names of objects that are directly
    subordinate to the given object.

    If the list is incomplete, the PARTIALOUTCOME structure is returned.
    This structure indicates the reason for the failure and a set of DSA's
    to contact to complete the operation.  For this release, this will
    only occur when more selected data exists in this DSA than can be
    returned.  In this case the CONTREF will point back into the same
    DSA.  PARTIALOUTCOME is used as follows:

    If the pPartialOutcomeQualifier is NULL the query is complete.
    If the pointer is not NULL there is more data available.  More data
    can be retrieved by repeating the operation with the same input
    arguments except that the nameRes field of the CommArg structure is
    set to OP_NAMERES_COMPLETE.  Setting this field indicates to the DSA
    that the operation is continuing.  This continued call must use the
    same handle as the original call and must be the next operation
    made with this handle.  Subsequent continuing calls may be applied
    until all data are returned.
--*/

typedef struct _LISTARG
{
    PDSNAME     pObject;            /* object name (base of search)        */
    COMMARG     CommArg;            /* common arguments                    */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */
} LISTARG;


typedef struct _CHILDLIST
{
    struct _CHILDLIST    * pNextChild;  /* linked-list to next info entry  */
    RDN FAR              * pChildName;  /* information about this entry    */
    BOOL                   aliasEntry;  /* If true the child is an alias   */
    BOOL                   fromMaster;  /* True if master object           */
} CHILDLIST;

#define PA_PROBLEM_TIME_LIMIT       'T'
#define PA_PROBLEM_SIZE_LIMIT       'S'
#define PA_PROBLEM_ADMIN_LIMIT      'A'

typedef struct _PARTIALOUTCOME
{
    UCHAR   problem;        /*  the reason for incomplete output
                             *   Valid values:
                             *     - PA_PROBLEM_TIME_LIMIT
                             *     - PA_PROBLEM_SIZE_LIMIT
                             *     - PA_PROBLEM_ADMIN_LIMIT
                             */
    UCHAR   unusedPad;
    USHORT  count;            /* count of unexplored DSAs */
    CONTREF *pUnexploredDSAs; /* Other DSA's to visit     */
} PARTIALOUTCOME;


typedef struct _LISTRES
{
    PDSNAME              pBase;          /* Name provided if an alias was
                                          *  dereferrenced.
                                          */
    ULONG                count;          /* number of output entries       */
    CHILDLIST            Firstchild;     /* linked-list of output entries  */

    PARTIALOUTCOME     * pPartialOutcomeQualifier;  /* incomplete operation*/

    PAGED_RESULT    PagedResult;         /* Paged Results local extension  */
    COMMRES              CommRes;
} LISTRES;


ULONG
DirList(
    LISTARG FAR   * pListArg,
    LISTRES      ** ppListRes

);



/*++
  DirSearch
--*/

#define SE_CHOICE_BASE_ONLY                 0
#define SE_CHOICE_IMMED_CHLDRN              1
#define SE_CHOICE_WHOLE_SUBTREE             2


typedef struct _SEARCHARG
{
    PDSNAME     pObject;        /* object name (base of search)              */
    UCHAR       choice;         /* depth of search:
                                 *  Valid values:
                                 *    - SE_CHOICE_BASE_ONLY
                                 *    - SE_CHOICE_IMMED_CHLDRN
                                 *    - SE_CHOICE_BASE_AND_SUBTREE
                                 */
    BOOL        bOneNC;         /* Are results constrained to same NC
                                 * as pObject
                                 */
    PFILTER     pFilter;        /* filter information
                                 *  (NULL if all objects selected)
                                 */
    BOOL        searchAliases;  /* If true, aliases are dereferenced for
                                 *  subtree elements.
                                 *  NOTE: ALWAYS Set to FALSE for this release.
                                 */
    ENTINFSEL * pSelection;     /* entry information selection
                                 *  (null means read all atts and values)
                                 */
    RANGEINFSEL *pSelectionRange;/* range information (i.e. max number of values
                                 * or subrange of values to read for a given
                                 * attribute
                                 */

    BOOL        fPutResultsInSortedTable:1;
                                 /* If set, leave the results in a
                                    temporary sorted Table and don't
                                    return a ENTINFLIST.
                                    The attribute to sort on is specified
                                    in CommArg.SortAttr
                                 */

    COMMARG     CommArg;        /* common arguments                          */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */

} SEARCHARG;

typedef struct _SEARCHRES
{
    BOOL        baseProvided;       /* indicates if the base object name
                                     * is provided.  (Only provided when
                                     * an alias has been dereferenced
                                     */
    BOOL        bSorted;            /* indicates that these results have
                                     * been sorted based on the sort
                                     * attribute specified in the commarg
                                     * in the SEARCHARG
                                     */
    PDSNAME     pBase;              /* base object of subtree                */
    ULONG       count;              /* number of output entries              */
    ENTINFLIST  FirstEntInf;        /* linked-list of output entries         */
    RANGEINFLIST FirstRangeInf;     /* linked-list of output range info      */

    PARTIALOUTCOME *pPartialOutcomeQualifier;  /* Defined in DirList     */
                                    /* Indicates incomplete operation        */

    COMMRES       CommRes;          /* Common Results                        */
    PAGED_RESULT  PagedResult;      /* Paged Results extension related       */
    VLV_REQUEST   VLVRequest;       /* VLV Request extension related         */
    ASQ_REQUEST   ASQRequest;       /* ASQ Request extension related         */

    DWORD         SortResultCode;   /* Result code for sorting               */

} SEARCHRES;


ULONG
DirSearch (
    SEARCHARG     * pSearchArg,
    SEARCHRES    ** ppSearchRes
);

typedef BOOL (*PF_PFI)(DWORD hClient, DWORD hServer, void ** ppImpersonateData);
typedef void (*PF_TD)(DWORD hClient, DWORD hServer, ENTINF *pEntInf);
typedef void (*PF_SI)(DWORD hClient, DWORD hServer, void * pImpersonateData);

typedef struct _NOTIFYARG {
    PF_PFI pfPrepareForImpersonate;
    PF_TD  pfTransmitData;
    PF_SI  pfStopImpersonating;
    DWORD  hClient;
} NOTIFYARG;

typedef struct _NOTIFYRES {
    COMMRES     CommRes;
    DWORD       hServer;
} NOTIFYRES;


ULONG
DirNotifyRegister(
                  SEARCHARG *pSearchArg,
                  NOTIFYARG *pNotifyArg,
                  NOTIFYRES **ppNotifyRes
);

ULONG
DirNotifyUnRegister(
                    DWORD hServer,
                    NOTIFYRES **pNotifyRes
);

BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        );

VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        );


/*++
  DirAddEntry
--*/



typedef struct _ADDARG
{
    PDSNAME     pObject;                /* target object name                */
    ATTRBLOCK   AttrBlock;              /* The block of attributes to add    */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge  */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)       */
    COMMARG     CommArg;                /* common input arguments            */
    struct _RESOBJ * pResParent;        /* for internal caching use, leave null */
    struct _CREATENCINFO * pCreateNC;   /* for internal caching use, leave null */
    struct _ADDCROSSREFINFO * pCRInfo;  /* for internal caching use. leave null */

} ADDARG;


/* No result is returned on successful completion of the operation.          */
typedef struct _ADDRES
{
    COMMRES     CommRes;
} ADDRES;

ULONG DirAddEntry
(
    ADDARG        * pAddArg,        /* add argument                          */
    ADDRES       ** ppAddRes
);



/*++
  DirRemoveEntry

    This API is used to delete a directory leaf object.  Non-leaves
    cannot be removed (unless one first removes all of the object's
    children, which, in effect, makes the object itself a leaf).

--*/

typedef struct _REMOVEARG
{
    PDSNAME     pObject;              /* target object name                 */
    BOOL        fPreserveRDN;         /* don't mangle the tombstone RDN     */
    BOOL        fGarbCollectASAP;     /* set deletion time such that the    */
                                      /*   object will be picked up by the  */
                                      /*   next garbage collection and      */
                                      /*   physically deleted               */
    BOOL        fTreeDelete;          /* Try to delete the object and all   */
                                      /* children.  USE SPARINGLY!!!!       */
    BOOL        fDontDelCriticalObj;  /* If set, objects mark critical will */
                                      /* cause the delete to fail.  Used    */
                                      /* with tree delete to avoid disaster */
    PROPERTY_META_DATA_VECTOR *       /* Remote meta data vector to merge   */
                pMetaDataVecRemote;   /*   (should be NULL if !fDRA)        */
    COMMARG     CommArg;              /* common input arguments             */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} REMOVEARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _REMOVERES
{
    COMMRES     CommRes;
} REMOVERES;

ULONG DirRemoveEntry
(
    REMOVEARG  * pRemoveArg,
    REMOVERES ** ppRemoveRes
);



/*++
  DirModifyEntry
--*/

#define AT_CHOICE_ADD_ATT           'A'
#define AT_CHOICE_REMOVE_ATT        'R'
#define AT_CHOICE_ADD_VALUES        'a'
#define AT_CHOICE_REMOVE_VALUES     'r'
#define AT_CHOICE_REPLACE_ATT       'C'

typedef struct _ATTRMODLIST
{
    struct _ATTRMODLIST * pNextMod;     /* linked-list to next att mod      */

    USHORT      choice;                 /* modification type:
                                         *  Valid values:
                                         *    - AT_CHOICE_ADD_ATT
                                         *    - AT_CHOICE_REMOVE_ATT
                                         *    - AT_CHOICE_ADD_VALUES
                                         *    - AT_CHOICE_REMOVE_VALUES
                                         *    - AT_CHOICE_REPLACE_ATT
                                         */
    ATTR AttrInf;                       /* information about the attribute  */
} ATTRMODLIST;


typedef struct _MODIFYARG
{
    PDSNAME     pObject;                /* target object name               */
    USHORT      count;                  /* num of link modifications        */
    ATTRMODLIST FirstMod;               /* linked-list of attr mods         */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)      */
    COMMARG     CommArg;                /* common input arguments           */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} MODIFYARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYRES
{
    COMMRES     CommRes;
} MODIFYRES;

ULONG DirModifyEntry
(
    MODIFYARG  * pModifyArg,
    MODIFYRES ** ppModifyRes
);



/*++
  DirModifyDN

  Rename and object and/or change it's parent.

--*/

typedef struct _MODIFYDNARG
{
    PDSNAME     pObject;                 /* target object name              */
    PDSNAME     pNewParent;              /* name of new parent              */
    ATTR        *pNewRDN;                /* new rdn                         */
    PROPERTY_META_DATA_VECTOR *          /* Remote meta data vector to merge*/
                pMetaDataVecRemote;      /*   (should be NULL if !fDRA)     */
    COMMARG     CommArg;                 /* common input arguments          */
    PWCHAR      pDSAName;                /* destination DSA, cross DSA move */
    DWORD       fAllowPhantomParent;     // whether we allow the parent to be a phantom
                                         // useful if moving object under phantoms
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
    struct _RESOBJ * pResParent;    /* for internal caching use, leave null */
} MODIFYDNARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYDNRES
{
    COMMRES     CommRes;
} MODIFYDNRES;

ULONG DirModifyDN
(
    MODIFYDNARG    * pModifyDNArg,
    MODIFYDNRES   ** ppModifyDNRes
);


/*++

  DirFind

  A light weight Search, that searches on a unique indexed attribute

--*/
typedef struct _FINDARG {
    ULONG       hDomain;
    ATTRTYP     AttId;
    ATTRVAL     AttrVal;
    COMMARG     CommArg;
    BOOL        fShortNames;
} FINDARG;

typedef struct _FINDRES {
    DSNAME     *pObject;
    COMMRES     CommRes;
} FINDRES;


DWORD DirGetDomainHandle(DSNAME *pDomainDN);

ULONG DirFindEntry
(
    FINDARG    *pFindArg,
    FINDRES    ** ppFindRes
);


/*++
  UpdateDSPerfStats

  Update performance counters held by NTDSA.DLL

  Note that the DSSTAT_ constants map directly to perf block offsets defined
  in the NTDSCTR.H file.  This is done so that UpdateDSPerfStats() can
  operate more efficiently (avoiding a large switch{} statement).

--*/

#define FLAG_COUNTER_INCREMENT  0x00000001
#define FLAG_COUNTER_DECREMENT  0x00000002
#define FLAG_COUNTER_SET        0x00000003

enum DSSTAT_TYPE
{
    DSSTAT_CREATEMACHINETRIES = 0,
    DSSTAT_CREATEMACHINESUCCESSFUL,
    DSSTAT_CREATEUSERTRIES,
    DSSTAT_CREATEUSERSUCCESSFUL,
    DSSTAT_PASSWORDCHANGES,
    DSSTAT_MEMBERSHIPCHANGES,
    DSSTAT_QUERYDISPLAYS,
    DSSTAT_ENUMERATIONS,
    DSSTAT_ASREQUESTS,
    DSSTAT_TGSREQUESTS,
    DSSTAT_KERBEROSLOGONS,
    DSSTAT_MSVLOGONS,
    DSSTAT_ATQTHREADSTOTAL,
    DSSTAT_ATQTHREADSLDAP,
    DSSTAT_ATQTHREADSOTHER,
    DSSTAT_ACCTGROUPLATENCY,
    DSSTAT_RESGROUPLATENCY,
    DSSTAT_UNKNOWN,             // always last item
};

// Count of exposed counters with UpdateDSPerfStats()

#define DSSTAT_COUNT            DSSTAT_UNKNOWN

VOID
UpdateDSPerfStats(
    IN DWORD        dwStat,
    IN DWORD        dwOperation,
    IN DWORD        dwChange
);

#define DSINIT_SAMLOOP_BACK      ((ULONG)(1<<0))
#define DSINIT_FIRSTTIME         ((ULONG)(1<<1))

typedef struct _DS_INSTALL_PARAM 
{
    PVOID BootKey;
    DWORD cbBootKey;
    BOOL  fPreferGcInstall;
    DWORD ReplicationEpoch;

    // The sam account name of the local computer
    LPWSTR AccountName;

    // The token of the caller requesting the install
    HANDLE ClientToken;

    // If we were restored, this is our old identify
    // These new fields are for internal use and should be set by the caller of DsInitialize.  
    UUID InvocationIdOld;
    USN UsnAtBackup;

    PVOID pIfmSystemInfo;

} DS_INSTALL_PARAM,*PDS_INSTALL_PARAM;

#define DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED  ((ULONG)(1<<0))

typedef struct _DS_INSTALL_RESULT
{
    DWORD ResultFlags;

    // Flags from the NTDS_INSTALL_* space to indicate
    // what operations have been completed and not undo
    // during initialization.
    ULONG InstallOperationsDone;

} DS_INSTALL_RESULT,*PDS_INSTALL_RESULT;

NTSTATUS
DsInitialize(
    ULONG Flags,
    IN  PDS_INSTALL_PARAM   InParams  OPTIONAL,
    OUT PDS_INSTALL_RESULT  OutParams OPTIONAL
    );

NTSTATUS
DsPrepareUninitialize(
    VOID
    );

NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    );

VOID
DsaDisableUpdates(
    VOID
    );

VOID
DsaEnableUpdates(
    VOID
    );


#define NTDS_INSTALL_SERVER_CREATED 0x00000001
#define NTDS_INSTALL_DOMAIN_CREATED 0x00000002
#define NTDS_INSTALL_SERVER_MORPHED 0x00000004

typedef DWORD (*DSA_CALLBACK_STATUS_TYPE)( IN LPWSTR wczStatus );
typedef DWORD (*DSA_CALLBACK_ERROR_TYPE)(  IN PWSTR  Status,
                                           IN DWORD  WinError );
typedef DWORD (*DSA_CALLBACK_CANCEL_TYPE) ( BOOLEAN fCancelOk );
  
VOID
DsaSetInstallCallback(
    IN DSA_CALLBACK_STATUS_TYPE        pfnUpdateStatus,
    IN DSA_CALLBACK_ERROR_TYPE         pfnErrorStatus,
    IN DSA_CALLBACK_CANCEL_TYPE        pfnCancelOperation,
    IN HANDLE                          ClientToken
    );

NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

ULONG
DirProtectEntry(IN DSNAME *pObj);

LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    );

MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    );

LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    );

extern
LPCWSTR
MapSpnServiceClass(WCHAR *);

extern
NTSTATUS
MatchCrossRefBySid(
   IN PSID           SidToMatch,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchCrossRefByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchDomainDnByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

extern
NTSTATUS
FindNetbiosDomainName(
   IN DSNAME*        DomainDsName,
   OUT LPWSTR        NetbiosName OPTIONAL,
   IN OUT PULONG     NetbiosNameLen
   );

DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    );


BOOL
DsCheckConstraint(
        IN ATTRTYP  attID,
        IN ATTRVAL *pAttVal,
        IN BOOL     fVerifyAsRDN
        );

BOOL
IsStringGuid(
    WCHAR       *pwszGuid,
    GUID        *pGuid
    );

DWORD DsUpdateOnPDC(BOOL fRootDomain);

#endif // MIDL_PASS not defined

#undef SIZE_IS
#undef SWITCH_IS
#undef CASE

#endif // _ntdsa_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\msrpc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       msrpc.h
//
//--------------------------------------------------------------------------


/*

Description:
    Contains declarations of data types and routines used to interface
    with the MS RPC runtime.

*/


#ifndef _msrpc_h_
#define _msrpc_h_

/*
 * maximum number of interfaces exported to RPC's name service
 */

#define MAX_RPC_NS_EXPORTED_INTERFACES	3   // xds, nspi, drs
#define NS_ENTRY_NAME_PREFIX "/.:/Directory/"
#define SERVER_PRINCIPAL_NAME "NTDS"
#define SERVER_PRINCIPAL_NAMEW L"NTDS"
#define MAX_NS_ENTRY_NAME_LEN (sizeof(NS_ENTRY_NAME_PREFIX) + MAX_COMPUTERNAME_LENGTH + 1)

#define RPC_TRANSPORT_ANY	0
#define RPC_TRANSPORT_NAMEPIPE	1
#define RPC_TRANSPORT_LPC	2
#define RPC_TRANSPORT_TCP	3
#define RPC_TRANSPORT_NB_NB	4
#define RPC_TRANSPORT_NB_TCP	5
#define RPC_TRANSPORT_SPX	6

//$MAC
#ifdef MAC
#define RPC_TRANSPORT_AT	7
#endif //MAC

/*
 * constants that should really come from Win32
 */
#define NB_NB_PROTSEQ       (unsigned char *)"ncacn_nb_nb"
#define NB_NB_PROTSEQW      (WCHAR *)L"ncacn_nb_nb"
#define NB_TCP_PROTSEQ      (unsigned char *)"ncacn_nb_tcp"
#define NB_TCP_PROTSEQW     (WCHAR *)L"ncacn_nb_tcp"
#define NP_PROTSEQ          (unsigned char *)"ncacn_np"
#define NP_PROTSEQW         (WCHAR *)L"ncacn_np"
#define LPC_PROTSEQ         (unsigned char *)"ncalrpc"
#define LPC_PROTSEQW        (WCHAR *)L"ncalrpc"
#define TCP_PROTSEQ         (unsigned char *)"ncacn_ip_tcp"
#define TCP_PROTSEQW        (WCHAR *)L"ncacn_ip_tcp"
#define DNET_PROTSEQ        (unsigned char *)"ncacn_dnet_nsp"
#define DNET_PROTSEQW       (WCHAR *)L"ncacn_dnet_nsp"
#define SPX_PROTSEQ         (unsigned char *)"ncacn_spx"
#define SPX_PROTSEQW        (WCHAR *)L"ncacn_spx"
#define AT_PROTSEQ          (unsigned char *)"ncacn_at_dsp"
#define AT_PROTSEQW         (WCHAR *)L"ncacn_at_dsp"
#define UDP_PROTSEQ         (unsigned char *)"ncadg_ip_udp"
#define UDP_PROTSEQW        (WCHAR *)L"ncadg_ip_udp"
#define HTTP_PROTSEQ        (unsigned char *)"ncacn_http"
#define HTTP_PROTSEQW       (WCHAR *)L"ncacn_http"

#define DS_LPC_ENDPOINT     "NTDS_LPC"
#define DS_LPC_ENDPOINTW    L"NTDS_LPC"

extern void StartDraRpc(void);
extern void StartNspiRpc(void);
extern void StartOrStopDsaOpRPC(BOOL fStart);
extern void MSRPC_Uninstall(BOOL fRunningInsideLsa);
extern void MSRPC_Install(BOOL fRunningInsideLsa);
extern void MSRPC_WaitForCompletion(void);
extern void MSRPC_RegisterEndpoints(RPC_IF_HANDLE hServerIf);
extern void MSRPC_UnregisterEndpoints(RPC_IF_HANDLE hServerIf);
extern void MSRPC_Init(void);

/* Max RPC calls */
extern ULONG ulMaxCalls;

extern int gRpcListening;        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdsbsrv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdsbsrv.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module proto-types the interface for the NT Directory Service
    Backup Server APIs. The proto-types would be called by the process
    that hosts the backup/restore server interface.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:
    
    Created		03/19/97    rsraghav

--*/

#ifndef _NTDSBSRV_H_
#define _NTDSBSRV_H_

typedef	DWORD ERR;

#ifndef	NTDSBSRV_BUILD
#define	NTDSBSRV_API	__declspec(dllimport) _stdcall
#else
#define	NTDSBSRV_API
#endif

#ifdef __cplusplus
extern "C" {
#endif 

#define	BACKUP_WITH_UUID

// HRESULT should be defined if the user included ntdef.h or winnt.h or wtypes.h
// Define it anyways just in case it is not defined yet
#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
    typedef LONG HRESULT;
#endif // _HRESULT_DEFINED

typedef DWORD ERR;

/*************************************************************************************
Proto-Types: 
    
      Server side DLL is loaded dynamically. The functions exported by the DLL are
      typedef'ed below to aid dynamic loading of the server DLL.

**************************************************************************************/

HRESULT
NTDSBSRV_API
HrBackupRegister(
    );

HRESULT
NTDSBSRV_API
HrBackupUnregister(
    );

ERR
NTDSBSRV_API
ErrRestoreRegister(
	);

ERR
NTDSBSRV_API
ErrRestoreUnregister(
	);

ERR
NTDSBSRV_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation,
        BOOL fInSafeMode
	);
typedef ERR (*ERR_RECOVER_AFTER_RESTORE_W)(WCHAR *, WCHAR *, BOOL);

ERR
NTDSBSRV_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation,
        BOOL fInSafeMode
	);
typedef ERR (*ERR_RECOVER_AFTER_RESTORE_A)(CHAR *, CHAR *, BOOL);

#define NEW_INVOCID_CREATE_IF_NONE  (0x1)
#define NEW_INVOCID_DELETE          (0x2)
#define NEW_INVOCID_SAVE            (0x4)
ERR
NTDSBSRV_API
ErrGetNewInvocationId(
    IN      DWORD   dwFlags,
    OUT     GUID *  NewId
    );
typedef ERR (*ERR_GET_NEW_INVOCATION_ID)(DWORD, GUID*);

DWORD
ErrGetBackupUsnFromDatabase(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_SESID     datasesid,
    IN  JET_TABLEID   datatblid_arg,
    IN  JET_COLUMNID  usncolid,
    IN  JET_TABLEID   linktblid_arg,
    IN  JET_COLUMNID  linkusncolid,
    IN  BOOL          fDelete,
    OUT USN *         pusnAtBackup
    );
typedef ERR (*ERR_GET_BACKUP_USN_FROM_DATABASE)(
    JET_DBID, JET_SESID, JET_TABLEID, JET_SESID, JET_TABLEID, JET_COLUMNID,
    JET_TABLEID, JET_COLUMNID, BOOL, USN *);

DWORD
ErrGetBackupUsn(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    OUT USN *         pusnAtBackup,
    OUT DSTIME *      pllExpiration
    );
typedef ERR (*ERR_GET_BACKUP_USN)(
    JET_DBID, JET_SESID, JET_TABLEID, USN *, DSTIME *);

typedef HRESULT FN_HrBackupRegister();
typedef HRESULT FN_HrBackupUnregister();

typedef ERR     FN_ErrRestoreRegister();
typedef ERR     FN_ErrRestoreUnregister();

typedef void    FN_SetNTDSOnlineStatus(BOOL fBootedOffNTDS);


#define BACKUP_REGISTER_FN              "HrBackupRegister"
#define BACKUP_UNREGISTER_FN            "HrBackupUnregister"
#define RESTORE_REGISTER_FN             "ErrRestoreRegister"
#define RESTORE_UNREGISTER_FN           "ErrRestoreUnregister"
#define SET_NTDS_ONLINE_STATUS_FN       "SetNTDSOnlineStatus"
#define GET_NEW_INVOCATION_ID_FN        "ErrGetNewInvocationId"
#define GET_BACKUP_USN_FROM_DATABASE_FN "ErrGetBackupUsnFromDatabase"
#define GET_BACKUP_USN_FN               "ErrGetBackupUsn"
#define ERR_RECOVER_AFTER_RESTORE_A_FN  "ErrRecoverAfterRestoreA"
#define ERR_RECOVER_AFTER_RESTORE_W_FN  "ErrRecoverAfterRestoreW"

#define NTDSBACKUPDLL_A "ntdsbsrv"
#define NTDSBACKUPDLL_W L"ntdsbsrv"

#ifdef	UNICODE
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreW
#define ERR_RECOVER_AFTER_RESTORE_FN ERR_RECOVER_AFTER_RESTORE_W_FN
#define ERR_RECOVER_AFTER_RESTORE ERR_RECOVER_AFTER_RESTORE_W
#define NTDSBACKUPDLL NTDSBACKUPDLL_W
#else
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreA
#define ERR_RECOVER_AFTER_RESTORE_FN ERR_RECOVER_AFTER_RESTORE_A_FN
#define ERR_RECOVER_AFTER_RESTORE ERR_RECOVER_AFTER_RESTORE_A
#define NTDSBACKUPDLL NTDSBACKUPDLL_A
#endif

extern ERR_GET_NEW_INVOCATION_ID FnErrGetNewInvocationId;
extern ERR_GET_BACKUP_USN_FROM_DATABASE FnErrGetBackupUsnFromDatabase;
extern ERR_GET_BACKUP_USN FnErrGetBackupUsn;

#ifdef __cplusplus
}
#endif 

#endif // _NTDSBSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\nsp_both.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nsp_both.h
//
//--------------------------------------------------------------------------

/*
 *      Common Name Service Provider Header
 *
 *  Things both the client and server side need to know
 */

#ifndef CP_WINUNICODE
#define CP_WINUNICODE 1200
#endif

#if (CP_WINUNICODE != 1200)
#error Win32 definition of CP_WINUNICODE has changed!
#endif
     
/*
 *  Basic data types and macros
 */
#ifndef _NSP_BOTH
#define _NSP_BOTH


#define EMAIL_TYPE     "EX"
#define EMAIL_TYPE_W   L"EX"

#define MAX_RECS    50

/* Number of rows to get on pre-emptive Query-Rows done by GetMatches. */
#define  DEF_SROW_COUNT 50

/*
 * ModLinkAtt Flags.
 */
#define fDELETE         0x1

/*
 * Searching and seeking flags
 */
#define bAPPROX		0
#define bEXACT		0x1
#define bPREFIX		0x2
#define bADMIN          0x8
#define bEND            0x10

/*
 * Flag for logon
 */
#define fAnonymousLogin 0x20

/*
 *  Flags for NspiModProp.
 */
#define AB_ADD                  1 // The modify is really adding a new object

/* 
 * Flags for NspiGetProps.
 */
#define AB_SKIP_OBJECTS	1

/*
 *  Flags for NspiGetHierarchyInfo
 */
#define AB_DOS			1
#define AB_ONE_OFF              2
#define AB_UNICODE              4
#define AB_ADMIN                8
#define AB_PAGE_HIER            16

/*
 *  Flags for ulInterfaceOptions on OpenProperty
 * This flag is strictly internal.  Other, external, flags are
 * defined in emsabtag.h
 */
#define AB_LINK_ONLY             1

/*
 *  Values for flags used in GetProps and QueryRows to describe behavior
 *  of the GetSRow call. These flags are used as a bit map, so use powers
 *  of 2 for new flags.
 */

/* default handling of entry ids is to return a permanent, this flag forces
 * use of an ephemeral.
 */
#define fEPHID                 2
/* default handling of deleted or phantom objects is to not find them.  This
 * flag tells us to fake up properties for these things if they are in a
 * restriction.
 */
#define fPhantoms              4   

#define   ONE_OFF_PROP_COUNT    7       // # of propvals in a OneOffTable row

/*
 * Flags for NspiGetTemplateInfo
 *
 * TI_MAX_TEMPLATE_INFO is the number of different information items that can
 * be returned.  TI_foo is a flag asking for the foo information.
 */
#define TI_MAX_TEMPLATE_INFO 7

/*
 * If constants are added here, TI_MAX_TEMPLATE_INFO MUST be updated to
 * reflect the change.
 */
#define TI_TEMPLATE	 1
#define TI_DOS_TEMPLATE	 2
#define TI_SCRIPT	 4
#define TI_HELPFILE16 	 8
#define TI_EMT		 16
#define TI_HELPFILE_NAME 32
#define TI_HELPFILE32 	 64


typedef struct  _CNTRL_MARSHALLED {
    DWORD dwType;
    ULONG ulSize;
    ULONG ulStringOffset;
} CNTRL_MARSHALLED;

typedef struct  _TROW_MARSHALLED {
    long lXPos;
    long lDeltaX;
    long lYPos;
    long lDeltaY;
    long lControlType;
    long lControlFlags;
    CNTRL_MARSHALLED cnControlStruc;
} TROW_MARSHALLED, FAR * LPTROW_MARSHALLED;

typedef struct  _TRowSet_r_MARSHALLED {
    ULONG ulVersion;
    ULONG cRows;
    TROW_MARSHALLED aRow[1];
} TRowSet_MARSHALLED, FAR * LPTRowSet_MARSHALLED, FAR * FAR * LPLPTRowSet_MARSHALLED;

#define DSA_TEMPLATE     1

/* 
 * The following codes are defined by windows NT in winerror.h. However, we need
 * to access them on all platforms, so define them here if they are not 
 * previously defined.
 */

#ifndef ERROR_PASSWORD_MUST_CHANGE
#define ERROR_PASSWORD_MUST_CHANGE	1907L
#endif
#ifndef ERROR_PASSWORD_EXPIRED
#define ERROR_PASSWORD_EXPIRED		1330L
#endif
#ifndef ERROR_INVALID_WORKSTATION
#define ERROR_INVALID_WORKSTATION	1329L
#endif
#ifndef ERROR_INVALID_LOGON_HOURS
#define ERROR_INVALID_LOGON_HOURS	1328L
#endif
#ifndef ERROR_ACCOUNT_DISABLED
#define ERROR_ACCOUNT_DISABLED		1331L
#endif

#endif      // ifdef _NSP_BOTH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdsetup.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ntdsetup.h

Abstract:

    Contains entry point declarations for ntdsetup.dll

Author:

    ColinBr  29-Sept-1996

Environment:

    User Mode - NT

Revision History:

    ColinBr 4-Jan-1997
        Added NTDSInstallReplica

    ColinBr 25-Jan-1997
        Added general purposes install primitive api with new
        helper functions

    ColinBr 03-September-1997
        Added NtdsISetReplicaMachineAccount

    ColinBr 09-Jan-1998
        Added demote support and cleanup


--*/

#ifndef _NTDSETUP_H_
#define _NTDSETUP_H_

#include <dsrolep.h>

//
// This typedef is used so functions in the dll can update the 
// OperationResultsFlag
//                                                                      
typedef DWORD (*CALLBACK_OPERATION_RESULT_FLAGS_TYPE)(IN DWORD Flags);

//
// This typedef is used so functions in the dll can give status
// updates since some of them take several minutes and perform
// many operations
//
typedef DWORD (*CALLBACK_STATUS_TYPE)( IN LPWSTR wczStatus );

//
// This typedef is used so function is ntdsetup.dll can give
// a detailed string giving the context of a particular error
//
typedef DWORD (*CALLBACK_ERROR_TYPE)( IN PWSTR String,  
                                      IN DWORD ErrorCode );


//
// Valid flags for NTDS_INSTALL_INFO
//
#define NTDS_INSTALL_ENTERPRISE         0x00000001
#define NTDS_INSTALL_DOMAIN             0x00000002
#define NTDS_INSTALL_REPLICA            0x00000004

// These cause the the existing dc's or domain's in the
// enterprise to be removed from the ds before
// installing the directory service.    
#define NTDS_INSTALL_DC_REINSTALL       0x00000008
#define NTDS_INSTALL_DOMAIN_REINSTALL   0x00000010

// This tells us to use hives that we saved off
#define NTDS_INSTALL_UPGRADE            0x00000020

// This tells NtdsInstall when creating a first dc in domain
// create a new domain, not migrate the exist server accounts
#define NTDS_INSTALL_FRESH_DOMAIN       0x00000040

// This indicates that the new domain is a new tree
#define NTDS_INSTALL_NEW_TREE           0x00000080

// This indicates to allow anonymous access
#define NTDS_INSTALL_ALLOW_ANONYMOUS    0x00000100

// This indicates to set the ds repair password to the
// current admin's password
#define NTDS_INSTALL_DFLT_REPAIR_PWD    0x00000200


// This indicates to set the behavior version of the forest
// to the most current version.  Valid only for new forest installs.
#define NTDS_INSTALL_SET_FOREST_CURRENT 0x00000400

//
// Flags for NtdsDemote
//
#define NTDS_LAST_DC_IN_DOMAIN           0x00000001
#define NTDS_LAST_DOMAIN_IN_ENTERPRISE   0x00000002
#define NTDS_DONT_DELETE_DOMAIN          0x00000004
#define NTDS_FORCE_DEMOTE                0x00000008
//
// Flags for NtdsInstallReplicaFULL
//
#define NTDS_IFM_PROMOTION               0x00000001

typedef struct {

    // Describes the kind of install requested
    DWORD   Flags;

    // In an IFM promotion, this is the sytem info off the oringinal
    //   system's registry.
    IFM_SYSTEM_INFO * pIfmSystemInfo;

    // The System Schema Version from the restored database files.
    DWORD   RestoredSystemSchemaVersion;

    // Location of database files
    LPWSTR  DitPath;
    LPWSTR  LogPath;
    LPWSTR  SysVolPath;

    PVOID  BootKey;
    DWORD  cbBootKey;

    // Ds location of server object
    LPWSTR  SiteName;   OPTIONAL

    // The name of the domain to join or create
    LPWSTR  DnsDomainName;
    LPWSTR  FlatDomainName;

    // The name of the tree to join
    LPWSTR  DnsTreeRoot;

    // This is required for replica or domain install
    LPWSTR  ReplServerName;

    // Credentials for replication
    SEC_WINNT_AUTH_IDENTITY *Credentials;   OPTIONAL

    // Status function
    CALLBACK_STATUS_TYPE pfnUpdateStatus;   OPTIONAL

    // New admin password
    LPWSTR AdminPassword;

    // Error function
    CALLBACK_ERROR_TYPE pfnErrorStatus;     OPTIONAL

    // OperationResultsFlags update function
    CALLBACK_OPERATION_RESULT_FLAGS_TYPE pfnOperationResultFlags;   OPTIONAL

    // Client Token
    HANDLE              ClientToken;

    // The safe mode (aka ds repair) admin password
    LPWSTR SafeModePassword;

    // The name of domain we will replicate from
    LPWSTR SourceDomainName;

    // The options Field
    ULONG Options;


} NTDS_INSTALL_INFO, *PNTDS_INSTALL_INFO;

typedef struct {

    LPWSTR DnsDomainName;
    GUID   DomainGuid;
    GUID   DsaGuid;
    LPWSTR DnsHostName;

} NTDS_DNS_RR_INFO, *PNTDS_DNS_RR_INFO;

#ifdef __cplusplus
extern "C" {
#endif

//
// This function starts the initialization of the directory service and
// performs any upgrading that the NT Security Accounts Manager requires
// to use the directory service.  The ds is left "running" so other lsass
// components can upgrade thier database items.
//
// The caller must free SiteName with RtlFreeHeap() from the process heap
// The caller must free NewDnsDomainSid with RtlFreeHeap() from the process
// heap.
//
DWORD               
NtdsInstall(
    IN  PNTDS_INSTALL_INFO InstallInfo,
    OUT LPWSTR *InstalledSiteName, OPTIONAL
    OUT GUID   *NewDnsDomainGuid,  OPTIONAL
    OUT PSID   *NewDnsDomainSid    OPTIONAL
    );

//
// This function shuts down the directory service when started by
// NtdsInstall.  This function will only succeed when NtdsInstall
// has succeeded and must be called between calls to NtdsInstall,
// should NtdsInstall be called more than once.
//
DWORD
NtdsInstallShutdown(
    VOID
    );

//
// This function undoes the effect of NtdsInstall
//
DWORD
NtdsInstallUndo(
    VOID
    );

//
// This function copies the Domain NC from the source machine.  During
// NtdsInstall, only the critical objects were copied at that time.
//
DWORD
NtdsInstallReplicateFull(
    CALLBACK_STATUS_TYPE StatusCallback,
    HANDLE               ClientToken,
    ULONG                ulRepOptions
    );

//
// This function causes NtdsInstall or NtdsInstallReplicateFull running in
// another thread to finish prematurely.
//
DWORD
NtdsInstallCancel(
    void
    );

//
// This function prepares the directory service to shutdown
// but does not perform the actual demotion
//
DWORD
NtdsPrepareForDemotion(
    IN ULONG Flags,
    IN LPWSTR                   ServerName,        OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorStatus,     OPTIONAL
    IN HANDLE                   ClientToken,        OPTIONAL
    IN ULONG                    cRemoveNCs,                           
    IN LPWSTR *                 pszRemoveNCs,      OPTIONAL
    OUT PNTDS_DNS_RR_INFO       *pDnsRRInfo
    );

//
// This function undoes any actions performed by
// NtdsPrepareForDemotion
//
DWORD
NtdsPrepareForDemotionUndo(
    VOID
    );

//
// This function performs the DS and SAM actions to be become a
// server from a DC and stops the ds
//
DWORD
NtdsDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName,
    IN HANDLE                   ClientToken,
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorStatus,     OPTIONAL
    IN ULONG                    cRemoveNCs,                           
    IN LPWSTR *                 pszRemoveNCs        OPTIONAL
    );


DWORD
NtdsPrepareForDsUpgrade(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO NewLocalAccountInfo,
    OUT LPWSTR                     *NewAdminPassword
    );

//
// This is a helper function for the ui to suggest what dns domain
// name should be used.
//
DWORD
NtdsGetDefaultDnsName(
    OUT LPWSTR     DnsName, OPTIONAL
    IN  OUT ULONG *DnsNameLength
    );


//
// This function will set the machine account type of the
// computer object of the local server via ldap.
//
typedef DWORD ( *NTDSETUP_NtdsSetReplicaMachineAccount )(
            IN SEC_WINNT_AUTH_IDENTITY_W *Credentials,
            IN HANDLE                     ClientToken,
            IN LPWSTR                     DcName,
            IN LPWSTR                     AccountName,
            IN ULONG                      AccountFlags,
            IN OUT WCHAR**                AccountDn OPTIONAL
            );

#define NTDSETUP_SET_MACHINE_ACCOUNT_FN  "NtdsSetReplicaMachineAccount"

DWORD
NtdsSetReplicaMachineAccount(
    IN SEC_WINNT_AUTH_IDENTITY_W   *Credentials,
    IN HANDLE                     ClientToken,
    IN LPWSTR                     DcName,
    IN LPWSTR                     AccountName,
    IN ULONG                      AccountType,  // either UF_SERVER_TRUST_ACCOUNT
                                                // or     UF_WORKSTATION_TRUST_ACCOUNT
    IN OUT WCHAR**                AccountDn    OPTIONAL
    );

VOID
NtdsFreeDnsRRInfo(
    IN PNTDS_DNS_RR_INFO pInfo
    );

#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // _NTDSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdsimp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       imports.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#ifdef MIDL_PASS
/******************************************************************
 *    Standard c data structures.  These should match the defaults.
 ******************************************************************/

typedef unsigned short USHORT;
typedef unsigned long  ULONG;
typedef unsigned char  UCHAR;
typedef UCHAR *PUCHAR;
typedef LONGLONG USN;

#define BOOL long
#define FAR
#define PASCAL

/* Needed to patch up the IDL understanding of UNICODE_STRING this is
   also defined in ntdef.h, but including ntdef.h provided too many 
   conflicts.  That is probably why this was added and things like
   USHORT, ULONG, UCHAR, etc were added.  Be nice if someone fixed 
   this */
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

#define NULL 0

#define IN
#define OUT

// So MIDL doesn't choke on parts of ntdsapi.h.
#define DECLSPEC_IMPORT
#define WINAPI

#endif

#include <ntdsapi.h>
#include <ntdsa.h>
#include <ntdsapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdskcc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdskcc.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/21/97    Jeff Parham (jeffparh)
                In-process interface to the KCC.

REVISION HISTORY:

--*/


DWORD
KccInitialize();

// Tells the KCC to shut down, but does not wait to see if it does so
void
KccUnInitializeTrigger();


// Waits at most dwMaxWaitInMsec milliseconds for the current KCC task
// to complete.  You must call the trigger routine (above) first.
DWORD
KccUnInitializeWait(
    DWORD   dwMaxWaitInMsec
    );

// Force the KCC to run a task (e.g., update the replication topology).
DWORD
KccExecuteTask(
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsg
    );

// Returns the contents of the connection or link failure cache.
DWORD
KccGetFailureCache(
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdsguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       ntdsguid.h
//
//--------------------------------------------------------------------------


/*++
 File:    NTDSGUID.H
 Purpose: Contains the Schema Guids for the Attributes and Class
          Schema Objects in NTDS.
 Creator: Automatically generated on
 Date:    Wed Jun 26 10:50:14 2002

 ** This is a Generated File From Schema.INI **

--*/
#ifndef _NTDSGUID_
#define _NTDSGUID_

// 
// The List of GUID Controls used in DS
// 

extern const GUID GUID_CONTROL_DomainListAccounts       ;  
extern const GUID GUID_CONTROL_DomainLookup             ;  
extern const GUID GUID_CONTROL_DomainAdministerServer   ;  
extern const GUID GUID_CONTROL_UserChangePassword       ;  
extern const GUID GUID_CONTROL_UserForceChangePassword  ;  
extern const GUID GUID_CONTROL_SendAs                   ;  
extern const GUID GUID_CONTROL_SendTo                   ;  
extern const GUID GUID_CONTROL_ReceiveAs                ;  
extern const GUID GUID_CONTROL_ListGroupMembership      ;  
extern const GUID GUID_CONTROL_DsInstallReplica         ;  
extern const GUID GUID_CONTROL_DsSamEnumEntireDomain    ;  
extern const GUID GUID_CONTROL_UpdatePasswordNotRequiredBit ;  
extern const GUID GUID_CONTROL_UnexpirePassword         ;  
extern const GUID GUID_CONTROL_EnablePerUserReversiblyEncryptedTextPassword ;  

//
// List of SAM property set GUIDS
//

extern const GUID GUID_PS_DOMAIN_PASSWORD               ;  
extern const GUID GUID_PS_GENERAL_INFO                  ;  
extern const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS     ;  
extern const GUID GUID_PS_USER_LOGON                    ;  
extern const GUID GUID_PS_MEMBERSHIP                    ;  
extern const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS       ;  


// 
// The list of Property Set GUIDS used by LSA
// 

extern const GUID GUID_PS_PASSWORD_POLICY               ;   
extern const GUID GUID_PS_LOCKOUT_POLICY                ;   
extern const GUID GUID_PS_DOMAIN_CONFIGURATION          ;   
extern const GUID GUID_PS_DOMAIN_POLICY                 ;   
extern const GUID GUID_PS_PRIVILEGES                    ;   
extern const GUID GUID_PS_ADMINISTRATIVE_ACCESS         ;   
extern const GUID GUID_PS_LOCAL_POLICY                  ;   
extern const GUID GUID_PS_AUDIT                         ;   
extern const GUID GUID_PS_BUILTIN_LOCAL_GROUPS          ;   



//--------------------------------------
// ATTRIBUTE SCHEMA GUIDS
//--------------------------------------
extern const GUID GUID_A_ACCOUNT_EXPIRES                     ;
extern const GUID GUID_A_ACCOUNT_NAME_HISTORY                ;
extern const GUID GUID_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER      ;
extern const GUID GUID_A_ACS_ALLOCABLE_RSVP_BANDWIDTH        ;
extern const GUID GUID_A_ACS_CACHE_TIMEOUT                   ;
extern const GUID GUID_A_ACS_DIRECTION                       ;
extern const GUID GUID_A_ACS_DSBM_DEADTIME                   ;
extern const GUID GUID_A_ACS_DSBM_PRIORITY                   ;
extern const GUID GUID_A_ACS_DSBM_REFRESH                    ;
extern const GUID GUID_A_ACS_ENABLE_ACS_SERVICE              ;
extern const GUID GUID_A_ACS_ENABLE_RSVP_ACCOUNTING          ;
extern const GUID GUID_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING      ;
extern const GUID GUID_A_ACS_EVENT_LOG_LEVEL                 ;
extern const GUID GUID_A_ACS_IDENTITY_NAME                   ;
extern const GUID GUID_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER      ;
extern const GUID GUID_A_ACS_MAX_DURATION_PER_FLOW           ;
extern const GUID GUID_A_ACS_MAX_NO_OF_ACCOUNT_FILES         ;
extern const GUID GUID_A_ACS_MAX_NO_OF_LOG_FILES             ;
extern const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH              ;
extern const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW      ;
extern const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE      ;
extern const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE       ;
extern const GUID GUID_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW       ;
extern const GUID GUID_A_ACS_MAX_TOKEN_RATE_PER_FLOW         ;
extern const GUID GUID_A_ACS_MAXIMUM_SDU_SIZE                ;
extern const GUID GUID_A_ACS_MINIMUM_DELAY_VARIATION         ;
extern const GUID GUID_A_ACS_MINIMUM_LATENCY                 ;
extern const GUID GUID_A_ACS_MINIMUM_POLICED_SIZE            ;
extern const GUID GUID_A_ACS_NON_RESERVED_MAX_SDU_SIZE       ;
extern const GUID GUID_A_ACS_NON_RESERVED_MIN_POLICED_SIZE      ;
extern const GUID GUID_A_ACS_NON_RESERVED_PEAK_RATE          ;
extern const GUID GUID_A_ACS_NON_RESERVED_TOKEN_SIZE         ;
extern const GUID GUID_A_ACS_NON_RESERVED_TX_LIMIT           ;
extern const GUID GUID_A_ACS_NON_RESERVED_TX_SIZE            ;
extern const GUID GUID_A_ACS_PERMISSION_BITS                 ;
extern const GUID GUID_A_ACS_POLICY_NAME                     ;
extern const GUID GUID_A_ACS_PRIORITY                        ;
extern const GUID GUID_A_ACS_RSVP_ACCOUNT_FILES_LOCATION      ;
extern const GUID GUID_A_ACS_RSVP_LOG_FILES_LOCATION         ;
extern const GUID GUID_A_ACS_SERVICE_TYPE                    ;
extern const GUID GUID_A_ACS_TIME_OF_DAY                     ;
extern const GUID GUID_A_ACS_TOTAL_NO_OF_FLOWS               ;
extern const GUID GUID_A_ACS_SERVER_LIST                     ;
extern const GUID GUID_A_ADDITIONAL_INFORMATION              ;
extern const GUID GUID_A_ADDITIONAL_TRUSTED_SERVICE_NAMES      ;
extern const GUID GUID_A_ADDRESS                             ;
extern const GUID GUID_A_ADDRESS_BOOK_ROOTS                  ;
extern const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE         ;
extern const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS      ;
extern const GUID GUID_A_ADDRESS_HOME                        ;
extern const GUID GUID_A_ADDRESS_SYNTAX                      ;
extern const GUID GUID_A_ADDRESS_TYPE                        ;
extern const GUID GUID_A_ADMIN_CONTEXT_MENU                  ;
extern const GUID GUID_A_ADMIN_COUNT                         ;
extern const GUID GUID_A_ADMIN_DESCRIPTION                   ;
extern const GUID GUID_A_ADMIN_DISPLAY_NAME                  ;
extern const GUID GUID_A_ADMIN_MULTISELECT_PROPERTY_PAGES      ;
extern const GUID GUID_A_ADMIN_PROPERTY_PAGES                ;
extern const GUID GUID_A_ALLOWED_ATTRIBUTES                  ;
extern const GUID GUID_A_ALLOWED_ATTRIBUTES_EFFECTIVE        ;
extern const GUID GUID_A_ALLOWED_CHILD_CLASSES               ;
extern const GUID GUID_A_ALLOWED_CHILD_CLASSES_EFFECTIVE      ;
extern const GUID GUID_A_ALT_SECURITY_IDENTITIES             ;
extern const GUID GUID_A_ANR                                 ;
extern const GUID GUID_A_APP_SCHEMA_VERSION                  ;
extern const GUID GUID_A_APPLICATION_NAME                    ;
extern const GUID GUID_A_APPLIES_TO                          ;
extern const GUID GUID_A_ASSET_NUMBER                        ;
extern const GUID GUID_A_ASSISTANT                           ;
extern const GUID GUID_A_ASSOC_NT_ACCOUNT                    ;
extern const GUID GUID_A_ASSOCIATEDDOMAIN                    ;
extern const GUID GUID_A_ASSOCIATEDNAME                      ;
extern const GUID GUID_A_ATTRIBUTECERTIFICATEATTRIBUTE       ;
extern const GUID GUID_A_ATTRIBUTE_DISPLAY_NAMES             ;
extern const GUID GUID_A_ATTRIBUTE_ID                        ;
extern const GUID GUID_A_ATTRIBUTE_SECURITY_GUID             ;
extern const GUID GUID_A_ATTRIBUTE_SYNTAX                    ;
extern const GUID GUID_A_ATTRIBUTE_TYPES                     ;
extern const GUID GUID_A_AUDIO                               ;
extern const GUID GUID_A_AUDITING_POLICY                     ;
extern const GUID GUID_A_AUTHENTICATION_OPTIONS              ;
extern const GUID GUID_A_AUTHORITY_REVOCATION_LIST           ;
extern const GUID GUID_A_AUXILIARY_CLASS                     ;
extern const GUID GUID_A_BAD_PASSWORD_TIME                   ;
extern const GUID GUID_A_BAD_PWD_COUNT                       ;
extern const GUID GUID_A_BIRTH_LOCATION                      ;
extern const GUID GUID_A_BRIDGEHEAD_SERVER_LIST_BL           ;
extern const GUID GUID_A_BRIDGEHEAD_TRANSPORT_LIST           ;
extern const GUID GUID_A_BUILDINGNAME                        ;
extern const GUID GUID_A_BUILTIN_CREATION_TIME               ;
extern const GUID GUID_A_BUILTIN_MODIFIED_COUNT              ;
extern const GUID GUID_A_BUSINESS_CATEGORY                   ;
extern const GUID GUID_A_BYTES_PER_MINUTE                    ;
extern const GUID GUID_A_CA_CERTIFICATE                      ;
extern const GUID GUID_A_CA_CERTIFICATE_DN                   ;
extern const GUID GUID_A_CA_CONNECT                          ;
extern const GUID GUID_A_CA_USAGES                           ;
extern const GUID GUID_A_CA_WEB_URL                          ;
extern const GUID GUID_A_CAN_UPGRADE_SCRIPT                  ;
extern const GUID GUID_A_CANONICAL_NAME                      ;
extern const GUID GUID_A_CARLICENSE                          ;
extern const GUID GUID_A_CATALOGS                            ;
extern const GUID GUID_A_CATEGORIES                          ;
extern const GUID GUID_A_CATEGORY_ID                         ;
extern const GUID GUID_A_CERTIFICATE_AUTHORITY_OBJECT        ;
extern const GUID GUID_A_CERTIFICATE_REVOCATION_LIST         ;
extern const GUID GUID_A_CERTIFICATE_TEMPLATES               ;
extern const GUID GUID_A_CLASS_DISPLAY_NAME                  ;
extern const GUID GUID_A_CODE_PAGE                           ;
extern const GUID GUID_A_COM_CLASSID                         ;
extern const GUID GUID_A_COM_CLSID                           ;
extern const GUID GUID_A_COM_INTERFACEID                     ;
extern const GUID GUID_A_COM_OTHER_PROG_ID                   ;
extern const GUID GUID_A_COM_PROGID                          ;
extern const GUID GUID_A_COM_TREAT_AS_CLASS_ID               ;
extern const GUID GUID_A_COM_TYPELIB_ID                      ;
extern const GUID GUID_A_COM_UNIQUE_LIBID                    ;
extern const GUID GUID_A_COMMENT                             ;
extern const GUID GUID_A_COMMON_NAME                         ;
extern const GUID GUID_A_COMPANY                             ;
extern const GUID GUID_A_CONTENT_INDEXING_ALLOWED            ;
extern const GUID GUID_A_CONTEXT_MENU                        ;
extern const GUID GUID_A_CONTROL_ACCESS_RIGHTS               ;
extern const GUID GUID_A_COST                                ;
extern const GUID GUID_A_COUNTRY_CODE                        ;
extern const GUID GUID_A_COUNTRY_NAME                        ;
extern const GUID GUID_A_CREATE_DIALOG                       ;
extern const GUID GUID_A_CREATE_TIME_STAMP                   ;
extern const GUID GUID_A_CREATE_WIZARD_EXT                   ;
extern const GUID GUID_A_CREATION_TIME                       ;
extern const GUID GUID_A_CREATION_WIZARD                     ;
extern const GUID GUID_A_CREATOR                             ;
extern const GUID GUID_A_CRL_OBJECT                          ;
extern const GUID GUID_A_CRL_PARTITIONED_REVOCATION_LIST      ;
extern const GUID GUID_A_CROSS_CERTIFICATE_PAIR              ;
extern const GUID GUID_A_CURR_MACHINE_ID                     ;
extern const GUID GUID_A_CURRENT_LOCATION                    ;
extern const GUID GUID_A_CURRENT_PARENT_CA                   ;
extern const GUID GUID_A_CURRENT_VALUE                       ;
extern const GUID GUID_A_DBCS_PWD                            ;
extern const GUID GUID_A_DEFAULT_CLASS_STORE                 ;
extern const GUID GUID_A_DEFAULT_GROUP                       ;
extern const GUID GUID_A_DEFAULT_HIDING_VALUE                ;
extern const GUID GUID_A_DEFAULT_LOCAL_POLICY_OBJECT         ;
extern const GUID GUID_A_DEFAULT_OBJECT_CATEGORY             ;
extern const GUID GUID_A_DEFAULT_PRIORITY                    ;
extern const GUID GUID_A_DEFAULT_SECURITY_DESCRIPTOR         ;
extern const GUID GUID_A_DELTA_REVOCATION_LIST               ;
extern const GUID GUID_A_DEPARTMENT                          ;
extern const GUID GUID_A_DEPARTMENTNUMBER                    ;
extern const GUID GUID_A_DESCRIPTION                         ;
extern const GUID GUID_A_DESKTOP_PROFILE                     ;
extern const GUID GUID_A_DESTINATION_INDICATOR               ;
extern const GUID GUID_A_DHCP_CLASSES                        ;
extern const GUID GUID_A_DHCP_FLAGS                          ;
extern const GUID GUID_A_DHCP_IDENTIFICATION                 ;
extern const GUID GUID_A_DHCP_MASK                           ;
extern const GUID GUID_A_DHCP_MAXKEY                         ;
extern const GUID GUID_A_DHCP_OBJ_DESCRIPTION                ;
extern const GUID GUID_A_DHCP_OBJ_NAME                       ;
extern const GUID GUID_A_DHCP_OPTIONS                        ;
extern const GUID GUID_A_DHCP_PROPERTIES                     ;
extern const GUID GUID_A_DHCP_RANGES                         ;
extern const GUID GUID_A_DHCP_RESERVATIONS                   ;
extern const GUID GUID_A_DHCP_SERVERS                        ;
extern const GUID GUID_A_DHCP_SITES                          ;
extern const GUID GUID_A_DHCP_STATE                          ;
extern const GUID GUID_A_DHCP_SUBNETS                        ;
extern const GUID GUID_A_DHCP_TYPE                           ;
extern const GUID GUID_A_DHCP_UNIQUE_KEY                     ;
extern const GUID GUID_A_DHCP_UPDATE_TIME                    ;
extern const GUID GUID_A_DISPLAY_NAME                        ;
extern const GUID GUID_A_DISPLAY_NAME_PRINTABLE              ;
extern const GUID GUID_A_DIT_CONTENT_RULES                   ;
extern const GUID GUID_A_DIVISION                            ;
extern const GUID GUID_A_DMD_LOCATION                        ;
extern const GUID GUID_A_DMD_NAME                            ;
extern const GUID GUID_A_DN_REFERENCE_UPDATE                 ;
extern const GUID GUID_A_DNS_ALLOW_DYNAMIC                   ;
extern const GUID GUID_A_DNS_ALLOW_XFR                       ;
extern const GUID GUID_A_DNS_HOST_NAME                       ;
extern const GUID GUID_A_DNS_NOTIFY_SECONDARIES              ;
extern const GUID GUID_A_DNS_PROPERTY                        ;
extern const GUID GUID_A_DNS_RECORD                          ;
extern const GUID GUID_A_DNS_ROOT                            ;
extern const GUID GUID_A_DNS_SECURE_SECONDARIES              ;
extern const GUID GUID_A_DNS_TOMBSTONED                      ;
extern const GUID GUID_A_DOCUMENTAUTHOR                      ;
extern const GUID GUID_A_DOCUMENTIDENTIFIER                  ;
extern const GUID GUID_A_DOCUMENTLOCATION                    ;
extern const GUID GUID_A_DOCUMENTPUBLISHER                   ;
extern const GUID GUID_A_DOCUMENTTITLE                       ;
extern const GUID GUID_A_DOCUMENTVERSION                     ;
extern const GUID GUID_A_DOMAIN_CERTIFICATE_AUTHORITIES      ;
extern const GUID GUID_A_DOMAIN_COMPONENT                    ;
extern const GUID GUID_A_DOMAIN_CROSS_REF                    ;
extern const GUID GUID_A_DOMAIN_ID                           ;
extern const GUID GUID_A_DOMAIN_IDENTIFIER                   ;
extern const GUID GUID_A_DOMAIN_POLICY_OBJECT                ;
extern const GUID GUID_A_DOMAIN_POLICY_REFERENCE             ;
extern const GUID GUID_A_DOMAIN_REPLICA                      ;
extern const GUID GUID_A_DOMAIN_WIDE_POLICY                  ;
extern const GUID GUID_A_DRINK                               ;
extern const GUID GUID_A_DRIVER_NAME                         ;
extern const GUID GUID_A_DRIVER_VERSION                      ;
extern const GUID GUID_A_DS_CORE_PROPAGATION_DATA            ;
extern const GUID GUID_A_DS_HEURISTICS                       ;
extern const GUID GUID_A_DS_UI_ADMIN_MAXIMUM                 ;
extern const GUID GUID_A_DS_UI_ADMIN_NOTIFICATION            ;
extern const GUID GUID_A_DS_UI_SHELL_MAXIMUM                 ;
extern const GUID GUID_A_DSA_SIGNATURE                       ;
extern const GUID GUID_A_DYNAMIC_LDAP_SERVER                 ;
extern const GUID GUID_A_E_MAIL_ADDRESSES                    ;
extern const GUID GUID_A_EFSPOLICY                           ;
extern const GUID GUID_A_EMPLOYEE_ID                         ;
extern const GUID GUID_A_EMPLOYEE_NUMBER                     ;
extern const GUID GUID_A_EMPLOYEE_TYPE                       ;
extern const GUID GUID_A_ENABLED                             ;
extern const GUID GUID_A_ENABLED_CONNECTION                  ;
extern const GUID GUID_A_ENROLLMENT_PROVIDERS                ;
extern const GUID GUID_A_ENTRY_TTL                           ;
extern const GUID GUID_A_EXTENDED_ATTRIBUTE_INFO             ;
extern const GUID GUID_A_EXTENDED_CHARS_ALLOWED              ;
extern const GUID GUID_A_EXTENDED_CLASS_INFO                 ;
extern const GUID GUID_A_EXTENSION_NAME                      ;
extern const GUID GUID_A_EXTRA_COLUMNS                       ;
extern const GUID GUID_A_FACSIMILE_TELEPHONE_NUMBER          ;
extern const GUID GUID_A_FILE_EXT_PRIORITY                   ;
extern const GUID GUID_A_FLAGS                               ;
extern const GUID GUID_A_FLAT_NAME                           ;
extern const GUID GUID_A_FORCE_LOGOFF                        ;
extern const GUID GUID_A_FOREIGN_IDENTIFIER                  ;
extern const GUID GUID_A_FRIENDLY_NAMES                      ;
extern const GUID GUID_A_FROM_ENTRY                          ;
extern const GUID GUID_A_FROM_SERVER                         ;
extern const GUID GUID_A_FRS_COMPUTER_REFERENCE              ;
extern const GUID GUID_A_FRS_COMPUTER_REFERENCE_BL           ;
extern const GUID GUID_A_FRS_CONTROL_DATA_CREATION           ;
extern const GUID GUID_A_FRS_CONTROL_INBOUND_BACKLOG         ;
extern const GUID GUID_A_FRS_CONTROL_OUTBOUND_BACKLOG        ;
extern const GUID GUID_A_FRS_DIRECTORY_FILTER                ;
extern const GUID GUID_A_FRS_DS_POLL                         ;
extern const GUID GUID_A_FRS_EXTENSIONS                      ;
extern const GUID GUID_A_FRS_FAULT_CONDITION                 ;
extern const GUID GUID_A_FRS_FILE_FILTER                     ;
extern const GUID GUID_A_FRS_FLAGS                           ;
extern const GUID GUID_A_FRS_LEVEL_LIMIT                     ;
extern const GUID GUID_A_FRS_MEMBER_REFERENCE                ;
extern const GUID GUID_A_FRS_MEMBER_REFERENCE_BL             ;
extern const GUID GUID_A_FRS_PARTNER_AUTH_LEVEL              ;
extern const GUID GUID_A_FRS_PRIMARY_MEMBER                  ;
extern const GUID GUID_A_FRS_REPLICA_SET_GUID                ;
extern const GUID GUID_A_FRS_REPLICA_SET_TYPE                ;
extern const GUID GUID_A_FRS_ROOT_PATH                       ;
extern const GUID GUID_A_FRS_ROOT_SECURITY                   ;
extern const GUID GUID_A_FRS_SERVICE_COMMAND                 ;
extern const GUID GUID_A_FRS_SERVICE_COMMAND_STATUS          ;
extern const GUID GUID_A_FRS_STAGING_PATH                    ;
extern const GUID GUID_A_FRS_TIME_LAST_COMMAND               ;
extern const GUID GUID_A_FRS_TIME_LAST_CONFIG_CHANGE         ;
extern const GUID GUID_A_FRS_UPDATE_TIMEOUT                  ;
extern const GUID GUID_A_FRS_VERSION                         ;
extern const GUID GUID_A_FRS_VERSION_GUID                    ;
extern const GUID GUID_A_FRS_WORKING_PATH                    ;
extern const GUID GUID_A_FSMO_ROLE_OWNER                     ;
extern const GUID GUID_A_GARBAGE_COLL_PERIOD                 ;
extern const GUID GUID_A_GENERATED_CONNECTION                ;
extern const GUID GUID_A_GENERATION_QUALIFIER                ;
extern const GUID GUID_A_GIVEN_NAME                          ;
extern const GUID GUID_A_GLOBAL_ADDRESS_LIST                 ;
extern const GUID GUID_A_GOVERNS_ID                          ;
extern const GUID GUID_A_GP_LINK                             ;
extern const GUID GUID_A_GP_OPTIONS                          ;
extern const GUID GUID_A_GPC_FILE_SYS_PATH                   ;
extern const GUID GUID_A_GPC_FUNCTIONALITY_VERSION           ;
extern const GUID GUID_A_GPC_MACHINE_EXTENSION_NAMES         ;
extern const GUID GUID_A_GPC_USER_EXTENSION_NAMES            ;
extern const GUID GUID_A_GPC_WQL_FILTER                      ;
extern const GUID GUID_A_GROUP_ATTRIBUTES                    ;
extern const GUID GUID_A_GROUP_MEMBERSHIP_SAM                ;
extern const GUID GUID_A_GROUP_PRIORITY                      ;
extern const GUID GUID_A_GROUP_TYPE                          ;
extern const GUID GUID_A_GROUPS_TO_IGNORE                    ;
extern const GUID GUID_A_HAS_MASTER_NCS                      ;
extern const GUID GUID_A_HAS_PARTIAL_REPLICA_NCS             ;
extern const GUID GUID_A_HELP_DATA16                         ;
extern const GUID GUID_A_HELP_DATA32                         ;
extern const GUID GUID_A_HELP_FILE_NAME                      ;
extern const GUID GUID_A_HIDE_FROM_AB                        ;
extern const GUID GUID_A_HOME_DIRECTORY                      ;
extern const GUID GUID_A_HOME_DRIVE                          ;
extern const GUID GUID_A_HOUSEIDENTIFIER                     ;
extern const GUID GUID_A_HOST                                ;
extern const GUID GUID_A_ICON_PATH                           ;
extern const GUID GUID_A_IMPLEMENTED_CATEGORIES              ;
extern const GUID GUID_A_INDEXEDSCOPES                       ;
extern const GUID GUID_A_INITIAL_AUTH_INCOMING               ;
extern const GUID GUID_A_INITIAL_AUTH_OUTGOING               ;
extern const GUID GUID_A_INITIALS                            ;
extern const GUID GUID_A_INSTALL_UI_LEVEL                    ;
extern const GUID GUID_A_INSTANCE_TYPE                       ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_FAILOVER        ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_GENERATOR       ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_RENEW           ;
extern const GUID GUID_A_INTERNATIONAL_ISDN_NUMBER           ;
extern const GUID GUID_A_INVOCATION_ID                       ;
extern const GUID GUID_A_IPSEC_DATA                          ;
extern const GUID GUID_A_IPSEC_DATA_TYPE                     ;
extern const GUID GUID_A_IPSEC_FILTER_REFERENCE              ;
extern const GUID GUID_A_IPSEC_ID                            ;
extern const GUID GUID_A_IPSEC_ISAKMP_REFERENCE              ;
extern const GUID GUID_A_IPSEC_NAME                          ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_ACTION      ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_REFERENCE      ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_TYPE       ;
extern const GUID GUID_A_IPSEC_NFA_REFERENCE                 ;
extern const GUID GUID_A_IPSEC_OWNERS_REFERENCE              ;
extern const GUID GUID_A_IPSEC_POLICY_REFERENCE              ;
extern const GUID GUID_A_IS_CRITICAL_SYSTEM_OBJECT           ;
extern const GUID GUID_A_IS_DEFUNCT                          ;
extern const GUID GUID_A_IS_DELETED                          ;
extern const GUID GUID_A_IS_EPHEMERAL                        ;
extern const GUID GUID_A_IS_MEMBER_OF_DL                     ;
extern const GUID GUID_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET      ;
extern const GUID GUID_A_IS_PRIVILEGE_HOLDER                 ;
extern const GUID GUID_A_IS_SINGLE_VALUED                    ;
extern const GUID GUID_A_JPEGPHOTO                           ;
extern const GUID GUID_A_KEYWORDS                            ;
extern const GUID GUID_A_KNOWLEDGE_INFORMATION               ;
extern const GUID GUID_A_LABELEDURI                          ;
extern const GUID GUID_A_LAST_BACKUP_RESTORATION_TIME        ;
extern const GUID GUID_A_LAST_CONTENT_INDEXED                ;
extern const GUID GUID_A_LAST_KNOWN_PARENT                   ;
extern const GUID GUID_A_LAST_LOGOFF                         ;
extern const GUID GUID_A_LAST_LOGON                          ;
extern const GUID GUID_A_LAST_LOGON_TIMESTAMP                ;
extern const GUID GUID_A_LAST_SET_TIME                       ;
extern const GUID GUID_A_LAST_UPDATE_SEQUENCE                ;
extern const GUID GUID_A_LDAP_ADMIN_LIMITS                   ;
extern const GUID GUID_A_LDAP_DISPLAY_NAME                   ;
extern const GUID GUID_A_LDAP_IPDENY_LIST                    ;
extern const GUID GUID_A_LEGACY_EXCHANGE_DN                  ;
extern const GUID GUID_A_LINK_ID                             ;
extern const GUID GUID_A_LINK_TRACK_SECRET                   ;
extern const GUID GUID_A_LM_PWD_HISTORY                      ;
extern const GUID GUID_A_LOCAL_POLICY_FLAGS                  ;
extern const GUID GUID_A_LOCAL_POLICY_REFERENCE              ;
extern const GUID GUID_A_LOCALE_ID                           ;
extern const GUID GUID_A_LOCALITY_NAME                       ;
extern const GUID GUID_A_LOCALIZED_DESCRIPTION               ;
extern const GUID GUID_A_LOCALIZATION_DISPLAY_ID             ;
extern const GUID GUID_A_LOCATION                            ;
extern const GUID GUID_A_LOCK_OUT_OBSERVATION_WINDOW         ;
extern const GUID GUID_A_LOCKOUT_DURATION                    ;
extern const GUID GUID_A_LOCKOUT_THRESHOLD                   ;
extern const GUID GUID_A_LOCKOUT_TIME                        ;
extern const GUID GUID_A_LOGO                                ;
extern const GUID GUID_A_LOGON_COUNT                         ;
extern const GUID GUID_A_LOGON_HOURS                         ;
extern const GUID GUID_A_LOGON_WORKSTATION                   ;
extern const GUID GUID_A_LSA_CREATION_TIME                   ;
extern const GUID GUID_A_LSA_MODIFIED_COUNT                  ;
extern const GUID GUID_A_MACHINE_ARCHITECTURE                ;
extern const GUID GUID_A_MACHINE_PASSWORD_CHANGE_INTERVAL      ;
extern const GUID GUID_A_MACHINE_ROLE                        ;
extern const GUID GUID_A_MACHINE_WIDE_POLICY                 ;
extern const GUID GUID_A_MANAGED_BY                          ;
extern const GUID GUID_A_MANAGED_OBJECTS                     ;
extern const GUID GUID_A_MANAGER                             ;
extern const GUID GUID_A_MAPI_ID                             ;
extern const GUID GUID_A_MARSHALLED_INTERFACE                ;
extern const GUID GUID_A_MASTERED_BY                         ;
extern const GUID GUID_A_MAX_PWD_AGE                         ;
extern const GUID GUID_A_MAX_RENEW_AGE                       ;
extern const GUID GUID_A_MAX_STORAGE                         ;
extern const GUID GUID_A_MAX_TICKET_AGE                      ;
extern const GUID GUID_A_MAY_CONTAIN                         ;
extern const GUID GUID_A_MEETINGADVERTISESCOPE               ;
extern const GUID GUID_A_MEETINGAPPLICATION                  ;
extern const GUID GUID_A_MEETINGBANDWIDTH                    ;
extern const GUID GUID_A_MEETINGBLOB                         ;
extern const GUID GUID_A_MEETINGCONTACTINFO                  ;
extern const GUID GUID_A_MEETINGDESCRIPTION                  ;
extern const GUID GUID_A_MEETINGENDTIME                      ;
extern const GUID GUID_A_MEETINGID                           ;
extern const GUID GUID_A_MEETINGIP                           ;
extern const GUID GUID_A_MEETINGISENCRYPTED                  ;
extern const GUID GUID_A_MEETINGKEYWORD                      ;
extern const GUID GUID_A_MEETINGLANGUAGE                     ;
extern const GUID GUID_A_MEETINGLOCATION                     ;
extern const GUID GUID_A_MEETINGMAXPARTICIPANTS              ;
extern const GUID GUID_A_MEETINGNAME                         ;
extern const GUID GUID_A_MEETINGORIGINATOR                   ;
extern const GUID GUID_A_MEETINGOWNER                        ;
extern const GUID GUID_A_MEETINGPROTOCOL                     ;
extern const GUID GUID_A_MEETINGRATING                       ;
extern const GUID GUID_A_MEETINGRECURRENCE                   ;
extern const GUID GUID_A_MEETINGSCOPE                        ;
extern const GUID GUID_A_MEETINGSTARTTIME                    ;
extern const GUID GUID_A_MEETINGTYPE                         ;
extern const GUID GUID_A_MEETINGURL                          ;
extern const GUID GUID_A_MEMBER                              ;
extern const GUID GUID_A_MHS_OR_ADDRESS                      ;
extern const GUID GUID_A_MIN_PWD_AGE                         ;
extern const GUID GUID_A_MIN_PWD_LENGTH                      ;
extern const GUID GUID_A_MIN_TICKET_AGE                      ;
extern const GUID GUID_A_MODIFIED_COUNT                      ;
extern const GUID GUID_A_MODIFIED_COUNT_AT_LAST_PROM         ;
extern const GUID GUID_A_MODIFY_TIME_STAMP                   ;
extern const GUID GUID_A_MONIKER                             ;
extern const GUID GUID_A_MONIKER_DISPLAY_NAME                ;
extern const GUID GUID_A_MOVE_TREE_STATE                     ;
extern const GUID GUID_A_MS_COM_DEFAULTPARTITIONLINK         ;
extern const GUID GUID_A_MS_COM_OBJECTID                     ;
extern const GUID GUID_A_MS_COM_PARTITIONLINK                ;
extern const GUID GUID_A_MS_COM_PARTITIONSETLINK             ;
extern const GUID GUID_A_MS_COM_USERLINK                     ;
extern const GUID GUID_A_MS_COM_USERPARTITIONSETLINK         ;
extern const GUID GUID_A_MS_DRM_IDENTITY_CERTIFICATE         ;
extern const GUID GUID_A_MS_DS_ADDITIONAL_DNS_HOST_NAME      ;
extern const GUID GUID_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME      ;
extern const GUID GUID_A_MS_DS_ALL_USERS_TRUST_QUOTA         ;
extern const GUID GUID_A_MS_DS_ALLOWED_DNS_SUFFIXES          ;
extern const GUID GUID_A_MS_DS_ALLOWED_TO_DELEGATE_TO        ;
extern const GUID GUID_A_MS_DS_AUXILIARY_CLASSES             ;
extern const GUID GUID_A_MS_DS_APPROX_IMMED_SUBORDINATES      ;
extern const GUID GUID_A_MS_DS_AZ_APPLICATION_DATA           ;
extern const GUID GUID_A_MS_DS_AZ_APPLICATION_NAME           ;
extern const GUID GUID_A_MS_DS_AZ_APPLICATION_VERSION        ;
extern const GUID GUID_A_MS_DS_AZ_BIZ_RULE                   ;
extern const GUID GUID_A_MS_DS_AZ_BIZ_RULE_LANGUAGE          ;
extern const GUID GUID_A_MS_DS_AZ_CLASS_ID                   ;
extern const GUID GUID_A_MS_DS_AZ_DOMAIN_TIMEOUT             ;
extern const GUID GUID_A_MS_DS_AZ_GENERATE_AUDITS            ;
extern const GUID GUID_A_MS_DS_AZ_LAST_IMPORTED_BIZ_RULE_PATH      ;
extern const GUID GUID_A_MS_DS_AZ_LDAP_QUERY                 ;
extern const GUID GUID_A_MS_DS_AZ_MAJOR_VERSION              ;
extern const GUID GUID_A_MS_DS_AZ_MINOR_VERSION              ;
extern const GUID GUID_A_MS_DS_AZ_OPERATION_ID               ;
extern const GUID GUID_A_MS_DS_AZ_SCOPE_NAME                 ;
extern const GUID GUID_A_MS_DS_AZ_SCRIPT_ENGINE_CACHE_MAX      ;
extern const GUID GUID_A_MS_DS_AZ_SCRIPT_TIMEOUT             ;
extern const GUID GUID_A_MS_DS_AZ_TASK_IS_ROLE_DEFINITION      ;
extern const GUID GUID_A_MS_DS_BEHAVIOR_VERSION              ;
extern const GUID GUID_A_MS_DS_BYTE_ARRAY                    ;
extern const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP             ;
extern const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP      ;
extern const GUID GUID_A_MS_DS_CONSISTENCY_GUID              ;
extern const GUID GUID_A_MS_DS_CONSISTENCY_CHILD_COUNT       ;
extern const GUID GUID_A_MS_DS_CREATOR_SID                   ;
extern const GUID GUID_A_MS_DS_DATE_TIME                     ;
extern const GUID GUID_A_MS_DS_DEFAULT_QUOTA                 ;
extern const GUID GUID_A_MS_DS_DNSROOTALIAS                  ;
extern const GUID GUID_A_MS_DS_ENTRY_TIME_TO_DIE             ;
extern const GUID GUID_A_MS_DS_EXECUTESCRIPTPASSWORD         ;
extern const GUID GUID_A_MS_DS_EXTERNAL_KEY                  ;
extern const GUID GUID_A_MS_DS_EXTERNAL_STORE                ;
extern const GUID GUID_A_MS_DS_FILTER_CONTAINERS             ;
extern const GUID GUID_A_MS_DS_HAS_INSTANTIATED_NCS          ;
extern const GUID GUID_A_MS_DS_HAS_DOMAIN_NCS                ;
extern const GUID GUID_A_MS_DS_HAS_MASTER_NCS                ;
extern const GUID GUID_A_MS_DS_INTEGER                       ;
extern const GUID GUID_A_MS_DS_INTID                         ;
extern const GUID GUID_A_MS_DS_KEYVERSIONNUMBER              ;
extern const GUID GUID_A_MS_DS_LOGON_TIME_SYNC_INTERVAL      ;
extern const GUID GUID_A_MS_DS_MASTERED_BY                   ;
extern const GUID GUID_A_MS_DS_MAX_VALUES                    ;
extern const GUID GUID_A_MS_DS_MEMBERS_FOR_AZ_ROLE           ;
extern const GUID GUID_A_MS_DS_MEMBERS_FOR_AZ_ROLE_BL        ;
extern const GUID GUID_A_MS_DS_NON_MEMBERS                   ;
extern const GUID GUID_A_MS_DS_NON_MEMBERS_BL                ;
extern const GUID GUID_A_MS_DS_TRUST_FOREST_TRUST_INFO       ;
extern const GUID GUID_A_MS_DS_TOMBSTONE_QUOTA_FACTOR        ;
extern const GUID GUID_A_MS_DS_TOP_QUOTA_USAGE               ;
extern const GUID GUID_A_MS_DS_MACHINE_ACCOUNT_QUOTA         ;
extern const GUID GUID_A_MS_DS_OBJECT_REFERENCE              ;
extern const GUID GUID_A_MS_DS_OBJECT_REFERENCE_BL           ;
extern const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_ROLE        ;
extern const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_ROLE_BL      ;
extern const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_TASK        ;
extern const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_TASK_BL      ;
extern const GUID GUID_A_MS_DS_OTHER_SETTINGS                ;
extern const GUID GUID_A_MS_DS_QUOTA_AMOUNT                  ;
extern const GUID GUID_A_MS_DS_QUOTA_EFFECTIVE               ;
extern const GUID GUID_A_MS_DS_QUOTA_TRUSTEE                 ;
extern const GUID GUID_A_MS_DS_QUOTA_USED                    ;
extern const GUID GUID_A_MS_DS_NC_REPL_CURSORS               ;
extern const GUID GUID_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS      ;
extern const GUID GUID_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS      ;
extern const GUID GUID_A_MS_DS_NC_REPLICA_LOCATIONS          ;
extern const GUID GUID_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES      ;
extern const GUID GUID_A_MS_DS_PER_USER_TRUST_QUOTA          ;
extern const GUID GUID_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA      ;
extern const GUID GUID_A_MS_DS_PREFERRED_GC_SITE             ;
extern const GUID GUID_A_MS_DS_REPL_ATTRIBUTE_META_DATA      ;
extern const GUID GUID_A_MS_DS_REPL_VALUE_META_DATA          ;
extern const GUID GUID_A_MS_DS_REPLICATES_NC_REASON          ;
extern const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY      ;
extern const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY      ;
extern const GUID GUID_A_MS_DS_REPLICATIONEPOCH              ;
extern const GUID GUID_A_MS_DS_RETIRED_REPL_NC_SIGNATURES      ;
extern const GUID GUID_A_MS_DS_SCHEMA_EXTENSIONS             ;
extern const GUID GUID_A_MS_DS_SD_REFERENCE_DOMAIN           ;
extern const GUID GUID_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES      ;
extern const GUID GUID_A_MS_DS_SETTINGS                      ;
extern const GUID GUID_A_MS_DS_SITE_AFFINITY                 ;
extern const GUID GUID_A_MS_DS_SPN_SUFFIXES                  ;
extern const GUID GUID_A_MS_DS_TASKS_FOR_AZ_ROLE             ;
extern const GUID GUID_A_MS_DS_TASKS_FOR_AZ_ROLE_BL          ;
extern const GUID GUID_A_MS_DS_TASKS_FOR_AZ_TASK             ;
extern const GUID GUID_A_MS_DS_TASKS_FOR_AZ_TASK_BL          ;
extern const GUID GUID_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      ;
extern const GUID GUID_A_MS_DS_UPDATESCRIPT                  ;
extern const GUID GUID_A_MS_EXCH_ASSISTANT_NAME              ;
extern const GUID GUID_A_MS_EXCH_HOUSE_IDENTIFIER            ;
extern const GUID GUID_A_MS_EXCH_LABELEDURI                  ;
extern const GUID GUID_A_MS_EXCH_OWNER_BL                    ;
extern const GUID GUID_A_MS_FRS_HUB_MEMBER                   ;
extern const GUID GUID_A_MS_FRS_TOPOLOGY_PREF                ;
extern const GUID GUID_A_MS_IEEE_80211_DATA                  ;
extern const GUID GUID_A_MS_IEEE_80211_DATA_TYPE             ;
extern const GUID GUID_A_MS_IEEE_80211_ID                    ;
extern const GUID GUID_A_MS_IIS_FTP_DIR                      ;
extern const GUID GUID_A_MS_IIS_FTP_ROOT                     ;
extern const GUID GUID_A_MS_PKI_CERT_TEMPLATE_OID            ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY      ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_NAME_FLAG        ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_POLICY           ;
extern const GUID GUID_A_MS_PKI_ENROLLMENT_FLAG              ;
extern const GUID GUID_A_MS_PKI_MINIMAL_KEY_SIZE             ;
extern const GUID GUID_A_MS_PKI_OID_ATTRIBUTE                ;
extern const GUID GUID_A_MS_PKI_OID_CPS                      ;
extern const GUID GUID_A_MS_PKI_OID_LOCALIZEDNAME            ;
extern const GUID GUID_A_MS_PKI_OID_USER_NOTICE              ;
extern const GUID GUID_A_MS_PKI_PRIVATE_KEY_FLAG             ;
extern const GUID GUID_A_MS_PKI_SUPERSEDE_TEMPLATES          ;
extern const GUID GUID_A_MS_PKI_TEMPLATE_MINOR_REVISION      ;
extern const GUID GUID_A_MS_PKI_TEMPLATE_SCHEMA_VERSION      ;
extern const GUID GUID_A_MS_PKI_RA_APPLICATION_POLICIES      ;
extern const GUID GUID_A_MS_PKI_RA_POLICIES                  ;
extern const GUID GUID_A_MS_PKI_RA_SIGNATURE                 ;
extern const GUID GUID_A_MS_RRAS_ATTRIBUTE                   ;
extern const GUID GUID_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY      ;
extern const GUID GUID_A_MS_SQL_NAME                         ;
extern const GUID GUID_A_MS_SQL_REGISTEREDOWNER              ;
extern const GUID GUID_A_MS_SQL_CONTACT                      ;
extern const GUID GUID_A_MS_SQL_LOCATION                     ;
extern const GUID GUID_A_MS_SQL_MEMORY                       ;
extern const GUID GUID_A_MS_SQL_BUILD                        ;
extern const GUID GUID_A_MS_SQL_SERVICEACCOUNT               ;
extern const GUID GUID_A_MS_SQL_CHARACTERSET                 ;
extern const GUID GUID_A_MS_SQL_SORTORDER                    ;
extern const GUID GUID_A_MS_SQL_UNICODESORTORDER             ;
extern const GUID GUID_A_MS_SQL_CLUSTERED                    ;
extern const GUID GUID_A_MS_SQL_NAMEDPIPE                    ;
extern const GUID GUID_A_MS_SQL_MULTIPROTOCOL                ;
extern const GUID GUID_A_MS_SQL_SPX                          ;
extern const GUID GUID_A_MS_SQL_TCPIP                        ;
extern const GUID GUID_A_MS_SQL_APPLETALK                    ;
extern const GUID GUID_A_MS_SQL_VINES                        ;
extern const GUID GUID_A_MS_SQL_STATUS                       ;
extern const GUID GUID_A_MS_SQL_LASTUPDATEDDATE              ;
extern const GUID GUID_A_MS_SQL_INFORMATIONURL               ;
extern const GUID GUID_A_MS_SQL_CONNECTIONURL                ;
extern const GUID GUID_A_MS_SQL_PUBLICATIONURL               ;
extern const GUID GUID_A_MS_SQL_GPSLATITUDE                  ;
extern const GUID GUID_A_MS_SQL_GPSLONGITUDE                 ;
extern const GUID GUID_A_MS_SQL_GPSHEIGHT                    ;
extern const GUID GUID_A_MS_SQL_VERSION                      ;
extern const GUID GUID_A_MS_SQL_LANGUAGE                     ;
extern const GUID GUID_A_MS_SQL_DESCRIPTION                  ;
extern const GUID GUID_A_MS_SQL_TYPE                         ;
extern const GUID GUID_A_MS_SQL_INFORMATIONDIRECTORY         ;
extern const GUID GUID_A_MS_SQL_DATABASE                     ;
extern const GUID GUID_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALIAS                        ;
extern const GUID GUID_A_MS_SQL_SIZE                         ;
extern const GUID GUID_A_MS_SQL_CREATIONDATE                 ;
extern const GUID GUID_A_MS_SQL_LASTBACKUPDATE               ;
extern const GUID GUID_A_MS_SQL_LASTDIAGNOSTICDATE           ;
extern const GUID GUID_A_MS_SQL_APPLICATIONS                 ;
extern const GUID GUID_A_MS_SQL_KEYWORDS                     ;
extern const GUID GUID_A_MS_SQL_PUBLISHER                    ;
extern const GUID GUID_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING      ;
extern const GUID GUID_A_MS_SQL_THIRDPARTY                   ;
extern const GUID GUID_A_MS_TAPI_CONFERENCE_BLOB             ;
extern const GUID GUID_A_MS_TAPI_IP_ADDRESS                  ;
extern const GUID GUID_A_MS_TAPI_PROTOCOL_ID                 ;
extern const GUID GUID_A_MS_TAPI_UNIQUE_IDENTIFIER           ;
extern const GUID GUID_A_MS_WMI_AUTHOR                       ;
extern const GUID GUID_A_MS_WMI_CHANGEDATE                   ;
extern const GUID GUID_A_MS_WMI_CLASS                        ;
extern const GUID GUID_A_MS_WMI_CLASSDEFINITION              ;
extern const GUID GUID_A_MS_WMI_CREATIONDATE                 ;
extern const GUID GUID_A_MS_WMI_GENUS                        ;
extern const GUID GUID_A_MS_WMI_ID                           ;
extern const GUID GUID_A_MS_WMI_INTDEFAULT                   ;
extern const GUID GUID_A_MS_WMI_INTFLAGS1                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS2                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS3                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS4                    ;
extern const GUID GUID_A_MS_WMI_INTMAX                       ;
extern const GUID GUID_A_MS_WMI_INTMIN                       ;
extern const GUID GUID_A_MS_WMI_INTVALIDVALUES               ;
extern const GUID GUID_A_MS_WMI_INT8DEFAULT                  ;
extern const GUID GUID_A_MS_WMI_INT8MAX                      ;
extern const GUID GUID_A_MS_WMI_INT8MIN                      ;
extern const GUID GUID_A_MS_WMI_INT8VALIDVALUES              ;
extern const GUID GUID_A_MS_WMI_MOF                          ;
extern const GUID GUID_A_MS_WMI_NAME                         ;
extern const GUID GUID_A_MS_WMI_NORMALIZEDCLASS              ;
extern const GUID GUID_A_MS_WMI_PARM1                        ;
extern const GUID GUID_A_MS_WMI_PARM2                        ;
extern const GUID GUID_A_MS_WMI_PARM3                        ;
extern const GUID GUID_A_MS_WMI_PARM4                        ;
extern const GUID GUID_A_MS_WMI_PROPERTYNAME                 ;
extern const GUID GUID_A_MS_WMI_QUERY                        ;
extern const GUID GUID_A_MS_WMI_QUERYLANGUAGE                ;
extern const GUID GUID_A_MS_WMI_SCOPEGUID                    ;
extern const GUID GUID_A_MS_WMI_SOURCEORGANIZATION           ;
extern const GUID GUID_A_MS_WMI_STRINGDEFAULT                ;
extern const GUID GUID_A_MS_WMI_STRINGVALIDVALUES            ;
extern const GUID GUID_A_MS_WMI_TARGETCLASS                  ;
extern const GUID GUID_A_MS_WMI_TARGETNAMESPACE              ;
extern const GUID GUID_A_MS_WMI_TARGETOBJECT                 ;
extern const GUID GUID_A_MS_WMI_TARGETPATH                   ;
extern const GUID GUID_A_MS_WMI_TARGETTYPE                   ;
extern const GUID GUID_A_MSCOPE_ID                           ;
extern const GUID GUID_A_MSI_FILE_LIST                       ;
extern const GUID GUID_A_MSI_SCRIPT                          ;
extern const GUID GUID_A_MSI_SCRIPT_NAME                     ;
extern const GUID GUID_A_MSI_SCRIPT_PATH                     ;
extern const GUID GUID_A_MSI_SCRIPT_SIZE                     ;
extern const GUID GUID_A_MSMQ_AUTHENTICATE                   ;
extern const GUID GUID_A_MSMQ_BASE_PRIORITY                  ;
extern const GUID GUID_A_MSMQ_COMPUTER_TYPE                  ;
extern const GUID GUID_A_MSMQ_COMPUTER_TYPE_EX               ;
extern const GUID GUID_A_MSMQ_COST                           ;
extern const GUID GUID_A_MSMQ_CSP_NAME                       ;
extern const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICE       ;
extern const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICES      ;
extern const GUID GUID_A_MSMQ_DIGESTS                        ;
extern const GUID GUID_A_MSMQ_DIGESTS_MIG                    ;
extern const GUID GUID_A_MSMQ_DS_SERVICE                     ;
extern const GUID GUID_A_MSMQ_DS_SERVICES                    ;
extern const GUID GUID_A_MSMQ_ENCRYPT_KEY                    ;
extern const GUID GUID_A_MSMQ_FOREIGN                        ;
extern const GUID GUID_A_MSMQ_IN_ROUTING_SERVERS             ;
extern const GUID GUID_A_MSMQ_INTERVAL1                      ;
extern const GUID GUID_A_MSMQ_INTERVAL2                      ;
extern const GUID GUID_A_MSMQ_JOURNAL                        ;
extern const GUID GUID_A_MSMQ_JOURNAL_QUOTA                  ;
extern const GUID GUID_A_MSMQ_LABEL                          ;
extern const GUID GUID_A_MSMQ_LABEL_EX                       ;
extern const GUID GUID_A_MSMQ_LONG_LIVED                     ;
extern const GUID GUID_A_MSMQ_MIGRATED                       ;
extern const GUID GUID_A_MSMQ_MULTICAST_ADDRESS              ;
extern const GUID GUID_A_MSMQ_NAME_STYLE                     ;
extern const GUID GUID_A_MSMQ_NT4_FLAGS                      ;
extern const GUID GUID_A_MSMQ_NT4_STUB                       ;
extern const GUID GUID_A_MSMQ_OS_TYPE                        ;
extern const GUID GUID_A_MSMQ_OUT_ROUTING_SERVERS            ;
extern const GUID GUID_A_MSMQ_OWNER_ID                       ;
extern const GUID GUID_A_MSMQ_PREV_SITE_GATES                ;
extern const GUID GUID_A_MSMQ_PRIVACY_LEVEL                  ;
extern const GUID GUID_A_MSMQ_QM_ID                          ;
extern const GUID GUID_A_MSMQ_QUEUE_JOURNAL_QUOTA            ;
extern const GUID GUID_A_MSMQ_QUEUE_NAME_EXT                 ;
extern const GUID GUID_A_MSMQ_QUEUE_QUOTA                    ;
extern const GUID GUID_A_MSMQ_QUEUE_TYPE                     ;
extern const GUID GUID_A_MSMQ_QUOTA                          ;
extern const GUID GUID_A_MSMQ_RECIPIENT_FORMATNAME           ;
extern const GUID GUID_A_MSMQ_ROUTING_SERVICE                ;
extern const GUID GUID_A_MSMQ_ROUTING_SERVICES               ;
extern const GUID GUID_A_MSMQ_SECURED_SOURCE                 ;
extern const GUID GUID_A_MSMQ_SERVICE_TYPE                   ;
extern const GUID GUID_A_MSMQ_SERVICES                       ;
extern const GUID GUID_A_MSMQ_SIGN_CERTIFICATES              ;
extern const GUID GUID_A_MSMQ_SIGN_CERTIFICATES_MIG          ;
extern const GUID GUID_A_MSMQ_SIGN_KEY                       ;
extern const GUID GUID_A_MSMQ_SITE_1                         ;
extern const GUID GUID_A_MSMQ_SITE_2                         ;
extern const GUID GUID_A_MSMQ_SITE_FOREIGN                   ;
extern const GUID GUID_A_MSMQ_SITE_GATES                     ;
extern const GUID GUID_A_MSMQ_SITE_GATES_MIG                 ;
extern const GUID GUID_A_MSMQ_SITE_ID                        ;
extern const GUID GUID_A_MSMQ_SITE_NAME                      ;
extern const GUID GUID_A_MSMQ_SITE_NAME_EX                   ;
extern const GUID GUID_A_MSMQ_SITES                          ;
extern const GUID GUID_A_MSMQ_TRANSACTIONAL                  ;
extern const GUID GUID_A_MSMQ_USER_SID                       ;
extern const GUID GUID_A_MSMQ_VERSION                        ;
extern const GUID GUID_A_MSNPALLOWDIALIN                     ;
extern const GUID GUID_A_MSNPCALLEDSTATIONID                 ;
extern const GUID GUID_A_MSNPCALLINGSTATIONID                ;
extern const GUID GUID_A_MSNPSAVEDCALLINGSTATIONID           ;
extern const GUID GUID_A_MSRADIUSCALLBACKNUMBER              ;
extern const GUID GUID_A_MSRADIUSFRAMEDIPADDRESS             ;
extern const GUID GUID_A_MSRADIUSFRAMEDROUTE                 ;
extern const GUID GUID_A_MSRADIUSSERVICETYPE                 ;
extern const GUID GUID_A_MSRASSAVEDCALLBACKNUMBER            ;
extern const GUID GUID_A_MSRASSAVEDFRAMEDIPADDRESS           ;
extern const GUID GUID_A_MSRASSAVEDFRAMEDROUTE               ;
extern const GUID GUID_A_MUST_CONTAIN                        ;
extern const GUID GUID_A_NAME_SERVICE_FLAGS                  ;
extern const GUID GUID_A_NC_NAME                             ;
extern const GUID GUID_A_NETBIOS_NAME                        ;
extern const GUID GUID_A_NETBOOT_ALLOW_NEW_CLIENTS           ;
extern const GUID GUID_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS      ;
extern const GUID GUID_A_NETBOOT_ANSWER_REQUESTS             ;
extern const GUID GUID_A_NETBOOT_CURRENT_CLIENT_COUNT        ;
extern const GUID GUID_A_NETBOOT_GUID                        ;
extern const GUID GUID_A_NETBOOT_INITIALIZATION              ;
extern const GUID GUID_A_NETBOOT_INTELLIMIRROR_OSES          ;
extern const GUID GUID_A_NETBOOT_LIMIT_CLIENTS               ;
extern const GUID GUID_A_NETBOOT_LOCALLY_INSTALLED_OSES      ;
extern const GUID GUID_A_NETBOOT_MACHINE_FILE_PATH           ;
extern const GUID GUID_A_NETBOOT_MAX_CLIENTS                 ;
extern const GUID GUID_A_NETBOOT_MIRROR_DATA_FILE            ;
extern const GUID GUID_A_NETBOOT_NEW_MACHINE_NAMING_POLICY      ;
extern const GUID GUID_A_NETBOOT_NEW_MACHINE_OU              ;
extern const GUID GUID_A_NETBOOT_SCP_BL                      ;
extern const GUID GUID_A_NETBOOT_SERVER                      ;
extern const GUID GUID_A_NETBOOT_SIF_FILE                    ;
extern const GUID GUID_A_NETBOOT_TOOLS                       ;
extern const GUID GUID_A_NETWORK_ADDRESS                     ;
extern const GUID GUID_A_NEXT_LEVEL_STORE                    ;
extern const GUID GUID_A_NEXT_RID                            ;
extern const GUID GUID_A_NON_SECURITY_MEMBER                 ;
extern const GUID GUID_A_NON_SECURITY_MEMBER_BL              ;
extern const GUID GUID_A_NOTIFICATION_LIST                   ;
extern const GUID GUID_A_NT_GROUP_MEMBERS                    ;
extern const GUID GUID_A_NT_MIXED_DOMAIN                     ;
extern const GUID GUID_A_NT_PWD_HISTORY                      ;
extern const GUID GUID_A_NT_SECURITY_DESCRIPTOR              ;
extern const GUID GUID_A_OBJ_DIST_NAME                       ;
extern const GUID GUID_A_OBJECT_CATEGORY                     ;
extern const GUID GUID_A_OBJECT_CLASS                        ;
extern const GUID GUID_A_OBJECT_CLASS_CATEGORY               ;
extern const GUID GUID_A_OBJECT_CLASSES                      ;
extern const GUID GUID_A_OBJECT_COUNT                        ;
extern const GUID GUID_A_OBJECT_GUID                         ;
extern const GUID GUID_A_OBJECT_SID                          ;
extern const GUID GUID_A_OBJECT_VERSION                      ;
extern const GUID GUID_A_OEM_INFORMATION                     ;
extern const GUID GUID_A_OM_OBJECT_CLASS                     ;
extern const GUID GUID_A_OM_SYNTAX                           ;
extern const GUID GUID_A_OMT_GUID                            ;
extern const GUID GUID_A_OMT_INDX_GUID                       ;
extern const GUID GUID_A_OPERATING_SYSTEM                    ;
extern const GUID GUID_A_OPERATING_SYSTEM_HOTFIX             ;
extern const GUID GUID_A_OPERATING_SYSTEM_SERVICE_PACK       ;
extern const GUID GUID_A_OPERATING_SYSTEM_VERSION            ;
extern const GUID GUID_A_OPERATOR_COUNT                      ;
extern const GUID GUID_A_OPTION_DESCRIPTION                  ;
extern const GUID GUID_A_OPTIONS                             ;
extern const GUID GUID_A_OPTIONS_LOCATION                    ;
extern const GUID GUID_A_ORGANIZATION_NAME                   ;
extern const GUID GUID_A_ORGANIZATIONAL_UNIT_NAME            ;
extern const GUID GUID_A_ORGANIZATIONALSTATUS                ;
extern const GUID GUID_A_ORIGINAL_DISPLAY_TABLE              ;
extern const GUID GUID_A_ORIGINAL_DISPLAY_TABLE_MSDOS        ;
extern const GUID GUID_A_OTHER_LOGIN_WORKSTATIONS            ;
extern const GUID GUID_A_OTHER_MAILBOX                       ;
extern const GUID GUID_A_OTHER_NAME                          ;
extern const GUID GUID_A_OTHER_WELL_KNOWN_OBJECTS            ;
extern const GUID GUID_A_OWNER                               ;
extern const GUID GUID_A_PACKAGE_FLAGS                       ;
extern const GUID GUID_A_PACKAGE_NAME                        ;
extern const GUID GUID_A_PACKAGE_TYPE                        ;
extern const GUID GUID_A_PARENT_CA                           ;
extern const GUID GUID_A_PARENT_CA_CERTIFICATE_CHAIN         ;
extern const GUID GUID_A_PARENT_GUID                         ;
extern const GUID GUID_A_PARTIAL_ATTRIBUTE_DELETION_LIST      ;
extern const GUID GUID_A_PARTIAL_ATTRIBUTE_SET               ;
extern const GUID GUID_A_PEK_KEY_CHANGE_INTERVAL             ;
extern const GUID GUID_A_PEK_LIST                            ;
extern const GUID GUID_A_PENDING_CA_CERTIFICATES             ;
extern const GUID GUID_A_PENDING_PARENT_CA                   ;
extern const GUID GUID_A_PER_MSG_DIALOG_DISPLAY_TABLE        ;
extern const GUID GUID_A_PER_RECIP_DIALOG_DISPLAY_TABLE      ;
extern const GUID GUID_A_PERSONAL_TITLE                      ;
extern const GUID GUID_A_PHONE_FAX_OTHER                     ;
extern const GUID GUID_A_PHONE_HOME_OTHER                    ;
extern const GUID GUID_A_PHONE_HOME_PRIMARY                  ;
extern const GUID GUID_A_PHONE_IP_OTHER                      ;
extern const GUID GUID_A_PHONE_IP_PRIMARY                    ;
extern const GUID GUID_A_PHONE_ISDN_PRIMARY                  ;
extern const GUID GUID_A_PHONE_MOBILE_OTHER                  ;
extern const GUID GUID_A_PHONE_MOBILE_PRIMARY                ;
extern const GUID GUID_A_PHONE_OFFICE_OTHER                  ;
extern const GUID GUID_A_PHONE_PAGER_OTHER                   ;
extern const GUID GUID_A_PHONE_PAGER_PRIMARY                 ;
extern const GUID GUID_A_PHOTO                               ;
extern const GUID GUID_A_PHYSICAL_DELIVERY_OFFICE_NAME       ;
extern const GUID GUID_A_PHYSICAL_LOCATION_OBJECT            ;
extern const GUID GUID_A_PICTURE                             ;
extern const GUID GUID_A_PKI_CRITICAL_EXTENSIONS             ;
extern const GUID GUID_A_PKI_DEFAULT_CSPS                    ;
extern const GUID GUID_A_PKI_DEFAULT_KEY_SPEC                ;
extern const GUID GUID_A_PKI_ENROLLMENT_ACCESS               ;
extern const GUID GUID_A_PKI_EXPIRATION_PERIOD               ;
extern const GUID GUID_A_PKI_EXTENDED_KEY_USAGE              ;
extern const GUID GUID_A_PKI_KEY_USAGE                       ;
extern const GUID GUID_A_PKI_MAX_ISSUING_DEPTH               ;
extern const GUID GUID_A_PKI_OVERLAP_PERIOD                  ;
extern const GUID GUID_A_PKT                                 ;
extern const GUID GUID_A_PKT_GUID                            ;
extern const GUID GUID_A_POLICY_REPLICATION_FLAGS            ;
extern const GUID GUID_A_PORT_NAME                           ;
extern const GUID GUID_A_POSS_SUPERIORS                      ;
extern const GUID GUID_A_POSSIBLE_INFERIORS                  ;
extern const GUID GUID_A_POST_OFFICE_BOX                     ;
extern const GUID GUID_A_POSTAL_ADDRESS                      ;
extern const GUID GUID_A_POSTAL_CODE                         ;
extern const GUID GUID_A_PREFERRED_DELIVERY_METHOD           ;
extern const GUID GUID_A_PREFERREDLANGUAGE                   ;
extern const GUID GUID_A_PREFERRED_OU                        ;
extern const GUID GUID_A_PREFIX_MAP                          ;
extern const GUID GUID_A_PRESENTATION_ADDRESS                ;
extern const GUID GUID_A_PREVIOUS_CA_CERTIFICATES            ;
extern const GUID GUID_A_PREVIOUS_PARENT_CA                  ;
extern const GUID GUID_A_PRIMARY_GROUP_ID                    ;
extern const GUID GUID_A_PRIMARY_GROUP_TOKEN                 ;
extern const GUID GUID_A_PRINT_ATTRIBUTES                    ;
extern const GUID GUID_A_PRINT_BIN_NAMES                     ;
extern const GUID GUID_A_PRINT_COLLATE                       ;
extern const GUID GUID_A_PRINT_COLOR                         ;
extern const GUID GUID_A_PRINT_DUPLEX_SUPPORTED              ;
extern const GUID GUID_A_PRINT_END_TIME                      ;
extern const GUID GUID_A_PRINT_FORM_NAME                     ;
extern const GUID GUID_A_PRINT_KEEP_PRINTED_JOBS             ;
extern const GUID GUID_A_PRINT_LANGUAGE                      ;
extern const GUID GUID_A_PRINT_MAC_ADDRESS                   ;
extern const GUID GUID_A_PRINT_MAX_COPIES                    ;
extern const GUID GUID_A_PRINT_MAX_RESOLUTION_SUPPORTED      ;
extern const GUID GUID_A_PRINT_MAX_X_EXTENT                  ;
extern const GUID GUID_A_PRINT_MAX_Y_EXTENT                  ;
extern const GUID GUID_A_PRINT_MEDIA_READY                   ;
extern const GUID GUID_A_PRINT_MEDIA_SUPPORTED               ;
extern const GUID GUID_A_PRINT_MEMORY                        ;
extern const GUID GUID_A_PRINT_MIN_X_EXTENT                  ;
extern const GUID GUID_A_PRINT_MIN_Y_EXTENT                  ;
extern const GUID GUID_A_PRINT_NETWORK_ADDRESS               ;
extern const GUID GUID_A_PRINT_NOTIFY                        ;
extern const GUID GUID_A_PRINT_NUMBER_UP                     ;
extern const GUID GUID_A_PRINT_ORIENTATIONS_SUPPORTED        ;
extern const GUID GUID_A_PRINT_OWNER                         ;
extern const GUID GUID_A_PRINT_PAGES_PER_MINUTE              ;
extern const GUID GUID_A_PRINT_RATE                          ;
extern const GUID GUID_A_PRINT_RATE_UNIT                     ;
extern const GUID GUID_A_PRINT_SEPARATOR_FILE                ;
extern const GUID GUID_A_PRINT_SHARE_NAME                    ;
extern const GUID GUID_A_PRINT_SPOOLING                      ;
extern const GUID GUID_A_PRINT_STAPLING_SUPPORTED            ;
extern const GUID GUID_A_PRINT_START_TIME                    ;
extern const GUID GUID_A_PRINT_STATUS                        ;
extern const GUID GUID_A_PRINTER_NAME                        ;
extern const GUID GUID_A_PRIOR_SET_TIME                      ;
extern const GUID GUID_A_PRIOR_VALUE                         ;
extern const GUID GUID_A_PRIORITY                            ;
extern const GUID GUID_A_PRIVATE_KEY                         ;
extern const GUID GUID_A_PRIVILEGE_ATTRIBUTES                ;
extern const GUID GUID_A_PRIVILEGE_DISPLAY_NAME              ;
extern const GUID GUID_A_PRIVILEGE_HOLDER                    ;
extern const GUID GUID_A_PRIVILEGE_VALUE                     ;
extern const GUID GUID_A_PRODUCT_CODE                        ;
extern const GUID GUID_A_PROFILE_PATH                        ;
extern const GUID GUID_A_PROXIED_OBJECT_NAME                 ;
extern const GUID GUID_A_PROXY_ADDRESSES                     ;
extern const GUID GUID_A_PROXY_GENERATION_ENABLED            ;
extern const GUID GUID_A_PROXY_LIFETIME                      ;
extern const GUID GUID_A_PUBLIC_KEY_POLICY                   ;
extern const GUID GUID_A_PURPORTED_SEARCH                    ;
extern const GUID GUID_A_PWD_HISTORY_LENGTH                  ;
extern const GUID GUID_A_PWD_LAST_SET                        ;
extern const GUID GUID_A_PWD_PROPERTIES                      ;
extern const GUID GUID_A_QUALITY_OF_SERVICE                  ;
extern const GUID GUID_A_QUERY_FILTER                        ;
extern const GUID GUID_A_QUERY_POLICY_BL                     ;
extern const GUID GUID_A_QUERY_POLICY_OBJECT                 ;
extern const GUID GUID_A_QUERYPOINT                          ;
extern const GUID GUID_A_RANGE_LOWER                         ;
extern const GUID GUID_A_RANGE_UPPER                         ;
extern const GUID GUID_A_RDN                                 ;
extern const GUID GUID_A_RDN_ATT_ID                          ;
extern const GUID GUID_A_REGISTERED_ADDRESS                  ;
extern const GUID GUID_A_REMOTE_SERVER_NAME                  ;
extern const GUID GUID_A_REMOTE_SOURCE                       ;
extern const GUID GUID_A_REMOTE_SOURCE_TYPE                  ;
extern const GUID GUID_A_REMOTE_STORAGE_GUID                 ;
extern const GUID GUID_A_REPL_PROPERTY_META_DATA             ;
extern const GUID GUID_A_REPL_TOPOLOGY_STAY_OF_EXECUTION      ;
extern const GUID GUID_A_REPL_UPTODATE_VECTOR                ;
extern const GUID GUID_A_REPLICA_SOURCE                      ;
extern const GUID GUID_A_REPORTS                             ;
extern const GUID GUID_A_REPL_INTERVAL                       ;
extern const GUID GUID_A_REPS_FROM                           ;
extern const GUID GUID_A_REPS_TO                             ;
extern const GUID GUID_A_REQUIRED_CATEGORIES                 ;
extern const GUID GUID_A_RETIRED_REPL_DSA_SIGNATURES         ;
extern const GUID GUID_A_TOKEN_GROUPS                        ;
extern const GUID GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL      ;
extern const GUID GUID_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE       ;
extern const GUID GUID_A_REVISION                            ;
extern const GUID GUID_A_RID                                 ;
extern const GUID GUID_A_RID_ALLOCATION_POOL                 ;
extern const GUID GUID_A_RID_AVAILABLE_POOL                  ;
extern const GUID GUID_A_RID_MANAGER_REFERENCE               ;
extern const GUID GUID_A_RID_NEXT_RID                        ;
extern const GUID GUID_A_RID_PREVIOUS_ALLOCATION_POOL        ;
extern const GUID GUID_A_RID_SET_REFERENCES                  ;
extern const GUID GUID_A_RID_USED_POOL                       ;
extern const GUID GUID_A_RIGHTS_GUID                         ;
extern const GUID GUID_A_ROLE_OCCUPANT                       ;
extern const GUID GUID_A_ROOMNUMBER                          ;
extern const GUID GUID_A_ROOT_TRUST                          ;
extern const GUID GUID_A_RPC_NS_ANNOTATION                   ;
extern const GUID GUID_A_RPC_NS_BINDINGS                     ;
extern const GUID GUID_A_RPC_NS_CODESET                      ;
extern const GUID GUID_A_RPC_NS_ENTRY_FLAGS                  ;
extern const GUID GUID_A_RPC_NS_GROUP                        ;
extern const GUID GUID_A_RPC_NS_INTERFACE_ID                 ;
extern const GUID GUID_A_RPC_NS_OBJECT_ID                    ;
extern const GUID GUID_A_RPC_NS_PRIORITY                     ;
extern const GUID GUID_A_RPC_NS_PROFILE_ENTRY                ;
extern const GUID GUID_A_RPC_NS_TRANSFER_SYNTAX              ;
extern const GUID GUID_A_SAM_ACCOUNT_NAME                    ;
extern const GUID GUID_A_SAM_ACCOUNT_TYPE                    ;
extern const GUID GUID_A_SCHEDULE                            ;
extern const GUID GUID_A_SCHEMA_FLAGS_EX                     ;
extern const GUID GUID_A_SCHEMA_ID_GUID                      ;
extern const GUID GUID_A_SCHEMA_INFO                         ;
extern const GUID GUID_A_SCHEMA_UPDATE                       ;
extern const GUID GUID_A_SCHEMA_VERSION                      ;
extern const GUID GUID_A_SCOPE_FLAGS                         ;
extern const GUID GUID_A_SCRIPT_PATH                         ;
extern const GUID GUID_A_SD_RIGHTS_EFFECTIVE                 ;
extern const GUID GUID_A_SEARCH_FLAGS                        ;
extern const GUID GUID_A_SEARCH_GUIDE                        ;
extern const GUID GUID_A_SECRETARY                           ;
extern const GUID GUID_A_SECURITY_IDENTIFIER                 ;
extern const GUID GUID_A_SEE_ALSO                            ;
extern const GUID GUID_A_SEQ_NOTIFICATION                    ;
extern const GUID GUID_A_SERIAL_NUMBER                       ;
extern const GUID GUID_A_SERVER_NAME                         ;
extern const GUID GUID_A_SERVER_REFERENCE                    ;
extern const GUID GUID_A_SERVER_REFERENCE_BL                 ;
extern const GUID GUID_A_SERVER_ROLE                         ;
extern const GUID GUID_A_SERVER_STATE                        ;
extern const GUID GUID_A_SERVICE_BINDING_INFORMATION         ;
extern const GUID GUID_A_SERVICE_CLASS_ID                    ;
extern const GUID GUID_A_SERVICE_CLASS_INFO                  ;
extern const GUID GUID_A_SERVICE_CLASS_NAME                  ;
extern const GUID GUID_A_SERVICE_DNS_NAME                    ;
extern const GUID GUID_A_SERVICE_DNS_NAME_TYPE               ;
extern const GUID GUID_A_SERVICE_INSTANCE_VERSION            ;
extern const GUID GUID_A_SERVICE_PRINCIPAL_NAME              ;
extern const GUID GUID_A_SETUP_COMMAND                       ;
extern const GUID GUID_A_SHELL_CONTEXT_MENU                  ;
extern const GUID GUID_A_SHELL_PROPERTY_PAGES                ;
extern const GUID GUID_A_SHORT_SERVER_NAME                   ;
extern const GUID GUID_A_SHOW_IN_ADDRESS_BOOK                ;
extern const GUID GUID_A_SHOW_IN_ADVANCED_VIEW_ONLY          ;
extern const GUID GUID_A_SID_HISTORY                         ;
extern const GUID GUID_A_SIGNATURE_ALGORITHMS                ;
extern const GUID GUID_A_SITE_GUID                           ;
extern const GUID GUID_A_SITE_LINK_LIST                      ;
extern const GUID GUID_A_SITE_LIST                           ;
extern const GUID GUID_A_SITE_OBJECT                         ;
extern const GUID GUID_A_SITE_OBJECT_BL                      ;
extern const GUID GUID_A_SITE_SERVER                         ;
extern const GUID GUID_A_SMTP_MAIL_ADDRESS                   ;
extern const GUID GUID_A_SPN_MAPPINGS                        ;
extern const GUID GUID_A_STATE_OR_PROVINCE_NAME              ;
extern const GUID GUID_A_STREET_ADDRESS                      ;
extern const GUID GUID_A_STRUCTURAL_OBJECT_CLASS             ;
extern const GUID GUID_A_SUB_CLASS_OF                        ;
extern const GUID GUID_A_SUB_REFS                            ;
extern const GUID GUID_A_SUBSCHEMASUBENTRY                   ;
extern const GUID GUID_A_SUPER_SCOPE_DESCRIPTION             ;
extern const GUID GUID_A_SUPER_SCOPES                        ;
extern const GUID GUID_A_SUPERIOR_DNS_ROOT                   ;
extern const GUID GUID_A_SUPPLEMENTAL_CREDENTIALS            ;
extern const GUID GUID_A_SUPPORTED_APPLICATION_CONTEXT       ;
extern const GUID GUID_A_SURNAME                             ;
extern const GUID GUID_A_SYNC_ATTRIBUTES                     ;
extern const GUID GUID_A_SYNC_MEMBERSHIP                     ;
extern const GUID GUID_A_SYNC_WITH_OBJECT                    ;
extern const GUID GUID_A_SYNC_WITH_SID                       ;
extern const GUID GUID_A_SYSTEM_AUXILIARY_CLASS              ;
extern const GUID GUID_A_SYSTEM_FLAGS                        ;
extern const GUID GUID_A_SYSTEM_MAY_CONTAIN                  ;
extern const GUID GUID_A_SYSTEM_MUST_CONTAIN                 ;
extern const GUID GUID_A_SYSTEM_ONLY                         ;
extern const GUID GUID_A_SYSTEM_POSS_SUPERIORS               ;
extern const GUID GUID_A_TELEPHONE_NUMBER                    ;
extern const GUID GUID_A_TELETEX_TERMINAL_IDENTIFIER         ;
extern const GUID GUID_A_TELEX_NUMBER                        ;
extern const GUID GUID_A_TELEX_PRIMARY                       ;
extern const GUID GUID_A_TEMPLATE_ROOTS                      ;
extern const GUID GUID_A_TERMINAL_SERVER                     ;
extern const GUID GUID_A_TEXT_COUNTRY                        ;
extern const GUID GUID_A_TEXT_ENCODED_OR_ADDRESS             ;
extern const GUID GUID_A_TIME_REFRESH                        ;
extern const GUID GUID_A_TIME_VOL_CHANGE                     ;
extern const GUID GUID_A_TITLE                               ;
extern const GUID GUID_A_TOMBSTONE_LIFETIME                  ;
extern const GUID GUID_A_TRANSPORT_ADDRESS_ATTRIBUTE         ;
extern const GUID GUID_A_TRANSPORT_DLL_NAME                  ;
extern const GUID GUID_A_TRANSPORT_TYPE                      ;
extern const GUID GUID_A_TREAT_AS_LEAF                       ;
extern const GUID GUID_A_TREE_NAME                           ;
extern const GUID GUID_A_TRUST_ATTRIBUTES                    ;
extern const GUID GUID_A_TRUST_AUTH_INCOMING                 ;
extern const GUID GUID_A_TRUST_AUTH_OUTGOING                 ;
extern const GUID GUID_A_TRUST_DIRECTION                     ;
extern const GUID GUID_A_TRUST_PARENT                        ;
extern const GUID GUID_A_TRUST_PARTNER                       ;
extern const GUID GUID_A_TRUST_POSIX_OFFSET                  ;
extern const GUID GUID_A_TRUST_TYPE                          ;
extern const GUID GUID_A_UAS_COMPAT                          ;
extern const GUID GUID_A_UID                                 ;
extern const GUID GUID_A_UNC_NAME                            ;
extern const GUID GUID_A_UNICODE_PWD                         ;
extern const GUID GUID_A_UNIQUEIDENTIFIER                    ;
extern const GUID GUID_A_UNIQUEMEMBER                        ;
extern const GUID GUID_A_UNSTRUCTUREDADDRESS                 ;
extern const GUID GUID_A_UNSTRUCTUREDNAME                    ;
extern const GUID GUID_A_UPGRADE_PRODUCT_CODE                ;
extern const GUID GUID_A_UPN_SUFFIXES                        ;
extern const GUID GUID_A_USER_ACCOUNT_CONTROL                ;
extern const GUID GUID_A_USER_CERT                           ;
extern const GUID GUID_A_USER_COMMENT                        ;
extern const GUID GUID_A_USER_PARAMETERS                     ;
extern const GUID GUID_A_USER_PASSWORD                       ;
extern const GUID GUID_A_USERCLASS                           ;
extern const GUID GUID_A_USERPKCS12                          ;
extern const GUID GUID_A_USER_PRINCIPAL_NAME                 ;
extern const GUID GUID_A_USER_SHARED_FOLDER                  ;
extern const GUID GUID_A_USER_SHARED_FOLDER_OTHER            ;
extern const GUID GUID_A_USER_SMIME_CERTIFICATE              ;
extern const GUID GUID_A_USER_WORKSTATIONS                   ;
extern const GUID GUID_A_USN_CHANGED                         ;
extern const GUID GUID_A_USN_CREATED                         ;
extern const GUID GUID_A_USN_DSA_LAST_OBJ_REMOVED            ;
extern const GUID GUID_A_USN_INTERSITE                       ;
extern const GUID GUID_A_USN_LAST_OBJ_REM                    ;
extern const GUID GUID_A_USN_SOURCE                          ;
extern const GUID GUID_A_VALID_ACCESSES                      ;
extern const GUID GUID_A_VENDOR                              ;
extern const GUID GUID_A_VERSION_NUMBER                      ;
extern const GUID GUID_A_VERSION_NUMBER_HI                   ;
extern const GUID GUID_A_VERSION_NUMBER_LO                   ;
extern const GUID GUID_A_VOL_TABLE_GUID                      ;
extern const GUID GUID_A_VOL_TABLE_IDX_GUID                  ;
extern const GUID GUID_A_VOLUME_COUNT                        ;
extern const GUID GUID_A_WBEM_PATH                           ;
extern const GUID GUID_A_WELL_KNOWN_OBJECTS                  ;
extern const GUID GUID_A_WHEN_CHANGED                        ;
extern const GUID GUID_A_WHEN_CREATED                        ;
extern const GUID GUID_A_WINSOCK_ADDRESSES                   ;
extern const GUID GUID_A_WWW_HOME_PAGE                       ;
extern const GUID GUID_A_WWW_PAGE_OTHER                      ;
extern const GUID GUID_A_X121_ADDRESS                        ;
extern const GUID GUID_A_X500UNIQUEIDENTIFIER                ;
extern const GUID GUID_A_X509_CERT                           ;


//--------------------------------------
// CLASS SCHEMA GUIDS
//--------------------------------------
extern const GUID GUID_C_ACCOUNT                            ;
extern const GUID GUID_C_ACS_POLICY                         ;
extern const GUID GUID_C_ACS_RESOURCE_LIMITS                ;
extern const GUID GUID_C_ACS_SUBNET                         ;
extern const GUID GUID_C_ADDRESS_BOOK_CONTAINER             ;
extern const GUID GUID_C_ADDRESS_TEMPLATE                   ;
extern const GUID GUID_C_APPLICATION_ENTITY                 ;
extern const GUID GUID_C_APPLICATION_PROCESS                ;
extern const GUID GUID_C_APPLICATION_SETTINGS               ;
extern const GUID GUID_C_APPLICATION_SITE_SETTINGS          ;
extern const GUID GUID_C_APPLICATION_VERSION                ;
extern const GUID GUID_C_ATTRIBUTE_SCHEMA                   ;
extern const GUID GUID_C_BUILTIN_DOMAIN                     ;
extern const GUID GUID_C_CATEGORY_REGISTRATION              ;
extern const GUID GUID_C_CERTIFICATION_AUTHORITY            ;
extern const GUID GUID_C_CLASS_REGISTRATION                 ;
extern const GUID GUID_C_CLASS_SCHEMA                       ;
extern const GUID GUID_C_CLASS_STORE                        ;
extern const GUID GUID_C_COM_CONNECTION_POINT               ;
extern const GUID GUID_C_COMPUTER                           ;
extern const GUID GUID_C_CONFIGURATION                      ;
extern const GUID GUID_C_CONNECTION_POINT                   ;
extern const GUID GUID_C_CONTACT                            ;
extern const GUID GUID_C_CONTAINER                          ;
extern const GUID GUID_C_CONTROL_ACCESS_RIGHT               ;
extern const GUID GUID_C_COUNTRY                            ;
extern const GUID GUID_C_CRL_DISTRIBUTION_POINT             ;
extern const GUID GUID_C_CROSS_REF                          ;
extern const GUID GUID_C_CROSS_REF_CONTAINER                ;
extern const GUID GUID_C_DEVICE                             ;
extern const GUID GUID_C_DFS_CONFIGURATION                  ;
extern const GUID GUID_C_DHCP_CLASS                         ;
extern const GUID GUID_C_DISPLAY_SPECIFIER                  ;
extern const GUID GUID_C_DISPLAY_TEMPLATE                   ;
extern const GUID GUID_C_DMD                                ;
extern const GUID GUID_C_DNS_NODE                           ;
extern const GUID GUID_C_DNS_ZONE                           ;
extern const GUID GUID_C_DOCUMENT                           ;
extern const GUID GUID_C_DOCUMENTSERIES                     ;
extern const GUID GUID_C_DOMAIN                             ;
extern const GUID GUID_C_DOMAIN_DNS                         ;
extern const GUID GUID_C_DOMAIN_POLICY                      ;
extern const GUID GUID_C_DOMAINRELATEDOBJECT                ;
extern const GUID GUID_C_DS_UI_SETTINGS                     ;
extern const GUID GUID_C_DSA                                ;
extern const GUID GUID_C_DYNAMIC_OBJECT                     ;
extern const GUID GUID_C_FILE_LINK_TRACKING                 ;
extern const GUID GUID_C_FILE_LINK_TRACKING_ENTRY           ;
extern const GUID GUID_C_FOREIGN_SECURITY_PRINCIPAL         ;
extern const GUID GUID_C_FRIENDLYCOUNTRY                    ;
extern const GUID GUID_C_FT_DFS                             ;
extern const GUID GUID_C_GROUP                              ;
extern const GUID GUID_C_GROUP_OF_NAMES                     ;
extern const GUID GUID_C_GROUPOFUNIQUENAMES                 ;
extern const GUID GUID_C_GROUP_POLICY_CONTAINER             ;
extern const GUID GUID_C_INDEX_SERVER_CATALOG               ;
extern const GUID GUID_C_INETORGPERSON                      ;
extern const GUID GUID_C_INFRASTRUCTURE_UPDATE              ;
extern const GUID GUID_C_INTELLIMIRROR_GROUP                ;
extern const GUID GUID_C_INTELLIMIRROR_SCP                  ;
extern const GUID GUID_C_INTER_SITE_TRANSPORT               ;
extern const GUID GUID_C_INTER_SITE_TRANSPORT_CONTAINER     ;
extern const GUID GUID_C_IPSEC_BASE                         ;
extern const GUID GUID_C_IPSEC_FILTER                       ;
extern const GUID GUID_C_IPSEC_ISAKMP_POLICY                ;
extern const GUID GUID_C_IPSEC_NEGOTIATION_POLICY           ;
extern const GUID GUID_C_IPSEC_NFA                          ;
extern const GUID GUID_C_IPSEC_POLICY                       ;
extern const GUID GUID_C_LEAF                               ;
extern const GUID GUID_C_LICENSING_SITE_SETTINGS            ;
extern const GUID GUID_C_LINK_TRACK_OBJECT_MOVE_TABLE       ;
extern const GUID GUID_C_LINK_TRACK_OMT_ENTRY               ;
extern const GUID GUID_C_LINK_TRACK_VOL_ENTRY               ;
extern const GUID GUID_C_LINK_TRACK_VOLUME_TABLE            ;
extern const GUID GUID_C_LOCALITY                           ;
extern const GUID GUID_C_LOST_AND_FOUND                     ;
extern const GUID GUID_C_MAIL_RECIPIENT                     ;
extern const GUID GUID_C_MEETING                            ;
extern const GUID GUID_C_MS_COM_PARTITION                   ;
extern const GUID GUID_C_MS_COM_PARTITIONSET                ;
extern const GUID GUID_C_MS_DS_APP_CONFIGURATION            ;
extern const GUID GUID_C_MS_DS_APP_DATA                     ;
extern const GUID GUID_C_MS_DS_AZ_ADMIN_MANAGER             ;
extern const GUID GUID_C_MS_DS_AZ_APPLICATION               ;
extern const GUID GUID_C_MS_DS_AZ_OPERATION                 ;
extern const GUID GUID_C_MS_DS_AZ_ROLE                      ;
extern const GUID GUID_C_MS_DS_AZ_SCOPE                     ;
extern const GUID GUID_C_MS_DS_AZ_TASK                      ;
extern const GUID GUID_C_MS_DS_QUOTA_CONTAINER              ;
extern const GUID GUID_C_MS_DS_QUOTA_CONTROL                ;
extern const GUID GUID_C_MS_EXCH_CONFIGURATION_CONTAINER     ;
extern const GUID GUID_C_MS_IEEE_80211_POLICY               ;
extern const GUID GUID_C_MS_PKI_ENTERPRISE_OID              ;
extern const GUID GUID_C_MS_PKI_KEY_RECOVERY_AGENT          ;
extern const GUID GUID_C_MS_SQL_SQLSERVER                   ;
extern const GUID GUID_C_MS_SQL_OLAPSERVER                  ;
extern const GUID GUID_C_MS_SQL_SQLREPOSITORY               ;
extern const GUID GUID_C_MS_SQL_SQLPUBLICATION              ;
extern const GUID GUID_C_MS_SQL_SQLDATABASE                 ;
extern const GUID GUID_C_MS_SQL_OLAPDATABASE                ;
extern const GUID GUID_C_MS_SQL_OLAPCUBE                    ;
extern const GUID GUID_C_MS_TAPI_RT_CONFERENCE              ;
extern const GUID GUID_C_MS_TAPI_RT_PERSON                  ;
extern const GUID GUID_C_MS_WMI_INTRANGEPARAM               ;
extern const GUID GUID_C_MS_WMI_INTSETPARAM                 ;
extern const GUID GUID_C_MS_WMI_MERGEABLEPOLICYTEMPLATE     ;
extern const GUID GUID_C_MS_WMI_OBJECTENCODING              ;
extern const GUID GUID_C_MS_WMI_POLICYTEMPLATE              ;
extern const GUID GUID_C_MS_WMI_POLICYTYPE                  ;
extern const GUID GUID_C_MS_WMI_RANGEPARAM                  ;
extern const GUID GUID_C_MS_WMI_REALRANGEPARAM              ;
extern const GUID GUID_C_MS_WMI_RULE                        ;
extern const GUID GUID_C_MS_WMI_SHADOWOBJECT                ;
extern const GUID GUID_C_MS_WMI_SIMPLEPOLICYTEMPLATE        ;
extern const GUID GUID_C_MS_WMI_SOM                         ;
extern const GUID GUID_C_MS_WMI_STRINGSETPARAM              ;
extern const GUID GUID_C_MS_WMI_UINTRANGEPARAM              ;
extern const GUID GUID_C_MS_WMI_UINTSETPARAM                ;
extern const GUID GUID_C_MS_WMI_UNKNOWNRANGEPARAM           ;
extern const GUID GUID_C_MS_WMI_WMIGPO                      ;
extern const GUID GUID_C_MSMQ_CONFIGURATION                 ;
extern const GUID GUID_C_MSMQ_CUSTOM_RECIPIENT              ;
extern const GUID GUID_C_MSMQ_ENTERPRISE_SETTINGS           ;
extern const GUID GUID_C_MSMQ_GROUP                         ;
extern const GUID GUID_C_MSMQ_MIGRATED_USER                 ;
extern const GUID GUID_C_MSMQ_QUEUE                         ;
extern const GUID GUID_C_MSMQ_SETTINGS                      ;
extern const GUID GUID_C_MSMQ_SITE_LINK                     ;
extern const GUID GUID_C_NTDS_CONNECTION                    ;
extern const GUID GUID_C_NTDS_DSA                           ;
extern const GUID GUID_C_NTDS_SERVICE                       ;
extern const GUID GUID_C_NTDS_SITE_SETTINGS                 ;
extern const GUID GUID_C_NTFRS_MEMBER                       ;
extern const GUID GUID_C_NTFRS_REPLICA_SET                  ;
extern const GUID GUID_C_NTFRS_SETTINGS                     ;
extern const GUID GUID_C_NTFRS_SUBSCRIBER                   ;
extern const GUID GUID_C_NTFRS_SUBSCRIPTIONS                ;
extern const GUID GUID_C_ORGANIZATION                       ;
extern const GUID GUID_C_ORGANIZATIONAL_PERSON              ;
extern const GUID GUID_C_ORGANIZATIONAL_ROLE                ;
extern const GUID GUID_C_ORGANIZATIONAL_UNIT                ;
extern const GUID GUID_C_PACKAGE_REGISTRATION               ;
extern const GUID GUID_C_PERSON                             ;
extern const GUID GUID_C_PHYSICAL_LOCATION                  ;
extern const GUID GUID_C_PKI_CERTIFICATE_TEMPLATE           ;
extern const GUID GUID_C_PKI_ENROLLMENT_SERVICE             ;
extern const GUID GUID_C_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT     ;
extern const GUID GUID_C_PRINT_QUEUE                        ;
extern const GUID GUID_C_QUERY_POLICY                       ;
extern const GUID GUID_C_REMOTE_MAIL_RECIPIENT              ;
extern const GUID GUID_C_REMOTE_STORAGE_SERVICE_POINT       ;
extern const GUID GUID_C_RESIDENTIAL_PERSON                 ;
extern const GUID GUID_C_RFC822LOCALPART                    ;
extern const GUID GUID_C_RID_MANAGER                        ;
extern const GUID GUID_C_RID_SET                            ;
extern const GUID GUID_C_ROOM                               ;
extern const GUID GUID_C_RPC_CONTAINER                      ;
extern const GUID GUID_C_RPC_ENTRY                          ;
extern const GUID GUID_C_RPC_GROUP                          ;
extern const GUID GUID_C_RPC_PROFILE                        ;
extern const GUID GUID_C_RPC_PROFILE_ELEMENT                ;
extern const GUID GUID_C_RPC_SERVER                         ;
extern const GUID GUID_C_RPC_SERVER_ELEMENT                 ;
extern const GUID GUID_C_RRAS_ADMINISTRATION_CONNECTION_POINT     ;
extern const GUID GUID_C_RRAS_ADMINISTRATION_DICTIONARY     ;
extern const GUID GUID_C_SAM_DOMAIN                         ;
extern const GUID GUID_C_SAM_DOMAIN_BASE                    ;
extern const GUID GUID_C_SAM_SERVER                         ;
extern const GUID GUID_C_SECRET                             ;
extern const GUID GUID_C_SECURITY_OBJECT                    ;
extern const GUID GUID_C_SECURITY_PRINCIPAL                 ;
extern const GUID GUID_C_SERVER                             ;
extern const GUID GUID_C_SERVERS_CONTAINER                  ;
extern const GUID GUID_C_SERVICE_ADMINISTRATION_POINT       ;
extern const GUID GUID_C_SERVICE_CLASS                      ;
extern const GUID GUID_C_SERVICE_CONNECTION_POINT           ;
extern const GUID GUID_C_SERVICE_INSTANCE                   ;
extern const GUID GUID_C_SIMPLESECURITYOBJECT               ;
extern const GUID GUID_C_SITE                               ;
extern const GUID GUID_C_SITE_LINK                          ;
extern const GUID GUID_C_SITE_LINK_BRIDGE                   ;
extern const GUID GUID_C_SITES_CONTAINER                    ;
extern const GUID GUID_C_STORAGE                            ;
extern const GUID GUID_C_SUBNET                             ;
extern const GUID GUID_C_SUBNET_CONTAINER                   ;
extern const GUID GUID_C_SUBSCHEMA                          ;
extern const GUID GUID_C_TOP                                ;
extern const GUID GUID_C_TRUSTED_DOMAIN                     ;
extern const GUID GUID_C_TYPE_LIBRARY                       ;
extern const GUID GUID_C_USER                               ;
extern const GUID GUID_C_VOLUME                             ;


#endif //_NTDSGUID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdspchx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ntdspchx.h
//
//--------------------------------------------------------------------------
//
//  Contents:   Common Header Files For the DS Project - Precompiled.
//              #include <NTDSpch.h>
//              #pragma  hdrstop
//
//--------------------------------------------------------------------------
#ifndef _NTDSpch_
#define _NTDSpch_


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>

//
// Common DS Headers
//
#include <ntdsapi.h>

// DS-wide error control
#include <ntdswarn.h>

// Macros to control Prefix
#include <tuneprefix.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdspch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ntdspch.h
//
//--------------------------------------------------------------------------
//
//  Contents:   Common Header Files For the DS Project - Precompiled.
//              #include <NTDSpch.h>
//              #pragma  hdrstop
//
//--------------------------------------------------------------------------
#ifndef _NTDSpch_
#define _NTDSpch_
//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>

//
// Common DS Headers
//
#include <ntdsapi.h>

// DS-wide error control
#include <ntdswarn.h>

// Macros to control Prefix
#include <tuneprefix.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\objids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       objids.h
//
//--------------------------------------------------------------------------

/* Contains all hard-coded ATT and CLASS ID's used by the server.   6/13/89
*/

#include <attids.h>

/***************************************************************
* 
* KEEP THESE SORTED BY NUMBER !
*
***************************************************************/

// The attid space is 32bits wide and is divided into the ranges:
//     0x00000000..0x7FFFFFFF - OIDs mapped into attids
//     0x80000000..0xBFFFFFFF - Randomly assigned Internal attids (msDS-IntId)
//     0xC0000000..0xFFFEFFFF - unused at this time.
//     0xFFFF0000..0xFFFFFFFE - Hardcoded fixed attids
//     0xFFFFFFFF             - the invalid attid

// OIDS are mapped into ULONG attids in this range
#define FIRST_MAPPED_ATT        ((ATTRTYP)0x00000000)
#define LAST_MAPPED_ATT         ((ATTRTYP)0x7FFFFFFF)

// IntIds are programmatically assigned in this range
#define FIRST_INTID_PREFIX      ((ATTRTYP)0x8000)
#define FIRST_INTID_ATT         ((ATTRTYP)0x80000000)
#define LAST_INTID_ATT          ((ATTRTYP)0xBFFFFFFF)

#define FIRST_UNUSED_ATT        ((ATTRTYP)0xC0000000)
#define LAST_UNUSED_ATT         ((ATTRTYP)0xFFFEFFFF)

// Fixed attids are hardcoded in this range
/* Fixed columns (High Word = 0xFFFF)  Currently only used by DBGetSingleValue*/
#define FIRST_FIXED_ATT         ((ATTRTYP)0xFFFF0000)
#define FIXED_ATT_ANCESTORS     ((ATTRTYP)0xFFFF0001)
#define FIXED_ATT_DNT           ((ATTRTYP)0xFFFF0002)
#define FIXED_ATT_NCDNT         ((ATTRTYP)0xFFFF0003)
#define FIXED_ATT_OBJ           ((ATTRTYP)0xFFFF0004)
#define FIXED_ATT_PDNT          ((ATTRTYP)0xFFFF0005)
#define FIXED_ATT_REFCOUNT      ((ATTRTYP)0xFFFF0006)
#define FIXED_ATT_RDN_TYPE      ((ATTRTYP)0xFFFF0007)
#define FIXED_ATT_AB_REFCOUNT   ((ATTRTYP)0xFFFF0008)
#define FIXED_ATT_EX_FOREST     ((ATTRTYP)0xFFFF0009)
#define FIXED_ATT_NEEDS_CLEANING ((ATTRTYP)0xFFFF000A)
#define FIXED_ATT_DEL_TIME      ((ATTRTYP)0xFFFF000B)
#define LAST_FIXED_ATT          ((ATTRTYP)0xFFFFFFFE)

// The invalid attid
#define INVALID_ATT             ((ATTRTYP)0xFFFFFFFF)


// these attids are only used internally, temporarily, on a pre thread basis
// they are not present in the prefix table

#define  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY    0xFFFF0010
#define  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY   0xFFFF0011
#define  ATT_MS_DS_NC_REPL_CURSORS_BINARY              0xFFFF0012
#define  ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY     0xFFFF0013
#define  ATT_MS_DS_REPL_VALUE_META_DATA_BINARY         0xFFFF0014


// These are valid values for the ATT_INSTANCE_TYPE.  

// First, the primitive bits

// Note that these bits, must be the same as the bits in ntdsapi.[w||h], note it is a BUGBUG for these
// to be in ntdsapi.w, they should be in ntdsadef.w.  Anyway, when that gets changed this comment
// should be fixed to reflect that one can not change these bits, as thier part of public domain.

// IT_NC_HEAD   == The head of naming context.
#define IT_NC_HEAD     ((SYNTAX_INTEGER) DS_INSTANCETYPE_IS_NC_HEAD)
// IT_UNINSTANT == This is an uninstantiated replica
#define IT_UNINSTANT   ((SYNTAX_INTEGER) 2)
// IT_WRITE     == The object is writable on this directory
#define IT_WRITE       ((SYNTAX_INTEGER) DS_INSTANCETYPE_NC_IS_WRITEABLE)
// IT_NC_ABOVE  == We hold the naming context above this one on this directory
#define IT_NC_ABOVE    ((SYNTAX_INTEGER) 8)
// IT_NC_COMING == The NC is in the process of being constructed for the first
//                 time via replication.
#define IT_NC_COMING   ((SYNTAX_INTEGER) DS_INSTANCETYPE_NC_COMING)
// IT_NC_GOING  == The NC is in the process of being removed from the local DSA.
#define IT_NC_GOING    ((SYNTAX_INTEGER) DS_INSTANCETYPE_NC_GOING)

// IT_NC_ABOVE, IT_UNINSTANT, IT_NC_COMING, and IT_NC_GOING are uninteresting
// unless the object they are on is also the head of a naming context, so they
// should be unset if IT_NC_HEAD is unset.

// Mask of all instance type bits understood by the current DSA version.
#define IT_MASK_CURRENT (IT_NC_HEAD | IT_UNINSTANT | IT_WRITE | IT_NC_ABOVE \
                         | IT_NC_COMING | IT_NC_GOING)

// Mask of all instance type bits understood by Win2k DSAs.
#define IT_MASK_WIN2K   (IT_NC_HEAD | IT_UNINSTANT | IT_WRITE | IT_NC_ABOVE)


// INT_* => interior node, NC_*/SUBREF => NC head.
// NC_MASTER* => writeable, NC_FULL_REPLICA* read-only.
// NC_*_SUBREF => serves as both an NC head and a subref.

// Now, the various combinations:
#define INT_MASTER                    ((SYNTAX_INTEGER) (IT_WRITE))
#define SUBREF                        ((SYNTAX_INTEGER) (IT_UNINSTANT | IT_NC_HEAD | IT_NC_ABOVE))
#define INT_FULL_REPLICA              ((SYNTAX_INTEGER) (0))
#define NC_MASTER                     ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD))
#define NC_MASTER_COMING              ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_COMING))
#define NC_MASTER_GOING               ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_GOING))
#define NC_FULL_REPLICA               ((SYNTAX_INTEGER) (IT_NC_HEAD))
#define NC_FULL_REPLICA_COMING        ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_COMING))
#define NC_FULL_REPLICA_GOING         ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_GOING))
#define NC_MASTER_SUBREF              ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE))
#define NC_MASTER_SUBREF_COMING       ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE | IT_NC_COMING))
#define NC_MASTER_SUBREF_GOING        ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE | IT_NC_GOING))
#define NC_FULL_REPLICA_SUBREF        ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE))
#define NC_FULL_REPLICA_SUBREF_COMING ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE | IT_NC_COMING))
#define NC_FULL_REPLICA_SUBREF_GOING  ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE | IT_NC_GOING))

#define ISVALIDINSTANCETYPE(it) \
    ((BOOL) (((it) == INT_MASTER)                    || \
             ((it) == NC_MASTER)                     || \
             ((it) == NC_MASTER_COMING)              || \
             ((it) == NC_MASTER_GOING)               || \
             ((it) == NC_MASTER_SUBREF)              || \
             ((it) == NC_MASTER_SUBREF_COMING)       || \
             ((it) == NC_MASTER_SUBREF_GOING)        || \
             ((it) == INT_FULL_REPLICA)              || \
             ((it) == NC_FULL_REPLICA)               || \
             ((it) == NC_FULL_REPLICA_COMING)        || \
             ((it) == NC_FULL_REPLICA_GOING)         || \
             ((it) == NC_FULL_REPLICA_SUBREF)        || \
             ((it) == NC_FULL_REPLICA_SUBREF_COMING) || \
             ((it) == NC_FULL_REPLICA_SUBREF_GOING)  || \
             ((it) == SUBREF)                        ))

// FExitIt - is 'it' an NC exit point type.
#define FExitIt(it) ((BOOL) ((it) & IT_NC_HEAD))

// FPrefixIt - is 'it' an NC prefix type.
#define FPrefixIt(it) ((BOOL) (((it) & IT_NC_HEAD) && !((it) & IT_UNINSTANT)))

// FPartialReplicaIt - is 'it' a partial NC prefix type.
#define FPartialReplicaIt(it) (FPrefixIt(it) && !((it) & IT_WRITE))

// FMasterIt - is 'it' a master type.
#define FMasterIt(it) ((BOOL) ((it) & IT_WRITE))



/*
 * These are valid values for the ATT_OBJECT_CLASS_CATEGORY.
 */

#define DS_88_CLASS           0
#define DS_STRUCTURAL_CLASS   1
#define DS_ABSTRACT_CLASS     2
#define DS_AUXILIARY_CLASS    3


/***************************************************************
* 
* KEEP THESE SORTED BY NUMBER !
*
***************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\ntdswarn.h ===
// A place to put any DS specific warning pragmas, such as
// #pragma warning(error:4312)  // cast of 32-bit int to 64-bit ptr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\samicli2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       samicli2.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains private samlib routines for use by internal clients.

Author:

    DaveStr     12-Mar-99

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMICLI2_
#define _SAMICLI2_

NTSTATUS
SamConnectWithCreds(
    IN  PUNICODE_STRING             ServerName,
    OUT PSAM_HANDLE                 ServerHandle,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    IN  RPC_AUTH_IDENTITY_HANDLE    Creds,
    IN  PWCHAR                      Spn,
    OUT BOOL                        *pfDstIsW2K
    );

#endif // _SAMICLI2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\permit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       permit.h
//
//--------------------------------------------------------------------------

/****************************************************************************
*                            permit.h                                       *
*                                                                           *
*  This file contains all the definition used by the directory service to   *
* implement security, as well the prototypes for the apis exposed.          *
*									    *
****************************************************************************/
#include "ntdsapi.h"
//
// Define the rights used in the DS
//

#define	RIGHT_DS_CREATE_CHILD	  ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_WRITE_PROPERTY_EXTENDED  ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

#define GENERIC_READ_MAPPING     DS_GENERIC_READ
#define GENERIC_EXECUTE_MAPPING  DS_GENERIC_EXECUTE
#define GENERIC_WRITE_MAPPING    DS_GENERIC_WRITE
#define GENERIC_ALL_MAPPING      DS_GENERIC_ALL

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
			    GENERIC_WRITE_MAPPING,   \
			    GENERIC_EXECUTE_MAPPING, \
			    GENERIC_ALL_MAPPING}




DWORD
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\samisrv2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       samisrv2.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contain private routines for use by Trusted SAM clients
    which live in the same process as the SAM server in NT5.

Author:

    Colin Watson (ColinW) 23-Aug-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMISRV2_
#define _SAMISRV2_



NTSTATUS
SamIImpersonateNullSession(
    );

NTSTATUS
SamIRevertNullSession(
    );

#endif // _SAMISRV2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\w32topl.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32topl.h

Abstract:

    This file contains the dll entrypoint declarations for the w32topl.dll

    The purpose of this module is provide a simple mechanism to manipulate
    a graph data structure and to provide a useful set of pre-written 
    graph analysis routines.
    
    These functions perform in-memory actions only - there is no device IO.
    As such it is expected that errors are few and occur rarly. Thus,
    the error handling model is exception based.  All function calls in this
    module should be called from within a try/except block.
    
    All data types are in fact typeless.   However run-time type checking is
    enforced and a failure will cause an exception to be thrown with the 
    error TOPL_WRONG_OBJECT.  This includes the scenario when a deleted
    object is reused.

    The two common error codes for raised exceptions are 
    
    TOPL_OUT_OF_MEMORY : this indicates a memory allocation failed.
    
    and
    
    TOPL_WRONG_OBJECT  : this indicates an object passed in not of the
                         type specfied by the function parameter list    
    
    Individual functions may have additional parameter checks too. See function
    comments below for details.
    
               
Author:

    Colin Brace  (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    6-9-00    NickHar    Add New W32TOPL Functionality
    
--*/

#ifndef __W32TOPL_H
#define __W32TOPL_H

//
// Other header files for new w32topl functionality
//
#include "w32toplsched.h"
#include "w32toplspantree.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Exception Error codes raised from this module
//

// The TOPL_EX_PREFIX indicates that the error code is an error (not a warning, etc)
// and will not conflict with any system exception codes.
//
#define ERROR_CODE     (0x3 << 30)
#define CUSTOMER_CODE  (0x1 << 29)
#define TOPL_EX_PREFIX (ERROR_CODE | CUSTOMER_CODE)


//
// These can be thrown be all Topl* functions
//
#define TOPL_EX_OUT_OF_MEMORY             (TOPL_EX_PREFIX | (0x1<<1))   /* 2 */
#define TOPL_EX_WRONG_OBJECT              (TOPL_EX_PREFIX | (0x1<<2))   /* 4 */

// These are specialized errors
#define TOPL_EX_INVALID_EDGE              (TOPL_EX_PREFIX | (0x1<<3))   /* 8 */
#define TOPL_EX_INVALID_VERTEX            (TOPL_EX_PREFIX | (0x1<<4))   /* 16 */
#define TOPL_EX_INVALID_INDEX             (TOPL_EX_PREFIX | (0x1<<5))   /* 32 */

// Schedule Manager reserves error codes from 100-199
// New Spanning Tree algorithm reserves error codes from 200-299

int
ToplIsToplException(
    DWORD ErrorCode
    );

//
// Type definitions of w32topl objects
//

typedef VOID* TOPL_LIST_ELEMENT;
typedef VOID* TOPL_LIST;
typedef VOID* TOPL_ITERATOR;

// both TOPL_EDGE and TOPL_VERTEX can be treated as TOPL_LIST_ELEMENT
typedef VOID* TOPL_EDGE;
typedef VOID* TOPL_VERTEX;
typedef VOID* TOPL_GRAPH;


//
// List manipulation routines
//

TOPL_LIST
ToplListCreate(
    VOID
    );

VOID 
ToplListFree(
    IN TOPL_LIST List,
    IN BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                              // in the list
    );

VOID
ToplListSetIter(
    IN TOPL_LIST     List,
    IN TOPL_ITERATOR Iterator
    );

//
// Passing NULL for Elem removes the first element from the list if any
//
TOPL_LIST_ELEMENT
ToplListRemoveElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    );

VOID
ToplListAddElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    );


DWORD
ToplListNumberOfElements(
    IN TOPL_LIST         List
    );

//
// Iterator object routines
//

TOPL_ITERATOR
ToplIterCreate(
    VOID
    );

VOID 
ToplIterFree(
    IN TOPL_ITERATOR Iterator
    );

TOPL_LIST_ELEMENT
ToplIterGetObject(
    IN TOPL_ITERATOR Iterator
    );

VOID
ToplIterAdvance(
    IN TOPL_ITERATOR Iterator
    );

//
// Edge object routines
//

TOPL_EDGE
ToplEdgeCreate(
    VOID
    );

VOID
ToplEdgeFree(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeSetToVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX ToVertex
    );

TOPL_VERTEX
ToplEdgeGetToVertex(
    IN TOPL_EDGE   Edge
    );

VOID
ToplEdgeSetFromVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX FromVertex
    );

TOPL_VERTEX
ToplEdgeGetFromVertex(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeAssociate(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeDisassociate(
    IN TOPL_EDGE Edge
    );


VOID
ToplEdgeSetWeight(
    IN TOPL_EDGE Edge,
    IN DWORD     Weight
    );

DWORD
ToplEdgeGetWeight(
    IN TOPL_EDGE Edge
    );


//
// Vertex object routines
//

TOPL_VERTEX
ToplVertexCreate(
    VOID
    );

VOID
ToplVertexFree(
    IN TOPL_VERTEX Vertex
    );

VOID
ToplVertexSetId(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Id
    );

DWORD
ToplVertexGetId(
    IN TOPL_VERTEX Vertex
    );

DWORD
ToplVertexNumberOfInEdges(
    IN TOPL_VERTEX Vertex
    );

TOPL_EDGE
ToplVertexGetInEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    );

DWORD
ToplVertexNumberOfOutEdges(
    IN TOPL_VERTEX Vertex
    );

TOPL_EDGE
ToplVertexGetOutEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    );

VOID
ToplVertexSetParent(
    IN TOPL_VERTEX Vertex,
    IN TOPL_VERTEX Parent
    );

TOPL_VERTEX
ToplVertexGetParent(
    IN TOPL_VERTEX Vertex
    );

//
// Graph object routines
//

TOPL_GRAPH
ToplGraphCreate(
    VOID
    );

VOID
ToplGraphFree(
    IN TOPL_GRAPH Graph,
    IN BOOLEAN    fRecursive    // TRUE implies recursively free the vertices
                                // that have been added to this graph
    );   

VOID
ToplGraphAddVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToAdd,
    IN PVOID       VertexName
    );

TOPL_VERTEX
ToplGraphRemoveVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToRemove
    );
      
VOID
ToplGraphSetVertexIter(
    IN TOPL_GRAPH    Graph,
    IN TOPL_ITERATOR Iter
    );

DWORD
ToplGraphNumberOfVertices(
    IN TOPL_GRAPH    Graph
    );


//
// This can used to release arrays of objects that may be passed back.
// It should not be used to free object themselves - use the appropriate
// Topl*Free() routines.
//

VOID
ToplFree(
    VOID *p
    );


//
// Can be used to change the default memory allocation routines used by this
// library.  Settings are per-thread.
//
typedef VOID * (TOPL_ALLOC)(DWORD size);
typedef VOID * (TOPL_REALLOC)(VOID *, DWORD size);
typedef VOID (TOPL_FREE)(VOID *);

DWORD
ToplSetAllocator(
    IN  TOPL_ALLOC *    pfAlloc     OPTIONAL,
    IN  TOPL_REALLOC *  pfReAlloc   OPTIONAL,
    IN  TOPL_FREE *     pfFree      OPTIONAL
    );


//
// General graph analysis routines
//

//
// The Flags parameter must be set to exactly one of these values
//
#define TOPL_RING_ONE_WAY   (0x1 << 1)
#define TOPL_RING_TWO_WAY   (0x1 << 2)

VOID
ToplGraphMakeRing(
    IN TOPL_GRAPH  Graph,
    IN DWORD       Flags,
    OUT TOPL_LIST  EdgesToAdd,
    OUT TOPL_EDGE  **EdgesToKeep,
    OUT ULONG      *cEdgesToKeep
    );


// Note: Caller must user ToplDeleteComponents() to free the
// TOPL_COMPONENTS structure.
TOPL_COMPONENTS*
ToplGraphFindEdgesForMST(
    IN  TOPL_GRAPH  Graph,
    IN  TOPL_VERTEX RootVertex,
    IN  TOPL_VERTEX VertexOfInterest,
    OUT TOPL_EDGE  **EdgesNeeded,
    OUT ULONG*      cEdgesNeeded
    );


#ifdef __cplusplus  
};
#endif

//
// For c++ users
//
//
typedef enum {

    eEdge,
    eVertex,
    eGraph,
    eList,
    eIterator,
    eInvalidObject

}TOPL_OBJECT_TYPE;

//
// Private type definitions
//

typedef struct {

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    SINGLE_LIST_ENTRY Head;
    ULONG             NumberOfElements;

}LIST, *PLIST;

typedef struct {

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    PSINGLE_LIST_ENTRY pLink;

} ITERATOR, *PITERATOR;

typedef struct {

    VOID  **Array;
    DWORD   Count;
    DWORD   ElementsAllocated;

}DYNAMIC_ARRAY, *PDYNAMIC_ARRAY;

struct _ListElement; 

typedef struct
{     

#ifdef __cplusplus
private:
#endif

    struct _ListElement* To;
    struct _ListElement* From;
    DWORD   Weight;


} EDGE_DATA, *PEDGE_DATA;

typedef struct
{

#ifdef __cplusplus
private:
#endif

    DWORD         Id;
    PVOID          VertexName;
    DYNAMIC_ARRAY InEdges;
    DYNAMIC_ARRAY OutEdges;

    struct _ListElement* Parent;

} VERTEX_DATA, *PVERTEX_DATA;
        
//
// Vertex, edge and graph definitions
//
struct _ListElement
{

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE     ObjectType;

    SINGLE_LIST_ENTRY    Link;

    union {
        VERTEX_DATA VertexData;
        EDGE_DATA   EdgeData;
    };

};

typedef struct _ListElement  EDGE;
typedef struct _ListElement* PEDGE;

typedef struct _ListElement  VERTEX;
typedef struct _ListElement* PVERTEX;

typedef struct _ListElement  LIST_ELEMENT;
typedef struct _ListElement* PLIST_ELEMENT;

typedef struct
{

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    LIST VertexList;

} GRAPH, *PGRAPH;

#ifdef __cplusplus
extern "C" {
#endif

VOID
ToplVertexInit(
    PVERTEX
    );

VOID
ToplVertexDestroy(
    PVERTEX
    );

VOID
ToplEdgeInit(
    PEDGE
    );

VOID
ToplEdgeDestroy(
    PEDGE
    );

VOID
ToplGraphInit(
    PGRAPH
    );

VOID
ToplGraphDestroy(
    PGRAPH
    );

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

class CTOPL_VERTEX;
class CTOPL_EDGE;
class CTOPL_GRAPH;



//
// Class definitions
//

class CTOPL_VERTEX : public VERTEX
{
public:

    CTOPL_VERTEX()
    {   
        ToplVertexInit((PVERTEX)this);
    }
    
    ~CTOPL_VERTEX()
    {
        ToplVertexDestroy((PVERTEX)this);
    }

    VOID
    ClearEdges(VOID) 
    {
        ToplVertexDestroy((PEDGE)this);
        ToplVertexInit((PEDGE)this);
    }

    VOID
    SetId(DWORD id)
    {
        ToplVertexSetId((PVERTEX)this, id);
    }

    DWORD
    GetId(VOID)
    {
        return ToplVertexGetId((PVERTEX)this);
    }

    DWORD
    NumberOfInEdges(void)
    {
        return ToplVertexNumberOfInEdges((PEDGE)this);
    }

    CTOPL_EDGE*
    GetInEdge(DWORD Index)
    {
        return (CTOPL_EDGE*)ToplVertexGetInEdge((PEDGE)this, Index);
    }

    DWORD
    NumberOfOutEdges(void)
    {
        return ToplVertexNumberOfOutEdges((PEDGE)this);
    }

    CTOPL_EDGE*
    GetOutEdge(DWORD Index)
    {
        return (CTOPL_EDGE*)ToplVertexGetOutEdge((PEDGE)this, Index);
    }

};

class CTOPL_EDGE : public EDGE
{
public:

    CTOPL_EDGE()
    {   
        ToplEdgeInit((PEDGE)this);
    }
    
    ~CTOPL_EDGE()
    {
        ToplEdgeDestroy((PEDGE)this);
    }


    VOID
    SetTo(CTOPL_VERTEX* V)
    {
        ToplEdgeSetToVertex((PEDGE)this, (PVERTEX)V);
    }

    VOID
    SetFrom(CTOPL_VERTEX* V)
    {
        ToplEdgeSetFromVertex((PEDGE)this, (PVERTEX)V);
    }

    CTOPL_VERTEX*
    GetTo()
    {
        return (CTOPL_VERTEX*)ToplEdgeGetToVertex((PEDGE)this);
    }

    CTOPL_VERTEX*
    GetFrom()
    {
        return (CTOPL_VERTEX*)ToplEdgeGetFromVertex((PEDGE)this);
    }

    VOID
    SetWeight(DWORD Weight)
    {
        ToplEdgeSetWeight((PEDGE)this, Weight);
    }

    DWORD
    GetWeight(void)
    {
        return ToplEdgeGetWeight((PEDGE)this);
    }

    VOID
    Associate(void)
    {
        ToplEdgeAssociate((PEDGE)this);
    }

    VOID
    Disassociate(void)
    {
        ToplEdgeDisassociate((PEDGE)this);
    }
};

class CTOPL_GRAPH : public GRAPH
{
public:


    CTOPL_GRAPH()
    {   
        ToplGraphInit((PGRAPH)this);
    }
    
    ~CTOPL_GRAPH()
    {
        ToplGraphDestroy((PGRAPH)this);
    }

    void
    // The KCC passes a KCC_SITE object in as a CTOPL_VERTEX and, because
    // of multiple inheritence, the pointer gets adjusted. W32TOPL later needs to add
    // the Vertex to a TOPL_COMPONENT structure, which contains a PVOID. The KCC
    // will examine the TOPL_COMPONENT structure and expect to receive a KCC_SITE.
    // However, because the pointer has been adjusted, it will receive a bogus pointer.
    // In order to work around this problem, this function takes a second parameter,
    // VertexName, which is of type PVOID and thus does not get adjusted.
    AddVertex(CTOPL_VERTEX *VertexToAdd, PVOID VertexName)
    {
        ToplGraphAddVertex((PGRAPH) this, (PVERTEX)VertexToAdd, VertexName);
    }

    void
    RemoveVertex(CTOPL_VERTEX *VertexToRemove)
    {
        ToplGraphRemoveVertex((PGRAPH) this, (PVERTEX)VertexToRemove);
    }
      
    void
    SetVertexIter(TOPL_ITERATOR Iter)
    {
        ToplGraphSetVertexIter((PGRAPH) this, Iter);
    }

    DWORD
    NumberOfVertices(void)
    {
        return ToplGraphNumberOfVertices((PGRAPH) this);
    }

    VOID
    MakeRing(IN DWORD       Flags,
             OUT TOPL_LIST  EdgesToAdd,
             OUT TOPL_EDGE  **EdgesToKeep,
             OUT ULONG      *cEdgesToKeep)
    {
        ToplGraphMakeRing((PGRAPH)this,
                          Flags,
                          EdgesToAdd,
                          EdgesToKeep,
                          cEdgesToKeep);
    }

    // Note: Caller must user ToplDeleteComponents() to free the
    // TOPL_COMPONENTS structure.
    TOPL_COMPONENTS*
    FindEdgesForMST(
        IN  CTOPL_VERTEX* RootVertex,
        IN  CTOPL_VERTEX* VertexOfInterest,
        OUT CTOPL_EDGE  ***EdgesNeeded,
        OUT ULONG*      cEdgesNeeded )
    {
        return ToplGraphFindEdgesForMST((PGRAPH) this,
                                        (TOPL_VERTEX)RootVertex,
                                        (TOPL_VERTEX)VertexOfInterest,
                                        (TOPL_EDGE**)EdgesNeeded,
                                        cEdgesNeeded );
    }

};

#endif // __cplusplus


#endif // __W32TOPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\taskq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskq.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/10/97    Jeff Parham (jeffparh)

REVISION HISTORY:
    01/28/00    Xin He (xinhe)
                Moved struct TQEntry into taskq.h from taskq.c.
                Struct TQEntry is only for internal use, and is put
                into taskq.h because debugger extension program needs it.

    01/22/97    Jeff Parham (jeffparh)
                Modified PTASKQFN definition such that a queued function
                can automatically reschedule itself without making another
                call to InsertTaskInQueue().  This mechanism reuses
                already allocated memory in the scheduler to avoid the
                case where a periodic function stops working when at
                some point in its lifetime a memory shortage prevented
                it from rescheduling itself.

Note, the functions provided by taskq\taskq.c are also stubbed out in mkdit\stubs.c
on behalf of the standalone tools mkdit and mkhdr.  If you add new task queue functions
you may need to stub them out also.

--*/

#define TASKQ_DONT_RESCHEDULE   ( 0xFFFFFFFF )
#define TASKQ_NOT_DAMPED        ( 0xFFFFFFFF )

extern DWORD gTaskSchedulerTID;
extern BOOL  gfIsTqRunning;

// Declaration of a function type which can determine if
// two parameters match or not.
typedef BOOL (*PISMATCHED)(
    IN  PCHAR  pParam1Name,
    IN  void  *pParam1,
    IN  PCHAR  pParam2Name,
    IN  void  *pParam2,
    IN  void  *pContext             // pointer to arbitrary data
    );

typedef void (*PTASKQFN)(
    IN  void *  pvParam,                // input parameter for this iteration
    OUT void ** ppvParamNextIteration,  // input parameter for next iteration
    OUT DWORD * pSecsUntilNextIteration // delay until next iteration in seconds
                                        //     set to TASKQ_DONT_RESCHEDULE to
                                        //     not reschedule the task
    );

typedef void (*PSPAREFN)(void);

typedef struct _SPAREFN_INFO {
    HANDLE    hevSpare;
    PSPAREFN  pfSpare;
} SPAREFN_INFO;


//for internal use only
typedef struct TQEntry
{
    void           *    pvTaskParm;
    DWORD               cTickRegistered;
    DWORD               cTickDelay;
    PTASKQFN            pfnTaskFn;
    PCHAR               pfnName;
}   TQEntry, *pTQEntry;

// Initialize task scheduler.
BOOL
InitTaskScheduler(
    IN  DWORD           cSpares,
    IN  SPAREFN_INFO *  pSpares,
    IN  BOOL            fRunImmediately
    );

// Start scheduler that has been initialized with fRunImmediately == FALSE
void StartTaskScheduler();

// Signal task scheduler to shut down.  Returns immediately
void
ShutdownTaskSchedulerTrigger( void );

// Waits for the task scheduler to shut down
// Returns TRUE if successful (implying current task, if any, ended).
BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds    // maximum time to wait for current
    );                                  //   task (if any) to complete

extern BOOL gfIsTqRunning;  // is the scheduler running?

// Insert a task in the task queue.
// Contains useful debugging assertions.
// note that when in singleusermode, we will not insert in the taskqueue
// but we don't want to assert
// DoInsertInTaskQueue takes the FunctionName string parameter. This macro stringizes
// the function name passed as the first param. If you want to pass a generic string
// (which can be useful when damping), use DoInsertInTaskQueue directly.
#define InsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow) {                               \
    Assert( gfIsTqRunning && "InsertInTaskQueue() called before InitTaskScheduler()!" || DsaIsSingleUserMode()); \
    DoInsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow, FALSE, #pfnTaskQFn);    \
}

// Insert a task in the task queue.
// Does not contain assertions.  Useful during shutdown.
#define InsertInTaskQueueSilent(pfnTaskQFn, pvParam, cSecsFromNow, fReschedule) \
        DoInsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow, fReschedule, #pfnTaskQFn)
        
// DoInsertInTaskQueueDamped takes the FunctionName string parameter. This macro stringizes
// the function name passed as the first param. If you want to pass a generic string
// (which can be useful when damping), use DoInsertInTaskQueueDamped directly.
#define InsertInTaskQueueDamped(pfnTaskQFn, pvParam, cSecsFromNow, cSecsDamped, pfnIsMatched, pContext) \
        DoInsertInTaskQueueDamped(pfnTaskQFn, pvParam, cSecsFromNow, FALSE, #pfnTaskQFn, cSecsDamped, pfnIsMatched, pContext)

// Remove a task from task queue (if it's there).
// (Ignore time data).
#define CancelTask(pfnTaskQFn, pvParam) \
        DoCancelTask(pfnTaskQFn, pvParam, #pfnTaskQFn)

// Cause the given task queue function to be executed synchonously with respect
// to other tasks in the task queue.
#define TriggerTaskSynchronously(pfnTaskQFn, pvParam) \
        DoTriggerTaskSynchronously(pfnTaskQFn, pvParam, #pfnTaskQFn)

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,     // task to execute
    void *      pvParam,        // user-defined parameter to that task
    DWORD       cSecsFromNow,   // secs from now to execute
    BOOL        fReschedule,    // attempt reschedule first?
    PCHAR       pfnName         // function name
    );

BOOL
DoInsertInTaskQueueDamped(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    DWORD       cSecsFromNow,
    BOOL        fReschedule,
    PCHAR       pfnName,
    DWORD       cSecsDamped,
    PISMATCHED  pfnIsMatched,
    void *      pContext
    );

BOOL
DoCancelTask(
    PTASKQFN    pfnTaskQFn,    // task to remove
    void *      pvParm,        // task parameter
    PCHAR       pfnName         // function name
    );

DWORD
DoTriggerTaskSynchronously(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName         // function name
    );

// Return seconds since Jan 1, 1601.
DSTIME
GetSecondsSince1601( void );

// Default TQ compare function to match functions by name and param
BOOL TaskQueueNameMatched(
    IN  PCHAR  pParam1Name,
    IN  void  *pParam1,
    IN  PCHAR  pParam2Name,
    IN  void  *pParam2,
    IN  void  *pContext             // pointer to arbitrary data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\rpcbind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rpcbind.h
//
//--------------------------------------------------------------------------

#ifndef MAC
#define MAX_SUPPORTED_PROTSEQ	6
#else // MAC
//$MAC - add 1 protseq
#define MAX_SUPPORTED_PROTSEQ	7
#endif // MAC

// 
// protocol sequence array indexed by transport type as defined in mds.h 
// and msrpc.h
//

extern unsigned char __RPC_FAR *rgszProtseq[];

RPC_STATUS GetRpcBinding(RPC_BINDING_HANDLE __RPC_FAR *phBinding,
       RPC_IF_HANDLE IfHandle,
    unsigned long ulTransportType,  unsigned char __RPC_FAR *szNetworkAddress);


// flag values GetBindingInfo
#define fServerToServer			0x00000001
#define fSupportNewCredentials		0x00000002

RPC_STATUS GetBindingInfo( void __RPC_FAR * __RPC_FAR *pBindingInfo,
    RPC_IF_HANDLE IfHandle,
    unsigned long ulTransportType, unsigned char __RPC_FAR *szNetworkAddress,
    unsigned long  cServerAddresses,
    unsigned char __RPC_FAR * __RPC_FAR *rgszServerAddresses,
    unsigned long ulFlags);

RPC_BINDING_HANDLE SelectRpcBinding( void __RPC_FAR * BindingInfo);

void FreeRpcBinding(RPC_BINDING_HANDLE __RPC_FAR *phBinding);

void FreeBindingInfo( void __RPC_FAR * BindingInfo);


typedef enum _CONNECTSTATE {offLine, connected, disconnected} CONNECTSTATE;

#ifndef HFILE
#define HFILE   int
#endif

#pragma warning( disable:4200)		// avoid non-standard extension warning
typedef struct _auth_info_buffer {
	struct _auth_info_buffer __RPC_FAR *pNext;
	BYTE rgbAuthInfo[];
} AUTH_INFO_BUFFER;
#pragma warning( default:4200)


typedef struct _RpcConnection {
        // RPC info
    CONNECTSTATE connectState;
    handle_t hBinding;
    void __RPC_FAR * hRpc;
    unsigned long   hServerContext;     // XDS server context for ds_wait
    unsigned long   ulTotRecs;          // OAB info
    unsigned long   ulTotANRdex;        // num of ANR recs
    unsigned long   oRoot;
    char __RPC_FAR * pDNTable;
    HFILE   hBrowse;            // file handle -- note these are NEAR ptrs in Win16
    HFILE   hDetails;
    HFILE   hRDNdex;
    HFILE   hANRdex;
    HFILE   hTmplts;
    ULONG   ulUIParam;
    ULONG   ulMapiFlags;
    ULONG   ulAuthenticationState;
    ULONG   ulAuthenticationFlags;
    RPC_AUTH_IDENTITY_HANDLE hCredentials;
    void __RPC_FAR *pvEmsuiSupportObject;
    AUTH_INFO_BUFFER __RPC_FAR *pBuffer;
} RPCCONNECTION;

// values for ulAuthenticationState
#define	AUTH_STATE_NO_AUTH		0
#define AUTH_STATE_OS_CREDENTIALS	1
#define AUTH_STATE_USER_CREDENTIALS	2


// Flag values for ulAuthenticationFlags
#define fAlwaysLogin			0x00000001
#define fCredentialsCameFromUser	0x00000002
#define fNeedEncryption			0x00000008
#define fInvalidCredentials		0x00000010

RPC_STATUS SetRpcAuthenticationInfo(RPC_BINDING_HANDLE hBinding,
    unsigned long ulAuthnLevel, RPC_AUTH_IDENTITY_HANDLE pAutthId);

RPC_STATUS
SetRpcAuthenticationInfoEx(
    RPC_BINDING_HANDLE          hBinding,
    unsigned char __RPC_FAR *   pszServerPrincName,
    ULONG                       ulAuthnLevel,
    ULONG                       ulAuthnSvc,
    RPC_AUTH_IDENTITY_HANDLE    hAuthId
    );

RPC_STATUS SetAuthInfoWithCredentials(RPC_BINDING_HANDLE hBinding,
    RPCCONNECTION  __RPC_FAR *pConnect);

#if DBG
void
DisplayBinding(RPC_BINDING_HANDLE hBinding);
void
DisplayBindingVector(RPC_BINDING_VECTOR __RPC_FAR *pVector);
#else
#define DisplayBinding(x)
#define DisplayBindingVector(x)
#endif /* DBG */

void ReleaseRpcContextHandle(void __RPC_FAR * __RPC_FAR * ContextHandle);


#ifdef WIN32
DWORD GetRpcAuthLevelFromReg(void);

void SetRpcAuthInfoFromReg(RPC_BINDING_HANDLE hBinding);
#endif

RPC_STATUS StepDownRpcSecurity(RPC_BINDING_HANDLE hBinding);

#define FUnsupportedAuthenticationLevel(status) 			\
    ((status == RPC_S_UNKNOWN_AUTHN_LEVEL) || (status == RPC_S_UNKNOWN_AUTHN_TYPE))

RPC_STATUS
StepDownRpcAuthnService(
    RPC_BINDING_HANDLE  hBinding
    );

#define FUnsupportedAuthenticationService(status) \
    ((status) == RPC_S_UNKNOWN_AUTHN_SERVICE)

// RPC bug - 5 is retuned on win16 for an access denied error so we
// hard code it

#define FPasswordInvalid(status) ((status == RPC_S_ACCESS_DENIED) || (status == 5))

void FreeAuthenticationBufferList(AUTH_INFO_BUFFER __RPC_FAR * __RPC_FAR * ppBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\w32toplsched.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    w32toplsched.h

Abstract:

    This file provides the interfaces for working with the new schedule cache,
    and some new 'helper' functions for working with schedules. 

Author:

    Nick Harvey    (NickHar)
    
Revision History

    13-6-2000   NickHar   Created
    
--*/

#ifndef SCHEDMAN_H
#define SCHEDMAN_H

/***** Header Files *****/
#include <schedule.h>

#ifdef __cplusplus
extern "C" {
#endif

/***** Data Structures *****/
/* These structures are opaque */
typedef PVOID TOPL_SCHEDULE;
typedef PVOID TOPL_SCHEDULE_CACHE;

/***** Exceptions *****/
/* Schedule Manager reserves error codes from 100-199 */
#define TOPL_EX_NULL_POINTER              (TOPL_EX_PREFIX | 101)
#define TOPL_EX_SCHEDULE_ERROR            (TOPL_EX_PREFIX | 102)
#define TOPL_EX_CACHE_ERROR               (TOPL_EX_PREFIX | 103)
#define TOPL_EX_NEVER_SCHEDULE            (TOPL_EX_PREFIX | 104)

/***** Constants *****/
#define TOPL_SCHEDULE_SIZE                (sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES)

/***** ToplScheduleCacheCreate *****/
/* Create a cache */
TOPL_SCHEDULE_CACHE
ToplScheduleCacheCreate(
	VOID
	);

/***** ToplScheduleCacheDestroy *****/
/* Destroy the cache. Frees all storage occupied by the cache and any handles
 * in the cache. The TOPL_SCHEDULE objects are also freed, and should not be
 * used after destroying the cache that they live in. */
VOID
ToplScheduleCacheDestroy(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
	);

/***** ToplScheduleImport *****/
/* Store an external schedule in the cache, either creating a new entry or
 * reusing an existing one. No expectations are made around the memory
 * allocator of pExternalSchedule. The pExternalSchedule parameter is copied
 * into the cache, and may be immediately freed by the caller.
 * If pExternalSchedule is NULL, this is interpreted as the 'always schedule'.
 * Schedules whose bits are all 0 (the 'never schedule') are acceptable for
 * importing into the cache. */
TOPL_SCHEDULE
ToplScheduleImport(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN PSCHEDULE pExternalSchedule
	);

/***** ToplScheduleNumEntries *****/
/* Returns a count of how many unique schedules are stored in the cache.
 * Note: this count does not include any always schedules that were
 * imported into the cache. */
DWORD
ToplScheduleNumEntries(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    );

/***** ToplScheduleExportReadonly *****/
/* Obtain a pointer to an external schedule given a TOPL_SCHEDULE object.
 * The exported schedule is considered readonly by the caller and should
 * not be deallocated by him. 
 * Note: If the input is TOPL_ALWAYS_SCHEDULE, a properly constructed
 * PSCHEDULE _will_ be returned. */
PSCHEDULE
ToplScheduleExportReadonly(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplScheduleMerge *****/
/* Return a new cached schedule which is the intersection of the two provided 
 * schedules. If the two schedules do not intersect, the fIsNever flag is set
 * to true (but an 'always unavailable' schedule is returned.) */
TOPL_SCHEDULE
ToplScheduleMerge(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2,
    OUT PBOOLEAN fIsNever
	);

/***** ToplScheduleCreate *****/
/* Create a new schedule in the cache according to the criteria.  If the
 * template schedule is given, it is used as the basis for the new schedule, else
 * the ALWAYS schedule is used. A new schedule is formed by finding the first
 * active period, marking it, skipping ahead by interval specified, and repeating. */
TOPL_SCHEDULE
ToplScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL,
	IN DWORD StaggeringNumber
	);

/***** ToplScheduleIsEqual *****/
/* This function indicates whether two schedule handles refer to the same schedule.
 * This may simply be check for pointer equality internally, but we don't want to
 * expose that knowledge to the caller. */
BOOLEAN
ToplScheduleIsEqual(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2
	);

/***** ToplScheduleDuration *****/
/* Return the number of minutes in use by the given schedule. */
DWORD
ToplScheduleDuration(
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplScheduleMaxUnavailable *****/
/* Return the length in minutes of the longest contiguous period
 * of time for which the schedule is unavailable. */
DWORD
ToplScheduleMaxUnavailable(
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplGetAlwaysSchedule *****/
/* Return the 'always schedule' */
TOPL_SCHEDULE
ToplGetAlwaysSchedule(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
    );

/***** ToplScheduleValid *****/
/* Returns true if a topl schedule appears to be valid, false otherwise.
 * NULL schedules are accepted -- they are interpreted to mean the
 * 'always schedule'. */
BOOLEAN
ToplScheduleValid(
    IN TOPL_SCHEDULE Schedule
    );

/***** ToplPScheduleValid *****/
/* Returns true if a pschedule is in a supported format, false otherwise.
 * Never schedules are not supported. */
BOOLEAN
ToplPScheduleValid(
    IN PSCHEDULE Schedule
    );

#ifdef __cplusplus
}
#endif

#endif // SCHEDMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\w32toplspantree.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    w32toplspantree.h

Abstract:

    This file provides the interfaces for invoking w32topl's new graph algorithms,
    which are used for calculating network topologies.

Memory Responsibilities:

    W32TOPL is responsible for:
        The graph state
        The multi-edges
        The output edges from the spanning-tree algorithm
        The components
    
    The user must allocate:
        All vertex names
        The list of pointers to vertex names
        The schedule cache
        The vertices for edges
        The edge sets
        The list of color vertices

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created
    14-7-2000   NickHar   Initial development complete, submit to source control
    
--*/

#ifndef W32TOPLSPANTREE_H
#define W32TOPLSPANTREE_H

/***** Header Files *****/
#include "w32toplsched.h"

#ifdef __cplusplus
extern "C" {
#endif

/***** Exceptions *****/
/* New Spanning Tree algorithm reserves error codes from 200-299. The meanings
 * of these errors are explained in the comments of any functions that raise them. */
#define TOPL_EX_GRAPH_STATE_ERROR         (TOPL_EX_PREFIX | 201)
#define TOPL_EX_INVALID_EDGE_TYPE         (TOPL_EX_PREFIX | 202)
#define TOPL_EX_INVALID_EDGE_SET          (TOPL_EX_PREFIX | 203)
#define TOPL_EX_COLOR_VTX_ERROR           (TOPL_EX_PREFIX | 204)
#define TOPL_EX_ADD_EDGE_AFTER_SET        (TOPL_EX_PREFIX | 205)
#define TOPL_EX_TOO_FEW_VTX               (TOPL_EX_PREFIX | 206)
#define TOPL_EX_TOO_FEW_EDGES             (TOPL_EX_PREFIX | 207)
#define TOPL_EX_NONINTERSECTING_SCHEDULES (TOPL_EX_PREFIX | 208)


/***** TOPL_GRAPH_STATE *****/
/* This structure is opaque */
typedef PVOID PTOPL_GRAPH_STATE;


/***** TOPL_REPL_INFO *****/
/* This structure describes the configured replication parameters of a graph edge.
 * When determining the replication parameters for a path (a sequence of edges),
 * the replication parameters are combined as follows:
 *  - The combined cost of two edges is the sum of the costs of the two edges.
 *    This sum will saturate at the maximum value of a DWORD.
 *  - The replication interval of two edges is the maximum of the replication
 *    intervals of the two edges.
 *  - The combined options of two edges is the logical AND of the options of the
 *    individual edges.
 *  - The combined schedule of two edges is formed by calling ToplScheduleMerge()
 *    function on the schedules of the individual edges. The semantics of that
 *    function are specified elsewhere.
 * Note that a NULL schedule implicitly means the 'always schedule'.
 */
typedef struct {
    DWORD               cost;
    DWORD               repIntvl;
    DWORD               options;
    TOPL_SCHEDULE       schedule;
} TOPL_REPL_INFO;
typedef TOPL_REPL_INFO *PTOPL_REPL_INFO;


/***** TOPL_NAME_STRUCT *****/
/* This structure contains a pointer to the name of a vertex and a 'reserved'
 * field, which is used internally for efficiency purposes. The user should
 * not set or examine the reserved field. */
typedef struct {
    PVOID   name;
    DWORD   reserved;
} TOPL_NAME_STRUCT;


/***** TOPL_MULTI_EDGE *****/
/* This structure is used to specify a connection between a set of vertices.
 * There can be multiple edges connecting the same set of vertices, hence the
 * name 'multi-edge'. Since the edge can connect more than 2 vertices, it
 * should be called a 'hyper-multi-edge', but that's not a very nice name. This
 * object acts like a fully connected subgraph of all vertices it contains.
 * When building a spanning tree, any combination of end-points can be chosen
 * for tree edges.  Each edge also has an associated 'edge type'. Vertices can
 * choose whether or not to permit spanning-tree edges of a given type (see
 * 'TOPL_COLOR_VERTEX'). The 'fDirectedEdge' flag is used only in edges output from
 * ToplGetSpanningTreeEdgesForVtx(). It can be ignored for input edges. */
typedef struct {
    DWORD               numVertices;
    DWORD               edgeType;       /* Legal values are 0..31 */
    TOPL_REPL_INFO      ri;
    BOOLEAN             fDirectedEdge;
    TOPL_NAME_STRUCT    vertexNames[1];
} TOPL_MULTI_EDGE;
typedef TOPL_MULTI_EDGE *PTOPL_MULTI_EDGE;


/***** TOPL_MULTI_EDGE_SET *****/
/* This structure contains a set of multi-edges. It essentially describes a
 * 'universe of transitivity'. Replication data can flow transitively from
 * one edge to another if all those edges are contained in some multi-edge set.
 * All edges within an edge set must have the same edge type. Every multi-edge
 * set should contain at least 2 edges.
 */
typedef struct {
    DWORD               numMultiEdges;
    PTOPL_MULTI_EDGE   *multiEdgeList;
} TOPL_MULTI_EDGE_SET;
typedef TOPL_MULTI_EDGE_SET *PTOPL_MULTI_EDGE_SET;


/***** TOPL_VERTEX_COLOR *****/
/* Used to specify the type of the graph's vertices. White vertices are
 * used only for finding paths between colored vertices. Red and black
 * vertices are more important -- they are the vertices that are part of
 * the spanning tree. In a sense, red vertices have higher 'priority'
 * than black vertices. */
typedef enum {
    COLOR_WHITE,        
    COLOR_RED,          
    COLOR_BLACK
} TOPL_VERTEX_COLOR;


/***** TOPL_COLOR_VERTEX *****/
/* This structure defines additional configuration information for a vertex,
 * including its color (red, black), and the edgeTypes it will accept. White
 * (non-colored) vertices do not need to use this structure to specify
 * additional information. 
 * 
 * When choosing spanning tree edges incident with a vertex, we can use this
 * structure to refuse edges of a certain type. In fact, we have even more
 * flexibility than that -- we can choose to refuse edges which connect two
 * red vertices, but accept edges whose endpoints are red-black or black-black.
 * For example, to accept a red-red edge of type i, set the i'th bit of
 * 'acceptRedRed' to 1. To deny a red-black edge of type j, set the j'th bit
 * of 'acceptBlack' to 0. */
typedef struct {
    PVOID               name;
    TOPL_VERTEX_COLOR   color;
    DWORD               acceptRedRed;
    DWORD               acceptBlack;
} TOPL_COLOR_VERTEX;
typedef TOPL_COLOR_VERTEX *PTOPL_COLOR_VERTEX;


/***** TOPL_COMPONENT *****/
/* This structure describes a single component of a spanning forest. */
typedef struct {
    DWORD               numVertices;
    PVOID              *vertexNames;
} TOPL_COMPONENT;


/***** TOPL_COMPONENTS *****/
/* This structure describes the components of the spanning forest computed by
 * the algorithm. If all is well, the graph will be connected and there will
 * be only one component. If not, this structure will contain information about
 * the different graph components. */
typedef struct {
    DWORD               numComponents;
    TOPL_COMPONENT     *pComponent;
} TOPL_COMPONENTS;
typedef TOPL_COMPONENTS *PTOPL_COMPONENTS;



/* The parameters to this comparison function are pointers to the PVOID
 * vertex names which were passed in. */
typedef int (__cdecl *TOPL_COMPARISON_FUNC)(const void*,const void*);


/***** Prototypes *****/

/***** ToplMakeGraphState *****/
/* Create a GraphState object. The graph's vertices are specified at creation
 * time -- the user should allocate an array of pointers to some structure
 * which names a vertex. W32TOPL is not interested in the details of the vertex
 * names. The multi-edges should all be added later by calling 'AddEdgeToGraph'.
 * Edge sets should be added after that to specify edge transitivity. The
 * function ToplDeleteGraphState() should be used to free the graph state
 * structure, but the user has the responsibility of deleting the vertex names,
 * their array, and the schedule cache.
 *
 * Error Conditions:
 *  - If the vertexNames array or any of its elements, vnCompFunc, or schedCache
 *    are NULL,  an exception of type TOPL_EX_NULL_POINTER will be raised.
 *  - Since this function allocates memory, it can also raise an exception if
 *    memory is exhausted.
 *
 * Warnings:
 *  - The contents of 'vertexNames' will be reordered after calling this function
 */
PTOPL_GRAPH_STATE
ToplMakeGraphState(
    IN PVOID* vertexNames,
    IN DWORD numVertices,
    IN TOPL_COMPARISON_FUNC vnCompFunc,
    IN TOPL_SCHEDULE_CACHE schedCache
    );


/***** ToplAddEdgeToGraph *****/
/* Allocate a multi-edge object, and add it to the graph G.
 * The number of vertices that this edge will contain must be specified
 * in the 'numVtx' parameter, so that the appropriate amount of memory
 * can be allocated. The names of the vertices contained in this edge
 * are not yet specified -- they are NULL. The names must be specified
 * later, by calling the function ToplEdgeSetVtx(). All names must be
 * set before adding this edge to an edge set, and before calling
 * ToplGetSpanningTreeEdgesForVtx().
 * 
 * Note: All edges must be added to the graph before starting to add
 * edge sets, otherwise an exception of type TOPL_EX_ADD_EDGE_AFTER_SET
 * will be raised. This is for performance reasons. 
 *
 * Error Conditions:
 *  - If this edge contains fewer than 2 vertices, an exception of type
 *    TOPL_EX_TOO_FEW_VTX will be raised.
 *  - If the pointer to replication info is NULL, an exception of type
 *    TOPL_EX_NULL_POINTER will be raised.
 *  - If the edge type is not in the legal range (0..31), an exception of
 *    type TOPL_EX_INVALID_EDGE_TYPE will be raised.
 *  - If the the schedule in the replication info is invalid, an exception
 *    of type TOPL_EX_SCHEDULE_ERROR will be raised. Note that a NULL
 *    schedule is interpreted as an 'always schedule'.
 *  - Since this function allocates memory, an exception can be raised
 *    if memory is exhausted.
 */
PTOPL_MULTI_EDGE
ToplAddEdgeToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN DWORD numVtx,
    IN DWORD edgeType,
    IN PTOPL_REPL_INFO ri
    );


/***** ToplEdgeSetVtx *****/
/* This function is used to set the name of a vertex in an edge.
 * If edge e has n vertices, 'whichVtx' should be in the range
 * [0..n-1]. The vertex name should be set up by the user, and there
 * is no reason why it can't point to the same name object passed to
 * ToplMakeGraphState().
 *
 * Error conditions:
 * - If the multi-edge 'e' is not valid, an appropriate exception
 *   will be raised.
 * - If 'whichVtx' is out of range for this edge, or if 'vtxName' is
 *   not the name of a vertex in the graph, an exception of type
 *   TOPL_EX_INVALID_VERTEX will be raised.
 * - If 'vtxName' is NULL, an exception of type TOPL_EX_NULL_POINTER
 *   will be raised.
 */
VOID
ToplEdgeSetVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE e,
    IN DWORD whichVtx,
    IN PVOID vtxName
    );


/***** ToplAddEdgeSetToGraph *****/
/* Adds a single edge-set to the graph state. Edge sets define transitivity
 * for paths through the graph. When the spanning-tree algorithm searches for
 * paths between vertices, it will only allow paths for which all edges are in
 * an edge set. A given edge can appear in more than one edge set.
 *
 * The user is responsible for allocating and setting up the edge set. The user
 * should free this memory after deleting the graph state, G.
 */
VOID
ToplAddEdgeSetToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE_SET s
    );


/***** ToplGetSpanningTreeEdgesForVtx *****/
/* This function is the heart of the spanning-tree generation algorithm.
 * Its behavior is fairly complicated, but briefly it generates a minimum
 * cost spanning tree connecting the red and black vertices. It uses
 * edge sets and other (non-colored) vertices in the graph to determine how
 * the colored vertices can be connected. This function returns all tree edges
 * containing the filter vertex, 'whichVtx'.
 * 
 * Note: This function can be called many times for the same graph with
 * different sets of colored vertices.
 *
 * Note: If the graph is fully transitive, the caller must create the
 * appropriate edge-set containing all edges.
 *
 * Note: If whichVtxName is NULL, this function will return all edges in
 * the spanning tree.
 *
 * Note: It is possible that a full spanning tree could not be built if
 * the graph is not connected, or it was connected but some paths
 * were invalidated due to non-intersecting schedules or something.
 * This condition can be detected by examining the number of components 
 * in the graph. If the number of components is 1 then the spanning tree
 * was successfully built. If the number of components is > 1 then the
 * spanning tree does not connect all vertices.
 *
 * Detailed Description:
 * ---------------------
 * The first step is to find a set of paths P in G, which have the
 * following properties:
 *    - Let p be an path in P. Then both its endpoints are either red or black.
 *    - p is a shortest-path in G
 *
 * Build a new graph G', whose vertices are all red or black vertices. There
 * is an edge (u,v) in G' if there is a path in P with endpoints u and v.
 * The cost of this edge is the total cost of the path P. The various
 * replication parameters of P are combined to get replication parameters
 * for edge (u,v).
 *
 * Our goal is to find a spanning tree of G', with the following conditions:
 *    - Edges in G' with two red endpoints are considered cheaper than edges in
 *      P without two red endpoints.
 *    - Edges of a certain type may be disallowed by certain properties set
 *      at its endpoint vertices
 *    - The spanning tree is of minimum cost, under the above assumptions.
 *
 * For each edge in the spanning tree, if one of its endpoints is 'whichVtx',
 * we add this edge TOPL_MULTI_EDGE to the output stEdgeList. If at least one of the
 * endpoints of the edge are black and this edge is in a component containing at least
 * one red vertex, then this edge will have the 'fDirectedEdge' flag set. The vertices
 * will be ordered such that e->vertexNames[0] will be closer to a red vertex than
 * e->vertexNames[1]. 
 *
 * The array of spanning tree edges is then returned to the caller as the return
 * value of this function. The number of edges in the list is returned in
 * 'numStEdges'.
 *
 * Information about the graph components is returned in the pComponents
 * structure. The user needs to provide a pointer to a TOPL_COMPONENTS
 * structure, which will then be filled in by this function. The first graph
 * component in the list always contains the filter vertex, 'whichVtxName', if
 * one was provided. Each component is described with a number of vertices and
 * all list of the vertices in the component.
 *
 * Error Conditions:
 *  - If the graph state or the array of color vertices is NULL, an exception
 *    of type TOPL_EX_NULL_POINTER will be raised.
 *  - If the graph state is invalid, an exception of type
 *    TOPL_EX_GRAPH_STATE_ERROR will be raised.
 *  - If the list of color vertices has fewer than two entries, an exception
 *    of type TOPL_EX_COLOR_VTX_ERROR will be raised.
 *  - If an entry in the array of color vertices has a NULL name, an exception
 *    of type TOPL_EX_NULL_POINTER will be raised.
 *  - If an entry in the array of color vertices doesn't refer to a vertex in
 *    the graph, or if two entries describe the same vertex, or the color
 *    specified in the entry is neither red nor black, an error of type
 *    TOPL_EX_COLOR_VTX_ERROR will be raised.
 *  - If whichVtx, the vertex whose edges we want, is not in the graph, or if
 *    it was not colored red or black, an exception of type
 *    TOPL_EX_INVALID_VERTEX will be raised.
 *  - If we discover that schedules don't intersect in our shortest-paths,
 *    we raise an exception of type TOPL_EX_NONINTERSECTING_SCHEDULES.
 */
PTOPL_MULTI_EDGE*
ToplGetSpanningTreeEdgesForVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PVOID whichVtxName,
    IN TOPL_COLOR_VERTEX *colorVtx,
    IN DWORD numColorVtx,
    OUT DWORD *numStEdges,
    OUT PTOPL_COMPONENTS pComponents
    );


/***** ToplDeleteSpanningTreeEdges *****/
/* After finding the spanning-tree edges, this function should be used to
 * free their memory. */
VOID
ToplDeleteSpanningTreeEdges(
    PTOPL_MULTI_EDGE *stEdgeList,
    DWORD numStEdges
    );


/***** ToplDeleteComponents *****/
/* After finding the spanning-tree edges, this function should be used to
 * free the data describing the components */
VOID
ToplDeleteComponents(
    PTOPL_COMPONENTS pComponents
    );


/***** ToplDeleteGraphState *****/
/* After the ToplGraphState object is not needed any more, this function
 * should be used to free its memory. */
VOID
ToplDeleteGraphState(
    PTOPL_GRAPH_STATE g
    );


#ifdef __cplusplus
}
#endif


#endif W32TOPLSPANTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\_entryid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1986 - 1999
//
//  File:       _entryid.h
//
//--------------------------------------------------------------------------

/*
** --_entryid.h----------------------------------------------------------------
**
**  Header file describing internal structure of EntryIDs returned
**  by Exchange Address Book provider.
**
** ----------------------------------------------------------------------------
*/

#ifndef _ENTRYID_
#define _ENTRYID_

/*
 *  The version of this ABPs entryids
 */
#define EMS_VERSION         0x000000001

/*
 * The version of the entryids supported by the CreateEntry method in this 
 * ABP.
 */
#define NEW_OBJ_EID_VERSION 0x00000002

/*
 *  Valid values for the entry id's Type field are Mapi Display Types, plus:
 */
#define AB_DT_CONTAINER     0x000000100
#define AB_DT_TEMPLATE      0x000000101
#define AB_DT_OOUSER        0x000000102
#define AB_DT_SEARCH        0x000000200

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}

/*
 *  Directory entry id structure
 *
 *  This entryid is permanent.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _dir_entryid
#else
typedef struct _dir_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
} DIR_ENTRYID, FAR * LPDIR_ENTRYID;

#define CBDIR_ENTRYID sizeof(DIR_ENTRYID)

/*
 *  Mail user entry id structure
 *
 *  This entryid is ephemeral.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_entryid
#else
typedef struct _usr_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    DWORD dwEph;
} USR_ENTRYID, FAR * LPUSR_ENTRYID;

/*
 *  This entryid is permanent.
 */
/* turn off the warning for the unsized array */
#pragma warning (disable:4200)
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_permid
#else
typedef struct _usr_permid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    char  szAddr[];
} USR_PERMID, FAR * LPUSR_PERMID;
#pragma warning (default:4200)

#define CBUSR_ENTRYID sizeof(USR_ENTRYID)
#define CBUSR_PERMID sizeof(USR_PERMID)

#define EPHEMERAL   (UCHAR)(~(  MAPI_NOTRECIP      \
                              | MAPI_THISSESSION   \
                              | MAPI_NOW           \
                              | MAPI_NOTRESERVED))


#endif  /* _ENTRYID_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\c\pch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.c
//
//--------------------------------------------------------------------------

#include <ntdspch.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\_hindex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       _hindex.h
//
//--------------------------------------------------------------------------

/*
 * Constants used to refer to indices in the stat block used in the 
 * MAPI interface. 
 *
 */

/* NOTE: H_DISPLAYNAME_INDEX and H_WHEN_CHANGED_INDEX are the only ones
 * currently supported in a general way.  The others are for special
 * purpose code in the DSA itself.
 */

#define H_DISPLAYNAME_INDEX     0
#define H_WHEN_CHANGED_INDEX    1
#define H_PROXY_INDEX           2
#define AB_MAX_SUPPORTED_INDEX  2

#define H_READ_TABLE_INDEX   1000
#define H_WRITE_TABLE_INDEX  1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\cxx\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.cxx
//
//--------------------------------------------------------------------------

#include <ntdspchx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\client\ismapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismapi.c

ABSTRACT:

    Service-to-ISM (Intersite Messaging) service API.

DETAILS:

CREATED:

    97/11/26    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/


#include <ntdspch.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>

typedef RPC_BINDING_HANDLE ISM_HANDLE;

#define I_ISMUnbind(ph) RpcBindingFree(ph)

#ifdef DLLBUILD
// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

BOOL
WINAPI
DllEntryPoint(
    IN  HINSTANCE   hDll,
    IN  DWORD       dwReason,
    IN  LPVOID      pvReserved
    )
/*++

Routine Description:

    DLL entry point routine.  Initializes global DLL state on process attach.

Arguments:

    See "DllEntryPoint" docs in Win32 SDK.

Return Values:

    TRUE - Success.
    FALSE - Failure.

--*/
{
    static BOOL fFirstCall = TRUE;

    if (fFirstCall) {
        fFirstCall = FALSE;

        DEBUGINIT(0, NULL, "ismapi");
        DisableThreadLibraryCalls(hDll);
    }

    return TRUE;
}
#endif


DWORD
I_ISMBind(
    OUT ISM_HANDLE *    phIsm
    )
/*++

Routine Description:

    Bind to the local ISM service.

Arguments:

    phIsm (OUT) - On successful return, holds a handle to the local ISM
        service.  This handle can be used in subsequent IDL_ISM* calls.
        Caller is responsible for eventually calling I_ISMUnbind() on this
        handle.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD   err;
    UCHAR * pszStringBinding = NULL;
    // Quality of service structure to ensure authentication.
    RPC_SECURITY_QOS SecurityQOS = { 0 };
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID pSID = NULL;
    CHAR rgchName[128];
    LPSTR pszName = rgchName;
    DWORD cbName = sizeof(rgchName);
    CHAR rgchDomainName[128];
    LPSTR pszDomainName = rgchDomainName;
    DWORD cbDomainName = sizeof(rgchDomainName);
    SID_NAME_USE Use;

    *phIsm = NULL;

    // Specify quality of service parameters.
    SecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    // Dynamic identity tracking is more efficient for a single LRPC call.
    SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;

    RpcTryExcept {
        // Compose string binding for local ISM service via LPC.
        err = RpcStringBindingCompose(NULL, "ncalrpc", NULL,
                    ISMSERV_LPC_ENDPOINT, NULL, &pszStringBinding);
        if (RPC_S_OK != err) {
            __leave;
        }

        // Bind from string binding.
        err = RpcBindingFromStringBinding(pszStringBinding, phIsm);
        if (RPC_S_OK != err) {
            __leave;
        }

        // The server must be running under this identity
        // Change this to SECURITY_NETWORK_SERVICE_RID someday
        if (AllocateAndInitializeSid(&SIDAuth, 1,
                                     SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pSID) == 0) {
            err = GetLastError();
            __leave;
        }

        if (LookupAccountSid(NULL, // name of local or remote computer
                             pSID, // security identifier
                             pszName, // account name buffer
                             &cbName, // size of account name buffer
                             pszDomainName, // domain name
                             &cbDomainName, // size of domain name buffer
                             &Use) == 0) { // SID type
            err = GetLastError();
            __leave;
        }

        // Set authentication info using our process's credentials.

        // By speciying NULL for the 5th parameter we use the security login
        // context for the current address space.
        // The security level is "PRIVACY" since it is the only level
        // provided by LRPC.
        // We are assured of talking to a local service running with 
        // system privileges.

        err = RpcBindingSetAuthInfoEx(*phIsm, pszName,
                                      RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_WINNT,
                                      NULL, RPC_C_AUTHN_NONE,
                                      &SecurityQOS);
    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        err = RpcExceptionCode();

    } RpcEndExcept

    if (NULL != pszStringBinding) {
        RpcStringFree(&pszStringBinding);
    }

    if (pSID != NULL) {
        FreeSid( pSID );
    }

    if ((RPC_S_OK != err) && (NULL != *phIsm)) {
        RpcBindingFree(phIsm);
    }

    return err;
}


DWORD
I_ISMSend(
    IN  const ISM_MSG * pMsg,
    IN  LPCWSTR         pszServiceName,
    IN  LPCWSTR         pszTransportDN,
    IN  LPCWSTR         pszTransportAddress
    )
/*++

Routine Description:

    Sends a message to a service on a remote machine.  If the client specifies a
    NULL transport, the lowest cost transport will be used.

Arguments:

    pMsg (IN) - Data to send.

    pszServiceName (IN) - Service to which to send the message.

    pszTransportDN (IN) - The DN of the Inter-Site-Transport object
        corresponding to the transport by which the message should be sent.

    pszTransportAddress (IN) - The transport-specific address to which to send
        the message.
            
Return Values:

    NO_ERROR - Message successfully queued for send.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMSend(hIsm, pMsg, pszServiceName, pszTransportDN,
                              pszTransportAddress);
        } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMReceive(
    IN  LPCWSTR         pszServiceName,
    IN  DWORD           dwMsecToWait,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Receives a message addressed to the given service on the local machine.

    If successful and no message is waiting, immediately returns a NULL message.
    If a non-empty message is returned, the caller is responsible for
    eventually calling I_ISMFree(*ppMsg).

Arguments:

    pszServiceName (IN) - Service for which to receive the message.

    dwMsecToWait (IN) - Milliseconds to wait for message if none is immediately
        available; in the range [0, INFINITE].

    ppMsg (OUT) - On successful return, holds a pointer to the returned data, or
        NULL if none.

Return Values:

    NO_ERROR - Message successfully returned (or NULL returned, indicating no
        message is waiting).
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    *ppMsg = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMReceive(hIsm, pszServiceName, dwMsecToWait, ppMsg);
        } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}


void
I_ISMFree(
    IN  VOID *  pv
    )
/*++

Routine Description:

    Frees memory allocated on the behalf of the client by I_ISM* APIs.

Arguments:

    pv (IN) - Memory to free.

Return Values:

    None.

--*/
{
    if (NULL != pv) {
        MIDL_user_free(pv);
    }
}


DWORD
I_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppConnectivity) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppConnectivity = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMGetConnectivity(hIsm, pszTransportDN, ppConnectivity);
        } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMGetTransportServers(hIsm, pszTransportDN,
                                             pszSiteDN, ppServerList);
        } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN1, pszSiteDN2 (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppSchedule) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppSchedule = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMGetConnectionSchedule(hIsm, pszTransportDN,
                       pszSiteDN1, pszSiteDN2, ppSchedule);
        }
        RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMQuerySitesByCost(
    LPCWSTR                     pszTransportDN,     // in
    LPCWSTR                     pszFromSite,        // in
    DWORD                       cToSites,           // in
    LPCWSTR*                    rgszToSites,        // in
    DWORD                       dwFlags,            // in
    ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo         // out
    )
/*++

Routine Description:

    Determine the individual costs between the From site and the To sites.
    
    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszFromSite (IN) - The distinguished name of the From site.

    rgszToSites (IN) - An array containing the distinguished names of the To sites.

    cToSites (IN) - The number of entries in the rgszToSites array.

    dwFlags (IN) - Unused.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == prgSiteInfo) {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize the results
    *prgSiteInfo = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        RpcTryExcept {
            err = IDL_ISMQuerySitesByCost(hIsm, pszTransportDN,
                       pszFromSite, cToSites, rgszToSites,
                       dwFlags, prgSiteInfo);
        } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {
            err = RpcExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        } RpcEndExcept

        I_ISMUnbind(&hIsm);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\client\ismmidl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocc.c
//
//--------------------------------------------------------------------------

/*
File: allocc.c

Description:
    
    Routines to handle allocation and deallocation for the client
    side RPC.
    
    Note: the RPC system allows the different MIDL_user_allocate()
    routines on the client and server sides. The DSA uses a
    special implementation of these routines. The client
    side is a simple malloc/free combination. The server side
    uses the THAlloc*() routines.
*/

#pragma warning( disable:4114)  // "same type qualifier used more than once"
#include <NTDSpch.h>
#pragma hdrstop
#pragma warning( default:4114)

#include <memory.h>

#include "dsaalloc.h"

#ifdef DEBUG
/* gAllocated keeps track of the number of times that
the MIDL allocater is called. It is intended to help spot memory leaks.
*/

volatile int gAllocated = 0;
#endif

/*
MIDL_user_allocate

On the server stub side, called by the stub to allocate space for [in]
parameters. Upon return from the called proceedure, the stub will
call MIDL_user_free to deallocate this memory.

The server stub also presumes that this routine is called to allocate
memory for [out] parameters. Upon return from the called proceedure, the
stub will call MIDL_user_free to deallocate [out] parameters.
*/

void* __RPC_USER MIDL_user_allocate( size_t bytes )
{
    void*   ret;
    
    /* Keep track of the number of times the
    allocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated++;
#endif

    ret = malloc( (size_t) bytes );
    if ( ret == NULL ) {
        return( ret );
    } else {
        /* Zero out the memory */
        memset( ret, 0, (size_t) bytes );
    }
    
    /* Normal return */
    
    return( ret );
}


void __RPC_USER MIDL_user_free( void* memory )
{
    /* Keep track of the number of times the
    deallocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated--;
#endif
    free( memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\client\ism_client.c ===
#include <ism_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\inc\x_list.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

   xList Library - x_list.h

Abstract:

   This is the main interface header for the x_list.lib library, which provides
   a library for enumerating lists of things, the most common of which is a list 
   of DCs.

Author:

    Brett Shirley (BrettSh)

Environment:

    Single threaded utility environment.  (NOT Multi-thread safe)
    
    Currently only repadmin.exe used, but could be used by dcdiag too.

Notes:

Revision History:

    Brett Shirley   BrettSh     July 9th, 2002
        Created file.

--*/

          
// We use LDAP structures in this include file.                    
#include <winldap.h>

#ifdef __cplusplus
extern "C" {
#endif

// ------------------------------------------------
// xLists structures ...
// ------------------------------------------------
                    
typedef struct _XLIST_LDAP_SEARCH_STATE {
    LDAP *          hLdap;
    LDAPSearch *    pLdapSearch;
    LDAPMessage *   pCurResult;
    LDAPMessage *   pCurEntry;
} XLIST_LDAP_SEARCH_STATE;

typedef struct _DC_LIST {

    // Kind of search we're doing, using DcListIsSingleType()
    // to determine if the search type is guaranteed to only
    // return a single object.
    enum {
        eNoKind = 0, // need the null case

        eDcName = 1,// typical case ... single DC name.

        eWildcard,  // multi-DC list types ...
        eSite,
        eGc,

        eIstg,      // per Site (quasi-FSMO)
        eFsmoDnm,   // per Enterprise FSMO
        eFsmoSchema,// per Enterprise FSMO
        eFsmoIm,    // per NC FSMO
        eFsmoPdc,   // per Domain FSMO
        eFsmoRid    // per Domain FSMO
    } eKind;

    ULONG    cDcs; // Counter of number of DCs returned so far.

    WCHAR *  szSpecifier; // internal state.
    XLIST_LDAP_SEARCH_STATE * pSearch; // internal state.
} DC_LIST, * PDC_LIST;

typedef struct _OBJ_LIST {
    // internal state - tracking of user set search params
    WCHAR *  szUserSrchFilter;
    ULONG    eUserSrchScope;
    // 
    BOOL     fDnOnly;
    LDAP *   hLdap;
    WCHAR *  szSpecifier; // internal state.
    WCHAR ** aszAttrs;
    LDAPControlW ** apControls;
    XLIST_LDAP_SEARCH_STATE * pSearch; // internal state.
    ULONG    cObjs; // Count of objects returned.
} OBJ_LIST, * POBJ_LIST;

typedef struct _OBJ_DUMP_OPTIONS {
    DWORD     dwFlags;
    WCHAR **  aszDispAttrs;
    WCHAR **  aszFriendlyBlobs;
    WCHAR **  aszNonFriendlyBlobs;
    LDAPControlW ** apControls;
} OBJ_DUMP_OPTIONS;

// ------------------------------------------------
//    DcList API functions.
// ------------------------------------------------

//
// This is called on the DC_LIST syntax string.  This returns
// and allocates the ppDcList structure for useage with the
// DcListGetFirst()/DcListGetNext() functions.  Use DcListFree
// to free the structure when done with it.
//
DWORD
DcListParse(
    WCHAR *    szQuery,
    DC_LIST ** ppDcList
    );

//
// Returns the DNS string of the first DSA according the 
// pDcList query.  Use xListFree() to free the DNS name.
// Guaranteed to return a DSA DNS string or an error.
//
DWORD
DcListGetFirst(
    PDC_LIST    pDcList, 
    WCHAR **    pszDsa
    );

//
// Returns the DNS string of the next DSA according to the
// pDcList query.  Use xListFree() to free the DNS name
// returned.  This will return a NULL pointer in *pszDsa
// when we're done enumerating the list of DCs.
//
DWORD
DcListGetNext(
    PDC_LIST    pDcList, 
    WCHAR **    pszDsa
    );

//
// Used to clean up the *ppDcList allocated by DcListParse().
//
void
DcListFree(
    PDC_LIST * ppDcList
    );

//
// Quasi-function that just tells the caller if the pDcList
// is likely to be the kind of query that will return multiple
// DCs.
//
// NOTE: Easier to define single types as not the multi-dc types ...
#define DcListIsSingleType(pDcList)     (! (((pDcList)->eKind == eWildcard) || \
                                            ((pDcList)->eKind == eGc) || \
                                            ((pDcList)->eKind == eSite)) )

//
// THis takes a DC_NAME syntax and returns the DSA Guid of
// the DC specified by the DC_NAME.
//
DWORD
ResolveDcNameToDsaGuid(
    LDAP *    hLdap,
    WCHAR *   szDcName,
    GUID *    pDsaGuid
    );



// ------------------------------------------------
//    ObjList API functions.
// ------------------------------------------------

//
// These routines can give return lists of DNs or LDAPMessages for
// the objects you requested.  The idea is call ConsumeObjListOptions()
// to consume the command line options, and then call ObjListParse()
// on the OBJ_LIST syntaxed attribute, and then you're ready to call
// ObjListGetFirstXxxx()/ObjListGetNextXxxx() on your pObjList.  Call
// ObjListFree() to free all allocated memory for this OBJ_LIST.
//
void
ObjListFree(
    POBJ_LIST * ppObjList
    );

DWORD    
ConsumeObjListOptions(
    int *       pArgc,
    LPWSTR *    Argv,
    OBJ_LIST ** ppObjList
    );

// This is a global constant that tells LDAP to not return any attributes.
// Very helpful if you just want DNs and no attributes.
extern WCHAR * aszNullAttrs[];

DWORD
ObjListParse(
    LDAP *      hLdap,
    WCHAR *     szObjList,
    WCHAR **    aszAttrList,
    LDAPControlW ** apControls,
    POBJ_LIST * ppObjList
    );

#define ObjListGetFirstDn(pObjList, pszDn)       ObjListGetFirst(pObjList, TRUE, (void **) pszDn)
#define ObjListGetFirstEntry(pObjList, ppEntry)  ObjListGetFirst(pObjList, FALSE, (void **)ppEntry)
DWORD
ObjListGetFirst(
    POBJ_LIST    pObjList, 
    BOOL        fDn,
    void **     ppObjObj
    );

#define ObjListGetNextDn(pObjList, pszDn)       ObjListGetNext(pObjList, TRUE, (void **) pszDn)
#define ObjListGetNextEntry(pObjList, ppEntry)  ObjListGetNext(pObjList, FALSE, (void **)ppEntry)
DWORD
ObjListGetNext(
    POBJ_LIST    pObjList, 
    BOOL         fDn,
    void **      ppObjObj
    );



// ------------------------------------------------
//    ObjDump API functions.
// ------------------------------------------------

//
// This is some routines that are used to either dump attributes
// and objects to the string, or just convert and attribute value
// of a given type into an appropriately printable string.
//

// Some options used by repadmin ... GetChanges()
#define OBJ_DUMP_ACCUMULATE_STATS               (1 << 6)
#define OBJ_DUMP_DISPLAY_ENTRIES                (1 << 7)
//
// Individual (per) value flags
//
#define OBJ_DUMP_VAL_DUMP_UNKNOWN_BLOBS         (1 << 3)
#define OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS       (1 << 1)
#define OBJ_DUMP_VAL_LONG_BLOB_OUTPUT           (1 << 2)
//
// Individual (per) attribute flags ...
//      
#define OBJ_DUMP_ATTR_LONG_OUTPUT               (1 << 0)
#define OBJ_DUMP_ATTR_SHOW_ALL_VALUES           (1 << 4)
// Only used for private blobs
#define OBJ_DUMP_PRIVATE_BLOBS                  (1 << 5)

//
// This takes one value it's attribute and the objectClass of the object
// you found it on, and turns it into a nice printable string or sets
// an xListError ...
//
DWORD
ValueToString(
    WCHAR *         szAttr,
    WCHAR **        aszzObjClasses,
    PBYTE           pbValue,
    DWORD           cbValue,
    OBJ_DUMP_OPTIONS * pObjDumpOptions,
    WCHAR **        pszDispValue
    );

// 
// This consumes the command line arguments for the search options
// that might be present for an OBJ_LIST.
//
DWORD
ConsumeObjDumpOptions(
    int *       pArgc,
    LPWSTR *    Argv,
    DWORD       dwDefaultFlags,
    OBJ_DUMP_OPTIONS ** ppObjDumpOptions
    );

// 
// This takes an array of values (BERVALs) and dumps them to the
// screen.
//
void
ObjDumpValues(
    LPWSTR              szAttr,
    LPWSTR *            aszzObjClasses,
    void              (*pfPrinter)(ULONG, WCHAR *, void *),
    struct berval **    ppBerVal,
    DWORD               cValuesToPrint,
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    );

// 
// This is the uber dump function.  This function will dump an entire
// object to the screen given it's LDAPMessage (pEntry).
//
DWORD
ObjDump( // was display entries or something
    LDAP *              hLdap,
    void                (*pfPrinter)(ULONG, WCHAR *, void *),
    LDAPMessage *       pLdapEntry,
    DWORD               iEntry,
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    );

// 
// Free's the memory allocated by ConsumeObjDumpOptions().
//
void
ObjDumpOptionsFree(
    OBJ_DUMP_OPTIONS ** ppDispOptions
    );


// 
// These two routines added to header to support ntdsutil.
//

//
// Take a ranged attribute "member:0-1500" and give you the true attr "member"
//
DWORD
ParseTrueAttr(
    WCHAR *  szRangedAttr,
    WCHAR ** pszTrueAttr
    );

//
// Dumps as many values of the specified ranged attribute as you specify.
//
DWORD
ObjDumpRangedValues(
    LDAP *              hLdap,
    WCHAR *             szObject,
    LPWSTR              szRangedAttr,
    LPWSTR *            aszzObjClasses,
    void              (*pfPrinter)(ULONG, WCHAR *, void *),
    struct berval **    ppBerVal,
    DWORD               cValuesToPrint,
    OBJ_DUMP_OPTIONS *  pObjDumpOptions
    );

// ------------------------------------------------
// Generic xList Library Functions
// ------------------------------------------------

//
// Used to clean up non-complex structures returned by the x_list APIs.
//
void  xListFree(void * pv);

//
// Used to clean up anything left allocated, or globally cached by the
// xList API.  This should be called if any xList API call is made.  Calling
// this function is harmless if no xList APIs were called.
//
DWORD xListCleanLib(void);

//
// This is used to allow the client to set a hint to tell the xList API
// what home server should be used for a reference of how to resolve
// a given DC_LIST, and perhaps other list types.
//
DWORD xListSetHomeServer(
    WCHAR *   szServer
    );


// ------------------------------------------------
// xList Error Handling Facilities
// ------------------------------------------------

// Notes on errors for all xList API functions.  Nearly all xList API functions
// return an xList Return Code, which is nothing like a normal Win32 or LDAP 
// error.  If the return code equals 0, then there is no problem, however if
// the error is non-zero, the caller should call xListGetError(...) to get all
// the error data to decide what to do.  One of the codes returned from this 
// function is *pdwReason, which is intended for the caller to be able to tell
// the user some sort of intelligent error code.

// 
// These are the reasons xList routines can fail.
//
#define  XLIST_ERR_NO_ERROR                     (0)
#define  XLIST_ERR_CANT_CONTACT_DC              (1)
#define  XLIST_ERR_CANT_LOCATE_HOME_DC          (2)
#define  XLIST_ERR_CANT_RESOLVE_DC_NAME         (3)
#define  XLIST_ERR_CANT_RESOLVE_SITE_NAME       (4)
#define  XLIST_ERR_CANT_GET_FSMO                (5)
#define  XLIST_ERR_PARSE_FAILURE                (6)
#define  XLIST_ERR_BAD_PARAM                    (7)
#define  XLIST_ERR_NO_MEMORY                    (8)
#define  XLIST_ERR_NO_SUCH_OBJ                  (9)

// ObjDump errors ...
#define  XLIST_ERR_ODUMP_UNMAPPABLE_BLOB        (10)
#define  XLIST_ERR_ODUMP_NEVER                  (11)
#define  XLIST_ERR_ODUMP_NONE                   (12)

// <---  new XLIST ERROR reasons go here, and update XLIST_ERR_LAST
#define  XLIST_ERR_LAST                        XLIST_ERR_ODUMP_NEVER

//
// These are the basic print routines for the ObjDump APIs
//
#define  XLIST_PRT_BASE                         (4096)
#define  XLIST_PRT_STR                          (XLIST_PRT_BASE + 1)
#define  XLIST_PRT_OBJ_DUMP_DN                  (XLIST_PRT_BASE + 2)
#define  XLIST_PRT_OBJ_DUMP_DNGUID              (XLIST_PRT_BASE + 3)
#define  XLIST_PRT_OBJ_DUMP_DNGUIDSID           (XLIST_PRT_BASE + 4)
#define  XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT      (XLIST_PRT_BASE + 5)
#define  XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED (XLIST_PRT_BASE + 6)
#define  XLIST_PRT_OBJ_DUMP_MORE_VALUES         (XLIST_PRT_BASE + 7)

// <---  new XLIST print definitions go here, and update where they might be used.


// 
// These are the error accessing routines.
//

//
// This is used to grab the full error state of the xList library.  If an
// xList API returns a xList Return Code that is non-zero, the API can call
// this to get the original Win32 or LDAP error condition that caused the 
// problem, and the reason (XLIST_ERR_*) this caused us to fail the function.
// None of these values need to be cleaned up, simply call xListClearErrors().
//
void xListGetError(DWORD dwXListReturnCode, DWORD * pdwReason, WCHAR ** pszReasonArg, DWORD * pdwWin32Err, DWORD * pdwLdapErr, WCHAR ** pszLdapErr, DWORD * pdwLdapExtErr, WCHAR ** pszLdapExtErr, WCHAR **pszExtendedErr);

//
// This is used to clean the global error state of the xList API.  The client
// should ensure they always call this API when a non zero xList Return Code
// is returned from a xList API function.
//
void xListClearErrors(void);

//
// Quasi function to get just the xList Reason code, this is so that code 
// can just decide what to do based on the xList reason code.
//
#define  XLIST_REASON_MASK              (0x0000FFFF)
#define  XLIST_LDAP_ERROR               (0x80000000)
#define  XLIST_WIN32_ERROR              (0x40000000)
#define  xListReason(dwRet)             ((dwRet) & XLIST_REASON_MASK)
#define  xListErrorCheck(dwRet)         ((xListReason(dwRet) <= XLIST_ERR_LAST) || \
                                         ((dwRet) & 0x80000000) || \
                                         ((dwRet) & 0x40000000))

// ------------------------------------------------
// xList Credentials
// ------------------------------------------------

//
// The way we treat the credentials is we expect a pointer gpCreds to be
// available in the binary we're linking with.  This should be a pointer
// to an RPC_AUTH_IDENTITY_HANDLE.
//


// ------------------------------------------------
// Utility Functions
// ------------------------------------------------

//
// These functions are just part of the xList library as a measure of
// convience.  These functions are unlike all the above xList APIs because
// they don't set xList errors, require xListFree, xListCleanLib(), etc.
// These are just the simpliest utility functions that usually LocalAlloc()
// memory and return Win32 error codes...
//

// This is just a utility function that takes an arg index, and adjusts the 
// array of strings (arguments) and arg count appropriately.
void
ConsumeArg(
    int         iArg,
    int *       pArgc,
    LPWSTR *    Argv
    );

/*
BOOL
IsDisplayable(
    PBYTE    pbValue,
    DWORD    cbValue
    );
*/    

// This takes a certain format of attribute list ( "systemFlags,objectClass,etc" )
// and turns it into a NULL terminated array of strings.  Use xListFree() to 
// clear it afterwards.
DWORD
ConvertAttList(
    LPWSTR      pszAttList,
    PWCHAR **   paszAttList
    );

// Takes a tartget (szAttr) and checks to see if it exists in the NULL terminated
// list of strings.
BOOL
IsInNullList(
    WCHAR *  szTarget,
    WCHAR ** aszList
    );

// Some useful quasi-functions.
#define wcsequal(str1, str2)    (0 == _wcsicmp((str1), (str2)))
#define wcsprefix(arg, target)  (0 == _wcsnicmp((arg), (target), wcslen(target)))
#define set(flags, flag)        (flags) |= (flag)
#define unset(flags, flag)      (flags) &= (~(flag))
#define wcslencb(p)             ((wcslen(p) + 1) * sizeof(WCHAR))


/*++

Routine Description:

    This quasi-routine is so large it deserves a function header.  This "function" gets
    expanded inline, and does basically one thing, but catches all the special cases.
    
    The function copies a string form szOrig to szCopy.  If there is an error in the copy,
    the error is set in dwRet, and then the FailAction is performed (INLINED).  So in a
    try { } __finally {} once could say something like this:
    
        WCHAR * szSomeUnallocatedPtr = NULL;
        QuickStrCopy(szSomeUnallocdPtr, szStringOfInterest, MyErrVar, __leave);
        
    and then on error we'd drop all the way to the __finally, but on success, we'd 
    continue on, which is usually what the code wants to do.

Arguments:

    szCopy - A pointer to WCHARs.  Remember since this is expanded inlined you can just
        pass by value "szVar".  The variable will be LocalAlloc()'d
    szOrig - The string to copy.
    dwRet - The variable to set on error.
    FailAction - The action to perform (usually "__leave" or "return(dwRet)" in case
        of a failure/error.

--*/
#define  QuickStrCopy(szCopy, szOrig, dwRet, FailAction) \
                                        if (szOrig) { \
                                            DWORD cbCopy = (1+wcslen(szOrig)) * sizeof(WCHAR); \
                                            (szCopy) = LocalAlloc(LMEM_FIXED, cbCopy); \
                                            if ((szCopy) == NULL) { \
                                                dwRet = GetLastError(); \
                                                if (dwRet == ERROR_SUCCESS) { \
                                                    Assert(!"Huh"); \
                                                    dwRet = ERROR_DS_CODE_INCONSISTENCY; \
                                                } \
                                                FailAction; \
                                            } else { \
                                                dwRet = HRESULT_CODE(StringCbCopyW((szCopy), cbCopy, (szOrig))); \
                                                if (dwRet) { \
                                                    Assert(!"Code inconsistency"); \
                                                    FailAction; \
                                                } \
                                            } \
                                        } else { \
                                            Assert(!"Code inconsistency"); \
                                            dwRet = ERROR_DS_CODE_INCONSISTENCY; \
                                            szCopy = NULL; \
                                            FailAction; \
                                        }


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

UNICODE=1

SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)
PRIVINC = $(DS_INC_PATH)

INCS = -I$(SDKINC) -I$(SDKCRTINC) -I$(PRIVINC) -Iinclude

EXTRN_DEPENDS = $(SDKINC)\winbase.h \
                $(SDKINC)\windef.h

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H -DMIDL_PASS
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"

#
# MIDL COMPILE
#

$(O)\ism.h $(O)\ism_c.c $(O)\ism_s.c: .\ism.idl .\ism.acf $(SDKINC)\ismapi.h $(EXTRN_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext -out .\$(O) $(CPP) $(INCS) .\ism.idl

$(O)\seo.h $(O)\seo_i.c: $(INETSRV_INC_PATH)\seo.idl
    midl -Oicf -robust -error all -ms_ext -c_ext -out .\$(O) $(CPP) $(INCS) $(INETSRV_INC_PATH)\seo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\include\memory.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Debug memory allocator.
    Checks for heap corruption.
    Reports memory not deallocated

    User interface:
    ptr = NEW_TYPE( type )
    ptr = NEW_TYPE_ARRAY( count, type )
    ptr = NEW_TYPE_ZERO( type )
    ptr = NEW_TYPE_ARRAY_ZERO( count, type )
    TYPE_FREE( ptr )

Author:

    Will Lees (wlees) 23-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _MEMORY_
#define _MEMORY_

#ifdef __cplusplus
extern "C" {
#endif

/* Prototypes */
/* End Prototypes */

// memory.c

void
DebugMemoryInitialize(
    void
    );

void
DebugMemoryTerminate(
    void
    );

#if DBG
PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define NEW_TYPE( type ) (type *) DebugMemoryAllocate( sizeof( type ), __FILE__, __LINE__ )
#define NEW_TYPE_ARRAY( count, type ) (type *) DebugMemoryAllocate( (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define NEW_TYPE( type ) (type *) malloc( sizeof( type ) )
#define NEW_TYPE_ARRAY( count, type ) (type *) malloc( (count) * sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
PVOID
DebugMemoryReallocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define REALLOC_TYPE( p, type ) (type *) DebugMemoryReallocate( p, sizeof( type ), __FILE__, __LINE__ )
#define REALLOC_TYPE_ARRAY( p, count, type ) (type *) DebugMemoryReallocate( p, (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define REALLOC_TYPE( p, type ) (type *) realloc( p, sizeof( type ) )
#define REALLOC_TYPE_ARRAY( p, count, type ) (type *) realloc( p, (count) * sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define NEW_TYPE_ZERO( type ) (type *) DebugMemoryAllocateZero( sizeof( type ), __FILE__, __LINE__ )
#define NEW_TYPE_ARRAY_ZERO( count, type ) (type *) DebugMemoryAllocateZero( (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define NEW_TYPE_ZERO( type ) (type *) calloc( 1, sizeof( type ) )
#define NEW_TYPE_ARRAY_ZERO( count, type ) (type *) calloc( (count), sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );
#define MEMORY_CHECK( p ) DebugMemoryCheck( p, __FILE__,__LINE__ )
#else
#define MEMORY_CHECK( p )
#endif

#if DBG
void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );
#define FREE_TYPE( p ) DebugMemoryFree( p, __FILE__, __LINE__ )
#else
#define FREE_TYPE( p ) free( p )
#endif

#if DBG
void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    );
#define MEMORY_CHECK_ALL( ) DebugMemoryCheckAll( __FILE__, __LINE__ )
#else
#define MEMORY_CHECK_ALL()
#endif

#ifdef __cplusplus
}
#endif

#endif /* _MEMORY_ */

/* end memory.h */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\include\common.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    common.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _COMMON_H_INCLUDED_
#define _COMMON_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

#include "memory.h"         // debug memory allocator
#include <wtypes.h>         // BSTR
#include <w32topl.h>

#ifndef MAX
#define MAX( a, b ) ( (a > b) ? a : b)
#endif

// Time support

typedef LONGLONG DSTIME;

// Generic table entry

typedef struct _TABLE_INSTANCE *PTABLE_INSTANCE;

typedef struct _TABLE_ENTRY {
    LPWSTR Name;
    struct _TABLE_ENTRY *Next;
} TABLE_ENTRY, *PTABLE_ENTRY;

// Long-lived routing state
// This is kept in the transport handle for lifetime reasons, but it is
// managed by the routing package.

// TODO: Make this an opaque handle managed inside the routing package
typedef struct _ROUTING_STATE {
    volatile BOOL fCacheIsValid;
    DWORD NumberSites;
    LPWSTR *pSiteList;
    struct _GRAPH_INSTANCE *CostGraph;
    struct _TABLE_INSTANCE *SiteSymbolTable;
} ROUTING_STATE, *PROUTING_STATE;

typedef struct _SMTP_INSTANCE {
    LPWSTR  pszSmtpAddress;
    PVOID pvCurrentCollection;
    LONG lCount;
    BSTR bstrDropDirectory;
    PVOID pvGuidTable;
} SMTP_INSTANCE;

typedef struct _IP_INSTANCE {
    DWORD dwReserved;
} IP_INSTANCE;

// Contains configuration info for each named transport passed to the
// Startup API

typedef struct _TRANSPORT_INSTANCE {
    DWORD Size;
    DWORD ReferenceCount;
    LPWSTR Name;
    LIST_ENTRY ListEntry;
    CRITICAL_SECTION Lock;
    PVOID DirectoryConnection;
    HANDLE ListenerThreadHandle;      // Handle on listener thread
    LONG ListenerThreadID;            // TID of listener thread
    volatile BOOLEAN fShutdownInProgress;      // Flag to indicate listener thread should exit
    HANDLE hShutdownEvent;            // Signalled when asked to shut down
    LIST_ENTRY ServiceListHead;       // Server-side list of services seen
    DWORD ServiceCount;               // Count of services that have left msg
    ISM_NOTIFY *pNotifyFunction;
    HANDLE hNotify;
    ROUTING_STATE RoutingState;
    DWORD Options;                    // Transport options, from trans object
    DWORD ReplInterval;               // Default repliation interval
    DWORD NotifyMessageNumber;        // LDAP notification message number
    HANDLE NotifyThreadHandle;        // Handle on notification thread
    union {
        IP_INSTANCE Ip;           // IP-specific port for this instance to use
        SMTP_INSTANCE Smtp;           // SMTP-specific info for this instance
    };
} TRANSPORT_INSTANCE, *PTRANSPORT_INSTANCE;

// This is a opaque graph descriptor

typedef struct _GRAPH_INSTANCE *PISMGRAPH;

// Max Registry path

#define MAX_REG_PATH 1024
#define MAX_REG_COMPONENT 255

// Cost array

#define INFINITE_COST 0xffffffff

// Limit on number of services which can be buffered

#define ISM_MAX_SERVICE_LIMIT 10

// route.c

// Routing flags.

#define ROUTE_IGNORE_SCHEDULES  (NTDSTRANSPORT_OPT_IGNORE_SCHEDULES)
    // Schedules on siteLink objects will be ignored. (And the "ever-present"
    // schedule is assumed.)

#define ROUTE_BRIDGES_REQUIRED  (NTDSTRANSPORT_OPT_BRIDGES_REQUIRED)
    // siteLinks must be explicitly bridged with siteLinkBridge objects to
    // indicate transitive connections. Otherwise, siteLink transitivity is
    // assumed.

// Routing API.

VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    );

DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
RouteQuerySitesByCost(
    PTRANSPORT_INSTANCE         pTransport,
    LPCWSTR                     pszFromSite,
    DWORD                       cToSites,
    LPCWSTR*                    rgszToSites,
    DWORD                       dwFlags,
    ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo
    );

VOID
RouteFreeSiteCostInfo(
    IN ISM_SITE_COST_INFO_ARRAY*   prgSiteInfo
    );

// graph.c

DWORD
GraphAllCosts(
    PISMGRAPH CostArray,
    BOOL fIgnoreSchedules
    );

DWORD
GraphMerge(
    PISMGRAPH FinalArray,
    PISMGRAPH TempArray
    );

PISMGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    );

DWORD
GraphAddEdgeIfBetter(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

DWORD
GraphInit(
    PISMGRAPH Graph
    );

void
GraphFree(
    PISMGRAPH Graph
    );

void
GraphPeekMatrix(
    PISMGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

void
GraphReferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

VOID
GraphDereferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK pLinkArray
    );

DWORD
GraphGetPathSchedule(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *pSchedule,
    DWORD *pLength
    );

// dirobj.c

DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    );

DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    );

DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    );

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    );

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    );

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    );

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    );

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    );

void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    );

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    );

DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    );

void
DirFreeMultiszString(
    LPWSTR MultiszString
    );

void
DirFreeSchedule(
    PBYTE pSchedule
    );

DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    );

DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirRegisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT HANDLE *              phServerChanges
    );

DWORD
DirWaitForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirUnregisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

// table

PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    );

VOID
TableFree(
    PTABLE_INSTANCE Table
    );

PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    );

// list

typedef struct _LIST_ENTRY_INSTANCE {
    LPWSTR Name;
    LIST_ENTRY ListEntry;
} LIST_ENTRY_INSTANCE, *PLIST_ENTRY_INSTANCE;

typedef DWORD (__cdecl LIST_CREATE_CALLBACK_FN)(
    PLIST_ENTRY_INSTANCE pListEntry
    );

typedef DWORD (__cdecl LIST_DESTROY_CALLBACK_FN)(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    );

DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroyFunction,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    );


#ifdef __cplusplus
}
#endif

#endif /* _COMMON_H_INCLUDED_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\clienttest\ismtest.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismtest.c

ABSTRACT:

    Test utility for the Intersite Messaging service.

DETAILS:

CREATED:

    97/12/10    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ismapi.h>

#include <schedule.h>


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tue","Wed","Thu","Fri","Sat"};

    printf( "day: 0123456789ab0123456789ab\n" );
    for( day = 0; day < 7; day++ ) {
        printf( "%s: ", dow[day] );
        for( hour = 0; hour < 24; hour++ ) {
            printf( "%x", (*data & 0xf) );
            data++;
        }
        printf( "\n" );
    }
}

int
__cdecl
wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    BOOL        fDisplayUsage = FALSE;
    BOOL        fSend = FALSE;
    BOOL        fReceive = FALSE;
    BOOL        fConnect = FALSE;
    BOOL        fServers = FALSE;
    BOOL        fSchedule = FALSE;
    LPWSTR      pszColon;
    LPWSTR      pszFile = NULL;
    LPWSTR      pszService = NULL;
    LPWSTR      pszTransport = NULL;
    LPWSTR      pszAddress = NULL;
    LPWSTR      pszSite1 = NULL;
    LPWSTR      pszSite2 = NULL;
    LPWSTR      pszSubject = NULL;
    int         iArg;
    BOOL        fSuccess = FALSE;
    HANDLE      hFile;
    ISM_MSG     msg = {0};
    ISM_MSG *   pmsg = NULL;
    DWORD       err;
    DWORD       cbActual;
    DWORD       dwTimeout = 0;

    for (iArg = 1; iArg < argc; iArg++) {
        switch (argv[iArg][0]) {
          case '/':
          case '-':
            // An option.
            pszColon = wcschr(&argv[iArg][1], ':');

            if (NULL == pszColon) {
                if (!lstrcmpiW(&argv[iArg][1], L"send")) {
                    fSend = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"receive")) {
                    fReceive = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"connect")) {
                    fConnect = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"servers")) {
                    fServers = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"schedule")) {
                    fSchedule = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"?")
                         || !lstrcmpiW(&argv[iArg][1], L"h")
                         || !lstrcmpiW(&argv[iArg][1], L"help")) {
                    fDisplayUsage = TRUE;
                    break;
                }
            }
            else {
                *pszColon = '\0';
                
                if (!lstrcmpiW(&argv[iArg][1], L"file")) {
                    pszFile = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"service")) {
                    pszService = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"transport")) {
                    pszTransport = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"address")) {
                    pszAddress = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"site")) {
                    pszSite1 = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"site2")) {
                    pszSite2 = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"subject")) {
                    pszSubject = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"timeout")) {
                    if (!lstrcmpiW(pszColon + 1, L"infinite")) {
                        dwTimeout = INFINITE;
                    }
                    else {
                        dwTimeout = _wtoi(pszColon + 1);
                    }
                    break;
                }
            }
            // Not a valid option if we're here.  Fall through....

          default:
            printf("Unrecognized parameter \"%ls\".\n", argv[iArg]);
            fDisplayUsage = TRUE;
            break;
        }
    }

    if (fDisplayUsage) {
        printf("\n"
               "Intersite Messaging Service Test Client\n"
               "Copyright (c) 1997 Microsoft Corporation.\n"
               "All rights reserved.\n"
               "\n"
               "Usage: %ls {operation} [paramaters...],\n"
               "where {operation} is one of:\n"
               "    /send     - Send a message.\n"
               "    /receive  - Retreieve a waiting message.\n"
               "    /connect  - Retrieve transport-specific site connectivity information.\n"
               "    /servers  - Get the servers in a site capable of using a given transport.\n"
               "    /schedule - Query for the schedule by which two sites are connected.\n"
               "and [parameters...] are composed of the following:\n"
               "    /file:{filename} - Holds message data.\n"
               "    /service:{service name}\n"
               "    /transport:{interSiteTransport object DN}\n"
               "    /address:{transport-specific address}\n"
               "    /site:{site object DN}\n"
               "    /site2:{site object DN}\n"
               "    /subject:{string}\n"
               "    /timeout:infinite|{timeout_in_msec}\n",
               argv[0]);
    }
    else if (fSend && !fReceive && !fConnect && !fServers && !fSchedule) {
        if (NULL != pszFile) {
            hFile = CreateFileW(pszFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

            if (INVALID_HANDLE_VALUE != hFile) {
                msg.cbData = GetFileSize(hFile, NULL);

                if (0xFFFFFFFF != msg.cbData) {
                    msg.pbData = LocalAlloc(LMEM_FIXED, msg.cbData);

                    fSuccess = (NULL != msg.pbData)
                               && ReadFile(hFile, msg.pbData, msg.cbData, &cbActual, NULL)
                               && (cbActual == msg.cbData);
                }

                CloseHandle(hFile);
            }
            msg.pszSubject = pszSubject;  // may be null
            if (fSuccess) {
                err = I_ISMSend(&msg, pszService, pszTransport, pszAddress);
                
                if (NO_ERROR == err) {
                    printf("%d bytes sent.\n", msg.cbData);
                }
                else {
                    printf("I_ISMSend failed, error %d.\n", err);
                }
            }
            else {
                printf("Failed to read file \"%ls\", error %d.\n",
                       pszFile, GetLastError());
            }

            if (NULL != msg.pbData) {
                LocalFree(msg.pbData);
            }
        }
        else {
            printf("Must specify /file.\n");
        }
    }
    else if (!fSend && fReceive && !fConnect && !fServers && !fSchedule) {
        if (NULL != pszFile) {
            err = I_ISMReceive(pszService, dwTimeout, &pmsg);
            
            if (NO_ERROR == err) {
                if (NULL == pmsg) {
                    printf("No message waiting.\n");
                }
                else {
                    hFile = CreateFileW(pszFile,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

                    fSuccess = (NULL != hFile)
                               && WriteFile(hFile, pmsg->pbData, pmsg->cbData, &cbActual, NULL)
                               && (cbActual == pmsg->cbData);

                    CloseHandle(hFile);

                    if (pmsg->pszSubject) {
                        printf( "Subj: '%ws'\n", pmsg->pszSubject );
                    } else {
                        printf( "no subject string present.\n" );
                    }

                    if (fSuccess) {
                        printf("%d bytes received.\n", pmsg->cbData);
                    }
                    else {
                        printf("Failed to write file \"%ls\", error %d.\n",
                               pszFile, GetLastError());
                    }

                    I_ISMFree(pmsg);
                }
            }
            else {
                printf("I_ISMReceive failed, error %d.\n", err);
            }
        }
        else {
            printf("Must specify /file.\n");
        }
    }
    else if (!fSend && !fReceive && fConnect && !fServers && !fSchedule) {
        ISM_CONNECTIVITY * pSiteConnect;
        DWORD iSite1, iSite2;

        err = I_ISMGetConnectivity(pszTransport, &pSiteConnect);
        
        if (NO_ERROR == err) {
            printf("Received connectivity information for %d sites:\n\n", pSiteConnect->cNumSites);


            for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                printf( "%s%4d", iSite2 ? ", " : "     ", iSite2 );
            }
            printf("\n");
            for (iSite1 = 0; iSite1 < pSiteConnect->cNumSites; iSite1++) {
                printf("(%2d) %ls\n", iSite1, pSiteConnect->ppSiteDNs[iSite1]);
                for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                    PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

                    printf("%s%d:%d", iSite2 ? ", " : "     ",
                           pLink->ulCost, pLink->ulReplicationInterval );

                }
                printf("\n");
            }
        }
        else {
            printf("I_ISMGetConnectivity() failed, error %d.\n", err);
        }        
    }
    else if (!fSend && !fReceive && !fConnect && fServers && !fSchedule) {
        ISM_SERVER_LIST * pServerList;
        DWORD iServer;

        err = I_ISMGetTransportServers(pszTransport, pszSite1, &pServerList);
        
        if (NO_ERROR == err) {
            if (NULL == pServerList) {
                printf("All DCs in the site (with a transport address) are reachable.\n");
            }
            else {
                for (iServer = 0; iServer < pServerList->cNumServers; iServer++) {
                    printf("%d server(s) are defined as bridgeheads for this transport & site:\n\n",
                           pServerList->cNumServers);
                    printf("(%2d) %ls\n", iServer, pServerList->ppServerDNs[iServer]);
                }
            }
        }
        else {
            printf("I_ISMGetTransportServers() failed, error %d.\n", err);
        }        
    }
    else if (!fSend && !fReceive && !fConnect && !fServers && fSchedule) {
        ISM_SCHEDULE * pSchedule;
        DWORD iServer;

        err = I_ISMGetConnectionSchedule(pszTransport, pszSite1, pszSite2, &pSchedule);
        
        if (NO_ERROR == err) {
            if (NULL == pSchedule) {
                printf("Connection is always available.\n");
            }
            else {
                printSchedule( pSchedule->pbSchedule );
            }
        }
        else {
            printf("I_ISMGetTransportServers() failed, error %d.\n", err);
        }        
    }
    else {
        printf("Must specify exactly one of /send, /receive, /connect, /servers, or /schedule.\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\ism_server.c ===
#include <ism_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\pending.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    pending.cxx

ABSTRACT:

    ISM_PENDING_LIST class.  Tracks pending messages for a specific transport.

DETAILS:

CREATED:

    97/01/13    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>
#include <fileno.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <mdcodes.h>
#include "ismserv.hxx"

#define DEBSUB "PENDING:"
#define FILENO FILENO_ISMSERV_PENDING


void
ISM_PENDING_LIST::Add(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        pPending = GetPendingEntry(pszTransportDN, pszServiceName);

        if (NULL != pPending) {
            SetEvent(pPending->hEvent);
        }
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }
}


HANDLE
ISM_PENDING_LIST::GetEvent(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;
    HANDLE              hEvent = NULL;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        pPending = GetPendingEntry(pszTransportDN, pszServiceName);

        if (NULL != pPending) {
            hEvent = pPending->hEvent;
        }
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }

    return hEvent;
}


void
ISM_PENDING_LIST::Destroy()
{
    ISM_PENDING_ENTRY * pPending;
    ISM_PENDING_ENTRY * pPendingNext;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        for (pPending = m_pPending; NULL != pPending; pPending = pPendingNext) {
            pPendingNext = pPending->pNext;
            delete pPending;
        }

        m_pPending = NULL;
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }
}



LPWSTR
buildEventName(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

Construct an event name based on the transport dn and the service name

Use only the first RDN of the transport DN.

The constructed name looks like:

_NT_DS_ISM_<transport rdn><service name>

Arguments:

    pszTransportDN - 
    pszServiceName - 

Return Value:

    LPWSTR - allocated event name string, or null on error

--*/

{
#define EVENT_NAME_PREFIX L"_NT_DS_ISM_"
    LPWSTR eventName, start, end;
    DWORD length, total;

    Assert( pszTransportDN );
    Assert( pszServiceName );

    // Extract the first RDN.  If we can't find the separators, use the whole
    start = wcschr( pszTransportDN, L'=' );
    if (start) {
        pszTransportDN = start + 1;
        end = wcschr( pszTransportDN, L',' );
        if (end) {
            length = (DWORD)(end - pszTransportDN);
        } else {
            length = wcslen( pszTransportDN );
        }
    } else {
        DPRINT1( 0, "Malformed transport dn, %ws\n", pszTransportDN );
        LogEvent(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_DS_BAD_NAME_SYNTAX,  
            szInsertWC(pszTransportDN),
            szInsertWC(pszServiceName),
            NULL
            );
        return NULL;
    }

    total = wcslen( EVENT_NAME_PREFIX ) +
        length +
        wcslen( pszServiceName ) +
        1;

    eventName = new WCHAR [total];
    if (eventName == NULL) {
        DPRINT( 0, "Memory allocation failed\n" );
        LogEvent(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_NOT_ENOUGH_MEMORY,  
            szInsertWC(pszTransportDN),
            szInsertWC(pszServiceName),
            NULL 
            );
        return NULL;
    }

    start = eventName;
    wcsncpy( start, EVENT_NAME_PREFIX, wcslen( EVENT_NAME_PREFIX ) );
    start += wcslen( EVENT_NAME_PREFIX );
    wcsncpy( start, pszTransportDN, length );
    start += length;
    wcscpy( start, pszServiceName );

    DPRINT1( 3, "buildEventName, %ws\n", eventName );

    return eventName;

} /* buildEventName */

ISM_PENDING_ENTRY *
ISM_PENDING_LIST::GetPendingEntry(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;

    for (pPending = m_pPending; NULL != pPending; pPending = pPending->pNext) {
        if (0 == _wcsicmp(pszServiceName, pPending->szServiceName)) {
            // Found it.
            break;
        }
    }

    if (NULL == pPending) {
        // Not found; add it.
        pPending = (ISM_PENDING_ENTRY *) new BYTE[
                        offsetof(ISM_PENDING_ENTRY, szServiceName)
                        + sizeof(WCHAR) * (1 + wcslen(pszServiceName))];

        if (NULL != pPending) {
            LPWSTR pszEventName;

            pPending->hEvent = NULL;

            pszEventName = buildEventName( pszTransportDN, pszServiceName );
            if (pszEventName) {
                // Auto-reset, initially non-signalled event.
                // Note: We do not pass a security descriptor, so the event inherits
                // the process' security descriptor, which is:
                //
                //   DACL - 
                //     Ace[ 0] - Grant - 0x1f0003 - NT AUTHORITY\SYSTEM
                //     Ace[ 1] - Grant - 0x120001 - BUILTIN\Administrators
                //
                pPending->hEvent = CreateEventW(NULL, FALSE, FALSE, pszEventName);

                if (pszEventName) {
                    delete pszEventName;
                }
            }
            if (NULL != pPending->hEvent) {
                wcscpy(pPending->szServiceName, pszServiceName);

                // Add new entry to the list.
                pPending->pNext = m_pPending;
                m_pPending = pPending;
            }
            else {
                // Failed to CreateEvent().
                DWORD err = GetLastError();
                
                DPRINT1(0, "Failed to CreateEvent(), error %d.\n", err);  
                LogEvent8(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_CREATE_EVENT_FAILED,
                    szInsertWC(pszServiceName),
                    szInsertWC(pszTransportDN),
                    szInsertWin32Msg( err ),  
                    szInsertWin32ErrCode( err ),  
                    NULL, NULL, NULL, NULL );
                delete[] pPending;
                pPending = NULL;
            }
        }
    }

    return pPending;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\service.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    service.cxx

ABSTRACT:

    ISM_SERVICE implementation.  The ISM_SERVICE class handles interaction with
    the Service Control Manager (SCM) and starting and stopping the ISM RPC
    server.

DETAILS:

CREATED:

    97/11/21    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ntdsa.h>      // for NTDS_DELAYED_STARTUP_COMPLETED_EVENT
#include <debug.h>
#include <ism.h>
#include <ismapi.h>
#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>
#include "ismserv.hxx"

#define DEBSUB "SERVICE:"
#define FILENO FILENO_ISMSERV_SERVICE


// Static constants.
LPCTSTR ISM_SERVICE::m_pszName         = "ismserv";
LPCTSTR ISM_SERVICE::m_pszDisplayName  = "Intersite Messaging";
LPCTSTR ISM_SERVICE::m_pszDependencies = "samss\0";
LPCTSTR ISM_SERVICE::m_pszLpcEndpoint  = ISMSERV_LPC_ENDPOINT;

const DWORD ISM_SERVICE::m_cMinRpcCallThreads = 1;
const DWORD ISM_SERVICE::m_cMaxConcurrentRpcCalls
    = RPC_C_LISTEN_MAX_CALLS_DEFAULT;


DWORD
ISM_SERVICE::Init(
    IN  LPHANDLER_FUNCTION  pServiceCtrlHandler
    )
/*++

Routine Description:

    Initialize the service object.

Arguments:

    pServiceCtrlHandler (IN) - Function to be called by SCM to issue service
        control requests.  Unfortunately the SCM requires that this be a global
        function with no context parameter (which could be used, e.g., to pass
        a this pointer).  This global function typically calls the Control()
        member function of a known, global ISM_SERVICE object.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err = NO_ERROR;

    m_pServiceCtrlHandler = pServiceCtrlHandler;
    m_fIsRunningAsService = TRUE;

    m_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdown) {
        err = GetLastError();
    }

    m_hLogLevelChange = LoadEventTable();
    if (NULL == m_hLogLevelChange) {
        err = -1;
    }
    
    m_fIsInitialized = (NO_ERROR == err);

    return err;
}


VOID
ISM_SERVICE::Control(
    IN  DWORD   dwControl
    )
/*++

Routine Description:

    Process a service control (stop, interrogate, or shutdown) requested by the
    SCM.

Arguments:

    dwControl (IN) - Requested action.  See docs for "Handler" function in
        Win32 SDK.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    switch (dwControl) {
    case ISM_SERVICE_CONTROL_REMOVE_STOP:
        m_fIsRemoveStopPending = TRUE;
        // Fall through

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        Stop();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        SetStatus();
        break;
    }
}


DWORD
ISM_SERVICE::Run()
/*++

Routine Description:

    Execute the service.  Called either directly or by way of the SCM.  Returns
    on error or when service shutdown is requested.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);

    m_fIsStopPending = FALSE;
    m_fIsRemoveStopPending = FALSE;

    if (m_fIsRunningAsService) {
        m_hStatus = RegisterServiceCtrlHandler(m_pszName, m_pServiceCtrlHandler);
        if (NULL == m_hStatus) {
            err = GetLastError();
            DPRINT1(0, "RegisterServiceCtrlHandler() failed, error %d.\n", err);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_REGISTER_SERVICE_CONTROL_HANDLER_FAILED,  
                szInsertWin32Msg( err ),
                szInsertWin32ErrCode( err ),
                NULL, NULL, NULL, NULL,
                NULL, NULL ); 
            return err;
        }
    }

    // Start the service immediately so that the service controller and other
    // automatically started services are not delayed by long initialization.
    memset(&m_Status, 0, sizeof(m_Status)); 
    m_Status.dwServiceType      = SERVICE_WIN32;
    m_Status.dwCurrentState     = SERVICE_RUNNING; 
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    m_Status.dwWaitHint         = 15*1000;
    SetStatus();

    err = m_TransportList.Init();

    if (NO_ERROR == err) {
        err = StartRpcServer();
        
        if (NO_ERROR == err) {
            // RPC server is running; process requests until we're asked to stop.
            WaitForRpcServerTermination();
        }
        else {
            DPRINT1(0, "Failed to StartRpcServer(), error %d.\n", err);
	    LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_START_RPC_SERVER_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);
        }

        // Control returns here when the service is stopped
        // All calls should be complete at this time

        m_TransportList.Destroy();
    }
    else {
        DPRINT1(0, "Failed to m_TransportList.Init(), error %d.\n", err);
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_TRANSPORT_CONFIG_FAILURE,
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL, NULL, NULL );
    }

    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwWin32ExitCode = err;
    SetStatus();

    m_fIsStopPending = FALSE;
    m_fIsRemoveStopPending = FALSE;

    return m_Status.dwWin32ExitCode;
}

 
VOID
ISM_SERVICE::Stop()
/*++

Routine Description:

    Signal the service to stop.  Does not wait for service termination before
    returning.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    m_fIsStopPending = TRUE;

    m_Status.dwCurrentState = SERVICE_STOP_PENDING;
    SetStatus();

    SetEvent(m_hShutdown);

    StopRpcServer();
}

 
VOID
ISM_SERVICE::SetStatus()
/*++

Routine Description:

    Report current service status to the SCM.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    if (m_fIsRunningAsService) {
        m_Status.dwCheckPoint++;
        SetServiceStatus(m_hStatus, &m_Status);
    }
}


DWORD
ISM_SERVICE::Install()
/*++

Routine Description:

    Add service to the SCM database.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err = NO_ERROR;
    SC_HANDLE   hService = NULL;
    SC_HANDLE   hSCM = NULL;
    TCHAR       szPath[512];
    DWORD       cchPath;

    Assert(m_fIsInitialized);

    cchPath = GetModuleFileName(NULL, szPath, ARRAY_SIZE(szPath));
    if (0 == cchPath) {
        err = GetLastError();
        DPRINT1(0, "Unable to GetModuleFileName(), error %d.\n", err);
    }

    if (NO_ERROR == err) {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (NULL == hSCM) {
            err = GetLastError();
            DPRINT1(0, "Unable to OpenSCManager(), error %d.\n", err);
        }
    }

    if (NO_ERROR == err) {
        hService = CreateService(hSCM,
                                 m_pszName,
                                 m_pszDisplayName,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_WIN32_OWN_PROCESS,
                                 SERVICE_AUTO_START,
                                 SERVICE_ERROR_NORMAL,
                                 szPath,
                                 NULL,
                                 NULL,
                                 m_pszDependencies,
                                 NULL,
                                 NULL);
        if (NULL == hService) {
            err = GetLastError();
            DPRINT1(0, "Unable to CreateService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}


DWORD
ISM_SERVICE::Remove()
/*++

Routine Description:

    Remove service from the SCM database.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err = NO_ERROR;
    SC_HANDLE       hService = NULL;
    SC_HANDLE       hSCM = NULL;
    SERVICE_STATUS  SvcStatus;

    Assert(m_fIsInitialized);

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCM) {
        err = GetLastError();
        DPRINT1(0, "Unable to OpenSCManager(), error %d.\n", err);
    }

    if (NO_ERROR == err) {
        hService = OpenService(hSCM, m_pszName, SERVICE_ALL_ACCESS);
        if (NULL == hService) {
            err = GetLastError();
            DPRINT1(0, "Unable to OpenService(), error %d.\n", err);
        }
    }

    if (NO_ERROR == err) {
        if (!DeleteService(hService)) {
            err = GetLastError();
            DPRINT1(0, "Unable to DeleteService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}


BOOL
InitializeAdminOnlyDacl(
    PACL *ppDacl
    )

/*++

Routine Description:

This routine constructs a Dacl which allows the local administrators all
access.

Arguments:

    ppDacl - pointer to pointer to receive allocated pDacl. Caller must
    deallocate using HeapFree

Return Value:

    BOOL - success/failure

--*/

{
    DWORD status;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PACL pDacl = NULL;
    PSID pAdministratorsSid = NULL;
    DWORD dwAclSize;

    //
    // preprate a Sid representing the well-known admin group
    // Are both the local admin and the domain admin members of this group?
    //

    if (!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pAdministratorsSid
        )) {
        status = GetLastError();
        DPRINT1(0, "Unable to allocate and init sid, error %d\n", status);
        goto cleanup;
    }

    //
    // compute size of new acl
    //
    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pAdministratorsSid) ;

    //
    // allocate storage for Acl
    //
    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
    if(pDacl == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DPRINT1(0, "Unable to allocate acl, error %d\n", status);
        goto cleanup;
    }

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        status = GetLastError();
        DPRINT1(0, "Unable to initialize acl, error %d\n", status);
        goto cleanup;
    }

    //
    // grant the Administrators Sid KEY_ALL_ACCESS access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        pAdministratorsSid
        )) {
        status = GetLastError();
        DPRINT1(0, "Unable to add access allowed ace, error %d\n", status);
        goto cleanup;
    }

    *ppDacl = pDacl;
    pDacl = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if(pAdministratorsSid != NULL)
    {
        FreeSid(pAdministratorsSid);
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    return (status == ERROR_SUCCESS) ? TRUE : FALSE;
} /* InitializeAdminOnlyDacl */

DWORD
ISM_SERVICE::StartRpcServer()
/*++

Routine Description:

    Start RPC server to service client requests.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err = 0;
    BYTE                    rgbSD[ SECURITY_DESCRIPTOR_MIN_LENGTH ];
    PSECURITY_DESCRIPTOR    pSD = (PSECURITY_DESCRIPTOR) rgbSD;
    RPC_POLICY rpcPolicy;
    PACL pDacl = NULL;

    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;

    Assert(m_fIsInitialized);
    Assert(!m_fIsRpcServerListening);

    // Construct the security descriptor to apply to our LPC interface.
    // By default LPC allows access only to the account under which the server
    // is running; ours should allow access to all local administrators.

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
        || !InitializeAdminOnlyDacl( &pDacl )
        || !SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE)) {
        err = GetLastError();
        DPRINT1(0, "Unable to construct security descriptor, error %d\n", err);
        LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_CONSTRUCT_SECURITY_DESCRIPTOR_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);
    }

    if (NO_ERROR == err) {
        // Listen on LPC (local machine only).
        err = RpcServerUseProtseqEpEx((UCHAR *) "ncalrpc",
                                      m_cMaxConcurrentRpcCalls,
                                      (UCHAR *) m_pszLpcEndpoint,
                                      pSD,
                                      &rpcPolicy);
        if (err) {
            DPRINT1(0, "Unable to RpcServerUseProtseqEpEx(), error %d.\n", err);
            LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_USE_PROT_SEQ_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);
        }
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    if (NO_ERROR == err) {
        // Register interface.
        err = RpcServerRegisterIf(ismapi_ServerIfHandle, 0, 0);
        if (err) {
            DPRINT1(0, "Unable to RpcServerRegisterIf(), error %d.\n", err);
            LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_REGISTER_IF_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);
        }
    }

    if (NO_ERROR == err) {
        // Principal name is NULL for local system service.
        err = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);
        if (err) {
            DPRINT1(0, "Unable to RpcServerRegisterAuthInfo(), error %d.\n", err);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_RPC_SERVER_REGISTER_AUTH_INFO_FAILED,  
                szInsertWin32Msg( err ),
                szInsertWin32ErrCode( err ),
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
        }
    }

    if (NO_ERROR == err) {
        // Start taking calls.
        err = RpcServerListen(m_cMinRpcCallThreads, m_cMaxConcurrentRpcCalls, TRUE);
        if (err) {
            DPRINT1(0, "Unable to RpcServerListen(), error %d.\n", err);
            LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_LISTEN_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);
        }
    }

    if (NO_ERROR == err) {
        m_fIsRpcServerListening = TRUE;
        DPRINT1(0, "RPC server listening...\n", err);
    }

    return err;
}


VOID
ISM_SERVICE::StopRpcServer()
/*++

Routine Description:

    Signals the RPC server to stop processing requests.  Does not wait for calls
    currently being processed to complete.

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);

    if (m_fIsRpcServerListening) {
        err = RpcMgmtStopServerListening(NULL);
        if (err) {
            DPRINT1(0, "Unable to RpcMgmtStopServerListening(), error %d.\n", err);
            LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_STOP_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		); 
        }
    }
}


VOID
ISM_SERVICE::WaitForRpcServerTermination()
/*++

Routine Description:

    Waits for completion of all RPC client calls made before StopRpcServer() is
    invoked.  (No RPC calls are accepted after the StopRpcServer().)

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err = 0;
    HANDLE rgWaitHandles[2];
    DWORD waitStatus;

    Assert(m_fIsInitialized);
    Assert(m_fIsRpcServerListening);

    /// m_hLogLevelChange
    rgWaitHandles[0] = m_hShutdown;
    rgWaitHandles[1] = m_hLogLevelChange;
    
    do {
        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles),
                                            rgWaitHandles,
                                            FALSE,
                                            INFINITE);
        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // Shutdown was requested.
            // We'll fall out of the do-while loop below.
            Assert(SERVICE_RUNNING != m_Status.dwCurrentState);
            break;

        case WAIT_OBJECT_0 + 1:
            // Our logging levels have changed.
            LoadEventTable();
            break;

        case WAIT_FAILED:
        default:
            err = GetLastError();
            Assert(err);
            DPRINT2(0, "WaitForMultipleObjects() failed, waitStatus %d, error %d.\n",
                    waitStatus, err);
	    LogEvent8(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( err ),
		szInsertWin32ErrCode( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		); 
            break;
        }
    } while (!err
             && (SERVICE_RUNNING == m_Status.dwCurrentState));

    err = RpcMgmtWaitServerListen();
    Assert((RPC_S_OK == err) || (RPC_S_NOT_LISTENING == err));

    DPRINT1(0, "RPC server terminated.\n", err);

    m_fIsRpcServerListening = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\ismapi.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismapi.cxx

ABSTRACT:

    Server stubs for functions exposed through the ISM RPC interface.

DETAILS:

CREATED:

    97/11/26    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/


#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>

#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>

#include "ismserv.hxx"

#define DEBSUB "ISMAPI:"
#define FILENO FILENO_ISMSERV_ISMAPI


// Thread-specific variables to track the last data structure returned.  Used
// by IDL_ISM*_notify() to free the structure once it has been marshalled.
__declspec(thread) ISM_TRANSPORT *              gpTransport;
__declspec(thread) ISM_MSG *                    gpMsg;
__declspec(thread) ISM_CONNECTIVITY *           gpConnectivity;
__declspec(thread) ISM_SERVER_LIST *            gpServerList;
__declspec(thread) ISM_SCHEDULE *               gpSchedule;
__declspec(thread) ISM_SITE_COST_INFO_ARRAY *   gpSiteCostInfo;


extern "C"
DWORD
IDL_ISMSend(
    IN  RPC_BINDING_HANDLE  hRpcBinding,
    IN  const ISM_MSG *     pMsg,
    IN  LPCWSTR             pszServiceName,
    IN  LPCWSTR             pszTransportDN,
    IN  LPCWSTR             pszTransportAddress
    )
/*++

Routine Description:

    Sends a message to a service on a remote machine.  If the client specifies a
    NULL transport, the lowest cost transport will be used.

Arguments:

    pMsg (IN) - The data to send.

    pszServiceName (IN) - Service to which to send the message.

    pszTransportDN (IN) - The DN of the Inter-Site-Transport object
        corresponding to the transport by which the message should be sent.
            
    pszTransportAddress (IN) - The transport-specific address to which to send
        the message.
            
Return Values:

    NO_ERROR - Message successfully queued for send.

    other - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    __try {    
        DPRINT(4, "Sending message...\n");

        pTransport = gService.m_TransportList.Get(pszTransportDN);

        if (NULL != pTransport) {
            err = pTransport->Send(pMsg, pszServiceName, pszTransportAddress);

            if (NO_ERROR == err) {
                DPRINT5(2, "Sent %d bytes to service %ls at %ls on transport %ls.\nSubject: %ls\n",
                        pMsg->cbData, pszServiceName, pszTransportAddress, pszTransportDN,
                        pMsg->pszSubject);
            }
            else {
                DPRINT4(0, "Failed to send message to service %ls at %ls on transport %ls, error %d.\n",
                        pszServiceName, pszTransportAddress, pszTransportDN, err);
            }
        }
        else {
            DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
            err = ERROR_NOT_FOUND;
        }
    }
    __finally {
        gService.m_TransportList.ReleaseLock();
    }

    if (NO_ERROR == err) {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_ISM_SEND_SUCCESS,
                  szInsertUL(pMsg->cbData),
                  szInsertWC(pszServiceName),
                  szInsertWC(pszTransportAddress),
                  szInsertWC(pszTransportDN),
                  szInsertWC(pMsg->pszSubject),
                  NULL, NULL, NULL);
    }
    else {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SEND_FAILURE,
                  szInsertUL(pMsg->cbData),
                  szInsertWC(pszServiceName),
                  szInsertWC(pszTransportAddress),
                  szInsertWC(pszTransportDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL);
    }

    return err;
}


extern "C"
DWORD
IDL_ISMReceive(
    IN  RPC_BINDING_HANDLE  hRpcBinding,
    IN  LPCWSTR             pszServiceName,
    IN  DWORD               dwMsecToWait,
    OUT ISM_MSG **          ppMsg
    )
/*++

Routine Description:

    Receives a message addressed to the given service on the local machine.

    If successful and no message is waiting, immediately returns a NULL message.
    If a non-NULL message is returned, the caller is responsible for eventually
    calling I_ISMFree()'ing the returned message.

Arguments:

    pszServiceName (IN) - Service for which to receive the message.

    dwMsecToWait (IN) - Milliseconds to wait for message if none is immediately
        available; in the range [0, INFINITE].

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    NO_ERROR - Message successfully returned (or NULL was returned,
        indicating no message is waiting).

    other - Failure.

--*/
{
    DWORD           err = NO_ERROR;
    DWORD           iTransport;
    ISM_TRANSPORT * pTransport;
    BOOL            fRetry;
    ISM_TRANSPORT * rgpTransports[MAXIMUM_WAIT_OBJECTS];
    HANDLE          rgWaitHandles[MAXIMUM_WAIT_OBJECTS];
    const DWORD     cMaxTransports = MAXIMUM_WAIT_OBJECTS - 2;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Receiving message...\n");

    do {
        fRetry = FALSE;

        // Check all transports for inbound messages for the given service.
        // If the receive fails or the transport has no message for this service,
        // continue on to the next service.

        for (iTransport = 0, pTransport = gService.m_TransportList[0];
             NULL != pTransport;
             pTransport = gService.m_TransportList[++iTransport]) {

            Assert((iTransport < cMaxTransports) && "Too many transports!");

            // Leave room in handle array for shutdown and transport list
            // change events.
            if (iTransport < cMaxTransports) {
                rgpTransports[iTransport] = pTransport;

                rgWaitHandles[iTransport] = pTransport->GetWaitHandle(pszServiceName);
                Assert(NULL != rgWaitHandles[iTransport]);
            }

            err = pTransport->Receive(pszServiceName, ppMsg);

            if (NO_ERROR == err) {
                if (NULL == *ppMsg) {
                    DPRINT2(3, "Transport %ls has no message for service %ls.\n",
                            pTransport->GetDN(), pszServiceName);
                }
                else {
                    DPRINT4(2, "Received %d bytes for service %ls via transport %ls.\nSubject: %ls.\n",
                            (*ppMsg)->cbData, pszServiceName, pTransport->GetDN(),
                            (*ppMsg)->pszSubject);

                    LogEvent8(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_ISM_RECEIVE_SUCCESS,
                              szInsertUL((*ppMsg)->cbData),
                              szInsertWC(pszServiceName),
                              szInsertWC(pTransport->GetDN()),
                              szInsertWC((*ppMsg)->pszSubject),
                              NULL, NULL, NULL, NULL
                        );
                    
                    // Remember transport and received message so we can free the
                    // message once it's been marshalled.
                    gpTransport = pTransport;
                    gpMsg = *ppMsg;

                    break;
                }
            }
            else {
                DPRINT3(0, "Failed to receive message for service %ls via transport %ls, error %d.\n",
                        pszServiceName, pTransport->GetDN(), err);
                
                LogEvent8(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_RECEIVE_FAILURE,
                          szInsertWC(pszServiceName),
                          szInsertWC(pTransport->GetDN()),
                          szInsertWin32Msg(err),
                          szInsertWin32ErrCode(err),
                          NULL, NULL, NULL, NULL);
            }
        }

        if ((NULL == *ppMsg) && (NO_ERROR == err)) {
            DPRINT1(3, "No message waiting for service %ls.\n", pszServiceName);

            if (0 != dwMsecToWait) {
                // Round up wait handles from all the transports.
                DWORD cNumTransports = min(iTransport, cMaxTransports);
                DWORD cNumHandles = cNumTransports;
                DWORD iShutdownEvent;
                DWORD iTransportChangeEvent;

                // Stop waiting if shutdown is signalled, too.
                iShutdownEvent = cNumHandles++;
                rgWaitHandles[iShutdownEvent] = gService.GetShutdownEvent();

                // ...or if a new transport is added.
                iTransportChangeEvent = cNumHandles++;
                rgWaitHandles[iTransportChangeEvent]
                    = gService.m_TransportList.GetChangeEvent();

                // Release lock while we're waiting.
                gService.m_TransportList.ReleaseLock();

                err = WaitForMultipleObjects(cNumHandles, rgWaitHandles, FALSE,
                                             dwMsecToWait);

                // Note that lock is released in notify routine.
                gService.m_TransportList.AcquireReadLock();

#pragma warning(disable:4296)
                // The following test generates an error 4296, because it turns
                // out that WAIT_OBJECT_0 is 0, and unsigned err can never be
                // negative.
                if ((WAIT_OBJECT_0 <= err) && (err < (WAIT_OBJECT_0 + cNumTransports))) {
#pragma warning(default:4296)
                    // Received notification of pending message.
                    iTransport = err - WAIT_OBJECT_0;
                    pTransport = gService.m_TransportList[iTransport];

                    for (iTransport = 0, pTransport = gService.m_TransportList[0];
                         NULL != pTransport;
                         pTransport = gService.m_TransportList[++iTransport]) {
                        if (pTransport == rgpTransports[err - WAIT_OBJECT_0]) {
                            // This is the transport that notified us.
                            break;
                        }
                    }

                    if (NULL == pTransport) {
                        // We were notified, but by the time we turned around
                        // the transport that notified us was gone.
                        DPRINT(0, "Unable to find transport that notified us; rewaiting.\n");
                        fRetry = TRUE;
                    }
                    else {
                        err = pTransport->Receive(pszServiceName, ppMsg);

                        if ((NO_ERROR != err) || (NULL == *ppMsg)) {
                            // We were notified, but apparently someone beat us
                            // to the message.
                            DPRINT2(1, "No message waiting for %ls from %ls, despite notification; rewaiting.\n",
                                    pszServiceName, pTransport->GetDN());
                            fRetry = TRUE;

                            if (err) {
                                LogEvent8(DS_EVENT_CAT_ISM,
                                          DS_EVENT_SEV_ALWAYS,
                                          DIRLOG_ISM_RECEIVE_FAILURE,
                                          szInsertWC(pszServiceName),
                                          szInsertWC(pTransport->GetDN()),
                                          szInsertWin32Msg(err),
                                          szInsertWin32ErrCode(err),
                                          NULL, NULL, NULL, NULL );
                            }
                        }
                        else {
                            DPRINT3(2, "Received %d bytes for service %ls via transport %ls.\n",
                                    (*ppMsg)->cbData, pszServiceName, pTransport->GetDN());

			    LogEvent8(DS_EVENT_CAT_ISM,
				      DS_EVENT_SEV_BASIC,
				      DIRLOG_ISM_RECEIVE_SUCCESS,
				      szInsertUL((*ppMsg)->cbData),
				      szInsertWC(pszServiceName),
				      szInsertWC(pTransport->GetDN()),
				      szInsertWC((*ppMsg)->pszSubject),
				      NULL, NULL, NULL, NULL
				      );

                            // Remember transport and received message so we can free the
                            // message once it's been marshalled.
                            gpTransport = pTransport;
                            gpMsg = *ppMsg;
                            
                            break;
                        }
                    }
                }
                else if ((WAIT_OBJECT_0 + iShutdownEvent) == err) {
                    // Shutting down.
                    DPRINT(0, "Shutdown signalled; wait terminated.\n");
                    err = ERROR_SHUTDOWN_IN_PROGRESS;
                }
                else if ((WAIT_OBJECT_0 + iTransportChangeEvent) == err) {
                    // Transport list has changed.
                    DPRINT(0, "Transport list changed; re-acquiring and re-waiting.\n");
                    fRetry = TRUE;
                }
                else if (WAIT_TIMEOUT == err) {
                    // Still no waiting message; return.
                    DPRINT2(2, "After %u msec, still no message for service %ls.\n",
                            dwMsecToWait, pszServiceName);
                    err = NO_ERROR;
                }
                else if ((WAIT_ABANDONED_0 <= err)
                         && (err < (WAIT_ABANDONED_0 + cNumTransports))) {
                    // Wait abandoned -- that transport must be being shut down.
                    // Wait again.
                    DPRINT(0, "Wait abandoned; re-waiting.\n");
                    fRetry = TRUE;
                }
                else {
		    DWORD gle = GetLastError();
		    DPRINT2(0, "Failed to wait for message, error %d (GLE = %d).\n",
                            err, gle);
		    LogEvent8(
			DS_EVENT_CAT_ISM,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,   
			szInsertWin32Msg( gle ),   
			szInsertWin32ErrCode( gle ),   
			NULL,
			NULL,
			NULL, NULL, NULL, NULL );
                }
            }
        }
    } while (fRetry);

    return err;
}


extern "C"
void
IDL_ISMReceive_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppMsg to ship back to the client.

    We take this opportunity to free the message via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpMsg) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing message.\n");
        gpTransport->FreeMsg(gpMsg);

        gpTransport = NULL;
        gpMsg = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetConnectivity(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    PISM_CONNECTIVITY_df_an *       ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting connectivity...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetConnectivity(ppConnectivity);

        if (NO_ERROR == err) {
            DPRINT1(2, "Retrieved site connectivity for transport %ls.\n",
                    pszTransportDN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpConnectivity = *ppConnectivity;
        }
        else {
            DPRINT2(0, "Failed to get site connectivity for transport %ls, error %d.\n",
                    pszTransportDN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    // BAD_NET_RESP is the special error that LDAP returns at shutdown

    if ( (err) &&
         (err != ERROR_BAD_NET_RESP)  // shutdown, don't log
        ) {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_GET_CONNECTIVITY_FAILURE,
                  szInsertWC(pszTransportDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL, NULL );
    }

    return err;
}


extern "C"
void
IDL_ISMGetConnectivity_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppConnectivity to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpConnectivity) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing connectivity.\n");
        gpTransport->FreeConnectivity(gpConnectivity);

        gpTransport = NULL;
        gpConnectivity = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetTransportServers(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    LPCWSTR                         pszSiteDN,
    PISM_SERVER_LIST_df_an *        ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting transport servers...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetTransportServers(pszSiteDN, ppServerList);

        if (NO_ERROR == err) {
            DPRINT2(2, "Retrieved %d transport servers for transport %ls.\n",
                    (NULL == *ppServerList) ? 0 : (*ppServerList)->cNumServers,
                    pszTransportDN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpServerList = *ppServerList;
        }
        else {
            DPRINT2(0, "Failed to get transport servers for transport %ls, error %d.\n",
                    pszTransportDN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    if (err) {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_GET_TRANSPORT_SERVERS_FAILURE,
                  szInsertWC(pszSiteDN),
                  szInsertWC(pszTransportDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL );
    }

    return err;
}


extern "C"
void
IDL_ISMGetTransportServers_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppServerList to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpServerList) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing transport servers.\n");
        gpTransport->FreeTransportServers(gpServerList);

        gpTransport = NULL;
        gpServerList = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetConnectionSchedule(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    LPCWSTR                         pszSite1DN,
    LPCWSTR                         pszSite2DN,
    PISM_SCHEDULE_df_an *           ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting connection schedule...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetConnectionSchedule(pszSite1DN, pszSite2DN, ppSchedule);

        if (NO_ERROR == err) {
            DPRINT4(2, "Retrieved schedule of %d bytes for transport %ls between sites %ls and %ls.\n",
                    (NULL == *ppSchedule) ? 0 : (*ppSchedule)->cbSchedule,
                    pszTransportDN, pszSite1DN, pszSite2DN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpSchedule = *ppSchedule;
        }
        else {
            DPRINT4(0, "Failed to get schedule for transport %ls between sites %ls and %ls, error %d.\n",
                    pszTransportDN, pszSite1DN, pszSite2DN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    if (err) {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_GET_CONECTION_SCHEDULE_FAILURE,
                  szInsertWC(pszSite1DN),
                  szInsertWC(pszSite2DN),
                  szInsertWC(pszTransportDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL );
    }

    return err;
}


extern "C"
void
IDL_ISMGetConnectionSchedule_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppSchedule to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpSchedule) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing connection schedule.\n");
        gpTransport->FreeConnectionSchedule(gpSchedule);

        gpTransport = NULL;
        gpSchedule = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMQuerySitesByCost(
    handle_t                    hRpcBinding,
    LPCWSTR                     pszTransportDN,
    LPCWSTR                     pszFromSite,
    DWORD                       cToSites,
    LPCWSTR*                    rgszToSites,
    DWORD                       dwFlags,
    ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo
    )
/*++

Routine Description:

    Determine the individual costs between the From site and the To sites.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*prgSiteInfo);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszFromSite (IN) - The distinguished name of the From site.

    rgszToSites (IN) - An array containing the distinguished names of the To sites.

    cToSites (IN) - The number of entries in the rgszToSites array.

    dwFlags (IN) - Unused.

    prgSiteInfo (IN) - On successful return, holds a pointer to a structure
        containing the costs between the From site and the To sites.

Notes:

    In the current implementation of NTDSA!IDL_DRSQuerySitesByCost, pszFromSite
    and rgszToSites are partially formed from RPC input data. Their contents
    cannot be trusted.
    
Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    // Clear relevant thread-local globals
    gpTransport = NULL;
    gpSiteCostInfo = NULL;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    pTransport = gService.m_TransportList.Get(pszTransportDN);
    if (NULL != pTransport) {

        err = pTransport->QuerySitesByCost(pszFromSite, cToSites, rgszToSites,
                dwFlags, prgSiteInfo);
        DPRINT1(2, "Transport->QuerySitesByCost returned %d.\n", err);

        if (NO_ERROR == err) {
            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpSiteCostInfo = *prgSiteInfo;
        }
    } else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    // The NTDSA wrapper around this call logs an eventlog message on failure
    // so we don't need to do so here.
    
    return err;
}


extern "C"
void
IDL_ISMQuerySitesByCost_notify()
/*++

Routine Description:

    Called by RPC after marshalling *prgSiteInfo to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpSiteCostInfo) && (NULL != gpTransport)) {
        DPRINT(2, "IDL_ISMQuerySitesByCost_notify: Freeing site cost info\n");
        gpTransport->FreeSiteCostInfo( gpSiteCostInfo );
        gpTransport = NULL;
        gpSchedule = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\graph.c ===
/*++

Copyright (c) 1997,2001  Microsoft Corporation

Module Name:

    graph.c

Abstract:

    Graph routines.

    The current implementation uses a matrix to represent the edge costs.  This is because the
    all pairs shortest cost algorithm uses an array as input, and also because the ISM ultimately
    wants an connectivity information as a matrix.

Author:

    Will Lees (wlees) 22-Dec-1997

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>
#include <schedule.h>

#include "common.h"

#define DEBSUB "IPGRAPH:"

#include <fileno.h>
#define FILENO    FILENO_ISMSERV_GRAPH

// An instance of type graph.  Returned by GraphCreate.  The head of the data structure
typedef struct _GRAPH_INSTANCE {
    DWORD Size;
    DWORD NumberElements;
    PISM_LINK LinkArray;

    // The W32TOPL Schedule Cache
    TOPL_SCHEDULE_CACHE ScheduleCache;

    // A two dimensional array of TOPL_SCHEDULEs. If no schedules have been added,
    // this will be NULL. If any schedules are added, this whole 2d array is allocated.
    TOPL_SCHEDULE *ScheduleArray;
} ISMGRAPH, *PISMGRAPH;

/* Forward */

DWORD
GraphAllCosts(
    PISMGRAPH Graph,
    BOOL fIgnoreSchedules
    );

DWORD
GraphMerge(
    PISMGRAPH FinalGraph,
    PISMGRAPH TempGraph
    );

PISMGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    );

DWORD
GraphAddEdgeIfBetter(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

DWORD
GraphInit(
    PISMGRAPH Graph
    );

void
GraphFree(
    PISMGRAPH Graph
    );

void
GraphReferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

VOID
GraphDereferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK pLinkArray
    );

DWORD
GraphGetPathSchedule(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    );

void
GraphComputeTransitiveClosure(
    IN OUT  PISMGRAPH      pGraph
    );

static BOOL
scheduleValid(
    PBYTE pSchedule
    );

static TOPL_SCHEDULE
scheduleFind(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To
    );

static void
scheduleArrayFree(
    PISMGRAPH Graph
    );

static DWORD
scheduleAddDel(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    TOPL_SCHEDULE toplSched
    );

TOPL_SCHEDULE
scheduleOverlap(
    IN PISMGRAPH Graph,
    IN TOPL_SCHEDULE Schedule1,
    IN TOPL_SCHEDULE Schedule2
    );

static DWORD
scheduleLength(
    PBYTE pSchedule
    );

static PSCHEDULE
scheduleAllocCopy(
    PSCHEDULE pSchedule
    );

/* End Forward */

DWORD
GraphAllCosts(
    PISMGRAPH Graph,
    BOOL fIgnoreSchedules
    )
/*++

Routine Description:

    Find the shortest path between all pairs of nodes

    When a path is updated, its schedule is considered.  If they paths are have a common schedule,
    the path can be chosen.  When two weights are the same, the path with the most available
    schedule is chosen.

    SCALING BUG 87827: this is an order(n^3) algorithm

    This algorithm is taken from:
    Fundamentals of Data Structures, Horowitz and Sahni,
    Computer Science Press, 1976, pp. 307

    for k = 1 to n
        for i = 1 to n
            for j = 1 to n
                A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

    "Some speed up can be obtained by noticing that the innermost for loop
     need be executed only when A(i,k) and A(k,j) are not equal to infinity."

Arguments:

    IN OUT CostArray (global) - Input is cost matrix, Output is shortest path array

Return Value:

    None

--*/
{
    DWORD NumberSites = Graph->NumberElements;
    PISM_LINK LinkArray = Graph->LinkArray;
    PISM_LINK pElement1, pElement2, pElement3;
    ISM_LINK newPath;
    DWORD i, j, k, cost1, cost2, cost3;
    DWORD DurationS1, DurationS23;
    TOPL_SCHEDULE sched1, sched2, sched3, sched23;
    BOOLEAN replace;
    DWORD ErrorCode;

    if ( (Graph->Size != sizeof( ISMGRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance is invalid" );
        return ERROR_INVALID_PARAMETER;
    }

    for( k = 0; k < NumberSites; k++ ) {

        for( i = 0; i < NumberSites; i++ ) {

            pElement2 = &( LinkArray[ i * NumberSites + k ] );
            cost2 = pElement2->ulCost;
            if (cost2 == INFINITE_COST) {
                continue;
            }

            for( j = 0; j < NumberSites; j++ ) {

                // A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

                pElement1 = &( LinkArray[ i * NumberSites + j ] );
                cost1 = pElement1->ulCost;

                pElement3 = &( LinkArray[ k * NumberSites + j ] );
                cost3 = pElement3->ulCost;
                if (cost3 == INFINITE_COST) {
                    continue;
                }

                // These equations aggregate attributes along a path
                newPath.ulCost = cost2 + cost3;
                newPath.ulReplicationInterval =
                    MAX( pElement2->ulReplicationInterval,
                         pElement3->ulReplicationInterval );
                newPath.ulOptions =
                    pElement2->ulOptions & pElement3->ulOptions;

                if (!fIgnoreSchedules) {
                    // Consider Schedules

                    // new weight must be better or not a candidate
                    if (newPath.ulCost > cost1 ) {
                        continue;
                    }

                    // Grab the schedule for the current i-j path
                    sched1 = scheduleFind( Graph, i, j );
                    __try {
                        DurationS1 = ToplScheduleDuration( sched1 );
                    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
                        Assert( !"ToplScheduleDuration failed!" );
                        return ERROR_INVALID_PARAMETER;
                    }

                    // Grab the schedule for the current i-k path
                    sched2 = scheduleFind( Graph, i, k );

                    // Grab the schedule for the current k-j path
                    sched3 = scheduleFind( Graph, k, j );
                    
                    // Merge the schedules for the i-k and k-j paths
                    __try {
                        sched23 = scheduleOverlap( Graph, sched2, sched3 );
                        DurationS23 = ToplScheduleDuration( sched23 );
                    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
                        Assert( !"scheduleOverlap failed!" );
                        return ERROR_INVALID_PARAMETER;
                    }

                    // If there was no overlap, this path is not acceptable
                    if( 0==DurationS23 ) {
                        continue;
                    }

                    if (newPath.ulCost == cost1) {
                        // If weights the same, schedule must be better
                        replace = DurationS23 > DurationS1;
                    } else {
                        Assert( newPath.ulCost<cost1 );
                        replace = TRUE;
                    }
 
                    if (replace) {
                        // Replace current i-j path with i-k, k-j path
                        *pElement1 = newPath;
                        ErrorCode = scheduleAddDel( Graph, i, j, sched23 );
                        if( ERROR_SUCCESS != ErrorCode ) {
                            return ERROR_INVALID_PARAMETER;
                        }
                    }

                } else {

                    // Don't consider schedules
                    if (newPath.ulCost < cost1 ) {
                        *pElement1 = newPath;
                    }
                }

            }
        }
    }

    return ERROR_SUCCESS;
}

DWORD
GraphMerge(
    PISMGRAPH FinalGraph,
    PISMGRAPH TempGraph
    )

/*++

Routine Description:

"OR" two graphs together, such that an edge is added only if it is better than what was there
before.  Better is defined as small weight, or more available schedule if the weights are the
same.

Arguments:

    FinalGraph - 
    TempGraph - 

Return Value:

    None

--*/

{
    DWORD NumberSites = FinalGraph->NumberElements;
    DWORD i, j, newCost, *pElement;
    DWORD DurationNew, DurationOld;
    TOPL_SCHEDULE oldSchedule, newSchedule, copySchedule;
    PSCHEDULE newPSchedule;
    BOOLEAN replace;
    DWORD ErrorCode;

    if ( (FinalGraph->Size != sizeof( ISMGRAPH )) ||
         (TempGraph->Size != sizeof( ISMGRAPH )) ||
         (FinalGraph->NumberElements != TempGraph->NumberElements) ||
         (FinalGraph->LinkArray == NULL) ||
         (TempGraph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance is invalid" );
        return ERROR_INVALID_PARAMETER;
    }

    for( i = 0; i < NumberSites; i++ ) {

        for( j = 0; j < NumberSites; j++ ) {

            // Get the old element and schedule
            pElement = &(FinalGraph->LinkArray[i * NumberSites + j].ulCost);
            oldSchedule = scheduleFind( FinalGraph, i, j );

            // Get the new schedule
            newCost = TempGraph->LinkArray[i * NumberSites + j].ulCost;
            newSchedule = scheduleFind( TempGraph, i, j );

            // Compute durations
            __try {
                DurationOld = ToplScheduleDuration( oldSchedule );
                DurationNew = ToplScheduleDuration( newSchedule );
            } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
                Assert( !"ToplScheduleDuration failed!" );
                return ERROR_INVALID_PARAMETER;
            }

            // Replace old value with new value *only* if smaller, or better schedule
            replace = FALSE;
            if (newCost == *pElement) {
                replace = DurationNew > DurationOld;
            } else {
                replace = (newCost < *pElement);
            }

            // Replace element value
            if (replace) {
                *pElement = newCost;

                __try {
                    // Create a copy of newSchedule in FinalGraph's schedule cache
                    newPSchedule = ToplScheduleExportReadonly(
                            TempGraph->ScheduleCache,
                            newSchedule );
                    Assert( NULL!=newPSchedule );
                    copySchedule = ToplScheduleImport(
                            FinalGraph->ScheduleCache,
                            newPSchedule );
                } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
                    Assert( !"ToplScheduleExport / Import failed!" );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                // replace schedule
                ErrorCode = scheduleAddDel( FinalGraph, i, j, copySchedule );
                if( ERROR_SUCCESS != ErrorCode ) {
                    return ErrorCode;
                }
            }
        }

    }

    return ERROR_SUCCESS;
} /* GraphMerge */

PISMGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    )

/*++

Routine Description:

Create a new graph.
The schedule cache is allocated right away but the schedule array is not allocated until used.

Arguments:

    NumberElements - 
    Initialize - 

Return Value:

    PISMGRAPH - 

--*/
{
    PISMGRAPH graph = NULL;
    DWORD i, ErrorCode;

    // use calloc so cleanup can know whether to free embedded pointers
    graph = NEW_TYPE_ARRAY_ZERO( 1, ISMGRAPH );
    if (graph == NULL) {
        return NULL;
    }

    // INITIALIZE GRAPH INSTANCE
    graph->Size = sizeof( ISMGRAPH );
    graph->NumberElements = NumberElements;

    graph->LinkArray = NEW_TYPE_ARRAY(
        NumberElements * NumberElements, ISM_LINK );
    if (graph->LinkArray == NULL) {
        goto cleanup;
    }

    // Create the schedule cache
    __try {
        graph->ScheduleCache = ToplScheduleCacheCreate();
    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
        goto cleanup;
    }

    // Not allocated yet
    graph->ScheduleArray = NULL;

    // INITIALIZE GRAPH INSTANCE

    if (Initialize) {
        GraphInit( graph );
    }

    return graph;

cleanup:
    if (graph->LinkArray) {
        FREE_TYPE( graph->LinkArray );
    }
    if (graph->ScheduleArray) {
        scheduleArrayFree( graph );
        graph->ScheduleArray = NULL;
    }
    if (graph) {
        FREE_TYPE( graph );
    }
    return NULL;
} /* GraphCreate */

DWORD
GraphAddEdgeIfBetter(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    )

/*++

Routine Description:

Add an edge to the graph, only if it is better.
Better is defined as lower weight, or more available schedule.

Arguments:

    Graph - 
    From - 
    To - 
    Value - 
    pSchedule - may be NULL, indicating connectivity at all times

Return Value:

    DWORD - 

--*/

{
    PISM_LINK pElement;
    BOOLEAN replace;
    DWORD Error, ErrorCode, Duration, DurationOld;
    TOPL_SCHEDULE toplSched, oldToplSched;
    
    DPRINT5( 4, "GraphAddEdgeIfBetter, From=%d, To=%d, Value=(%d,%d), pSched=%p\n",
             From, To,
             pLinkValue->ulCost, pLinkValue->ulReplicationInterval,
             pSchedule );

    // Verify parameters
    if ( (Graph->Size != sizeof( ISMGRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance is invalid" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        Assert( !"node index is invalid" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( !scheduleValid(pSchedule) ) {
        // Note: Never Schedules are rejected here
        DPRINT( 0, "schedule is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Don't add obvious bad connections
    if ( pLinkValue->ulCost == INFINITE_COST ) {
        DPRINT( 1, "Not adding edge because weight infinite\n" );
        return ERROR_SUCCESS;
    }

    // Add the schedule to our cache
    Assert( Graph->ScheduleCache );
    __try {
        toplSched = ToplScheduleImport( Graph->ScheduleCache, (PSCHEDULE) pSchedule );
    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    __try {
        Duration = ToplScheduleDuration( toplSched );
    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
        Assert( !"ToplScheduleDuration failed!" );
        return ERROR_INVALID_PARAMETER;
    }

    // Look up the existing element in the graph
    pElement = &( Graph->LinkArray[ From * Graph->NumberElements + To ] );

    // See if the new value is better, or the schedule is better
    replace = FALSE;
    if (pLinkValue->ulCost == pElement->ulCost) {
        oldToplSched = scheduleFind( Graph, From, To );
        __try {
            DurationOld = ToplScheduleDuration( oldToplSched );
        } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
            Assert( !"ToplScheduleDuration failed!" );
            return ERROR_INVALID_PARAMETER;
        }
        replace = Duration > DurationOld;
    } else {
        replace = (pLinkValue->ulCost < pElement->ulCost);
    }

    if (replace) {
        *pElement = *pLinkValue;
        Error = scheduleAddDel( Graph, From, To, toplSched );
        if( Error!=ERROR_SUCCESS ) {
            Assert( !"ToplScheduleDuration failed!" );
            return Error;
        }
    }

    return ERROR_SUCCESS;
} /* GraphAddEdgeIfBetter */

DWORD
GraphInit(
    PISMGRAPH Graph
    )

/*++

Routine Description:

Clear out old values in a graph.  Graph must already be created.  Graph may or may not
have any sparse elements yet.

Arguments:

    Graph - 

Return Value:

    DWORD - 

--*/

{
    DWORD i, number = Graph->NumberElements;

    if ( (Graph->Size != sizeof( ISMGRAPH ) ) ||
         (Graph->LinkArray == NULL ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance invalid!" );
        return ERROR_INVALID_PARAMETER;
    }

    // Zero the array of structures
    ZeroMemory( Graph->LinkArray, number * number * sizeof( ISM_LINK ) );

    // Initially all costs are infinite
    for( i = 0; i < number * number; i++ ) {
        Graph->LinkArray[i].ulCost = INFINITE_COST;
    }
    
    // Cost to ourselves is zero
    for( i = 0; i < number; i++ ) {
        Graph->LinkArray[i * number + i].ulCost = 0; // loopback cost
    }

    scheduleArrayFree( Graph );

    return ERROR_SUCCESS;
} /* GraphInit */

void
GraphFree(
    PISMGRAPH Graph
    )

/*++

Routine Description:

Deallocate a graph.
May or may not have any sparse elements.
It may or may not have had its matrix extracted.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    DWORD ErrorCode;

    if (Graph->Size != sizeof( ISMGRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance invalid!" );
        return;
    }
    if (Graph->LinkArray != NULL) {
        FREE_TYPE( Graph->LinkArray );
    }
    Graph->LinkArray = NULL;

    scheduleArrayFree( Graph );

    // Free the schedule cache
    Assert( Graph->ScheduleCache!=NULL );
    __try {
        ToplScheduleCacheDestroy( Graph->ScheduleCache );
    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
        Assert( !"ToplScheduleCacheDestroy failed!" );
        // There's not much we can do about this. Keep going.
    }

    Graph->ScheduleCache=NULL;
    FREE_TYPE( Graph );
} /* GraphFree */

void
GraphPeekMatrix(
    PISMGRAPH Graph,
    PISM_LINK *ppLinkArray
    )
/*++

Routine Description:

Obtain a pointer to the cost matrix without copying it. The caller
should be sure to treat this structure as read only and should not
attempt to free it.

Arguments:

    Graph - 
    ppArray - 

Return Value:

    None

--*/
{
    if (Graph->Size != sizeof( ISMGRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (ppLinkArray == NULL) {
        DPRINT( 0, "Invalid parameter\n" );
        Assert( !"Invalid parameter to GraphReferenceMatrix!" );
        return;
    }

    *ppLinkArray = Graph->LinkArray;
}

void
GraphReferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK *ppLinkArray
    )

/*++

Routine Description:

Copy the cost matrix out

The caller must release the matrix when he is finished using the
GraphDereferenceMatrix function.

Arguments:

    Graph - 
    ppArray - 

Return Value:

    None

--*/

{
    PISM_LINK pLinkArray = NULL;
    DWORD number, i, j, index;

    if (Graph->Size != sizeof( ISMGRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (ppLinkArray == NULL) {
        DPRINT( 0, "Invalid parameter\n" );
        Assert( !"Invalid parameter to GraphReferenceMatrix!" );
        return;
    }

    number = Graph->NumberElements;

    // Allocate a new array to hold the cost matrix
    pLinkArray = NEW_TYPE_ARRAY( number * number, ISM_LINK );
    if (pLinkArray == NULL) {
        goto cleanup;
    }

    CopyMemory( pLinkArray, Graph->LinkArray,
                number * number * sizeof( ISM_LINK ) );

cleanup:

    *ppLinkArray = pLinkArray;
    // Note, Graph is still alive and well at this point

} /* GraphReturnMatrix */

VOID
GraphDereferenceMatrix(
    PISMGRAPH Graph,
    PISM_LINK pLinkArray
    )

/*++

Routine Description:

Release a matrix reference.

The idea behind the reference/dereference api is to allow us to return a
pointer to the matrix instead of copying it each time.  This is useful when
the caller is himself going to copy the data, and will protect our reference
from corruption by users.

The problem with this approach is that a reference to the matrix implies
a reference count on the graph, so it won't go away while it is referenced.
TODO: implement reference counts

Arguments:

    Graph - 
    pLinkArray - 

Return Value:

    None

--*/

{
    // Warning, at this writing there is no reference count on the graph, so
    // it may be NULL or different entirely at this point from when it was
    // referenced.

    // For now, just deallocate the copy
    if (pLinkArray) {
        FREE_TYPE( pLinkArray );
    }

} /* GraphDereferenceMatrix */

DWORD
GraphGetPathSchedule(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

Public routine to get a schedule for a path in the graph.

We try to limit knowlege of the schedule.h structure of the schedule from the other modules.
We return the length here because clients need it and we don't want others to have to
calculate it.

Arguments:

    Graph - 
    From - 
    To - 
    ppSchedule - pointer to pointer to receive pointer to newly allocated schedule
    pLength - pointer to dword to receive length of blob

Return Value:

    DWORD - 

--*/

{
    TOPL_SCHEDULE toplSched;
    PSCHEDULE pSchedule;
    DWORD ErrorCode, length;

    // Validate

    if (Graph->Size != sizeof( ISMGRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        Assert( !"Graph instance is invalid!" );
        return ERROR_INVALID_BLOCK;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        Assert( !"node index is invalid!" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (ppSchedule == NULL) || (pLength == NULL) ) {
        DPRINT( 0, "Invalid parameter\n" );
        Assert( !"Invalid parameter!" );
        return ERROR_INVALID_PARAMETER;
    }

    // Find the schedule if there is one
    toplSched = scheduleFind( Graph, From, To );
    if (toplSched == NULL) {
        *ppSchedule = NULL;
        *pLength = 0;
        return ERROR_SUCCESS;
    }

    // Make a private copy for the user
    __try {
        pSchedule = ToplScheduleExportReadonly( Graph->ScheduleCache, toplSched );
    } __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    if( pSchedule==NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    *ppSchedule = (PBYTE) scheduleAllocCopy( pSchedule );
    if ( *ppSchedule == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pLength = pSchedule->Size;

    return ERROR_SUCCESS;
} /* GraphGetPathSchedule */


#if 0


void
GraphComputeTransitiveClosure(
    IN OUT  GRAPH *     pGraph
    )
/*++

Routine Description:

    Given a graph containing only weighted edges, add in the shortest path
    (i.e., least cost) transitive closure.

    ** NOTE THAT SCHEDULES ARE IGNORED. **

    An adaptation of the Floyd-Warshall algorithm as illustrated in
    "Introduction to Algorithms," p. 556, by Cormen-Leiserson-Rivest, published
    by MIT Press, 1990.

    Runs in O(N^3) time, where N = pGraph->NumberElements.

Arguments:

    pGraph (IN/OUT) - The weighted graph on entry; on exit, its least cost
        transitive closure.

Return Values:

    None.

--*/
{
    DWORD i, j, k;
    DWORD *pCurrCost;
    DWORD Cost1, Cost2;

    Assert(pGraph->NumberElements > 0);

    for (k = 0; k < pGraph->NumberElements; k++) {
        for (i = 0; i < pGraph->NumberElements; i++) {
            for (j = 0; j < pGraph->NumberElements; j++) {
                pCurrCost = &pGraph->LinkArray[i*pGraph->NumberElements + j].ulCost;

                Cost1 = pGraph->LinkArray[i*pGraph->NumberElements + k].ulCost;
                Cost2 = pGraph->LinkArray[k*pGraph->NumberElements + j].ulCost;

                if ((INFINITE_COST != Cost1)
                    && (INFINITE_COST != Cost2)
                    && (Cost1 + Cost2 >= min(Cost1, Cost2))
                    && (Cost1 + Cost2 < *pCurrCost)) {
                    // This path is cheaper than the cheapest one we've
                    // found thus far.
                    *pCurrCost = Cost1 + Cost2;
                }
            }
        }
    }
}
#endif

static BOOL
scheduleValid(
    PBYTE pSchedule
    )
/*++

Routine Description:

Check that the schedule is OK.

Arguments:

    pSchedule - The schedule to examine. May be NULL.
    Note: Never schedules are rejected by this function.

Return Value:

    TRUE - Schedule is OK
    FALSE - Schedule not OK

--*/
{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    
    if (pSchedule == NULL) {
        return TRUE;
    }

    return ToplPScheduleValid( header );
}

static TOPL_SCHEDULE
scheduleFind(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To
    )
/*++

Routine Description:

    Determine if a schedule is present in a graph.

    If the schedule exists, a pointer to the schedule data is returned. This
    schedule is read-only to the caller.
    
    If the schedule is not stored in the graph, NULL is returned. Recall that
    NULL represents the ALWAYS schedule.

Arguments:

    Graph - The graph to search.
    From - The from vertex.
    To - The to vertex.

Return Value:

    TOPL_SCHEDULE - As described above.

--*/
{
    TOPL_SCHEDULE result;

    Assert( From<Graph->NumberElements );
    Assert( To<Graph->NumberElements );
    if( Graph->ScheduleArray==NULL ) {
        return NULL;
    }

    result = Graph->ScheduleArray[From*Graph->NumberElements + To];
    Assert( ToplScheduleValid(result) );

    return result;
}

static void
scheduleArrayFree(
    PISMGRAPH Graph
    )

/*++

Routine Description:

Free the schedule array portion of the graph.  The schedule array portion can be deallocated while
the graph is allocated.  This is a normal mode of the sparse array, and it represents an empty
array.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    DWORD i,j;
    TOPL_SCHEDULE* row, next;

    if (Graph->ScheduleArray == NULL) {
        return;
    }

    FREE_TYPE( Graph->ScheduleArray );
    Graph->ScheduleArray = NULL;
}

static DWORD
scheduleAddDel(
    PISMGRAPH Graph,
    DWORD From,
    DWORD To,
    TOPL_SCHEDULE toplSched
    )
/*++

Routine Description:

Add or delete a schedule from the array.

Arguments:

    Graph - 
    From - 
    To - 
    toplSched -

Return Value:

    ERROR_SUCCESS - Success
    Otherwise - Failure

--*/

{
    DWORD i;

    Assert( From<Graph->NumberElements );
    Assert( To<Graph->NumberElements );
    Assert( ToplScheduleValid(toplSched) );
    DPRINT3( 4, "scheduleAddDel, from=%d, to=%d, toplSched=%p\n",
            From, To, toplSched );

    // Allocate the array headers the first time a schedule is added
    if (Graph->ScheduleArray == NULL) {

        // Nothing to delete
        if (toplSched == NULL) {
            return ERROR_SUCCESS;
        }

        Graph->ScheduleArray = NEW_TYPE_ARRAY_ZERO(
            Graph->NumberElements * Graph->NumberElements,
            TOPL_SCHEDULE );
        if (Graph->ScheduleArray == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    // Find the element in the array
    Assert( NULL!=Graph->ScheduleArray );
    Graph->ScheduleArray[From*Graph->NumberElements + To] = toplSched;
    
    return ERROR_SUCCESS;
}

TOPL_SCHEDULE
scheduleOverlap(
    IN PISMGRAPH Graph,
    IN TOPL_SCHEDULE Schedule1,
    IN TOPL_SCHEDULE Schedule2
    )
/*++

Routine Description:

Determine if two schedules overlap. If so, return a new schedule which represents the common
time periods of the two.

Arguments:

    Schedule1 - This schedule will be merged with Schedule2
    Schedule2 - This schedule will be merged with Schedule1

Return Value:

    The function's returns a pointer to the merged schedule.
    This may either NULL (which represents the 'always' schedule)
    or it will point to pNewSchedule, containing appropriate schedule data.

    Note: This function may raise an exception.

--*/
{
    TOPL_SCHEDULE mergedSchedule;
    BOOLEAN fIsNever;

    mergedSchedule = ToplScheduleMerge(
        Graph->ScheduleCache,
        Schedule1,
        Schedule2,
        &fIsNever);
    
    return mergedSchedule;
} /* scheduleOverlap */

static PSCHEDULE
scheduleAllocCopy(
    PSCHEDULE pSchedule
    )

/*++

Routine Description:

Copy a schedule to a new blob.  This is made a separate function in case we support new
schedule formats.

Arguments:

    pSchedule - 

Return Value:

    PBYTE - 

--*/

{
    PSCHEDULE pNewSchedule;

    if (pSchedule == NULL) {
        return NULL;
    }

    pNewSchedule = (PSCHEDULE) NEW_TYPE_ARRAY( pSchedule->Size, BYTE );
    if (pNewSchedule == NULL) {
        return NULL;
    }

    CopyMemory( (PBYTE) pNewSchedule, (PBYTE) pSchedule, pSchedule->Size );

    return pNewSchedule;
} /* scheduleAllocCopy */

/* end graph.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\transprt.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    transprt.cxx

ABSTRACT:

    ISM_TRANSPORT class.  Abstracts interaction with specific plug-in
    transports, defined by DS objects of class Site-Transport.

    Also contains ISM_TRANSPORT_LIST class, which abstracts a collection of
    ISM_TRANSPORT objects.

DETAILS:

CREATED:

    97/12/03    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>
#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>
#include <ntldap.h>
#include "ismserv.hxx"

#define DEBSUB "TRANSPRT:"
#define FILENO FILENO_ISMSERV_TRANSPRT


////////////////////////////////////////////////////////////////////////////////
//
// Constants
//

#define REFRESH_TRANSPORT_INTERVAL_SECS     60*60*8     // 8 hours

LPWSTR ISM_TRANSPORT_LIST::rgpszTransportAttrsToRead[] =
    {L"objectGuid", L"objectClass", L"transportDllName", L"isDeleted", NULL};


////////////////////////////////////////////////////////////////////////////////
//
//  ISM_TRANSPORT methods.
//

void
ISM_TRANSPORT::Destroy()
/*++

Routine Description:

    Free the resources associated with an ISM_TRANSPORT object, returning it to
    its un-Init()'ed state.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if (m_fIsInitialized) {
        m_fIsInitialized = FALSE;

        delete [] m_pszTransportDN;

        delete [] m_pszTransportDll;

        (*m_pShutdown)(
            m_hIsm,
            (gService.IsStoppingAndBeingRemoved() ?
             ISM_SHUTDOWN_REASON_REMOVAL : ISM_SHUTDOWN_REASON_NORMAL )
            );

        FreeLibrary(m_hDll);

        Reset();
    }
}


BOOL
ISM_TRANSPORT::ValidTransportDllName(
    IN  LPCWSTR         pszTransportDll
    )
/*++

Routine Description:

    Determine if a transportDllName is valid

Arguments:

    pszTransportDll (IN) - Name of the associated transport plug-in DLL.

Return Values:

    TRUE - Valid
    FALSE - Invalid

--*/

{
    LPWSTR  rgwszValidDllNames[] = { L"ismip.dll", L"ismsmtp.dll" };
    DWORD   iName, cValidNames = ARRAY_SIZE(rgwszValidDllNames);

    for( iName=0; iName<cValidNames; iName++ ) {
        if( 0==_wcsicmp( pszTransportDll, rgwszValidDllNames[iName] ) ) {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
ISM_TRANSPORT::Init(
    IN  LPCWSTR         pszTransportDN,
    IN  const GUID *    pTransportGuid,
    IN  LPCWSTR         pszTransportDll
    )
/*++

Routine Description:

    Initialize an ISM_TRANSPORT object.

Arguments:

    pszTransportDN (IN) - The DN of the corresponding Inter-Site-Transport
        object.
    pTransportGuid (IN) - The objectGuid of the corresponding Inter-Site-Transport
        object.
    pszTransportDll (IN) - Name of the associated transport plug-in DLL.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err = NO_ERROR;
    BOOL  fStarted = FALSE;
    LPSTR pszExport = NULL;

    Assert(!m_fIsInitialized);

    if( ValidTransportDllName(pszTransportDll) ) {

        // Load plug-in DLL and retrieve its exports.
        m_hDll = LoadLibraryW(pszTransportDll);
        if (NULL == m_hDll) {
            err = GetLastError();
            DPRINT2(0, "Failed to load transport plug-in DLL %ls, error %d.\n",
                    pszTransportDll, err);
        }

    } else {
        err = ERROR_INVALID_NAME;
        DPRINT1(0, "Transport plug-in DLL %ls has invalid name\n", pszTransportDll);
    } 
    
#define GET_EXPORT(name, type, var) \
    (pszExport = name, var = (type *) GetProcAddress(m_hDll, pszExport))

    if ((NO_ERROR == err)
        && GET_EXPORT("IsmStartup",                ISM_STARTUP,                  m_pStartup)
        && GET_EXPORT("IsmRefresh",                ISM_REFRESH,                  m_pRefresh)
        && GET_EXPORT("IsmSend",                   ISM_SEND,                     m_pSend)
        && GET_EXPORT("IsmReceive",                ISM_RECEIVE,                  m_pReceive)
        && GET_EXPORT("IsmFreeMsg",                ISM_FREE_MSG,                 m_pFreeMsg)
        && GET_EXPORT("IsmGetConnectivity",        ISM_GET_CONNECTIVITY,         m_pGetConnectivity)
        && GET_EXPORT("IsmFreeConnectivity",       ISM_FREE_CONNECTIVITY,        m_pFreeConnectivity)
        && GET_EXPORT("IsmGetTransportServers",    ISM_GET_TRANSPORT_SERVERS,    m_pGetTransportServers)
        && GET_EXPORT("IsmFreeTransportServers",   ISM_FREE_TRANSPORT_SERVERS,   m_pFreeTransportServers)
        && GET_EXPORT("IsmGetConnectionSchedule",  ISM_GET_CONNECTION_SCHEDULE,  m_pGetConnectionSchedule)
        && GET_EXPORT("IsmFreeConnectionSchedule", ISM_FREE_CONNECTION_SCHEDULE, m_pFreeConnectionSchedule)
        && GET_EXPORT("IsmQuerySitesByCost",       ISM_QUERY_SITES_BY_COST,      m_pQuerySitesByCost)
        && GET_EXPORT("IsmFreeSiteCostInfo",       ISM_FREE_SITE_COST_INFO,      m_pFreeSiteCostInfo)
        && GET_EXPORT("IsmShutdown",               ISM_SHUTDOWN,                 m_pShutdown)) {

        DPRINT1(1, "Loaded transport plug-in DLL %ls.\n", pszTransportDll);
    }
    else {
        err = GetLastError();
        DPRINT3(0, "Failed to find export %s in plug-in DLL %ls, error %d.\n",
                pszExport, pszTransportDll, err);
    }

    if (NO_ERROR == err) {
        // Call transport DLL startup routine.
        err = (*m_pStartup)(pszTransportDN, Notify, this, &m_hIsm);
        fStarted = (NO_ERROR == err);
    }

    if (NO_ERROR == err) {
        // Save transport DN.
        DWORD cchTransportDN = wcslen(pszTransportDN) + 1;
        m_pszTransportDN = new WCHAR[cchTransportDN];

        if (NULL != m_pszTransportDN) {
            memcpy(m_pszTransportDN, pszTransportDN,
                   cchTransportDN * sizeof(WCHAR));
        }
        else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (NO_ERROR == err) {
        // Save transport guid.
        m_TransportGuid = *pTransportGuid;
    }

    if (NO_ERROR == err) {
        // Save transport DLL name.
        DWORD cchTransportDll = wcslen(pszTransportDll) + 1;
        m_pszTransportDll = new WCHAR[cchTransportDll];

        if (NULL != m_pszTransportDll) {
            memcpy(m_pszTransportDll, pszTransportDll,
                   cchTransportDll * sizeof(WCHAR));
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (NO_ERROR == err) {
        DPRINT1(0, "Transport %ls initialized.\n", pszTransportDN);
        m_fIsInitialized = TRUE;
    }
    else {
        DPRINT2(0, "Failed to initialize transport %ls, error %d.\n",
                pszTransportDN, err);

        if (NULL != m_pszTransportDN) {
            delete [] m_pszTransportDN;
        }

        if (NULL != m_pszTransportDll) {
            delete [] m_pszTransportDll;
        }

        if (fStarted) {
            // We could pass ISM_SHUTDOWN_REASON_ERROR if this were useful?
            (*m_pShutdown)(m_hIsm, ISM_SHUTDOWN_REASON_NORMAL);
        }

        if (NULL != m_hDll) {
            FreeLibrary(m_hDll);
        }

        Reset();

        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_TRANSPORT_LOAD_FAILURE,
                  szInsertWC(pszTransportDN),
                  szInsertWC(pszTransportDll),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL );
    }

    return err;
}


DWORD
ISM_TRANSPORT::Refresh(
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR     pszObjectDN
    )
/*++

Routine Description:

    Signals a change in the Inter-Site-Transport object.

Arguments:

    eReason (IN) - Reason code for refresh

    pszObjectDN (IN) - DN of the transport object.  Might be different
        from the value originally given in the Init() call, as the transport
        object can be renamed.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);
    err = (*m_pRefresh)(m_hIsm, eReason, pszObjectDN);

    if (NO_ERROR != err) {

        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_TRANSPORT_REFRESH_FAILURE,
                  szInsertWC(pszObjectDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL, NULL );
    }

    return err;
}


void
ISM_TRANSPORT::Notify(
    IN  void *      pvThis,
    IN  LPCWSTR     pszServiceName
    )
{
    ISM_TRANSPORT * pTransport = (ISM_TRANSPORT *) pvThis;

    DPRINT2(3, "Message pending for %ls on transport %ls.\n", pszServiceName,
            pTransport->GetDN());

    LogEvent(DS_EVENT_CAT_ISM,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_ISM_MESSAGE_PENDING,
             szInsertWC(pszServiceName),
             szInsertWC(pTransport->GetDN()),
             NULL);

    pTransport->m_PendingList.Add(pTransport->GetDN(), pszServiceName);
}


////////////////////////////////////////////////////////////////////////////////
//
//  ISM_TRANSPORT_LIST methods.
//

ISM_TRANSPORT *
ISM_TRANSPORT_LIST::Get(
    IN  const GUID *      pTransportGuid
    )
/*++

Routine Description:

    Retrieve the member transport that was initialized from the
    Inter-Site-Transport object with the given objectGuid, or NULL if none.

Arguments:

    pTransportGuid (IN) - The objectGuid to look for.

Return Values:

    A pointer to the associated ISM_TRANSPORT object, or NULL if none.

--*/
{
    for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
        if (0 == memcmp(m_ppTransport[iTransport]->GetGUID(),
                        pTransportGuid, sizeof(GUID))) {
            return m_ppTransport[iTransport];
        }
    }

    return NULL;
}


void
ISM_TRANSPORT_LIST::Destroy()
/*++

Routine Description:

    Free the resources associated with an ISM_TRANSPORT_LIST object, returning
    it to its un-Init()'ed state.

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err;
    DWORD win32err;
    // Run down the transport notification thread

    if ( (NULL != m_hLdap) && (m_ulTransportNotifyMsgNum) ) {
        err = ldap_abandon(m_hLdap, m_ulTransportNotifyMsgNum);
        if (0 != err) { 
            if (!gService.IsStopping()) {
                win32err = LdapMapErrorToWin32(err);
                LogEvent8(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ABANDON_FAILED,  
                    szInsertWin32Msg( win32err ),
                    szInsertWin32ErrCode( win32err ),
                    NULL, NULL, NULL, NULL, NULL, NULL );
                DPRINT2(0, "Failed to abandon transport notif search -- err %d, %d!\n",
                    err, m_hLdap->ld_errno);
            }
        }
    }

    if (NULL != m_hTransportMonitorThread) {
        err = WaitForSingleObject(m_hTransportMonitorThread, 3*1000);

        if (WAIT_OBJECT_0 != err) {
            DWORD gle = GetLastError();
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
                szInsertWin32Msg( gle ),
                szInsertWin32ErrCode( gle ),
                NULL, NULL, NULL, NULL, NULL, NULL );
            DPRINT2(0, "Transport monitor thread failed to terminate -- err %d, gle %d!\n",
                    err, gle);
        }

        CloseHandle(m_hTransportMonitorThread);
    }

    // Run down the site notification thread

    if ( (NULL != m_hLdap)  && (m_ulSiteNotifyMsgNum) ) {
        err = ldap_abandon(m_hLdap, m_ulSiteNotifyMsgNum);
        if (0 != err) {
            if (!gService.IsStopping()) {
                win32err = LdapMapErrorToWin32(err);
                LogEvent8(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ABANDON_FAILED,  
                    szInsertWin32Msg( win32err ),
                    szInsertWin32ErrCode( win32err ),
                    NULL, NULL, NULL, NULL, NULL, NULL );
                DPRINT2(0, "Failed to abandon site notif search -- err %d, %d!\n",
                    err, m_hLdap->ld_errno);
            }
        }
    }

    if (NULL != m_hSiteMonitorThread) {
        err = WaitForSingleObject(m_hSiteMonitorThread, 3*1000);

        if (WAIT_OBJECT_0 != err) {
            DWORD gle = GetLastError();
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
                szInsertWin32Msg( gle ),
                szInsertWin32ErrCode( gle ),
                NULL, NULL, NULL, NULL, NULL, NULL );
            DPRINT2(0, "Site monitor thread failed to terminate -- err %d, gle %d!\n",
                    err, gle);
        }

        CloseHandle(m_hSiteMonitorThread);
    }

    for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
        delete m_ppTransport[iTransport];
    }

    // Yes, realloc() and free() are used since there is no equivalent of
    // realloc() in the new/delete family.
    free(m_ppTransport);

    delete [] m_pszTransportContainerDN;
    delete [] m_pszSiteContainerDN;

    if (NULL != m_hLdap) {
        ldap_unbind(m_hLdap);
    }

    Reset();
}


ISM_TRANSPORT *
ISM_TRANSPORT_LIST::Get(
    IN  LPCWSTR   pszTransportDN
    )
/*++

Routine Description:

    Retrieve the member transport that was initialized from the
    Inter-Site-Transport object with the given DN, or NULL if none.

Arguments:

    pszTransportDN (IN) - The DN to look for.

Return Values:

    A pointer to the associated ISM_TRANSPORT object, or NULL if none.

--*/
{
    Assert(NULL != pszTransportDN);

    if (NULL != pszTransportDN) {
        for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
            if (!_wcsicmp(m_ppTransport[iTransport]->GetDN(), pszTransportDN)) {
                return m_ppTransport[iTransport];
            }
        }
    }

    return NULL;
}


DWORD
ISM_TRANSPORT_LIST::Init()
/*++

Routine Description:

    Initialize the ISM_TRANSPORT_LIST object, populating it with all the
    configured transports.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    AcquireWriteLock();
    __try {
        m_hChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hChangeEvent) {
            err = GetLastError();
            DPRINT1(0, "Unable to CreateEvent(), error %d.\n", err);
            Destroy();
            return err;
        }

        err = InitializeTransports();
        if (NO_ERROR != err) {
            DPRINT1(0, "Unable to InitializeTransports(), error %d.\n", err);
            Destroy();
            return err;
        }

        m_fIsInitialized = TRUE;
    } __finally {
        ReleaseLock();
    }

    return NO_ERROR;
}


DWORD
ISM_TRANSPORT_LIST::Add(
    IN  LPCWSTR         pszTransportDN,
    IN  const GUID *    pTransportGuid,
    IN  LPCWSTR         pszTransportDll
    )
/*++

Routine Description:

    Add given transport with the given definition to the set.

Arguments:

    pszTransportDN (IN) - The DN of the corresponding Inter-Site-Transport
        object.
    pTransportGuid (IN) - The objectGuid of the corresponding Inter-Site-Transport
        object.
    pszTransportDll (IN) - Name of the associated transport plug-in DLL.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD               err;
    ISM_TRANSPORT *     pTransport;
    ISM_TRANSPORT **    ppNewTransportList;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_Lock));

    pTransport = new ISM_TRANSPORT;

    if (NULL != pTransport) {
        err = pTransport->Init(pszTransportDN, pTransportGuid, pszTransportDll);

        if (NO_ERROR == err) {
            // Yes, realloc() and free() are used since there is no equivalent
            // of realloc() in the new/delete family.
            ppNewTransportList =
                (ISM_TRANSPORT **) realloc(m_ppTransport,
                                           sizeof(m_ppTransport[0])
                                             * (1 + m_cNumTransports));

            if (NULL != ppNewTransportList) {
                m_ppTransport = ppNewTransportList;
                m_ppTransport[m_cNumTransports++] = pTransport;
            }
            else {
                DPRINT(0, "Out of memory.\n");
                delete pTransport;
                err = ERROR_OUTOFMEMORY;
            }
        }
        else {
            DPRINT2(0, "Transport %ls failed to initialize, error %d.\n",
                    pszTransportDN, err);
            delete pTransport;
        }
    }
    else {
        DPRINT(0, "Out of memory.\n");
        err = ERROR_OUTOFMEMORY;
    }

    return err;
}


DWORD
ISM_TRANSPORT_LIST::ReloadTransports(
    VOID
    )
/*++

Routine Description:

    Do an LDAP search to grab relevant information about the transport
    objects and then call UpdateTransportObjects(). 

    Note: Updating the transport objects does not cause the cached
    cost-matrix to be flushed.

    Note: Assumes that a write-lock is held for the transport list.

Parameters:

    None

Return value:

    On success, return ERROR_SUCCESS
    On failure, logs an event log message and return the Win32 error code

--*/
{
    LDAPMessage *   pResults;
    int             ldStatus;
    DWORD           win32err = ERROR_SUCCESS;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_Lock));
    Assert(this->m_hChangeEvent);

    pResults = NULL;
    ldStatus = ldap_search_s(
                    m_hLdap,
                    m_pszTransportContainerDN,
                    LDAP_SCOPE_ONELEVEL,
                    L"(objectClass=interSiteTransport)",
                    rgpszTransportAttrsToRead,
                    0,
                    &pResults
                    );

    if (LDAP_SUCCESS == ldStatus) {
        win32err = UpdateTransportObjects(pResults);
        SetEvent(this->m_hChangeEvent);
    } else {
        DPRINT1(0,"Failed to ldap_search_s(), ldap error %d.\n", ldStatus);
        win32err = LdapMapErrorToWin32(ldStatus);
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
            szInsertWC( m_pszTransportContainerDN ),
            szInsertWin32Msg( win32err ),  
            szInsertWin32ErrCode( win32err ),  
            NULL, NULL, NULL, NULL, NULL );
    }

    // bug 327001, ldap_search* functions can return failure and still allocate
    // the result buffer.
    if (pResults) {
        ldap_msgfree(pResults);
    }

    return win32err;
}


DWORD
ISM_TRANSPORT_LIST::InitializeTransports()
/*++

Routine Description:

    Add an ISM_TRANSPORT object for each Inter-Site-Transport object configured
    in the DS.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    DWORD           win32err;
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext", NULL};
    LPWSTR          rgpszSiteAttrsToRead[] = {L"objectGuid", L"objectClass", L"isDeleted", NULL};
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};
    ULONG           ulOptions;

    Assert(0 == m_cNumTransports);

    // Connect.
    m_hLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == m_hLdap) {
        DPRINT(0, "Failed to open LDAP connection.\n");
        ldStatus = LDAP_SERVER_DOWN;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW(m_hLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Bind.
    if (LDAP_SUCCESS == ldStatus) {

        // Force LDAP V3.  Without this, the LDAP client dumbs down to V2 and
        // rejects any searches that use controls.
        Assert(m_hLdap);
        m_hLdap->ld_version = LDAP_VERSION3;

        ldStatus = ldap_bind_s(m_hLdap, NULL, NULL, LDAP_AUTH_NTLM);
        if (LDAP_SUCCESS != ldStatus) {  
            DPRINT1(0, "Failed to ldap_bind_s(), ldap error %d.\n", ldStatus); 
            win32err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_BIND_FAILED,  
                szInsertWin32Msg( win32err ),
                szInsertWin32ErrCode( win32err ),
                NULL, NULL, NULL, NULL, NULL, NULL );
        }
    }

    // Get the configuration NC.
    if (LDAP_SUCCESS == ldStatus) {
        pResults = NULL;
        ldStatus = ldap_search_s(
                        m_hLdap,
                        NULL,
                        LDAP_SCOPE_BASE,
                        L"(objectClass=*)",
                        rgpszRootAttrsToRead,
                        0,
                        &pResults
                        );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0, "Failed to ldap_search_s() the root, ldap error %d.\n", ldStatus);
            win32err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,  
                szInsertWC( rgpszRootAttrsToRead[0] ),
                szInsertWin32Msg( win32err ),  
                szInsertWin32ErrCode( win32err ),  
                NULL, NULL, NULL, NULL, NULL );
            // bug 327001, ldap_search* functions can return failure and still allocate
            // the result buffer.
            if (pResults) {
                ldap_msgfree(pResults);
            }
        }
    }

    // Derive the location of the Inter-Site Transports container.
    if (LDAP_SUCCESS == ldStatus) {
        const WCHAR szSitesPrefix[] = L"CN=Sites,";
        const WCHAR szTransportsPrefix[] = L"CN=Inter-Site Transports,";
        LPWSTR * ppszConfigNC;
        DWORD cchConfigNC;

        pEntry = ldap_first_entry(m_hLdap, pResults);
        Assert(NULL != pEntry);

        ppszConfigNC = ldap_get_values(m_hLdap, pEntry, L"configurationNamingContext");
        Assert(NULL != ppszConfigNC);
        Assert(1 == ldap_count_values(ppszConfigNC));

        cchConfigNC = wcslen(*ppszConfigNC);

        // Build the sites container
        m_pszSiteContainerDN = new WCHAR[cchConfigNC + ARRAY_SIZE(szSitesPrefix)];
        if (NULL != m_pszSiteContainerDN) {
            wcscpy(m_pszSiteContainerDN, szSitesPrefix);
            wcscat(m_pszSiteContainerDN, *ppszConfigNC);

            DPRINT1(0, "Site container is %ls.\n", m_pszSiteContainerDN);
        }
        else {
            DPRINT(0, "Out of memory.\n");
            ldStatus = LDAP_NO_MEMORY;
        }

        // Build the transports container
        if (LDAP_SUCCESS == ldStatus) {
            m_pszTransportContainerDN = new WCHAR[cchConfigNC + ARRAY_SIZE(szSitesPrefix) - 1 + ARRAY_SIZE(szTransportsPrefix) ];
            if (NULL != m_pszTransportContainerDN) {
                wcscpy(m_pszTransportContainerDN, szTransportsPrefix);
                wcscat(m_pszTransportContainerDN, szSitesPrefix);
                wcscat(m_pszTransportContainerDN, *ppszConfigNC);

                DPRINT1(0, "Transport container is %ls.\n", m_pszTransportContainerDN);
            }
            else {
                DPRINT(0, "Out of memory.\n");
                ldStatus = LDAP_NO_MEMORY;
            }
        }

        ldap_value_free(ppszConfigNC);

        ldap_msgfree(pResults);
    }

    // Register to receive notifications of changes in the contents of the
    // sites container.
    // Note that we start the notification before the initial read so that
    // we are assured there isn't a timing window after the read where
    // changes could be made before the notification is established.
    if (LDAP_SUCCESS == ldStatus) {
        ldStatus = ldap_search_ext(
                        m_hLdap,
                        m_pszSiteContainerDN,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=*)",
                        rgpszSiteAttrsToRead,
                        0,
                        rgpctrlServerCtrls,
                        NULL,
                        0,
                        0,
                        &m_ulSiteNotifyMsgNum
                        );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to site ldap_search_ext(), ldap error %d.\n",ldStatus);
            win32err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
                szInsertWC( m_pszSiteContainerDN ),
                szInsertWin32Msg( win32err ),  
                szInsertWin32ErrCode( win32err ),  
                NULL, NULL, NULL, NULL, NULL );
        }
    }

    // Register to receive notifications of changes in the contents of the
    // transports container.
    if (LDAP_SUCCESS == ldStatus) {
        ldStatus = ldap_search_ext(
                        m_hLdap,
                        m_pszTransportContainerDN,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=*)",
                        rgpszTransportAttrsToRead,
                        0,
                        rgpctrlServerCtrls,
                        NULL,
                        0,
                        0,
                        &m_ulTransportNotifyMsgNum
                        );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to transport ldap_search_ext(), ldap error %d.\n",ldStatus);
            win32err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
                szInsertWC( m_pszTransportContainerDN ),
                szInsertWin32Msg( win32err ),  
                szInsertWin32ErrCode( win32err ),  
                NULL, NULL, NULL, NULL, NULL );
        }
    }

    // Query for initial contents of transports container.
    if (LDAP_SUCCESS == ldStatus) {
        err = ReloadTransports();
    } else {
        err = LdapMapErrorToWin32(ldStatus);
    }

    // Start monitoring sites container
    if (NO_ERROR == err) {
        unsigned tid;

        m_hSiteMonitorThread = (HANDLE) _beginthreadex(
                                        NULL,
                                        0,
                                        &MonitorSiteContainerThread,
                                        this,
                                        0,
                                        &tid
                                        );
        if (NULL == m_hSiteMonitorThread) {
            DPRINT(0, "Failed to start MonitorTransportsContainerThread().\n");
            err = -1;
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_TRANSPORT_MONITOR_START_FAILURE,    
                NULL,  NULL, NULL );
        }
    }

    // Start monitoring transport container
    if (NO_ERROR == err) {
        unsigned tid;

        m_hTransportMonitorThread = (HANDLE) _beginthreadex(
                                        NULL,
                                        0,
                                        &MonitorTransportsContainerThread,
                                        this,
                                        0,
                                        &tid
                                        );
        if (NULL == m_hTransportMonitorThread) {
            DPRINT(0, "Failed to start MonitorTransportsContainerThread().\n");
            err = -1;
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_TRANSPORT_MONITOR_START_FAILURE,    
                NULL, NULL, NULL );
        }
    }

    return err;
}


unsigned int
__stdcall
ISM_TRANSPORT_LIST::MonitorSiteContainerThread(
    IN  void *  pvThis
    )
/*++

Routine Description:

    Query the DS for any changes in the Site objects and, if
    changes have been made, reflect those changes in the ISM_TRANSPORT object
    list.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err;
    int                     ldStatus;
    LDAPMessage *           pResults;
    ISM_TRANSPORT_LIST *    pThis = (ISM_TRANSPORT_LIST *) pvThis;
    int                     ldResType;
    LPWSTR          rgpszSiteAttrsToRead[] = {L"objectGuid", L"objectClass", L"isDeleted", NULL};
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};

    // pThis->m_fIsInitialized is not set yet
    Assert(pThis->m_hLdap && pThis->m_ulSiteNotifyMsgNum);

    while (1) {

        do {
            // Wait for changes in the sites container.
            ldResType = ldap_result(
                pThis->m_hLdap,
                pThis->m_ulSiteNotifyMsgNum,
                LDAP_MSG_ONE,
                NULL,     // No timeout (wait forever).
                &pResults
                );

            if (gService.IsStopping()) {
                ldStatus = LDAP_SUCCESS;
                break;
            }

            ldStatus = pThis->m_hLdap->ld_errno;

            DPRINT3(2, "Back from site ldap_result(): ldResType = 0x%x, ldStatus = 0x%x, pResults = %p.\n",
                    ldResType, ldStatus, pResults);

            if (LDAP_RES_SEARCH_ENTRY == ldResType) {
                Assert(LDAP_SUCCESS == ldStatus);

                pThis->AcquireWriteLock();
                __try {
                    ldStatus = pThis->UpdateSiteObjects(pResults);

                    ldap_msgfree(pResults);
                }
                __finally {
                    pThis->ReleaseLock();
                }
            }
        } while (LDAP_SUCCESS == ldStatus);

        // See if we are really shutting down
        err = WaitForSingleObject( gService.m_hShutdown, 60 * 1000 );
        if ( (err != WAIT_OBJECT_0) &&
             (err != WAIT_TIMEOUT) ) {
            DWORD gle = GetLastError();
            DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                     err, gle );
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
                szInsertWin32Msg( gle ),
                szInsertWin32ErrCode( gle ),
                NULL, NULL, NULL, NULL, NULL, NULL );
        }

        if (gService.IsStopping()) {
            // Ignore errors on shutdown
            err = LDAP_SUCCESS;
            break;
        }

        DPRINT1(0, "Failed to site ldap_result(), error %d; retrying notification.\n",
                ldStatus);
        err = LdapMapErrorToWin32(ldStatus);
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                  szInsertWC(pThis->m_pszSiteContainerDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL, NULL );
        // Assert( !"Ldap search terminated prematurely" );

        // Error recovery - start a new search
        // This can occur under some legitimate circumstances, such as when
        // Kerberos tickets expire.

        err = ldap_abandon(pThis->m_hLdap, pThis->m_ulSiteNotifyMsgNum);
        // ignore error

        ldStatus = ldap_search_ext(
            pThis->m_hLdap,
            pThis->m_pszSiteContainerDN,
            LDAP_SCOPE_ONELEVEL,
            L"(objectClass=*)",
            rgpszSiteAttrsToRead,
            0,
            rgpctrlServerCtrls,
            NULL,
            0,
            0,
            &(pThis->m_ulSiteNotifyMsgNum)
            );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to site ldap_search_ext(), ldap error %d.\n",ldStatus);
            err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_TRANSPORT_MONITOR_FAILURE,
                      szInsertWin32Msg(err),
                      szInsertWin32ErrCode(err),
                      NULL, NULL, NULL, NULL, NULL, NULL );
            break;
        }

    } // while (1)

    return err;
}


unsigned int
__stdcall
ISM_TRANSPORT_LIST::MonitorTransportsContainerThread(
    IN  void *  pvThis
    )
/*++

Routine Description:

    Query the DS for any changes in the Inter-Site-Transport objects and, if
    changes have been made, reflect those changes in the ISM_TRANSPORT object
    list.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err;
    int                     ldStatus;
    LDAPMessage *           pResults;
    ISM_TRANSPORT_LIST *    pThis = (ISM_TRANSPORT_LIST *) pvThis;
    int                     ldResType;
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};
    struct l_timeval        timeout;

    // pThis->m_fIsInitialized is not set yet
    Assert(pThis->m_hLdap && pThis->m_ulTransportNotifyMsgNum);

    // Set a timeout waiting for search results in case notifications are lost
    timeout.tv_sec = REFRESH_TRANSPORT_INTERVAL_SECS;

    while (1) {

        do {
            // Wait for changes in the transports container.
            ldResType = ldap_result(
                pThis->m_hLdap,
                pThis->m_ulTransportNotifyMsgNum,
                LDAP_MSG_ONE,
                &timeout,
                &pResults
                );

            if (gService.IsStopping()) {
                ldStatus = LDAP_SUCCESS;
                break;
            }

            if( 0==ldResType ) {
                // Timeout expired; reload transports

                pThis->AcquireWriteLock();
                __try {
                    ldStatus = pThis->ReloadTransports();
                } __finally {
                    pThis->ReleaseLock();
                }

                // If we failed to reload the transports we break out of
                // this loop and log an event below.
            }

            ldStatus = pThis->m_hLdap->ld_errno;

            DPRINT3(2, "Back from transport ldap_result(): ldResType = 0x%x, "
                    "ldStatus = 0x%x, pResults = %p.\n",
                    ldResType, ldStatus, pResults);

            if (LDAP_RES_SEARCH_ENTRY == ldResType) {
                Assert(LDAP_SUCCESS == ldStatus);

                pThis->AcquireWriteLock();
                __try {
                    // Inform interested parties that the transport list is
                    // changing.
                    SetEvent(pThis->m_hChangeEvent);

                    ldStatus = pThis->UpdateTransportObjects(pResults);

                    ldap_msgfree(pResults);
                }
                __finally {
                    pThis->ReleaseLock();
                }
            }
        } while (LDAP_SUCCESS == ldStatus);

        // See if we are really shutting down
        err = WaitForSingleObject( gService.m_hShutdown, 60 * 1000 );
        if ( (err != WAIT_OBJECT_0) &&
             (err != WAIT_TIMEOUT) ) {
            DWORD gle = GetLastError();
            DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                     err, gle );
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
                szInsertWin32Msg( gle ),
                szInsertWin32ErrCode( gle ),
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL
                );
        }

        if (gService.IsStopping()) {
            // Ignore errors on shutdown
            err = ERROR_SUCCESS;
            break;
        }

        DPRINT1(0, "Failed to transport ldap_result(), error %d; retrying notification.\n",
                ldStatus);
        err = LdapMapErrorToWin32(ldStatus);
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                  szInsertWC(pThis->m_pszTransportContainerDN),
                  szInsertWin32Msg(err),
                  szInsertWin32ErrCode(err),
                  NULL, NULL, NULL, NULL, NULL );
        // Assert( !"Ldap search terminated prematurely" );

        // Error recovery - start a new search
        // This can occur under some legitimate circumstances, such as when
        // Kerberos tickets expire.

        err = ldap_abandon(pThis->m_hLdap, pThis->m_ulTransportNotifyMsgNum);
        // ignore error

        ldStatus = ldap_search_ext(
            pThis->m_hLdap,
            pThis->m_pszTransportContainerDN,
            LDAP_SCOPE_ONELEVEL,
            L"(objectClass=*)",
            rgpszTransportAttrsToRead,
            0,
            rgpctrlServerCtrls,
            NULL,
            0,
            0,
            &(pThis->m_ulTransportNotifyMsgNum)
            );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to transport ldap_search_ext(), ldap error %d.\n",ldStatus);

            err = LdapMapErrorToWin32(ldStatus);
            LogEvent8(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_TRANSPORT_MONITOR_FAILURE,
                              szInsertWin32Msg(err),
                              szInsertWin32ErrCode(err),
                              NULL, NULL, NULL, NULL, NULL, NULL );
            break;
        }

    } // while (1)

    return err;
}


int
ISM_TRANSPORT_LIST::UpdateSiteObjects(
    IN  LDAPMessage *   pResults
    )
/*++

Routine Description:

Notify the transport objects of changes to the site list

Arguments:

    pResults (IN) - The DS objects.

Return Values:

    LDAP_SUCCESS - Success.
    LDAP_* - Failure.

--*/
{
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pEntry;

    // For each site object...
    for (pEntry = ldap_first_entry(m_hLdap, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(m_hLdap, pEntry)) {

        LPWSTR              pszSiteDN;
        LPWSTR *            ppszObjectClass;
        LPWSTR *            ppszIsDeleted;
        struct berval **    ppbvObjectGuid;
        GUID *              pObjectGuid;
        BOOL                fIsDeleted;
        ISM_TRANSPORT *     pTransport;
        DWORD               err, iTransport;

        // Retrieve its interesting attributes.
        pszSiteDN = ldap_get_dn(m_hLdap, pEntry);
        Assert(NULL != pszSiteDN);

        ppbvObjectGuid = ldap_get_values_len(m_hLdap, pEntry, L"objectGuid");
        Assert(NULL != ppbvObjectGuid);

        ppszObjectClass = ldap_get_values(m_hLdap, pEntry, L"objectClass");
        Assert(NULL != ppszObjectClass);

        ppszIsDeleted = ldap_get_values(m_hLdap, pEntry, L"isDeleted");

        if ((NULL != pszSiteDN)
            && (NULL != ppbvObjectGuid)
            && (NULL != ppszObjectClass)) {

            Assert(1 == ldap_count_values_len(ppbvObjectGuid));
            Assert(sizeof(GUID) == ppbvObjectGuid[0]->bv_len);
            Assert((NULL == ppszIsDeleted)
                   || (1 == ldap_count_values(ppszIsDeleted)));

            fIsDeleted = (NULL != ppszIsDeleted)
                         && (0 == _wcsicmp(*ppszIsDeleted, L"TRUE"));

            pObjectGuid = (GUID *) ppbvObjectGuid[0]->bv_val;

            // Notify transports
            for( iTransport = 0; iTransport < m_cNumTransports; iTransport++ ){
                pTransport = m_ppTransport[iTransport];

                // Notify on all kinds of site changes
                err = pTransport->Refresh(ISM_REFRESH_REASON_SITE, pszSiteDN);
                if (NO_ERROR == err) {
                    DPRINT2(0, "Refreshed transport %ls with site %ls.\n",
                            pTransport->GetDN(), pszSiteDN);
                }
                else {
                    DPRINT3(0, "Failed to refresh transport %ls with site %ls, error %d.\n",
                            pTransport->GetDN(), pszSiteDN, err);
                }
            }
        }
        else {
            DPRINT1(0, "Failed to read critical attributes for site %ls; ignoring.\n",
                    pszSiteDN ? pszSiteDN : L"");
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_CRITICAL_SITE_ATTRIBUTE_FAILURE,  
                szInsertWC( pszSiteDN ),
                NULL,
                NULL
                );
        }

        if (NULL != pszSiteDN) {
            ldap_memfree(pszSiteDN);
        }

        if (NULL != ppbvObjectGuid) {
            ldap_value_free_len(ppbvObjectGuid);
        }

        if (NULL != ppszObjectClass) {
            ldap_value_free(ppszObjectClass);
        }

        if (NULL != ppszIsDeleted) {
            ldap_value_free(ppszIsDeleted);
        }
    }

    return ldStatus;
}

int
ISM_TRANSPORT_LIST::UpdateTransportObjects(
    IN  LDAPMessage *   pResults
    )
/*++

Routine Description:

    Update the list of in-memory ISM_TRANSPORT objects given a set of
    corresponding DS objects.

    Note: Assumes that a write-lock is held for the transport list.

Arguments:

    pResults (IN) - The DS objects.

Return Values:

    LDAP_SUCCESS - Success.
    LDAP_* - Failure.

--*/
{
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pEntry;

    // For each transport object...
    for (pEntry = ldap_first_entry(m_hLdap, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(m_hLdap, pEntry)) {

        LPWSTR              pszTransportDN;
        LPWSTR *            ppszTransportDll;
        LPWSTR *            ppszObjectClass;
        LPWSTR *            ppszIsDeleted;
        struct berval **    ppbvObjectGuid;
        GUID *              pObjectGuid;
        BOOL                fIsDeleted;
        ISM_TRANSPORT *     pTransport;
        DWORD               err;
        BOOL                fAddNewTransport;

        // Retrieve its interesting attributes.
        pszTransportDN = ldap_get_dn(m_hLdap, pEntry);
        Assert(NULL != pszTransportDN);

        ppbvObjectGuid = ldap_get_values_len(m_hLdap, pEntry, L"objectGuid");
        Assert(NULL != ppbvObjectGuid);
        Assert(1 == ldap_count_values_len(ppbvObjectGuid));
        Assert(sizeof(GUID) == ppbvObjectGuid[0]->bv_len);

        ppszObjectClass = ldap_get_values(m_hLdap, pEntry, L"objectClass");
        Assert(NULL != ppszObjectClass);

        ppszIsDeleted = ldap_get_values(m_hLdap, pEntry, L"isDeleted");
        Assert((NULL == ppszIsDeleted)
               || (1 == ldap_count_values(ppszIsDeleted)));
        fIsDeleted = (NULL != ppszIsDeleted)
                     && (0 == _wcsicmp(*ppszIsDeleted, L"TRUE"));

        ppszTransportDll = ldap_get_values(m_hLdap, pEntry, L"transportDllName");
        Assert((NULL != ppszTransportDll) || fIsDeleted);
        Assert((NULL == ppszTransportDll)
               || (1 == ldap_count_values(ppszTransportDll)));

        if ((NULL != pszTransportDN)
            && (NULL != ppbvObjectGuid)
            && (NULL != ppszObjectClass)) {

            pObjectGuid = (GUID *) ppbvObjectGuid[0]->bv_val;
            pTransport = Get(pObjectGuid);

            fAddNewTransport = (NULL == pTransport) && !fIsDeleted;

            if (NULL != pTransport) {
                // Update pre-existing transport.
                if (!fIsDeleted) {
                    if ((NULL != ppszTransportDll)
                        && (0 != _wcsicmp(pTransport->GetDLL(),
                                          ppszTransportDll[0]))) {
                        // The DLL for this transport has changed.
                        // Unload current DLL and load new one.
                        DPRINT1(0, "Switching to new DLL for transport %ls.\n",
                                pTransport->GetDN());
                        Delete(pTransport);
                        fAddNewTransport = TRUE;
                    } else {
                        err = pTransport->Refresh(ISM_REFRESH_REASON_TRANSPORT,
                                                  pszTransportDN);
                        if (NO_ERROR == err) {
                            DPRINT1(0, "Refreshed transport %ls.\n", pszTransportDN);
                        }
                        else {
                            DPRINT2(0, "Failed to refresh transport %ls, error %d.\n",
                                    pszTransportDN, err);
                        }
                    }
                }
                else {
                    // Transport has been deleted.
                    DPRINT1(0, "Deleting transport %ls.\n", pTransport->GetDN());
                    Delete(pTransport);
                }
            }

            if (fAddNewTransport) {
                if (NULL != ppszTransportDll) {
                    gService.SetStatus(); // Give SCM a status report

                    // Add new transport.
                    err = Add(pszTransportDN, pObjectGuid, ppszTransportDll[0]);
                    if (NO_ERROR == err) {
                        DPRINT1(0, "Added transport %ls.\n", pszTransportDN);
                    }
                    else {
                        DPRINT2(0, "Failed to add transport %ls, error %d.\n",
                                pszTransportDN, err);
                    }

                    gService.SetStatus(); // Give SCM a status report
                } else {
                    DPRINT1(0, "Failed to read critical attribute transportDllName for transport %ls; ignoring.\n",
                            pszTransportDN ? pszTransportDN : L"");
                    LogEvent(
                        DS_EVENT_CAT_ISM,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_ISM_CRITICAL_TRANSPORT_ATTRIBUTE_FAILURE,  
                        szInsertWC( pszTransportDN ),
                        NULL, NULL );
                }
            }
        }
        else {
            DPRINT1(0, "Failed to read critical attributes for transport %ls; ignoring.\n",
                    pszTransportDN ? pszTransportDN : L"");
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_CRITICAL_TRANSPORT_ATTRIBUTE_FAILURE,  
                szInsertWC( pszTransportDN ),
                NULL, NULL );
        }

        if (NULL != pszTransportDN) {
            ldap_memfree(pszTransportDN);
        }

        if (NULL != ppszTransportDll) {
            ldap_value_free(ppszTransportDll);
        }

        if (NULL != ppbvObjectGuid) {
            ldap_value_free_len(ppbvObjectGuid);
        }

        if (NULL != ppszObjectClass) {
            ldap_value_free(ppszObjectClass);
        }

        if (NULL != ppszIsDeleted) {
            ldap_value_free(ppszIsDeleted);
        }
    }

    return ldStatus;
}


VOID
ISM_TRANSPORT_LIST::Delete(
    IN  ISM_TRANSPORT * pTransport
    )
/*++

Routine Description:

    Remove the given ISM_TRANSPORT from the list.

Arguments:

    pTransport (IN) - Transport to remove.

Return Values:

    None.

--*/
{
    DWORD i;
    BOOL  fFound = FALSE;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_Lock));

    for (i = 0; i < m_cNumTransports; i++) {
        if (pTransport == m_ppTransport[i]) {
            // Remove pTransport from the list.
            memmove(&m_ppTransport[i],
                    &m_ppTransport[i+1],
                    (m_cNumTransports - (i + 1)) * sizeof(*m_ppTransport));
            m_cNumTransports--;
            fFound = TRUE;
            break;
        }
    }

    Assert(fFound);

    delete pTransport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\ldapobj.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ldapobj.c

Abstract:

    This module implements an object specific interface to the directory.

    The current directory is the NT 5 DS, as accessed through LDAP.

    The implementation of the directory is abstracted away, so that any directory may be used.
    For example, the registry was used during testing.

    THIS IS THE LDAP IMPLEMENTATION.

Author:

    Will Lees (wlees) 07-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <winsock2.h>
#define LDAP_UNICODE 1
#include <winldap.h>
#include <ntldap.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include <dsconfig.h>                   // GetConfigParam

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_LDAPOBJ

#include <debug.h>
#define DEBSUB "LDAPOBJ:"

#include <ismapi.h>

#include <common.h>

// The number of items returned from a paged search
#if DBG
// Make smaller on checked build to stress page handling
#define ISM_LDAP_PAGE_SIZE 10
#else
#define ISM_LDAP_PAGE_SIZE 1000
#endif

// This is the internal state for a connection
typedef struct _CONNECTION_INSTANCE {
    DWORD Size;
    // ldap stuff goes here
    LDAP *LdapConnection;
    LPWSTR ConfigNC;
    // We don't cache the server dn in here because it might be renamed
    WCHAR szServerGuidDN[32+sizeof("<GUID=>")];
} CONNECTION_INSTANCE, *PCONNECTION_INSTANCE;

// This is the internal state kept across calls to the iteration routines
typedef struct _ITERATION_CONTEXT {
    LDAP *hLdap;
    LDAPSearch *pSearch;
    LDAPMessage *Results;
    LDAPMessage *Message;
} ITERATION_CONTEXT, *PITERATION_CONTEXT;

/* External */

/* Static */

static LPWSTR ExtendedErrorSpecialError = L"Failed to get server error.";

/* Forward */ /* Generated by Emacs 21.1 (patch 9) "Canyonlands" XEmacs Lucid on Wed Jan 03 10:34:07 2001 */

void
logExtendedServerError(
    IN LDAP *pLdap
    );

DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    );

DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    );

DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    );

DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    );

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    );

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    );

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    );

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    );

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    );

static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    );

void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    );

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    );

DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    );

void
DirFreeMultiszString(
    LPWSTR MultiszString
    );

void
DirFreeSchedule(
    PBYTE pSchedule
    );

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    );

DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirWriteServerSmtpAttributesUnused(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirRegisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT HANDLE *              phServerChanges
    );

DWORD
DirWaitForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirUnregisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    );

DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    );

DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

unsigned __stdcall
notifyThread(
    PVOID Argument
    );

/* End Forward */


void
logExtendedServerError(
    IN LDAP *pLdap
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *pmsg = NULL;
    DWORD err = 0;

    ldap_get_optionW( pLdap, LDAP_OPT_SERVER_ERROR, &pmsg );
    ldap_get_optionW(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &err);

    if ( pmsg || err || pLdap->ld_errno ) {
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_EXTENDED_SERVER_ERROR,
            szInsertWC( pmsg ? pmsg : L"" ),
            szInsertWin32Msg( err ),
            szInsertWin32ErrCode( err ),
            szInsertLdapErrMsg(pLdap->ld_errno),
            szInsertLdapErrCode(pLdap->ld_errno),
            NULL, NULL, NULL
            );
    }

    DPRINT2( 0, "Ism extended LDAP error info:\nServer Error: %ws\nExtended Error: %d\n",
             pmsg, err );

    if ( pmsg != NULL ) {
        ldap_memfreeW(pmsg);
    }
}


DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    )

/*++

Routine Description:

Open a connection handle to the directory service.  This package chooses the implementation and
which server to open.

This is needed because some directory services need a long-lived handle on which each call
is made.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = NULL;
    DWORD status, ldapStatus;
    LDAP *ldapConnection = NULL;
    LPWSTR configNC = NULL;
    WCHAR pszTargetServer[MAX_PATH];
    ULONG                   ulOptions;

    connection = NEW_TYPE_ZERO( CONNECTION_INSTANCE );
    if (connection == NULL) {
        // no resources to free yet
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    connection->Size = sizeof( CONNECTION_INSTANCE );

    // Allow means to configure ISM to use remote directory instance
#if DBG
    if (GetConfigParamW( MAKE_WIDE( ISM_ALTERNATE_DIRECTORY_SERVER ),
                         pszTargetServer, MAX_PATH )) {
        // Parameter not found or other error
        wcscpy( pszTargetServer, L"localhost" );
    } else {
        DPRINT1( 0, "ISM using alternate directory server %ws\n", pszTargetServer );
    }
#else
    wcscpy( pszTargetServer, L"localhost" );
#endif

    // Open ourselves as the ldap server.
    // Assumption: this code is always running on a DC

    ldapConnection = ldap_initW( pszTargetServer, LDAP_PORT );
    if (ldapConnection == NULL) {
        status = GetLastError();
        DPRINT1(0, "ldap_initW failed, status = %d\n", status);
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW(ldapConnection, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    DPRINT1( 2, "Connected to server %s.\n", ldapConnection->ld_host );

    // Force LDAP V3.  Without this, the LDAP client dumbs down to V2 and
    // rejects any searches that use controls.
    ldapConnection->ld_version = LDAP_VERSION3;

    ldapStatus = ldap_bind_s( ldapConnection, NULL, NULL, LDAP_AUTH_NTLM );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_bind_s failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        logExtendedServerError( ldapConnection );
        goto cleanup;
    }

    connection->LdapConnection = ldapConnection;

    status = cacheOperationalAtts(connection);
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    *ConnectionHandle = (PVOID) connection;

    return ERROR_SUCCESS;

cleanup:  // only called on failure

    if (connection->ConfigNC != NULL) {
        FREE_TYPE(connection->ConfigNC);
    }

    if (connection != NULL) {
        FREE_TYPE( connection );
    }

    if (ldapConnection != NULL) {
        ldap_unbind( ldapConnection );
    }

    return status;

} /* DirOpenConnection */


DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    )

/*++

Routine Description:

Close a connection handle.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldap_unbind( connection->LdapConnection );

    FREE_TYPE( connection->ConfigNC );

    FREE_TYPE( connection );

    return ERROR_SUCCESS;
} /* DirCloseConnection */


DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    )

/*++

Routine Description:

    Helper routine to cache important operational atts from the DS
    into the connection handle.

Arguments:

    pConnection (IN/OUT) - Connection to poulate with cached info.

Return Value:

    Win32 error code

--*/

{
#define ATT1 L"configurationNamingContext"
#define ATT2 L"serverName"
#define ATT3 L"objectGuid"
    DWORD status, ldapStatus, length;
    PWCHAR rootAttributeList[] = { ATT1, ATT2, NULL };
    PWCHAR serverAttributeList[] = {ATT3, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *serverResults = NULL;
    LDAPMessage *rootMessage;
    LDAPMessage *serverMessage;
    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;
    WCHAR *pch;
    DWORD ib;

    // Get the config NC attribute
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"Root DN" ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    length = wcslen( *valueList ) + 1; // length in wchars inc term
    pConnection->ConfigNC = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pConnection->ConfigNC) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy(pConnection->ConfigNC, *valueList);

    // Get the DN of the server object.
    ldap_value_free(valueList);
    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage,
                                ATT2 );
    if (NULL == valueList) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // TODO: Search for this attribute with the others in the previous search

    // Read the server object.
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               *valueList,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               &serverAttributeList[0],
                               FALSE,
                               &serverResults);
    if (LDAP_SUCCESS != ldapStatus) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2(0, "Ldap_search_s failed, server object, ldap error = %d, win32 error = %d\n",
                ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( *valueList ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (NULL == serverResults) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }
    serverMessage = ldap_first_entry(pConnection->LdapConnection, serverResults);
    if (NULL == serverMessage) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Extract the object GUID and cache the GUID form of the DN.
    // Referencing the server object via the GUID DN later makes us immune from
    // renames of our site and renames/moves of our server object.
    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT3 );
    if (NULL == ppbv) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }
    Assert(1 == ldap_count_values_len(ppbv));
    Assert(sizeof(GUID) == (*ppbv)->bv_len);

    wcscpy(pConnection->szServerGuidDN, L"<GUID=");
    pch = pConnection->szServerGuidDN + sizeof(L"<GUID=")/sizeof(WCHAR) - 1;
    for (ib = 0; ib < sizeof(GUID); ib++) {
        swprintf(pch, L"%02x", (UCHAR) (*ppbv)->bv_val[ib]);
        pch += 2;
    }
    *(pch++) = L'>';
    *(pch++) = L'\0';
    Assert(pch - &pConnection->szServerGuidDN[0]
           == sizeof(pConnection->szServerGuidDN)/sizeof(WCHAR));

    status = ERROR_SUCCESS;

cleanup:  // called in all cases

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree( rootResults );
    }

    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }

    return status;
#undef ATT1
#undef ATT2
#undef ATT3
} /* cacheOperationalAtts */


DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

This routine rereads the transport object from the directory service.

Object must exist.

Arguments:

    ConnectionHandle - directory handle
    pTransport - dn of transport object

Return Value:

    DWORD -

--*/

{
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
    PWCHAR attributeList[] = { ATT_RI, ATT_OP, NULL };
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PCHAR *numberList;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 pTransport->Name, ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // We only update the value if the attribute is present.  By presetting a
    // value in field to be updated, the caller may determine whether the
    // attribute was actually present or not.

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        pTransport->ReplInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport default replication interval = %d\n", pTransport->ReplInterval );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        pTransport->Options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport options = 0x%x\n", pTransport->Options );
    }

    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadTransport */


DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )

/*++

Routine Description:

This routine returns the bridgehead servers for a given site

Arguments:

    SiteDN - string name of site. It is supposed to be the full DN of the site.
    It must exist.
    pNumberServers - pointer to dword to receive number of servers
    ppServerList - pointer to a pointer, that will receive a pointer to a block of
           strings (which are pointers to char)
           Server list must be freed by the caller.

Return Value:

    DWORD -

--*/

{
#define ATT1 L"bridgeheadServerListBL"
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    DWORD status, ldapStatus, index, length;
    DWORD number = 0;
    LPWSTR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LPWSTR *pServerList = NULL;
    LPWSTR *valueList = NULL, *pString;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct the element path
    // CODE.IMP - default to current stie
    if ( (SiteDN == NULL) || (*SiteDN == L'\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Bug 151694. Verify that the site dn is valid
    status = verifyExistence( ConnectionHandle, SiteDN );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_NO_SUCH_SITE;
        }
        return status;
    }

    // Get the bridgehead servers for this transport.
    // Note, these are the servers for all sites
    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results

    // Attribute not found, a success case
    if (ldapStatus == LDAP_NO_SUCH_ATTRIBUTE)
    {
       *pNumberServers = 0;
       *ppServerList = NULL;
       status = ERROR_SUCCESS;
       goto cleanup;
    }

    if (ldapStatus != LDAP_SUCCESS) {
        // better error, no such transport
        // error LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList == NULL) {
        // Attribute is optional
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Count the number of servers in this site
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            number++;
        }
        pString++;
    }

    // If no matching sites, exit now
    if (number == 0) {
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Allocate the block of pointers
    // Zero'd for ease of cleanup
    pServerList = NEW_TYPE_ARRAY_ZERO( number, LPWSTR );
    if (pServerList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;

    }

    // Populate the return block
    index = 0;
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            length = wcslen( *pString ) + 1; // len in wchars plus term
            pServerList[index] = NEW_TYPE_ARRAY( length, WCHAR );
            if (pServerList[index] == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            wcscpy( pServerList[index], *pString );
            index++;
        }
        pString++;
    }

    // Return out parameters

    *pNumberServers = number;
    *ppServerList = pServerList;

    pServerList = NULL; // given away, don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if (pServerList != NULL) {
        for( index = 0; index < number; index++ ) {
            if (pServerList[index] != NULL) {
                FREE_TYPE( pServerList[index] );
            }
        }
        FREE_TYPE( pServerList );
    }

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
#undef ATT1
} /* IpGetSiteBridgeheadList */


DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Return the list of all sites.
    Some of these sites may be inaccessible for our purposes if they are not mentioned in the
    site link structures.

    This site list is a counted array of pointers to strings, NOT a multi-sz format as is
    used in other places.

    The preferred method to interate a container is to do a search with only
    invalid arguments, and then get the dn out of each entry

Arguments:

    ConnectionHandle - Current open directory
    pNumberSites - pointer to dword to receive the number of sites
    ppSiteList - pointer which receives pointer to array of strings.
                 Storage must be freed by caller.

Return Value:

    DWORD -

--*/

{
#define ATT1        L"invalid"
    DWORD status, ldapStatus, length, number, i, total;
    DWORD index = 0;
    LPWSTR *pSiteList = NULL;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    WCHAR path[MAX_REG_PATH];
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LDAPSearch *pSearch = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    wcscpy( path, L"CN=Sites," );
    wcscat( path, connection->ConfigNC );

    //
    // Initialize paged search
    //
    pSearch = ldap_search_init_page(
        connection->LdapConnection,
        path,                   // base dn
        LDAP_SCOPE_ONELEVEL,    // immediate children
        L"(objectClass=site)",  // filter is all objects
        &attributeList[0],      // list of attributes
        FALSE,                  // attrs only
        NULL,                   // ServerControls
        NULL,                   // ClientControls
        0,                      // PageTimeLimit
        0,                      // TotalSizeLimit
        NULL                   // SortKeys
        );
    if (pSearch == NULL) {
        ldapStatus = LdapGetLastError();
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 path, ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
            szInsertWC( path ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    // Search for all site objects below the Sites container
    // In order to free loop resources, all exits from loop must be through
    // loop cleanup at bottom

    status = ERROR_SUCCESS;
    do {
        //
        // Get the next page of results
        //
        ldapStatus = ldap_get_next_page_s(
            connection->LdapConnection,
            pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &results );
        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         path, ldapStatus, status );
                LogEvent8(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( path ),
                    szInsertWin32Msg( status ),
                    szInsertWin32ErrCode( status ),
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL
                    );
                logExtendedServerError( connection->LdapConnection );
            }
            goto loop_cleanup;
        }
        if (results == NULL) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Count number of entries found
        number = ldap_count_entries( connection->LdapConnection, results );
        // There should always be atleast one site
        if (number == 0) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Allocate return array
        if (pSiteList) {
            // Expand existing array to encompass new entries
            LPWSTR *pTempSiteList =
                REALLOC_TYPE_ARRAY( pSiteList, (index + number), PWSTR );
            if (pTempSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
            pSiteList = pTempSiteList;
        } else {
            // New array
            pSiteList = NEW_TYPE_ARRAY( number, PWSTR );
            if (pSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
        }

        // Load the array with the sites
        message = ldap_first_entry( connection->LdapConnection, results );
        while (message != NULL ) {
            PWCHAR dn;
            dn = ldap_get_dn( connection->LdapConnection, message );
            if (dn == NULL) {
                // error, inconsistent results found
                DPRINT( 0, "missing dn in ldap message\n" );
                status = ERROR_DS_MISSING_EXPECTED_ATT;
                goto loop_cleanup;
            }

            length = wcslen( dn ) + 1;    // length in wchars inc term

            pSiteList[index] = (PWSTR) NEW_TYPE_ARRAY( length, WCHAR );   // in wchars
            if (pSiteList[index] == NULL) {
                ldap_memfree( dn );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }

            wcscpy(pSiteList[index], dn);
            ldap_memfree( dn );


            index++;
            message = ldap_next_entry( connection->LdapConnection, message );
        }

    loop_cleanup:
        if (results != NULL) {
            ldap_msgfree( results );
            results = NULL;
        }

    } while (status == ERROR_SUCCESS);
    // Make sure loop exited for right reason
    // This is the goofy ldap translation of NO_RESULTS_RETURNED
    if (status != ERROR_MORE_DATA) {
        goto cleanup;
    }
    // There should always be atleast one site
    if (index == 0) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto loop_cleanup;
    }

    // Return the OUT parameters

    *pNumberSites = index;
    *ppSiteList = pSiteList;

    // Don't clean up the list now that we've given it away
    pSiteList = NULL;

    status = ERROR_SUCCESS;

cleanup:
    if (pSiteList != NULL) {
        for( i = 0; i < index; i++ ) {
            if (pSiteList[i] != NULL) {
                FREE_TYPE( pSiteList[i] );
            }
        }
        FREE_TYPE( pSiteList );
    }

   // Clean up paged search
   if (pSearch) {
       ldapStatus = ldap_search_abandon_page(
           connection->LdapConnection,
           pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT3( 0, "Ldap_search_abandon_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                    path, ldapStatus, status1 );
       }
   }

   return status;
#undef ATT1
} /* DirGetSiteList */


void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LPWSTR *pNewSiteList = NULL;
    LPWSTR pszNewSite;
    DWORD i, length;

    Assert( ppSiteList );

    *ppSiteList = NULL;

    pNewSiteList = NEW_TYPE_ARRAY_ZERO( NumberSites, LPWSTR );
    if (pNewSiteList == NULL) {
        return;
    }

    for( i = 0; i < NumberSites; i++ ) {
        length = wcslen( pSiteList[i] ) + 1;
        pszNewSite = NEW_TYPE_ARRAY( length, WCHAR );
        if (pszNewSite == NULL) {
            goto cleanup;
        }
        wcscpy( pszNewSite, pSiteList[i] );
        pNewSiteList[i] = pszNewSite;
    }

    *ppSiteList = pNewSiteList;

    pNewSiteList = NULL;  // don't clean up

cleanup:
    if (pNewSiteList) {
        DirFreeSiteList( i, pNewSiteList );
    }
}


void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    )

/*++

Routine Description:

Free the site list returned from the DirGetSiteList function.

Arguments:

    NumberSites -
    pSiteList -

Return Value:

    None

--*/

{
    DWORD i;

    // Get rid of site list
    for( i = 0; i < NumberSites; i++ ) {
        FREE_TYPE( pSiteList[i] );
    }
    FREE_TYPE( pSiteList );
} /* DirFreeSiteList */


DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle - pointer to a PVOID
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLink)",
                          pIterateContextHandle,
                          SiteLinkName );

} /* DirIterateSiteLinks */


DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link bridge object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle -
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLinkBridge)",
                          pIterateContextHandle,
                          SiteLinkBridgeName );

} /* DirIterateSiteLinkBridges */


static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    )

/*++

Routine Description:

Helper routine to iterate through the names of a set of child objects given a dn of
the parent.

The preferred LDAP mechanism to get the dn's of child objects is to do a
search with only invalid arguments, and retrieve the dn's of the returned
entries.  LDP also does this.  This should get around problems were we don't
have permission to read the child object's attributes, but still want to
enumerate the directory.

Arguments:

    ConnectionHandle - Handle to the directory service
    BaseDN - Parent of children to be returned
    LdapFilter - select class of objects to be returned, can use
    L"(objectClass = *)" for all.
    pIterateContextHandle - Context for the iteration. Pointer to DWORD.  DWORD is null
       to start
    Name - Storage for returned name.  Must be REG_MAX_COMPONENT

Return Value:

    DWORD -

--*/

{
#define ATT1 L"invalid"
    PWCHAR attributeList[] = { ATT1, NULL };
    DWORD status, ldapStatus, total;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PITERATION_CONTEXT context;
    PWCHAR dn;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }
    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (*pIterateContextHandle == NULL) {

        // *****************************
        // Set up for first time through
        // *****************************

        // Allocate a new context
        context = NEW_TYPE_ZERO( ITERATION_CONTEXT );
        if (context == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        context->hLdap = connection->LdapConnection;

        //
        // Initialize paged search
        //

        context->pSearch = ldap_search_init_page(
            connection->LdapConnection,
            BaseDN,                 // base dn
            LDAP_SCOPE_ONELEVEL,    // immediate children
            LdapFilter,             // filter is all objects
            &attributeList[0],      // list of attributes
            FALSE,                  // attrs only
            NULL,                   // ServerControls
            NULL,                   // ClientControls
            0,                      // PageTimeLimit
            0,                      // TotalSizeLimit
            NULL                   // SortKeys
            );
        if (context->pSearch == NULL) {
            ldapStatus = LdapGetLastError();
            status = LdapMapErrorToWin32( ldapStatus );
            DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                     BaseDN, ldapStatus, status );
            LogEvent8(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                szInsertWC( BaseDN ),
                szInsertWin32Msg( status ),
                szInsertWin32ErrCode( status ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
                );
            logExtendedServerError( connection->LdapConnection );
            goto cleanup;
        }
        *pIterateContextHandle = (PVOID) context;
    } else {

        // On second and later iterations, ConnectionHandle, BaseDN, and
        // LdapFilter not guaranteed to be present.

        context = (PITERATION_CONTEXT) *pIterateContextHandle;
    }

    while (context->Message == NULL) {

        // *****************************
        // Set up for first entry on a new page
        // *****************************

        // Release any previous results
        if (context->Results) {
            ldap_msgfree( context->Results );
        }
        context->Results = NULL;

        // Read the next page
        ldapStatus = ldap_get_next_page_s(
            context->hLdap,
            context->pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &(context->Results) );

        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         BaseDN, ldapStatus, status );
                LogEvent8(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( BaseDN ? BaseDN : L"(iteration)" ),
                    szInsertWin32Msg( status ),
                    szInsertWin32ErrCode( status ),
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL
                    );
                logExtendedServerError( context->hLdap );
            }
            if (ldapStatus == LDAP_NO_RESULTS_RETURNED) {
                // Return a better translation than ldap does
                status = ERROR_NO_MORE_ITEMS;
            }
            goto cleanup;
        }
        if (context->Results == NULL) {
            continue;  // 0 entry pages are permissable
        }

        context->Message = ldap_first_entry( context->hLdap, context->Results );
        if (context->Message == NULL) {
            continue;  // 0 entry pages are permissable
        }
    }

    // *****************************
    // Return the next dn
    // *****************************

    Assert( context->Results );
    Assert( context->Message );

    dn = ldap_get_dn( context->hLdap, context->Message );
    if (dn == NULL) {
        // error, inconsistent results found
        DPRINT( 0, "missing dn in ldap message\n" );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // Name must be allocated by the caller to be MAX_REG_COMPONENT length
    wcsncpy( Name, dn, MAX_REG_COMPONENT );
    Name[MAX_REG_COMPONENT - 1] = L'\0';

    ldap_memfree( dn );

    // Advance context to next message
    context->Message = ldap_next_entry( context->hLdap, context->Message );

    return ERROR_SUCCESS;

cleanup:

    DirTerminateIteration( pIterateContextHandle );

    return status;
#undef ATT1
} /* iterateContainer */


void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    )

/*++

Routine Description:

Clean up the context of an DirIterate* call.

Arguments:

    pIterateContextHandle -

Return Value:

    None

--*/

{
    PITERATION_CONTEXT context =
        (PITERATION_CONTEXT) *pIterateContextHandle;

    Assert( context ); // don't call us twice
    if (context == NULL) {
        return;
    }

    // Release the search
    if (context->pSearch) {
        DWORD ldapStatus = ldap_search_abandon_page(
            context->hLdap,
            context->pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT2( 0, "Ldap_search_abandon_page failed, ldap error = %d, win32 error = %d\n",
                    ldapStatus, status1 );
       }
    }

    // Release the results
    if (context->Results) {
        ldap_msgfree( context->Results );
    }
    context->Results = NULL;
    context->Message = NULL;
    context->hLdap = NULL;

    // Destory context
    FREE_TYPE( context );
    *pIterateContextHandle = NULL;
} /* DirTerminateIteration */


DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    )

/*++

Routine Description:

   Given the name of a site link, return its fields.

   The site list and the schedule are allocated by this routine.  The user must deallocate.

   The expectation that the site link object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkName -
    pSiteList - pointer to pointer to string. Receives multisz string.  Caller must free.  May be NULL
    pCost - pointer to DWORD. Filled with cost.
    pSchedule - pointer to schedule. Filled with schedule.  Caler must free.

Return Value:

    DWORD -

--*/

{
#define ATT_SL L"siteList"
#define ATT_COST L"cost"
#define ATT_COST_A "cost"
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
#define ATT_SCHED L"schedule"

// Note, schedule must be last in the list
#define ATT_SCHED_POS 4  // index from 0 of sched attribute
    PWCHAR attributeList[] =
    { ATT_SL, ATT_COST, ATT_RI, ATT_OP, ATT_SCHED, NULL };

    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    PCHAR *numberList;
    struct berval **ppThing;
    LPWSTR siteList = NULL;
    PBYTE pSchedule = NULL;
    DWORD cost = 0, replInterval = 0, options = 0;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Don't read schedule attribute if it wasn't requested.

    Assert(0 == _wcsicmp(ATT_SCHED, attributeList[ATT_SCHED_POS]));
    Assert(NULL == attributeList[ATT_SCHED_POS+1]);
    if (NULL == ppSchedule) {
        attributeList[ATT_SCHED_POS] = NULL;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkName, ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkName ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteList attribute
    // CODE.IMPROVEMENT: It would be nice to return this native form, array of ptrs,
    // instead of converting to multisz.

    // Attribute may be empty if all references deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT_SL );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Read optional cost attribute
    // Integers are represented as an array of ascii digits, not unicode

    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_COST_A);
    if (numberList != NULL) {
        cost = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        replInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read schedule attribute
    ppThing = ldap_get_values_len( connection->LdapConnection, message,
                                   ATT_SCHED );
    if ( (ppThing != NULL) && ( (*ppThing)->bv_len != 0 ) ) {
        // Validate schedule attribute.
        SCHEDULE *psched = (SCHEDULE *) (*ppThing)->bv_val;

        if (((*ppThing)->bv_len < offsetof(SCHEDULE, Size) + sizeof(psched->Size))
            || (psched->Size != sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES)
            || (psched->NumberOfSchedules != 1)
            || (psched->Schedules[0].Type != SCHEDULE_INTERVAL)
            || (psched->Schedules[0].Offset != sizeof(SCHEDULE))) {
            // The schedule blob is not a correctly formed SCHEDULE structure.
            DPRINT1(0, "The schedule attribute of siteLink object %ls is invalid.\n",
                    SiteLinkName);
            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_ISM_SITELINK_INVALID_SCHEDULE_FORMAT,
                     szInsertWC(SiteLinkName),
                     NULL, NULL);

            // Pretend as if we didn't find a schedule attribute....
        }
        else {
            // Is the schedule set to "never"?
            BYTE *  pEntries = (BYTE *) psched + psched->Schedules[0].Offset;
            DWORD   iEntry;
            BOOL    fIsNever = TRUE;

            for (iEntry = 0; iEntry < SCHEDULE_DATA_ENTRIES; iEntry++) {
                if (pEntries[iEntry] & 0xf) {
                    fIsNever = FALSE;
                    break;
                }
            }

            if (fIsNever) {
                // The schedule is "never".
                DPRINT1(0, "The schedule attribute of siteLink object %ls is \"never\".\n",
                        SiteLinkName);
                LogEvent(DS_EVENT_CAT_ISM,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ISM_SITELINK_SCHEDULE_NEVER,
                         szInsertWC(SiteLinkName),
                         NULL, NULL);
                // Pretend as if we didn't find a schedule attribute....
            }
            else {
                // Schedule is acceptable -- use it.
                pSchedule = NEW_TYPE_ARRAY( (*ppThing)->bv_len, CHAR );
                if (pSchedule == NULL) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    ldap_value_free_len( ppThing );
                    goto cleanup;
                }
                CopyMemory( pSchedule, (*ppThing)->bv_val, (*ppThing)->bv_len );
            }
        }

        ldap_value_free_len( ppThing );
    }

    // Return data to user
    if (pSiteList != NULL) {
        *pSiteList = siteList;
        siteList = NULL;  // given to user
    }

    if (pLinkValue != NULL) {
        pLinkValue->ulCost = cost;
        pLinkValue->ulReplicationInterval = replInterval;
        pLinkValue->ulOptions = options;
    }

    if (ppSchedule) {
        *ppSchedule = pSchedule;
        pSchedule = NULL; // don't clean up
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteList) {
        FREE_TYPE( siteList );
    }

    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_SL
#undef ATT_COST
#undef ATT_COST_A
#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadSiteLink */


DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    )

/*++

Routine Description:

   Return the fields of a site link bridge object

   The expectation that the bridge object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkBridgeName -
    pSiteLinkList - pointer to pointer to multisz string allocated by this routine,
        user must free

Return Value:

    DWORD -

--*/

{
#define ATT1 L"siteLinkList"
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    LPWSTR siteLinkList = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Return the attributes for this one site link bridge object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkBridgeName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        // TODO:LOG AN EVENT HERE. OBJECT WAS FOUND VIA ENUM BUT CAN'T BE READ!
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkBridgeName, ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkBridgeName ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteLinkList attribute

    // Attribute may not exist if all referents have been deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteLinkList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Return data to user
    if (pSiteLinkList != NULL) {
        *pSiteLinkList = siteLinkList;
        siteLinkList = NULL;  // given to user
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteLinkList) {
        FREE_TYPE( siteLinkList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT1
} /* DirReadSiteLinkBridge */


void
DirFreeMultiszString(
    LPWSTR MultiszString
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (MultiszString) {
        FREE_TYPE( MultiszString );
    }
}


void
DirFreeSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }
}

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )
{
    DWORD   winError = ERROR_SUCCESS;
    DWORD   cch;

    Assert(NULL == pTransport->Smtp.pszSmtpAddress);

    // Cache SMTP address (e.g., mailbox@server-4.ntdev.microsoft.com).
    cch = 1 + wcslen(pszMailAddress);
    pTransport->Smtp.pszSmtpAddress = NEW_TYPE_ARRAY(cch, WCHAR);
    if (NULL == pTransport->Smtp.pszSmtpAddress) {
        winError = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        wcscpy(pTransport->Smtp.pszSmtpAddress, pszMailAddress);
    }

    if (ERROR_SUCCESS != winError) {
        // Failed; free any memory we allocated.
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return winError;
}


DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    )
{
#define ATT1 L"mailAddress"
    CONNECTION_INSTANCE * pConn
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD           winError;
    int             ldStatus;
    LPWSTR          rgpszServerAttrsToRead[] = {ATT1, NULL};
    LDAPMessage *   pResults = NULL;
    LDAPMessage *   pEntry;
    LPWSTR *        ppszMailAddress;

    ldStatus = ldap_search_s(pConn->LdapConnection,
                             pConn->szServerGuidDN,
                             LDAP_SCOPE_BASE,
                             L"(objectClass=*)",
                             rgpszServerAttrsToRead,
                             0,
                             &pResults);
    switch (ldStatus) {
      case LDAP_NO_SUCH_ATTRIBUTE:
        // Our server object has no mailAddress.
        DPRINT(0, "Our server object has no mailAddress attribute.\n");
        // This is not an error; detect by examining SmtpAddress field
        winError = ERROR_SUCCESS;
        break;

      case LDAP_SUCCESS:
        // Successfully read our server object's mailAddress; cache it.
        pEntry = ldap_first_entry(pConn->LdapConnection, pResults);
        Assert(NULL != pEntry);

        ppszMailAddress = ldap_get_values(pConn->LdapConnection, pEntry,
                                          ATT1);
        if (NULL == ppszMailAddress) {
            DPRINT(0, "Our server object has empty mailAddress attribute.\n");
            // This is not an error; detect by examining SmtpAddress field
            winError = ERROR_SUCCESS;
        }
        else {
            Assert(1 == ldap_count_values(ppszMailAddress));

            winError = cacheServerSmtpAttributes(pTransport, *ppszMailAddress);

            ldap_value_free(ppszMailAddress);
            DPRINT1(0, "Our SMTP address is \"%ls\".\n",
                    pTransport->Smtp.pszSmtpAddress);
        }
        break;

      default:
        // Some other error...
        DPRINT1(0, "Failed to ldap_search_s(), error %d.\n", ldStatus);
        winError = LdapMapErrorToWin32(ldStatus);
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pConn->szServerGuidDN ),
            szInsertWin32Msg( winError ),
            szInsertWin32ErrCode( winError ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConn->LdapConnection );
        break;
    }

    // bug 327001, ldap_search* functions can return failure and still allocate
    // the result buffer.
    if (pResults) {
        ldap_msgfree(pResults);
    }

    return winError;
#undef ATT1
}


DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    )

/*++

Routine Description:

Construct the mail address of the server

This routine constructs an address suitable for the SMTP service.
We should only call this when we know that SMTP service is running.
TODO: If Exchange is running, we should do something different.

The name looks like:

_IsmService@guid-based-dns-name

Arguments:

    pTransport -
    ppszMailAddress -

Return Value:

    DWORD -

--*/

{
#define NTDS_SETTINGS L"CN=NTDS Settings,"
#define ENTERPRISE_CONFIGURATION L"CN=Enterprise Configuration,CN=Partitions,"
#define ISM_SMTP_RECIPIENT L"_IsmService"
#define ATT1 L"serverName"
#define ATT2 L"objectGuid"
#define ATT3 L"dnsRoot"
#define ATT4 L"mailAddress"
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus, length;

    PWCHAR rootAttributeList[] = {ATT1, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *rootMessage;

    PWCHAR serverAttributeList[] = {ATT2, NULL};
    LDAPMessage *serverResults = NULL;
    LDAPMessage *serverMessage;

    PWCHAR computerAttributeList[] = {ATT3, NULL};
    LDAPMessage *computerResults = NULL;
    LDAPMessage *computerMessage;

    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;

    PWCHAR pszNTDSA = NULL;
    PWCHAR pszMailAddress = NULL;
    PWCHAR pszEnterprise = NULL;
    PWCHAR pszGUID = NULL;

    // Read the server name on the base dn
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"root dn" ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dn of the server oobject

    length = wcslen( NTDS_SETTINGS) + wcslen( *valueList ) + 1;
    pszNTDSA = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszNTDSA) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszNTDSA, NTDS_SETTINGS );
    wcscat( pszNTDSA, *valueList );

    // *********************************************************************

    // Read the object guid on the NTDS settings object
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszNTDSA,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &serverAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &serverResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszNTDSA ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (serverResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    serverMessage = ldap_first_entry( pConnection->LdapConnection, serverResults );
    if (serverMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT2 );
    if ( (ppbv == NULL) ||
         ( 1 != ldap_count_values_len(ppbv)) ||
         ( sizeof(GUID) != (*ppbv)->bv_len ) ) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *********************************************************************

    // Read the dnsRoot for the enterprise

    length = wcslen( ENTERPRISE_CONFIGURATION ) +
        wcslen( pConnection->ConfigNC ) + 1;
    pszEnterprise = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszEnterprise) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszEnterprise, ENTERPRISE_CONFIGURATION );
    wcscat( pszEnterprise, pConnection->ConfigNC );

    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszEnterprise,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &computerAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &computerResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszEnterprise ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (computerResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    computerMessage = ldap_first_entry( pConnection->LdapConnection, computerResults );
    if (computerMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ldap_value_free(valueList);  // get rid of last value
    valueList = ldap_get_values(pConnection->LdapConnection, computerMessage, ATT3);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dns root of the enterprise

    // *********************************************************************

    status = UuidToStringW( (PVOID) (*ppbv)->bv_val, &pszGUID );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "UuidToString failed, error %d\n", status );
        goto cleanup;
    }

    //
    // Form new mail address
    //
    length = wcslen( ISM_SMTP_RECIPIENT ) + 1 +
        wcslen( pszGUID ) + 8 +
        wcslen( *valueList ) + 1; // length in wchars inc term
    pszMailAddress = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszMailAddress) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszMailAddress, ISM_SMTP_RECIPIENT );
    wcscat( pszMailAddress, L"@" );
    wcscat( pszMailAddress, pszGUID );
    wcscat( pszMailAddress, L"._msdcs." );
    wcscat( pszMailAddress, *valueList);

    // *********************************************************************

    // Return mail address

    *ppszMailAddress = pszMailAddress;

    pszMailAddress = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    if (pszGUID) {
        RpcStringFreeW( &pszGUID );
    }
    if (pszEnterprise) {
        FREE_TYPE( pszEnterprise );
    }
    if (pszNTDSA) {
        FREE_TYPE( pszNTDSA );
    }
    if (pszMailAddress) {
        FREE_TYPE( pszMailAddress );
    }

    if (valueList != NULL) {
        ldap_value_free(valueList);
    }
    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree(rootResults);
    }
    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }
    if (NULL != computerResults) {
        ldap_msgfree(computerResults);
    }

    return status;

} /* DirGetServerSmtpAttributes */


DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )

/*++

Routine Description:

This routine auto configures the mail address attribute.

It is assumed the mail address is empty at this point.

Note, we should only put a mail address on a server object if we are sure
that the server can receive mail.  The KCC uses the presense of the mailAddress
of an indicator of which system it should choose as form a connection to.

Arguments:

    pTransport - Transport object
    pszMailAddress - Mail address to be written. A null means to remove it.

Return Value:

    DWORD -

--*/

{
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus;
    LDAPModW *ppModifyList[2];
    LDAPModW modMailAddress;
    PWCHAR ppszValueList[2];

    // Get rid of any old cached address
    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    //
    // Write it to server object
    //

    ppszValueList[0] = pszMailAddress;
    ppszValueList[1] = NULL;
    modMailAddress.mod_op = LDAP_MOD_REPLACE;
    modMailAddress.mod_type = ATT4;
    modMailAddress.mod_vals.modv_strvals = ppszValueList;
    ppModifyList[0] = &modMailAddress;
    ppModifyList[1] = NULL;

    ldapStatus = ldap_modify_s( pConnection->LdapConnection,
                                pConnection->szServerGuidDN,  // base dn
                                ppModifyList );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_modify_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_MODIFY_FAILED,
            szInsertWC( pConnection->szServerGuidDN ),
            szInsertWin32Msg( status ),
            szInsertUL( status )
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (pszMailAddress) {
        DPRINT1(0, "Wrote new SMTP address \"%ls\".\n", pszMailAddress );

        // Cache the new server mail address
        cacheServerSmtpAttributes( pTransport, pszMailAddress );
    }

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    return status;
} /* DirWriteServerSmtpAttributes */


static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    )

/*++

Routine Description:

Given a null-terminated array of string pointers, convert that into a multisz array.

Arguments:

    pString - pointer to null-terminated array of pointers
    pFlat - pointer to receive allocated buffer.  Buffer contains the multisz rep of the
            input string array, for example member1\0member2\0\member3\0\0

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    PWSTR flat = NULL, *pItem, element;

    // Count number of characters and terminators
    length = 0;
    pItem = pString;

    if (pItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    while (*pItem != NULL) {
        length += wcslen( *pItem ) + 1;
        pItem++;
    }
    length++; // length in whars plus all terminators

    // Allocate the multisz array
    flat = NEW_TYPE_ARRAY( length, WCHAR );
    if (flat == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }

    // Populate it
    pItem = pString;
    element = flat;
    while (*pItem != NULL) {
        length = wcslen( *pItem ) + 1;
        wcscpy( element, *pItem );
        element += length;
        pItem++;
    }
    *element = L'\0';

    *pFlat = flat;
    return ERROR_SUCCESS;
} /* stringArrayToMultiSz */


DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    )

/*++

Routine Description:

Verify that an object exists.
This routine does not try to read any attributes.
If the object does not exist, an error is displayed

This code uses the ldap enumeration technique where we search for invalid
arguments and see how many entries are returned.

Arguments:

    ConnectionHandle -
    ObjectDN -

Return Value:

    DWORD -

--*/

{
    PWCHAR attributeList[] = { L"invalid", NULL };
    DWORD status, length, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               (LPWSTR) ObjectDN,     // base dn
                               LDAP_SCOPE_BASE,     // just this one
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // If the object is not present, this is the path that will be taken
        // LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 ObjectDN, ldapStatus, status );
        LogEvent8(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( ((LPWSTR) ObjectDN) ),
            szInsertWin32Msg( status ),
            szInsertWin32ErrCode( status ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }
    if (results == NULL) {
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // There should be an entry for the base object, but no attributes
    message = ldap_first_entry( connection->LdapConnection, results);
    if (message  == NULL) {
        DPRINT1( 0, "expected object %ws is missing.\n", ObjectDN );
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    //
    // Bug 26647 comment:
    // For some names such as CNF names, the ldap returned dn string
    // format isn't necessarily identical to the core generated dn string.
    // That is:
    //  wcsicmp(ObjectDN, dn) != 0
    // Example (note the "" and \):
    // CN="ExampleSite<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d",CN=Sites,
    // CN=Configuration,...DC=com !=
    // CN=ExampleSite\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites,
    // CN=Configuration,...DC=com
    // Do represent the same object yet the strings are different.
    //
    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
} /* static verifyExistence */


DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Start a notification thread if one is not already running
    This routine is thread-safe. Multiple callers can try to create the
    thread and only one will succeed.
    Assumes pTransport->NotifyThreadHandle is initialized to zero at first.

Arguments:

    pTransport - transport instance

Return Value:

    DWORD - error if thread could not be started

--*/

{
    DWORD status;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LONG threadId;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // Under protection of the lock, atomically test and set the thread
    // handle to determine if a thread should be started or not.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if (pTransport->NotifyThreadHandle) {
            // Thread already running
            status = ERROR_SUCCESS;
            __leave;
        }

        // Note, _beginthreadex returns 0 on error
        pTransport->NotifyThreadHandle = (HANDLE)
            _beginthreadex(
                NULL,
                0,
                notifyThread,
                pTransport, // argument
                0,
                &threadId
                );
        if (0 == pTransport->NotifyThreadHandle) {
            status = _doserrno;
            Assert(status);
            DPRINT1(0, "Failed to create listener thread, error %d.\n", status);
            __leave;
        }

        DPRINT2( 2, "Started notification thread 0x%x on %ws\n",
                 pTransport->NotifyThreadHandle,
                 pTransport->Name );

        status = ERROR_SUCCESS;
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    return status;
} /* DirStartNotifyThread */


BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Test whether notification thread is still alive.

We have having problems with the thread exiting prematurely.  This check is down
periodically by the ISM apis.  If the thread has disappeared, this call will
log the fact.

Arguments:

    pTransport -

Return Value:

    BOOL - True, active or False, exited

--*/

{
    DWORD exitCode = 0;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;
    }

    if (pTransport->NotifyThreadHandle) {

        // Is the thread still alive?
        if ( (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) &&
             (exitCode == STILL_ACTIVE) ) {
            return TRUE;
        }

        // Thread is dead - reap it

        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );

        pTransport->NotifyThreadHandle = 0;
    }

    // Start another thread
    DirStartNotifyThread( pTransport );

    // Indicate thread was not active at time of check
    return FALSE;
} /* DirIsNotifyThreadActive */


BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Cause the notification thread to exit.

Ideally, the execution of this routine would be the only legitimate way
that the thread should exit.  The problem is that because we are in a dll
of a server, we sometimes don't get notificated of shutdown in a timely
manner.  In fact, LDAP may have shutdown its searches before we are called.
In that case, the thread may have exitted on its own legitimately before
we get a chance to do so.

Arguments:

    pTransport - transport state object

Return Value:

    BOOL - whether the thread exited, or not

--*/

{
    DWORD status, ldapStatus, waitStatus, exitCode;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    BOOL fExit = FALSE;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;  // don't know
    }
    // Make sure not already called
    if (pTransport->NotifyThreadHandle == 0) {
        DPRINT(1, "DirEndNotifyThread already called!\n" );
        return TRUE;  // has exitted
    }

    // We don't enforce that the thread is still alive at this point. It may
    // have terminated on its own due to LDAP shutting down

    // Stop asynchronous search
    ldapStatus = ldap_abandon(
        connection->LdapConnection,
        pTransport->NotifyMessageNumber
        );
    if (ldapStatus != LDAP_SUCCESS) {
        // May occur if LDAP is shutting down
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_abandon failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        // Keep going to see if the thread exited or not
    }

    waitStatus = WaitForSingleObject(pTransport->NotifyThreadHandle,5*1000);
    if (waitStatus == WAIT_TIMEOUT) {
        DPRINT1( 0, "Notify thread 0x%x did not exit promptly, timeout.\n",
                 pTransport->NotifyThreadHandle );
        goto cleanup;
    } else if (waitStatus != WAIT_OBJECT_0 ) {
        status = GetLastError();
        DPRINT2(0, "Failure waiting for notify thread to exit, wait status=%d, error=%d\n",
                waitStatus, status);
        goto cleanup;
    }

    exitCode = 0;
    if (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) {
        if (exitCode != ERROR_SUCCESS) {
            DPRINT1( 1, "Notify thread exited with non success code %d\n",
                     exitCode );
        }
    }

    fExit = (exitCode != STILL_ACTIVE);
    // pass status through
cleanup:
    if (!fExit) {
        DPRINT( 0, "Notify thread did not exit\n" );
    }
    if (pTransport->NotifyThreadHandle) {
        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );
    }

    pTransport->NotifyThreadHandle = 0;

    return fExit;
} /* DirEndNotifyThread */


unsigned __stdcall
notifyThread(
    PVOID Argument
    )

/*++

Routine Description:

    Notification thread routine

Arguments:

    Argument - Transport object
    Note that the controller of this thread guarantees not to destroy the
    transport object until this thread has exitted cleanly

Return Value:

    unsigned __stdcall -

--*/

{
    DWORD status, ldapResultType, ldapStatus;
    PTRANSPORT_INSTANCE pTransport = (PTRANSPORT_INSTANCE) Argument;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LDAPMessage *results = NULL;
    BOOL fDone;
    LPWSTR attributeList[] = {
        L"objectGuid", L"objectClass", L"isDeleted",
        NULL};
    LDAPControl ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *serverControls[] = {&ctrlNotify, NULL};
    DWORD i;

    DPRINT1( 1, "Started monitoring %ws\n", pTransport->Name );

    InterlockedIncrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        while (1) {
            // Check for official shutdown first
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break; // exit shutdown loop
            }

            // Start a new search
            ldapStatus = ldap_search_ext(
                connection->LdapConnection,     // ldap connection
                pTransport->Name,               // base dn
                LDAP_SCOPE_ONELEVEL,            // scope
                L"(objectClass=*)",             // filter
                attributeList,                  // attrs[]
                0,                              // attrsonly
                serverControls,                 // server controls
                NULL,                           // client controls
                0,                              // time limit
                0,                              // size limit
                &(pTransport->NotifyMessageNumber) // message number
                );

#ifdef FAULT_INSERTION
            if (rand() % 2 == 0) {
                DPRINT( 0, "Inserting ldap_search_ext error\n" );
                ldapStatus = LDAP_PROTOCOL_ERROR;
            }
#endif

            if (ldapStatus != LDAP_SUCCESS) {
                status = LdapMapErrorToWin32( ldapStatus );
                DPRINT2( 0, "ldap_search_ext failed, ldap error = %d, status = %d\n",
                         ldapStatus, status );
                logExtendedServerError( connection->LdapConnection );
                // This is a hard error with no recovery - exit shutdown loop
                break;
            }

            DPRINT2( 1, "Starting new notify search %d on %ws\n",
                     pTransport->NotifyMessageNumber,  pTransport->Name );

            // Loop reading results until error
            fDone = FALSE;
            while (!fDone) {
                ldapResultType = ldap_result(
                    connection->LdapConnection,      // ldap connection
                    pTransport->NotifyMessageNumber, // message id
                    LDAP_MSG_ONE,                    // all
                    NULL,                            // timeout
                    &results                         // results
                    );

                // Check for official shutdown first
                if (pTransport->fShutdownInProgress) {
                    status = ERROR_SUCCESS;
                    fDone = TRUE;
                    goto loop_cleanup;
                }

#ifdef FAULT_INSERTION
                if (rand() % 5 == 0) {
                    DPRINT( 0, "Inserting ldap_result error\n" );
                    ldapResultType = 0xffffffff;
                    connection->LdapConnection->ld_errno = LDAP_PROTOCOL_ERROR;
                }
#endif

                if (ldapResultType == 0xffffffff) {
                    ldapStatus = connection->LdapConnection->ld_errno;
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT2( 0, "ldap_result failed, ldap error = %d, status = %d\n",
                             ldapStatus, status );
                    fDone = TRUE;
                } else if (ldapResultType == LDAP_RES_SEARCH_ENTRY) {

                    // This is the normal, successful result
                    RouteInvalidateConnectivity( pTransport );

                } else if (ldapResultType == LDAP_RES_SEARCH_RESULT) {

                    // This means the server terminated the search

                    ldapStatus = ldap_result2error(
                        connection->LdapConnection,      // ldap connection
                        results,
                        FALSE );
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT1( 0, "IsmNotifyThread:Ldap result error is 0x%x\n",ldapStatus );
                    fDone = TRUE;
                } else {
                    // Something unexpected
                    DPRINT2( 0, "IsmNotifyThread: Unexpected ldap result type 0x%x for %ws\n",
                             ldapResultType, pTransport->Name );
                    LogUnhandledError( ldapResultType );
                    status = ERROR_INVALID_FUNCTION;
                    fDone = TRUE;
                }

            loop_cleanup:

                if (results) {
                    ldap_msgfree( results );
                    results = NULL;
                }

            } // while (!fDone) result loop

            // Its ambiguous whether this is a real error or a shutdown induced error.
            // See if we were asked to shutdown

            if (!pTransport->fShutdownInProgress) {
                // Give us some time to see if we're shutting down
                DWORD waitStatus;
                waitStatus = WaitForSingleObject( pTransport->hShutdownEvent,
                                                  60 * 1000 );
                if ( (waitStatus != WAIT_OBJECT_0) &&
                     (waitStatus != WAIT_TIMEOUT) ) {
                    DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                             waitStatus, GetLastError() );
                }
            }

            // If shutting down, we're done
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break;
            }

            // LDAP terminated our search prematurely, do error recovery
            // This can occur under some legitimate circumstances, such as when
            // Kerberos tickets expire.
            DPRINT2( 0, "ldap_result failed!, ldapStatus = 0x%x, win32 = %d\n",
                     ldapStatus, status );
            DPRINT2( 0, "h_ldap = 0x%p, message number = %d\n",
                     connection->LdapConnection,
                     pTransport->NotifyMessageNumber );
            // Assert( !"LDAP terminated search prematurely" );

        // Record that there was a problem with the last search
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                      szInsertWC(pTransport->Name),
                      szInsertWin32Msg(status),
                      szInsertWin32ErrCode(status),
                      NULL, NULL, NULL, NULL, NULL );
            // Do this before we alter the connection state
            logExtendedServerError( connection->LdapConnection );

            // Stop asynchronous search - make sure we're cleaned up
            (void) ldap_abandon(
                connection->LdapConnection,
                pTransport->NotifyMessageNumber
                );
            // ignore error - keep going
            pTransport->NotifyMessageNumber = 0;

            // Invalidate the cache on error to force re-read of data
            // in case we miss any notifications
            RouteInvalidateConnectivity( pTransport );

        } // while (1) search loop

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DPRINT1(0, "Caught exception 0x%x in notifyThread!\n", status );
    }

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "Notify thread terminating due to error %d\n", status );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_LINK_MONITOR_FAILURE_RESTART,
                  szInsertWC(pTransport->Name),
                  szInsertWin32Msg(status),
                  szInsertWin32ErrCode(status),
                  NULL, NULL, NULL, NULL, NULL );
    } else {
        DPRINT1( 3, "monitor thread %ws exit\n", pTransport->Name );
    }

    InterlockedDecrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    // Note that if this thread exists prematurely, we don't touch the
    // ThreadHandle. It is still open.  When we reap the thread later we will
    // close the handle at that time.

    // _endthreadex() is called automatically

    return status;
} /* notifyThread */
/* end ldapobj.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\server\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    Command-line/Service Control Manager entry points for ISM (Intersite
    Messaging) service.

DETAILS:

CREATED:

    97/12/03    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <debug.h>
#include <ism.h>
#include <ismapi.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <fileno.h>
#include <mdcodes.h>
#include "ismserv.hxx"
#include <safeboot.h>

#define DEBSUB "MAIN:"
#define FILENO FILENO_ISMSERV_MAIN


ISM_SERVICE gService;


extern "C" {
// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }
}


VOID
WINAPI
ServiceMain(
    IN  DWORD   argc,
    IN  LPTSTR  argv[]
    )
/*++

Routine Description:

    Entry point used by SCM (Service Control Manager) to start the ISM service
    once main() has been invoked.

Arguments:

    argc, argv (IN) - Command-line arguments configured for this service
        (ignored).

Return Values:

    None.

--*/
{
    gService.Run();
}


VOID
WINAPI
ServiceCtrlHandler(
    IN  DWORD   dwControl
    )
/*++

Routine Description:

    Entry point used by SCM (Service Control Manager) to control (i.e., stop,
    query, etc.) the ISM service once it's been started via main() and
    ServiceMain().

Arguments:

    dwControl (IN) - Requested action.  See docs for "Handler" function in
        Win32 SDK.

Return Values:

    None.

--*/
{
    gService.Control(dwControl);
}


BOOL
WINAPI
ConsoleCtrlHandler(
    IN  DWORD   dwCtrlType
    )
/*++

Routine Description:

    Console control handler.  Intercepts Ctrl-C and Ctrl-Break to simulate
    "stop" service control when running in debug mode (i.e., when not running
    under the Service Control Manager).

Arguments:

    dwCtrlType (IN) - Console control type.  See docs for "HandlerRoutine" in
        Win32 SDK.

Return Values:

    TRUE - The function handled the control signal.
    FALSE - Control not handled; the next handler function in the list of
        handlers for this process should be used. 

--*/
{
    switch (dwCtrlType) {
      case CTRL_BREAK_EVENT:
      case CTRL_C_EVENT:
        printf("Stopping %s service.\n", gService.m_pszDisplayName);
        gService.Stop();
        return TRUE;

      default:
        return FALSE;
    }
}


BOOL
isSafeMode(
    VOID
    )

/*++

Routine Description:

    Detect whether the system has been booted in DSREPAIR mode

Arguments:

    VOID - 

Return Value:

    BOOL - True if it has, False if it has not

--*/

{
    WCHAR SafeBootEnvVar[sizeof(SAFEBOOT_DSREPAIR_STR_W)];

    RtlZeroMemory(SafeBootEnvVar, sizeof(SafeBootEnvVar));

    if ( GetEnvironmentVariableW(L"SAFEBOOT_OPTION", SafeBootEnvVar, sizeof(SafeBootEnvVar)/sizeof(SafeBootEnvVar[0]) ) )
    {
        if ( !wcscmp( SafeBootEnvVar, SAFEBOOT_DSREPAIR_STR_W ) )
        {
            return TRUE;
        }
    }
    return FALSE;
} /* isSafeMode */

int
__cdecl
main(
    IN  int     argc,
    IN  char *  argv[]
    )
/*++

Routine Description:

    Entry point for the ISM process.  Called when started both directly from
    the command line and indirectly via the Service Control Manager.

Arguments:

    argc, argv (IN) - Command-line arguments.  Accepted arguments are:
       /install - Add the service to the Service Control Manager (SCM) database.
       /remove  - Remove the service from the SCM database.
       /debug   - Run the service as a normal process, not under the SCM.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    static SERVICE_TABLE_ENTRY DispatchTable[] = {
        { (char *) ISM_SERVICE::m_pszName, ServiceMain },
        { NULL, NULL }
    };

    int  ret = NO_ERROR;
    BOOL fInstall = FALSE;
    BOOL fRemove = FALSE;
    BOOL fDisplayUsage = FALSE;

    ret = gService.Init(ServiceCtrlHandler);
    if (NO_ERROR != ret) {
        DPRINT1(0, "Failed to gService.Init(), error %d.\n", ret);
	LogEvent8(
	    DS_EVENT_CAT_ISM,
	    DS_EVENT_SEV_ALWAYS,
	    DIRLOG_ISM_INIT_SERVICE,  
	    szInsertWin32Msg( ret ),   
	    szInsertWin32ErrCode( ret ),   
	    NULL,
	    NULL,
	    NULL, NULL, NULL, NULL );
        return ret;
    }

    // Parse command-line argumemnts.
    for (int iArg = 1; iArg < argc; iArg++) {
        switch (argv[iArg][0]) {
          case '/':
          case '-':
            // An option.
            if (!lstrcmpi(&argv[iArg][1], "install")) {
                fInstall = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "remove")) {
                fRemove = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "debug")) {
                gService.m_fIsRunningAsService = FALSE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "?")
                     || !lstrcmpi(&argv[iArg][1], "h")
                     || !lstrcmpi(&argv[iArg][1], "help")) {
                fDisplayUsage = TRUE;
                break;
            }
            else {
                // Fall through...
            }

          default:
            printf("Unrecognized parameter \"%s\".\n", argv[iArg]);
            ret = -1;
            fDisplayUsage = TRUE;
            break;
        }
    }

    if (fDisplayUsage) {
        // Display usage information.
        printf("\n"
               "Intersite Messaging Service\n"
               "Copyright (c) 1997 Microsoft Corporation.\n"
               "All rights reserved.\n"
               "\n"
               "/install    Add the service to the Service Control Manager (SCM) database.\n"
               "/remove     Remove the service from the SCM database.\n"
               "/debug      Run the service as a normal process, not under the SCM.\n"
               "\n");
    }
    else if (fInstall) {
        // Add service to the Service Control Manager database.
        ret = gService.Install();

        if (NO_ERROR == ret) {
            printf("Service installed successfully.\n");
        }
        else {
            printf("Failed to install service, error %d.\n", ret);
        }
    }
    else if (fRemove) {
        // Remove service from the Service Control Manager database.
        ret = gService.Remove();

        if (NO_ERROR == ret) {
            printf("Service removeed successfully.\n");
        }
        else {
            printf("Failed to remove service, error %d.\n", ret);
        }
    }
    else {
        if (gService.m_fIsRunningAsService) {
            LPSTR rgpszDebugParams[] = {"ismserv.exe", "-noconsole"};
            DWORD cNumDebugParams = sizeof(rgpszDebugParams)
                                    / sizeof(rgpszDebugParams[0]);

            // Start service under Service Control Manager.
            DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ismserv");

            if (!isSafeMode()) {
                if (!StartServiceCtrlDispatcher(DispatchTable)) {
                    ret = GetLastError();
                    DPRINT1(0, "Unable to StartServiceCtrlDispatcher(), error %d.\n", ret);
                    LogEvent8(
                        DS_EVENT_CAT_ISM,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_ISM_START_SERVICE_CTRL_DISPATCHER_FAILURE,  
                        szInsertWin32Msg( ret ),   
                        szInsertWin32ErrCode( ret ),   
                        NULL,
                        NULL,
                        NULL, NULL, NULL, NULL );
                }
            } else {
                DPRINT( 1, "Service not started because system is in DSREPAIR mode\n" );
            }
        }
        else {
            // Start service without Service Control Manager supervision.
            DEBUGINIT(0, NULL, "ismserv");

            SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);

            ret = gService.Run();
            DEBUGTERM( );
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\list.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    list.c

Abstract:

    Generic linked list package    

    Current functions include: create element or lookup element, and delete whole
    list.

    Callers define their list element.  They embed in the structure an element of
    type LIST_ENTRY. It is the address of this field that is used to identify an
    element in the list.  The caller can convert from a pointer to a LIST_ENTRY in
    their structure, to the base of their structure, by using CONTAINING_RECORD.

    Because the caller's structure may have other dynamically allocated storage, the
    caller must pass in callback routines to create and destroy their element as
    needed.

    In the future it would be reasonable to add a sorted version of the list.
    Also, single element removal/deletion function.
    Note there is no provision for protecting the lifetime of single elements,
    especially when a pointer has been handed out to another caller. In order
    to do that, a reference counting mechanism would need to be added.

Author:

    Will Lees (wlees) 19-Oct-1998

Environment:

Notes:

Revision History:

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include <winsock.h>

#include "common.h"

#include <fileno.h>
#define FILENO  FILENO_ISMSERV_LIST

#define DEBSUB "ISMLIST:"

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 20 15:27:32 1998 */

DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    );

DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    );

/* End Forward */


DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    )

/*++

Routine Description:

Generic list lookup and element creation routine.

Look up an element with the given name. If not found and Create is true, create
a new one.  If there are too many elements, release the oldest one.

List lock should be held by caller, if necessary.

Caller should have initialized listhead

Arguments:

    pfnCreate - Routine to initialize the callers element, but not allocate
    pfnDestroy - Routine to clear the caller's element, but not deallocate
    cbEntry - Size of callers element, including LIST_ENTRY_INSTANCE
    MaximumNumberEntries - List limit, or 0 for none
    pListHead - List head, must already be initialized
        NOTE, this is a LIST_ENTRY not a LIST_ENTRY_INSTANCE
    pdwEntryCount - Updated count of entries in list, caller must initialize
    EntryName - Name of new entry. Matching is on the basis of this name
    Create - Set true if we should create a new element if this name not found
    ppListEntry - Returned entry, either existing or newly created

Return Value:

    DWORD - 

--*/

{
    DWORD status, length;
    PLIST_ENTRY curr;
    PLIST_ENTRY_INSTANCE pNewEntry = NULL;

    // Be defensive
    if ( !( ppListEntry ) ||
         !( pdwEntryCount ) ||
         ( cbEntry < sizeof( LIST_ENTRY_INSTANCE ) ) ||
         !( pListHead ) ||
         !( pListHead->Flink ) ||
         !( pListHead->Blink ) ) {
        Assert( FALSE );
        return E_INVALIDARG;
    }

    // See if the entry is already present

    curr = pListHead->Flink;
    while (curr != pListHead) {
        PLIST_ENTRY_INSTANCE pListEntry;

        pListEntry = CONTAINING_RECORD( curr, LIST_ENTRY_INSTANCE, ListEntry );

        if (_wcsicmp( EntryName, pListEntry->Name ) == 0) {
            *ppListEntry = pListEntry;
            return ERROR_SUCCESS;
        }
        curr = curr->Flink;
    }

    // If we are not allowed to create it, exit at this point

    if (!Create) {
        *ppListEntry = NULL;
        return ERROR_FILE_NOT_FOUND;
    }

    // Create new record of user-specified size

    pNewEntry = (PLIST_ENTRY_INSTANCE) NEW_TYPE_ARRAY_ZERO( cbEntry, BYTE );
    if (pNewEntry == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize our part
    // Do this first so callback can use this info

    length = wcslen( EntryName );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    pNewEntry->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (pNewEntry->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pNewEntry->Name, EntryName );

    // Initialize caller's part

    status = (*pfnCreate)( pNewEntry );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // If too many instances, get rid of one
    if ( (MaximumNumberEntries) &&
         (*pdwEntryCount == MaximumNumberEntries) ) {
        PLIST_ENTRY entry;
        PLIST_ENTRY_INSTANCE pListEntry;

        // Select least recent
        entry = pListHead->Flink;
        Assert( !IsListEmpty( pListHead ) );

        RemoveEntryList( entry );
        pListEntry = CONTAINING_RECORD( entry, LIST_ENTRY_INSTANCE,
                                        ListEntry);

        // Deallocate caller's part
        (VOID) (*pfnDestroy)( pListEntry );

        // Deallocate our part
        if (pListEntry->Name) {
            FREE_TYPE( pListEntry->Name );
        }
        FREE_TYPE( pListEntry );

    } else {
        (*pdwEntryCount)++;
    }

    // Link the new instance onto the list at the end

    InsertTailList( pListHead, &(pNewEntry->ListEntry) );

    // Success!

    *ppListEntry = pNewEntry;

    return ERROR_SUCCESS;

cleanup:
    if (pNewEntry) {
        if (pNewEntry->Name != NULL) {
            FREE_TYPE( pNewEntry->Name );
        }
        FREE_TYPE( pNewEntry );
    }

    return status;

} /* ListFindCreateEntry */


DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    )

/*++

Routine Description:

Destroy a generic list.

Caller should hold list lock if necessary

Arguments:

    pfnDestroy - Caller's element release function
    pListHead - List head of list
    pdwEntryCount - Updated count of elements in list, set to zero
        Note, we check this for accuracy

Return Value:

    DWORD - Always success

--*/

{
    PLIST_ENTRY entry;
    PLIST_ENTRY_INSTANCE pListEntry;

    Assert( pdwEntryCount );

    while (!IsListEmpty( pListHead )) {
        Assert( *pdwEntryCount );
        (*pdwEntryCount)--;

        entry = RemoveHeadList( pListHead );

        pListEntry = CONTAINING_RECORD( entry, LIST_ENTRY_INSTANCE,
                                        ListEntry );

        // Release caller's part
        (VOID) (*pfnDestroy)( pListEntry );

        // Release our part
        FREE_TYPE( pListEntry->Name );

        FREE_TYPE( pListEntry );
    }

    Assert( *pdwEntryCount == 0 );
    *pdwEntryCount = 0;

    return ERROR_SUCCESS;
} /* ListDestroyList */

/* end list.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\route.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    route.c

Abstract:

This module contains the routines to implement the "routing api", namely
    GetTransportServers
    GetSiteConnectivity
    GetSchedule

These routines are independent from the data transfer functions.

These routines are based on configuration data of servers, sites and links.  This may come
from the local system registry (testing) or from ldap.

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // INTERSITETRANS_OPT_* flags

#include <dsconfig.h>  // GetConfigParam()
#include <ismapi.h>
#include <debug.h>

#include <winsock.h>

#include <common.h>

#include <dsutil.h> // TickTime routines

#define DEBSUB "ROUTE:"

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ROUTE

// Use the generate table template to create a type specific table!
// Site Hash Table

#define SITE_HASH_TABLE_SIZE 5003  // should be prime

#define DWORD_INFINITY          (~ (DWORD) 0)

typedef struct _SITE_INSTANCE {
    TABLE_ENTRY TableEntry;  // must be first
    DWORD Size;
    DWORD Index;
} SITE_INSTANCE, *PSITE_INSTANCE;

typedef PTABLE_INSTANCE PSITE_TABLE;

#define SiteTableCreate() TableCreate( SITE_HASH_TABLE_SIZE, sizeof( SITE_INSTANCE ) )
#define SiteTableFree( table ) TableFree( (PTABLE_INSTANCE) table )
#define SiteTableFindCreate( table, name, create ) \
(PSITE_INSTANCE) TableFindCreateEntry( (PTABLE_INSTANCE) table, name, create )

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 27 11:07:11 1998 */

VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
RouteGetConnInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    );

DWORD
RouteGetPathSchedInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    );

static DWORD
processSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PSITE_TABLE SiteTable,
    DWORD NumberSites,
    PISMGRAPH CostArray
    );

static DWORD
readSimpleBridge(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PWSTR BridgeName,
    PSITE_TABLE SiteTable,
    PISMGRAPH TempArray,
    PISMGRAPH CostArray
    );

static DWORD
walkSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

static DWORD
addSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    LPWSTR SiteLinkName,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

static DWORD
addLinkToCostArray(
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    PWSTR FromSite,
    PWSTR ToSite,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

/* End Forward */


VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        // Invalidate the cache, recalculate later
        DPRINT1( 1, "Invalidating routing cache for %ws\n",
                 pTransport->Name );
        pTransport->RoutingState.fCacheIsValid = FALSE;
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
}


DWORD
RouteGetConnInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

Return the list of sites, a site name array, and a connectivity matrix.

A hash table is used to store the site names found, for ease of lookup.

Once all the site names are found, they are assigned an order (index).  This is the order
used to generate the site name list at the end.

The simple link structures are read to determine which sites are connected.

Once the number of sites is known, the cost array is allocated.  The initial single hop costs
are then placed in the array.  Then the ALL COSTS algorithm is run on the array to produce the
shorted paths for all pairs.

Each time this routine is called, it regenerates three pieces of information:
- the list of sites
- the matrix of costs
- the matrix of schedules
The first two are returned and freed.

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

Arguments:

    pTransport - 
    pNumberSites - May be NULL if output is not desired.
    ppSiteList - May be NULL if output is not desired.
    ppLinkArray - May be NULL if output is not desired.

    dwRouteFlags - Zero or more of the following bits:
        ROUTE_IGNORE_SCHEDULES - Schedules on siteLink objects will be ignored.
            (And the "ever-present" schedule is assumed.)
        ROUTE_BRIDGES_REQUIRED - siteLinks must be explicitly bridged with
            siteLinkBridge objects to indicate transitive connections.
            Otherwise, siteLink transitivity is assumed.

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status, i;
    PISMGRAPH CostGraph = NULL;
    PSITE_TABLE SiteTable = NULL;
    PSITE_INSTANCE site;
    DWORD NumberSites;
    LPWSTR *pSiteList = NULL, *pSiteListCopy = NULL;
    PISM_LINK pLinkArray = NULL;
    int nPriority = THREAD_PRIORITY_NORMAL;
    DWORD dwBiasedPriority;

    // Parameter validation: NULL output parameters are okay here if the
    // caller does not want any output. (i.e. RouteQuerySitesByCost)
    if(    (NULL==pNumberSites)
        || (NULL==ppSiteList)
        || (NULL==ppLinkArray) )
    {
        // All output parameters must be NULL
        Assert( NULL==pNumberSites && NULL==ppSiteList && NULL==ppLinkArray );
    }

    // Step 0: Check if cached data still valid
    // Use tick counts in case time gets changed or set backwards
    // Tick counts are in 1ms intervals, wrap every 47 days of uptime
    // Note the degraded performance guarantee. If the notify thead dies for some
    // reason, we will not consider the cache valid and will recalculate.

    if ( (DirIsNotifyThreadActive( pTransport ) ) &&
         (pTransport->RoutingState.CostGraph) &&
         (pTransport->RoutingState.fCacheIsValid) ) {

        NumberSites = pTransport->RoutingState.NumberSites;
        CostGraph = pTransport->RoutingState.CostGraph;
        pSiteList = pTransport->RoutingState.pSiteList;

        goto copy_out;
    }

    // Step 1: Initialize

    // Free previous graph state 
    RouteFreeState( pTransport );

    // initialize site list
    NumberSites = 0;
    status = DirGetSiteList( pTransport->DirectoryConnection,
                             &NumberSites,
                             &pSiteList );
    if (status != ERROR_SUCCESS) {
        // nothing to clean up yet
        return status;
    }

    // There should always be atleast one site
    if (NumberSites == 0) {
        // nothing to clean up yet
        return ERROR_DS_OBJ_NOT_FOUND;
    }

    // Initialize symbol table
    SiteTable = SiteTableCreate();
    if (NULL == SiteTable) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // Change priority if necessary
    if (!GetConfigParam( ISM_THREAD_PRIORITY, &dwBiasedPriority, sizeof( DWORD ) )) {
        if (dwBiasedPriority > ISM_MAX_THREAD_PRIORITY) {
            dwBiasedPriority = ISM_MAX_THREAD_PRIORITY;
        }
        nPriority = dwBiasedPriority - ISM_THREAD_PRIORITY_BIAS;
        if( ! SetThreadPriority(GetCurrentThread(),nPriority) ) {
            status = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", status);
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SET_PRIORITY_ERROR,
                szInsertWin32Msg(status),
                NULL,
                NULL
                );
        } else {
            DPRINT1(1, "ISM thread priority is now %d\n", nPriority );
        }
    }

    // Step 2: Insert each site into the hash table for ease of lookup
    for( i = 0; i < NumberSites; i++ ) {
        site = SiteTableFindCreate( SiteTable, pSiteList[i], TRUE /* create */ );
        if (site == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        // Assign index to site according to site list order
        site->Index = i;
    }

    // Step 3: allocate cost matrix
    // SCALING BUG 87827:
    // 1000 SITES = 1000 * 1000 * 12 BYTES = approx 12 MB
    CostGraph = GraphCreate( NumberSites, TRUE /* initialize */ );
    if (CostGraph == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;  // bug fix 151725
        goto cleanup;
    }

    // Step 4: add pure links without bridging

    status = walkSiteLinks( pTransport,
                            SiteTable,
                            CostGraph,
                            dwRouteFlags,
                            dwReplInterval );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (dwRouteFlags & ROUTE_BRIDGES_REQUIRED) {
        // Step 5: walk site link bridges for explicit transitivity

        status = processSiteLinkBridges( pTransport,
                                         dwRouteFlags,
                                         dwReplInterval,
                                         SiteTable,
                                         NumberSites,
                                         CostGraph );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }
    else {
        // Step 5: Transitivity is assumed, so compute the full transitive
        // closure.
        status = GraphAllCosts( CostGraph, (dwRouteFlags & ROUTE_IGNORE_SCHEDULES) );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "GraphAllCosts failed, error %d\n", status );
            goto cleanup;
        }
    }

    Assert( pTransport->RoutingState.NumberSites == 0 );
    Assert( pTransport->RoutingState.pSiteList == NULL );
    Assert( pTransport->RoutingState.CostGraph == NULL );
    Assert( pTransport->RoutingState.SiteSymbolTable == NULL );

    // Cache data: SiteList, CostGraph and SiteTable remain allocated
    pTransport->RoutingState.fCacheIsValid = TRUE;
    pTransport->RoutingState.NumberSites = NumberSites;
    pTransport->RoutingState.pSiteList = pSiteList;
    pTransport->RoutingState.CostGraph = CostGraph;
    pTransport->RoutingState.SiteSymbolTable = SiteTable;

copy_out:
    // Step 6: Copy out user arguments
    // The resource release code here is a little tricky. If we are successful, all the
    // data blocks will have been handed out, and don't need any individual cleanup.
    // If we fail in here, then we want to clear the cache and allow individual cleanup
    // of the data blocks.

    Assert( NumberSites != 0 );
    Assert( pSiteList != NULL );
    Assert( CostGraph != NULL );

    Assert( pTransport->RoutingState.NumberSites != 0 );
    Assert( pTransport->RoutingState.pSiteList != NULL );
    Assert( pTransport->RoutingState.CostGraph != NULL );
    Assert( pTransport->RoutingState.SiteSymbolTable != NULL );
    Assert( pSiteListCopy == NULL );
    Assert( pLinkArray == NULL );

    // Assume success
    status = ERROR_SUCCESS;

    // If the caller does not want any output, don't create any...
    if( NULL==pNumberSites || NULL==ppSiteList || NULL==ppLinkArray ) {
        // ... but don't clean up the transport's internal state either
        pSiteList = NULL;
        CostGraph = NULL;
        SiteTable = NULL;
        goto cleanup;
    }

    DirCopySiteList( NumberSites, pSiteList, &pSiteListCopy );
    if (pSiteListCopy == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        // We are in the strange position of having enough memory to build and
        // cache a routing state, but not enough to copy it out.
        // keep going
    }

    if (status == ERROR_SUCCESS) {
        // This call copies the array portion out of the graph.
        GraphReferenceMatrix( CostGraph, &pLinkArray );
        if (pLinkArray == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            // keep going
        }
    }

    if (status == ERROR_SUCCESS) {
        *pNumberSites = NumberSites;
        *ppSiteList = pSiteListCopy;
        *ppLinkArray = pLinkArray;

        pSiteListCopy = NULL;  // don't clean this up
        pLinkArray = NULL;  // don't clean this up

    } else {
        RouteFreeState( pTransport );
        // pSiteList, CostGraph and SiteSymbolTable cleaned up now
        // pSiteListCopy and pLinkArray will be cleaned up below

        Assert( pTransport->RoutingState.NumberSites == 0 );
        Assert( pTransport->RoutingState.pSiteList == NULL );
        Assert( pTransport->RoutingState.CostGraph == NULL );
        Assert( pTransport->RoutingState.SiteSymbolTable == NULL );
    }

    pSiteList = NULL; // don't clean this up
    CostGraph = NULL; // don't clean this up
    SiteTable = NULL; // don't clean this up

cleanup:               

    if (nPriority != THREAD_PRIORITY_NORMAL) {
        if( ! SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL) ) {
            status = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", status);
        }
    }

    // Clean up site list
    if (pSiteList) {
        DirFreeSiteList( NumberSites, pSiteList );
    }
    if (pSiteListCopy) {
        DirFreeSiteList( NumberSites, pSiteListCopy );
    }

    // free site table
    if (SiteTable != NULL) {
        SiteTableFree( SiteTable );
    }

    // free matrix
    if (pLinkArray != NULL) {
        GraphDereferenceMatrix( CostGraph, pLinkArray );
    }

    // free cost array
    if (CostGraph != NULL) {
        GraphFree( CostGraph );
    }

    return status;
} /* RouteGetConnectivity */


DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

Wrapper for RouteGetConnInternal.
Take a lock around the connectivity function so that no other routine may
be reading or writing the routing state variables.

Arguments:

    pTransport - 
    pNumberSites - 
    ppSiteList - 
    ppLinkArray - 
    dwRouteFlags - 
    dwReplInterval - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    EnterCriticalSection( &(pTransport->Lock) );
    __try {

        status = RouteGetConnInternal(
            pTransport,
            pNumberSites,
            ppSiteList,
            ppLinkArray,
            dwRouteFlags,
            dwReplInterval
            );
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    return status;
} /* RouteGetConnectivity */


VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    pLinkArray - 

Return Value:

    None

--*/

{
    GraphDereferenceMatrix( pTransport->RoutingState.CostGraph,
                            pLinkArray );
} /* RouteFreeLinkArray */


DWORD
RouteGetPathSchedInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    PSITE_INSTANCE toSite, fromSite;

    // Note that there are no cache lifetime requirements on the schedule
    // data.
    // TODO: investigate returning schedules with connectivity data

    // Must have called GetConnectivity first
    if (pTransport->RoutingState.CostGraph == NULL) {
        DPRINT( 0, "Must call GetConnectivity first on this transport\n" );
        return ERROR_NOT_READY;
    }

    fromSite = SiteTableFindCreate( pTransport->RoutingState.SiteSymbolTable,
                                    FromSiteName,
                                    FALSE /* don't create */ );
    if (fromSite == NULL) {
        DPRINT1( 0, "GetPathSched: %ws, (from) site not found\n", FromSiteName );
        return ERROR_NO_SUCH_SITE;
    }

    toSite = SiteTableFindCreate( pTransport->RoutingState.SiteSymbolTable,
                                  ToSiteName,
                                  FALSE /* don't create */ );
    if (toSite == NULL) {
        DPRINT1( 0, "GetPathSched: %ws, (to) site not found\n", ToSiteName );
        return ERROR_NO_SUCH_SITE;
    }

    status = GraphGetPathSchedule( pTransport->RoutingState.CostGraph,
                                   fromSite->Index,
                                   toSite->Index,
                                   pSchedule,
                                   pLength );

    return status;
}


DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

Wrapper for RouteGetPathSchedInternal.
Take the transport lock so only one thread may be accessing the routing
state at a given time.

Arguments:

    pTransport - 
    FromSiteName - 
    ToSiteName - 
    pSchedule - 
    pLength - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        status = RouteGetPathSchedInternal(
            pTransport,
            FromSiteName,
            ToSiteName,
            pSchedule,
            pLength
            );
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    return status;
} /* RouteGetPathSchedule */


void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 

Return Value:

    None

--*/

{
    PROUTING_STATE prs = &(pTransport->RoutingState);
    
    // This routine assumes that the caller will hold the transport
    // lock, expect during rundown

    if (prs->pSiteList) {
        DirFreeSiteList( prs->NumberSites, prs->pSiteList );
    }
    if (prs->CostGraph) {
        GraphFree( prs->CostGraph );
    }
    if (prs->SiteSymbolTable) {
        SiteTableFree( prs->SiteSymbolTable );
    }

    ZeroMemory( prs, sizeof( ROUTING_STATE ) );
} /* RouteFreeState */


DWORD
RouteQuerySitesByCost(
    PTRANSPORT_INSTANCE         pTransport,
    LPCWSTR                     pszFromSite,
    DWORD                       cToSites,
    LPCWSTR*                    rgszToSites,
    DWORD                       dwFlags,
    ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo
    )
/*++

Routine Description:

    Determine the individual costs between the From site and the To sites.

Arguments:

    pTransport (IN) - Pointer to the structure containing all information
                      for this transport.

    pszFromSite (IN) - The distinguished name of the From site.

    rgszToSites (IN) - An array containing the distinguished names of the To sites.

    cToSites (IN) - The number of entries in the rgszToSites array.

    dwFlags (IN) - Unused.

    prgSiteInfo (IN) - On successful return, holds a pointer to a structure
        containing the costs between the From site and the To sites.
        This array should be freed using RouteFreeSiteCostInfo().
    
Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PISM_SITE_COST_INFO rgCostInfo=NULL;
    PWSTR               *pSiteList=NULL;
    PISM_LINK           pLinkArray=NULL;
    PSITE_TABLE         SiteTable=NULL;
    PSITE_INSTANCE      site;
    DWORD               NumberSites=0, i;
    DWORD               iFromSite, iToSite;
    DWORD               status;

    // Validate parameters
    Assert( NULL!=pTransport );
    Assert( NULL!=pszFromSite );
    Assert( NULL!=rgszToSites );
    Assert( NULL!=prgSiteInfo );

    // Clear results
    *prgSiteInfo = NULL;

    EnterCriticalSection( &(pTransport->Lock) );

    __try {

        // Call RouteGetConnInternal to check the cached matrix and generate a
        // new one if necessary. It does not return any results to us.
        status = RouteGetConnInternal( pTransport, NULL, NULL, NULL,
            pTransport->Options, pTransport->ReplInterval );
        
        // The results of the RouteGetConnInternal call are obtained by
        // directly peeking in the transport object.
        NumberSites = pTransport->RoutingState.NumberSites;
        SiteTable = pTransport->RoutingState.SiteSymbolTable;
        GraphPeekMatrix( pTransport->RoutingState.CostGraph, &pLinkArray );
        
        Assert( NULL!=pLinkArray );
        Assert( NULL!=SiteTable );
        
        // Find the From site in the hash table
        site = SiteTableFindCreate( SiteTable, pszFromSite, FALSE /* don't create */ );
        if( site==NULL ) {
            status = ERROR_DS_OBJ_NOT_FOUND;
            __leave;
        }
        iFromSite = site->Index;

        // Allocate the structure which contains the results
        *prgSiteInfo = NEW_TYPE_ZERO( ISM_SITE_COST_INFO_ARRAY );
        if( NULL==*prgSiteInfo ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        (*prgSiteInfo)->cToSites = cToSites;

        // Allocate the array containing the results
        rgCostInfo = NEW_TYPE_ARRAY_ZERO( cToSites, ISM_SITE_COST_INFO );
        if( NULL==rgCostInfo ) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        (*prgSiteInfo)->rgCostInfo = rgCostInfo;

        // Copy the costs into the results
        for( i=0; i<cToSites; i++ ) {

            // Find the To site in the hash table
            site = SiteTableFindCreate( SiteTable, rgszToSites[i], FALSE /* don't create */ );
            if( site==NULL ) {
                rgCostInfo[i].dwErrorCode = ERROR_DS_OBJ_NOT_FOUND;
                rgCostInfo[i].dwCost = DWORD_INFINITY;
                continue;   // Skip to next To site
            }

            iToSite = site->Index;
            rgCostInfo[i].dwErrorCode = ERROR_SUCCESS;
            rgCostInfo[i].dwCost = pLinkArray[ iFromSite*NumberSites + iToSite ].ulCost;

        }

        status = ERROR_SUCCESS;

    } finally {

        // If the call failed for some reason, free the results structure
        if( ERROR_SUCCESS!=status ) {
            if( NULL!=rgCostInfo ) {
                FREE_TYPE( rgCostInfo );
                rgCostInfo = NULL;
            }
            if( NULL!=*prgSiteInfo ) {
                FREE_TYPE( *prgSiteInfo );
                *prgSiteInfo = NULL;
            }
        }

        LeaveCriticalSection( &(pTransport->Lock) );
    }

    return status;
}


VOID
RouteFreeSiteCostInfo(
    IN ISM_SITE_COST_INFO_ARRAY*   prgSiteInfo
    )
/*++

Routine Description:

    Frees the structure returned by RouteQuerySitesByCost().

Arguments:

    prgSiteInfo (IN) - Structure to free.

Return Values:

    None.

--*/
{
    if( NULL!=prgSiteInfo ) {
        if( NULL!=prgSiteInfo->rgCostInfo ) {
            FREE_TYPE( prgSiteInfo->rgCostInfo );
        }
        FREE_TYPE( prgSiteInfo );
    }
}


static DWORD
processSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PSITE_TABLE SiteTable,
    DWORD NumberSites,
    PISMGRAPH CostArray
    )

/*++

Routine Description:

This routine enumerates the simple link structures in the registry.  It calls an action
routine for each.

The temp array is used to calculate an intermediate matrix for each bridged network
They are merged into the final cost array

Arguments:

    pTransport - 
    dwRouteFlags - route behavior options
    dwReplInterval - default replication interval
    NumberSites - 
    SiteTable - 
    CostArray - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, index, length;
    WCHAR bridgeName[MAX_REG_COMPONENT];
    PISMGRAPH TempArray = NULL;
    PVOID context = NULL;

    Assert( dwRouteFlags & ROUTE_BRIDGES_REQUIRED );

    // Allocate a temp array now for intermediate results.  It is init'd later
    TempArray = GraphCreate( NumberSites, FALSE /* initialize */ );
    if (TempArray == NULL) {
        DPRINT1( 0, "failed to allocate temp matrix for %d sites\n", NumberSites );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    while (1) {
        status = DirIterateSiteLinkBridges( pTransport,
                                            pTransport->DirectoryConnection,
                                            &context,
                                            bridgeName );
        if (status == ERROR_NO_MORE_ITEMS) {
            // context is already cleaned up
            status = ERROR_SUCCESS;
            break;
        } else if (status != ERROR_SUCCESS) {
            break;
        }

        status = readSimpleBridge( pTransport,
                                   dwRouteFlags,
                                   dwReplInterval,
                                   bridgeName,
                                   SiteTable,
                                   TempArray,
                                   CostArray
                                   );
        if (status != ERROR_SUCCESS) {
            DPRINT2( 0, "read of bridge key %ws, error = %d\n", bridgeName, status );
            LogEvent8( 
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_OBJECT_FAILURE,
                szInsertWC( bridgeName ),
                szInsertWin32Msg( status ),
                szInsertWin32ErrCode( status ),
                NULL, NULL, NULL, NULL, NULL
                );
            // keep going
        }
    }

    // status is set according to success or failure of iteration

cleanup:

    if (context != NULL) {
        DirTerminateIteration( &context );
    }

    if (TempArray != NULL) {
        GraphFree( TempArray );
    }

    return status;
} /* processSiteLinkBridges */


static DWORD
readSimpleBridge(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PWSTR BridgeName,
    PSITE_TABLE SiteTable,
    PISMGRAPH TempArray,
    PISMGRAPH CostArray
    )

/*++

Routine Description:

This routine is called by processSiteLinkBridges.  It handles the work on a single bridge entry.

Arguments:

    pTransport - 
    dwRouteFlags - route behavior options
    dwReplInterval - default replication interval
    BridgeName - 
    NumberSites - 
    SiteTable - 
    TempArray - 
    CostArray - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, type, length, i;
    PWSTR siteLinkList = NULL, linkName;

    DPRINT1( 3, "readSimpleBridge, bridge = %ws\n", BridgeName );

    status = GraphInit( TempArray );
    if( ERROR_SUCCESS!=status ) {
        return status;
    }

    status = DirReadSiteLinkBridge( pTransport,
                                    pTransport->DirectoryConnection,
                                    BridgeName,
                                    &siteLinkList );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // No siteLinks listed, all done
    if (siteLinkList == NULL) {
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Walk SiteLink list, populating array

    for( linkName = siteLinkList; *linkName != L'\0'; linkName += wcslen( linkName ) + 1 ) {

        status = addSiteLink( pTransport,
                              SiteTable,
                              TempArray,
                              linkName,
                              dwRouteFlags,
                              dwReplInterval );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "Action routine failed, error %d\n", status );
            goto cleanup;
        }

    }

    // All sites in a site link that is in a bridge are transitive
    // Perform all pairs, shortest path

    status = GraphAllCosts( TempArray, (dwRouteFlags & ROUTE_IGNORE_SCHEDULES) );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "GraphAllCosts failed, error %d\n", status );
        goto cleanup;
    }

    // Merge results into master matrix
    status = GraphMerge( CostArray, TempArray );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "GraphMerge failed, error %d\n", status );
        goto cleanup;
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteLinkList != NULL) {
        DirFreeMultiszString( siteLinkList );
    }

    return status;
} /* readSimpleBridge */


static DWORD
walkSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

This routine enumerates the simple link structures in the registry.  It calls an action
routine for each.

Arguments:

    pTransport - 
    SiteTable - 
    CostArray - 

    dwRouteFlags - If the ROUTE_IGNORE_SCHEDULES bit is set, schedules on
        siteLink objects will be ignored.  (And the "ever-present" schedule
        is assumed.)

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    PVOID context = NULL;
    WCHAR siteLinkName[MAX_REG_COMPONENT];

    while (1) {
        status = DirIterateSiteLinks( pTransport,
                                      pTransport->DirectoryConnection,
                                      &context,
                                      siteLinkName );
        if (status == ERROR_NO_MORE_ITEMS) {
            // context is already cleaned up
            status = ERROR_SUCCESS;
            break;
        } else if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

        status = addSiteLink( pTransport,
                              SiteTable,
                              CostArray,
                              siteLinkName,
                              dwRouteFlags,
                              dwReplInterval );
        if (status != ERROR_SUCCESS) {
            LogEvent8( 
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_OBJECT_FAILURE,
                szInsertWC( siteLinkName ),
                szInsertWin32Msg( status ),
                szInsertWin32ErrCode( status ),
                NULL, NULL, NULL, NULL, NULL
                );
            // keep going
        }
    }

    // status is set at this point according to success or failure

cleanup:

    if (context != NULL) {
        DirTerminateIteration( &context );
    }

    return status;

} /* walkSiteLinks */


static DWORD
addSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    LPWSTR SiteLinkName,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    SiteTable - 
    CostArray - 
    SiteLinkName - 

    dwRouteFlags - If the ROUTE_IGNORE_SCHEDULES bit is set, schedules on
        siteLink objects will be ignored.  (And the "ever-present" schedule
        is assumed.)

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    LPWSTR siteList = NULL, inner, outer;
    PBYTE pSchedule = NULL;
    PBYTE *ppSchedule;
    ISM_LINK link;

    //DPRINT1( 3, "addSiteLink, link name = %ws\n", SiteLinkName );

    ppSchedule = (dwRouteFlags & ROUTE_IGNORE_SCHEDULES)
                    ? NULL
                    : &pSchedule;

    status = DirReadSiteLink( pTransport,
                              pTransport->DirectoryConnection,
                              SiteLinkName,
                              &siteList,
                              &link,
                              ppSchedule );
    if (status != ERROR_SUCCESS) {
        // nothing to clean up
        return status;
    }

    // No sites listed
    if (siteList == NULL) {
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // If interval not specified, use the transport default

    if (link.ulReplicationInterval == 0) {
        link.ulReplicationInterval = dwReplInterval;
    }

    // process site link

    // SiteList can be 2 or more sites
    // Generate pairs, eliminate duplicates (order is not significant):
    // (a,b,c) => (a,b), (a,c), (b,c)

    outer = siteList;
    while (*outer != L'\0') {
        DWORD outerLength = wcslen( outer) + 1;

        for( inner = outer + outerLength; *inner != L'\0'; inner += wcslen( inner ) + 1 ) {

            // Filter out cyles to self, just in case
            if (_wcsicmp( outer, inner ) == 0) {
                continue;
            }

            // The action routine handles unidirectional (directed) links.  We convert here from
            // the bidirectional (undirected) notation by calling the action routine twice, once
            // for each direction.
            
            // Add the link in the forward direction

            status = addLinkToCostArray( SiteTable, CostArray, 
                                         outer, inner, &link, pSchedule );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "addLinkToCostArray1 failed, error %d\n", status );
                goto cleanup;
            }

            // Add the link in the backward direction
            status = addLinkToCostArray( SiteTable, CostArray,
                                         inner, outer, &link, pSchedule );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "addLinkToCostArray2 failed, error %d\n", status );
                goto cleanup;
            }
        }

        outer += outerLength;
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteList) {
        DirFreeMultiszString( siteList );
    }

    if (pSchedule) {
        DirFreeSchedule( pSchedule );
    }

    return status;
} /* addSiteLink */


static DWORD
addLinkToCostArray(
    PSITE_TABLE SiteTable,
    PISMGRAPH CostArray,
    PWSTR FromSite,
    PWSTR ToSite,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    )

/*++

Routine Description:

This is an action routine for the WalkSiteLinks function.

This routine stores the hop costs in the cost array.

Arguments:

    SiteTable - 
    CostArray - 
    FromSite - 
    ToSite - 
    Cost - 
    pSchedule - 

Return Value:

    DWORD - 

--*/

{
    PSITE_INSTANCE site1, site2;
    LPDWORD element;
    DWORD status;

    DPRINT5( 3, "Adding simple link %ws --(%d,%d,%p)--> %ws\n",
             FromSite,
             pLinkValue->ulCost, pLinkValue->ulReplicationInterval,
             pSchedule, ToSite );

    site1 = SiteTableFindCreate( SiteTable,
                                 FromSite,
                                 FALSE /* don't create */ );
    if (site1 == NULL) {
        // Must exist
        DPRINT1( 0, "Site %ws is not valid\n", FromSite );
        return ERROR_NO_SUCH_SITE;
    }
    site2 = SiteTableFindCreate( SiteTable,
                                 ToSite,
                                 FALSE /* don't create */ );
    if (site2 == NULL) {
        // Must exist
        DPRINT1( 0, "Site %ws is not valid\n", ToSite );
        return ERROR_NO_SUCH_SITE;
    }

    // Put cost in table ONLY if it is better than previous cost
    status = GraphAddEdgeIfBetter( CostArray,
                                   site1->Index, site2->Index,
                                   pLinkValue, pSchedule );

    return status;
} /* addLinkToCostArray */

/* end route.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\ip\dlltest.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    transporttest.c

Abstract:

Test for a transport dll.    

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name

        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

#include <schedule.h>

#include "ismapi.h"

/* External */

/* Static */

static ISM_NOTIFY NotifyFunction;

static HANDLE ghNotify = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 15 17:05:00 1998 */

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    );

static void
Usage(
    WCHAR *ProgramName
    );

static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    );

static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    );

static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    );

static void
printSchedule(
    PBYTE pSchedule
    );

static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    );

/* End Forward */


int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *option, *address, *service, *message, *transport, *site;
    if (argc < 2) {
        Usage( argv[0] );
        return -1;
    }
    option = argv[1];
    if (_wcsicmp( option, L"-c" ) == 0) {
        if (argc < 6) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        address = argv[3];
        service = argv[4];
        message = argv[5];
        if (!clientTest( transport, address, service, message )) {
            printf( "client test failed\n" );
        }
    } else if (_wcsicmp( option, L"-s" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        service = argv[3];

        if (!serverTest( transport, service )) {
            printf( "server test failed\n" );
        }
    } else if (_wcsicmp( option, L"-r" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        site = argv[3];

        if (!directoryTest( transport, site )) {
            printf( "directory test failed\n" );
        }
    } else {
        Usage( argv[0] );
        return -1;
    }
    return 0;
}


static void
Usage(
    WCHAR *ProgramName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "Usage:\n" );
    printf( "\t%ws -c transport address service \"string\"\tclient test\n", ProgramName );
    printf( "\t%ws -s transport service\tserver test\n", ProgramName );
    printf( "\t%ws -r transport site \trouting function test\n", ProgramName );
}


static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    ISM_MSG message;
    DWORD status, bytes, i;
    PBYTE pBlock;

    printf( "client test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    bytes = 0;
    bytes = _wtoi( Message );
    if (bytes == 0) {
        message.pszSubject = L"This is the subject";
        message.cbData = (wcslen( Message ) + 1) * sizeof( WCHAR );
        message.pbData = (PBYTE) Message;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
    } else {
        pBlock = LocalAlloc( LMEM_FIXED, bytes );
        if (pBlock == NULL) {
            printf( "LocalAlloc failed to alloc %d bytes\n", bytes );
            return FALSE;
        }
        for( i = 0; i < bytes; i++ ) {
            pBlock[i] = (BYTE) ((i % 26) + 'a');
        }
        message.cbData = bytes;
        message.pbData = pBlock;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
        LocalFree( pBlock );
    }

    IsmShutdown( handle );

    return TRUE;
}


static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status;
    PISM_MSG pMessage;
    BOOLEAN done = FALSE;

    printf( "server  test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = RpcServerListen(
        1, // minimum
        RPC_C_LISTEN_MAX_CALLS_DEFAULT, // maximum,
        1   // don't wait
        ); 
    if (status != ERROR_SUCCESS) {
        printf( "RpcServerListen failed with status %d\n", status );
        return FALSE;
    }

    while (!done) {
        status = IsmReceive( handle, Service, &pMessage );
        if (status) {
            printf( "IsmReceived failed with error %d\n", status );
            break;
        }
        if (pMessage == NULL) {
            Sleep( 30 * 1000 );
        } else {
            if (pMessage->cbData < 100) {
                printf( "Received subj: '%ws', message: \"%ws\"\n",
                        pMessage->pszSubject ? pMessage->pszSubject : L"no subject",
                        pMessage->pbData );
                if (_wcsicmp( (WCHAR *) pMessage->pbData, L"exit" ) == 0) {
                    done = TRUE;
                }
            } else {
                printf( "Received message: %d bytes\n", pMessage->cbData );
            }
            IsmFreeMsg( handle, pMessage );
        }
    }

    status = RpcMgmtStopServerListening( NULL );
    if (status != ERROR_SUCCESS) {
        printf( "RpcMgmtStopServerListen failed with status %d\n", status );
    }

    status = RpcMgmtWaitServerListen( );
    if (status != ERROR_SUCCESS) {
        printf( "RpcMgmtWaitServerListen failed with status %d\n", status );
    }

    IsmShutdown( handle );
    return TRUE;
}


static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status, i, j;
    BOOLEAN result = FALSE;
    PISM_CONNECTIVITY pConnectivity = NULL;
    PISM_SERVER_LIST pServerList = NULL;
    PISM_SCHEDULE pSchedule = NULL;

    printf( "directory test\n" );
    if (IsmStartup( TransportName, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = IsmGetTransportServers( handle, SiteName, &pServerList );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get transport servers, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nTransport Servers:\n" );
    if (pServerList != NULL) {
        printf( "Number of Servers = %d\n", pServerList->cNumServers );
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            printf( "\tServer[%d] = %ws\n", i, pServerList->ppServerDNs[i] );
        }
    } else {
        printf( "\tNone\n" );
    }

    status = IsmGetConnectionSchedule( handle, L"FOO", L"BAR", &pSchedule );
    if (status != ERROR_NOT_READY) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectivity( handle, &pConnectivity );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get connectivity, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nSite Connectivity::\n" );

    if (pConnectivity != NULL) {
        printf( "Number of sites = %d\n", pConnectivity->cNumSites );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "\tSite[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        }
        printf( "All pairs shortest path matrix:\n" );
        printf( "     |" );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            printf( "%5.5d|", j );
        }
        printf( "\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "%5.5d|", i );
            for( j = 0; j < pConnectivity->cNumSites; j++ ) {
                PISM_LINK pLink = &( pConnectivity->pLinkValues[ i * pConnectivity->cNumSites + j ] );
                if (pLink->ulCost != 0xffffffff) {
                    printf( "%5.5u:", pLink->ulCost );
                } else {
                    printf( "  *  :" );
                }
                printf( "%5.5u:", pLink->ulReplicationInterval );
                printf( "%5.5x|", pLink->ulOptions );
            }
            printf( "\n" );
        }
    } else {
        printf( "\tNo site connectivity\n" );
    }

    status = IsmGetConnectionSchedule( handle,
                                       pConnectivity->ppSiteDNs[0],
                                       L"BAR",
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectionSchedule( handle,
                                       L"FOO",
                                       pConnectivity->ppSiteDNs[0],
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    // Generate all pairs of sites

    if (pConnectivity != NULL) {
        printf( "\nSite to Site Scheduling:\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            for( j = i + 1; j < pConnectivity->cNumSites; j++ ) {
                if (pConnectivity->pLinkValues[ i + pConnectivity->cNumSites * j ].ulCost == 0xffffffff) {
                    continue;
                }
                status = IsmGetConnectionSchedule( handle,
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j],
                               &pSchedule );
                if (status != ERROR_SUCCESS) {
                    printf( "failed to get common site schedule, or not connected\n" );
                    goto cleanup;
                }

                printf( "\t%ws to %ws: ",
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j] );
                if (pSchedule != NULL) {
                    printf( "Connected via schedule, addr: %p, len: %d\n",
                            pSchedule->pbSchedule, pSchedule->cbSchedule );
                    printSchedule( pSchedule->pbSchedule );
                    IsmFreeConnectionSchedule( handle, pSchedule );
                } else {
                    printf( "Connected all the time\n" );
                }

            }
        }
    }


    result = TRUE;

cleanup:
    if (pConnectivity != NULL) {
        IsmFreeConnectivity( handle, pConnectivity );
    }

    if (pServerList != NULL) {
        IsmFreeTransportServers( handle, pServerList );
    }

    IsmShutdown( handle );

    return result;
}


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tues","Wed","Thurs","Fri","Sat"};

    printf( "\t\t" );
    for( day = 0; day < 7; day++ ) {
        for( hour = 0; hour < 24; hour++ ) {
            if (*data & 0x1) printf( "%s%d:00;", dow[day], hour );
            if (*data & 0x2) printf( "%s%d:15;", dow[day], hour );
            if (*data & 0x4) printf( "%s%d:30;", dow[day], hour );
            if (*data & 0x8) printf( "%s%d:45;", dow[day], hour );
            data++;
        }
    }
    printf( "\n" );
}


static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    )
/*++

Routine Description:

    Called by the plug-in to notify the ISM service that a message has been
    received for the given service.

Arguments:

    hNotify (IN) - Notification handle, as passed to the plug-in in the
        IsmStartup() call.

    pszServiceName (IN) - Service for which a message was received.

Return Values:

    None.

--*/
{
    printf( "Notified of pending message for service %ws.\n", pszServiceName );
}

/* end plugtest.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\memory.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Debug memory allocator.
    Checks for heap corruption.
    Reports memory not deallocated

    User interface:
    ptr = NEW_TYPE( type )
    ptr = NEW_TYPE_ARRAY( count, type )
    ptr = NEW_TYPE_ZERO( type )
    ptr = NEW_TYPE_ARRAY_ZERO( count, type )
    TYPE_FREE( ptr )

Author:

    Will Lees (wlees) 22-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include "common.h"
#include <fileno.h>
#define FILENO   FILENO_ISMSERV_MEMORY

#define DEBSUB "IPMEM:"

#define HEADER_SIGNATURE  0x01234567
#define TRAILER_SIGNATURE 0xabcdef01
#define DEAD_SIGNATURE    0xdeadbeef

// Force quadword alignment

#define ALIGNMENT 8
#define ALIGN( x ) (((x) + (ALIGNMENT-1)) & ~(ALIGNMENT-1))

typedef struct _HEADER {
    LIST_ENTRY Link;
    PCHAR File;
    DWORD Line;
    DWORD Signature;
    DWORD UserSize;
    DWORD TrailerOffset;
    LARGE_INTEGER UserData[1];
    // CODE.IMP: in use linkage
} HEADER, *PHEADER;

typedef struct _TRAILER {
    DWORD Signature;
} TRAILER, *PTRAILER;

/* External */

/* Static */

CRITICAL_SECTION gcsIsmMemoryLock;
LIST_ENTRY gleIsmMemoryListHead;

// Last entry we saw before we crashed
PLIST_ENTRY gpleIsmLastGoodEntry = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Jul 20 17:08:24 1998 */

void
DebugMemoryInitialize(
    void
    );

void
DebugMemoryTerminate(
    void
    );

PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryRellocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    );

/* End Forward */


void
DebugMemoryInitialize(
    void
    )

/*++

Routine Description:

Initialize the package.  Call once at startup.

Arguments:

    void - 

Return Value:

    None

--*/

{
    InitializeCriticalSection( &gcsIsmMemoryLock );
    InitializeListHead( &gleIsmMemoryListHead );
} /* DebugMemoryInitialize */


void
DebugMemoryTerminate(
    void
    )

/*++

Routine Description:

Rundown the package.  Call once at shutdown.  Reports memory not deallocated.

Arguments:

    void - 

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

    while (!IsListEmpty(&gleIsmMemoryListHead)) {
        entry = RemoveHeadList( &gleIsmMemoryListHead );
        pHeader = CONTAINING_RECORD( entry, HEADER, Link );
        DPRINT2( 0, "Unfreed memory: %s:%d\n", pHeader->File, pHeader->Line );
    }
    DeleteCriticalSection( &gcsIsmMemoryLock );
} /* DebugMemoryTerminate */


PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to allocate a block of memory.

Arguments:

    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader;
    PTRAILER pTrailer;

//    DPRINT3( 1, "DebugMemoryAllocate, Size=%d,File=%s,Line=%d\n", Size, File, Line );

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pHeader = (PHEADER) malloc( amount );
    if (pHeader == NULL) {
        DPRINT3( 0, "Memory allocation of %d failed at %s:%d\n", amount, File, Line );
        // CODE.IMP: Additional logging?
        return NULL;
    }
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryAllocate */


PVOID
DebugMemoryReallocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to reallocate a block of memory.

Arguments:

    MemoryBlock - pointer to old block
    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader, pNewHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    // Treat like a new allocation

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pNewHeader = (PHEADER) realloc( pHeader, amount );
    if (pNewHeader == NULL) {
        DPRINT4( 0, "Memory reallocation of %p,%d failed at %s:%d\n",
                 MemoryBlock, amount, File, Line );
        // CODE.IMP: Additional logging?

        // Need to reinsert block back on the list
        EnterCriticalSection( &gcsIsmMemoryLock );
        __try {
            // Most recent to the front
            InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
        } __finally {
            LeaveCriticalSection( &gcsIsmMemoryLock );
        }

        return NULL;
    }
    pHeader = pNewHeader;

    // Reinitialize header and trailer
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryReallocate */


PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Allocate a block of memory, zero user portion

Arguments:

    Size - 
    File - 
    Line - 

Return Value:

    PVOID - 

--*/

{
    PVOID memory;
    memory = DebugMemoryAllocate( Size, File, Line );
    if (memory) {
        ZeroMemory( memory, Size );
    }
    return memory;
} /* DebugMemoryAllocateZero */


BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Check if block of memory is ok

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    True if block is ok, else false

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );
    if (pHeader->Signature != HEADER_SIGNATURE) {
        if (pHeader->Signature == DEAD_SIGNATURE) {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p header is already deleted, from %s:%d\n",
                     File, Line,
                     MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT3( 0, "Check on %s:%d\nMemory block %p header has invalid signature\n",
                     File, Line, MemoryBlock );
        }
        Assert( FALSE );
        return FALSE;
    }

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    if (pTrailer->Signature != TRAILER_SIGNATURE) {
        if (pTrailer->Signature == DEAD_SIGNATURE) {
           DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer is already deleted, from %s:%d\n",
                    File, Line,
                    MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer has invalid signature, from %s:%d\n",
                     File, Line, MemoryBlock, pHeader->File, pHeader->Line );
        }
        Assert( FALSE );
        return FALSE;
    }
    return TRUE;
} /* DebugMemoryCheck */


void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Free a block of memory

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    None

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    pHeader->Signature = DEAD_SIGNATURE;
    ZeroMemory( &(pHeader->Link), sizeof( LIST_ENTRY ) );

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    pTrailer->Signature = DEAD_SIGNATURE;

    // Note that we preserve the remaining header contents so that if this
    // block turns up again, we may know where it came from

    memset( MemoryBlock, 'w', pHeader->UserSize );

    free( (PVOID) pHeader );
} /* DebugMemoryFree */


void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

/*
  Do the whole list traversal and analysis under the lock. Yuck. This guarantees a
  coherent view. If contention gets to be a problem, we need to do two things:
1. Protect access to the Flink using the critical section to prevent linked
   list simultaneous access.
2. Guarantee the lifetime of the block while we are using it.  A ref count or an
   in use flag will be needed for that.
*/

    gpleIsmLastGoodEntry = &gleIsmMemoryListHead;

    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {

        entry = gleIsmMemoryListHead.Flink;
        while ( entry != &gleIsmMemoryListHead ) {
            Assert( entry && "linked list entry should have been non-zero but was not\ndd gpleIsmLastEntry l1 for pointer to last good list entry" );

            pHeader = CONTAINING_RECORD( entry, HEADER, Link );
            DebugMemoryCheck( pHeader->UserData, File, Line );

            gpleIsmLastGoodEntry = entry;
            entry = entry->Flink;
        }

    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

}
/* end memory.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\table.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    table.c

Abstract:

    This is a generic table module.

    It is customized by macro's by the caller to return entries of whatever size and type
    the user requires.  For example, in route.c we have:

// Use the generate table template to create a type specific table!
// Site Hash Table

#define SITE_HASH_TABLE_SIZE 107  // should be prime

typedef struct _SITE_INSTANCE {
    TABLE_ENTRY TableEntry;  // must be first
    DWORD Size;
    DWORD Index;
} SITE_INSTANCE, *PSITE_INSTANCE;

typedef PTABLE_INSTANCE PSITE_TABLE;

#define SiteTableCreate() TableCreate( SITE_HASH_TABLE_SIZE, sizeof( SITE_INSTANCE ) )
#define SiteTableFree( table ) TableFree( (PTABLE_INSTANCE) table )
#define SiteTableFindCreate( table, name, create ) \
(PSITE_INSTANCE) TableFindCreateEntry( (PTABLE_INSTANCE) table, name, create )

The core structure must be embedded in the user's datatype at the start.

TODO: Deletion of entries, locking, and reference counting
For deletion, switch to using doubly linked list macros

Author:

    Will Lees (wlees) 08-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include <winsock.h>
#include <ntdsapi.h>

#include "common.h"

#include <fileno.h>
#define FILENO   FILENO_ISMSERV_LIST

#define DEBSUB "TABLE:"

// This represents a generic table.  It is self describing.
typedef struct _TABLE_INSTANCE {
    DWORD Size;
    DWORD TableSize;
    DWORD EntrySize;
    struct _TABLE_ENTRY **Table;
} TABLE_INSTANCE, *PTABLE_INSTANCE;

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 08 16:25:46 1998 */

PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    );

VOID
TableFree(
    PTABLE_INSTANCE Table
    );

PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    );

LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    );

/* End Forward */


PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    )

/*++

Routine Description:

Create a generic table.

Arguments:

    TableSize - Number of hash buckets.  Should be prime.
    EntrySize - Size of user entries.  Must embed a TABLE_ENTRY structure

Return Value:

    PTABLE_INSTANCE -

--*/

{
    DWORD i;
    PTABLE_INSTANCE table;

    if (EntrySize < sizeof( TABLE_ENTRY ) ) {
        DPRINT( 1, "table entry size is invalid\n" );
        return NULL;
    }

    table = NEW_TYPE( TABLE_INSTANCE );
    if (table == NULL) {
        // ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    table->Size = sizeof( TABLE_INSTANCE );
    table->TableSize = TableSize;
    table->EntrySize = EntrySize;

    table->Table = NEW_TYPE_ARRAY( TableSize, PTABLE_ENTRY );
    if (table->Table == NULL) {
        FREE_TYPE( table );
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    for( i = 0; i < TableSize; i++ ) {
        table->Table[i] = NULL;
    }

    return table;
} /* TableCreate */


VOID
TableFree(
    PTABLE_INSTANCE Table
    )

/*++

Routine Description:

Free a generic table

CODE.IMPROVEMENT: provide a means to deallocate dynamic data in user section of the entry

Arguments:

    Table -

Return Value:

    None

--*/

{
    DWORD i;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return;
    }

    // Cleanup hash table
    for( i = 0; i < Table->TableSize; i++ ) {
        PTABLE_ENTRY current, next;

        current = Table->Table[i];
        while (current != NULL) {
            next = current->Next;

            FREE_TYPE( current->Name );
            current->Name = NULL;
            FREE_TYPE( current ); // destroys the users entry, EntrySize bytes worth

            current = next;
        }
    }
    FREE_TYPE( Table->Table );
    Table->Table = NULL;

    FREE_TYPE( Table );
} /* TableFree */


PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    )

/*++

Routine Description:

This routine stores an in the hash table.

Data structure is a hash table to a sorted single linked list by name

Arguments:

    Table - Hash table to work on
    EntryName - Name in DN form
    Create - flag to indicate wether to create if not found

Return Value:

    Success: created or found PTABLE_ENTRY
    Error: NULL.

Remarks:
    - Assumes EntryName is in DN form.
--*/

{
    DWORD hash, length;
    PWCHAR p;
    LPWSTR pCanonicalName = NULL;
    PTABLE_ENTRY current, new, previous;
    int result;
    DWORD err;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return NULL;
    }

    pCanonicalName = GetCanonicalDN( EntryName );

    if ( !pCanonicalName ) {
        DPRINT(1, "Error: Failed to generate canonical name\n");
        return NULL;
    }

    hash = 0;
    for( p = (LPWSTR) pCanonicalName; *p != L'\0'; p++ ) {
        hash += *p;
    }
    hash %= Table->TableSize;

    previous = NULL;
    current = Table->Table[hash];
    while (current != NULL) {
        result = _wcsicmp( pCanonicalName, current->Name );
        if (result == 0) {
            goto cleanup;
        } else if (result == 1) {
            break;
        }
        previous = current;
        current = current->Next;
    }

    // If we are not allowed to create it, exit at this point

    if (!Create) {
        current = NULL;
        goto cleanup;
    }

    // Create new entry

    new = (PTABLE_ENTRY) NEW_TYPE_ARRAY_ZERO( Table->EntrySize, CHAR );
    if (new == NULL) {
        current = NULL;
        goto cleanup;
    }

    // INITIALIZE TABLE ENTRY HERE

    length = wcslen( pCanonicalName ) + 1;  // in wchars inc terminator
    new->Name = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == new->Name) {
        FREE_TYPE(new);
        current = NULL;
        goto cleanup;
    }

    wcscpy( new->Name, pCanonicalName );

    // INITIALIZE TABLE ENTRY HERE

    new->Next = current;

    if (previous == NULL) {
        Table->Table[hash] = new;
    } else {
        previous->Next = new;
    }

    current = new;

cleanup:
    if (pCanonicalName) {
        FREE_TYPE(pCanonicalName);
    }
    return current;
} /* TableFindCreateEntry */


LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    )
/*++

Routine Description:

    Convert a DN into canonical form (see DsUnquoteRdnValueW for details).


    Various clients use different name forms resulting w/ misses when searched
    for in the hash table. For example, two name forms of interest are as follows:

    A) Backslash form (typically an ldap client will get this form)
        CN=site3\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites...

    B) Quoted form (typically core generated dsname format)
        CN="site3<0xA>CNF:d565bc93-293c-46d88831-69c345b30f7d",CN=Sites...

    To overcome this problem, all names are converted to the unquoted/unescaped
    form (we'll call it canonical) in this function.


Arguments:

    pDN - name to compute value for.

Return Value:

    success: name in canonical form.
    error: NULL.

Remarks:
    On success, returned name is allocated. Caller is responsible to
    free using FREE_TYPE().

--*/
{

    DWORD cDN, cKey, cVal, cRdn;
    LPCWCH pVal, pKey, pTmpDN = pDN;
    LPWCH pRdn = NULL;
    LPWCH pName = NULL, pCurName=NULL;
    DWORD err = ERROR_SUCCESS;
    DWORD len = 0, curlen = 0;


    // param sanity
    if (!pDN){
        // when would we ever try to hash an empty name?
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    //
    // Convert to canonical form:
    // a) calc required mem & alloc
    // b) cycle, apply DsUnquoteRdnValueW & copy
    //

    //
    // calc required memory
    //

    // first string length
    curlen = cDN = wcslen(pDN);
    if (!cDN) {
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    // now cycle rdns.
    while (cDN) {
        err = DsGetRdnW( &pTmpDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        if( ERROR_SUCCESS!=err ) {
            // An invalid DN would cause an infinite loop here so we
            // must bail out on error.
            DPRINT(1, "Error: invalid DN\n");
            return NULL;
        }
        len += cKey + cVal + 2;         // 2 addt'l for '=' & ','
    }

    // allocate memory (+ term char)
    pCurName = pName = NEW_TYPE_ARRAY_ZERO( len + 1, WCHAR );
    if (!pName) {
        DPRINT(1, "Error: not enough memory\n");
        return NULL;
    }

    // restore cDN (note that pDN wasn't touched, only pTmpDN)
    cDN = curlen;
    curlen = 0;


    while (cDN) {
        //
        // Cycle & re-create DN in unquoted form
        //

        err = DsGetRdnW( &pDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        if (err != ERROR_SUCCESS) {
            goto cleanup;
        }
        //
        // create formatted rdn
        //
        if (cKey) {
            // copy key (ie "CN" etc)
            wcsncpy(pCurName, pKey, cKey);
            curlen += cKey;
            // add '='
            pName[curlen++] = '=';
            pCurName = &pName[curlen];
        }
        if (cVal) {
            // copy value
            cRdn = len - curlen;
            err = DsUnquoteRdnValueW(cVal, pVal, &cRdn, pCurName);
            if (err) {
                goto cleanup;
            }
            Assert(cRdn);

            curlen += cRdn;
            pName[curlen++] = ',';
            pCurName = &pName[curlen];
        }
    }

    // terminate name excluding (overwriting) last ','
    Assert(curlen > 1 && pName[curlen-1] == ',');
    pName[curlen-1] = '\0';

    Assert(err == ERROR_SUCCESS);

cleanup:

    if (err) {
        if (pName) {
            FREE_TYPE(pName);
            pName = NULL;
        }
    }

    return pName;
}


/* end table.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\simlib\simism.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    simism.c

Abstract:

    Simulate the ISM connectivity APIs    

    This module is a wrapper around the ISM plug in common library.  It exposes
    the ISM APIs in a callable library.  Normally, you have to go through the
    ISM SERVICE to access this code.

Author:

    Will Lees (wlees) 22-Jul-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#define UNICODE 1

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>

#include "common.h"         // common transport library
#include <debug.h>
#define DEBSUB "SIMISM:"

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_SIMISM

// Memory block tags
// We have a problem with the memory allocation/deallocation model.
// Becuase this interface is normally remoted via RPCs, the expectation
// of the free routine is that all the memory returned is contigious.
// Use a Tag to determine what kind of block is being freed.

#define SIMISM_CONNECTIVITY 1
#define SIMISM_SERVER_LIST 2
#define SIMISM_SCHEDULE 3

typedef struct _TAGGED_BLOCK {
    DWORD BlockType;
    union {
        ISM_CONNECTIVITY Connectivity;
        ISM_SERVER_LIST ServerList;
        ISM_SCHEDULE Schedule;
    };
} TAGGED_BLOCK, *PTAGGED_BLOCK;

/* External */

/* Static */

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Fri Jul 23 10:13:39 1999 */

void
I_ISMInitialize(
    void
    );

void
I_ISMTerminate(
    void
    );

PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    );

PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    );

void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    );

void
deleteTransportList(
    void
    );

void
I_ISMFree(
    IN  VOID *  pv
    );

DWORD
I_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

DWORD
I_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   );

DWORD
I_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    );

/* End Forward */


void
SimI_ISMInitialize(
    void
    )

/*++

Routine Description:

This function is to be called before the other functions.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG
    DebugMemoryInitialize();
#endif
    InitializeListHead( &TransportListHead );
}


void
SimI_ISMTerminate(
    void
    )

/*++

Routine Description:

This function is to be called at the end.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
    deleteTransportList();
#if DBG
    DebugMemoryTerminate();
#endif
    if (!IsListEmpty( &TransportListHead )) {
        DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
    }

}


PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length, status;
    PTRANSPORT_INSTANCE instance = NULL;

    length = wcslen( pszTransportDN );
    if (length == 0) {
        return NULL;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        return NULL;
    }
    instance->Size = sizeof( TRANSPORT_INSTANCE );

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        return NULL;
    }
    wcscpy( instance->Name, pszTransportDN );

    InitializeCriticalSection( &(instance->Lock) );

    // ReplInterval is 0, meaning the application should take default
    instance->ReplInterval = 0;

    if (wcsstr( pszTransportDN, L"CN=SMTP" ) == pszTransportDN) {
        // SMTP transport
        // Default is schedules not significant, bridges not required (transitive)
        instance->Options = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
    } else {
        // non-SMTP transport
        // Default is schedules significant, bridges not required (transitive)
        instance->Options = 0;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Add to transport list
    InsertTailList( &TransportListHead, &(instance->ListEntry) );

    return instance;
cleanup:
    if (instance) {
        deleteTransport( instance );
    }
    return NULL;
}


PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PTRANSPORT_INSTANCE pTransport, pFound = NULL;

    for( entry = TransportListHead.Flink;
         entry != &(TransportListHead);
         entry = entry->Flink ) {
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );
        if (_wcsicmp( pszTransportDN, pTransport->Name ) == 0) {
            pFound = pTransport;
            break;
        }
    }

    return pFound;
}


void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    Assert( instance );

    // Release any routing state
    RouteFreeState( instance );

    DeleteCriticalSection( &(instance->Lock) );

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }
    instance->Size = 0; // clear signature to prevent reuse

    FREE_TYPE( instance );
}


void
deleteTransportList(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LIST_ENTRY *entry;
    PTRANSPORT_INSTANCE pTransport;

    while (!IsListEmpty(&TransportListHead)) {

        entry = RemoveHeadList( &TransportListHead );
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );

        deleteTransport( pTransport );

    }
}

void
SimI_ISMFree(
    IN  VOID *  pv
    )
/*++

Routine Description:

    Frees memory allocated on the behalf of the client by I_ISM* APIs.

Arguments:

    pv (IN) - Memory to free.

Return Values:

    None.

--*/
{
    PTAGGED_BLOCK pBlock;
    if (pv == NULL) {
        return;
    }

    pBlock = CONTAINING_RECORD( pv, TAGGED_BLOCK, Connectivity );
    switch (pBlock->BlockType) {
    case SIMISM_CONNECTIVITY:
    {
        TRANSPORT_INSTANCE dummyInstance;

        ISM_CONNECTIVITY *pConnectivity = &(pBlock->Connectivity);

        if (pConnectivity->cNumSites > 0) {
            DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

            RouteFreeLinkArray( &dummyInstance, pConnectivity->pLinkValues );
        }
        break;
    }
    case SIMISM_SERVER_LIST:
    {
        ISM_SERVER_LIST *pServerList = &(pBlock->ServerList);
        DWORD i;

        DirFreeSiteList( pServerList->cNumServers, pServerList->ppServerDNs );

        break;
    }
    case SIMISM_SCHEDULE:
    {
        ISM_SCHEDULE *pSchedule = &(pBlock->Schedule);
        Assert( pSchedule->cbSchedule != 0 );
        Assert( pSchedule->pbSchedule );

        FREE_TYPE( pSchedule->pbSchedule );

        pSchedule->pbSchedule = NULL;
        pSchedule->cbSchedule = 0;

        break;
    }
    default:
        Assert( FALSE );
    }

    FREE_TYPE( pBlock );
}


DWORD
SimI_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    DWORD status;
    DWORD numberSites, i;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppConnectivity) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppConnectivity = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Simulate the call

    // Get the site list and connectivity matrix

    status = RouteGetConnectivity( instance, &numberSites, &pSiteList,
                                   &pLinkArray, instance->Options,
                                   instance->ReplInterval );

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to get connectivity, error %d\n", status );
        goto cleanup;
    }

    // Return null structure to indicate no sites
    if (numberSites == 0) {
        ppConnectivity = NULL; // No connectivity
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( pLinkArray );
    Assert( pSiteList );

    // Build a connectivity structure to return

//    pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );

        // Cleanup the pieces
        DirFreeSiteList( numberSites, pSiteList );
        RouteFreeLinkArray( instance, pLinkArray );

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pBlock->BlockType = SIMISM_CONNECTIVITY;
    pConnectivity = &(pBlock->Connectivity);

    pConnectivity->cNumSites = numberSites;
    pConnectivity->ppSiteDNs = pSiteList;
    pConnectivity->pLinkValues = pLinkArray;
    *ppConnectivity = pConnectivity;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}

DWORD
SimI_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Get the server list

    status = DirGetSiteBridgeheadList( instance, instance->DirectoryConnection,
                                       pszSiteDN, &numberServers, &serverList );
    if (status != ERROR_SUCCESS) {

        if (status == ERROR_FILE_NOT_FOUND) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            goto cleanup;
        }

        DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
        return status;
    }

    // Return null structure to indicate no servers
    if (numberServers == 0) {
        *ppServerList = NULL; // All servers
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Construct the server structure

    // pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

        // Clean up the pieces
        for( i = 0; i < numberServers; i++ ) {
            FREE_TYPE( serverList[i] );
        }
        FREE_TYPE( serverList );

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    pBlock->BlockType = SIMISM_SERVER_LIST;
    pIsmServerList = &(pBlock->ServerList);

    pIsmServerList->cNumServers = numberServers;
    pIsmServerList->ppServerDNs = serverList;

    *ppServerList = pIsmServerList;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}


DWORD
SimI_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN1, pszSiteDN2 (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE instance = NULL;
    PBYTE pSchedule;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppSchedule) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppSchedule = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    status = RouteGetPathSchedule( instance,
                                   pszSiteDN1,
                                   pszSiteDN2,
                                   &pSchedule,
                                   &length );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
//        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        pBlock = NEW_TYPE( TAGGED_BLOCK );
        if (pBlock == NULL) {
            FREE_TYPE( pSchedule );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        pBlock->BlockType = SIMISM_SCHEDULE;
        *ppSchedule = &(pBlock->Schedule);
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

// ************************************************************

    status = ERROR_SUCCESS;

cleanup:

    return status;
}

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    // Caching is always supported in the simulator
    return TRUE;
}

/* end simism.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\common\simlib\simismt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simismt.c

ABSTRACT:

    Test utility for the Simulated Intersite Messaging service.

DETAILS:

CREATED:

    22 Jul 99   Will Lees

REVISION HISTORY:

--*/

#include <ntdspch.h>
#if SIMISM
#define I_ISMGetConnectivity SimI_ISMGetConnectivity
#define I_ISMGetConnectionSchedule SimI_ISMGetConnectionSchedule
#define I_ISMFree SimI_ISMFree
#endif
#include <ismapi.h>

#include <schedule.h>
#include <debug.h>
#include "common.h"

#include <fileno.h>
#define FILENO FILENO_ISMSERV_SIMISMT

// Extern
// Need to find a header file for these
void
SimI_ISMInitialize(
    void
    );
void
SimI_ISMTerminate(
    void
    );

int
__cdecl
wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i, j;
    ISM_CONNECTIVITY *pConnectivity = NULL;
    LPSTR rgpszDebugParams[] = {"simism.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
    ISM_SCHEDULE *pSchedule = NULL;

    DEBUGINIT(cNumDebugParams, rgpszDebugParams, "simismt");

    printf( "hello world\n" );

#if DBG
// This stuff forces the debugging spew in the simism library to come out on
// your kernel debugger. You probably won't need this...
//        DebugInfo.severity = 1;
//        strcpy( DebugInfo.DebSubSystems, "ISMIP:IPDGRPC:" ); 
        DebugInfo.severity = 3;
        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif

    printf( "I_ISMInitialize\n" );
    SimI_ISMInitialize();

// *************************************

    printf( "I_ISMGetConnectivity\n" );
    status = I_ISMGetConnectivity( L"CN=IP", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    status = I_ISMGetConnectionSchedule( L"CN=IP",
                                         pConnectivity->ppSiteDNs[0],
                                         pConnectivity->ppSiteDNs[1],
                                         &pSchedule );
    if (pSchedule) {
        printf( "Returned non-null schedule = 0x%p\n", pSchedule );
        I_ISMFree( pSchedule );
    } else {
        printf( "Returned schedule = NULL\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

    pConnectivity = NULL;

// *************************************

    printf( "I_ISMGetConnectivity, second time, cached results\n" );
    status = I_ISMGetConnectivity( L"CN=IP", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

// *************************************

    printf( "I_ISMGetConnectivity(SMTP)\n" );
    status = I_ISMGetConnectivity( L"CN=SMTP,blah", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    status = I_ISMGetConnectionSchedule( L"CN=SMTP,blah",
                                         pConnectivity->ppSiteDNs[0],
                                         pConnectivity->ppSiteDNs[1],
                                         &pSchedule );
    if (pSchedule) {
        printf( "Returned non-null schedule = 0x%p\n", pSchedule );
        I_ISMFree( pSchedule );
    } else {
        printf( "Returned schedule = NULL\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

    pConnectivity = NULL;

// *************************************

    printf( "I_ISMTerminate\n" );
    SimI_ISMTerminate();

    DEBUGTERM();

    return 0;
}

//**************************************************************************************
// Aaron - these are the routines that you need to simulate
//**************************************************************************************


DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

This routine allows the directory provider to fill in the instance with
transport object specific information.  The name transport object should
be looked up to make sure it exists.  If it does, the "replInterval" and
"options" attributes should be read and populated into the fields
in the transport instance.

Note that the transport instance is already initialized. Only update it
if you have something to override.

Arguments:

    ConnectionHandle - Ignored
    pTransport - Contains useful information in and out
       in: Name - name of transport
       out: ReplInterval - transport specific replInterval to apply
            Options - transport specific options to apply

Return Value:

    DWORD - 

--*/

{
    printf( "DirReadTransport, name = %ws\n", pTransport->Name );

    // Look up name of transport and make sure it exists
    // Look up "replInterval" on transport object and return if non-zero
    // Loop up options on transport object and return if non-zero

    return ERROR_SUCCESS;
} /* DirReadTransport */

//**************************************************************************************
// These routines deal with an array of pointers to strings for the sites
//**************************************************************************************

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    )

/*++

Routine Description:

Free the site list returned by DirGetSiteList.
Also frees the server list returned by DirGetSiteBridgeheadList
Use the matching deallocator that you use for the allocator.

Note that this routine should be defensive and free partially constructed
structures.

Arguments:

    NumberSites - 
    pSiteList - 

Return Value:

    None

--*/

{
    DWORD i;
    printf( "DirFreeSiteList\n" );

    if ( (NumberSites == 0) || (pSiteList == NULL) ) {
        return;
    }
    for( i = 0; i < NumberSites; i++ ) {
        if (pSiteList[i] != NULL) {
            free( pSiteList[i] );
            pSiteList[i] = NULL;
        }
    }
    free( pSiteList );
} /* DirFreeSiteList */

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

Make a copy of a site list.  A site list is a array of pointers to strings.

Use the same allocator as DirGetSiteList.

Arguments:

    NumberSites - 
    pSiteList - 
    ppSiteList - 

Return Value:

    None

--*/

{
    DWORD i;
    LPWSTR *pStringList = NULL;

    printf( "DirCopySiteList\n" );

    if ( (NumberSites == 0) || (pSiteList == NULL) ) {
        *ppSiteList = NULL;
        return;
    }

    pStringList = (LPWSTR *) malloc( NumberSites * sizeof( LPWSTR ) );
    if (pStringList == NULL) {
        *ppSiteList = NULL;
        return;
    }
    ZeroMemory( pStringList, NumberSites * sizeof( LPWSTR ) );

    for( i = 0; i < NumberSites; i++ ) {
        pStringList[i] = malloc( (wcslen( pSiteList[i] ) + 1) * sizeof( WCHAR ) );
        if (pStringList[i] == NULL) {
            goto cleanup;
        }
        wcscpy( pStringList[i], pSiteList[i] );
    }

    *ppSiteList = pStringList;

    return;
cleanup:
    if (pStringList) {
        DirFreeSiteList( NumberSites, pStringList );
    }
    // Must null out parameters on error because no error code returned
    *ppSiteList = NULL;

} /* DirCopySiteList */

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

Return the list of sites as an array of pointers to wide strings.

To get the list of sites, do a one-level search of the sites container,
looking for objects of type site.

If any of the allocations should fail, any internal allocations should
be cleaned up, and NULL should be returned.

Arguments:

    ConnectionHandle - 
    pNumberSites - 
    ppSiteList - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, numberSites;
    LPWSTR pszSite1 = L"CN=Site One";
    LPWSTR pszSite2 = L"CN=Site Two";
    LPWSTR pszSite3 = L"CN=Site Three";
    LPWSTR *pStringList = NULL;

    printf( "DirGetSiteList\n" );

    numberSites = 3;
    pStringList = (LPWSTR *) malloc( 3 * sizeof( LPWSTR ) );
    if (pStringList == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pStringList, 3 * sizeof( LPWSTR ) );

    pStringList[0] = malloc( (wcslen( pszSite1 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[0] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[0], pszSite1 );

    pStringList[1] = malloc( (wcslen( pszSite2 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[1] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[1], pszSite2 );

    pStringList[2] = malloc( (wcslen( pszSite3 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[2] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[2], pszSite3 );

    // Return out parameters

    *ppSiteList = pStringList;
    *pNumberSites = numberSites;
    pStringList = NULL; // don't clean up

    status = ERROR_SUCCESS;
cleanup:
    if (pStringList) {
        DirFreeSiteList( numberSites, pStringList );
    }

    // No need to null out parameters on error, because error code is returned

    return status;
} /* DirGetSiteList */

//**************************************************************************************
// These routines return the site links and bridges
//**************************************************************************************


void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    )

/*++

Routine Description:

This routine cleans up an iteration context allocated by the following routines.

Arguments:

    pIterationContextHandle - pointer to a PVOID. The PVOID contains a pointer to
         whatever context you need to implement the iteration functions

Return Value:

    None

--*/

{
    LPDWORD pContext;

    printf( "DirTerminateIteration\n" );

    if (pIterateContextHandle == NULL) {
        return;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    if (pContext != NULL) {
        // Context is present, deallocate
        *pContext = 0;
        free( pContext );
        *pIterateContextHandle = NULL;
    }
}

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    )

/*++

Routine Description:

This routine returns name name of each site link, one at a time.

This routine is structured as an "iterator", where the caller calls us
successively until no more items are returned.  The caller provides us
with a pointer to a PVOID in which we can keep whatever we need
to keep track of where we are.  The caller agrees to call us with NULL
in the PVOID at the start of the iteration.

The site links are stored below the transport object.  Do a one-level search
below the transport object for objects of type "siteLink".

SiteLinkName must be allocated by the caller to be MAX_REG_COMPONENT length

Arguments:

    pTransport - Context for the transport. Various transport-wide defaults are
        here. You can get the name.
    ConnectionHandle - Ignored.
    pIterateContextHandle - A pointer to a pointer, which this routine uses to store
        a pointer to a block of storage we use to keep track of where we are.
        In this sample, we use only a DWORD for a count, but you can keep whatever
        you want.
    SiteLinkName - Pointer to a fixed string allocated by the caller.

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    LPDWORD pContext;
    LPWSTR dn;

    printf( "DirIterateSiteLinks, transport = %ws\n", pTransport->Name );

    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    // Allocate the context if this is the first time
    if (pContext == NULL) {
        // First time, new context required
        pContext = (LPDWORD) malloc( sizeof( DWORD ) );
        if (pContext == NULL) {
            *pIterateContextHandle = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIterateContextHandle = pContext;
        if (wcsstr( pTransport->Name, L"CN=SMTP") != NULL) {
            *pContext = 4;
        } else {
            *pContext = 0;
        }
    }

    switch (*pContext) {
    case 0:
        dn = L"CN=Site Link One";
        break;
    case 1:
        dn = L"CN=Site Link Two";
        break;
    case 2:
        dn = L"CN=Site Link Three";
        break;
    case 3:
        return ERROR_NO_MORE_ITEMS;
    case 4:
        dn = L"CN=Site Link Four";
        break;
    default:
        return ERROR_NO_MORE_ITEMS;
    }

    // Call allocates the storage, we copy into it
    wcsncpy( SiteLinkName, dn, MAX_REG_COMPONENT );
    SiteLinkName[MAX_REG_COMPONENT - 1] = L'\0';

    // Advance context for next iteration
    (*pContext)++;

    return ERROR_SUCCESS;;

} /* DirIterateSiteLinks */


void
DirFreeMultiszString(
    LPWSTR MultiszString
    )

/*++

Routine Description:

Free the storage for the multisz out parameters return from 
DirReadSiteLink and DirReadSiteLinkBridge

This deallocator must match the allocator used by DirRead functions.

Arguments:

    MultiszString - String to be freed.

Return Value:

    None

--*/

{
    free( MultiszString );
} /* DirFreeMultiszString */


void
DirFreeSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

Free the storage for the schedule returned from the
DirReadSiteLink routine

This deallocator must match the allocator used by DirRead functions.

Arguments:

    pSchedule - 

Return Value:

    None

--*/

{
    free( pSchedule );
} /* DirFreeSchedule */

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    )

/*++

Routine Description:

Return the attributes of the named site link.  The attributes are stored
on the object and returned in the directory.

The attributes are:
#define ATT_SL L"siteList"
#define ATT_COST L"cost"
#define ATT_RI L"replInterval"
#define ATT_OP L"options"
#define ATT_SCHED L"schedule"

Arguments:

    pTransport - 
    ConnectionHandle - 
    SiteLinkName - 
    pSiteList - pointer to a multisz string, we allocate
        Note that allocator must match deallocator in DirFreeMultiszString
    pLinkValue - pointer to an ISM_LINK, caller allocates
    ppSchedule - pointer to a blob, we allocate
        Note that allocator must match deallocator in DirFreeSchedule

Return Value:

    DWORD - 

--*/

{
    DWORD length;
// Calculating the size of these is a little tricky since the string
// has embedded NULL's
#define MULTISZ1 L"CN=Site One\0"
#define MULTISZ3 L"CN=Site Two\0CN=Site Three\0"
#define MULTISZ4 L"CN=Site One\0CN=Site Three\0"
    LPWSTR pszSiteList1 = MULTISZ1;
    LPWSTR pszSiteList3 = MULTISZ3;
    LPWSTR pszSiteList4 = MULTISZ4;

    printf( "DirReadSiteLink, transport = %ws, SiteLinkName = %ws\n",
            pTransport->Name, SiteLinkName );

    if (_wcsicmp( SiteLinkName, L"CN=Site Link One") == 0) {
        length = (sizeof MULTISZ1) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList1, length );

        pLinkValue->ulCost = 100;
        pLinkValue->ulReplicationInterval = 15;
        pLinkValue->ulOptions = 0;

        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Two") == 0) {
        *pSiteList = NULL;
        pLinkValue->ulCost = 200;
        pLinkValue->ulReplicationInterval = 30;
        pLinkValue->ulOptions = 0;

        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Three") == 0) {
        length = (sizeof MULTISZ3) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList3, length );

        pLinkValue->ulCost = 300;
        pLinkValue->ulReplicationInterval = 45;
        pLinkValue->ulOptions = 0;
        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Four") == 0) {
        length = (sizeof MULTISZ4) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList4, length );

        pLinkValue->ulCost = 400;
        pLinkValue->ulReplicationInterval = 60;
        pLinkValue->ulOptions = 0;
        ppSchedule = NULL;
    } else {
        Assert( FALSE );
    }

    return ERROR_SUCCESS;
} /* DirReadSiteLink */

//**************************************************************************************
// The remaining routines must be stubbed out, but are not called by default
//**************************************************************************************

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    )

/*++

Routine Description:

Return each site link bridge one at a time.

NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! 

Not used by default. Only when "bridges required option" turned on.
Aaron, implement this last.

Arguments:

    pTransport - 
    ConnectionHandle - 
    pIterateContextHandle - 
    SiteLinkBridgeName - 

Return Value:

    DWORD - 

--*/

{
#if 0
    DWORD status;
    LPDWORD pContext;
    LPWSTR dn;

    printf( "DirIterateSiteLinkBridges, transport = %ws\n", pTransport->Name );

    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    if (pContext == NULL) {
        // First time, new context required
        pContext = (LPDWORD) malloc( sizeof( DWORD ) );
        if (pContext == NULL) {
            *pIterateContextHandle = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIterateContextHandle = pContext;
        *pContext = 0;
    }

    status = ERROR_SUCCESS;

    switch (*pContext) {
    case 0:
        dn = L"Site Bridge One";
        break;
    case 1:
        dn = L"Site Bridge Two";
        break;
    case 2:
        dn = L"Site Bridge Three";
        break;
    default:
        status = ERROR_NO_MORE_ITEMS;
        break;
    }

    // Call allocates the storage, we copy into it
    wcsncpy( SiteLinkBridgeName, dn, MAX_REG_COMPONENT );
    SiteLinkBridgeName[MAX_REG_COMPONENT - 1] = L'\0';

    // Advance context for next iteration
    (*pContext)++;

    return status;
#endif
    return ERROR_INVALID_PARAMETER;
} /* DirIterateSiteLinkBridges */


DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    )

/*++

Routine Description:

NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! 

Return information on the named site link bridge

Site link bridges are only when read the transport option is set such that
bridges are required. This is not the default. Thus this routine is never
called unless specifically requested by the user.  

Arguments:

    pTransport - 
    ConnectionHandle - 
    SiteLinkBridgeName - 
    pSiteLinkList - 

Return Value:

    DWORD - 

--*/

{
    printf( "DirReadSiteLinkBridge, transport = %ws, SiteLinkBridgeName = %ws\n",
            pTransport->Name, SiteLinkBridgeName );

    // Aaron, you can fill this in at the end if you have time

    return ERROR_INVALID_PARAMETER;

} /* DirReadSiteLinkBridge */

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    printf( "DirGetSiteBridgeheadList\n" );

    if ( (SiteDN == NULL) || (*SiteDN == L'\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Should validate that the site is valid

    // This is the result if there are no explicit bridgeheads in the site

    *pNumberServers = 0;
    *ppServerList = NULL;
    status = ERROR_SUCCESS;

    // If there were explicit bridgheads, the would be returend as a
    // array of pointers to strings.

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\ip\ismip.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ismip.c

Abstract:

   This module is a plug-in DLL for the Inter-Site Messaging service, which is part of
   the mail-based replication subsystem in the Directory Service.

   This DLL, as is any instance of the ISM plug-in DLL class, provides a set of abstract
   transport functions, such as send, receive, and so on.  See plugin.h for details.

   This implementation is based on sockets, using the TCP protocol.  This is used for testing.
   A true implementation would not require the server to be up at the time of send.

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    User-mode, win32 dll
    To be loaded by another image

Notes:

    optional-notes

Revision History:


--*/

#define UNICODE 1

#include <ntdspch.h>

#include <rpc.h>
#include <rpcndr.h>   // midl_user_free
#include <ismapi.h>
#include <debug.h>
#include <fileno.h>
#include <drs.h>     // DSTIME
#include <ntdsa.h>   // Option flags

// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include <dsevent.h>

#include "private.h"

// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

#define DEBSUB "ISMIP:"
#define FILENO FILENO_ISMSERV_ISMIP

// Set this non-zero to display debug messages
#define UNIT_TEST_DEBUG 0

/* External */

// Event logging config (as exported from ismserv.exe).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

/* Static */

// Lock on instances list
CRITICAL_SECTION TransportListLock;

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Nov 04 09:54:07 1998 */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     );

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    );

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    );

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    );

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    );

void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    );

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    );

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    );

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    );

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    );

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    );

/* End Forward */


DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    )

/*++

Routine Description:

Wrapper function to handle exception handling in the
InitializeCriticalSection() function.

Arguments:

    pcsCriticalSection - pointer to critical section

Return Value:

    DWORD - status code

--*/

{
    DWORD status;

    __try {
        InitializeCriticalSection( pcsCriticalSection );
        status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    return status;
} /* initializeCriticalSectionHelper */

WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    DWORD status;
    BOOL  fReturn = TRUE;
    LPSTR rgpszDebugParams[] = {"lsass.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {
        // DO QUICK STUFF HERE - DO THE REST IN STARTUP/FIRSTTIME

        // Debug library is already initialized in dll, ismserv.exe,
        // where the library is exported from.

        // Get event logging config (as exported from ismserv.exe).
        gpDsEventConfig = DsGetEventConfig();

#if DBG
#if UNIT_TEST_DEBUG
        DebugInfo.severity = 1;
        strcpy( DebugInfo.DebSubSystems, "ISMIP:IPDGRPC:" ); 
//        DebugInfo.severity = 3;
//        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif
        DebugMemoryInitialize();
#endif
        
        if (ERROR_SUCCESS != InitializeCriticalSectionHelper( &TransportListLock )) {
            fReturn = FALSE;
            goto exit;
        }
        InitializeListHead( &TransportListHead );
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // Make sure all threads stopped
        // Empty address list
        DeleteCriticalSection( &TransportListLock );
        if (!IsListEmpty( &TransportListHead )) {
            DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
        }
#if DBG
        DebugMemoryTerminate();
#endif

        // Debug library is terminated in dll, ismserv.exe,
        // where the library is exported from.

        break;
    }
    default:
        break;
    }   /* switch */

exit:
    return ( fReturn);
}  /* DllLibMain() */

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    )
/*++

Routine Description:

    Initialize the plug-in.

Arguments:

    pszTransportDN (IN) - The DN of the Inter-Site-Transport that named this
        DLL as its plug-in.  The DS object may contain additional configuration
        information for the transport (e.g., the name of an SMTP server for
        an SMTP transport).

    pNotifyFunction (IN) - Function to call to notify the ISM service of pending
        messages.

    hNotify (IN) - Parameter to supply to the notify function.

    phIsm (OUT) - On successful return, holds a handle to be used in
        future calls to the plug-in for the named Inter-Site-Transport.  Note
        that it is possible for more than one Inter-Site-Transport object to
        name a given DLL as its plug-in, in which case IsmStartup() will be
        called for each such object.

Return Values:

    NO_ERROR - Successfully initialized.

    other - Failure.
        
--*/
{
    DWORD length;
    PTRANSPORT_INSTANCE instance;
    DWORD status;
    BOOLEAN firsttime;
    BOOLEAN fNotifyInit = FALSE;

    DPRINT1( 1, "IsmStartup, transport='%ws'\n", pszTransportDN );

    // Check validity of arguments

    if (phIsm == NULL) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    length = wcslen( pszTransportDN );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Restrict to only one transport instance.
    EnterCriticalSection(&TransportListLock);
    __try {
        firsttime = IsListEmpty( &(TransportListHead) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }
    if (!firsttime) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        return status;
    }

    // INITIALIZE TRANSPORT INSTANCE HERE
    // All values initially zero

    instance->Size = sizeof( TRANSPORT_INSTANCE );
    Assert( instance->ReferenceCount == 0 );
    instance->pNotifyFunction = pNotifyFunction;
    instance->hNotify = hNotify;
    InitializeListHead( &(instance->ServiceListHead) );
    status = InitializeCriticalSectionHelper( &(instance->Lock) );
    if (ERROR_SUCCESS != status) {
        goto cleanup;
    }
    // ReplInterval is 0, meaning the application should take default
    // Default is schedules significant, bridges not required (transitive)
    instance->Options = 0;

    // INITIALIZE TRANSPORT INSTANCE HERE

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }
    wcscpy( instance->Name, pszTransportDN );

    // ***********************************************************************

    // Create event to signal shutdown.
    instance->hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == instance->hShutdownEvent) {
        status = GetLastError();
        DPRINT1(0, "Failed to create shutdown event, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    // Open connection to directory service
    status = DirOpenConnection( &instance->DirectoryConnection );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Start monitoring for routing changes
    status = DirStartNotifyThread( instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }
    fNotifyInit = TRUE;

    // Insert this instance into the list.
    
    // Note that, assuming the ISM service is functioning correctly, this list
    // cannot contain duplicates (where "duplicate" is defined as an entry with
    // the same DN).
    
    EnterCriticalSection(&TransportListLock);
    __try {
        InsertTailList( &TransportListHead, &(instance->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    InterlockedIncrement( &(instance->ReferenceCount) );  // 1 for the lifetime of this transport

    *phIsm = instance;

    return ERROR_SUCCESS;

cleanup:
    instance->fShutdownInProgress = TRUE;

    if (fNotifyInit) {
        (void) DirEndNotifyThread( instance );
    }

    if (instance->DirectoryConnection) {
        (void) DirCloseConnection( instance->DirectoryConnection );
    }

    if (instance->hShutdownEvent != NULL) {
        CloseHandle( instance->hShutdownEvent );
    }

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }

    Assert( instance->ReferenceCount == 0 );
    FREE_TYPE(instance);

    return status;
}

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    )
/*++

Routine Description:

    Called whenever changes occur to the Inter-Site-Transport object specified
    in the IsmStartup() call.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    eReason (IN) - Reason code for refresh

    pszObjectDN (IN) - DN of the Inter-Site-Transport object.  This is
        guaranteed to be the same as the DN passed in IsmStartup, as inter-site
        transport objects cannot be renamed.

Return Values:

    0 or Win32 error code.
    
--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status, oldOptions, oldReplInterval;

    DPRINT2( 1, "IsmRefresh, reason = %d, new name = %ws\n",
             eReason,
             pszObjectDN ? pszObjectDN : L"not supplied" );

    if (instance->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (eReason == ISM_REFRESH_REASON_RESERVED) ||
         (eReason >= ISM_REFRESH_REASON_MAX) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // If a site changed in any way, just invalidate the cache

    if (eReason == ISM_REFRESH_REASON_SITE) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( eReason == ISM_REFRESH_REASON_TRANSPORT );

    // Inter-site transport objects cannot be renamed.
    Assert((pszObjectDN == NULL)
           || (0 == _wcsicmp(pszObjectDN, instance->Name)));

    oldOptions = instance->Options;
    oldReplInterval = instance->ReplInterval;

    // Reread parameters from the registry 
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( ( oldOptions != instance->Options) ||
         ( oldReplInterval != instance->ReplInterval ) ) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
    }

cleanup:

    return status;
}

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    )
/*++

Routine Description:

    Uninitialize transport plug-in.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().
    eReason (IN) - Reason for shutdown

Return Values:

    None.

--*/
{
    DWORD status;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    BOOL fFailed;
    LONG count;

    DPRINT2( 1, "IsmShutdown %ws, Reason %d\n", transport->Name, eReason );

    // Validate
    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        return;
    }
    transport->fShutdownInProgress = TRUE;

    SetEvent(transport->hShutdownEvent);

    // Remove this instance from the list.
    EnterCriticalSection(&TransportListLock);
    __try {
        RemoveEntryList( &(transport->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    DeleteCriticalSection( &(transport->Lock) );

    DirEndNotifyThread( transport );

    count = InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for the lifetime of this transport
    if (count == 0) {
        // Clean up only if thread is finished

        // Release any routing state
        RouteFreeState( transport );

        // Close connection to directory
        status = DirCloseConnection( transport->DirectoryConnection );
        // ignore error

        CloseHandle( transport->hShutdownEvent );
        transport->hShutdownEvent = NULL;

        // RUNDOWN TRANSPORT INSTANCE HERE

        transport->Size = 0; // clear signature to prevent reuse
        FREE_TYPE( transport->Name );
        FREE_TYPE( transport );

        // RUNDOWN TRANSPORT INSTANCE HERE
    } else {
        DPRINT2( 0, "Transport %ws not completely shutdown, %d references still exist.\n",
                 transport->Name, count );
    }
}

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Send a message over this transport.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszRemoteTransportAddress (IN) - Transport address of the destination
        server.

    pszServiceName (IN) - Name of the service on the remote machine that is the
        intended receiver of the message.

Return Values:

    0 or Win32 error.

--*/
{
    // The IP transport does not support send/receive.
    return ERROR_NOT_SUPPORTED;
}

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Return the next waiting message (if any).  If no message is waiting, a NULL
    message is returned.  If a non-NULL message is returned, the ISM service
    is responsible for calling IsmFreeMsg(*ppMsg) when the message is no longer
    needed.

    If a non-NULL message is returned, it is immediately dequeued.  (I.e., once
    a message is returned through IsmReceive(), the transport is free to destroy
    it.)

This routine is pretty simple.  It finds the service, and dequeues a message if there is any.
Queue the message is done by the listener thread behind the scenes.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    0 or Win32 error.

--*/
{
    // The IP transport does not support send/receive.
    // Return "no message waiting."
    *ppMsg = NULL;
    return 0;
}


void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Frees a message returned by IsmReceive().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pMsg (IN) - Message to free.

Return Values:

    None.

--*/
{
    // The IP transport does not support send/receive.
    ;
}

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites.

    On successful return, the ISM service will eventually call
    IsmFreeConnectivity(hIsm, *ppConnectivity);

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

There is no time-based caching of this information.  Each time this routine is called, the
information is regnerated.  GetConnectionSchedule api uses the matrix of schedules from the
last time this call was made, regardless of time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along this transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, numberSites, i;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;

    DPRINT( 2, "IsmGetConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }


    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {

        // Get the site list and connectivity matrix

        status = RouteGetConnectivity( transport, &numberSites, &pSiteList,
                                       &pLinkArray, transport->Options,
                                       transport->ReplInterval );

        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "failed to get connectivity, error %d\n", status );
            __leave;
        }

        // Return null structure to indicate no sites
        if (numberSites == 0) {
            ppConnectivity = NULL; // No connectivity
            status = ERROR_SUCCESS;
            __leave;
        }

        Assert( pLinkArray );
        Assert( pSiteList );

        // Build a connectivity structure to return

        pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
        if (pConnectivity == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );

            // Cleanup the pieces
            DirFreeSiteList( numberSites, pSiteList );
            RouteFreeLinkArray( transport, pLinkArray );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pConnectivity->cNumSites = numberSites;
        pConnectivity->ppSiteDNs = pSiteList;
        pConnectivity->pLinkValues = pLinkArray;
        *ppConnectivity = pConnectivity;

        status = ERROR_SUCCESS;
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    return status;
}

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    )
/*++

Routine Description:

    Frees the structure returned by IsmGetConnectivity().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSiteConnectivity (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    DPRINT( 2, "IsmFreeConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pConnectivity == NULL) {
        return;
    }

    // Free individual components

    if (pConnectivity->cNumSites > 0) {
        DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

        RouteFreeLinkArray( transport, pConnectivity->pLinkValues );
    }

    FREE_TYPE( pConnectivity );
}

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via this transport.

    On successful return of a non-NULL list, the ISM service will eventually call
    IsmFreeTransportServers(hIsm, *ppServerList);

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;

    DPRINT1( 2, "IsmGetTransportServers, site = %ws\n", pszSiteDN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Get the server list

        status = DirGetSiteBridgeheadList( transport, transport->DirectoryConnection,
                                           pszSiteDN, &numberServers, &serverList );
        if (status != ERROR_SUCCESS) {

            if (status == ERROR_FILE_NOT_FOUND) {
                *ppServerList = NULL; // All servers
                status = ERROR_SUCCESS;
                __leave;
            }

            DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
            __leave;
        }

        // Return null structure to indicate no servers
        if (numberServers == 0) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            __leave;
        }

        // Construct the server structure

        pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
        if (pIsmServerList == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

            // Clean up the pieces
            for( i = 0; i < numberServers; i++ ) {
                FREE_TYPE( serverList[i] );
            }
            FREE_TYPE( serverList );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pIsmServerList->cNumServers = numberServers;
        pIsmServerList->ppServerDNs = serverList;

        *ppServerList = pIsmServerList;

        status = ERROR_SUCCESS;
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    return status;
}

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pServerList (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    DPRINT( 2, "IsmFreeTransportServers\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pServerList == NULL) {
        return;
    }

    // Free individual components

    if ( (pServerList->cNumServers != 0) && (pServerList->ppServerDNs != NULL) ) {
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            FREE_TYPE( pServerList->ppServerDNs[i] );
        }
        FREE_TYPE( pServerList->ppServerDNs );
    }

    FREE_TYPE( pServerList );
}

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    )

/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via this
    transport.

    On successful return, it is the ISM service's responsibility to eventually
    call IsmFreeSchedule(*ppSchedule);

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

There is no time-based caching of this information.  Each time the get conn routine is called, the
information is regnerated.  GetConnectionSchedule api uses the matrix of schedules from the
last time this call was made, regardless of time.

The actual semantics of this routine are that it returns a non-default schedule
if there is one.  Otherwise, it returns the default, all available schedule.
If you desire to know if there is a path between the two sites, consult the
cost matrix first. It is a feature of this routine that inquiring a schedule
for a non-connected pair of sites will return NULL for all available.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PBYTE pSchedule;

    DPRINT2( 2, "IsmGetConnectionSchedule, site1 = %ws, site2 = %ws\n",
            pszSite1DN, pszSite2DN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    status = RouteGetPathSchedule( transport,
                                   pszSite1DN,
                                   pszSite2DN,
                                   &pSchedule,
                                   &length );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        if (*ppSchedule == NULL) {
            FREE_TYPE( pSchedule );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

    return ERROR_SUCCESS;
}

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSchedule (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    DPRINT( 2, "IsmFreeConnectionSchedule\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pSchedule == NULL) {
        return;
    }

    Assert( pSchedule->cbSchedule != 0 );
    Assert( pSchedule->pbSchedule );

    FREE_TYPE( pSchedule->pbSchedule );

    pSchedule->pbSchedule = NULL;
    pSchedule->cbSchedule = 0;

    FREE_TYPE( pSchedule );
}


DWORD
IsmQuerySitesByCost(
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszFromSite,
    IN  DWORD                       cToSites,
    IN  LPCWSTR*                    rgszToSites,
    IN  DWORD                       dwFlags,
    OUT ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo
    )
/*++

Routine Description:

    Determine the individual costs between the From site and the To sites.

Arguments:

    pszFromSite (IN) - The name (not distinguished) of the From site.

    rgszToSites (IN) - An array containing the names of the To sites.

    cToSites (IN) - The number of entries in the rgszToSites array.

    dwFlags (IN) - Unused.

    prgSiteInfo (IN) - On successful return, holds a pointer to a structure
        containing the costs between the From site and the To sites.
    
Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status;

    DPRINT2( 2, "IsmQuerySitesByCost (FromSite=%ls, cToSites=%d)\n",
        pszFromSite, cToSites );

    // Validate
    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {

        status = RouteQuerySitesByCost( transport, pszFromSite,
                    cToSites, rgszToSites, dwFlags, prgSiteInfo );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "Failed to get query sites, error %d\n", status );
            __leave;
        } else {
            DPRINT( 2, "RouteQuerySitesByCost succeeded\n" );
        }

    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    return status;
}


VOID
IsmFreeSiteCostInfo(
    IN  HANDLE                     hIsm,
    IN  ISM_SITE_COST_INFO_ARRAY  *rgSiteCostInfo
    )
/*++

Routine Description:

    Frees the structure returned by ISM_QUERY_SITES_BY_COST().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    rgSiteCostInfo (IN) - Structure to free.

Return Values:

    None.

--*/
{
    DPRINT( 2, "IsmFreeSiteCostInfo\n" );
    RouteFreeSiteCostInfo( rgSiteCostInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\ip\private.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    private.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _PRIVATE_
#define _PRIVATE_

#include "common.h"         // common transport library

// This is a server-side structure describing a message recipient.  There is
// one of these instances for each unique service which as received a message.

typedef struct _SERVICE_INSTANCE {
    DWORD Size;
    LPWSTR Name;
    DWORD ByteCount;
    DWORD MessageCount;
    CRITICAL_SECTION Lock;
    LIST_ENTRY MessageListHead;
    LIST_ENTRY ServiceListEntry;
} SERVICE_INSTANCE, *PSERVICE_INSTANCE;

// This is a message descriptor.  It is to allow us to keep track of the
// queue of messages.  It points to the actual message which is allocated
// by rpc.

typedef struct _MESSAGE_INSTANCE {
    DWORD Size;
    LIST_ENTRY ListEntry;
    PISM_MSG pIsmMsg;
} MESSAGE_INSTANCE, *PMESSAGE_INSTANCE;

// Limit on number of queued messages per service

#define MESSAGES_QUEUED_PER_SERVICE 16

// Limit on total number of bytes queued

#define BYTES_QUEUED_PER_SERVICE (1024 * 1024)

// Registry parameter to overide to default endpoint
#define IP_SERVER_ENDPOINT "ISM IP Transport Endpoint"
#define HTTP_SERVER_ENDPOINT "ISM HTTP Transport Endpoint"

// RPC protocol sequences

#define HTTP_PROTOCOL_SEQUENCE L"ncacn_http"
#define UDP_PROTOCOL_SEQUENCE L"ncadg_ip_udp"
#define TCP_PROTOCOL_SEQUENCE L"ncacn_ip_tcp"

// Register parameter for options
#define HTTP_OPTIONS L"ISM HTTP Transport Options"

// Size cutoff of when to switch from udp to tcp

#define TCP_PROTOCOL_SWITCH_OVER (16 * 1024)

// External (see data.c)

// Lock on services list
extern CRITICAL_SECTION ServiceListLock;

// ismip.c

DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    );

PTRANSPORT_INSTANCE
IpLookupTransport(
    LPCWSTR TransportName
    );

// dgrpc.c

DWORD
IpRegisterRpc(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
IpUnregisterRpc(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
IpSend(
    PTRANSPORT_INSTANCE pTransport,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IpFindCreateService(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR ServiceName,
    BOOLEAN Create,
    PSERVICE_INSTANCE *pService
    );

PISM_MSG
IpDequeueMessage(
    PSERVICE_INSTANCE Service
    );

VOID
IpRundownServiceList(
    HANDLE hIsm
    );

#endif /* _PRIVATE_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\ismsmtp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismsmtp.h

ABSTRACT:

DETAILS:

CREATED:

    3/20/98     Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntrtl.h>            // Generic table

#ifdef __cplusplus
extern "C" {
#endif

extern CRITICAL_SECTION DropDirectoryLock;
extern CRITICAL_SECTION QueueDirectoryLock;

// Don't support messages bigger than a megabyte.
#define MAX_DATA_SIZE (1024 * 1024)

// xmitrecv.cxx

HRESULT
SmtpInitialize(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

HRESULT
SmtpTerminate(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fRemoval
    );

unsigned __stdcall
SmtpRegistryNotifyThread(
    IN  HANDLE        hIsm
    );

DWORD
SmtpSend(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
SmtpReceive(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    );

VOID
SmtpFreeMessage(
    IN ISM_MSG *              pMsg
    );










// table.c

DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

// Service descriptor

typedef struct _SERVICE_INSTANCE {
    LIST_ENTRY_INSTANCE ListEntryInstance;
    RTL_GENERIC_TABLE TargetTable;
} SERVICE_INSTANCE, *PSERVICE_INSTANCE;

// Target descriptor

typedef struct _TARGET_INSTANCE {
    DWORD NameLength;
    RTL_GENERIC_TABLE SendSubjectTable;
    DWORD MaximumSendSubjectEntries;
    DWORD NumberSendSubjectEntries;
    LIST_ENTRY SendSubjectListHead;
    WCHAR Name[1]; // variable length structure
} TARGET_INSTANCE, *PTARGET_INSTANCE;

// Subject descriptor

typedef struct _SUBJECT_INSTANCE {
    DWORD NameLength;
    GUID Guid;
    LIST_ENTRY ListEntry;
    WCHAR Name[1]; // variable length structure
} SUBJECT_INSTANCE, *PSUBJECT_INSTANCE;

DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE   * ppSubjectInstance
    );

// Guid table

typedef struct _GUID_TABLE {
    RTL_GENERIC_TABLE GuidTable;
} GUID_TABLE, *PGUID_TABLE;

typedef struct _GUID_ENTRY {
    GUID Guid;
} GUID_ENTRY, *PGUID_ENTRY;

PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    );

VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    );

BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\cdosupp.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cdosupp.cxx

Abstract:

    CDO support routines

Author:

    Will Lees (wlees) 20-Oct-1998

Environment:

Notes:

Revision History:

--*/

#include <ntdspchx.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_CDOSUPP

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

#include <atlbase.h>          // cccomptr
#include "cdosys.h"

#define DEBSUB "CDOSUPP:"

#include <smtpsink.h>
#include <initguid.h>
#include <seo.h>
#include <seoexports.h> // IEventUtil   

// This code fragment defines the CLSIDs and IIDs for the event sink
#include "smtpsink_i.c"

// This code fragment defines the CLSIDs and IIDs for the event package
#include "seo_i.c"

// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DEFINE_GUID(GUID_PLAT_SMTPSVC, 
0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DEFINE_GUID(SMTP_PLAT_SOURCE_TYPE_GUID,
0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {4f803d90-fd85-11d0-869a-00c04fd65616}
DEFINE_GUID(SMTP_SOURCE_TYPE_GUID,
0x4f803d90, 0xfd85, 0x11d0, 0x86, 0x9a, 0x0, 0xc0, 0x4f, 0xd6, 0x56, 0x16);

// OnArrival category guid
//"{ff3caa23-00b9-11d2-9dfb-00C04FA322BA}"
DEFINE_GUID( CATID_SMTP_ON_ARRIVAL,
0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

#define STR_DISPLAY_NAME                 "ISM SMTP Transport"
#define STR_SINKCLASS                    "CDO2EventSink.IsmSink1"
#define LONG_PRIORITY                    8192

typedef HRESULT STDAPICALLTYPE REGISTER_SERVER_FN( VOID );

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Apr 26 10:02:58 1999 */

VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    );

BOOL
classPresent(
    IN const GUID *puuidClass
    );

BOOL
servicePresent(
    LPSTR ServiceName
    );

BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    );

HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    );

HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    );

LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    );

HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    );

HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    );

/* End Forward */


VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    )

/*++

Routine Description:

    Log a CDO error event

Arguments:

    hrError - Error status to be logged
    ulInternalId - Call site

Return Value:

    None

--*/

{
    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_CDO_ERROR,
              szInsertWin32Msg(hrError),
              szInsertUL(ulInternalId),
              szInsertHResultCode(hrError),
              NULL, NULL, NULL, NULL, NULL );
} /* LogCdoErrorInternal */


BOOL
classPresent(
    IN const GUID *puuidClass
    )

/*++

Routine Description:

Determine if a given COM class is registered

Arguments:

    puuidClass - pointer to uuid of class, the CLSID or class-id

Return Value:

    BOOL - is it registered

--*/

{
#define CLASS_REG_PATH "SOFTWARE\\Classes\\CLSID\\{%s}"
    BOOL found = FALSE;
    CHAR keyPath[80];
    unsigned char *pszUuidString = NULL;
    DWORD status;
    HKEY hkKey = NULL;

    status = UuidToString( (GUID *) puuidClass, &pszUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        goto cleanup;
    }

    sprintf( keyPath, CLASS_REG_PATH, pszUuidString );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (pszUuidString) {
        RpcStringFree( &pszUuidString );
    }

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* classPresent */


BOOL
servicePresent(
    LPSTR ServiceName
    )

/*++

Routine Description:

Determine if a given service is installed.  We do this by checking the registry.

Arguments:

    ServiceName - Name of service to check

Return Value:

    BOOL - 

--*/

{
#define SERVICE_REG_PATH "SYSTEM\\CurrentControlSet\\Services\\%s"
    BOOL found = FALSE;
    CHAR keyPath[80];
    DWORD status;
    HKEY hkKey = NULL;

    sprintf( keyPath, SERVICE_REG_PATH, ServiceName );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* servicePresent */


BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    )

/*++

Routine Description:

    See if the given name matches the mail address
    This handle the mail address syntax "person" <user@domain>
    A prefix match is done on the name, so that we may match on user only

Arguments:

    bstrAddress - 
    Name - 

Return Value:

    BOOL - 

--*/

{
    LPWSTR start;

    start = wcschr( bstrAddress, L'<' );
    if (start == NULL) {
        return FALSE;
    }
    start++;
    return (_wcsnicmp( start, Name, wcslen( Name ) ) == 0 );

} /* mailAddressMatch */


HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Get the value of the named field out of a Field object
Returned as a variant, caller must free contents

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    VariantInit( pvarValue );

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->get_Value( pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* getFieldVariant */


HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Put the value of the named field in a Field object

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->put_Value( *pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to put_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* putFieldVariant */


HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    )

/*++

Routine Description:

Return the message id of the message

Arguments:

    pIMsg - 
    pbstrFilename - pointer to receive bstr, caller must free

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vMessageId;

    *pbstrId = NULL;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        // This code is on the error handling path
        // Don't log
        // The system may be too hosed at this point to retrieve the message id
        goto cleanup;
    }

    hr = getFieldVariant( pFields, cdoMessageId, &vMessageId );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vMessageId.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Message id type %d was not expected!\n",
                vMessageId.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Steal the bstr out of the variant; don't clean up the variant

    *pbstrId = vMessageId.bstrVal;

    hr = S_OK;

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* getMessageId */


HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pwzUuidString = NULL;
    BSTR bstrGuid = NULL;
    VARIANT vGuid;

    VariantInit( &vGuid );

    status = UuidToStringW( (GUID *) pGuid, &pwzUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    bstrGuid = SysAllocString( pwzUuidString );
    if (bstrGuid == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    vGuid.vt = VT_BSTR;
    vGuid.bstrVal = bstrGuid;

    hr = putFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "putFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;

cleanup:
    if (pwzUuidString) {
        RpcStringFreeW( &pwzUuidString );
    }
    if (bstrGuid) {
        SysFreeString( bstrGuid );
    }

    return hr;
}


HRESULT
getFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    VARIANT vGuid;

    hr = getFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vGuid.vt == VT_EMPTY) {
        ZeroMemory( pGuid, sizeof( GUID ) );
        goto cleanup;
    } else if (vGuid.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Guid type %d was not expected!\n", vGuid.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    status = UuidFromStringW( vGuid.bstrVal, pGuid );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    // Release resources in the variant
    if (vGuid.vt != VT_EMPTY) {
        VariantClear( &vGuid );
    }

    return hr;
}


LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    )

/*++

Routine Description:

Parse a delivery status message for the status: field.
Field is of the form class.subject.detail
Return a descriptive error string for each message

Arguments:

    bstrDeliveryStatus - String describing delivery status message to be
parsed.
    pdwStatus - Pointer to dword to receive closest win32 status

Return Value:

    LPWSTR - Error string returned

--*/

{
#define STATUS_KEYWORD L"Status: "
    LPWSTR pszStatus;
    LONG classCode = 0, subjectCode = 0, detailCode = 0;

    Assert( pdwWin32Status );

    pszStatus = wcsstr( bstrDeliveryStatus, STATUS_KEYWORD );
    if (pszStatus == NULL) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse delivery status message";
    }

    pszStatus += wcslen( STATUS_KEYWORD );

    if (swscanf( pszStatus, L"%d.%d.%d", &classCode, &subjectCode, &detailCode )
        != 3) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse status field";
    }

    // Any success
    if (classCode == 2) {
        *pdwWin32Status = ERROR_SUCCESS;
        return L"Success";
    }

    switch (subjectCode) {
    case 0:
        switch (classCode) {
        // Case 2 handled above
        case 4:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Transient failure, no other information";
        case 5:
            *pdwWin32Status = ERROR_CAN_NOT_COMPLETE;
            return L"Permanent failure, no other information";
        }
    case 1:
        *pdwWin32Status = ERROR_INCORRECT_ADDRESS;
        switch (detailCode) {
        case 1:
            return L"Bad destination mailbox address";
        case 2:
            return L"Bad destination system address";
        case 3:
            return L"Bad destination mailbox address syntax";
        case 4:
            return L"Destination mailbox address ambiguous";
        case 5:
            return L"Destination address valid";
        case 6:
            return L"Destination mailbox has moved, No forwarding address";
        case 7:
            return L"Bad sender's mailbox address syntax";
        case 8:
            return L"Bad sender's system address";
        }
        break;
    case 2:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"Mailbox disabled, not accepting messages";
        case 2:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mailbox full";
        case 3:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message length exceeds administrative limit";
        case 4:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Mailing list expansion problem";
        }
        break;
    case 3:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mail system full";
        case 2:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"System not accepting network messages";
        case 3:
            *pdwWin32Status = ERROR_CALL_NOT_IMPLEMENTED;
            return L"System not capable of selected features";
        case 4:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message too big for system";
        case 5:
            *pdwWin32Status = ERROR_BAD_CONFIGURATION;
            return L"System incorrectly configured";
        }
        break;
    case 4:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HOST_UNREACHABLE;
            return L"No answer from host";
        case 2:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Bad connection";
        case 3:
            *pdwWin32Status = ERROR_FILE_NOT_FOUND;
            return L"Directory server failure";
        case 4:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Unable to route";
        case 5:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Mail system congestion";
        case 6:
            *pdwWin32Status = ERROR_DS_LOOP_DETECT;
            return L"Routing loop detected";
        case 7:
            *pdwWin32Status = ERROR_SEM_TIMEOUT;
            return L"Delivery time expired";
        }
        break;
    case 5:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command";
        case 2:
            *pdwWin32Status = ERROR_INVALID_DATA;
            return L"Syntax error";
        case 3:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Too many recipients";
        case 4:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command arguments";
        case 5:
            *pdwWin32Status = ERROR_UNKNOWN_REVISION;
            return L"Wrong protocol version";
        }
        break;
    case 6:
        *pdwWin32Status = ERROR_BAD_FORMAT;
        switch (detailCode) {
        case 1:
            return L"Media not supported";
        case 2:
            return L"Conversion required and prohibited";
        case 3:
            return L"Conversion required but not supported";
        case 4:
            return L"Conversion with loss performed";
        case 5:
            return L"Conversion failed";
        }
        break;
    case 7:
        *pdwWin32Status = ERROR_ACCESS_DENIED;
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_CONNECTION_REFUSED;
            return L"Delivery not authorized, message refused";
        case 2:
            return L"Mailing list expansion prohibited";
        case 3:
            return L"Security conversion required but not possible";
        case 4:
            return L"Security features not supported";
        case 5:
            return L"Cryptographic failure";
        case 6:
            return L"Cryptographic algorithm not supported";
        case 7:
            return L"Message integrity failure";
        }
        break;
    }

    *pdwWin32Status = ERROR_DS_UNKNOWN_ERROR;
    return L"Unknown status code";

} /* parseStatus */


HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    )

/*++

Routine Description:

Invoke a COM dll's registration or deregistration entry point

Arguments:

    DllFilename - 
    Register - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    HINSTANCE hDll = NULL;
    REGISTER_SERVER_FN *pfnRegisterServer, *pfnUnregisterServer;

    hDll = LoadLibrary( DllFilename );
    if (hDll == NULL) {
        status = GetLastError();
        DPRINT2( 0, "LoadLibrary(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    pfnRegisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllRegisterServer" );
    pfnUnregisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllUnregisterServer" );
    if ( (pfnRegisterServer == NULL) ||
         (pfnUnregisterServer == NULL) ) {
        status = GetLastError();
        DPRINT2( 0, "GetProcAddress(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;
    __try {
        if (Register) {
            hr = (*pfnRegisterServer)();
        } else {
            hr = (*pfnUnregisterServer)();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = GetExceptionCode();
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Registration function failed with %d\n", hr );
    }

cleanup:
    if (NULL != hDll) {
        FreeLibrary(hDll);
    }

    return hr;
} /* registerInterfaceDll */


HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Update the existing binding with new properties if necessary

Arguments:

    pBinding - 
    bstrRule - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;
    VARIANT vOldRule;

    VariantInit( &vOldRule );

    hr = pBinding->get_SourceProperties(&pSourceProps);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
        goto cleanup;
    }

    // Get the old value of the rule
    hr = pSourceProps->Item( &CComVariant(CComBSTR(_T("Rule"))), &vOldRule );
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "SourceProps->Item(Rule) failed with error 0x%x\n", hr );
        goto cleanup;
    }

    if (vOldRule.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Rule type %d was not expected!\n", vOldRule.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // If changed, modify the rule
    if (_wcsicmp( vOldRule.bstrVal, bstrRule ) != 0 ) {
        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto cleanup;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto cleanup;
        }

        DPRINT2( 1, "Event sink binding '%ws' Rule=%ws was modified.\n",
                 bstrDisplayName, bstrRule );
    }

cleanup:
    pSourceProps = NULL;

    if (vOldRule.vt != VT_EMPTY) {
        VariantClear( &vOldRule );
    }

    return hr;
} /* modifyBinding */


HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Check if the desired binding is present in the binding list.
If so, verify the fields are up to date

Arguments:

    pBindings - 
    bstrDisplayName - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IUnknown> pIUnknown;
    CComPtr<IEnumVARIANT> pIEnumVariant;
    CComPtr<IEventBinding> pBinding	= NULL;
    LONG count = 0;
    DWORD fetched;
    VARIANT varRet;
    BSTR bstrBindingDisplayName = NULL;
    BOOLEAN found;

    VariantInit( &varRet );

    // Get a new enumeration
    hr = pBindings->get__NewEnum( &pIUnknown );
    if (FAILED(hr))
        goto error_exit;

    // How many?
    hr = pBindings->get_Count(&count);
    if (FAILED(hr))
        goto error_exit;
    if (count == 0) {
        hr = S_FALSE;  // not found
        goto error_exit;
    }

    // Enumerate a series of variants
    hr = pIUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pIEnumVariant);
    if (FAILED(hr))
        goto error_exit;

    // Here is the search loop. We exit at the top. Resources released at loop end

    found = FALSE;
    hr = S_OK;
    while ( (hr == S_OK) && (!found) ) {

        // Get next item
        fetched = 0;
        hr = pIEnumVariant->Next(1UL,&varRet,&fetched);
        if ( FAILED(hr) || (!fetched) ) {
            hr = S_FALSE;
            goto loop_cleanup;
        }

        // Retrieve the binding
        hr = varRet.punkVal->QueryInterface(IID_IEventBinding,(void**)&pBinding);
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Get the display name
        hr = pBinding->get_DisplayName( &bstrBindingDisplayName );
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Does it match?
        if (_wcsicmp( bstrDisplayName, bstrBindingDisplayName ) == 0) {
            found = TRUE;

            hr = modifyExistingBinding( pBinding, bstrDisplayName, bstrRule );
            if (FAILED(hr)) {
                LogUnhandledError( hr );
                DPRINT1( 0, "modifyExistingBinding failed with error 0x%x\n", hr );
                goto loop_cleanup;
            }
        }

    loop_cleanup:
        // Loop resource release
        VariantClear(&varRet);
        pBinding = NULL;
        if (bstrBindingDisplayName) {
            SysFreeString( bstrBindingDisplayName );
            bstrBindingDisplayName = NULL;
        }
    }

    // hr == S_OK, found
    // hr == S_FALSE, not found
    // hr other, error

error_exit:

    return hr;
} /* eventBindingPresent */



HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    )

/* HrIsmSinkBinding()
 *
 * Credits: This code was obtained from Jeff Stammerjohn (jstammerj) of the
 * Exchange group.  It was modified to work as a CDO sink.

 * Purpose:
 *     Binds or unbinds the Ism sink
 *
 * Parameters:
 *     BOOL    fBindSink
 *                 TRUE  - bind the sink
 *                 FALSE - unbind the sink
 *     BSTR    bstrRule - rule to use when creating the binding
 *
 * Returns:
 *     HResult
 */

{
    HRESULT	hr = NULL;
    CComPtr<IEventUtil> pEventUtil = NULL;
    TCHAR szDisplayName[32]	= { NULL };
    CComPtr<IEventBindingManager> pBindingManager	= NULL;
    CComPtr<IEventBindings>	pBindings= NULL;
    CComPtr<IEventBinding> pBinding	= NULL;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;

    // SEO.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_CEventUtil )) ) {
        DPRINT(0,"One or more SEO classes not found - SEO not registered\n" );
        hr = REGDB_E_CLASSNOTREG;
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_CLASS_MISSING,
                  szInsertWC( L"SEO.DLL" ),
                  szInsertWin32Msg(hr),
                  szInsertHResultCode(hr),
                  NULL, NULL, NULL, NULL, NULL );
        goto error_exit;
    }

    // Set up the default site (instance)
    lstrcpy(szDisplayName,_T("smtpsvc 1"));

    hr = CoCreateInstance(CLSID_CEventUtil,NULL,CLSCTX_ALL,IID_IEventUtil,(LPVOID *) &pEventUtil);
    if (FAILED(hr))
    {
        LogUnhandledError( hr );
        DPRINT1( 0, "CoCreateInstance CEventUtil failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pEventUtil->RegisterSource(CComBSTR((LPCWSTR) CStringGUID(SMTP_PLAT_SOURCE_TYPE_GUID)),
                                    CComBSTR((LPCWSTR) CStringGUID(GUID_PLAT_SMTPSVC)),
                                    1,
                                    CComBSTR(_T("smtpsvc")),
                                    CComBSTR(_T("")),
                                    CComBSTR(_T("event.metabasedatabasemanager")),
                                    CComBSTR(szDisplayName),
                                    &pBindingManager);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "RegisterSource smtpsvc failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_ON_ARRIVAL)),
									   &pBindings);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "get_Bindings failed with error 0x%x\n", hr );
        goto error_exit;
    }

    // Check if binding already registered

    hr = eventBindingPresent( pBindings, CComBSTR(STR_DISPLAY_NAME), bstrRule);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "eventBindingPresent failed with error 0x%x\n", hr );
        goto error_exit;
    }

    if (fBindSink)
    {
        if (hr == S_OK) {
            // Binding already present
            DPRINT2( 1, "Event sink binding '%s' %s already present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Create binding
        hr = pBindings->Add(CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)),&pBinding);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Add failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_DisplayName(CComBSTR(STR_DISPLAY_NAME));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_DisplayName failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_SinkClass(CComBSTR(STR_SINKCLASS));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SinkClass failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->get_SourceProperties(&pSourceProps);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("priority")),&CComVariant(LONG_PRIORITY));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop priority failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto error_exit;
        }

        DPRINT3( 1, "Event sink binding '%s' Class=%s Rule=%ws was added.\n",
                 STR_DISPLAY_NAME, STR_SINKCLASS, bstrRule );
    }
    else
    {
        if (hr == S_FALSE) {
            // Binding not present
            DPRINT2( 1, "Event sink binding '%s' %s is not present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Delete binding
        CComVariant vID (CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)));
        
        hr = pBindings->Remove(&vID);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Remove failed with error 0x%x\n", hr );
            goto error_exit;
        }
    }
error_exit:

    return hr;
}

/* end cdosupp.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\ismsmtp.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    imssmtp.c

ABSTRACT:

    This module is a plug-in DLL for the Inter-Site Messaging service, which is
    part of the mail-based replication subsystem in the Directory Service.

    This DLL, as is any instance of the ISM plug-in DLL class, provides a set
    of abstract transport functions, such as send, receive, and so on.  See
    ismapi.h for details.

    This implementation is based on e-mail, using the SMTP protocol.

DETAILS:

CREATED:

    1/28/98     Jeff Parham (jeffparh)
                (Largely copied from WLees's ismip.c.)

REVISION HISTORY:

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>
#include <ntdsa.h>   // Option flags

// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include <dsevent.h>

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ISMSMTP

#include "common.h"
#include "ismsmtp.h"

// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

#define DEBSUB "ISMSMTP:"

// Here is a way to enable debugging dynamically
// Run ismserv.exe under ntsd
// break in to the ismserv process
// !dsexts.dprint /m:ismsmtp level 4
// !dsexts.dprint /m:ismsmtp add *

// Set this to 1 for unit test debug
#define UNIT_TEST_DEBUG 0


/* External */

// Event logging config (as exported from ismserv.exe).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

/* Static */

// Lock on instances list
CRITICAL_SECTION TransportListLock;
// Lock on drop directory
CRITICAL_SECTION DropDirectoryLock;
// Lock on queue directory
CRITICAL_SECTION QueueDirectoryLock;

// Note that aligned 32 bit access is naturally atomic. However, if you ever
// require any atomic test-and-set functionality, you must use Interlocked
// instructions.
// [Nickhar] Aligned 32-bit reads and writes are atomic. Increments and
// decrements, however, are not.
volatile DWORD gcRefCount = 0;
#define ENTER_CALL() (InterlockedIncrement(&gcRefCount))
#define EXIT_CALL() (InterlockedDecrement(&gcRefCount))
#define CALLS_IN_PROGRESS() (gcRefCount)
#define NO_CALLS_IN_PROGRESS() (gcRefCount == 0)

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Nov 04 10:12:42 1998 */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     );

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    );

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    );

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    );

void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    );

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    );

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    );

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    );

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    );

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    );

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    );

/* End Forward */


DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    )

/*++

Routine Description:

Wrapper function to handle exception handling in the
InitializeCriticalSection() function.

Arguments:

    pcsCriticalSection - pointer to critical section

Return Value:

    DWORD - status code

--*/

{
    DWORD status;

    __try {
        InitializeCriticalSection( pcsCriticalSection );
        status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    return status;
} /* initializeCriticalSectionHelper */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

    This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    DWORD status;
    BOOL  fReturn = TRUE;
    LPSTR rgpszDebugParams[] = {"lsass.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
    HANDLE hevLogging;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {

        // Debug library is already initialize in dll, ismserv.exe,
        // where the library is exported from.

        // Get event logging config (as exported from ismserv.exe).
        gpDsEventConfig = DsGetEventConfig();

#if DBG
#if UNIT_TEST_DEBUG
        DebugInfo.severity = 1;
        strcpy( DebugInfo.DebSubSystems, "ISMSMTP:XMITRECV:CDOSUPP:" ); 
//        DebugInfo.severity = 3;
//        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif
        DebugMemoryInitialize();
#endif
        
        if ( (ERROR_SUCCESS != InitializeCriticalSectionHelper( &TransportListLock ) ) ||
             (ERROR_SUCCESS != InitializeCriticalSectionHelper( &DropDirectoryLock ) ) ||
             (ERROR_SUCCESS != InitializeCriticalSectionHelper( &QueueDirectoryLock ) ) ) {
            fReturn = FALSE;
            goto exit;
        }
        InitializeListHead( &TransportListHead );
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // Make sure all threads stopped
        // Empty address list
        DeleteCriticalSection( &TransportListLock );
        DeleteCriticalSection( &DropDirectoryLock );
        DeleteCriticalSection( &QueueDirectoryLock );
        if (!IsListEmpty( &TransportListHead )) {
            DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
        }
#if DBG
        DebugMemoryTerminate();
#endif

        // Debug library is terminated in dll, ismserv.exe,
        // where the library is exported from.

        break;
    }
    default:
        break;
    }   /* switch */

exit:
    return ( fReturn);
}  /* DllLibMain() */

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    )
/*++

Routine Description:

    Initialize the plug-in.

Arguments:

    pszTransportDN (IN) - The DN of the Inter-Site-Transport that named this
        DLL as its plug-in.  The DS object may contain additional configuration
        information for the transport (e.g., the name of an SMTP server for
        an SMTP transport).

    pNotifyFunction (IN) - Function to call to notify the ISM service of pending
        messages.

    hNotify (IN) - Parameter to supply to the notify function.

    phIsm (OUT) - On successful return, holds a handle to be used in
        future calls to the plug-in for the named Inter-Site-Transport.  Note
        that it is possible for more than one Inter-Site-Transport object to
        name a given DLL as its plug-in, in which case IsmStartup() will be
        called for each such object.

Return Values:

    NO_ERROR - Successfully initialized.

    other - Failure.
        
--*/
{
    DWORD length;
    PTRANSPORT_INSTANCE instance;
    DWORD status, hr;
    BOOLEAN firsttime;
    BOOLEAN fSmtpInit = FALSE;
    BOOLEAN fNotifyInit = FALSE;

    DPRINT1( 1, "IsmStartup, transport='%ws'\n", pszTransportDN );

    MEMORY_CHECK_ALL();
    // Check validity of arguments

    if (phIsm == NULL) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    length = wcslen( pszTransportDN );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Restrict to only one transport instance.
    EnterCriticalSection(&TransportListLock);
    __try {
        firsttime = IsListEmpty( &(TransportListHead) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }
    if (!firsttime) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        return status;
    }

    // INITIALIZE TRANSPORT INSTANCE HERE
    // All values initially zero

    instance->Size = sizeof( TRANSPORT_INSTANCE );
    Assert( instance->ReferenceCount == 0 );
    instance->pNotifyFunction = pNotifyFunction;
    instance->hNotify = hNotify;
    InitializeListHead( &(instance->ServiceListHead) );
    status = InitializeCriticalSectionHelper( &(instance->Lock) );
    if( ERROR_SUCCESS!=status ) {
        FREE_TYPE( instance );
        LogUnhandledError( status );
        return status;
    }

    // ReplInterval is 0, meaning the application should take default

    // Default is schedules not significant, bridges not required (transitive)
    instance->Options = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;

    // INITIALIZE TRANSPORT INSTANCE HERE

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }
    wcscpy( instance->Name, pszTransportDN );

    MEMORY_CHECK_ALL();

    // ************************************************************************

    // Create event to signal shutdown.
    instance->hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == instance->hShutdownEvent) {
        status = GetLastError();
        DPRINT1(0, "Failed to create shutdown event, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    // Open connection to directory service
    status = DirOpenConnection( &instance->DirectoryConnection );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Start monitoring for routing changes
    status = DirStartNotifyThread( instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }
    fNotifyInit = TRUE;

    hr = SmtpInitialize( instance );
    if (FAILED(hr)) {
        status = hr;
        // Event already logged
        goto cleanup;
    }
    fSmtpInit = TRUE;

    MEMORY_CHECK_ALL();

    // Insert this instance into the list.

    // Note that, assuming the ISM service is functioning correctly, this list
    // cannot contain duplicates (where "duplicate" is defined as an entry with
    // the same DN).
    
    EnterCriticalSection(&TransportListLock);
    __try {
        InsertTailList( &TransportListHead, &(instance->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    // Start a listener thread for this instance
    // Note, make sure instance fully initialized before starting this thread
    // Note, instance cannot be destroyed until thread is stopped
    instance->ListenerThreadHandle = (HANDLE)
        _beginthreadex(NULL, 0, SmtpRegistryNotifyThread, instance, 0,
                       &instance->ListenerThreadID);
    if (NULL == instance->ListenerThreadHandle) {
        status = _doserrno;
        Assert(status);
        DPRINT1(0, "Failed to create listener thread, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    InterlockedIncrement( &(instance->ReferenceCount) );  // 1 for the lifetime of this transport

    *phIsm = instance;

    MEMORY_CHECK_ALL();

    return ERROR_SUCCESS;

cleanup:

    instance->fShutdownInProgress = TRUE;

    if (fNotifyInit) {
        (void) DirEndNotifyThread( instance );
    }

    if (fSmtpInit) {
        (void) SmtpTerminate( instance, FALSE /* not removal */ );
    }

    if (instance->DirectoryConnection) {
        (void) DirCloseConnection( instance->DirectoryConnection );
    }

    if (instance->hShutdownEvent != NULL) {
        CloseHandle( instance->hShutdownEvent );
    }

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }
    Assert( instance->ReferenceCount == 0 );
    FREE_TYPE(instance);

    MEMORY_CHECK_ALL();

    return status;
}

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    )
/*++

Routine Description:

    Called whenever changes occur to the Inter-Site-Transport object specified
    in the IsmStartup() call.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    eReason (in) - Reason for refresh

    pszObjectDN (IN) - DN of the Inter-Site-Transport object.  This is
        guaranteed to be the same as the DN passed in IsmStartup, as inter-site
        transport objects cannot be renamed.

Return Values:

    0 or Win32 error code.

--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status, oldReplInterval, oldOptions;

    ENTER_CALL();

    DPRINT2( 1, "IsmRefresh, reason = %d, new name = %ws\n",
             eReason,
             pszObjectDN ? pszObjectDN : L"not supplied" );

    if (instance->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ( (eReason == ISM_REFRESH_REASON_RESERVED) ||
         (eReason >= ISM_REFRESH_REASON_MAX) ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // If a site changed in any way, just invalidate the cache

    if (eReason == ISM_REFRESH_REASON_SITE) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( eReason == ISM_REFRESH_REASON_TRANSPORT );

    // Inter-site transport objects cannot be renamed.
    Assert((pszObjectDN == NULL)
           || (0 == _wcsicmp(pszObjectDN, instance->Name)));

    oldOptions = instance->Options;
    oldReplInterval = instance->ReplInterval;

    // Reread parameters from the registry 
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( ( oldOptions != instance->Options) ||
         ( oldReplInterval != instance->ReplInterval ) ) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
    }

cleanup:

    EXIT_CALL();

    return status;
}


DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Send a message over this transport.

    The local message is implementated as four segments:
    1. Length of service, 4 bytes
    2. Service name itself, terminated, unicode
    3. Length of data, 4 bytes
    4. Data itself

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszRemoteTransportAddress (IN) - Transport address of the destination
        server.

    pszServiceName (IN) - Name of the service on the remote machine that is the
        intended receiver of the message.

Return Values:

    0 or Win32 error code.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status;

    ENTER_CALL();

    DPRINT2( 1, "IsmSend, address = %ws, service = %ws\n",
            pszRemoteTransportAddress, pszServiceName);

    // Validate arguments

    if ( (transport->Size != sizeof( TRANSPORT_INSTANCE )) ||
         (pszServiceName == NULL) ||
         (*pszServiceName == L'\0') ||
         (pMsg == NULL) ||
         (pMsg->cbData == 0) ||
         (pMsg->pbData == NULL) ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call
    __try {
        status = SmtpSend(transport,
                          pszRemoteTransportAddress,
                          pszServiceName,
                          pMsg);
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

cleanup:

    EXIT_CALL();

    return status;
}


DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Return the next waiting message (if any).  If no message is waiting, a NULL
    message is returned.  If a non-NULL message is returned, the ISM service
    is responsible for calling IsmFreeMsg(*ppMsg) when the message is no longer
    needed.

    If a non-NULL message is returned, it is immediately dequeued.  (I.e., once
    a message is returned through IsmReceive(), the transport is free to destroy
    it.)

    This routine is pretty simple.  It finds the service, and dequeues a message
    if there is any.  Queue the message is done by the listener thread behind
    the scenes.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    0 or Win32 error code.

--*/
{
    DWORD status;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT1( 2, "IsmReceive, service name = %ws\n", pszServiceName );

    // Validate arguments

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ppMsg == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call
    __try {
        status = SmtpReceive(transport, pszServiceName, ppMsg);
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    DPRINT1( 2, "IsmReceive, size = %d\n", *ppMsg ? (*ppMsg)->cbData : 0 );

cleanup:

    EXIT_CALL();

    return status;
}


void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Frees a message returned by IsmReceive().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pMsg (IN) - Message to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT1( 1, "IsmFreeMsg, size = %d\n", pMsg->cbData );

    // Validate arguments

    if ( (instance != NULL) &&
         (instance->Size != sizeof( TRANSPORT_INSTANCE )) ) {
        // error: invalid parameter
        Assert( FALSE );
        goto cleanup;
    }

    SmtpFreeMessage( pMsg );

cleanup:

    EXIT_CALL();

}

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites.

    On successful return, the ISM service will eventually call
    IsmFreeConnectivity(hIsm, *ppConnectivity);

    The transport has associated with it some lingering state.  The matrix of
    schedules is notfreed at the end of this routine.  It remains, tied to
    the transport handle, for the benefit of the GetConnectionSchedule api.

    There is no time-based caching of this information.  Each time this routine
    is called, theinformation is regnerated.  GetConnectionSchedule api uses the
    matrix of schedules from the last time this call was made, regardless of
    time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along this transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, numberSites, i;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;

    DPRINT( 1, "IsmGetConnectivity\n" );

    ENTER_CALL();
    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Validate
        if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
            status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (transport->fShutdownInProgress) {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            __leave;
        }

        // Get the site list and connectivity matrix

        status = RouteGetConnectivity( transport,
                                       &numberSites,
                                       &pSiteList,
                                       &pLinkArray,
                                       transport->Options,
                                       transport->ReplInterval );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "failed to get connectivity, error %d\n", status );
            __leave;
        }

        // Return null structure to indicate no sites
        if (numberSites == 0) {
            ppConnectivity = NULL; // No connectivity
            status = ERROR_SUCCESS;
            __leave;
        }

        Assert( pLinkArray );
        Assert( pSiteList );

        // Build a connectivity structure to return

        pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
        if (pConnectivity == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );
            
            DirFreeSiteList( numberSites, pSiteList );
            RouteFreeLinkArray( transport, pLinkArray );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pConnectivity->cNumSites = numberSites;
        pConnectivity->ppSiteDNs = pSiteList;
        pConnectivity->pLinkValues = pLinkArray;
        *ppConnectivity = pConnectivity;

        status = ERROR_SUCCESS;
    } __finally {

        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
        EXIT_CALL();
    }

    return status;
}

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    )
/*++

Routine Description:

    Frees the structure returned by IsmGetConnectivity().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSiteConnectivity (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        goto cleanup;
    }

    if (pConnectivity == NULL) {
        goto cleanup;
    }

    // Free individual components

    if (pConnectivity->cNumSites > 0) {
        DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

        RouteFreeLinkArray( transport, pConnectivity->pLinkValues );
    }

    FREE_TYPE( pConnectivity );

cleanup:

    EXIT_CALL();
}

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via this transport.

    On successful return of a non-NULL list, the ISM service will eventually
    call IsmFreeTransportServers(hIsm, *ppServerList);

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;

    DPRINT1( 1, "IsmGetTransportServers, site = %ws\n", pszSiteDN );

    ENTER_CALL();
    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Validate

        if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
            status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (transport->fShutdownInProgress) {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            __leave;
        }

        // Get the server list

        status = DirGetSiteBridgeheadList( transport, transport->DirectoryConnection,
                                           pszSiteDN, &numberServers, &serverList );
        if (status != ERROR_SUCCESS) {

            if (status == ERROR_FILE_NOT_FOUND) {
                *ppServerList = NULL; // All servers
                status = ERROR_SUCCESS;
                __leave;
            }

            DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
            __leave;
        }

        // Return null structure to indicate no servers
        if (numberServers == 0) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            __leave;
        }

        // Construct the server structure

        pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
        if (pIsmServerList == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

            // Clean up the pieces
            for( i = 0; i < numberServers; i++ ) {
                FREE_TYPE( serverList[i] );
            }
            FREE_TYPE( serverList );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pIsmServerList->cNumServers = numberServers;
        pIsmServerList->ppServerDNs = serverList;

        *ppServerList = pIsmServerList;

        status = ERROR_SUCCESS;

    } __finally {

        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
        EXIT_CALL();

    }
    return status;
}

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pServerList (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeTransportServers\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
// error: invalid parameter
        goto cleanup;
    }

    if (pServerList == NULL) {
        goto cleanup;
    }

    // Free individual components

    if ( (pServerList->cNumServers != 0) && (pServerList->ppServerDNs != NULL) ) {
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            FREE_TYPE( pServerList->ppServerDNs[i] );
        }
        FREE_TYPE( pServerList->ppServerDNs );
    }

    FREE_TYPE( pServerList );

cleanup:

    EXIT_CALL();
}

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    )

/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via this
    transport.

    On successful return, it is the ISM service's responsibility to eventually
    call IsmFreeSchedule(*ppSchedule);

    The transport has associated with it some lingering state.  The matrix of
    schedules is not freed at the end of this routine.  It remains, tied to the
    transport handle, for the benefit of the GetConnectionSchedule api.

    There is no time-based caching of this information.  Each time the get conn
    routine is called, the information is regnerated.  GetConnectionSchedule api
    uses the matrix of schedules from the last time this call was made,
    regardless of time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PBYTE pSchedule;

    ENTER_CALL();

    DPRINT2( 1, "IsmGetConnectionSchedule, site1 = %ws, site2 = %ws\n",
            pszSite1DN, pszSite2DN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    status = RouteGetPathSchedule( transport,
                                     pszSite1DN,
                                     pszSite2DN,
                                     &pSchedule,
                                     &length );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        if (*ppSchedule == NULL) {
            FREE_TYPE( pSchedule );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

    status = ERROR_SUCCESS;
cleanup:

    EXIT_CALL();

    return status;
}

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSchedule (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeConnectionSchedule\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
// error: invalid parameter
        goto cleanup;
    }

    if (pSchedule == NULL) {
        goto cleanup;
    }

    Assert( pSchedule->cbSchedule != 0 );
    Assert( pSchedule->pbSchedule );

    FREE_TYPE( pSchedule->pbSchedule );

    pSchedule->pbSchedule = NULL;
    pSchedule->cbSchedule = 0;

    FREE_TYPE( pSchedule );

cleanup:

    EXIT_CALL();
}

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    )
/*++

Routine Description:

    Uninitialize transport plug-in.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().
    eReason (IN) - Reason for shutdown

Return Values:

    None.

--*/
{
    DWORD               status;
    DWORD               waitStatus;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    LONG count;

    DPRINT1( 1, "IsmShutdown, Reason %d\n", eReason );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        return;
    }

    transport->fShutdownInProgress = TRUE;

    SetEvent(transport->hShutdownEvent);

    // Shutdown the listener thread
    // Note, shut this down before invalidating the instance

    waitStatus = WaitForSingleObject(transport->ListenerThreadHandle, 5*1000);
    if ( (WAIT_OBJECT_0 != waitStatus) &&
         (WAIT_TIMEOUT != waitStatus) ) {
        status = GetLastError();
        DPRINT3(0, "Shutdown failed, wait status=%d, GLE=%d, TID=0x%x.\n",
                waitStatus, status, transport->ListenerThreadID);
    }

    // If calls in progress, give them a chance to finish
    // The service and rpc should guarantee that this entrypoint is
    // not called while calls are in progress. I suspect this is not
    // always true.  Be defensive.

    if (CALLS_IN_PROGRESS()) {
        Sleep( 5 * 1000 );
    }

    // Remove this instance from the list.
    EnterCriticalSection(&TransportListLock);
    __try {
        RemoveEntryList( &(transport->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    // Release any routing state
    RouteFreeState( transport );

    DeleteCriticalSection( &(transport->Lock) );

    if (NO_CALLS_IN_PROGRESS()) {
        // Clean up only if all calls complete
        (void) SmtpTerminate( transport, (eReason == ISM_SHUTDOWN_REASON_REMOVAL) );
    } else {
        Assert( FALSE && "calls in progress did not exit" );
    }

    DirEndNotifyThread( transport );

    count = InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for the lifetime of this transport

    if (count == 0) {
        // Clean up only if thread is finished

        // Close connection to directory
        status = DirCloseConnection( transport->DirectoryConnection );
        // ignore error

        CloseHandle( transport->hShutdownEvent );
        transport->hShutdownEvent = NULL;

        // RUNDOWN TRANSPORT INSTANCE HERE

        transport->Size = 0; // clear signature to prevent reuse
        
        FREE_TYPE( transport->Name );
        FREE_TYPE( transport );

        // RUNDOWN TRANSPORT INSTANCE HERE
    } else {
        DPRINT2( 0, "Transport %ws not completely shutdown, %d references still exist.\n",
                 transport->Name, count );
    }
}


DWORD
IsmQuerySitesByCost(
    IN  HANDLE                      hIsm,
    IN  LPCWSTR                     pszFromSite,
    IN  DWORD                       cToSites,
    IN  LPCWSTR*                    rgszToSites,
    IN  DWORD                       dwFlags,
    OUT ISM_SITE_COST_INFO_ARRAY**  prgSiteInfo
    )
/*++

Routine Description:

    Determine the individual costs between the From site and the To sites.

Arguments:

    pszFromSite (IN) - The name (not distinguished) of the From site.

    rgszToSites (IN) - An array containing the names of the To sites.

    cToSites (IN) - The number of entries in the rgszToSites array.

    dwFlags (IN) - Unused.

    prgSiteInfo (IN) - On successful return, holds a pointer to a structure
        containing the costs between the From site and the To sites.
    
Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status;

    ENTER_CALL();

    DPRINT2( 0, "IsmQuerySitesByCost (FromSite=%ls, cToSites=%d)\n",
        pszFromSite, cToSites );

    // Validate
    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto Cleanup;
    }

    status = RouteQuerySitesByCost( transport, pszFromSite,
                cToSites, rgszToSites, dwFlags, prgSiteInfo );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "Failed to get query sites, error %d\n", status );
    } else {
        DPRINT( 0, "RouteQuerySitesByCost succeeded\n" );
    }

Cleanup:
    
    EXIT_CALL();
    
    return status;
}


VOID
IsmFreeSiteCostInfo(
    IN  HANDLE                     hIsm,
    IN  ISM_SITE_COST_INFO_ARRAY  *rgSiteCostInfo
    )
/*++

Routine Description:

    Frees the structure returned by ISM_QUERY_SITES_BY_COST().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    rgSiteCostInfo (IN) - Structure to free.

Return Values:

    None.

--*/
{
    ENTER_CALL();
    RouteFreeSiteCostInfo( rgSiteCostInfo );
    EXIT_CALL();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\dlltest.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    transporttest.c

Abstract:

Test for a transport dll.    

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name

        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

#include <schedule.h>

#include "ismapi.h"

/* External */

/* Static */

static ISM_NOTIFY NotifyFunction;

static HANDLE ghNotify = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 15 17:05:00 1998 */

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    );

static void
Usage(
    WCHAR *ProgramName
    );

static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    );

static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    );

static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    );

static void
printSchedule(
    PBYTE pSchedule
    );

static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    );

/* End Forward */


int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *option, *address, *service, *message, *transport, *site;
    if (argc < 2) {
        Usage( argv[0] );
        return -1;
    }
    option = argv[1];
    if (_wcsicmp( option, L"-c" ) == 0) {
        if (argc < 6) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        address = argv[3];
        service = argv[4];
        message = argv[5];
        if (!clientTest( transport, address, service, message )) {
            printf( "client test failed\n" );
        }
    } else if (_wcsicmp( option, L"-s" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        service = argv[3];

        if (!serverTest( transport, service )) {
            printf( "server test failed\n" );
        }
    } else if (_wcsicmp( option, L"-r" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        site = argv[3];

        if (!directoryTest( transport, site )) {
            printf( "directory test failed\n" );
        }
    } else {
        Usage( argv[0] );
        return -1;
    }
    return 0;
}


static void
Usage(
    WCHAR *ProgramName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "Usage:\n" );
    printf( "\t%ws -c transport address service \"string\"\tclient test\n", ProgramName );
    printf( "\t%ws -s transport service\tserver test\n", ProgramName );
    printf( "\t%ws -r transport site \trouting function test\n", ProgramName );
}


static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    ISM_MSG message;
    DWORD status, bytes, i;
    PBYTE pBlock;

    printf( "client test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    bytes = 0;
    bytes = _wtoi( Message );
    if (bytes == 0) {
        message.pszSubject = L"This is the mail subject";
        message.cbData = (wcslen( Message ) + 1) * sizeof( WCHAR );
        message.pbData = (PBYTE) Message;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
    } else {
        pBlock = LocalAlloc( LMEM_FIXED, bytes );
        if (pBlock == NULL) {
            printf( "LocalAlloc failed to alloc %d bytes\n", bytes );
            return FALSE;
        }
        for( i = 0; i < bytes; i++ ) {
            pBlock[i] = (BYTE) ((i % 26) + 'a');
        }
        message.cbData = bytes;
        message.pbData = pBlock;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
        LocalFree( pBlock );
    }

    IsmShutdown( handle );

    return TRUE;
}


static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle, event;
    DWORD status, waitStatus;
    PISM_MSG pMessage;
    BOOLEAN done = FALSE;
    WCHAR eventName[255];

    wcscpy( eventName, L"_NT_DS_ISM_SMTP" );
    wcscat( eventName, Service );

    printf( "server  test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    printf( "startup successful\n" );

    // auto-reset, inital value non-signaled
    event = CreateEventW( NULL, FALSE, FALSE, eventName );
    if (NULL == event) {
        printf( "CreateEvent failed\n" );
        return FALSE;
    }

    while (!done) {
        status = IsmReceive( handle, Service, &pMessage );
        if (status) {
            printf( "IsmReceived failed with error %d\n", status );
            break;
        }
        if (pMessage == NULL) {
            printf( "no more messages, waiting...\n" );
            waitStatus = WaitForSingleObject( event, INFINITE );
            if (waitStatus != WAIT_OBJECT_0) {
                printf( "wait failed with unexpected status %d\n",waitStatus);
                break;
            }
        } else {
            if (pMessage->cbData < 100) {
                printf( "Received subj: '%ws', message: \"%ws\"\n",
                        pMessage->pszSubject, pMessage->pbData );
                if (_wcsicmp( (WCHAR *) pMessage->pbData, L"exit" ) == 0) {
                    done = TRUE;
                }
            } else {
                printf( "Received message: %d bytes\n", pMessage->cbData );
            }
            IsmFreeMsg( handle, pMessage );
        }
    }

    CloseHandle( event );

    IsmShutdown( handle );
    return TRUE;
}


static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status, i, j;
    BOOLEAN result = FALSE;
    PISM_CONNECTIVITY pConnectivity = NULL;
    PISM_SERVER_LIST pServerList = NULL;
    PISM_SCHEDULE pSchedule = NULL;

    printf( "directory test\n" );
    if (IsmStartup( TransportName, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = IsmGetTransportServers( handle, SiteName, &pServerList );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get transport servers, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nTransport Servers:\n" );
    if (pServerList != NULL) {
        printf( "Number of Servers = %d\n", pServerList->cNumServers );
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            printf( "\tServer[%d] = %ws\n", i, pServerList->ppServerDNs[i] );
        }
    } else {
        printf( "\tNone\n" );
    }

    status = IsmGetConnectionSchedule( handle, L"FOO", L"BAR", &pSchedule );
    if (status != ERROR_NOT_READY) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectivity( handle, &pConnectivity );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get connectivity, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nSite Connectivity::\n" );

    if (pConnectivity != NULL) {
        printf( "Number of sites = %d\n", pConnectivity->cNumSites );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "\tSite[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        }
        printf( "All pairs shortest path matrix:\n" );
        printf( "     |" );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            printf( "%5.5d|", j );
        }
        printf( "\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "%5.5d|", i );
            for( j = 0; j < pConnectivity->cNumSites; j++ ) {
                PISM_LINK pLink = &( pConnectivity->pLinkValues[ i * pConnectivity->cNumSites + j ] );
                if (pLink->ulCost != 0xffffffff) {
                    printf( "%5.5u:", pLink->ulCost );
                } else {
                    printf( "  *  :" );
                }
                printf( "%5.5u:", pLink->ulReplicationInterval );
                printf( "%5.5x|", pLink->ulOptions );
            }
            printf( "\n" );
        }
    } else {
        printf( "\tNo site connectivity\n" );
    }

    status = IsmGetConnectionSchedule( handle,
                                       pConnectivity->ppSiteDNs[0],
                                       L"BAR",
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectionSchedule( handle,
                                       L"FOO",
                                       pConnectivity->ppSiteDNs[0],
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    // Generate all pairs of sites

    if (pConnectivity != NULL) {
        printf( "\nSite to Site Scheduling:\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            for( j = i + 1; j < pConnectivity->cNumSites; j++ ) {
                if (pConnectivity->pLinkValues[ i + pConnectivity->cNumSites * j ].ulCost == 0xffffffff) {
                    continue;
                }
                status = IsmGetConnectionSchedule( handle,
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j],
                               &pSchedule );
                if (status != ERROR_SUCCESS) {
                    printf( "failed to get common site schedule, or not connected\n" );
                    goto cleanup;
                }

                printf( "\t%ws to %ws: ",
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j] );
                if (pSchedule != NULL) {
                    printf( "Connected via schedule, addr: %p, len: %d\n",
                            pSchedule->pbSchedule, pSchedule->cbSchedule );
                    printSchedule( pSchedule->pbSchedule );
                    IsmFreeConnectionSchedule( handle, pSchedule );
                } else {
                    printf( "Connected all the time\n" );
                }

            }
        }
    }


    result = TRUE;

cleanup:
    if (pConnectivity != NULL) {
        IsmFreeConnectivity( handle, pConnectivity );
    }

    if (pServerList != NULL) {
        IsmFreeTransportServers( handle, pServerList );
    }

    IsmShutdown( handle );

    return result;
}


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tues","Wed","Thurs","Fri","Sat"};

    printf( "\t\t" );
    for( day = 0; day < 7; day++ ) {
        for( hour = 0; hour < 24; hour++ ) {
            if (*data & 0x1) printf( "%s%d:00;", dow[day], hour );
            if (*data & 0x2) printf( "%s%d:15;", dow[day], hour );
            if (*data & 0x4) printf( "%s%d:30;", dow[day], hour );
            if (*data & 0x8) printf( "%s%d:45;", dow[day], hour );
            data++;
        }
    }
    printf( "\n" );
}


static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    )
/*++

Routine Description:

    Called by the plug-in to notify the ISM service that a message has been
    received for the given service.

Arguments:

    hNotify (IN) - Notification handle, as passed to the plug-in in the
        IsmStartup() call.

    pszServiceName (IN) - Service for which a message was received.

Return Values:

    None.

--*/
{
    printf( "Notified of pending message for service %ws.\n", pszServiceName );
}

/* end plugtest.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\adsisupp.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adsisupp.cxx

Abstract:

    ADSI support routines

    This package contains general ADSI helper routines, as well as routines to
    query and manipulate data in the metabase for particular services.

    ADSI is a general COM interface to any kind of hierarchical data store.
    Many components in the system register themselves as providers to the asdi
    namespace, and thus become managable through it.  We are managing the
    Smtpservice in the way.

    You can view the structure of the namespace using adsvw.

    The structure of the smtp service is:

    IIS:/LocalHost/SMTPSVC/
        1/ (class IIsSmtpServer)
            .
            .
            Domain (class Container)
                <your domain here> (Class IIsSmtpDomain)

        Info/ (class IIsSmtpInfo)

    There are many interesting properties on the server and domain objects that
    may prove useful in the future.

    The routines here include:
        Determine if a given Smtp mail routing domain is present
        Create a smtp mail routing domain

Author:

    Will Lees (wlees) 07-Oct-1998

Environment:

Notes:

Revision History:

--*/

#define INC_OLE2

#include <ntdspchx.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ADSISUPP

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

#define DEBSUB "ADSISUPP:"

#include <activeds.h>

/* External */

/* Static */
static LPWSTR EmptyClassList[] = { NULL };

#define ADS_DOMAIN_PATH L"IIS://LocalHost/SMTPSVC/1/Domain"
#define ADS_DOMAIN_PATH_LENGTH (ARRAY_SIZE(DROP_DIRECTORY))

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Apr 26 09:46:36 1999 */

HRESULT
AddSmtpDomainIfNeeded(
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT __cdecl
domainCallback(
    PVOID pObjectOpaque,
    PVOID Context1,
    PVOID Context2
    );

HRESULT
addSmtpDomain(
    LPWSTR AdsPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT
ModifySmtpDomainIfNeeded(
    LPWSTR AdsContainerPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT
EnumObject(
    LPWSTR pszADsPath,
    LPWSTR * lppClassNames,
    DWORD dwClassNames,
    ENUM_CALLBACK_FN *pCallback,
    PVOID Context1,
    PVOID Context2
    );

HRESULT
getSmtpServerProperties(
    LPWSTR AdsPath,
    BSTR *pbstrDropDirectory
    );

HRESULT
getPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR *pbstrValue
    );

HRESULT
putPropInteger(
    IADs *pObject,
    LPWSTR PropertyName,
    DWORD Value
    );

HRESULT
putPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR bstrValue
    );

/* End Forward */


HRESULT
CheckSmtpDomainContainerPresent(
    void
    )

/*++

Routine Description:

Check whether the Smtp Domain Container can be opened

Arguments:

    void - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL;
    IADsContainer * pADsContainer =  NULL;

    // Get the domain container
    hr = ADsGetObject(
        ADS_DOMAIN_PATH,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        goto cleanup;
    }

    // Just checking

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }

    return hr;
} /* CheckSmtpDomainContainerPresent */


HRESULT
removeSmtpDomainHelper(
    LPWSTR AdsPath,
    LPWSTR DomainName
    )

/*++

Routine Description:

    Remove the given smtp domain

Arguments:

    AdsPath - 
    DomainName - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    IADs * pADsObject =  NULL;

    // Get the domain container
    hr = ADsGetObject(
        AdsPath,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                  szInsertWC(AdsPath),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = pADsContainer->Delete( L"IIsSmtpDomain", DomainName );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsContainer->Delete(%ws) failed with error 0x%x\n",
                DomainName, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_DELETE_OBJECT_FAILURE,
                  szInsertWC(DomainName),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = pADsContainer->QueryInterface(IID_IADs, (VOID **) &pADsObject) ;
    if (FAILED(hr)) {
        DPRINT1( 0, "QueryInterface failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Commit the deletion to the store
    hr = pADsObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT2(0,"ADsObject->SetInfo(%ws) failed with error 0x%x\n",
                DomainName, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_SET_INFO_FAILURE,
                  szInsertWC(DomainName),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }
    if (pADsObject) {
        pADsObject->Release();
    }

    return hr;

} /* removeSmtpDomainHelp */


HRESULT
RemoveSmtpDomain(
    LPWSTR DomainName
    )

/*++

Routine Description:

    Remove the given smtp domain

Arguments:

    DomainName - 

Return Value:

    HRESULT - 

--*/

{
    return removeSmtpDomainHelper( ADS_DOMAIN_PATH, DomainName );
}


HRESULT
AddSmtpDomainIfNeeded(
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Check for the given Smtp Domain in the Smtp Service metabase, and create one
if not present.

Note, this routine uses the first virtual Smtp Server.  In the future we may
need a way to specify the preferred virtual server

Arguments:

    DomainName - usually a dns name of this computer, the RHS of a mail addr

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    LPWSTR classList[] = { L"IIsSmtpDomain" };
    BOOL fDomainFound = FALSE;

    // Note: we search only the first Virtual Smtp Server

    // Enumerate the domain container, looking for IIsSmtpDomain objects

    hr = EnumObject( ADS_DOMAIN_PATH,
                     classList,
                     1,
                     domainCallback,
                     DomainName,
                     &fDomainFound
                     );
    if (FAILED(hr)) {
        DPRINT2( 0, "EnumObject(%ws) failed, error 0x%x\n",
                 ADS_DOMAIN_PATH, hr );
        // Error already logged
        goto cleanup;
    }

    // If it was found, we need to check that it is correct
    if (fDomainFound) {
        DPRINT1( 1, "SMTP Domain %ws is already present.\n", DomainName );
        hr = ModifySmtpDomainIfNeeded( ADS_DOMAIN_PATH, DomainName, bstrDropDirectory );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to modify Smtp Domain, error 0x%x\n", hr );
            // Error already logged
        }
        goto cleanup;
    }

    // Add the new domain
    hr = addSmtpDomain( ADS_DOMAIN_PATH, DomainName, bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to add Smtp Domain, error 0x%x\n", hr );
        // Error already logged
        goto cleanup;
    }

    hr = S_OK;
cleanup:
   return hr;
} /* AddSmtpDomainIfNeeded */


HRESULT __cdecl
domainCallback(
    PVOID pObjectOpaque,
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

This is a call back routine for the EnumObject function.
This routine is expected to be called back for SmtpDomain objects.  It
compares the passed in objects with the given domain name, and sets the
out parameter boolean true when they match

Arguments:

    pObjectOpaque - a pointer to a IADS * object for a smtp domain
    Context1 - lpwstr domain name
    Context2 - lpbool found, set true if a match occurs

Return Value:

    HRESULT __cdecl - 

--*/

{
    HRESULT hr;
    BSTR bstrName = NULL;
    IADs *pObject = (IADs *) pObjectOpaque;
    LPWSTR DomainName = (LPWSTR) Context1;
    LPBOOL pfDomainFound = (LPBOOL) Context2;

    // Get the object name
    hr = pObject->get_Name(&bstrName) ;
    if (FAILED(hr)) {
        DPRINT1(0,"get_Name failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Does it match?
    if (_wcsicmp(DomainName,bstrName) == 0) {
        *pfDomainFound = TRUE;
        hr = S_FALSE; // terminate enumeration with success
    }

cleanup:

    if (bstrName) {
        SysFreeString(bstrName);
    }

    return hr;
} /* domainCallback */


HRESULT
addSmtpDomain(
    LPWSTR AdsPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Add a Smtp Domain to the given domain container.
The domain is added as type "1".
We default everything else for now.

Arguments:

    AdsPath - 
    DomainName - 
    bstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    BSTR bstrClass = NULL, bstrName = NULL;
    IDispatch *pDispatch = NULL;
    IADs *pObject = NULL;

    // Get the domain container
    hr = ADsGetObject(
        AdsPath,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                  szInsertWC(AdsPath),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    // build a class string
    bstrClass = SysAllocString( L"IIsSmtpDomain" );
    if (bstrClass == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // build a new object name string
    bstrName = SysAllocString( DomainName );
    if (bstrName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Invoke the create method on the container object to create the new
    // object of default class, in this case, IIsSmtpDomain.

    hr = pADsContainer->Create(
        bstrClass,
        bstrName,
        &pDispatch
        );
    if (FAILED(hr)) {
        DPRINT1(0,"ADsContainer::Crate failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }
    
    // Get the newly created object
    hr = pDispatch->QueryInterface(
        IID_IADs,
        (VOID **) &pObject
        );
    if (FAILED(hr)) {
        DPRINT1(0,"QueryInterface failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write properties here if needed
    // 0x1 is the value Mike Swafford (mikeswa) said to put here.
    hr = putPropInteger( pObject, L"RouteAction", 1 );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropInteger failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = putPropBstr( pObject, L"RouteActionString", bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write the object to persistent store
    hr = pObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT1(0,"SetInfo failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT3( 1, "Added SMTP Domain %ws (drop dir %ws) to %ws\n",
             DomainName, bstrDropDirectory, AdsPath );
    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_DOMAIN_ADD,
              szInsertWC(AdsPath),
              szInsertWC(DomainName),
              szInsertWC(bstrDropDirectory),
              NULL, NULL, NULL, NULL, NULL);

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }
    if (pDispatch) {
        pDispatch->Release();
    }
    if (pObject) {
        pObject->Release();
    }

    if (bstrClass) {
        SysFreeString( bstrClass );
    }
    if (bstrName) {
        SysFreeString( bstrName );
    }

    return hr;
} /* addSmtpDomain */


HRESULT
ModifySmtpDomainIfNeeded(
    LPWSTR AdsContainerPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Make sure the drop directory is correct on the existing smtp domain

Arguments:

    AdsPath - 
    DomainName - 
    bstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL;
    LPWSTR pwzDomainObjectPath = NULL;
    BSTR bstrOldDropDirectory = NULL;

    pwzDomainObjectPath = NEW_TYPE_ARRAY(
        (wcslen( AdsContainerPath ) + 1 + wcslen( DomainName ) + 1), WCHAR );
    if (pwzDomainObjectPath == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"Can't allocate domain path, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }
    wcscpy( pwzDomainObjectPath, AdsContainerPath );
    wcscat( pwzDomainObjectPath, L"/" );
    wcscat( pwzDomainObjectPath, DomainName );

    // Get the domain container
    hr = ADsGetObject(
        pwzDomainObjectPath,
        IID_IADs,
        (void **)&pObject
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                pwzDomainObjectPath, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                  szInsertWC(pwzDomainObjectPath),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = getPropBstr( pObject, L"RouteActionString", &bstrOldDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"getPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // See if the value needs to be changed
    if (_wcsicmp( bstrOldDropDirectory, bstrDropDirectory ) == 0) {
        hr = S_OK;
        goto cleanup;
    }

    // Write properties here if needed
    // 0x1 is the value Mike Swafford (mikeswa) said to put here.
    hr = putPropInteger( pObject, L"RouteAction", 1 );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropInteger failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = putPropBstr( pObject, L"RouteActionString", bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write the object to persistent store
    hr = pObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT1(0,"SetInfo failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT2( 1, "Modified object %ws with drop dir %ws\n",
             pwzDomainObjectPath, bstrDropDirectory );
    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_DOMAIN_ADD,
              szInsertWC(AdsContainerPath),
              szInsertWC(DomainName),
              szInsertWC(bstrDropDirectory),
              NULL, NULL, NULL, NULL, NULL);

cleanup:
    if (pwzDomainObjectPath != NULL) {
        FREE_TYPE( pwzDomainObjectPath );
    }
    if (pObject) {
        pObject->Release();
    }
    if (bstrOldDropDirectory) {
        SysFreeString( bstrOldDropDirectory );
    }


    return hr;
} /* addSmtpDomain */


HRESULT
EnumObject(
    LPWSTR pszADsPath,
    LPWSTR * lppClassNames,
    DWORD dwClassNames,
    ENUM_CALLBACK_FN *pCallback,
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

Enumerates the contents of a container object.
Calls a callback on each object found.
Filters objects returned if requested.

This routine is taken from
mssdk\samples\netds\adsi\cpp\adscmd\enum.cxx
Enhanced for error handling, manual filtering and a callback routine.

Arguments:

    pszADsPath - string path of container in ads namespace
    lppClassNames - array of strings of classes to request
    dwClassNames - number of strings in array
    pCallback - callback function to call on each object found
    Context1 - callback argument 1
    Context2 - callback argument 2

Return Value:

    HRESULT - 

--*/

{
#define MAX_ADS_ENUM      16     // number of entries to read each time
    ULONG cElementFetched = 0L;
    IEnumVARIANT * pEnumVariant = NULL;
    VARIANT VarFilter, VariantArray[MAX_ADS_ENUM];

    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    DWORD i = 0;
    BOOL  fContinue = TRUE, fLoopContinue;
    BOOL fFilterPutSuccessful = FALSE;
    BOOL fManualFilterNeeded = FALSE;

   VariantInit(&VarFilter);

   // Get the container object
   hr = ADsGetObject(
       pszADsPath,
       IID_IADsContainer,
       (void **)&pADsContainer
       );
    if (FAILED(hr)) {
        DPRINT2( 0, "AdsGetObject(%ws) failed, error 0x%x\n",
                 pszADsPath, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                  szInsertWC(pszADsPath),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL )
        goto cleanup ;
    }

    // Build and supply the filter array
    // Not all classes support this, apparently
    if (dwClassNames) {
        hr = ADsBuildVarArrayStr(
            lppClassNames,
            dwClassNames,
            &VarFilter
            );
        if (FAILED(hr)) {
            DPRINT1( 0, "ADsBuildVarArrayStr failed, error 0x%x\n", hr );
            LogUnhandledError( hr );
            goto cleanup ;
        }

        hr = pADsContainer->put_Filter(VarFilter);
        if (hr != E_NOTIMPL) {
            if (FAILED(hr)) {
                DPRINT1( 0, "put_Filter failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                goto cleanup ;
            }
            fFilterPutSuccessful = TRUE;
        } else {
            fManualFilterNeeded = TRUE;
        }
    }

    // Build an enumerator for the container
    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    if (FAILED(hr)) {
        DPRINT1( 0, "ADsBuildEnumerator failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup ;
    }

    // Loop while more to do
    // Note the structure of the loop: we always exit through the top.
    // The loop_cleanup section must be executed to free resources.

    while (fContinue) {

        // Zero the array of variants
        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);

        // Get the next batch. Note that cElemFetched may be >0 even though
        // the routine returns S_FALSE.

        hr = ADsEnumerateNext(
                    pEnumVariant,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
            // keep going, but this is the last time
        } else if (FAILED(hr)) {
            DPRINT1( 0, "ADsEnumerateNext failed, error 0x%x\n", hr );
            LogUnhandledError( hr );
            goto cleanup ;
        }

        // Loop through the elements found
        fLoopContinue = TRUE;
        for (i = 0; ((i < cElementFetched) && (fLoopContinue)); i++ ) {

            IDispatch *pDispatch = NULL;
            IADs *pObject = NULL ;
            BSTR bstrClass = NULL;

            // Get the pointer to the object returned

            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            if (FAILED(hr)) {
                DPRINT1( 0, "QueryInterface failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                fLoopContinue = FALSE;
                goto loop_cleanup ;
            }

            // Get its class name

            hr = pObject->get_Class(&bstrClass);
            if (FAILED(hr)) {
                DPRINT1( 0, "get_Class failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                fLoopContinue = FALSE;
                goto loop_cleanup ;
            }

            // If manual filtering, check class against list
            if (fManualFilterNeeded) {
                DWORD j;
                BOOL found;
                for( j = 0, found=FALSE; (j < dwClassNames) && (!found); j++ ) {
                    found = (wcscmp( bstrClass, lppClassNames[j] ) == 0);
                }
                if (!found) {
                    goto loop_cleanup;
                }
            }

            // Call the callback on this object
            hr = (*pCallback)( pObject, Context1, Context2 );
            if (FAILED(hr)) {
                DPRINT1( 0, "enumObject callback failed, error 0x%x\n", hr );
                fLoopContinue = FALSE;
            } else if (hr == S_FALSE) {
                fLoopContinue = FALSE;
                // Enumeration terminated prematurely with success
            }

        loop_cleanup:
            if (bstrClass) {
                SysFreeString(bstrClass);
            }

            if (pObject) {
                pObject->Release();
            }
            pDispatch->Release();

        } // For loop through elements found

        // Cleanup up premature loop termination
        if (!fLoopContinue) {
            for (; (i < cElementFetched); i++ ) {
                IDispatch *pDispatch = NULL;

                pDispatch = VariantArray[i].pdispVal;
                pDispatch->Release();
            }
            // Abort containing loop
            fContinue = FALSE;
        }

    } // while (fContinue)

    // hr set above and passed through

cleanup:

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    if (!fFilterPutSuccessful) {
        VariantClear(&VarFilter);
    }
    // else will be cleared as part of container release

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
} /* EnumObject */


HRESULT
getSmtpServerProperties(
    LPWSTR AdsPath,
    BSTR *pbstrDropDirectory
    )

/*++

Routine Description:

Get properties from the given smtp server

Arguments:

    AdsPath - 
    pbstrDropDirectory - pointer to bstr to get drop directory, caller frees

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL ;

    // Get smtp server object
    hr = ADsGetObject(
        AdsPath,
        IID_IADs,
        (void **)&pObject
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                  szInsertWC(AdsPath),
                  szInsertWin32Msg( hr ),
                  szInsertHResultCode( hr ),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = getPropBstr( pObject, L"DropDirectory", pbstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"getPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Retrieve other properties here as needed

    hr = S_OK;

cleanup:

    if (pObject) {
        pObject->Release();
    }

    return hr;
} /* getSmtpServerProperties */


HRESULT
getPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR *pbstrValue
    )

/*++

Routine Description:

Get a bstr-valued property from an object. Caller must free.

Arguments:

    pObject - 
    PropertyName - 
    pbstrValue - pointer to allocated bstr; caller must sysfree()

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    // Allocate the property
    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property
    hr = pObject->Get( bstrProp, &varValue );
    if (FAILED(hr)) {
        DPRINT1(0,"Get failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // We are expecting a bstr

    if (varValue.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1( 0, "Variant has unexpected type %d\n", varValue.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

// Steal the bstr out of the variant, and don't free the variant
    *pbstrValue = varValue.bstrVal;

    hr = S_OK;

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    return hr;
} /* getPropBstr */


HRESULT
putPropInteger(
    IADs *pObject,
    LPWSTR PropertyName,
    DWORD Value
    )

/*++

Routine Description:

This is a helper routine to create an integer attribute on an object.
The attribute to be set is specified at run-time.

Note, it is assumed caller will call pObject->SetInfo to flush the changes

Arguments:

    pObject - iads object pointer
    PropertyName - string name of property to be written
    Value - integer

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    VariantInit( &varValue );

    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    varValue.vt = VT_I4;
    varValue.lVal = Value;

    hr = pObject->Put( bstrProp, varValue );
    if (FAILED(hr)) {
        DPRINT1(0, "Put failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    // No need to free variant

    return hr;

} /* putPropInteger */


HRESULT
putPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR bstrValue
    )

/*++

Routine Description:

This is a helper routine to create an bstr attribute on an object.
The attribute to be set is specified at run-time.

Note, it is assumed caller will call pObject->SetInfo to flush the changes

Arguments:

    pObject - iads object pointer
    PropertyName - string name of property to be written
    Value - bstr

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    VariantInit( &varValue );

    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    varValue.vt = VT_BSTR;
    varValue.bstrVal = bstrValue;

    hr = pObject->Put( bstrProp, varValue );
    if (FAILED(hr)) {
        DPRINT1(0, "Put failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    // Caller will free bstr
    // No need to free variant

    return hr;

} /* putPropBstr */

/* end adsisupp.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\stdafx.cxx ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

//#include "stdafx.h"
#include "atlbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMTPSink.rc
//
#define IDS_PROJNAME                    100
#define IDR_SINK1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\ismsink1.h ===
// Modified from SMTP SINK SAMPLE by wlees, Jul 22, 1998

// Sink1.h : Declaration of the CSink1

#ifndef __ISMSINK1_H_
#define __ISMSINK1_H_

#include "resource.h"       // main symbols
#include "cdosys.h"  // ISMTPOnArrival
// Jun 8, 1999. #ifdef necessary until new headers checked in
#ifdef __cdo_h__
using namespace CDO;
#endif
#include "cdosysstr.h" // string constants (field names)
#include "cdosyserr.h" // error codes for CDO
#include "seo.h" // IEventIsCacheable

HRESULT HrIsmSinkBinding(BOOL fBindSink);

/////////////////////////////////////////////////////////////////////////////
// CIsmSink1
class ATL_NO_VTABLE CIsmSink1 : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CIsmSink1, &CLSID_IsmSink1>,
	public IDispatchImpl<ISMTPOnArrival, &IID_ISMTPOnArrival, &LIBID_ISMSMTPSINKLib>,
        public IEventIsCacheable
{
public:
	CIsmSink1()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SINK1)

BEGIN_COM_MAP(CIsmSink1)
	COM_INTERFACE_ENTRY(ISMTPOnArrival)
	COM_INTERFACE_ENTRY(IEventIsCacheable)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISink1
public:
    STDMETHOD(OnArrival)(IMessage *pISinkMsg, CdoEventStatus *pEventStatus);
    STDMETHOD(IsCacheable)() { return S_OK; };
};

#endif //__ISMSINK1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\ismsink1.cpp ===
// Modified from SMTP SINK SAMPLE by wlees, Jul 22, 1998

/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ismsink1

Abstract:

    This module contains the implementation of the OnArrival method for the
    ism smtp event sink.

    This method is invoked when a new smtp message arrives

    Since this notification dll runs in a different process from the ism, we
    employ a optimization to notify the ISM.
    1. The event that the ism waits for, for a particular transport and
    service, has a name we can predict.
    2. We signal the ism directly that a message is available.  We don't bother
    signalling the transport dll, which would just have to have a thread
    waiting on the event.  The ism is already waiting on the event anyway.

    ISM notification events look like:
    _NT_DS_ISM_<transport rdn><service name>

Author:

    Will Lees (wlees) 22-Jul-1998

Environment:

Notes:

Revision History:


--*/

// Sink1.cpp : Implementation of CSink1

#include "stdafx.h"
#include "SMTPSink.h"
#include "ismSink1.h"

#include <mdcodes.h>

// Event logging
typedef ULONG MessageId;
#define pszNtdsSourceIsm            "NTDS Inter-site Messaging"

extern "C" ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

// To temporarily enable debugging
#if 1
#define DPRINT( level, format ) DbgPrint( format )
#define DPRINT1( level, format, arg1 ) DbgPrint( format, arg1 )
#define DPRINT2( level, format, arg1, arg2 ) DbgPrint( format, arg1, arg2 )
#define DPRINT3( level, format, arg1, arg2, arg3 ) DbgPrint( format, arg1, arg2, arg3 )
#else
#define DPRINT( level, format ) 
#define DPRINT1( level, format, arg1 ) 
#define DPRINT2( level, format, arg1, arg2 ) 
#define DPRINT3( level, format, arg1, arg2, arg3 ) 
#endif

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define SMTP_EVENT_PREFIX L"_NT_DS_ISM_SMTP"
#define SMTP_EVENT_PREFIX_LEN  (ARRAY_SIZE(SMTP_EVENT_PREFIX) - 1)

// TODO: put this in a common header?

// The service name used to send and receive messages between DSAs via ISM.
#define DRA_ISM_SERVICE_NAME L"NTDS Replication"
#define SUBJECT_PREFIX      L"Intersite message for "
#define SUBJECT_PREFIX_LEN  (ARRAY_SIZE(SUBJECT_PREFIX) - 1)
#define SUBJECT_SEPARATOR L": "
#define SUBJECT_SEPARATOR_LEN  (ARRAY_SIZE(SUBJECT_SEPARATOR) - 1)

// This code fragment defines the CLSIDs and IIDs for the event package
#include "seo_i.c"

/////////////////////////////////////////////////////////////////////////////
// CSink1


VOID
LogNtdsAbortEvent(
    IN DWORD EventMid,
    IN BSTR bstrClientIpAddress,
    IN BSTR bstrSubject,
    IN HRESULT hr
    )
/*++

Routine Description:

    This function writes an error event with the given description into the
    directory service error log.

Arguments:

    EventMid - Event code to be logged
    bstrClientIpAddress - insertion parameter
    bstrSubject - insertion parameter
    hr - insertion parameter

Return Value:

    None 

--*/
{

    HANDLE hEventSource = NULL;
    DWORD err;
    BOOL succeeded;
    WCHAR errorCodeText[16];
    LPCWSTR rgpszInserts[4];
    DWORD cch = 0;
    PWCHAR pBuffer = NULL;

    hEventSource = RegisterEventSourceA(NULL, pszNtdsSourceIsm);

    if (hEventSource == NULL)
        goto CleanUp;

    // Default radix for hresult is 16
    if (!_itow(hr, errorCodeText, 16))
        goto CleanUp;

    cch = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        0, // system message file
        hr,
        0,
        (LPWSTR) &pBuffer,
        0,
        NULL);
    if (!cch)
        goto CleanUp;

    rgpszInserts[0] = bstrClientIpAddress ? bstrClientIpAddress : L"";
    rgpszInserts[1] = bstrSubject ? bstrSubject : L"";
    rgpszInserts[2] = errorCodeText;
    rgpszInserts[3] = (cch != 0) ? pBuffer : L"";

    succeeded = ReportEventW(hEventSource,
                             EVENTLOG_ERROR_TYPE,
                             ISM_CATEGORY,
                             EventMid,
                             NULL,
                             4,
                             0,
                             rgpszInserts,
                             NULL);

    if (!succeeded)
        goto CleanUp;

CleanUp:

    if (hEventSource != NULL)
    {
        DeregisterEventSource(hEventSource);
    }

    if (pBuffer != NULL) {
        LocalFree( pBuffer );
    }

} /* DbgPrint */


HRESULT
getItemValue(
    LPWSTR ItemName,
    CComPtr<Fields> pFields,
    VARIANT *pvValue
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItem = NULL;
    VARIANT vItem;

    VariantInit( &vItem );

    bstrItem = SysAllocString( ItemName );
    if (bstrItem == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: Failed to allocate from bstr\n" );
        goto exit;
    }
    vItem.vt = VT_BSTR;
    vItem.bstrVal = bstrItem;

    hr = pFields->get_Item( vItem, &pField );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Item(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = pField->get_Value( pvValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Value(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = S_OK;

exit:
    if (vItem.vt != VT_EMPTY) {
        VariantClear( &vItem );
    }
    if (pField) {
        pField = NULL;
    }

    return hr;
}


HRESULT
putItemValue(
    LPWSTR ItemName,
    CComPtr<Fields> pFields,
    VARIANT *pvValue
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItem = NULL;
    VARIANT vItem;

    VariantInit( &vItem );

    bstrItem = SysAllocString( ItemName );
    if (bstrItem == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: Failed to allocate from bstr\n" );
        goto exit;
    }
    vItem.vt = VT_BSTR;
    vItem.bstrVal = bstrItem;

    hr = pFields->get_Item( vItem, &pField );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Item(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = pField->put_Value( *pvValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: put_Value(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = S_OK;

exit:
    if (vItem.vt != VT_EMPTY) {
        VariantClear( &vItem );
    }
    if (pField) {
        pField = NULL;
    }

    return hr;
}


HRESULT
abortDelivery(
    IN IMessage *pIMsg
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vMessageStatus;

    VariantInit( &vMessageStatus );

    // Get the envelope fields
    hr = pIMsg->get_EnvelopeFields( &pFields );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_EnvelopeFields failed, error 0x%x\n", hr );
        goto exit;
    }

    vMessageStatus.vt = VT_I4;
    vMessageStatus.lVal = cdoStatAbortDelivery;

    // Set Message Status
    hr = putItemValue( cdoMessageStatus, pFields, &vMessageStatus );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = pFields->Update();
    if (FAILED(hr)) {
        goto exit;
    }

    hr = S_OK;
exit:
    if (vMessageStatus.vt != VT_EMPTY) {
        VariantClear( &vMessageStatus );
    }
    if (pFields) {
        pFields = NULL;
    }

    return hr;
}


HRESULT
filterOnEnvelope(
    IN CComPtr<IMessage> pIMsg,
    OUT BSTR *pbstrClientIpAddress,
    OUT BOOL *pfSkip
    )

/*++

Routine Description:

Determine if we should skip this message based on the contents of the envelope

Arguments:

    pIMsg - Incoming message to be decoded
    pbstrClientIpAddress - return client ip address
    pfSkip - Return indicator whether this message should be skipped

Return Value:

    HRESULT - 

--*/

{
#define IP_LOCALHOST L"127.0.0.1"
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vClientIp;

    VariantInit( &vClientIp );

    // Get the envelope fields
    hr = pIMsg->get_EnvelopeFields( &pFields );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_EnvelopeFields failed, error 0x%x\n", hr );
        goto exit;
    }

    // Submitters IP address
    hr = getItemValue( cdoClientIPAddress, pFields, &vClientIp );
    if (FAILED(hr)) {
        goto exit;
    }

    // If value not present, finish now
    if (vClientIp.vt == VT_EMPTY) {
        hr = S_OK;
        goto exit;
    }

    if (vClientIp.vt != VT_BSTR) {
        DPRINT1( 0, "IsmSink: Client IP address has wrong variant type %d\n", vClientIp.vt );
        hr = E_INVALIDARG;
        goto exit;
    }

    //DPRINT1( 0, "client ip vt = %d\n", vClientIp.vt );
    //DPRINT1( 0, "client ip = %ws\n", vClientIp.bstrVal );

    // We want to ignore arrivals from the pickup directory
    // Ignore if client or server ip is "local host"
    // NOTE. See my comments in xmitrecv.c::SmtpSend about the three ways to
    // send a message.  If we switch from using the pickup directory, we may
    // need to be more clever about how we detect "relay arrival" notifies.
    if (0 == _wcsicmp( vClientIp.bstrVal, IP_LOCALHOST )) {
        *pfSkip = TRUE;
    }

    // Return client ip address to caller
    *pbstrClientIpAddress = SysAllocString( vClientIp.bstrVal );
    if (*pbstrClientIpAddress == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: Failed to allocate from bstr\n" );
        goto exit;
    }

    hr = S_OK;
exit:
    if (vClientIp.vt != VT_EMPTY) {
        VariantClear( &vClientIp );
    }
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* filterOnEnvelope */

STDMETHODIMP
CIsmSink1::OnArrival(
    IMessage *pISinkMsg,
    CdoEventStatus *pEventStatus
    )

/*++

Routine Description:

   Event handling routine for a new message

   The messages we receive are governed by our filter rule.
   Currently the rule is RCPT TO=_IsmService@guid-based-dns-name
   Thus we receive any mail addressed directly to us, including ism messages,
   status notifications, and potentially anything else.

   There are three possible outcomes from this sink:
1. The message is recognized. We signal the event and skip remaining sinks.
2. We get an error and can't determine what kind of message it is.  In this
case we don't signal, but we don't skip either.
3. We message is definitely not for us.  In this case we don't signal the
event, we abort delivery of the message, and we skip remaining sinks.

We own a customer drop directory. That means we own responsibility for rejecting
bad or unsolicited mail. To prevent denial of service attacks, we must guarantee that
all messages in this drop directory eventually get deleted. There are two levels
of screening: the arrival event sink, and the ism mail drop reader. The mail drop
reader will guarantee that all messages are processed and deleted, but it has to be
woken up by us in order for that to happen.

Think of the sink as a guard over the ism private drop directory.

Perhaps the simplest design of the sink would have been to always notify on the
default service event, or atleast guarantee that this is done on error, so that
the drop reader always has a chance to clean things up.  The drop reader is always
going to be authoritative on what constitutes a valid message anyway.

The drop reader could also run on a timer and scan the drop directory periodically
to guarantee that even if the sink is broken we eventually get all our messages.

What we have currently is a two level effect. The sink aborts on obviously bad messages
and resource errors.  Otherwise it signals if it thinks the message may be decent.
The sink should either abort or signal in all cases.  Note that if it can't signal the event
it aborts the message. This prevents an accumulation of mail in the case that the ISM
is broken or stopped or disabled.

Arguments:

    pISinkMsg - 
    pEventStatus - 

Return Value:

    STDMETHODIMP - 

--*/

{
    HRESULT hr, hr1;
    HANDLE handle = NULL;
    BSTR bstrSubject = NULL;
    BSTR bstrClientIpAddress = NULL;
    LPWSTR pszEventName = NULL;
    LPWSTR pszMsgForServiceName, pszMessageSubject;
    CdoEventStatus disposition = cdoSkipRemainingSinks;  // its for us
    DWORD length;
    BOOL fSkip, fAbortDelivery = TRUE;
    static DWORD cTickLastLogEvent = 0;
#define LOG_EVENT_THROTTLE (15 * 60 * 1000)
#define LOG_EVENT_START_DELAY (5 * 60 * 1000)

//    DPRINT( 0, "Smtp event sink, message OnArrival routine\n" );

    // Wait START_DELAY before the first event is logged to allow
    // time for the ISM service to start.
    if (!cTickLastLogEvent) {
        cTickLastLogEvent = GetTickCount() - LOG_EVENT_THROTTLE + LOG_EVENT_START_DELAY;
    }

    fSkip = FALSE;
    hr = filterOnEnvelope( pISinkMsg, &bstrClientIpAddress, &fSkip );
    // If we fail to determine, don't skip
    if  (fSkip) {
        fAbortDelivery = FALSE;
        disposition = cdoRunNextSink;  // See if anyone else wants it
        goto exit;
    }

    // Get the subject of the message
    hr = pISinkMsg->get_Subject( &bstrSubject );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_To failed with error 0x%x\n", hr );
        goto exit;
    } else if (NULL == bstrSubject) {
        // Can't be for us
        DPRINT( 0, "IsmSink: subject field is missing\n" );
        hr = S_OK;
        goto exit;
    }

    // Determine which ISM service to notify.  Note that we notify on any reasonable
    // message we receive. We leave complex message validation for the ISM service.

    if (_wcsnicmp(bstrSubject, SUBJECT_PREFIX, SUBJECT_PREFIX_LEN) == 0) {
        pszMsgForServiceName = bstrSubject + SUBJECT_PREFIX_LEN;
        pszMessageSubject = wcsstr( pszMsgForServiceName, SUBJECT_SEPARATOR );
        if (!pszMessageSubject) {
            // malformed subject line
            DPRINT1( 0, "IsmSink: subject field not recognized: '%ws'\n", bstrSubject );
            hr = S_OK;
            goto exit;
        }

        *pszMessageSubject = L'\0';
        pszMessageSubject += SUBJECT_SEPARATOR_LEN; // Skip over
    } else {
        // We have received a status notification about some returned mail or problem
        // delivering the mail.  We need to wake up the ismserv.  Normally we signal
        // the ism in the context of a particular ism service according to the message.
        // In the case of returned mail, the name of the original service is not easy to
        // find in the returned mail. So use a well known ISM service.
        // If this mail is not a valid mail delivery problem report, it will be screened
        // out when the message is read by the ISM service.
        pszMsgForServiceName = DRA_ISM_SERVICE_NAME;
        pszMessageSubject = bstrSubject;
    }

#ifdef UNIT_TEST_DEBUG
    DPRINT2( 0, "NTDS ISM SMTP message arrived for service '%ws' subject '%ws'\n",
             pszMsgForServiceName, pszMessageSubject );
#endif

    length = (DWORD)(SMTP_EVENT_PREFIX_LEN + wcslen( pszMsgForServiceName ) + 1);

    pszEventName = new WCHAR [length];
    if (pszEventName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: failed to allocate memory\n" );
        goto exit;
    }

    // Build the predicted global name of the ism+smtp+service event
    wcscpy( pszEventName, SMTP_EVENT_PREFIX );
    wcscat( pszEventName, pszMsgForServiceName );

    // Open the event.  If the ism smtp dll isn't running, we will get
    // error 2 here.  We abort the message in this case. This has the nice
    // property of stopping the accumulation of mail if the ism service
    // is stopped.
    handle = OpenEventW( EVENT_MODIFY_STATE,  // Access flag
                        FALSE,               // Inherit flag
                        pszEventName
                        );
    if (handle == NULL) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPRINT2( 0, "IsmSink: OpenEvent(%ws) failed with 0x%x\n", pszEventName, hr);
        goto exit;
    }

    // Signal the event.
    if (!SetEvent( handle )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPRINT1( 0, "IsmSink: SetEvent failed with 0x%x\n", hr );
        goto exit;
    }

    hr = S_OK;
    fAbortDelivery = FALSE;

exit:
    if (handle != NULL) {
        CloseHandle( handle );
    }
        
    if (pszEventName) {
        delete[] pszEventName;
    }

    if (fAbortDelivery) {
        // Note that MSDN documentation says that pEventStatus must be set to
        // skipRemainingSinks in order for this to be effective
        hr1 = abortDelivery( pISinkMsg );
        if (FAILED(hr1)) {
            DPRINT3( 0, "IsmSink: abortDelivery of message '%ws' from '%ws' failed with error 0x%x\n",
                     bstrSubject, bstrClientIpAddress, hr1 );
            LogNtdsAbortEvent( DIRLOG_SMTPSINK_MESSAGE_ABORT_FAILURE,
                               bstrClientIpAddress,
                               bstrSubject,
                               hr1 );
            // ignore error
        } else {
            DPRINT3( 0, "IsmSink: abortDelivery of message '%ws' from '%ws' reason 0x%x\n",
                     bstrSubject, bstrClientIpAddress, hr );
            if ( (GetTickCount() - cTickLastLogEvent) > LOG_EVENT_THROTTLE ) {
                LogNtdsAbortEvent( DIRLOG_SMTPSINK_MESSAGE_ABORTED,
                                   bstrClientIpAddress,
                                   bstrSubject,
                                   hr );
                cTickLastLogEvent = GetTickCount();
            }
        }
    }

    if (bstrSubject != NULL) {
        SysFreeString( bstrSubject );
    }

    if (bstrClientIpAddress != NULL) {
        SysFreeString( bstrClientIpAddress );
    }

    *pEventStatus = disposition;

    return hr;
} /* CIsmSink1::OnArrival */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\smtpsink.cpp ===
// Modified from CDO V2 SMTP SINK sample, by wlees Jul 22, 1998
// SMTPSink.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SMTPSinkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "SMTPSink.h"
#include "SMTPSink_i.c"
#include "ismSink1.h"
#include "cdosys_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IsmSink1, CIsmSink1)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
    HRESULT hr;

    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtpsink\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED_)
#define AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\table.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    table.c

Abstract:

    Subject table routines

// The following helper routines are used with the link list package to create
// a hierarchy of lists to keep track of subjects strings

This lookaside list represents our recent history of messages that were sent.  We
want the list large enough to hold all the messages sent during a retry interval.
That way if we come to the next interval and we find that we have already sent
this subject before, we will tag it with the guid of the original message and
the mail system can filter it out.
How many is enough?
(number ncs) x (2 types [req/resp]) x (4 flags variations)
64 x 2 x 4 = 512
The only drawback with making the list very large is that the only way it is cleared
is when new items push older items out the end.  So when things are not backed up
you end up searching this long history each time you send.

Author:

    Will Lees (wlees) 10-May-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <ntrtl.h>                      // Generic table package

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_XMITRECV

#include "common.h"
#include "ismsmtp.h"

#define DEBSUB "SMTPTAB:"

#define MAXIMUM_SEND_SUBJECT_ENTRIES 512

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue May 11 14:36:11 1999 */

PVOID NTAPI
tableAllocate(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    );

VOID NTAPI
tableFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );

PSUBJECT_INSTANCE
subjectEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    );

VOID
subjectEntryFree(
    PSUBJECT_INSTANCE pSubject
    );

PSUBJECT_INSTANCE
LookupInsertSubjectEntry(
    IN PTARGET_INSTANCE pTarget,
    IN LPCWSTR pszMessageSubject
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
subjectTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

VOID
subjectTableDestroy(
    RTL_GENERIC_TABLE *pSubjectTable
    );

PTARGET_INSTANCE
targetEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    );

VOID
targetEntryFree(
    PTARGET_INSTANCE pTarget
    );

PTARGET_INSTANCE
LookupInsertTargetEntry(
    RTL_GENERIC_TABLE *pTargetTable,
    IN  LPCWSTR pszRemoteTransportAddress
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
targetTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

VOID
targetTableDestroy(
    RTL_GENERIC_TABLE *pTargetTable
    );

DWORD __cdecl
serviceConstruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE  *  ppSubject
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
guidTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    );

VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    );

BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

/* End Forward */











PVOID NTAPI
tableAllocate(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )

/*++

Routine Description:

Memory allocation helper routine for use by Rtl Generic Table.

I am assuming the Rtl routine does the right think if you return null
out of here.

Arguments:

    Table - 
    ByteSize - 

Return Value:

    PVOID NTAPI - 

--*/

{
    return NEW_TYPE_ARRAY( ByteSize, CHAR );
} /* tableAllocate */


VOID NTAPI
tableFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )

/*++

Routine Description:

Memory free helper routine for use by Rtl Generic Table.

Arguments:

    Table - 
    Buffer - 

Return Value:

    VOID NTAPI - 

--*/

{
    FREE_TYPE( Buffer );
} /* tableFree */
















PSUBJECT_INSTANCE
subjectEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    )

/*++

Routine Description:

Allocate a zero-initialized, correctly formatted subject instance.
The instance is variable sized, depending on the name.

Arguments:

    Name - Name of instance
    pdwInstanceSize - Returned total size of instance allocated

Return Value:

    PSUBJECT_INSTANCE - 

--*/

{
    PSUBJECT_INSTANCE pSubject;
    DWORD length = wcslen( Name ) + 1, size;
    size = sizeof( SUBJECT_INSTANCE ) + (length * sizeof( WCHAR ));

    pSubject = (SUBJECT_INSTANCE *) NEW_TYPE_ARRAY_ZERO( size, CHAR );
    if (pSubject == NULL) {
        DPRINT( 0, "subjectEntryCreate failed to allocate memory\n" );
        return NULL;
    }
    pSubject->NameLength = length;
    wcscpy( pSubject->Name, Name );
    *pdwInstanceSize = size;

    return pSubject;
} /* subjectEntryCreate */


VOID
subjectEntryFree(
    PSUBJECT_INSTANCE pSubject
    )

/*++

Routine Description:

Free a subject entry.

Arguments:

    pSubject - 

Return Value:

    None

--*/

{
    // There are no contained pointers to release

    FREE_TYPE( pSubject );
} /* subjectEntryFree */


PSUBJECT_INSTANCE
LookupInsertSubjectEntry(
    IN PTARGET_INSTANCE pTarget,
    IN LPCWSTR pszMessageSubject
    )

/*++

Routine Description:

Lookup a subject instance by name. The subject table and supporting variables
are the target instance passed in.

Arguments:

    pTarget - 
    pszMessageSubject - 

Return Value:

    PSUBJECT_INSTANCE - 

--*/

{
    PVOID pElement;
    PSUBJECT_INSTANCE pDummySubject = NULL;
    PSUBJECT_INSTANCE pSubject = NULL;
    DWORD subjectSize;
    BOOLEAN fNewElement;

    // Create an empty subject instance for matching purposes
    pDummySubject = subjectEntryCreate( pszMessageSubject, &subjectSize );
    if (pDummySubject == NULL) {
        return NULL;
    }

    // Lookup existing element or insert the new element in the table
    pElement = RtlInsertElementGenericTable(
        &(pTarget->SendSubjectTable),
        pDummySubject,
        subjectSize,
        &fNewElement );
    if (!pElement) {
        // Error, not created for some reason
        // pSubject is already NULL
        goto cleanup;
    }

    // Note, after the insertion, pElement points to the actual table member,
    // while pDummy is only a copy.
    pSubject = (PSUBJECT_INSTANCE) pElement;

    // See if it was in the table
    if (!fNewElement) {
        // pSubject is set to the found element
        goto cleanup;
    }

    // It wasn't in the table
    DPRINT2( 4, "subject entry create, %ws(%d)\n",
             pDummySubject->Name, pDummySubject->NameLength );

    // BEGIN Initialize SUBJECT instance
        
    // Link the element into the list as the newest element
    InsertHeadList( &(pTarget->SendSubjectListHead), &(pSubject->ListEntry) );

    // END Initialize SUBJECT instance



    // See if we need to get rid of oldest entry
    if (pTarget->NumberSendSubjectEntries == pTarget->MaximumSendSubjectEntries) {
        // Older entries at the end of the list
        PSUBJECT_INSTANCE pDeadSubject;
        PLIST_ENTRY pListEntry;
        BOOL found;

        pListEntry = RemoveTailList( &(pTarget->SendSubjectListHead) );
        pDeadSubject = CONTAINING_RECORD( pListEntry, SUBJECT_INSTANCE, ListEntry );

        DPRINT1( 4, "Deleting oldest subject: %ws\n", pDeadSubject->Name );

        found = RtlDeleteElementGenericTable(
            &(pTarget->SendSubjectTable),
            pDeadSubject );
        Assert( found );
        pDeadSubject = NULL;

        // The code giveth and the code taketh away
        // Entry count stays the same
    } else {
        (pTarget->NumberSendSubjectEntries)++;
    }

cleanup:
    if (pDummySubject) {
        subjectEntryFree( pDummySubject );
    }
    return pSubject;
} /* LookupInsertSubjectEntry */


RTL_GENERIC_COMPARE_RESULTS NTAPI
subjectTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table to compare two subject instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PSUBJECT_INSTANCE pFirstSubject = (PSUBJECT_INSTANCE) FirstStruct;
    PSUBJECT_INSTANCE pSecondSubject = (PSUBJECT_INSTANCE) SecondStruct;

    diff = pFirstSubject->NameLength - pSecondSubject->NameLength;
    if (diff == 0) {
        diff = wcscmp( pFirstSubject->Name, pSecondSubject->Name );
    }
    DPRINT5( 5, "Comparing %ws(%d) with %ws(%d) = %d\n",
             pFirstSubject->Name,
             pFirstSubject->NameLength,
             pSecondSubject->Name,
             pSecondSubject->NameLength,
             diff);

    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* subjectTableCompare */


VOID
subjectTableDestroy(
    RTL_GENERIC_TABLE *pSubjectTable
    )

/*++

Routine Description:

Deallocate all the elements of the table.

Arguments:

    pSubjectTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( pSubjectTable, TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( pSubjectTable, TRUE ) ) {
        PSUBJECT_INSTANCE pSubject = (PSUBJECT_INSTANCE) pElement;
        BOOLEAN found;

        DPRINT1( 4, "\t\tCleaning up subject %ws\n", pSubject->Name );
        found = RtlDeleteElementGenericTable( pSubjectTable, pElement );
        Assert( found );
    }
} /* subjectTableDestroy */


















PTARGET_INSTANCE
targetEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    )

/*++

Routine Description:

Create a zero-initialized, properly formed target instance.  The target instance
is a variable length structure.

Arguments:

    Name - 
    pdwInstanceSize - Returned total byte count allocated

Return Value:

    PTARGET_INSTANCE - null on error

--*/

{
    PTARGET_INSTANCE pTarget;
    DWORD length = wcslen( Name ) + 1, size;
    size = sizeof( TARGET_INSTANCE ) + (length * sizeof( WCHAR ));

    pTarget = (TARGET_INSTANCE *) NEW_TYPE_ARRAY_ZERO( size, CHAR );
    if (pTarget == NULL) {
        DPRINT( 0, "targetEntryCreate failed to allocate memory\n" );
        return NULL;
    }
    pTarget->NameLength = length;
    wcscpy( pTarget->Name, Name );
    *pdwInstanceSize = size;

    return pTarget;
} /* targetEntryCreate */


VOID
targetEntryFree(
    PTARGET_INSTANCE pTarget
    )

/*++

Routine Description:

Free a target instance.

This routine should not be used to remove elements from the table.

Arguments:

    pTarget - 

Return Value:

    None

--*/

{
    // Secondary pointers not cleaned up here by design

    FREE_TYPE( pTarget );
} /* targetEntryFree */


PTARGET_INSTANCE
LookupInsertTargetEntry(
    RTL_GENERIC_TABLE *pTargetTable,
    IN  LPCWSTR pszRemoteTransportAddress
    )

/*++

Routine Description:

Lookup or instert a new target entry in the target table.

Arguments:

    pTargetTable - 
    pszRemoteTransportAddress - 

Return Value:

    PTARGET_INSTANCE - 

--*/

{
    PVOID pElement;
    PTARGET_INSTANCE pDummyTarget = NULL;
    PTARGET_INSTANCE pTarget = NULL;
    DWORD targetSize;
    BOOLEAN fNewElement;

    // Create a empty target instance for matching against
    pDummyTarget = targetEntryCreate( pszRemoteTransportAddress, &targetSize );
    if (pDummyTarget == NULL) {
        return NULL;
    }

    // Lookup or Insert the new element in the table
    pElement = RtlInsertElementGenericTable(
        pTargetTable,
        pDummyTarget,
        targetSize,
        &fNewElement );
    if (!pElement) {
        // Error, not created for some reason
        // pTarget is set to NULL already
        goto cleanup;
    }

    // Note, after the insertion, pElement points to the actual table member,
    // while pDummy is only a copy.
    pTarget = (PTARGET_INSTANCE) pElement;

    // Element was already in table
    if (!fNewElement) {
        // pTarget points to the found element
        goto cleanup;
    }

    // It wasn't in the table
    DPRINT1( 4, "target entry create, %ws\n", pDummyTarget->Name );

    // BEGIN Initialize empty TARGET instance
    pTarget->MaximumSendSubjectEntries = MAXIMUM_SEND_SUBJECT_ENTRIES;
    RtlInitializeGenericTable( &(pTarget->SendSubjectTable),
                               subjectTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );
    InitializeListHead( &(pTarget->SendSubjectListHead) );
    // END Initialize empty TARGET instance
        

cleanup:
    if (pDummyTarget) {
        targetEntryFree( pDummyTarget );
    }

    return pTarget;
} /* LookupInsertTargetEntry */


RTL_GENERIC_COMPARE_RESULTS NTAPI
targetTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table. Compare two target instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PTARGET_INSTANCE pFirstTarget = (PTARGET_INSTANCE) FirstStruct;
    PTARGET_INSTANCE pSecondTarget = (PTARGET_INSTANCE) SecondStruct;

    diff = pFirstTarget->NameLength - pSecondTarget->NameLength;
    if (diff == 0) {
        diff = wcscmp( pFirstTarget->Name, pSecondTarget->Name );
    }
    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* targetTableCompare */


VOID
targetTableDestroy(
    RTL_GENERIC_TABLE *pTargetTable
    )

/*++

Routine Description:

Destroy all the elements in the target table.

Arguments:

    pTargetTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( pTargetTable, TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( pTargetTable, TRUE ) ) {
        PTARGET_INSTANCE pTarget = (PTARGET_INSTANCE) pElement;
        BOOLEAN found;

        DPRINT1( 4, "\tCleaning up target %ws\n", pTarget->Name );

        subjectTableDestroy( &(pTarget->SendSubjectTable) );
        // number entries and list head now incoherent

        found = RtlDeleteElementGenericTable( pTargetTable, pElement );
        Assert( found );
    }

} /* targetTableDestroy */

















DWORD __cdecl
serviceConstruct(
    PLIST_ENTRY_INSTANCE pListEntry
    )

/*++

Routine Description:

Callback routine for the generic list package
Initializes a structure of type SERVICE_INSTANCE

Arguments:

    pListEntry - 

Return Value:

    DWORD - 

--*/

{
    PSERVICE_INSTANCE pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

    DPRINT1( 4, "serviceCreate %ws\n", pListEntry->Name );

    RtlInitializeGenericTable( &(pService->TargetTable),
                               targetTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );

    return ERROR_SUCCESS;
} /* serviceCreate */


DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    )

/*++

Routine Description:

Callback routine for the generic list package.
Destroys a service instance

Arguments:

    None

Return Value:

    None

--*/

{
    PSERVICE_INSTANCE pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

    DPRINT1( 4, "serviceDestroy %ws\n", pListEntry->Name );

    targetTableDestroy( &(pService->TargetTable) );

    return ERROR_SUCCESS;
}



















DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE  *  ppSubject
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pszMessageSubject - 
    ppSubject - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    PSERVICE_INSTANCE pService;
    PTARGET_INSTANCE pTarget;
    PLIST_ENTRY_INSTANCE pListEntry;

// First level search, look up service in service list
// This list is a linear linked list unsorted

    status = ListFindCreateEntry(
        serviceConstruct,
        SmtpServiceDestruct,
        sizeof( SERVICE_INSTANCE ),
        ISM_MAX_SERVICE_LIMIT,
        &(pTransport->ServiceListHead),
        &(pTransport->ServiceCount),
        pszServiceName,
        TRUE, // Create
        &(pListEntry) );
    if (status != ERROR_SUCCESS) {
        DPRINT2( 0, "Couldn't find/create service entry %ws, error %d\n",
                 pszServiceName, status );
        LogUnhandledError( status );
        goto cleanup;
    }
    pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

// Second level search, look up target in target table

    pTarget = LookupInsertTargetEntry(
        &( pService->TargetTable ),
        pszRemoteTransportAddress
        );
    if (pTarget == NULL) {
        DPRINT1( 0, "Failed to allocate new target table entry for %ws\n",
                 pszRemoteTransportAddress);
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }

// Third level search: look up subject in subject table

    *ppSubject = LookupInsertSubjectEntry(
        pTarget,
        pszMessageSubject
        );
    if (*ppSubject == NULL) {
        DPRINT1( 0, "Failed to allocate new subject table entry for %ws\n",
                pszMessageSubject);
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }

    status = ERROR_SUCCESS;

cleanup:

    return status;
} /* SmtpTableFindSendSubject */


RTL_GENERIC_COMPARE_RESULTS NTAPI
guidTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table to compare two guid instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PGUID_ENTRY pFirstEntry = (PGUID_ENTRY) FirstStruct;
    PGUID_ENTRY pSecondEntry = (PGUID_ENTRY) SecondStruct;

    diff = memcmp( &(pFirstEntry->Guid), &(pSecondEntry->Guid), sizeof( GUID ) );
    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* guidTableCompare */


PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    VOID - 

Return Value:

    PGUID_TABLE  - 

--*/

{
    PGUID_TABLE pGuidTable = NULL;

    pGuidTable = NEW_TYPE_ZERO( GUID_TABLE );
    if (pGuidTable == NULL) {
        goto cleanup;
    }

    // BEGIN Initialize guid table here
    RtlInitializeGenericTable( &(pGuidTable->GuidTable),
                               guidTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );
    // END Initialize guid table here

cleanup:
    return pGuidTable;
} /* SmtpCreateGuidTable */


VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    Assert( pGuidTable );

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( &(pGuidTable->GuidTable), TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( &(pGuidTable->GuidTable), TRUE ) ) {
        BOOLEAN found;
        PGUID_ENTRY pGuidEntry = (PGUID_ENTRY) pElement;
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &(pGuidEntry->Guid), &pszUuid );
        DPRINT1( 4, "cleaning up guid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif

        found = RtlDeleteElementGenericTable( &(pGuidTable->GuidTable), pElement );
        Assert( found );
    }

    FREE_TYPE( pGuidTable );
} /* SmtpDestroyGuidTable */


BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 
    pGuid - 

Return Value:

    BOOL - 

--*/

{
    PVOID pElement;
    GUID_ENTRY dummyEntry;

    ZeroMemory( &dummyEntry, sizeof( GUID_ENTRY ) );
    dummyEntry.Guid = *pGuid;

    pElement = RtlLookupElementGenericTable(
        &(pGuidTable->GuidTable),
        &dummyEntry );

    return (pElement != NULL);
} /* SmtpGuidPresentInTable */


BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 
    pGuid - 

Return Value:

    BOOL - 

--*/

{
    PVOID pElement;
    GUID_ENTRY dummyEntry;
    BOOLEAN fNewElement;

    ZeroMemory( &dummyEntry, sizeof( GUID_ENTRY ) );
    dummyEntry.Guid = *pGuid;

    pElement = RtlInsertElementGenericTable(
        &(pGuidTable->GuidTable),
        &dummyEntry,
        sizeof( GUID_ENTRY ),
        &fNewElement );

    return (pElement != NULL) && fNewElement;

} /* SmtpGuidInsertInTable */

/* end table.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ism\trnsprts\smtp\xmitrecv.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    xmitrecv.cxx

ABSTRACT:

    Methods to support send and receive via SMTP for the Intersite Messaging
    service.

DETAILS:

CREATED:

    3/20/98     Jeff Parham (jeffparh)

REVISION HISTORY:

    Jul 17, 1998  Will Lees (wlees)
           Restructured and simplified to use CDO V2.
1. Use events as primary means of event notification (polling as backup)
2. Send message data in-line instead of an attachment
3. Combine polling and receiving routines into one

    Sep 3, 1998   wlees
          Added support for detecting and eliminating duplicate messages

    Oct 22, 1998
          Duplicate suppression, guid-based mail names

--*/

#include <ntdspchx.h>

#include <align.h>

#include <ismapi.h>
#include <debug.h>

#include <atlbase.h>          // cccomptr
#include "cdosys.h"
// Jun 8, 1999. #ifdef necessary until new headers checked in
#ifdef __cdo_h__
using namespace CDO;
#endif

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
//#include "ntdsa.h"
//#include "taskq.h"                      // GetSecondsSince1601()
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsconfig.h"                   // Get config param
#include <ntrtl.h>                      // Generic table package

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_XMITRECV

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

// This is actually a C fragment generated by the IDL compiler
// It contains some useful constants for calling CDO
#include "cdosys_i.c"

// Include the class id for the smtp sink so we can check for it
#include "smtpsink_i.c"

#define DEBSUB "XMITRECV:"

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define QUEUE_DIRECTORY L"Queue"
#define QUEUE_DIRECTORY_LEN (ARRAY_SIZE(QUEUE_DIRECTORY))

#define DROP_DIRECTORY L"Drop"
#define DROP_DIRECTORY_LEN (ARRAY_SIZE(DROP_DIRECTORY))

#define RCPT_TO_RULE L"RCPT TO="
#define RCPT_TO_RULE_LEN (ARRAY_SIZE(RCPT_TO_RULE))

// Format for the message subject.
#define USER_PREFIX L"_IsmService@"
#define USER_PREFIX_LEN (ARRAY_SIZE(USER_PREFIX) - 1)
#define SUBJECT_PREFIX      L"Intersite message for "
#define SUBJECT_PREFIX_LEN  (ARRAY_SIZE(SUBJECT_PREFIX) - 1)
#define SUBJECT_SEPARATOR L": "
#define SUBJECT_SEPARATOR_LEN  (ARRAY_SIZE(SUBJECT_SEPARATOR) - 1)
const WCHAR gszSubjectFormat[] =
SUBJECT_PREFIX L"%ls" SUBJECT_SEPARATOR L"%ls";
const DWORD gcchSubjectFormat = ARRAY_SIZE(gszSubjectFormat);

#define HR_SHARING_VIOLATION (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
#define HR_FILE_NOT_FOUND (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
#define HR_NOT_ENOUGH_MEMORY (HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))
#define HR_INVALID_DATA (HRESULT_FROM_WIN32(ERROR_INVALID_DATA))

#define SMTP_MSG_GUID cdoNSMailHeader L"X-MsgGuid"
#define SMTP_SUPERSEDES_MSG_GUID cdoNSMailHeader L"X-SupersedesMsgGuid"

// How frequently do we log an error if SMTP domain not available
#define NO_SMTP_DOMAIN_INTERVAL (24 * 60 * 60)  // Once a day

typedef LONGLONG DSTIME;

extern "C" {
// Return seconds since Jan 1, 1601.
DSTIME
GetSecondsSince1601( void );
}

// Forward

DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

// Static

static GUID zeroGuid = {0};


HRESULT
supersedeMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    IN  IMessage *            pIMsg
    )

/*++

Routine Description:

This routine writes the necessary fields in the message so that it will supercede
a previous message with the same (service,address,subject).  This is done by
keeping keeping a circular list/cache of most recent triples, and associating
with the entry the guid of the last sent message.  On the first send, a new guid
is used.  On a second or later send, the previous guid is set for the
"supersede guid", and then a new guid is set in the cache.

Note that this cache is a performance optimization.  If an entry is bumped out
of the cache, it only means that we won't be able to regenerate the previous
supersede guid to suppress the previous message.  Under certain degenerate
circumstances (more than x services, more than y naming contexts), we will start
to drop entries out.

Note that we depend on the circular nature of the list at the subject level in
order to push out old subject entries.  We don't get feed back whether we were
successful. We depend on the fact that when communication in happening, new
subjects get inserted at the front and the old useless subjects get pushed out
the back. We limit the number of entries so we won't have to search so many each
time.  When communication isn't happening, we expect that the size of the circular
buffer is enough to contain all the unique subjects that are generated by the
application (hopefully small).  These limits can be adjusted.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pszMessageSubject - 
    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    CComPtr<Fields> pFields;
    PSUBJECT_INSTANCE pSubject = NULL;

    // Look up the (Service, Address, Subject) triple
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        status = SmtpTableFindSendSubject(
            pTransport,
            pszRemoteTransportAddress,
            pszServiceName,
            pszMessageSubject,
            &pSubject
            );
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to find subject cache, error 0x%x\n", status );
        hr = HRESULT_FROM_WIN32( status );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Now we have a pointer to a subject record, either new or previous

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // if guid is present, ie this is a retry, load the guid into the
    // supersedes guid filed
    if (memcmp( &(pSubject->Guid), &zeroGuid, sizeof(GUID) ) != 0) {
        DPRINT3( 1, "This message supersedes prior message: (%ws,%ws,%ws)\n",
                 pszServiceName,
                 pszRemoteTransportAddress,
                 pszMessageSubject );
        hr = putFieldGuid( pFields,
                           SMTP_SUPERSEDES_MSG_GUID,
                           &(pSubject->Guid) );
        if (FAILED(hr)) {
            DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Allocate a new guid, store in subject descriptor
    status = UuidCreate( &(pSubject->Guid) );
    if ( (status != RPC_S_OK) &&
         (status != RPC_S_UUID_LOCAL_ONLY) ) {
        DPRINT1( 0, "failed to create guid, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Load guid into message
    hr = putFieldGuid( pFields, SMTP_MSG_GUID, &(pSubject->Guid) );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pFields->Update();
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to update fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* supersedeMessage */


VOID
addRemoveSmtpSvc(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fIsSmtpSvcPresent
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    fIsSmtpSvcPresent - 

Return Value:

    None

--*/

{
    DWORD status, tries, waitCode;

    if (fIsSmtpSvcPresent) {
        DPRINT( 1, "SMTPSVC is present\n" );

        // Even though SmtpSvc is installed, all the other necessary plumbing
        // to add a new domain (ADSI) support is not fully there.  Give the IIS
        // install a chance to finish
    
        for( tries = 0; tries < 40; tries++ ) {
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
    
            if (pTransport->fShutdownInProgress) {
                return;
            }

            if (SUCCEEDED( CheckSmtpDomainContainerPresent() )) {
                break;
            }
        }
    
        if (pTransport->fShutdownInProgress) {
            return;
        }
    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
                status = configureMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } else {
        // This is where we detect the SmtpSvc being uninstalled.
        
        DPRINT( 1, "SMTPSVC is absent\n" );
                    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL != pTransport->Smtp.pszSmtpAddress ) {
                disableMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } // if fIsSmtpSvcPresent

} /* addRemoveSmtpSvc */


unsigned __stdcall
SmtpRegistryNotifyThread(
    void *Argument1
    )

/*++

Routine Description:

Thread to wait for a registry notification that the Smtp Service
has been installed.  When we detect that the Smtp Service is present,
we configure our mail address so that we may receive mail.

This thread exits after the mail address has been set.

This thread uses closure of the registry hkey being monitored as a
single to terminate.  That way we don't need a separate event for
that purpose.

Arguments:

    Argument1 - Transport Instance

Return Value:

    void __cdecl - 

--*/

{
    TRANSPORT_INSTANCE *pTransport = (PTRANSPORT_INSTANCE) Argument1;
    DWORD status, waitCode;
    HKEY hKey = NULL;
    HANDLE hRegChange = NULL;
    HANDLE rghWaitHandles[2];
    BOOL fIsSmtpSvcPresentOldState, fIsSmtpSvcPresentNewState;

    DPRINT( 1, "SmtpRegistryNotifyThread is watching...\n" );

    InterlockedIncrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        status = RegOpenKey(HKEY_LOCAL_MACHINE, 
                            "SYSTEM\\CurrentControlSet\\Services",
                            &hKey);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0, "failed to open services key, error %d\n",
                    status);
            LogUnhandledError(status);
            __leave;
        }

        hRegChange = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == hRegChange) {
            status = GetLastError();
            DPRINT1(0, "CreateEvent failed with %d\n", status);
            LogUnhandledError(status);
            __leave;
        }

        rghWaitHandles[0] = pTransport->hShutdownEvent;
        rghWaitHandles[1] = hRegChange;
        
        // Remember initial state
        fIsSmtpSvcPresentOldState = servicePresent("SmtpSvc");

        // Verify the proper settings on startup every time
        addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentOldState );


        // Wait in a loop watching for SmtpSvc either coming or going

        while (!pTransport->fShutdownInProgress) {
            // Register request for notification of registry change
            // This call does not wait.
            // Returns success on handle closure
            status = RegNotifyChangeKeyValue(hKey,
                                             TRUE, // bWatchSubkeys
                                             REG_NOTIFY_CHANGE_NAME,
                                             hRegChange,
                                             TRUE // fAsynchronous
                                             );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "RegNotifyChangeValue returned %d\n", status );
                LogUnhandledError( status );
                __leave;
            }

            // Wait for shutdown or a change in the Services portion of the
            // registry.
            waitCode = WaitForMultipleObjects(ARRAY_SIZE(rghWaitHandles),
                                              rghWaitHandles,
                                              FALSE,
                                              INFINITE);
            switch (waitCode) {
            case WAIT_OBJECT_0:
                // Shutdown was signalled; bail.
                __leave;

            case WAIT_OBJECT_0 + 1:
                // Services registry change; loop back to the top.
                break;

            case WAIT_FAILED:
            default:
                // Unexpected error return; log and bail.
                status = GetLastError();
                LogUnhandledError(waitCode);
                LogUnhandledError(status);
                __leave;
            }

            fIsSmtpSvcPresentNewState = servicePresent("SmtpSvc"); 

            if (fIsSmtpSvcPresentOldState != fIsSmtpSvcPresentNewState) {

                addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentNewState );

                fIsSmtpSvcPresentOldState = fIsSmtpSvcPresentNewState;

            } // If OldState != NewState 

        } // while ! shutdown

    } __finally {
        DPRINT( 1, "SmtpRegistryNotifyThread exit\n" );

        if (NULL != hRegChange) {
            CloseHandle(hRegChange);
        }

        if (NULL != hKey) {
            RegCloseKey(hKey);
        }

        InterlockedDecrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread
    }

    if (pTransport->fShutdownInProgress) {
        // Normal thread termination.
        status = 0;
    }

    return status;
} /* SmtpRegistryNotifyThread */


DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

This routine initializes the mail address for this server, and prepares the
SMTP server to receive mail on this system.

This routine does nothing if SMTP is not installed.

This routine performs several functions:
1. Generates a mail address for this server and writes it to the mailAddress
attribute if necessary
2. Initializes the transport mail address
3. Adds the Smtp mail routing domain for the guid-based name on this server
4. Register the event sink dll as a COM dll if necessary
5. Bind the event sink to SMTP/CDO

The administrator is no longer required to manually assign a mail address for
the server.  This is created automatically based on the guid-based name of the
server.

Arguments:

    pTransport - The Smtp.pszSmtpAddress field in the transport is updated

Return Value:

    DWORD - success if smtp not installed, otherwise
       hresult error if anything goes wrong

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pszDomain, pszOfficialMailAddress = NULL;
    BOOL fIsGuidBasedName = FALSE;
    BOOL fMailAddressSyntaxIsBad = FALSE;
    LPWSTR pwzRule = NULL;
    BSTR bstrRule = NULL;

    Assert( NULL == pTransport->Smtp.pszSmtpAddress );
    Assert( OWN_CRIT_SEC(pTransport->Lock) );

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // SMTP must be installed (not nec. running) in order to set up
    if ( (!servicePresent("SmtpSvc")) ||
         (!servicePresent("IisAdmin")) ) {
        DPRINT( 1, "Dependent services not present, SMTP not configured.\n" );

        hr = S_OK;
        goto cleanup;
    }

    // SMTP administrative namespace must be available
    // If this fails, either IIS is disabled, or misconfigured
    // Warn the administrator infrequently
    if (FAILED(hr = CheckSmtpDomainContainerPresent())) {
        static DSTIME timeLastFailureLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastFailureLogged)
            || (timeCurrent > (timeLastFailureLogged + NO_SMTP_DOMAIN_INTERVAL))) {
            // Log event to alert admin that we have no domain.
            timeLastFailureLogged = timeCurrent;
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_NO_SMTP_DOMAIN,
                      szInsertWin32Msg(hr),
                      szInsertHResultCode(hr),
                      NULL, NULL, NULL, NULL, NULL, NULL );
        }

        DPRINT1( 0, "Smtp Domain configuration not available, error 0x%x, SMTP not configured.\n",
                hr);

        hr = S_OK;
        goto cleanup;
    }

    // This check was needed before CDO was a regular part of the NT build.
    // CDOSYS.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_Message )) ||
         (!classPresent( &CLSID_Configuration )) ||
         (!classPresent( &CLSID_DropDirectory )) ) {

        DPRINT(0,"One or more CDO classes not found - CDO not registered\n" );

        hr = REGDB_E_CLASSNOTREG;
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_CDO_CLASS_MISSING,
                  szInsertWin32Msg(hr),
                  szInsertHResultCode(hr),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    // Calculate official mail address
    status = DirGetServerSmtpAttributes( pTransport, &pszOfficialMailAddress );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to get server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // See if we have a mail address attribute already set
    status = DirReadServerSmtpAttributes( pTransport );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to read server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Check if it is a guid-based name and syntax is correct
    if (pTransport->Smtp.pszSmtpAddress) {
#define UUID_STRING_LENGTH 36
        LPWSTR p1, p2;
        DWORD length;
        WCHAR szServerUuid[UUID_STRING_LENGTH + 1];
        UUID uuidServer;

        p1 = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (p1) {
            p1++;
            p2 = wcschr( p1, L'.' );
            if (p2) {
                length = (DWORD) (p2 - p1);
            } else {
                length = 0;
            }
        } else {
            fMailAddressSyntaxIsBad = TRUE;
            length = 0;
        }
        if (length == UUID_STRING_LENGTH) {
            // Note: wcsncpy does not null-terminate the string; we do it manually
            wcsncpy(szServerUuid, p1, length);
            szServerUuid[length] = L'\0';
            status = UuidFromStringW(szServerUuid, &uuidServer);
            fIsGuidBasedName = (status == ERROR_SUCCESS);
        }
        // Check that addressee is correct
        if (!fMailAddressSyntaxIsBad) {
            fMailAddressSyntaxIsBad =
                (_wcsnicmp( pTransport->Smtp.pszSmtpAddress,
                            USER_PREFIX, USER_PREFIX_LEN ) != 0 );
        }
    }

    // If we don't, set one up
    // If we have an address, if it is guid-based, check that it is correct
    // Otherwise, leave the address alone.  This allows a user-provided
    // mail address to override the official form.
    if ( (!pTransport->Smtp.pszSmtpAddress) ||
         ( (fIsGuidBasedName || fMailAddressSyntaxIsBad) &&
           (_wcsicmp( pTransport->Smtp.pszSmtpAddress,
                      pszOfficialMailAddress ) != 0 ) ) ) {
        // This call writes the new address and makes it the default
        status = DirWriteServerSmtpAttributes( pTransport,
                                               pszOfficialMailAddress);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0,"Failed to auto configure mail address, error %d\n",
                    status );
            // Error already logged
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else if (!pTransport->Smtp.pszSmtpAddress) {
            status = ERROR_INCORRECT_ADDRESS;
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else {
            DPRINT1( 1, "This server was assigned mail address %ws\n",
                     pTransport->Smtp.pszSmtpAddress );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_MAIL_ADDRESS,
                      szInsertWC(pTransport->Smtp.pszSmtpAddress ),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
    }

    // Make sure guid-based mail routing domain is known to SMTP

    pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
    if (pszDomain == NULL) {
        DPRINT1( 0, "Smtp address %ws is malformed\n",
                 pTransport->Smtp.pszSmtpAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto cleanup;
    }

    pszDomain++; // skip separator

    hr = AddSmtpDomainIfNeeded( pszDomain, pTransport->Smtp.bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1( 0, "AddSmtpDomain failed with error 0x%x\n", hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_DOMAIN_ADD_FAILURE,
                  szInsertWC(pszDomain),
                  szInsertWin32Msg(hr),
                  szInsertHResultCode(hr),
                  NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    // See if our event sink is already registered
    // Note that ismsink.dll has a registration dependency on seo.dll
    // This will only work if IIS is installed, which is implied by smtp check
    // TODO: how do we deregister when we demote?
    if (!classPresent( &CLSID_IsmSink1 )) {
        hr = registerInterfaceDll( "ismsink.dll", TRUE /* register */ );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to register ismsink.dll, error 0x%x\n", hr );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_SINK_REG_FAILURE,
                      szInsertWin32Msg(hr),
                      szInsertHResultCode(hr),
                      NULL, NULL, NULL, NULL, NULL, NULL );
            goto cleanup;
        } else {
            DPRINT( 1, "Successfully registered COM server ismsink.dll.\n" );
        }
    }

    // Create a filter rule to use with our binding
    // The rule is:
    //     RCPT TO=_IsmService@guid-based-domain
    // This will fire for mail addressed to us, and returned mail from the postmaster.
    // It will not fire for mail being routed through this system destined
    // for other servers

    pwzRule = NEW_TYPE_ARRAY(
        (DWORD)(RCPT_TO_RULE_LEN + wcslen( pTransport->Smtp.pszSmtpAddress ) + 1),
        WCHAR );
    if (pwzRule == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    wcscpy( pwzRule, RCPT_TO_RULE );
    wcscat( pwzRule, pTransport->Smtp.pszSmtpAddress );
    bstrRule = SysAllocString( pwzRule );
    if (bstrRule == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Bind our event sink to SMTPSVC, if necessary
    // We check this everytime we start in case IIS has been removed and re-added
    // TODO: When do we call unbind?

    hr = HrIsmSinkBinding( TRUE /* register */, bstrRule );
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to bind event sink, error 0x%x\n", hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_SINK_BIND_FAILURE,
                  szInsertWin32Msg(hr),
                  szInsertHResultCode(hr),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    if (pwzRule) {
        FREE_TYPE( pwzRule );
    }
    if (bstrRule) {
        SysFreeString( bstrRule );
    }
    if (pszOfficialMailAddress) {
        FREE_TYPE( pszOfficialMailAddress );
    }

    if (FAILED(hr)) {
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return hr;
} /* configureMailAddress */


VOID
removeMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Undo the effects of configureMailAddress.
    Cleanup permanent changes to environment prior to service removal

    Environment:

    fShutdownInProgress is TRUE
    CDO Messages have been released
    COM is still running
    pTransport is largely intact

    At the time this is running, LDAP is not available. We do not try to
    remove the transport specific mail address.  It is largely irrelevant
    now since if this server is being demoted, it will not have a NT-DSA
    object and will not be a subject for replication.

Arguments:

    pTransport - Transport state object

Return Value:

    None.

--*/

{
    HRESULT hr;
    LPWSTR pszDomain, pszEnd;
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    BOOL fMoreFound, fFilesRemaining;
    WCHAR szFileName[MAX_PATH];

    // Remove the smtp domain (if configured)

    if (pTransport->Smtp.pszSmtpAddress) {
        pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (pszDomain == NULL) {
            DPRINT1( 0, "Smtp address %ws is malformed\n",
                     pTransport->Smtp.pszSmtpAddress);
            hr = E_INVALIDARG;
            LogUnhandledError( hr );
        } else {
            pszDomain++; // Skip @
            hr = RemoveSmtpDomain( pszDomain );
            if (FAILED(hr)) {
                DPRINT1( 0, "RemoveSmtpDomain failed with error 0x%x\n", hr );
                LogEvent8(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DOMAIN_REMOVE_FAILURE,
                          szInsertWC(pszDomain),
                          szInsertWin32Msg(hr),
                          szInsertHResultCode(hr),
                          NULL, NULL, NULL, NULL, NULL );
                // Keep going
            } else {
                DPRINT1(0, "Removed Smtp Domain %ls\n", pszDomain );
            }
        }
    }

    // Remove any files in the Drop directory

    wcscpy( szFileName, pTransport->Smtp.bstrDropDirectory);
    pszEnd = szFileName + wcslen(pTransport->Smtp.bstrDropDirectory);
    *pszEnd++ = L'\\';

    wcscpy( pszEnd, L"*" );

    fFilesRemaining = FALSE;
    hFind = FindFirstFileW( szFileName, &FindFileData );
    if (hFind != INVALID_HANDLE_VALUE) {
        fMoreFound = TRUE;
        while ( fMoreFound ) {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                wcscpy( pszEnd, FindFileData.cFileName );
                if (!DeleteFileW( szFileName )) {
                    DPRINT1(0, "Failed to delete %ls\n", szFileName );
                    fFilesRemaining = TRUE;
                    // We don't log this error
                } else {
                    DPRINT1(1, "Deleted %ls\n", szFileName );
                }
            }
            fMoreFound = FindNextFileW( hFind, &FindFileData );
        }
        FindClose(hFind);
    }

    // Remove the drop directory itself
    // Don't even try if the directory is not empty
    if ( !fFilesRemaining ) {
        if (!RemoveDirectoryW(pTransport->Smtp.bstrDropDirectory)) {
            DPRINT1(0, "Failed to delete directory %ls\n",
                    pTransport->Smtp.bstrDropDirectory);
            fFilesRemaining = TRUE;
        } else {
            DPRINT1(1, "Deleted %ls\n", pTransport->Smtp.bstrDropDirectory);
        }
    }

    if (fFilesRemaining) {
         LogEvent(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_DROP_DIR_NOT_REMOVED,
                  szInsertWC(pTransport->Smtp.bstrDropDirectory),
                  NULL, NULL );
    }

} /* removeMailAddress */


VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Reset our configuration when SMTP service has been removed

    We leave the drop directory in place since this is tied to our service,
    not SMTPSVC.

    The SMTP domain registration was lost when SMTPSVC was deinstalled, so
    we don't try to remove it here.

    We need to handle the following removal scenarios
    1. We were configured, had a mail address attribute
    2. We are not configured, no mail address attribute
    3. We are not configured, lingering mail address attribute

    Removing the mail address attribute does not solve the problem. Without
    SMTP, there is no way for knowledge of the removal to replicate off the
    system.

Arguments:

    pTransport - 

Return Value:

    None

--*/

{
    // Mark ourselves as unconfigured so we will try again later

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    // Warn the user once at removal time

    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
              NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

} /* disableMailAddress */


HRESULT
getDropDirectoryPath(
    BSTR *pbstrDropDirectory
    )

/*++

Routine Description:

Calculate the drop directory for the system and return it as a BSTR.
The drop directory is recalculated each startup according to the base
NTDS directories in the registry.
Here is the algorithm:
1. If the MAILPATH_KEY is present, it's value is used as an override
2. Otherwise we start with the LOGPATH_KEY.  We want the mail files to
follow the ntds files so they all stay together. The reason the mail files follow
the log and not the main database is that I figure they are both secondary,
supporting files to the main database.  Also, if the main database is
getting full, we want these files to migrate away as well.
2a. Prepend "Drop" as the subdirectory

Note that we expect these registry keys to only change between boots. You can
currently only change these keys during directory safe mode.

Arguments:

    pbstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr, dwFileAttributes;
    WCHAR wzPath[MAX_PATH];

    Assert( pbstrDropDirectory );

    // Construct the drop directory path
    // It comes from the mail path key, or if not defined, from the concatenation
    // of the logging path and the name Drop
    if (GetConfigParamW( MAKE_WIDE(MAILPATH_KEY), wzPath, MAX_PATH)){
        if (status = GetConfigParamW( MAKE_WIDE(LOGPATH_KEY), wzPath, MAX_PATH)){
            DPRINT1( 0, "LOGPATH_KEY not present, error %d\n", status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
        wcscat( wzPath, L"\\" );
        wcscat( wzPath, DROP_DIRECTORY );
    }

    // Make sure it exists
    dwFileAttributes = GetFileAttributesW( wzPath );
    if (dwFileAttributes == 0xffffffff) {
        status = GetLastError();
        if ( (status == ERROR_FILE_NOT_FOUND) ||
             (status == ERROR_PATH_NOT_FOUND) ) {
            if (!CreateDirectoryW( wzPath, NULL )) {
                status = GetLastError();
                DPRINT2( 0, "CreateDirectory(%ws) failed, error %d\n", wzPath, status );
                hr = HRESULT_FROM_WIN32( status );
                goto cleanup;
            }
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_DROP_DIRECTORY,
                      szInsertWC(wzPath),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        } else {
            status = GetLastError();
            DPRINT2( 0, "GetFileAttributes(%ws) failed, error %d\n", wzPath, status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
    } else if ( (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        DPRINT1( 0, "File %ws already exists, but is not a directory!\n", wzPath );
        hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        goto cleanup;
    }

    // Allocate a return string for it
    *pbstrDropDirectory = SysAllocString( wzPath );
    if (*pbstrDropDirectory == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT1( 1, "This server is using drop directory %ws\n", wzPath );

    hr = S_OK;
cleanup:
    return hr;
} /* getDropDirectoryPath */


HRESULT
SmtpInitialize(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

Initialize the Smtp specific aspects of the transport.

In this case, initialize COM so that we can use CDO V2

This is called by the Startup() entry point.  If things are amiss, IsmServ
will unload the dll and log a message.

PERF: Create one long lived drop directory object for the life of the dll?

Arguments:

    pTransport - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BOOLEAN fComInit = FALSE;

// NOTE: This code must return success when SMTP not installed

    // Initialize COM for multi-threaded application
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( (hr != S_OK) && (hr != S_FALSE) ) {
        DPRINT1( 0, "CoInitializeEx failed with error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }
    fComInit = TRUE;

    // We no longer call configureMailAddress at this point because it takes
    // too long. It will be called the first time the Receive or Send entry
    // points are called.

    // Calculate the drop directory
    
    pTransport->Smtp.bstrDropDirectory = NULL;
    hr = getDropDirectoryPath( &(pTransport->Smtp.bstrDropDirectory) );
    if (FAILED(hr)) {
        DPRINT1(0, "Failed to get drop directory, error 0x%x.\n", hr);
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_DROP_DIR_MISSING,
                  szInsertWin32Msg(hr),
                  szInsertHResultCode(hr),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        goto cleanup;
    }

    hr = S_OK;
    fComInit = FALSE; // Don't clean this up

cleanup:

    if (fComInit) {
        CoUninitialize();
    }

    return hr;
} /* SmtpInitialize */


HRESULT
SmtpTerminate(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fRemoval
    )

/*++

Routine Description:

    Terminate the smtp transport functions

Arguments:

    pTransport - Transport object
    fRemoval - Whether service is being removed

Return Value:

    HRESULT - 

--*/

{
    DPRINT( 1, "Enter SmtpTerminate\n" );

    if (NULL != pTransport->Smtp.pvCurrentCollection) {
        IMessages *pIMessages = (IMessages *)pTransport->Smtp.pvCurrentCollection;
        pIMessages->Release();
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
    }

    if (fRemoval) {
        DPRINT( 1, "Removal of ISMSERV/ISMSMTP requested.\n" );
        removeMailAddress( pTransport );
    }

    CoUninitialize();

    (VOID) ListDestroyList( SmtpServiceDestruct,
                            &(pTransport->ServiceListHead),
                            &(pTransport->ServiceCount) );

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
    }

    if (pTransport->Smtp.bstrDropDirectory) {
        SysFreeString( pTransport->Smtp.bstrDropDirectory );
    }

    if (pTransport->Smtp.pvGuidTable) {
        SmtpDestroyGuidTable( (PGUID_TABLE) pTransport->Smtp.pvGuidTable );
    }

    MEMORY_CHECK_ALL();

    DPRINT( 1, "Exit SmtpTerminate\n" );

    return S_OK;
} /* SmtpTerminate */


HRESULT
attachMessageData(
    IN OUT CComPtr<IMessage> pIMsg,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

    Attach the ISM message data.

Arguments:

    pIMsg - 
    pMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<_Stream> pStream;
    CComPtr<IBodyPart> pIBodyPart;
    VARIANT vBuffer;
    SAFEARRAY *psaData = NULL;

    // Allocate an array to describe the binary data
    hr = SafeArrayAllocDescriptor( 1, &psaData );
    if FAILED(hr) {
        DPRINT1(0, "Unable to SafeArrayAllocDescriptor, error 0x%x.\n", hr);
        LogUnhandledError( hr );
        goto exit;
    }

    // Initialize the array.  We construct the array manually so we can use
    // our own data which has been already allocated.
    psaData->cbElements = sizeof( char );
    psaData->pvData = pMsg->pbData;
    psaData->rgsabound[0].lLbound = 0;
    psaData->rgsabound[0].cElements = pMsg->cbData;

    // Set the body part options for binary data

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if FAILED(hr) {
        DPRINT1(0, "Unable to get_BodyPart, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentTransferEncoding(cdoBase64);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentTransferEncoding, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentMediaType(cdoGif);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentMediaType, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if FAILED(hr) {
        DPRINT1(0, "Unable to GetDecodedContentStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->put_Type(adTypeBinary);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Type, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Write the binary data into the body
    VariantInit( &vBuffer );
    vBuffer.vt = VT_ARRAY | VT_UI1;
    vBuffer.parray = psaData;

    hr = pStream->Write(vBuffer);
    if FAILED(hr) {
        DPRINT1(0, "Unable to WriteStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->Flush();
    if FAILED(hr) {
        DPRINT1(0, "Unable to Commit, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

exit:

    if (psaData != NULL) {
        HRESULT hr1;

        psaData->pvData = NULL;
        hr1 = SafeArrayDestroyDescriptor( psaData );
        if (FAILED(hr1)) {
            DPRINT1(0, "Unable to SafeArrayDestroyDescriptor, error 0x%x.\n", hr);
            LogUnhandledError( hr1 );
        }
    }

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* attachMessageData */


HRESULT
getDropMessages(
    BSTR bstrDropDirectory,
    IDropDirectory **ppIDropDir,
    IMessages **ppIMessages,
    LONG *pCount
    )

/*++

Routine Description:

Helper routine to initialize a drop directory object, get the message
collection, and get the count of messages.

Note, drop directory and message collection must be freed by the caller!

Arguments:

    ppIDropDir - Returned pointer to drop directory object
    ppIMessages - Return pointer to message collection
    pCount - Returned count of messgaes

Return Value:

    HRESULT - 

--*/

{
    HRESULT     hr;

    Assert( ppIDropDir );
    Assert( ppIMessages );
    Assert( *ppIDropDir == NULL );
    Assert( *ppIMessages == NULL );

    // Create the drop directory object
    hr = CoCreateInstance(CLSID_DropDirectory, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDropDirectory,
                          (void**) ppIDropDir);
    if (FAILED(hr)) {
        DPRINT1(0, "CoCreateInstance(DropDirectory) failed, error 0x%x\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get the object representing the list of all messages

    hr = (*ppIDropDir)->GetMessages(bstrDropDirectory, ppIMessages);
    if (FAILED(hr)) {
        DPRINT1(0, "getMessages() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    
    // Get count of messages

    *pCount = 0;
    hr = (*ppIMessages)->get_Count( pCount );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Count() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    DPRINT2( 1, "Found %d messages in the drop directory %ws\n",
             *pCount, bstrDropDirectory ? bstrDropDirectory : L"default" );

    return S_OK;

cleanup:

    if (*ppIMessages) {
        (*ppIMessages)->Release();
        *ppIMessages = NULL;
    }
    if (*ppIDropDir) {
        (*ppIDropDir)->Release();
        *ppIDropDir = NULL;
    }

    return hr;
} /* getDropMessages */


DWORD
SmtpSend(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

   Send a message using the smtp transport.
   Message is sent as a binary blob.

   Our approach is to keep the dll running even when the smtp service is
   not running.  The dll can operate without the smtp
   service running since the CDO library only uses the file system for
   communication.

   We check for valid conditions when the ism server tries to use the dll
   for sending or receiving.

CDO provides three ways to send a message:
1. Send by pickup directory.  That is the default and what we are doing.  The
mail is actually "relayed", in the sense that it is received by here, queued,
and sent to the destination when possible.  Triggers OnArrival routine as
a mail receiption on localhost as well as ultimate destination host.
Benefit: if the destination is down, it will resend.
2. Send to local host and port.  Same as #1. The mail is received, queued, and
sent on when possible.
3. Send to destination host, using port number. The destination must be up.
OnArrival routine on triggered on destination.  No queuing on localhost.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pMsg - 

Return Value:

    DWORD - 

--*/

{
    DWORD       status;
    HRESULT     hr;
    LPWSTR      pszSubject, pszMessageSubject, pszServer;
    DWORD       cchSubject;
    CComPtr<IMessage> pIMsg;
    BSTR bstrFrom = NULL, bstrTo = NULL, bstrSubj = NULL;

    if ( (!pTransport) ||
         (!pszRemoteTransportAddress) ||
         (!pszServiceName) ||
         (!pMsg) ) {
        status = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( status );
        return status;
    }

    DPRINT4( 1, "SmtpSend, addr = %ws, serv = %ws, subj = %ws, size = %d\n",
             pszRemoteTransportAddress,
             pszServiceName,
             pMsg->pszSubject,
             pMsg->cbData );

    MEMORY_CHECK_ALL();

    // If we don't have a mail address, try to auto configure
    // A mailAddress attribute has to have been written in order for the KCC
    // to have created a mail-based replica.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if ( ( hr == S_OK ) &&
         ( NULL == pTransport->Smtp.pszSmtpAddress ) ) {
        // SMTP not installed
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_DOES_NOT_EXIST );
    }

    if (FAILED(hr)) {
        static DSTIME timeLastNoSmtpLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastNoSmtpLogged)
            || (timeCurrent > (timeLastNoSmtpLogged + NO_SMTP_DOMAIN_INTERVAL))) {

            // Log event to alert admin we have no SMTP transport
            timeLastNoSmtpLogged = timeCurrent;
            DPRINT( 0, "Cannot send: SMTP transport not installed.\n" );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
        return hr;
    }

    // CDO does not depend on any services to queue the message.
    // Some service needs to be running in order for the messages to get off
    // the machine.
    // That service could be SmtpSvc or Exchange

//***************************************************************************

    // Create an instance of the message object
    hr = CoCreateInstance(CLSID_Message, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IMessage,
                          (void**) &pIMsg);
    if FAILED(hr) {
        DPRINT1(0, "Unable to create CLSID_Message object, error 0x%x.\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto exit;
    }

    Assert( pTransport->Smtp.pszSmtpAddress );
    // Set the 'From' property.
    bstrFrom = SysAllocString( pTransport->Smtp.pszSmtpAddress );
    if (bstrFrom == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }

    hr = pIMsg->put_From( bstrFrom );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_From, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Determine the server to send to
    pszServer = wcschr( pszRemoteTransportAddress, L'@' );
    if (pszServer == NULL) {
        DPRINT1( 0, "Remote transport address %ws is malformed\n",
                 pszRemoteTransportAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto exit;
    }
    pszServer++;  // Skip separator

    // Set the 'To' property.
    bstrTo = SysAllocString( pszRemoteTransportAddress );
    if (bstrTo == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate to bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_To( bstrTo );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_To, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // This field may be null
    pszMessageSubject = pMsg->pszSubject ? pMsg->pszSubject : L"";

    // Set the 'Subject' property.
    cchSubject = gcchSubjectFormat +
        wcslen(pszServiceName) + wcslen( pszMessageSubject );

    __try {
        pszSubject = (LPWSTR) alloca(cchSubject * sizeof(*pszSubject));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    swprintf(pszSubject, gszSubjectFormat, pszServiceName, pszMessageSubject);

    bstrSubj = SysAllocString( pszSubject );
    if (bstrSubj == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate subj bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_Subject( bstrSubj );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Subject, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Attach the data

    hr = attachMessageData( pIMsg, pMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to attach message data, error 0x%x.\n", hr);
        // Event already logged at lower layer
        goto exit;
    }

    hr = supersedeMessage( pTransport,
                           pszRemoteTransportAddress,
                           pszServiceName,
                           pszMessageSubject,
                           pIMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to supersede message, error 0x%x.\n", hr);
        // Keep going, not fatal
    }

//***************************************************************************

    // Serialize access to queue directory, by this dll anyway
    EnterCriticalSection(&QueueDirectoryLock);
    __try {

        // queue the message locally
        hr = pIMsg->Send();
    }
    __finally {
        LeaveCriticalSection(&QueueDirectoryLock);
    }

    if (FAILED(hr)) {
        DPRINT1(0, "Unable to Send(), error 0x%x.\n", hr);
        // Error will be logged at a higher level
        goto exit;
    }

exit:

    if (bstrFrom) {
        SysFreeString( bstrFrom );
    }
    if (bstrTo) {
        SysFreeString( bstrTo );
    }
    if (bstrSubj) {
        SysFreeString( bstrSubj );
    }

    MEMORY_CHECK_ALL();

    // IsmServ will log the send failure

    if (pIMsg) {
        pIMsg = NULL;
    }

    return hr;
} /* SmtpSend */



HRESULT
getIsmMsgFromAttachment(
    CComPtr<IMessage> pIMsg,
    OUT ISM_MSG **  ppMsg,
    LPWSTR pszMessageSubject
    )

/*++

Routine Description:

Read the contents of a message.  The message is read into the message
descriptor

Arguments:

    pIMsg - CDO message object
    ppMsg - New message descriptor allocated to repesent the decoded message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IBodyPart> pIBodyPart;
    CComPtr<_Stream> pStream;
    VARIANT vBuffer;
    SAFEARRAY *psaData;
    ULONG cbData, cbDataAligned, len, subjectLength;
    BYTE *ptr;
    int i = 0;
    
    if (!pszMessageSubject) {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( hr );
        return hr;
    }

    DPRINT1( 4, "getIsmMsgFromAttachment, subj=%ws\n", pszMessageSubject );

    VariantInit( &vBuffer );

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if (FAILED(hr)) {
        DPRINT1(0, "get_BodyPart() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pStream->Read(adReadAll, &vBuffer);
    if (FAILED(hr)) {
        DPRINT1(0, "Read() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (vBuffer.vt != (VT_ARRAY | VT_UI1)) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, Body part type %d was not expected!\n",
                vBuffer.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    psaData = vBuffer.parray;
    cbData = psaData->rgsabound[0].cElements;
    cbDataAligned = ROUND_UP_COUNT( cbData, ALIGN_WCHAR );

    subjectLength = wcslen( pszMessageSubject );

// wlees Sep 1, 1998. Getting mysterious AVs while freeing messages. Switch
// to simpler buffer management until we can track this down

#ifdef NO_COPY
// Minimize the number of data copies by extracting the binary data right out
// of the returned safe array.  We free the array descriptor manually.  Later,
// when we free the message, we use the right OLE api to free the data

    // Allocate an ISM_MSG to hold the data
    *ppMsg = NEW_TYPE( ISM_MSG );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }

    // Steal the data chuck out of the safe array.

    (*ppMsg)->cbData = cbData;
    (*ppMsg)->pbData = (BYTE *) psaData->pvData;

    // Free the descriptor manually.

    psaData->rgsabound[0].cElements = 0;
    psaData->pvData = NULL;

    hr = SafeArrayDestroyDescriptor( psaData );
    if (FAILED(hr)) {
        DPRINT1(0, "SafeArrayDestroyDescriptor() failed, error 0x%x\n", hr);
        // keep going
    }

    // No need to free this now
    vBuffer.vt = VT_EMPTY;
    vBuffer.parray = NULL;

    // Allocate a subject
    (*ppMsg)->pszSubject = NEW_TYPE_ARRAY( subjectLength + 1, WCHAR );
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );

#else
    // Allocate a buffer for the ISM_MSG, the data, and the subject string
    len = sizeof( ISM_MSG ) + 
        cbDataAligned +
        (subjectLength + 1) * sizeof( WCHAR );
    *ppMsg = (ISM_MSG *) NEW_TYPE_ARRAY( len, CHAR );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    (*ppMsg)->cbData = cbData;
    ptr = (BYTE *) &( (*ppMsg)[1] ); // point past struct
    (*ppMsg)->pbData = ptr;
    // PERF: this is a data copy
    memcpy( ptr, psaData->pvData, cbData );
    ptr += cbDataAligned;
    Assert( POINTER_IS_ALIGNED( ptr, ALIGN_WCHAR ) );
    (*ppMsg)->pszSubject = (LPWSTR) ptr;
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );
#endif

    hr = NOERROR;

cleanup:

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    if (vBuffer.vt != VT_EMPTY) {
        VariantClear( &vBuffer );
    }

    if FAILED(hr) {
        Assert(NULL == *ppMsg);
    }
    else {
        Assert(NULL != *ppMsg);
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "NTDS ISM SMTP failed to read a message stream, error 0x%x\n", hr );
    }

    return hr;
} /* getIsmMsgFromAttachment */


VOID
SmtpFreeMessage(
    IN ISM_MSG *pMsg
    )

/*++

Routine Description:

Free the message alllocated by SmtpReceive.

This routine has the actual knowledge of how the data should be deallocated.

Arguments:

    pMsg - ism message descriptor

Return Value:

    None

--*/

{
    HRESULT hr;
    SAFEARRAY saData;

    Assert( pMsg );
    Assert( pMsg->pbData );

    DPRINT1( 3, "SmtpFreeMessage, size = %d\n", pMsg->cbData );

#ifdef NO_COPY
    // Whip up a phony safe array descriptor to describe the data
    // Try to use it to deallocate the data
    // Hope that this descriptor is close enough to the one originally
    // allocated.  Note if we have problems, we may need to see what the
    // "features" field had at time of allocation, and set accordingly.

    ZeroMemory( &saData, sizeof( SAFEARRAY ) );
    saData.cDims = 1;
    saData.cbElements = sizeof( char );
    saData.pvData = pMsg->pbData;
    saData.rgsabound[0].lLbound = 0;
    saData.rgsabound[0].cElements = pMsg->cbData;

    hr = SafeArrayDestroyData( &saData );
    if (FAILED(hr)) {
        DPRINT1( 0, "SafeArrayDestroyData failed with error 0x%x\n", hr );
    }

    if (pMsg->pszSubject) {
        FREE_TYPE( pMsg->pszSubject );
    }
#else
    // In this mode, data allocated with the msg descriptor
#endif

    pMsg->cbData = 0;
    pMsg->pbData = NULL;

    FREE_TYPE( pMsg );

} /* SmtpFreeMessage */


BOOL
messageIsDuplicate(
    PGUID_TABLE pGuidTable,
    BSTR bstrFrom,
    BSTR bstrSubject,
    IMessage *pIMsg
    )

/*++

Routine Description:

We can take advantage of the fact that all messages have a message guid, and that
retried messages have a supersedes guid.  As we receive messages, we record the
message guid in a guid table.  The guid table is only for the current drop
directory.  If the message we receive has a supersedes guid, we check to see if
that superseded guid is in the table.  If so, then we have recently seen the
predecessor of the current message, and we do not have to process the current
message.

The reason that we only consider messages in the current drop directory to be
candidates for recently seen messages is that mail delivery is unreliable.  The
fact that we have seen a request mail doesn't mean the reply was delivered.  The
requestor may send us the same request again for legitimate reasons and we
don't want to drop it on the floor.  The current drop directory becomes a kind
of simple grouping mechanism: all messages in the same drop directory instance
we received together in time and can be treated as equivalent.

Arguments:

    pGuidTable - Table of guid's recently seen
    bstrFrom - From field from message
    bstrSubject - Subject field from message
    pIMsg - Current message object

Return Value:

    BOOL - 

--*/

{
    HRESULT hr;
    BOOL fResult = FALSE;   // say no if not sure
    CComPtr<Fields> pFields;
    GUID guidMessage, guidSupersedes;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Record that we have seen this message
    // Note that we record the message as seen regardless of whether we later
    // decide to discard it as a duplicate.  This is because of the transitive
    // nature of the supersedes guid:
    // message A
    // message B, supersedes A
    // message C, supersedes B
    // A is accepted, B is a duplicate of A, and in order to suppress C,
    // we must note B as seen, which it was transitively.

    hr = getFieldGuid( pFields, SMTP_MSG_GUID, &guidMessage );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // If the message has a guid
    if (memcmp( &guidMessage, &zeroGuid, sizeof(GUID) ) != 0) {
        // Insert in table of guids that have been seen
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidMessage, &pszUuid );
        DPRINT1( 4, "Message contains messageGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (!SmtpGuidInsertInTable( pGuidTable, &guidMessage )) {
            DPRINT( 0, "Failed to insert msg guid into table\n" );
            // Keep going
        }
    } else {
        DPRINT2( 0, "Warning: Message from %ws, subject %ws lacks a message guid.\n",
                 bstrFrom, bstrSubject );
    }

    // See if there is a supersedes guid in the message
    hr = getFieldGuid( pFields, SMTP_SUPERSEDES_MSG_GUID, &guidSupersedes );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (memcmp( &guidSupersedes, &zeroGuid, sizeof(GUID) ) != 0) {
        // See if we've seen the prior message
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidSupersedes, &pszUuid );
        DPRINT1( 4, "Message contains supersedesGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (SmtpGuidPresentInTable( pGuidTable, &guidSupersedes )) {
            // It is a duplicate of a message we have seen recently
            fResult = TRUE;
            goto cleanup;
        }
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return fResult;
} /* messageIsDuplicate */



HRESULT
parseDeliveryStatus(
    CComPtr<IBodyPart> pBodyPart,
    LPWSTR pszExpectedContentType,
    BSTR *pbstrText
    )

/*++

Routine Description:

This is a helper routine to parse the delivery status section of a
delivery status report.

Arguments:

    pBodyPart - 
    pszExpectedContentType - 
    pbstrText - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrContentType = NULL;
    CComPtr<_Stream> pStream;
    StreamTypeEnum streamType;
    DWORD length;
    BSTR bstrCharset = NULL;

    hr = pBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (_wcsicmp( bstrContentType, pszExpectedContentType ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", pszExpectedContentType, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the content stream
    hr = pBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the stream type
    hr = pStream->get_Type( &streamType );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Type() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (streamType != adTypeText) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, ndr, Stream type %d was not expected!\n",
                streamType );
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the character set.  Adjust if not correct.
    // This works around a problem where body parts are incorrectly marked
    // with the wrong character set.
    hr = pStream->get_Charset( &bstrCharset );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Charset() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    if (_wcsicmp( bstrCharset, cdoISO_8859_1 ) != 0) {
        SysFreeString(bstrCharset);
        bstrCharset = SysAllocString( cdoISO_8859_1 );
        if (bstrCharset == NULL) {
            hr = E_OUTOFMEMORY;
            DPRINT( 0, "Failed to allocate from bstr\n" );
            LogUnhandledError( hr );
            goto cleanup;
        }
        hr = pStream->put_Charset( bstrCharset );
        if (FAILED(hr)) {
            DPRINT1(0, "set_Charset() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Read it into a bstr
    hr = pStream->ReadText( adReadAll, pbstrText );
    if (FAILED(hr)) {
        DPRINT1(0, "ReadText(All) failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:
    if (bstrCharset) {
        SysFreeString(bstrCharset);
    }

    if (bstrContentType) {
        SysFreeString(bstrContentType);
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* parseDeliveryStatus */


HRESULT
parseNondeliveryReport(
    BSTR bstrSubject,
    CComPtr<IMessage> pIMsg
    )

/*++

Routine Description:

Decode a Nondelivery report.  It is encoded as a hierarchy of body parts:

root body part
   body part 1 - plain text, the session transcript
   body part 2 - message/delivery-status
         ... n-1
   body part n - message/rfc822, the original message

Warning, this may change in the future.  To accomodate this, we don't log
when we encounter unexpected syntax.  We simply stop parsing.  The caller
won't delete the report and the user can dispose of it himself. Note that we
do log function errors, since they should not happen.

We are only interested in the first and second parts

Arguments:

    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
#define CDO_CONTENT_TYPE_MULTIPART_REPORT L"multipart/report"
#define CDO_CONTENT_TYPE_DELIVERY_STATUS L"message/delivery-status"
    DWORD win32Status;
    HRESULT hr;
    LONG count, i;
    CComPtr<IBodyPart> pRootBodyPart;
    CComPtr<IBodyParts> pBodyParts;
    BSTR bstrContentType = NULL;

    CComPtr<IBodyPart> pBodyPart;
    BSTR bstrText = NULL;
    LPWSTR pwzErrorString;

    // Get the root body part
    hr = pIMsg->get_BodyPart(&pRootBodyPart);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get root body part, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get content type of whole message
    hr = pRootBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // It better be a multi-part report
    if (_wcsicmp( bstrContentType, CDO_CONTENT_TYPE_MULTIPART_REPORT ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", CDO_CONTENT_TYPE_MULTIPART_REPORT, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the collection of 1st level body parts
    hr = pRootBodyPart->get_BodyParts(&pBodyParts);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_BodyParts, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // See how many there are
    hr = pBodyParts->get_Count(&count);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_Count, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Should be atleast one
    if (count < 3) {
        hr = E_INVALIDARG;
        DPRINT( 0, "Malformed DSN doesn't have enough parts!\n" );
        // Do not log
        goto cleanup;
    }

    //DPRINT1( 0, "NDR has %d body parts\n", count );

// ***********************************************************************

    DPRINT1( 1, "ISM SMTP %ws:\n", bstrSubject );

    // Skip the first and the last

    count--;
    for( i = 2; i <= count; i++ ) {
        pBodyPart = NULL;
        bstrText = NULL;

        hr = pBodyParts->get_Item(i,&pBodyPart);
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to get_Item, error 0x%x\n", hr );
            LogCdoError( hr );
            goto loop_cleanup;
        }

        hr = parseDeliveryStatus( pBodyPart,
                                  (i == 1) ?
                                  cdoTextPlain :
                                  CDO_CONTENT_TYPE_DELIVERY_STATUS,
                                  &bstrText );
        if (FAILED(hr)) {
            DPRINT1( 0, "parseDeliveryStatus failed, error 0x%x\n", hr );
            // don't log
            goto loop_cleanup;
        }

        // This string is static and doesn't need to be freed
        pwzErrorString = parseStatus( bstrText, &win32Status );

        DPRINT4( 1, "\t(%d): Status: 0x%x - %ws\nText: %ws\n",
                 i, win32Status, pwzErrorString, bstrText );

        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_DSN,
                  szInsertWin32Msg(win32Status),
                  szInsertWC(pwzErrorString),
                  szInsertWC(bstrText),
                  szInsertWin32ErrCode(win32Status),
                  NULL, NULL, NULL, NULL );


    loop_cleanup:
        pBodyPart = NULL;
        if(bstrText)
        {
            SysFreeString(bstrText);
        }
    }

    hr = S_OK;

cleanup:

    if(bstrContentType)
    {
        SysFreeString(bstrContentType);
    }

    pBodyParts = NULL;
    pRootBodyPart = NULL;

    return hr;
} /* parseNondeliveryReport */


HRESULT
scanMessages(
    IN TRANSPORT_INSTANCE *pTransport,
    IN IMessages *pIMessages,
    IN  LPCWSTR pszServiceName,
    IN OUT LONG *plCount,
    IN OUT PGUID_TABLE pGuidTable,
    OUT ISM_MSG **ppMsg
    )

/*++

Routine Description:

Enumerate the messages in the drop directory.  Return the first one.
Duplicates are eliminated as they are encountered in the drop directory.

If we encounter any nondelivery reports for ISM messages, we log and delete.

We loop through the messages in the drop directory.  We read the first message
each time.  At the end of the loop we delete the first message, making the
next one the first.  If we can dispose of the message in the loop because
it is a notification or a duplicate, we do so.  On the first valid message, we
break out of the loop and return.  If we can't read a message, we log an event
and delete it.

There is no notion of skipped messages. We don't track unreadable messages still
in the collection. Our current reading position is always at the start and we
expect we can delete each message as we go.  There are no errors returned out of this
routine. We always delete the message or return it.  When we exit the routine
there are no messages left, or we are returning a valid message.

Arguments:

    pTransport - Transport object
    pIMessages - Collection of messages
    pszServiceName - Name of server we are looking for
    plCount - Pointer to count of how many left to read. This is updated
               as we read each so we don't read them again next time
    pGuidTable - pointer to guid table to track duplicates
    ppMsg - Pointer to receive a message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr, hr1;
    CComPtr<IMessage> pIMsg;
    BSTR bstrSubject, bstrTo, bstrFrom;
    LPWSTR pszMsgForServiceName, pszMessageSubject;
    BOOL done, exitScan;

    DPRINT1( 2, "scanning message collection entry, %d unread\n", *plCount );

    Assert( pIMessages );
    Assert( plCount );
    Assert( *plCount >= 1 );
    Assert( ppMsg );
    Assert( *ppMsg == NULL );

    // Initial conditions: not done, not busy and atleast one message

    // Note the structure of this loop.  We have to go through the next_
    // message processing at the bottom to free the resources.  The only way
    // out is through the for test at the bottom of the loop.

    done = exitScan = FALSE;
    do {
        DWORD busyTries = 0, waitCode;
        bstrSubject = bstrTo = bstrFrom = NULL;

        // We always read the first message
        // Each time we delete message 1, moving the rest up

        // If shutdown detected exit immediately
        if (pTransport->fShutdownInProgress) {
            DPRINT(2, "Message was skipped due to shutdown\n");
            hr = S_OK;
            exitScan = TRUE;
            goto next_message;
        }

        // NOTE: Busy retry loop could be avoided with an improved ismsink.dll
        // paragdigm -- see bug 88430: ISM SMTP sink should pre-process received
        // messages.
        
        // Read a message with retry
        // Deal with contention with writer process. This is a fact of life since
        // we will try to read a new file as soon as it appears in the directory.
        
        while (1) {
            hr = pIMessages->get_Item(1,&pIMsg);
            if (FAILED(hr)) {
                DPRINT1(0, "get_Item(1) failed, error 0x%x\n", hr);
                LogCdoError( hr );
                goto next_message;
            }

            // This is the first field we read from the message. If something is going
            // to fail, this is where it happens
            hr = pIMsg->get_To( &bstrTo );

            // Workaround. It appears that CDO will succeed with an empty value
            // when there is a sharing violation. However, it is also possible that
            // the message simply does not have a To field. We have no way of
            // distinguishing these two cases.
            if ( (SUCCEEDED(hr)) && ((bstrTo == NULL) || (wcslen(bstrTo) == 0)) ) {
                DPRINT( 1, "get_To returned empty string, treating as busy.\n" );
                hr = HR_SHARING_VIOLATION;
            }

            if ( (hr != HR_SHARING_VIOLATION) ||
                 (busyTries > 4) ||
                 (pTransport->fShutdownInProgress) ) {
                break;
            }
            busyTries++;
            DPRINT1( 1, "get_To returned busy, try %d\n", busyTries );
            pIMsg = NULL; // Cleanup old instance
            // Sleep while watching for shutdown
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
            if (waitCode == WAIT_OBJECT_0) {
                // Shutdown detected.
                exitScan = TRUE;
                break;
            }
        }
        if (FAILED(hr)) {
            if (hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                // We failed to read the To field, either due to a sharing violation
                // or due to non-existence of a To field. We will try to delete this
                // message below. If the message really was busy then the delete
                // should fail (although admittedly this is a race condition). If the
                // message did not have a To field then it is invalid and should be deleted.
                DPRINT(2, "Message was skipped due to a sharing violation or no To field\n");
                hr = S_OK;
            } else {
                DPRINT1(0, "get_To() failed, error 0x%x\n", hr);
                LogCdoError( hr );
            }
            goto next_message;
        }
        if ( (bstrTo == NULL) || (wcslen( bstrTo ) == 0) ) {
            DPRINT( 0, "To: field in Ism Message is empty\n" );
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        hr = pIMsg->get_Subject( &bstrSubject );
        if (FAILED(hr)) {
            DPRINT1(0, "get_Subject() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrSubject == NULL) || (wcslen( bstrSubject ) == 0) ) {
            DPRINT( 0, "Subj: field in Ism Message is empty\n" );
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        hr = pIMsg->get_From( &bstrFrom );
        if (FAILED(hr)) {
            DPRINT1(0, "get_From() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrFrom == NULL) || (wcslen( bstrFrom ) == 0) ) {
            DPRINT( 0, "From: field in Ism Message is empty\n" );
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        // See if the message is addressed to us
        if (!mailAddressMatch( bstrTo, pTransport->Smtp.pszSmtpAddress )) {
            DPRINT1( 0, "Ism Message not addressed to this DSA: %ws\n", bstrTo );
            // We wouldn't be finding the message unless the @domain portion of
            // the address matches. Mail being sent to the wrong user?
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        // Sanity check subject for basic syntax
        if (_wcsnicmp(bstrSubject, SUBJECT_PREFIX, SUBJECT_PREFIX_LEN) != 0) {

            // Check for delivery status report
            hr = parseNondeliveryReport( bstrSubject, pIMsg );
            if (SUCCEEDED(hr)) {
                goto next_message;
            }

            // Not an ISM message.
            DPRINT3(0, "IsmSmtp: Ignoring non-ISM message to %ws from %ws with subject \"%ls\".\n",
                    bstrTo, bstrFrom, bstrSubject);
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        // Check if message is a recently seen duplicate
        if (messageIsDuplicate(
            pGuidTable,
            bstrFrom,
            bstrSubject,
            pIMsg)) {

            DPRINT2( 1, "Duplicate message suppressed: From: \"%ws\", Subject: \"%ws\"\n",
                     bstrFrom, bstrSubject );

            // Note that we can get into a tight loop identifying and
            // deleting duplicates if there are many of them. This will be
            // true if the machine has been down or the ismserv had been
            // stopped. We will detect shutdown above. Do we need to return
            // the thread to the ismserv after every x messages so we don't
            // hog the thread?

            goto next_message;
        }

        // Looks like an ISM message.
        pszMsgForServiceName = bstrSubject + SUBJECT_PREFIX_LEN;
        pszMessageSubject = wcsstr( pszMsgForServiceName, SUBJECT_SEPARATOR );
        if (!pszMessageSubject) {
            // malformed subject line
            DPRINT1( 0, "Ism message subject line is malformed: %ws\n",
                     pszMsgForServiceName );
            hr = HR_INVALID_DATA;
            goto next_message;
        }
        *pszMessageSubject = L'\0';
        pszMessageSubject += SUBJECT_SEPARATOR_LEN; // Skip over

        DPRINT2(3, "Message appears to be for service \"%ls\", from %ws.\n",
                pszMsgForServiceName, bstrFrom);

        // It is implicit in the design of this message loop that there is only
        // one type of service per drop directory.  This is fine in product 1
        // where the only client of ISM SMTP is NTDS Replication.  In the future we
        // will need to have child drop directories, one per service.  This is not
        // hard: the sink needs to save the incoming message in the right child.
        // That means we don't need a private domain either.
        if (_wcsicmp(pszServiceName, pszMsgForServiceName)) {
            // Not for us
            DPRINT1( 0, "Ism message is in wrong drop directory, claiming to be for service %ws\n", pszMsgForServiceName );
            hr = HR_INVALID_DATA;
            goto next_message;
        }

        hr = getIsmMsgFromAttachment( pIMsg, ppMsg, pszMessageSubject );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to decode message, error 0x%x\n", hr );
            goto next_message;
        }

        Assert( *ppMsg );
        DPRINT3( 1, "SmtpReceive, from %ws, subj %ws, size %d bytes.\n",
                pszServiceName, (*ppMsg)->pszSubject, (*ppMsg)->cbData );

        done = TRUE;

    next_message:

        // Log an event on failure to read a message
        // Note, pIMsg may be NULL at this point
        // The insert params are in this order for compat with prev releases
        if (FAILED(hr)) {
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_MSG_UNREADABLE,
                      szInsertUL(1),
                      szInsertWC( pTransport->Smtp.bstrDropDirectory ),
                      szInsertWin32Msg(hr),
                      szInsertHResultCode(hr),
                      szInsertWC( bstrTo ),
                      szInsertWC( bstrFrom ),
                      szInsertWC( bstrSubject ),
                      NULL );
        }

        if( ! exitScan ) {
            // Try to remove a message we read. If we fail, abort the message scan.
            hr1 = pIMessages->Delete( 1 );
            if (SUCCEEDED(hr1))
            {
                (*plCount)--;
            } else {
                // Note we can be in the strange position of having a valid message
                // but not being able to delete it.  We don't want to return a
                // message we can't delete, since we will read it again, causing
                // duplicates.
                DPRINT1(0, "Delete() failed, error 0x%x\n", hr1);
                if (hr1 != HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                    LogEvent8(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_SMTP_MSG_DELETE_FAILURE,
                              szInsertUL(1),
                              szInsertWC( pTransport->Smtp.bstrDropDirectory ),
                              szInsertWin32Msg(hr1),
                              szInsertHResultCode(hr1),
                              szInsertWC( bstrTo ),
                              szInsertWC( bstrFrom ),
                              szInsertWC( bstrSubject ),
                              NULL );
                }
                done = FALSE;  // don't return message
                exitScan = TRUE;   // exit message loop
            }
        }

        // Since this can take a while to work through a large backlog, let
        // the user know the progress we've made
        if ( ( *plCount >= 1 ) && ((*plCount % 50) == 0) ) {
            DPRINT1( 0, "There are %d SMTP messages remaining to be processed.\n",
                     *plCount );

            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ISM_SMTP_MESSAGE_COUNT,
                     szInsertUL(*plCount),
                     szInsertWC(pTransport->Smtp.bstrDropDirectory),
                     NULL );
        }

        // Clean up if necessary

        if ( (!done) && (*ppMsg) ) {
            SmtpFreeMessage( *ppMsg );
            *ppMsg = NULL;
        }

        if (pIMsg) {
            pIMsg = NULL;
        }

        if (bstrSubject != NULL) {
            SysFreeString( bstrSubject );
        }
        if (bstrTo != NULL) {
            SysFreeString( bstrTo );
        }
        if (bstrFrom != NULL) {
            SysFreeString( bstrFrom );
        }
    }
    while ((!done) && (!exitScan) && (*plCount));

    // Termination conditions:
    Assert( (*plCount == 0) ||
            (done) && (*ppMsg) ||
            (exitScan)
        );

    DPRINT1( 2, "scanning message collection exit, %d remaining\n", *plCount );

    hr = S_OK;

    return hr;

} /* scanMessages */


HRESULT
getMailMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

This is a wrapper around the scanMessages function.  It handles
caching of the current collection.  We only get a collection once from the
drop directory, and eliminate duplicates once.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IDropDirectory> pIDropDir;
    IMessages *pIMessages =
        (IMessages *) pTransport->Smtp.pvCurrentCollection;
    PGUID_TABLE pGuidTable = (PGUID_TABLE) pTransport->Smtp.pvGuidTable;

    Assert( ppMsg );
    Assert( *ppMsg == NULL );   // we don't have a message yet

    // If we already have a collection in progress, use it
    if (pIMessages) {

        hr = scanMessages(
            pTransport,
            pIMessages,
            pszServiceName,
            &(pTransport->Smtp.lCount),
            pGuidTable,
            ppMsg );

        // If we got a message, return it
        if ( (SUCCEEDED(hr)) && (*ppMsg) ) {
            goto cleanup;
        }

        // No message left in current collection, get rid of it
        pIMessages->Release();
        pIMessages = NULL;
        pTransport->Smtp.lCount = 0;
        SmtpDestroyGuidTable( pGuidTable);
        pGuidTable = NULL;
    }

    // We don't have a current collection
    Assert( pTransport->Smtp.lCount == 0);

    // Get the collection of messages
    hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                          &pIDropDir,
                          &pIMessages,
                          &(pTransport->Smtp.lCount) );
    if (FAILED(hr)) {
        DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
        // Status already logged
        goto cleanup;
    }

    Assert( pIDropDir );
    Assert( pIMessages );

    // The way the notification mechanism works, we may receive a notification
    // before the file appears in the drop directory. We delay here in order
    // to give time for the file to arrive.  A better approach would be to have
    // the sink write the file itself before signalling the event.
    //
    // See bug 88430: ISM SMTP sink should pre-process received messages.

    // Only wait when no messages pending, so that under load we pay no penelty
    if (pTransport->Smtp.lCount == 0) {
        DWORD waitCode;

        // Call destructors
        pIMessages->Release();
        pIMessages= NULL;
        pIDropDir = NULL;

        // Sleep( 10 * 1000 ) while waiting for shutdown
        waitCode = WaitForSingleObject( pTransport->hShutdownEvent, 10 * 1000 );
        if (waitCode == WAIT_OBJECT_0) {
            // Shutdown requested
            hr = S_OK;
            goto cleanup;
        }

        hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                              &pIDropDir,
                              &pIMessages,
                              &(pTransport->Smtp.lCount) );
        if (FAILED(hr)) {
            DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
            // Message already logged
            goto cleanup;
        }

        Assert( pIMessages );

        // Sorry, no mail today
        if (pTransport->Smtp.lCount == 0) {
            hr = S_OK;
            goto cleanup;
        }
    }

    Assert( pTransport->Smtp.lCount >= 1 );

    // Create a new guid table for tracking duplicates
    pGuidTable = SmtpCreateGuidTable();
    if (pGuidTable == NULL) {
        DPRINT( 0, "failed to allocate guid table\n" );
        hr = HR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Try to get one out
    hr = scanMessages(
        pTransport,
        pIMessages,
        pszServiceName,
        &(pTransport->Smtp.lCount),
        pGuidTable,
        ppMsg );

cleanup:

    // Update context
    if ( (SUCCEEDED(hr)) &&
         (pTransport->Smtp.lCount > 0) ) {
        pTransport->Smtp.pvCurrentCollection = pIMessages;
        pIMessages = NULL;  // don't free
        pTransport->Smtp.pvGuidTable = pGuidTable;
        pGuidTable = NULL; // don't free
    } else {
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
        pTransport->Smtp.pvGuidTable = NULL;
    }

    // Free resources if necessary
    if (pIMessages) {
        pIMessages->Release();
        pIMessages= NULL;
    }

    if (pIDropDir) {
        pIDropDir = NULL;
    }

    if (pGuidTable) {
        SmtpDestroyGuidTable( pGuidTable );
        pGuidTable = NULL;
    }

    return hr;
} /* getMailMessage */


DWORD
SmtpReceive(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

API called by the server to retrieve a message.

This routine needs to return success if we are not configured yet.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - pointer to receive allocated message structure
    If NULL, notify instead of return a message

Return Value:

    DWORD - 

--*/

{
    HRESULT     hr;
    DWORD       winError;

    DPRINT1( 3, "SmtpReceive, serv = %ws\n", pszServiceName );

    MEMORY_CHECK_ALL();

    if ( (NULL == ppMsg) ||
         (NULL == pszServiceName) ) {
        return E_INVALIDARG;
    }

    // Default to "none waiting."
    *ppMsg = NULL;

    // If not configured, try to do so now
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to configure mail address, error 0x%x\n", hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        return hr;
    }

    // Smtp not installed, its ok
    if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
        DPRINT( 3, "SMTP not present, returning no messages\n");
        return S_OK;
    }

    // Synchronize access to drop directory

    EnterCriticalSection(&DropDirectoryLock);
    __try {
        hr = getMailMessage( pTransport, pszServiceName, ppMsg );
    }
    __finally {
        LeaveCriticalSection(&DropDirectoryLock);
    }

    MEMORY_CHECK_ALL();

    return hr;
} /* SmtpReceive */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\common.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       common.c
//
//--------------------------------------------------------------------------

/*
 *	COMMON.C
 *	
 *	Code common between restore client and server.
 *	
 *	
 */
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>
#include <windows.h>
#include <stdlib.h> // wsplitpath
#include <mxsutil.h>
#include <rpc.h>
#include <ntdsbcli.h>
#include <dsconfig.h>
#include <jetbp.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <dsevent.h>    // pszNtdsSourceGeneral
#include <fileno.h>
#include <msrpc.h>
#define FILENO    FILENO_JETBACK_COMMON

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


WSZ
WszFromSz(
	IN	LPCSTR Sz
	)
{
	WSZ Wsz;
	CCH cchWstr;

	cchWstr = MultiByteToWideChar(CP_ACP, 0, Sz, -1, NULL, 0);

	if (cchWstr == 0)
	{
		return(NULL);
	}

	Wsz = MIDL_user_allocate(cchWstr*sizeof(WCHAR));

	if (Wsz == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
	}

	if (MultiByteToWideChar(CP_ACP, 0, Sz, -1, Wsz, cchWstr) == 0) {
		MIDL_user_free(Wsz);
		return(NULL);
	}

	return(Wsz);
}

/*
 -	FGetCurrentSid
 -
 *	Purpose:
 *		Retrieves the current SID of the logged on user.
 *
 *	Parameters:
 *		psidCurrentUser - Filled in with the SID of the current user.
 *
 *	Returns:
 *		fTrue if we retrieved the SID.
 *
 */

VOID
GetCurrentSid(
	PSID *ppsid
	)
{
	HANDLE hToken;
	CB cbUserLength = 200;
	PTOKEN_USER ptuUserInfo = (PTOKEN_USER)LocalAlloc(0, cbUserLength);

	*ppsid = NULL;

	if (ptuUserInfo == NULL) {
		DebugTrace(("GetCurrentSid: Unable to allocate token_user structure: %d\n", GetLastError()));
		return;
	}

	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, fTrue, &hToken))
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
			DebugTrace(("GetCurrentSid: OpenProcess and ThreadToken fails: %d\n", GetLastError()));
            LocalFree(ptuUserInfo);
			return;
		}
	}
	
	if (!GetTokenInformation(hToken, TokenUser, ptuUserInfo, cbUserLength, &cbUserLength)) {
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
			DebugTrace(("GetCurrentSid: GetTokenInformation failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			LocalFree(ptuUserInfo);
			return;
		}

		LocalFree(ptuUserInfo);

		ptuUserInfo = (PTOKEN_USER)LocalAlloc(0, cbUserLength);

		if (ptuUserInfo == NULL) {
			DebugTrace(("GetCurrentSid: Allocate of buffer failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			return;
		}

		if (!GetTokenInformation(hToken, TokenUser, ptuUserInfo, cbUserLength, &cbUserLength)) {
			DebugTrace(("GetCurrentSid: GetTokenInformation failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			LocalFree(ptuUserInfo);
			return;
		}
	}

	
	Assert(IsValidSid(ptuUserInfo->User.Sid));

	*ppsid = LocalAlloc(0, GetLengthSid(ptuUserInfo->User.Sid));

	if (*ppsid == NULL)
	{
		DebugTrace(("GetCurrentSid: Allocation of new SID failed: %d\n", GetLastError()));
        CloseHandle(hToken);
        LocalFree(ptuUserInfo);
		return;
	}

	//
	//	We know know the SID (and attributes) of the current user.  Return the SID.
	//

	CopySid(GetLengthSid(ptuUserInfo->User.Sid), *ppsid, ptuUserInfo->User.Sid);

	Assert(IsValidSid(*ppsid));

	LocalFree(ptuUserInfo);

	CloseHandle(hToken);
}


BOOL
InitializeSectionEventDacl(
    PACL *ppDacl
    )

/*++

Routine Description:

This routine constructs a Dacl which allows ourself and local system
access.  We grant all access for both section and event objects, which is
what this dacl is currently used for.

Arguments:

    ppDacl - pointer to pointer to receive allocated pDacl. Caller must
    deallocate using HeapFree

Return Value:

    BOOL - success/failure

--*/

{
    DWORD status;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PACL pDacl = NULL;
    PSID pAdministratorsSid = NULL;
    PSID pSelfSid = NULL;
    DWORD dwAclSize;

    // FUTURE-2002/03/18-BrettSh - SDDL routines are easier to use, and less error prone.
    ;

    //
    // preprate a Sid representing the well-known admin group
    // Are both the local admin and the domain admin members of this group?
    //

    if (!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pAdministratorsSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to allocate and init sid, error %d\n", status));
        goto cleanup;
    }

    // Here is a sid for ourself
    GetCurrentSid( &pSelfSid );
    if (pSelfSid == NULL) {
        status = GetLastError();
        DebugTrace(("Unable to allocate and init sid, error %d\n", status));
        goto cleanup;
    }

    //
    // compute size of new acl
    //
    dwAclSize = sizeof(ACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pAdministratorsSid) +
        GetLengthSid(pSelfSid);

    //
    // allocate storage for Acl
    //
    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
    if(pDacl == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace(("Unable to allocate acl, error %d\n", status));
        goto cleanup;
    }

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        status = GetLastError();
        DebugTrace(("Unable to initialize acl, error %d\n", status));
        goto cleanup;
    }

    //
    // grant the Administrators Sid access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        (SECTION_ALL_ACCESS|EVENT_ALL_ACCESS),
        pAdministratorsSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to add access allowed ace, error %d\n", status));
        goto cleanup;
    }

    //
    // grant the Self Sid access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        (SECTION_ALL_ACCESS|EVENT_ALL_ACCESS),
        pSelfSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to add access allowed ace, error %d\n", status));
        goto cleanup;
    }

    *ppDacl = pDacl;
    pDacl = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if(pAdministratorsSid != NULL)
    {
        FreeSid(pAdministratorsSid);
    }

    if(pSelfSid != NULL)
    {
        FreeSid(pSelfSid);
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    return (status == ERROR_SUCCESS) ? TRUE : FALSE;
} /* InitializeSectionDacl */

BOOLEAN
FCreateSharedMemorySection(
	PJETBACK_SHARED_CONTROL pjsc,
	DWORD dwClientIdentifier,
	BOOLEAN	fClientOperation,
	CB	cbSharedMemory
	)
{
	WCHAR rgwcMutexName[ MAX_PATH ];
	WCHAR rgwcClientEventName[ MAX_PATH ];
	WCHAR rgwcServerEventName[ MAX_PATH ];
	WCHAR rgwcSharedName[ MAX_PATH ];

	SECURITY_ATTRIBUTES	*	psa = NULL;

	SECURITY_ATTRIBUTES		sa;
	char		rgbForSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
	SECURITY_DESCRIPTOR *  	psd;
        PACL pDacl = NULL;
	BOOLEAN fResult = fFalse;  // assume failure

// Both client and server ends map the section.  Although the bulk of the data
// passes from server to client (server:write,client:read), the client writes
// some initial configuation data in the section for the server initially.
// Both need write. Thus access is ourself:write,admin:write.  The first is for
// ourself, the second is for the ds running as LocalSystem.

	psa = &sa;
	psd = (SECURITY_DESCRIPTOR *)rgbForSecurityDescriptor;

	if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
		return fFalse;

        if (!InitializeSectionEventDacl( &pDacl ))
            return fFalse;

	// Add DACL to the security descriptor..
	if (!SetSecurityDescriptorDacl(psd, TRUE, pDacl, FALSE)) {
            fResult = fFalse;
            goto cleanup;
        }

	psa->nLength = sizeof(*psa);
	psa->lpSecurityDescriptor = psd;
	psa->bInheritHandle = FALSE;

	wsprintfW(rgwcMutexName, LOOPBACKED_CRITSEC_MUTEX_NAME, dwClientIdentifier);
	wsprintfW(rgwcClientEventName, LOOPBACKED_READ_EVENT_NAME, dwClientIdentifier);
	wsprintfW(rgwcServerEventName, LOOPBACKED_WRITE_EVENT_NAME, dwClientIdentifier);
	wsprintfW(rgwcSharedName, LOOPBACKED_SHARED_REGION, dwClientIdentifier);

	//
	//	Allocate the shared memory section.  The size of the section is the size requested, plus enough
	//	memory for the header (which means 1 more page).
	//

    SetLastError(ERROR_SUCCESS);
	pjsc->hSharedMemoryMapping = CreateFileMappingW(
            (HANDLE) (-1),
            psa,
            PAGE_READWRITE,
            0,
            cbSharedMemory + sizeof(JETBACK_SHARED_HEADER),
            rgwcSharedName
            );
    if (fClientOperation && GetLastError() == ERROR_ALREADY_EXISTS) {
        Assert(!"Is someone trying to hi-jack this event!?!");
        goto cleanup;
    }
    // test server side finds object
    Assert(fClientOperation || GetLastError() == ERROR_ALREADY_EXISTS);

	//
	//	Ok, we've created our shared memory region, we now want to open up the
	//	read, write, and critical section events (and mutex).
	//
    // Jan 25, 1999 wlees. Events made auto-reset with SetEvent being used
    // instead of PulseEvent.
    // heventRead is used to synchronize when the writing-side has more
    // data available.  See jetback\jetback.c
    // heventWrite is used to synchonize when the read-side has consumed
    // the data. See jetbcli\jetbcli.c
    SetLastError(ERROR_SUCCESS);
    if (pjsc->hSharedMemoryMapping != NULL)
    {
        if (pjsc->heventRead = CreateEventW(psa, fFalse /* ManualReset is false ==> AutoReset */, fFalse, rgwcClientEventName))
        {
            if (fClientOperation && GetLastError() == ERROR_ALREADY_EXISTS) {
                Assert(!"Is someone trying to hi-jack this event!?!");
                goto cleanup;
            }
            // test server side finds object
            Assert(fClientOperation || GetLastError() == ERROR_ALREADY_EXISTS);
            SetLastError(ERROR_SUCCESS);
            if (pjsc->heventWrite = CreateEventW(psa, fFalse /* ManulReset is False means AutoReset*/, fFalse, rgwcServerEventName))
            {
                if (fClientOperation && GetLastError() == ERROR_ALREADY_EXISTS) {
                    Assert(!"Is someone trying to hi-jack this event!?!");
                    goto cleanup;
                }
                // test server side finds object
                Assert(fClientOperation || GetLastError() == ERROR_ALREADY_EXISTS);
                SetLastError(ERROR_SUCCESS);
                if (pjsc->hmutexSection = CreateMutexW(psa, FALSE, rgwcMutexName))
                {
                    if (fClientOperation && GetLastError() == ERROR_ALREADY_EXISTS) {
                        Assert(!"Is someone trying to hi-jack this event!?!");
                        goto cleanup;
                    }
                    // test server side finds object
                    Assert(fClientOperation || GetLastError() == ERROR_ALREADY_EXISTS);
                    if ((pjsc->pjshSection = MapViewOfFile(pjsc->hSharedMemoryMapping, FILE_MAP_WRITE,0,0,0)) != NULL)
                    {
                        //
                        //	Initialize the shared memory section.
                        //

                        if (fClientOperation)
                        {
                            SYSTEM_INFO si;

                            //
                            //	Take cbReadHintSize, and round it up to the nearest page size (on the client).
                            //

                            GetSystemInfo(&si);

                            //
                            //	Guarantee that dwPageSize is a power of 2
                            //

                            Assert ((si.dwPageSize != 0) && ((si.dwPageSize & (si.dwPageSize - 1)) == 0));

                            pjsc->pjshSection->cbPage = si.dwPageSize;
                            pjsc->pjshSection->cbSharedBuffer = cbSharedMemory;
                            pjsc->pjshSection->dwReadPointer = 0;
                            pjsc->pjshSection->dwWritePointer = 0;
                            pjsc->pjshSection->cbReadDataAvailable = 0;
                            pjsc->pjshSection->fReadBlocked = fFalse;	//	Read operation is blocked
                            pjsc->pjshSection->fWriteBlocked = fFalse;	//	Write operation is blocked
                        } else
                        {
                            Assert(pjsc->pjshSection->cbSharedBuffer == (DWORD) cbSharedMemory);
                        }

                        //
                        //	Ok, we're ready to use the shared memory section!!!!
                        //

                        fResult = fTrue;
                    }
				}
			}
		}
	}

cleanup:
#if DBG
        if (!fResult) {
            DebugTrace(("fCreateSharedMemoryFailed, client=%d, error %d\n", fClientOperation, GetLastError()));
        }
#endif
        // Free the ACL now that we are finished with it
        if (pDacl) {
            HeapFree(GetProcessHeap(), 0, pDacl);
        }

	return fResult;
}

VOID
CloseSharedControl(
	PJETBACK_SHARED_CONTROL pjsc
	)
{
	if (pjsc->pjshSection)
	{
		UnmapViewOfFile((HANDLE )pjsc->pjshSection);
		pjsc->pjshSection = NULL;
	}

	if (pjsc->hSharedMemoryMapping)
	{
		CloseHandle(pjsc->hSharedMemoryMapping);
		pjsc->hSharedMemoryMapping = NULL;
	}

	if (pjsc->heventRead)
	{
		CloseHandle(pjsc->heventRead);
		pjsc->heventRead = NULL;
	}

	if (pjsc->heventWrite)
	{
		CloseHandle(pjsc->heventWrite);
		pjsc->heventWrite = NULL;
	}

	if (pjsc->hmutexSection)
	{
		CloseHandle(pjsc->hmutexSection);
		pjsc->hmutexSection = NULL;
	}
}


VOID
LogNtdsErrorEvent(
    IN DWORD EventMid,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    This function writes an error event with the given description into the
    directory service error log.

Arguments:

    Description - Supplies the text for the error description.
    ErrorCode - Supplies the error code to be displayed.

Return Value:

    None

--*/
{

    HANDLE hEventSource = NULL;
    DWORD err;
    BOOL succeeded;
    WCHAR errorCodeText[16];
    WCHAR *inserts[2];
    DWORD cch = 0;
    PWCHAR pBuffer = NULL;

    hEventSource = RegisterEventSourceA(NULL, pszNtdsSourceGeneral);

    if (hEventSource == NULL)
        goto CleanUp;

    if (!_itow(ErrorCode, errorCodeText, 10))
        goto CleanUp;

    cch = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        0, // system message file
        ErrorCode,
        0,
        (LPWSTR) &pBuffer,
        0,
        NULL);
    if (!cch)
        goto CleanUp;

    inserts[0] = errorCodeText;
    if (cch != 0) {
        inserts[1] = pBuffer;
    } else {
        inserts[1] = L"[]";
    }

    succeeded = ReportEvent(hEventSource,
                            EVENTLOG_ERROR_TYPE,
                            BACKUP_CATEGORY,
                            EventMid,
                            NULL,
                            2,
                            0,
                            inserts,
                            NULL);

    if (!succeeded)
        goto CleanUp;

CleanUp:

    if (hEventSource != NULL)
    {
        DeregisterEventSource(hEventSource);
    }

    if (pBuffer != NULL) {
        LocalFree( pBuffer );
    }

} // LogNtdsErrorEvent


DWORD
CreateNewInvocationId(
    IN BOOL     fSaveGuid,
    OUT GUID    *NewId
    )
{
    RPC_STATUS rpcStatus;
    DWORD dwErr;
    HKEY hKey;
    PWCHAR pszUuid = NULL;

    //
    // Try to create one
    //

    rpcStatus = UuidCreate(NewId);

    if ( (rpcStatus != RPC_S_OK)
#if 0
         // 2000-02-23 JeffParh
         // Local UUIDs are bad, particularly for invocation IDs.
         && (rpcStatus != RPC_S_UUID_LOCAL_ONLY)
#endif
         ) {
        
        return rpcStatus;
    }

    if ( !fSaveGuid ) {
        return ERROR_SUCCESS;
    }

    //
    // Store this new uuid in a registry key so it can be reused by a second
    // Auth restore and by the restore from backup code in the bootup code
    //

    // Open the DS parameters key.

    dwErr = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey);

    if ( ERROR_SUCCESS != dwErr ) {
        return dwErr;
    } 

    rpcStatus = UuidToString(NewId, &pszUuid);

    if ( rpcStatus != RPC_S_OK ) {
        RegCloseKey(hKey);
        return rpcStatus;
    }

    dwErr = RegSetValueEx(  hKey, 
                            RESTORE_NEW_DB_GUID,
                            0, 
                            REG_SZ, 
                            (BYTE *) pszUuid,
                            (wcslen(pszUuid) + 1)*sizeof(WCHAR));

    RpcStringFree(&pszUuid);
    RegCloseKey(hKey);

    if ( ERROR_SUCCESS != dwErr ) {
        return dwErr;
    } 

    return ERROR_SUCCESS;

} // CreateNewInvocationId
                                   

#if DBG

#define TRACE_FILE_SIZE 256

VOID
ResetTraceLogFile(
    VOID
    );

CRITICAL_SECTION
critsTraceLock = {0};

DWORD
dwDebugFileLimit = 10000000;

typedef enum _TER {
    terUnknown,
    terFalse,
    terTrue
} TER;

TER
terTraceEnabled = terUnknown;


HANDLE hfileTraceLog = INVALID_HANDLE_VALUE;
UCHAR chLast = '\n';

DWORD
dwTraceLogFileSize = 0;

BOOLEAN fTraceInitialized = {0};

#include <lmshare.h>
#include <lmapibuf.h>
#include <lmerr.h>

/*++

A standardized shorthand notation for SIDs makes it simpler to
visualize their components:

S-R-I-S-S...

In the notation shown above,

S identifies the series of digits as an SID,
R is the revision level,
I is the identifier-authority value,
S is subauthority value(s).

An SID could be written in this notation as follows:
S-1-5-32-544

In this example,
the SID has a revision level of 1,
an identifier-authority value of 5,
first subauthority value of 32,
second subauthority value of 544.
(Note that the above Sid represents the local Administrators group)

The GetTextualSid function will convert a binary Sid to a textual
string.

The resulting string will take one of two forms.  If the
IdentifierAuthority value is not greater than 2^32, then the SID
will be in the form:

S-1-5-21-2127521184-1604012920-1887927527-19009
  ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
  | | |		 |			|		   |		|
  +-+-+------+----------+----------+--------+--- Decimal

Otherwise it will take the form:

S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
  ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
  |		  |		   |	  |			 |			|		 |
  |	  Hexidecimal  |	  |			 |			|		 |
  +----------------+------+----------+----------+--------+--- Decimal

If the function succeeds, the return value is TRUE.
If the function fails, the return value is FALSE.  To get extended
	error information, call the Win32 API GetLastError().

Scott Field (sfield)	11-Jul-95
Unicode enabled

Scott Field (sfield)	15-May-95
--*/

BOOL GetTextualSid(
	PSID pSid,			// binary Sid
	LPWSTR szTextualSid,  // buffer for Textual representaion of Sid
	LPDWORD dwBufferLen // required/provided TextualSid buffersize
	)
{
	PSID_IDENTIFIER_AUTHORITY psia;
	DWORD dwSubAuthorities;
	DWORD dwSidRev=SID_REVISION;
	DWORD dwCounter;
	DWORD dwSidSize;

	//
	// test if Sid passed in is valid
	//
	if(!IsValidSid(pSid)) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// obtain SidIdentifierAuthority
	psia=GetSidIdentifierAuthority(pSid);

	// obtain sidsubauthority count
	dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

	//
	// compute buffer length
	// S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
	//
	dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

	//
	// check provided buffer length.
	// If not large enough, indicate proper size and setlasterror
	//
	if (*dwBufferLen < dwSidSize)
	{
		DebugTrace(("Buffer too small.  Requested %d bytes, %d needed\n", *dwBufferLen, dwSidSize));
		*dwBufferLen = dwSidSize;
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	//
	// prepare S-SID_REVISION-
	//
	wsprintfW(szTextualSid, L"S-%lu-", dwSidRev );

	//
	// prepare SidIdentifierAuthority
	//
	if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid),
					L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
					(USHORT)psia->Value[0],
					(USHORT)psia->Value[1],
					(USHORT)psia->Value[2],
					(USHORT)psia->Value[3],
					(USHORT)psia->Value[4],
					(USHORT)psia->Value[5]);
	}
	else
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid), L"%lu",
					(ULONG)(psia->Value[5]		)	+
					(ULONG)(psia->Value[4] <<  8)	+
					(ULONG)(psia->Value[3] << 16)	+
					(ULONG)(psia->Value[2] << 24)	);
	}

	//
	// loop through SidSubAuthorities
	//
	for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid), L"-%lu",
					*GetSidSubAuthority(pSid, dwCounter) );
	}

	SetLastError(NO_ERROR);
	return TRUE;
}
VOID
DebugPrint(char *szFormat,...)
#define LAST_NAMED_ARGUMENT szFormat

{
	CHAR rgchOutputString[4096];
	ULONG ulBytesWritten;
    HRESULT hr;

	va_list ParmPtr;					// Pointer to stack parms.

	if (terTraceEnabled == terUnknown)
	{
		HRESULT hr;
		HKEY hkey;
		DWORD dwType;
		DWORD fTraceEnabled;
		DWORD cbTraceEnabled;

		if (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, BACKUP_INFO, 0, KEY_READ, &hkey))
		{
			terTraceEnabled = terFalse;
		}
		dwType = REG_DWORD;
		cbTraceEnabled = sizeof(fTraceEnabled);
		hr = RegQueryValueEx(hkey, ENABLE_TRACE, 0, &dwType, (LPBYTE)&fTraceEnabled, &cbTraceEnabled);
	
		RegCloseKey(hkey);
		if (hr != hrNone)
		{
			terTraceEnabled = terFalse;
		}
		if (fTraceEnabled)
		{
			terTraceEnabled = terTrue;
		}
		
	}

	if (terTraceEnabled == terFalse)
	{
		return;
	}


	if (!fTraceInitialized) {
		if (!FInitializeTraceLog())
            return;
	}

	EnterCriticalSection(&critsTraceLock);

	try {

		if (hfileTraceLog == INVALID_HANDLE_VALUE) {
			//
			//	We've not opened the trace log file yet, so open it.
			//

			OpenTraceLogFile();
		}

		if (hfileTraceLog == INVALID_HANDLE_VALUE) {
			return;
		}

		//
		//	Attempt to catch bad trace.
		//

		for (ulBytesWritten = 0; ulBytesWritten < strlen(szFormat) ; ulBytesWritten += 1) {
			if (szFormat[ulBytesWritten] > 0x7f) {
				DebugBreak();
			}
		}

		if (chLast == '\n') {
			SYSTEMTIME SystemTime;

			GetLocalTime(&SystemTime);

			//
			//	The last character written was a newline character.	 We should
			//	timestamp this record in the file.
			//

			sprintf(rgchOutputString, "%2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d.%3.3d: ", SystemTime.wMonth,
															SystemTime.wDay,
															SystemTime.wYear,
															SystemTime.wHour,
															SystemTime.wMinute,
															SystemTime.wSecond,
															SystemTime.wMilliseconds);

			if (!WriteFile(hfileTraceLog, rgchOutputString, strlen(rgchOutputString), &ulBytesWritten, NULL)) {
//				  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
				return;
			}

			if (ulBytesWritten != strlen(rgchOutputString)) {
//				  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
				return;
			}

			dwTraceLogFileSize += ulBytesWritten;

		}

		va_start(ParmPtr, LAST_NAMED_ARGUMENT);

		//
		//	Format the parameters to the string.
		//

		hr = StringCchVPrintfA(rgchOutputString, 4096, szFormat, ParmPtr);
        if (hr) {
            Assert(!"NOT ENOUGH_MEMORY"); 
            // Game over man!
            return;
        }
        strcat(rgchOutputString, "\r\n");

		if (!WriteFile(hfileTraceLog, rgchOutputString, strlen(rgchOutputString), &ulBytesWritten, NULL)) {
//			  KdPrint(("Error writing to Browser log file: %ld\n", GetLastError()));
//			  KdPrint(("%s", rgchOutputString));
			return;
		}

		if (ulBytesWritten != strlen(rgchOutputString)) {
//			  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
//			  KdPrint(("%s", rgchOutputString));
			return;
		}

		dwTraceLogFileSize += ulBytesWritten;

		//
		//	Remember the last character output to the log.
		//

		chLast = rgchOutputString[strlen(rgchOutputString)-1];

		if (dwTraceLogFileSize > dwDebugFileLimit) {
			ResetTraceLogFile();
		}

	} finally {
		LeaveCriticalSection(&critsTraceLock);
	}
}


BOOL
FInitializeTraceLog()
{

    __try
    {
	    InitializeCriticalSection(&critsTraceLock);
	    fTraceInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);
    }

    return TRUE;
}

HRESULT
GetTraceLogRoot(
    IN ULONG  cchTraceFileName,
	IN PWCHAR szTraceFileName
	)
{
	PSHARE_INFO_502 ShareInfo;
	WCHAR rgwcModuleName[ MAX_PATH ];
	WCHAR rgwcFileName[ MAX_PATH ];

	//
	//	If the DEBUG share exists, put the log file in that directory,
	//	otherwise, use the system root.
	//
	//	This way, if the browser is running on an NTAS server, we can always
	//	get access to the log file.
	//

	if (NetShareGetInfo(NULL, L"DEBUG", 502, (PCHAR *)&ShareInfo) != NERR_Success) {

		if (GetSystemDirectory(szTraceFileName, cchTraceFileName*sizeof(WCHAR)) == 0)  {
//			  KdPrint(("Unable to get system directory: %ld\n", GetLastError()));
            return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		}

        if(cchTraceFileName < wcslen(szTraceFileName)+2){
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
		if (szTraceFileName[wcslen(szTraceFileName)] != L'\\') {
			szTraceFileName[wcslen(szTraceFileName)+1] = L'\0';
			szTraceFileName[wcslen(szTraceFileName)] = L'\\';
		}

	} else {
		//
		//	Seed the trace file buffer with the local path of the netlogon
		//	share if it exists.
		//

        if (cchTraceFileName > wcslen(ShareInfo->shi502_path)+2){
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
		wcscpy(szTraceFileName, ShareInfo->shi502_path);
		szTraceFileName[wcslen(ShareInfo->shi502_path)] = L'\\';
		szTraceFileName[wcslen(ShareInfo->shi502_path)+1] = L'\0';

		NetApiBufferFree(ShareInfo);
	}

	//
	//	Figure out our process name.
	//
	GetModuleFileName(NULL, rgwcModuleName, (sizeof(rgwcModuleName))/(sizeof(rgwcModuleName[0])));

	_wsplitpath(rgwcModuleName, NULL, NULL, rgwcFileName, NULL);

	StringCchCat(szTraceFileName, cchTraceFileName, rgwcFileName);

    return(hrNone);
}

VOID
ResetTraceLogFile(
	VOID
	)
{
	WCHAR rgwcOldTraceFile[TRACE_FILE_SIZE];
	WCHAR rgwcNewTraceFile[TRACE_FILE_SIZE];
    HRESULT hr;

	if (hfileTraceLog != INVALID_HANDLE_VALUE) {
		CloseHandle(hfileTraceLog);
	}

	hfileTraceLog = INVALID_HANDLE_VALUE;

	hr = GetTraceLogRoot(TRACE_FILE_SIZE, rgwcOldTraceFile);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return;
    }

    hr = StringCchCopy(rgwcNewTraceFile, TRACE_FILE_SIZE, rgwcOldTraceFile);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return;
    }
    hr = StringCchCat(rgwcOldTraceFile, TRACE_FILE_SIZE, L".Backup.Log");
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return;
    }
	hr = StringCchCat(rgwcNewTraceFile, TRACE_FILE_SIZE, L".Backup.Bak");
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return;
    }

	//
	//	Delete the old log
	//

	DeleteFile(rgwcNewTraceFile);

	//
	//	Rename the current log to the new log.
	//

	MoveFile(rgwcOldTraceFile, rgwcNewTraceFile);

	OpenTraceLogFile();

}

VOID
OpenTraceLogFile(
	VOID
	)
{
	WCHAR rgwcTraceFile[TRACE_FILE_SIZE];
    HRESULT hr;

	hr = GetTraceLogRoot(TRACE_FILE_SIZE, rgwcTraceFile);
    if (hr) {
        hfileTraceLog = INVALID_HANDLE_VALUE;
        return;
    }

	StringCchCat(rgwcTraceFile, TRACE_FILE_SIZE, L".Backup.Log");

	hfileTraceLog = CreateFile(rgwcTraceFile,
										GENERIC_WRITE,
										FILE_SHARE_READ,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL);


	if (hfileTraceLog == INVALID_HANDLE_VALUE) {
//		  KdPrint(("Error creating trace file %ws: %ld\n", rgwcTraceFile, GetLastError()));

		return;
	}

	dwTraceLogFileSize = SetFilePointer(hfileTraceLog, 0, NULL, FILE_END);

	if (dwTraceLogFileSize == 0xffffffff) {
//		  KdPrint(("Error setting trace file pointer: %ld\n", GetLastError()));

		return;
	}
}

VOID
UninitializeTraceLog()
{
	if (fTraceInitialized)
	{
		DeleteCriticalSection(&critsTraceLock);

		if (hfileTraceLog != NULL) {
			CloseHandle(hfileTraceLog);
		}

		hfileTraceLog = INVALID_HANDLE_VALUE;

		fTraceInitialized = FALSE;
	}
}

NET_API_STATUS
TruncateLog()
{
	if (hfileTraceLog == INVALID_HANDLE_VALUE) {
		OpenTraceLogFile();
	}

	if (hfileTraceLog == INVALID_HANDLE_VALUE) {
		return ERROR_GEN_FAILURE;
	}

	if (SetFilePointer(hfileTraceLog, 0, NULL, FILE_BEGIN) == 0xffffffff) {
		return GetLastError();
	}

	if (!SetEndOfFile(hfileTraceLog)) {
		return GetLastError();
	}

	return NO_ERROR;
}

		


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbak_server.c ===
#include <jetbak_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbak_client.c ===
#include <jetbak_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetbp.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetbp.h

Abstract:

    This module contains the private definitions for the JET backup APIs


Author:

    Larry Osterman (larryo) 21-Aug-1994


Revision History:


--*/

#ifndef	_JETBP_
#define	_JETBP_

#include <dsjet.h>
#ifndef	MIDL_PASS
#include <jetbak.h>
#endif
#include <nspapi.h>

// MIDL 2.0 switched the names of the generated server interface globals (why!?).
// This hack so that we only have to change one place.
// Parameters are interface name, major and minor version numbers.
#if   (_MSC_VER > 800)
#define ServerInterface(s,vMaj,vMin)	s##_v##vMaj##_##vMin##_s_ifspec
#define ClientInterface(s,vMaj,vMin)	s##_v##vMaj##_##vMin##_c_ifspec
#else
#define ServerInterface(s,vMaj,vMin)	s##_ServerIfHandle
#define ClientInterface(s,vMaj,vMin)	s##_ClientIfHandle
#endif

#include "options.h"

#define	MAX_SOCKETS	10

#define	RESTORE_IN_PROGRESS		L"\\Restore in Progress"
#define	RESTORE_STATUS			L"RestoreStatus"
#define	BACKUP_LOG_PATH			L"BackupLogPath"
#define	CHECKPOINT_FILE_PATH	L"CheckpointFilePath"
#define	LOG_PATH				L"LogPath"
#define	HIGH_LOG_NUMBER			L"HighLog Number"
#define	LOW_LOG_NUMBER			L"LowLog Number"
#define	JET_RSTMAP_NAME			L"NTDS_RstMap"
#define	JET_RSTMAP_SIZE			L"NTDS_RstMap Size"
#define	JET_DATABASE_RECOVERED	L"NTDS Database recovered"
#define	BACKUP_INFO				L"SYSTEM\\CurrentControlSet\\Services\\NTDS\\BackupInformation\\"
#define	LAST_BACKUP_LOG			L"Last Backup Log"
#define	DISABLE_LOOPBACK		L"DisableLoopback"
#define	ENABLE_TRACE			L"Enable Trace"
#define RESTORE_NEW_DB_GUID     L"New Database GUID"

//
// Note these two registry settings only work in checked builds for 
// testing, and they're both in the normal DSA NTDS\Parameters key.
//
#define	ALLOW_REMOTE_SERVER_OP              L"Backup Enable TCP"
#define	ALLOW_ONLINE_SNAPSHOT_RESTORE_OP    L"Allow Online Snapshot Restore"

//
//	Sockets protocol value.
//
typedef INT PROTVAL;

#define	LOOPBACKED_READ_EVENT_NAME      L"Global\\NTDS Backup Loopbacked Read Event - %d"
#define	LOOPBACKED_WRITE_EVENT_NAME     L"Global\\NTDS Backup Loopbacked Write Event - %d"
#define	LOOPBACKED_CRITSEC_MUTEX_NAME   L"Global\\NTDS Backup Loopbacked Critical Section - %d"
#define	LOOPBACKED_SHARED_REGION        L"Global\\NTDS Backup Shared Memory Region - %d"

#define	READAHEAD_MULTIPLIER	5
#if DBG
#define	BACKUP_WAIT_TIMEOUT		(10*60*1000)
#else
#define	BACKUP_WAIT_TIMEOUT		(2*60*1000)
#endif

#define IsLocalProtSeq(iszProtSeq)   ((iszProtSeq) == 0)
#define IsRemoteProtSeq(iszProtSeq)  ((iszProtSeq) == 1)

typedef volatile struct {
	DWORD	cbSharedBuffer;
	DWORD	cbPage;				// 	Convenient place to store the size of a page.
	DWORD	dwReadPointer;		//	Read offset within shared buffer.
	DWORD	dwWritePointer;		//	Write offset within buffer.
	LONG	cbReadDataAvailable;//	Number of bytes of data available.
	HRESULT	hrApi;				//	Status of API - used to communicate to server if client fails.
	BOOLEAN	fReadBlocked;		//	Read operation is blocked
	BOOLEAN	fWriteBlocked;		//	Write operation is blocked
} JETBACK_SHARED_HEADER, *PJETBACK_SHARED_HEADER;


typedef struct {
	HANDLE		hSharedMemoryMapping;
	HANDLE		heventRead;
	HANDLE		heventWrite;
	HANDLE		hmutexSection;
	PJETBACK_SHARED_HEADER pjshSection;
} JETBACK_SHARED_CONTROL, *PJETBACK_SHARED_CONTROL;


//
//	Client side context.
//

typedef struct _BackupContext {
	handle_t	hBinding;
	CXH			cxh;
	BOOLEAN		fLoopbacked;
	BOOLEAN		fUseSockets;
	BOOLEAN		fUseSharedMemory;

	//
	//	Socket support.
	//

	SOCKET		rgsockSocketHandles[MAX_SOCKETS];
	PROTVAL		rgprotvalProtocolsUsed[MAX_SOCKETS];
	C			cSockets;
	SOCKET		sock;
	HANDLE		hReadThread;
	DWORD		tidThreadId;
	HANDLE		hPingThread;		// Keep alive thread for loopbacked backups.
	DWORD		tidThreadIdPing;	// And thread ID for that thread.
	HRESULT		hrApiStatus;

	//
	//	Shared memory support.
	//

	JETBACK_SHARED_CONTROL jsc;

        // Whether a token was supplied at checked when the context was created
        BOOL fExpiryTokenChecked;
} BackupContext, *pBackupContext;

typedef
DWORD
(*PRESTORE_DATABASE_LOCATIONS)(
	OUT CHAR rgLocationBuffer[],
	OUT PULONG pulLocationSize,
	OUT char rgRegistryBase[],
	OUT ULONG cbRegistryBase,
	OUT BOOL *pfCircularLogging
	);

typedef
DWORD
(*PRESTORE_PERFORM_RESTORE)(
	SZ szLogPath,
	SZ szBackupLogPath,
	C crstmap,
	JET_RSTMAP rgrstmap[]
	);

//
//	Server side context binding - the server context handle points to a
//	structure containing this information.
//
typedef struct _JETBACK_SERVER_CONTEXT {
	BOOL	fRestoreOperation;
	union {
		struct {
		    JET_INSTANCE    instance;
			JET_HANDLE		hFile;
			BOOL			fHandleIsValid;
			CB				cbReadHint;
			SOCKET			sockClient;
			LARGE_INTEGER 	liFileSize;
			DWORD			dwHighestLogNumber;
			WSZ				wszBackupAnnotation;
			DWORD			dwFileSystemGranularity;
			BOOLEAN			fUseSockets;
			BOOLEAN			fUseSharedMemory;
			BOOLEAN			fBackupIsRegistered;
            WCHAR **        awszAllowedFiles;

			//
			//	Client identifer used to identify the client to the server - we use this
			//	when opening the shared memory segment on local backup.
			//

			DWORD			dwClientIdentifier;
			JETBACK_SHARED_CONTROL jsc;
		} Backup;
		struct {
			BOOL						fJetCompleted;
			C							cUnitDone;
			C							cUnitTotal;
		} Restore;
	} u;
} JETBACK_SERVER_CONTEXT, *PJETBACK_SERVER_CONTEXT;

//
// Structure representing ExpiryToken
//
typedef struct
{
    DWORD       dwVersion;      // token version (only one version is supported now)
    LONGLONG    dsBackupTime;   // time stamp on backup copy (number of seconds since 1601)
    DWORD       dwTombstoneLifeTimeInDays; // tombstone life time as per the DS
} EXPIRY_TOKEN;

//
//	Server side private routines.
//

typedef ULONG MessageId;

VOID
GetCurrentSid(
	PSID *ppsid
	);

extern BOOL g_fAllowRemoteOp;

typedef enum {
    eOk = 0,
    eNullContextHandle,
    eAttemptToRestoreOnline,
    eImpersonateFailed,
    eNoBackupPrivilege,
    eNoRestorePrivilege,
    eUnknown,

    eLastReasonDontUse
} E_REASON;

//
// I found the flags to be confusing, so I made some clearer function names.
//
#define HrValidateInitialBackupSecurity()            HrValidateContextAndSecurity(FALSE, FALSE, TRUE, NULL)
#define HrValidateBackupContextAndSecurity(x)        HrValidateContextAndSecurity(FALSE, FALSE, FALSE, (x))
#define HrValidateInitialRestoreSecurity()           HrValidateContextAndSecurity(TRUE, TRUE,   TRUE, NULL)
#define HrValidateRestoreContextAndSecurity(x)       HrValidateContextAndSecurity(TRUE, FALSE,  FALSE, (x))
// There are some restore operations that can be called from either backup or 
// restore, this is what I refer to as loose, because if we fail to have the
// restore privilege we'll check to see if we have the backup privilege.
#define HrValidateRestoreContextAndSecurityLoose(x)  HrValidateContextAndSecurity(TRUE, TRUE,   FALSE, (x))

HRESULT
HrValidateContextAndSecurity(
    BOOL                      fRestoreOp,
    BOOL                      fFakeRestoreOp,
    BOOL                      fIniting,
    PJETBACK_SERVER_CONTEXT   pjsc
    );

E_REASON
BackupServerAccessCheck(
	BOOL fRestoreOperation
	);

DWORD
AdjustBackupRestorePrivilege(
	BOOL fEnable,
	BOOL fRestoreOperation,
	PTOKEN_PRIVILEGES ptpPrevious,
	DWORD *pcbptpPrevious
	);

LONGLONG
GetSecsSince1601();

HRESULT
HrFromJetErr(
	JET_ERR jetError
	);

HRESULT
HrDestroyCxh(
	CXH cxh
	);

BOOL
FIsAbsoluteFileName(SZ szFileName);

HRESULT
HrAnnotateMungedFileList(
	PJETBACK_SERVER_CONTEXT pjsc,
	WSZ wszFileList,
	CB cbFileList,
	WSZ *pwszAnnotatedList,
	CB *pcbAnnotatedList
	);

HRESULT
HrMungedFileNamesFromJetFileNames(
	WSZ *pszMungedList,
	C *pcbSize,
	SZ szJetAttachmentList,
	C cbJetSize,
	BOOL fAnnotated
	);

HRESULT
HrMungedFileNameFromJetFileName(
	SZ szJetFileName,
	WSZ *pszMungedFileName
	);

HRESULT
HrJetFileNameFromMungedFileName(
	WSZ szMungedList,
	SZ *pszJetFileName
	);

VOID
RestoreRundown(
	PJETBACK_SERVER_CONTEXT pjsc
	);

EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    );

BOOL
FInitializeRestore();

BOOL
FUninitializeRestore();

DWORD
getTombstoneLifetimeInDays(
    VOID
    );

//
//	Client side private routines.
//

HRESULT
HrCreateRpcBinding( I iszProtoseq, WSZ szServer, handle_t * phBinding );

void
UnbindRpc( handle_t *phBinding );

HRESULT
HrJetbpConnectToBackupServer(
	WSZ szBackupServer,
	WSZ szBackupAnnotation,
	RPC_IF_HANDLE rifHandle,
	RPC_BINDING_HANDLE *prbhBinding,
    ULONG *             piszProtSeq
	);

BOOL
FBackupClientAccessCheck(
	BOOL fRestoreOperation
	);

BOOL
FIsInBackupGroup(
	BOOL fRestoreOperation
	);


WSZ
WszFromSz(LPCSTR Sz);


HRESULT
HrGetTombstoneLifeTime(
    LPCWSTR wszBackupServer,
    LPDWORD pdwTombstoneLifeTimeDays
    );

extern
WSZ
rgszProtSeq[];

extern
long
cszProtSeq;


//
//	Sockets related APIs and prototypes.
//

HRESULT
HrCreateBackupSockets(
	SOCKET rgsockSocketHandles[],
	PROTVAL rgprotvalProtocolsUsed[],
	C *pcSocketHandles
	);

SOCKET
SockWaitForConnections(
	SOCKET rgsockSocketHandles[],
	C cSocketMax
	);

SOCKET
SockConnectToRemote(
	SOCKADDR rgsockaddrClient[],
	C cSocketMax
	);

HRESULT
HrSockAddrsFromSocket(
	OUT SOCKADDR sockaddr[],
	OUT C *pcSockets,
	IN SOCKET sock,
	IN PROTVAL protval
	);


BOOL
FInitializeSocketClient(
	);

BOOL
FInitializeSocketServer(
	);

BOOL
FUninitializeSocketClient(
	);

BOOL
FUninitializeSocketServer(
	);

HRESULT
I_DsCheckBackupLogs(
	WSZ wszBackupAnnotation
	);


BOOLEAN
FIsLoopbackedBinding(
    WSZ wszServerName
	);

BOOLEAN
FCreateSharedMemorySection(
	PJETBACK_SHARED_CONTROL pjsc,
	DWORD dwClientIdentifier,
	BOOLEAN	fClientOperation,
	CB	cbSharedMemory
	);

VOID
CloseSharedControl(
	PJETBACK_SHARED_CONTROL pjsc
	);

VOID
LogNtdsErrorEvent(
    IN DWORD EventMid,
    IN DWORD ErrorCode
    );

DWORD
CreateNewInvocationId(
    IN BOOL     fSaveGuid,
    OUT GUID    *NewId
    );

DWORD
RegisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf,
    IN  LPWSTR          pszAnnotation
    );

DWORD
UnregisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf
    );

// Two local versions of RPC functions that HrRBackupPrepare was calling,
// this removes the need to link to ntdsbcli.dll
HrSetCurrentLogNumber(
    WSZ wszBackupAnnotation,
    DWORD dwNewCurrentLog
    );

HRESULT
HrRestoreCheckLogsForBackup(
    WSZ wszBackupAnnotation
    );

#if DBG
VOID
DebugPrint(char *format,...);

BOOL GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen // required/provided TextualSid buffersize
    );

VOID
OpenTraceLogFile(
    VOID
    );

BOOL
FInitializeTraceLog(
    VOID
    );

VOID
UninitializeTraceLog(
    VOID
    );

NET_API_STATUS
TruncateLog(
    VOID
    );

		   
#define	DebugTrace(x)	DebugPrint x
#undef KdPrint
#define KdPrint(x)	DebugPrint x
#else
#define	DebugTrace(x)
#endif

#endif	// _JETBP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\local.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       local.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    local.h

Abstract:

    Header file for common routines shared by both client and server

Author:

    Will Lees (wlees) 11-Sep-1998

Environment:

Notes:

Revision History:

--*/

#ifndef _LOCAL_
#define _LOCAL_

// Common routines

EC HrLocalQueryDatabaseLocations(
	SZ szDatabaseLocation,
	CB *pcbDatabaseLocationSize,
	SZ szRegistryBase,
	CB cbRegistryBase,
	BOOL *pfCircularLogging
    );

HRESULT
HrLocalGetRegistryBase(
	OUT WSZ wszRegistryPath,
	OUT WSZ wszKeyName
	);

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore );


HRESULT
HrLocalRestoreRegister(WSZ wszCheckpointFilePath,
                WSZ wszLogPath,
                EDB_RSTMAPW rgrstmap[],
                C crstmap,
                WSZ wszBackupLogPath,
                ULONG genLow,
                ULONG genHigh);

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore );

#endif /* _LOCAL_ */

/* end local.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\local.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       local.c
//
//--------------------------------------------------------------------------

/*
 *  LOCAL.C
 *  
 *  Code common between restore client and server.
 *  
 * wlees Aug 28, 1998
 *    Code to update the registry moved into the common section so the client
 *    library to utilize these functions too.
 *  
 */
#define UNICODE
#include <windows.h>
#include <mxsutil.h>
#include <rpc.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <mdcodes.h>
#include <dsconfig.h>
#include <stdlib.h>

#define DSID(x, y)    (0 | (y))

/*
 -  EcDsarQueryStatus
 -
 *  Purpose:
 *
 *      This routine will return progress information about the restore process
 *
 *  Parameters:
 *      pcUnitDone - The number of "units" completed.
 *      pcUnitTotal - The total # of "units" completed.
 *
 *  Returns:
 *      ec
 *
 */
EC HrLocalQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    )
{
    EC ec = hrNone;
    char rgchPathBuf[ MAX_PATH ];
    SZ szDatabase = NULL;
    HKEY hkeyDs;
    DWORD dwType;
    DWORD cbBuffer;

    // You may be interested to know that szDatabaseLocations is MAX_PATH * 4            
    //    this seems kind of hacky to not pass in the size of such an oddly 
    //    sized buffer.  pcbDatabaseLocationSize does not hold the size of 
    //    szDatabaseLocations, it's an out param only.
    if (pcbDatabaseLocationSize)
    {
        *pcbDatabaseLocationSize = 0;
    }

    if (szRegistryBase != NULL && sizeof(DSA_CONFIG_ROOT) <= cbRegistryBase)
    {
        strcpy(szRegistryBase, DSA_CONFIG_ROOT);
    }

    ec = RegCreateKeyA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hkeyDs); 

    if (ec != hrNone)
    {
        return(ec);
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);

    ec = RegQueryValueExA(hkeyDs, JETSYSTEMPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            szDatabase = szDatabaseLocation;

            *szDatabaseLocation++ = BFT_CHECKPOINT_DIR;
            strcpy(szDatabaseLocation, rgchPathBuf);
            szDatabaseLocation += strlen(rgchPathBuf)+1;
        }
        
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);
    ec = RegQueryValueExA(hkeyDs, LOGPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            szDatabase = szDatabaseLocation+1;

            *szDatabaseLocation++ = BFT_LOG_DIR;
            strcpy(szDatabaseLocation, rgchPathBuf);
            szDatabaseLocation += strlen(szDatabaseLocation)+1;
        }
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);
    ec = RegQueryValueExA(hkeyDs, FILEPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            *szDatabaseLocation++ = BFT_NTDS_DATABASE;
            strcpy(szDatabaseLocation, rgchPathBuf);
            szDatabaseLocation += strlen(szDatabaseLocation)+1;
        }
    }

    if (szDatabaseLocation)
    {
        *szDatabaseLocation = '\0';
    }

    if (pcbDatabaseLocationSize)
    {
        *pcbDatabaseLocationSize += 1;
    }

    // Circular logging is all we do nowadays.
    if (pfCircularLogging) {
        *pfCircularLogging = fTrue;
    }

    RegCloseKey(hkeyDs);
    
    return(hrNone);
}

HRESULT
HrLocalGetRegistryBase(
    OUT WSZ wszRegistryPath,
    OUT WSZ wszKeyName
    )
{
    CHAR rgbRegistryPath[ MAX_PATH ];
    HRESULT hr;

    hr = HrLocalQueryDatabaseLocations(NULL, NULL, rgbRegistryPath, sizeof(rgbRegistryPath), NULL);

    if (hr != hrNone)
    {
        return hr;
    }

    if (MultiByteToWideChar(CP_ACP, 0, rgbRegistryPath, -1, wszRegistryPath, MAX_PATH) == 0) {
        return(GetLastError());
    }
    
    if (wszKeyName)
    {
        wcscat(wszRegistryPath, wszKeyName);
    }

    return hrNone;
}

/*
 -  HrJetFileNameFromMungedFileName
 -
 *  Purpose:
 *
 *  This routine will convert the database names returned from JET into a form
 *  that the client can use.  This is primarily there for restore - the client
 *  will get the names in UNC format relative to the root of the server, so they
 *  can restore the files to that location.
 *  
 *  Please note that a munged file name might not be from the local machine.
 *
 *  Parameters:
 *
 *      cxh - the server side context handle for this operation.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  hrNone if successful, reasonable value if not.
 *
 */

HRESULT
HrJetFileNameFromMungedFileName(
    WSZ wszMungedName,
    SZ *pszJetFileName
    )
{
    CB cbJetName;
    SZ szJetFileName;
    WSZ wszJetNameStart;
    BOOL fUsedDefault;

    //
    //  Make sure this is a munged file name.
    //
    //  A munged file has the following format:
    //
    //  \\server\<drive>$\<path>
    //

    if (wszMungedName[0] != '\\' ||
        wszMungedName[1] != '\\' ||
        (wszJetNameStart = wcschr(&wszMungedName[2], '\\')) == 0 ||
        !iswalpha(*(wszJetNameStart+1)) ||
        *(wszJetNameStart+2) != L'$' ||
        ((*(wszJetNameStart+3) != L'\\') && (*(wszJetNameStart+3) != L'\0')) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  Ok, we know the name is of the form:
    //
    //  \\server\<drive>$\<file>
    //
    //  And wszJetNameStart is:
    //
    //  \<drive>$\<file>
    //

    // need an extra for "\\brettsh-posh\c$" where we add a trailing '\', this
    // is overallocated by 1, b/c the initial '\' gives us NUL space.
    cbJetName = wcslen(wszJetNameStart) + 2;

    szJetFileName = MIDL_user_allocate(cbJetName);

    if (szJetFileName == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    szJetFileName[0] = (CHAR)*(wszJetNameStart+1);  // Drive letter.
    szJetFileName[1] = ':'; //  form <drive>:

    if (!WideCharToMultiByte(CP_ACP, 0, wszJetNameStart+3, -1,
                                          &szJetFileName[2],
                                          cbJetName-2,
                                          "?", &fUsedDefault))
    {
        MIDL_user_free(szJetFileName);
        return(GetLastError());
    }
    if (szJetFileName[2] == '\0') {
        // This is the case of "\\brettsh-posh\c$" being passed in, need
        // to add a trailing backslash so we get "C:\" out.
        szJetFileName[2] = '\\';
        szJetFileName[3] = '\0';
    }

    *pszJetFileName = szJetFileName;

    return(hrNone);
}

HRESULT
HrLocalCleanupOldLogs(
    WSZ wszCheckpointFilePath,
    WSZ wszLogPath, 
    ULONG genLow, 
    ULONG genHigh
    )
{
    HRESULT hr = hrNone;
    SZ szUnmungedLogPath = NULL;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA findData;
    // We use MAX_PATH+10 so we can have MAX_PATH of directory, plus 10 of filespec
    char szLogFileWildCard[MAX_PATH + 10];
    char szLogFileName[MAX_PATH + 10]; // logfile name with full path (e-x c:\winnt\ntds\edb0006A.log)
    char *pszFileName = NULL;         // final component of the logfilename (e-x:  edb0006A.log)   
    char szCheckpointFileName[MAX_PATH + 10]; // Checkpoint file name with full path
    DWORD dwErr, dwCheckpointFileLength;

    if ( (NULL == wszCheckpointFilePath) ||
         (NULL == wszLogPath) ||
         (genHigh < genLow) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try 
    {
        //
        // Delete old checkpoint files (edb.chk)
        //

        // Convert the UNC logpath to the regular drive based logpath 
        hr = HrJetFileNameFromMungedFileName(wszCheckpointFilePath, &szUnmungedLogPath);
        if (hrNone != hr)
        {
            __leave;
        }
        lstrcpynA(szCheckpointFileName, szUnmungedLogPath, MAX_PATH);
        MIDL_user_free(szUnmungedLogPath);
        szUnmungedLogPath = NULL;
        dwCheckpointFileLength = strlen( szCheckpointFileName );
        // Append a \ if not there already
        if ('\\' != szCheckpointFileName[dwCheckpointFileLength - 1]) {
            strcat(szCheckpointFileName, "\\");
            dwCheckpointFileLength++;
        }

        // Delete unneeded checkpoint files
        strcpy( szCheckpointFileName + dwCheckpointFileLength, "edb.chk" );
        // If the file is there...
        if (0xffffffff != GetFileAttributesA( szCheckpointFileName ) ) {
            if (!DeleteFileA(szCheckpointFileName))
            {
                // Unable to delete the old logfile; not cleaning up will cause problems later
                // return failure code
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32( dwErr );
                __leave;
            }
        }

        //
        // Set up log paths
        //

        // Convert the UNC logpath to the regular drive based logpath 
        hr = HrJetFileNameFromMungedFileName(wszLogPath, &szUnmungedLogPath);
        if (hrNone != hr)
        {
            __leave;
        }

        // copy the the unmunged LogPath (it's of the form c:\winnt\ntlog or c:\winnt\ntlog\ )
        // make two copies of the logpath - one to pass a wildcard string for searching and
        // other to create filenames with full path for the logfiles found
        lstrcpynA(szLogFileWildCard, szUnmungedLogPath, MAX_PATH);
        lstrcpynA(szLogFileName, szUnmungedLogPath, MAX_PATH);

        // append the wildcard string to search for all *.log files from the logpath
        if ('\\' == szLogFileWildCard[strlen(szLogFileWildCard) - 1])
        {
            // given logpath has a backslash at the end
            strcat(szLogFileWildCard, "*.log");
        }
        else
        {
            // given logpath does not have a backslash at the end
            strcat(szLogFileWildCard, "\\*.log");
            strcat(szLogFileName, "\\");
        }

        //
        // Delete old log files (edbxxx.log, *.log)
        //

        // make pszFileName poing to the terminating null in szLogFileName
        pszFileName = &szLogFileName[strlen(szLogFileName)];

        hFind = FindFirstFileA(szLogFileWildCard, &findData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            // Nothing to cleanup - return success
            hr = hrNone;
            __leave;
        }

        do
        {
            BOOL fDelete = FALSE;
            // We are only in this loop if file is a log file, but we only want to
            // delete the edb.log file and any edbXXXXX.log file where the XXXXX
            // number is outside of our genLow - genHigh range.

            if (_strnicmp( findData.cFileName, "edb.log", 7) == 0){
                // Must delete the "edb.log" file.
                fDelete = TRUE;
            } else if ( (_strnicmp( findData.cFileName, "edb", 3 ) == 0) &&
                        (strlen(findData.cFileName) >= 9) && // make sure we don't overwalk our array.
                        isxdigit(findData.cFileName[3]) && 
                        isxdigit(findData.cFileName[4]) &&
                        isxdigit(findData.cFileName[5]) &&
                        isxdigit(findData.cFileName[6]) &&
                        isxdigit(findData.cFileName[7]) &&
                        (_strnicmp(&(findData.cFileName[8]), ".log", 4) == 0)
                       ) {
                // Only delete edbxxxxx.log where sequence is outside of
                // a certain range.

                // findData.cFileName points to the name of edb*.log file found
                ULONG ulLogNo = strtoul(findData.cFileName + 3, NULL, 16);
                
                fDelete = (ulLogNo < genLow) || (ulLogNo > genHigh);

            }
            if (fDelete) {
                // This is an old logfile which was not copied down by ntbackup - clean it up

                // first append the filename to the logpath (note:- pszFileName already pointing
                // to the byte at the end of the final backslash in logpath) and then delete the
                // file by passing in the filename with full path
                strcpy(pszFileName, findData.cFileName); 
                if (!DeleteFileA(szLogFileName))
                {
                    // Unable to delete the old logfile; not cleaning up will cause problems later
                    // return failure code
                    dwErr = GetLastError();
                    hr = HRESULT_FROM_WIN32( dwErr );
                    __leave;
                }
            }
        } while (FindNextFileA(hFind, &findData));
        
        if (ERROR_NO_MORE_FILES != (dwErr = GetLastError()))
        {
            // we came out of the loop for some unexpected error - return the error code
            hr = HRESULT_FROM_WIN32( dwErr );
            __leave;
        }

        // We are done cleaningup
        hr = hrNone;
        // fall out the end
    }
    __finally
    {
        if (szUnmungedLogPath)
        {
            MIDL_user_free(szUnmungedLogPath);
        }

        if (INVALID_HANDLE_VALUE != hFind)
        {
            FindClose(hFind);
        }
    }

    return hr;
}

HRESULT
HrLocalRestoreRegister(
    WSZ wszCheckpointFilePath,
    WSZ wszLogPath,
    EDB_RSTMAPW rgrstmap[],
    C crstmap,
    WSZ wszBackupLogPath,
    ULONG genLow,
    ULONG genHigh
    )
{
    WCHAR rgwcRegistryPath[ MAX_PATH ];
    HRESULT hr = hrNone;
    HKEY hkey = NULL;
    CB cbRstMap = 0;
    WSZ wszRstMap = NULL;
    WSZ wszRstEntry;
    I irgrstmap;

    __try
    {
        DWORD dwDisposition;
        DWORD dwType;
        DWORD cbGen;
        ULONG genCurrent;
        BOOLEAN fDatabaseRecovered = fFalse;
        BYTE rgbSD[200];
        BYTE rgbACL[200];
        PACL pACL = (PACL)rgbACL;
        PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) rgbSD;
        PSID psidUser;
        SECURITY_ATTRIBUTES sa;
        SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID psidAdmin;
        PSID psidEveryone;

        hr = HrLocalGetRegistryBase(rgwcRegistryPath, RESTORE_IN_PROGRESS);

        if (hr != hrNone)
        {
            __leave;
        }

        //
        //  Construct the default security descriptor allowing access to all
        //  this is used to allow authenticated connections over LPC.
        //  By default LPC allows access only to the same account
        //

        // FUTURE-2002/03/18-BrettSh - SDDL routines are easier to use, and allow us to wipe out so much error prone code.

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            DebugTrace(("Error %d constructing a security descriptor\n", GetLastError()));
            pSD = NULL;
        }

        if (pSD && !InitializeAcl(pACL, sizeof(rgbACL), ACL_REVISION))
        {
            DebugTrace(("Error %d constructing an ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        GetCurrentSid(&psidUser);

        if (pSD && pACL && psidUser && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_ALL_ACCESS, psidUser))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidUser != NULL)
        {
            MIDL_user_free(psidUser);
        }

        if (!AllocateAndInitializeSid(&siaNt, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdmin)) {
            DebugTrace(("Error %d Allocating SID for admin.\n", GetLastError()));
        }

        if (pSD && pACL && psidAdmin && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidAdmin)
        {
            FreeSid(psidAdmin);
            psidAdmin = NULL;
        }

        if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID,0, 0, 0, 0, 0, 0, 0, &psidEveryone)) {
            DebugTrace(("Error %d Allocating SID for world.\n", GetLastError()));
        }

        if (pSD && pACL && psidEveryone && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_READ, psidEveryone))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidEveryone)
        {
            FreeSid(psidEveryone);
            psidEveryone = NULL;
        }
        if (pSD && pACL && !SetSecurityDescriptorDacl(pSD,  TRUE, pACL, FALSE))
        {
            DebugTrace(("Error %d setting a security descriptor ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (pSD && pACL)
        {
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = fFalse;
            sa.nLength = sizeof(sa);
        }

        if (hr = RegCreateKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryPath, 0, 0, 0, KEY_WRITE | KEY_READ, &sa, &hkey, &dwDisposition))
        {
            __leave;
        }

        
        //
        //  Seed the restore-in-progress in the registry.
        //

        hr = hrRestoreInProgress;

        if (hr = RegSetValueExW(hkey, RESTORE_STATUS, 0, REG_DWORD, (LPBYTE)&hr, sizeof(DWORD)))
        {
            __leave;
        }


        //
        //  We've now interlocked other restore operations from coming in from other machines.
        //

        if (wszBackupLogPath)
        {
            hr = RegSetValueExW(hkey, BACKUP_LOG_PATH, 0, REG_SZ, (LPBYTE)wszBackupLogPath, (wcslen(wszBackupLogPath)+1)*sizeof(WCHAR));
    
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (wszCheckpointFilePath)
        {
            hr = RegSetValueExW(hkey, CHECKPOINT_FILE_PATH, 0, REG_SZ, (LPBYTE)wszCheckpointFilePath, (wcslen(wszCheckpointFilePath)+1)*sizeof(WCHAR));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (wszLogPath)
        {
            hr = RegSetValueExW(hkey, LOG_PATH, 0, REG_SZ, (LPBYTE)wszLogPath, (wcslen(wszLogPath)+1)*sizeof(WCHAR));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        //
        //  Reset the "database recovered" bit.
        //
        hr = RegSetValueExW(hkey, JET_DATABASE_RECOVERED, 0, REG_BINARY, (LPBYTE)&fDatabaseRecovered, sizeof(BOOLEAN));
        if (hr != hrNone)
        {
            __leave;
        }


        dwType = REG_DWORD;
        cbGen = sizeof(DWORD);

        hr = RegQueryValueExW(hkey, LOW_LOG_NUMBER, 0, &dwType, (LPBYTE)&genCurrent, &cbGen);

        if (crstmap != 0 || hr != hrNone || genLow < genCurrent)
        {
            hr = RegSetValueExW(hkey, LOW_LOG_NUMBER, 0, REG_DWORD, (LPBYTE)&genLow, sizeof(DWORD));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        hr = RegQueryValueExW(hkey, HIGH_LOG_NUMBER, 0, &dwType, (LPBYTE)&genCurrent, &cbGen);

        if (crstmap != 0 || hr != hrNone || genHigh > genCurrent)
        {
            hr = RegSetValueExW(hkey, HIGH_LOG_NUMBER, 0, REG_DWORD, (LPBYTE)&genHigh, sizeof(DWORD));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (crstmap)
        {

//
//          //
//          //  If there's already a restore map size (or restore map), then you can't set
//          //  another restore map.  The restore map should only be set on a full backup.
//          //
//
//          if ((hr = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&genCurrent, &cbGen)) != ERROR_FILE_NOT_FOUND)
//          {
//              return hrRestoreMapExists;
//          }
//

            //
            //  Save away the size of the restore map.
            //

            hr = RegSetValueExW(hkey, JET_RSTMAP_SIZE, 0, REG_DWORD, (LPBYTE)&crstmap, sizeof(DWORD));
    
            //
            //  We now need to convert the restore map into one that we can put into the
            //  registry.
            //
    
            //
            //  First figure out how big this thing is going to be.
            //
            for (irgrstmap = 0 ; irgrstmap < crstmap ; irgrstmap += 1)
            {
                cbRstMap += wcslen(rgrstmap[irgrstmap].wszDatabaseName)+wcslen(rgrstmap[irgrstmap].wszNewDatabaseName)+2;
            }
    
            cbRstMap *= sizeof(WCHAR);
    
            wszRstMap = MIDL_user_allocate(cbRstMap+sizeof(WCHAR));
    
            if (wszRstMap == NULL)
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_SERVER_MEMORY );
                __leave;
            }
    
            wszRstEntry = wszRstMap;
    
            for (irgrstmap = 0 ; irgrstmap < crstmap ; irgrstmap += 1)
            {
                wcscpy(wszRstEntry, rgrstmap[irgrstmap].wszDatabaseName);
                wszRstEntry += wcslen(wszRstEntry)+1;
    
                wcscpy(wszRstEntry, rgrstmap[irgrstmap].wszNewDatabaseName);;
                wszRstEntry += wcslen(wszRstEntry)+1;
            }
    
            *wszRstEntry++ = L'\0';
    
            hr = RegSetValueExW(hkey, JET_RSTMAP_NAME, 0, REG_MULTI_SZ, (LPBYTE)wszRstMap, (DWORD)(wszRstEntry-wszRstMap)*sizeof(WCHAR));
        }
        else
        {
            if ((hr = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&genCurrent, &cbGen)) != NO_ERROR)
            {
                hr = hrNoFullRestore;
            }
        }

        //
        // Create the new Database Invocation ID.This will be used by both
        // authoritative restore and boot recovery. This would cause AR to
        // fail.
        //

        {
            GUID tmpGuid;

            hr = CreateNewInvocationId(TRUE,        // save GUID in Database
                                       &tmpGuid);

            //
            // Log and fail if we can't create. 
            //

            if ( hr != S_OK ) {

                LogNtdsErrorEvent(DIRLOG_FAILED_TO_CREATE_INVOCATION_ID,
                                  hr);
            }
        }

        if (hrNone == hr)
        {
            // We have successfully registered the restore, now cleanup the any pre-existing logfiles
            // in the logdir to avoid JetExternalRestore() from using logfiles that are not specified
            // by the lowlog and highlog numbers.

            hr = HrLocalCleanupOldLogs(
                wszCheckpointFilePath,
                wszLogPath,
                genLow, genHigh);
        }

    }
    __finally
    {
        if (wszRstMap != NULL)
        {
            MIDL_user_free(wszRstMap);
        }

        if (hkey != NULL)
        {
            RegCloseKey(hkey);
        }
    }


    return hr;
}

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore )
{
    WCHAR rgwcRegistryPath[ MAX_PATH ];
    HRESULT hr = hrNone;
    HKEY hkey;
    
        hr = HrLocalGetRegistryBase(rgwcRegistryPath, RESTORE_IN_PROGRESS);
    
        if (hr != hrNone)
        {
            return hr;
        }

        if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryPath, 0, KEY_WRITE | DELETE, &hkey))
        {
            //
            //  We want to ignore file_not_found - it is ok.
            //
            if (hr == ERROR_FILE_NOT_FOUND)
            {
                return(ERROR_SUCCESS);
            }
    
            return(hr);
        }
    
        //
        //  If the restore status is not success, then set the status to the error.
        //  If the restore status is success, then clear the "restore-in-progress"
        //  indicator.
        //
        if (hrRestore != hrNone)
        {
            hr = RegSetValueExW(hkey, RESTORE_STATUS, 0, REG_DWORD, (BYTE *)&hrRestore, sizeof(HRESULT));
        }
        else
        {
            hr = RegDeleteValueW(hkey, RESTORE_STATUS);
        }
    
        RegCloseKey(hkey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\options.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       options.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1996

Module Name:

    options.h

Abstract:

    This module contains compile time options for the jet backup APIs.


Author:

    Larry Osterman (larryo) 2-Sep-1994


Revision History:


--*/

#ifndef	_OPTIONS_
#define	_OPTIONS_
#define	SOCKETS	1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbsock.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetbsock.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetbsock.c

Abstract:

    This module provides socket support for the exchange MDB/DS backup APIs.


Author:

    Larry Osterman (larryo) 1-Sep-1994


Revision History:

--*/
#define UNICODE

#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <rpcdce.h>
#include <svcguid.h>

#ifdef  SOCKETS

WSADATA
wsaDataClient;

WSADATA
wsaDataServer;

HRESULT
HrCreateBackupSockets(
    SOCKET rgsockSocketHandles[],
    PROTVAL rgprotvalProtocolsUsed[],
    C *pcSocket
    )
/*++

Routine Description:

    This will create a socket for each of the socket protocols registered
    for backup processing.

Arguments:

    rgsockSocketHandles - Filled in with the sockets that have been allocated.
    rgprotvalProtocolsUsed - Protocol value for each of the socket handles.
    pcSocket - IN: the maximum number of entries available in the rgsockSocketHandles array.
                OUT: the number of actual sockets read.

Return Value:

    HRESULT - hrNone if no error, otherwise a reasonable value.

--*/
{
    SOCKET sock;

    //
    //  Start at the beginning.
    //
    *pcSocket = 0;

    sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if ( sock != INVALID_SOCKET ) {
        HRESULT hrErr;
        struct sockaddr_in sockaddr = {0};

        sockaddr.sin_family = AF_INET;

        //
        // Bind the socket to the local address specified.
        //

        hrErr = bind( sock, (PSOCKADDR)&sockaddr, sizeof(sockaddr) );
        if ( hrErr != NO_ERROR ) {
            closesocket( sock );
            return hrErr;
        }

        //
        // Start listening for incoming sockets on the socket if this is
        // not a datagram socket.  If this is a datagram socket, then
        // the listen() API doesn't make sense; doing a bind() is
        // sufficient to listen for incoming datagrams on a
        // connectionless protocol.
        //
    
        hrErr = listen( sock, 5 );
        if ( hrErr != NO_ERROR ) {
            closesocket( sock );
            return hrErr;
        }

        //
        //  Ok, we're ready to rock&roll now.
        //

        rgsockSocketHandles[*pcSocket] = sock;
        rgprotvalProtocolsUsed[*pcSocket] = IPPROTO_TCP;
        *pcSocket += 1;

    }
    //
    //  The client socket has been created, and it is now listening, we
    //  can finish now.
    //

    return(hrNone);
}


SOCKET
SockWaitForConnections(
    SOCKET rgsockSocketHandles[],
    C cSocketMax
    )
/*++

Routine Description:

    Waits for a connection to be established on any of the specified sockets.

Arguments:

    rgsockSocketHandles - An array of socket handles to accept connections on.
    C cSocketMax - The number of sockets to wait on.

Return Value:

    A connected socket handle, or INVALID_SOCKET if the connection
    could not be established.

--*/
{
    I iT;
    C cSocketsConnected;
    fd_set fdset;
    struct timeval timeval = {5, 0};

    fdset.fd_count = 0;

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        FD_SET(rgsockSocketHandles[iT], &fdset);
    }


    cSocketsConnected = select(FD_SETSIZE, &fdset, NULL, NULL, &timeval);

    if (cSocketsConnected == 0)
    {
        SetLastError(WAIT_TIMEOUT);
        return(INVALID_SOCKET);
    }
    else if (cSocketsConnected == SOCKET_ERROR)
    {
        return(INVALID_SOCKET);
    }

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        if (FD_ISSET(rgsockSocketHandles[iT], &fdset)) {
            return(accept(rgsockSocketHandles[iT], NULL, 0));
        }
    }

    return INVALID_SOCKET;
}

HRESULT
HrSockAddrsFromSocket(
    OUT SOCKADDR sockaddr[],
    OUT C *pcSocket,
    IN SOCKET sock,
    IN PROTVAL protval
    )
/*++

Routine Description:

    Converts a socket handle into a sockaddr suitable for connecting to the specified socket.

Arguments:

    sockaddr - the socket to connect to.
    sock - the socket to convert.
    protval - the protocol used for the socket.

Return Value:

    ecNone if the operation as successful, a reasonable value otherwise.

--*/
{

    switch (protval)
    {
    case IPPROTO_TCP:
        {
            CB cbAddrSize = sizeof(SOCKADDR);
            SOCKADDR sockaddrT;
            char    rgchComputerName[MAX_COMPUTERNAME_LENGTH + 1];
            CB cbComputerName = sizeof(rgchComputerName);
            struct hostent *hostentT;
            struct sockaddr_in *sockaddrinT = (struct sockaddr_in *)sockaddr;

            if (getsockname(sock, &sockaddrT, &cbAddrSize) == INVALID_SOCKET) {
                return(GetLastError());
            }
        
            if (cbAddrSize > sizeof(SOCKADDR))
            {
                return(hrInvalidParam);
            }
        
            if (gethostname(rgchComputerName, cbComputerName) == SOCKET_ERROR)
            {
                return(GetLastError());
            }

            hostentT = gethostbyname(rgchComputerName);

            //
            //  If there are multiple entries to return, return them.
            //

            *pcSocket = 0;
            while (hostentT->h_addr_list[*pcSocket])
            {
                //
                //  Copy in the fixed portion of the socket address.
                //

                memcpy(sockaddrinT, &sockaddrT, cbAddrSize);
                sockaddrinT->sin_addr = *((struct in_addr *)hostentT->h_addr_list[*pcSocket]);
                *pcSocket += 1;
                sockaddrinT = (struct sockaddr_in *)(++sockaddr);
            }

            break;
        }
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return(hrNone);
}

SOCKET
SockConnectToRemote(
    SOCKADDR rgsockaddrClient[],
    C cSocketMax
    )
/*++

Routine Description:

    Converts a socket handle into a sockaddr suitable for connecting to the specified socket.

Arguments:

    rgsockaddrClient - The address of the client.
    rgprotvalClient - the protocol used by the client.
    cSocketMax - the number of sockets that can be used to connect to the client.

Return Value:

    scNone if the operation as successful, a reasonable value otherwise.

--*/
{
    I iT;
    SOCKET sock;

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        if (rgsockaddrClient[iT].sa_family == AF_INET)
        {
            struct sockaddr_in sockaddrLocal;

            memset(&sockaddrLocal, 0, sizeof(struct sockaddr_in));

            sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP);

            //
            //  If we can't open a socket with this address, keep on trying.
            //
            if (sock == INVALID_SOCKET)
            {
                continue;
            }

            //
            //  Bind this socket to the first available port on the server.
            //

            sockaddrLocal.sin_family = AF_INET;
            sockaddrLocal.sin_port = 0;
            sockaddrLocal.sin_addr.s_addr = 0;

            if (bind(sock, (struct sockaddr *)&sockaddrLocal, sizeof(struct sockaddr_in)) == SOCKET_ERROR)
            {
                closesocket(sock);
                sock = INVALID_SOCKET;
                continue;
            }

            //
            //  Now connect back to the client.
            //
            if (connect(sock, &rgsockaddrClient[iT], sizeof(struct sockaddr_in)) == SOCKET_ERROR)
            {
                closesocket(sock);
                sock = INVALID_SOCKET;
                continue;
            }

            //
            //  It succeeded, we're done.
            //

            return(sock);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(INVALID_SOCKET);
        }
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return INVALID_SOCKET;
}


BOOL
FInitializeSocketClient(
    )
{
    WORD wVersionRequested;
    int iError;
    wVersionRequested = MAKEWORD(1,1);

    //
    //  Register ourselves with winsock.
    //

    iError = WSAStartup(wVersionRequested, &wsaDataClient);

    //
    //  The winsock implementation is not version 1.1, so
    //  punt.
    //

    if (iError != 0)
    {
        return(FALSE);
    }


    return(fTrue);
}

BOOL
FUninitializeSocketClient(
    )
{
    return(fTrue);
}
BOOL
FInitializeSocketServer(
    )
{
    WORD wVersionRequested;
    int iError;
    wVersionRequested = MAKEWORD(1,1);

    //
    //  Register ourselves with winsock.
    //

    iError = WSAStartup(wVersionRequested, &wsaDataServer);

    //
    //  The winsock implementation is not version 1.1, so
    //  punt.
    //

    if (iError != 0)
    {
        return(FALSE);
    }

    return(fTrue);

}

BOOL
FUninitializeSocketServer(
    )
{
    return(fTrue);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\mxsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mxsutil.h
//
//--------------------------------------------------------------------------

/*
 *      General include file
 */

#ifndef MXSUTIL_INCLUDED
#define	MXSUTIL_INCLUDED	1

#include "util.h"

#ifdef DOS16
#define __export
#define _export
#define export
#endif

//#ifndef NONMAPI
//#include "mapiwin.h"
//#endif
#endif // MXSUTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       util.h
//
//--------------------------------------------------------------------------

/*
 *	Declarations for utilities common to store and msp.
 */

#ifndef UTIL_INCLUDED
#define UTIL_INCLUDED

#include "assert.h"
#include "malloc.h"
#include "memory.h"
#include "string.h"
#include "stdio.h"

//#define	FARSTRUCT

#ifdef __cplusplus
extern "C"
{
#endif

#include "windows.h"

#ifdef __cplusplus
}
#endif

#include "debug.h"

/* Count, index types */
#define	UINT_MAX	(UINT)0x7FFFFFFF
typedef LONG	C;
typedef LONG	I;

/* Other Hungarian */
typedef char *	SZ;
typedef WCHAR *	WSZ;
typedef long	EC;
typedef void *	PV;
typedef C		CB;
typedef I		IB;
typedef BYTE *	PB;
typedef C		CCH;
typedef	char *	PCH;

/* Standard Boolean values */
#define	fFalse	((BOOL)0)
#define fTrue	((BOOL)1)

#endif // UTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\idl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

#
# This is the MIDL compile phase of the build process.
#

!INCLUDE $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

UNICODE=1

SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)

INCS  = -I$(SDKINC) -I$(SDKCRTINC) -I..\..\inc -I..\..\xinc -I..

EXTRN_DEPENDS = $(SDKINC)\winbase.h \
                $(SDKINC)\windef.h

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"


$(O)\jetbak.h : jetbak.idl jetbak.acf imports.h imports.idl ..\options.h $(EXTRN_DEPENDS)
    midl -Oicf -robust -oldnames -error ref -ms_ext -c_ext $(CPP) -out .\$(O) $(INCS) .\jetbak.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\idl\imports.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       imports.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <winbase.h>
#include <lmcons.h>
#define	_INC_WINDOWS
#include <winsock.h>
#include <ntdsbcli.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif

#include <options.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetback\dirapi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dirapi.c

Abstract:

    Routines to obtain data from the ds using the DirXXX api
    Used for in-process, non-ntdsa callers.
    This code is intended to be used by the backup server dll, which is
    dynamically loaded into lsass.  The DirApi will only work when NTDSA
    is active (that is, not during DS Restore Mode).

Author:

    Will Lees (wlees) 06-Apr-2001

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <winbase.h>
#include <tchar.h>
#include <string.h>
#include <dsconfig.h>
#include <ntdsa.h>
#include <attids.h>
#include <direrr.h>

#define DEBSUB "DIRAPI:"       // define the subsystem for debugging
#include "debug.h"              // standard debugging header
#include <fileno.h>
#define  FILENO FILENO_DIRAPI
#include "dsevent.h"
#include "mdcodes.h"            // header for error codes

/* External */

/* Static */

/* Forward */
/* End Forward */


DWORD
getTombstoneLifetimeInDays(
    VOID
    )

/*++

Routine Description:

    Get the forest tombstone lifetime, in days. If none is set or an error occurs,
    we return the default.

Arguments:

    VOID - 

Return Value:

    DWORD - lifetime, in days

--*/

{
    NTSTATUS NtStatus;

    ULONG        Size;
    DSNAME       *DsServiceConfigName = 0;
    ULONG        dirError;

    ATTR      rgAttrs[] =
    {
        { ATT_TOMBSTONE_LIFETIME, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    READARG   ReadArg;
    READRES   *pReadRes = 0;

    DWORD iAttr;
    DWORD dwTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;

    try {

        //
        // Create a thread state
        //
        if (THCreate( CALLERTYPE_INTERNAL )) {

            leave;

        }

        // Find DN of Ds Service Config Object
        Size = 0;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DS_SVC_CONFIG,
                                         &Size,
                                         DsServiceConfigName );
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            __leave;
        }

        DsServiceConfigName = (DSNAME*) malloc( Size );
        if (DsServiceConfigName == NULL) {
            NtStatus = I_RpcMapWin32Status(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_DS_SVC_CONFIG,
                                         &Size,
                                         DsServiceConfigName );
        if (NtStatus) {
            __leave;
        }

        // Set up read args
        RtlZeroMemory(&ReadArg, sizeof(ReadArg));

        ReadArg.pObject = DsServiceConfigName;

        ReadArg.pSel    = &Sel;

        //
        // Setup the common arguments
        //
        InitCommarg(&ReadArg.CommArg);

        // Trusted caller
        SampSetDsa( TRUE );

        // Clear errors
        THClearErrors();

        //
        // We are now ready to read!
        //
        ;
        // FUTURE-2002/03/18-BrettSh/WLees - Useage of Dir API should really be replaced by 
        // GetConfigurationName(), which is much less likely to make a dumb mistake.
        dirError = DirRead(&ReadArg, &pReadRes);

        if ( 0 != dirError )
        {
            if ( attributeError == dirError )
            {
                INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

                if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                        && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
                    )
                {
                    // No value; use default (as set above).
                    dirError = 0;
                }
            }

            if ( 0 != dirError )
            {
                LogEvent8(
                    DS_EVENT_CAT_BACKUP,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_BACKUP_DIR_READ_FAILURE,
                    szInsertDN(DsServiceConfigName),
                    szInsertInt(dirError),
                    szInsertSz(THGetErrorString()),
                    szInsertHex(DSID(FILENO,__LINE__)),
                    NULL, NULL, NULL, NULL
                    ); 
                __leave;
            }
        }
        else
        {
            // Read succeeded; parse returned attributes.
            for ( iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
            {
                ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

                switch ( pattr->attrTyp )
                {
                case ATT_TOMBSTONE_LIFETIME:
                    Assert( 1 == pattr->AttrVal.valCount );
                    Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                    dwTombstoneLifetimeDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                    break;
            
                default:
                    DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                    break;
                }
            }

            if ( dwTombstoneLifetimeDays < DRA_TOMBSTONE_LIFE_MIN )
            {
                // Invalid value; use default.
                dwTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
            }
        }
    }
    finally
    {
        if (DsServiceConfigName) { free(DsServiceConfigName); }
        THDestroy();
    }

    DPRINT1( 1, "Tombstone Lifetime is %d days.\n", dwTombstoneLifetimeDays );

    return dwTombstoneLifetimeDays;
} /* getTombstoneLifetimeInDays */

/* end dirapi.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetback\jetrest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jetrest.c
//
//--------------------------------------------------------------------------

/*
 *  JETREST.C
 *  
 *  JET restore API support.
 *  
 *  
 */
#define UNICODE

#include <ntdspch.h>

#include <ntseapi.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <ntdsa.h>     // need DSTIME structure.
#include <ntdsbsrv.h>
#include <rpc.h>
#include <dsconfig.h>
#include <safeboot.h>
#include <mdcodes.h>  // for DIRMSG's
#include <ntdsa.h>    // for dsevent.h
#include <dsevent.h>  // for logging support
#include <usn.h>
#include <msrpc.h>

#include <stdlib.h>
#include <stdio.h>

#include <fileno.h>
#define FILENO   FILENO_JETBACK_JETREST	

#include <strsafe.h>

#include "local.h"  // common functions shared by client and server
#include "snapshot.hxx"


BOOL
fRestoreRegistered = fFalse;

BOOL
fSnapshotRegistered = fFalse;

BOOL
fRestoreInProgress = fFalse;

extern BOOL g_fBootedOffNTDS;

// proto-types
EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    );

EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    );

HRESULT
HrGetDatabaseLocations(
    WSZ *pwszDatabases,
    CB *pcbDatabases
    );


/*
 -  HrRIsNTDSOnline
 *
 *  Purpose:
 *  
 *      This routine tells if the NT Directory Service is Online or not.
 *
 *  Parameters:
 *      hBinding - An RPC binding handle for the operation - ignored.
 *      pfDSOnline - Boolean that receives TRUE if the DS is online; FALSE
 *                   otherwise.store target to restore.
 *  Returns:
 *      HRESULT - status of operation. hrNone if successful; error code if not.
 *
 */
HRESULT HrRIsNTDSOnline(handle_t hBinding, BOOLEAN *pfDSOnline)
{
    HRESULT hr = hrNone;

    *pfDSOnline = (BOOLEAN) g_fBootedOffNTDS;

    return hr;
}

/*
 -  HrRRestorePrepare
 *
 *  Purpose:
 *  
 *      This routine will prepare the server and client for a restore operation.
 *      It will allocate the server side context block and will locate an appropriate
 *      restore target for this restore operation.
 *
 *  Parameters:
 *      hBinding - An RPC binding handle for the operation - ignored.
 *      szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which restore target to restore.
 *      pcxh - The RPC context handle for the operation.
 *
 *  Returns:
 *      EC - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT HrRRestorePrepare(
    handle_t hBinding,
    WSZ wszDatabaseName,
    CXH *pcxh)
{
    PJETBACK_SERVER_CONTEXT pjsc = NULL;
    HRESULT hr;
    ULONG fLostRace = 0;

    // This call uses loose security, because backup clients can call this too.
    if (hr = HrValidateInitialRestoreSecurity()) {
        DebugTrace(("HrrRestorePrepare: Returns ACCESS_DENIED\n"));
        return(hr);
    }

    fLostRace = InterlockedCompareExchange(&fRestoreInProgress, fTrue, fFalse);
    if (fLostRace) {
        DebugTrace(("HrRRestorePrepare: InterlockedCompareExchange(&fRestoreInProgress) returned 1, meaning we lost race.\n"));
        return(hrRestoreInProgress);
    }
    DebugTrace(("HrRRestorePrepare: InterlockedCompareExchange(&fRestoreInProgress) returned 0, meaning we won race!\n"));

    pjsc = MIDL_user_allocate(sizeof(JETBACK_SERVER_CONTEXT));

    if (pjsc == NULL)
    {
        fRestoreInProgress = 0;
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    pjsc->fRestoreOperation = fTrue;

    *pcxh = (CXH)pjsc;

    return(hrNone);
}


/*

 -  HrRRestore
 *
 *  Purpose:
 *  
 *      This routine actually processes the restore operation.
 *
 *  Parameters:
 *
 *      cxh                     - The RPC context handle for this operation
 *      szCheckpointFilePath    - Checkpoint directory location.
 *      szLogPath               - New log path
 *      rgrstmap                - Mapping from old DB locations to new DB locations
 *      crstmap                 - Number of entries in rgrstmap
 *      szBackupLogPath         - Log path at the time of backup.
 *      genLow                  - Low log #
 *      genHigh                 - High log # (logs between genLow and genHigh must exist)
 *      pfRecoverJetDatabase    - IN/OUT - on IN, indicates if we are supposed to use JET to recover
 *                                  the DB.  on OUT, indicates if we successfully recovered the JET database.
 *
 *  Returns:
 *
 *      EC - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */

HRESULT HrRestoreLocal(
    WSZ szCheckpointFilePath,
    WSZ szLogPath,
    EDB_RSTMAPW __RPC_FAR rgrstmap[  ],
    C crstmap,
    WSZ szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh,
    BOOLEAN *pfRecoverJetDatabase
    )
{
    HRESULT hr = hrNone;
    SZ szUnmungedCheckpointFilePath = NULL;
    SZ szUnmungedLogPath = NULL;
    SZ szUnmungedBackupLogPath = NULL;
    JET_RSTMAP *rgunmungedrstmap = NULL;
    DWORD err; //delete me

    __try {
        if (szCheckpointFilePath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szCheckpointFilePath, &szUnmungedCheckpointFilePath);
        }

        if (hr != hrNone) {
            __leave;
        }

        if (szLogPath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szLogPath, &szUnmungedLogPath);
        }

        if (hr != hrNone) {
            __leave;
        }

        if (szBackupLogPath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szBackupLogPath, &szUnmungedBackupLogPath);
        }

        if (hr != hrNone) {
            __leave;
        }

        //
        //  Now unmunge the restoremap....
        //

        if (crstmap)
        {
            I irgunmungedrstmap;
            rgunmungedrstmap = MIDL_user_allocate(sizeof(JET_RSTMAP)*crstmap);
            if (rgunmungedrstmap == NULL)
            {
                hr = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                __leave;
            }

            for (irgunmungedrstmap = 0; irgunmungedrstmap < crstmap ; irgunmungedrstmap += 1)
            {
                hr = HrJetFileNameFromMungedFileName(rgrstmap[irgunmungedrstmap].wszDatabaseName,
                                                    &rgunmungedrstmap[irgunmungedrstmap].szDatabaseName);

                if (hr != hrNone) {
                    __leave;
                }

                hr = HrJetFileNameFromMungedFileName(rgrstmap[irgunmungedrstmap].wszNewDatabaseName,
                                                    &rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName);

                if (hr != hrNone) {
                    __leave;
                }
            }
        }

        //
        //  We've now munged our incoming parameters into a form that JET can deal with.
        //
        //  Now call into JET to let it munge the databases.
        //
        //  Note that the JET interpretation of LogPath and BackupLogPath is totally
        //  wierd, and we want to pass in LogPath to both parameters.
        //

        if (!*pfRecoverJetDatabase)
        {
            err = JetExternalRestore(szUnmungedCheckpointFilePath,
                                    szUnmungedLogPath,  
                                    rgunmungedrstmap,
                                    crstmap,
                                    szUnmungedLogPath,
                                    genLow,
                                    genHigh,
                                    NULL);

            hr = HrFromJetErr(err);
            if (hr != hrNone) {
                LogEvent(
                    DS_EVENT_CAT_BACKUP,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_DB_ERR_RESTORE_FAILED,
                    szInsertJetErrCode( err ),
                    szInsertHex( err ),
                    szInsertJetErrMsg( err ) )
                __leave;
            }
        }

        //
        //  Ok, we were able to recover the database.  Let the other side of the API know about it
        //  so it can do something "reasonable".
        //

        *pfRecoverJetDatabase = fTrue;


        //
        //  Mark the DS as a restored version
        //  [Add any external notification here.]
        //

        hr = EcDsarPerformRestore(szUnmungedLogPath,
                                                szUnmungedBackupLogPath,
                                                crstmap,
                                                rgunmungedrstmap
                                                );

    }
    __finally
    {
        if (szUnmungedCheckpointFilePath)
        {
            MIDL_user_free(szUnmungedCheckpointFilePath);
        }
        if (szUnmungedLogPath)
        {
            MIDL_user_free(szUnmungedLogPath);
        }
        if (szUnmungedBackupLogPath)
        {
            MIDL_user_free(szUnmungedBackupLogPath);
        }
        if (rgunmungedrstmap != NULL)
        {
            I irgunmungedrstmap;
            for (irgunmungedrstmap = 0; irgunmungedrstmap < crstmap ; irgunmungedrstmap += 1)
            {
                if (rgunmungedrstmap[irgunmungedrstmap].szDatabaseName)
                {
                    MIDL_user_free(rgunmungedrstmap[irgunmungedrstmap].szDatabaseName);
                }

                if (rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName)
                {
                    MIDL_user_free(rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName);
                }
            }

            MIDL_user_free(rgunmungedrstmap);
        }
    }

    return(hr);

}

HRESULT
HrGetRegistryBase(
    IN PJETBACK_SERVER_CONTEXT pjsc,
    OUT WSZ wszRegistryPath,
    OUT WSZ wszKeyName
    )
{
    return HrLocalGetRegistryBase( wszRegistryPath, wszKeyName );
}

HRESULT
HrRRestoreRegister(CXH cxh,
                    WSZ wszCheckpointFilePath,
                    WSZ wszLogPath,
                    C crstmap,
                    EDB_RSTMAPW rgrstmap[],
                    WSZ wszBackupLogPath,
                    ULONG genLow,
                    ULONG genHigh)
{
    HRESULT hr = hrNone;

    if (hr = HrValidateRestoreContextAndSecurity((PJETBACK_SERVER_CONTEXT)cxh)) {
        return(hr);
    }

    hr = HrLocalRestoreRegister(
            wszCheckpointFilePath,
            wszLogPath,
            rgrstmap,
            crstmap,
            wszBackupLogPath,
            genLow,
            genHigh
            );

    return hr;
}

HRESULT
HrRRestoreRegisterComplete(CXH cxh,
                    HRESULT hrRestore )
{
    HRESULT hr = hrNone;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT )cxh;
    
    if (hr = HrValidateRestoreContextAndSecurity(pjsc)) {
        return(hr);
    }

    hr = HrLocalRestoreRegisterComplete( hrRestore );

    return hr;
}

HRESULT
HrRRestoreGetDatabaseLocations(
    CXH cxh,
    C *pcbSize,
    char **pszDatabaseLocations
    )
{
    HRESULT hr = hrNone;
    *pszDatabaseLocations = NULL;
    *pcbSize = 0;

    // We use loose security here, because backup clients can call this too.
    if (hr = HrValidateRestoreContextAndSecurityLoose((PJETBACK_SERVER_CONTEXT)cxh)) {
        return(hr);
    }
    
    return HrGetDatabaseLocations((WSZ *)pszDatabaseLocations, pcbSize);
}



HRESULT
HrRRestoreEnd(
    CXH *pcxh)
{
    HRESULT hr = hrNone;
    PJETBACK_SERVER_CONTEXT pjsc = NULL;
    fRestoreInProgress = fFalse;

    if (pcxh == NULL){
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    pjsc = (PJETBACK_SERVER_CONTEXT)*pcxh;

    // We use loose security here, because backup clients can call this too.
    if (hr = HrValidateRestoreContextAndSecurityLoose(pjsc)) {
        return(hr);
    }

    RestoreRundown(pjsc); 

    MIDL_user_free(*pcxh);

    *pcxh = NULL;

    return(hrNone);
}

/*
 -  HrRRestoreCheckLogsForBackup
 -
 *
 *  Purpose:
 *      This routine checks to verify
 *
 *  Parameters:
 *      hBinding - binding handle (ignored)
 *      wszAnnotation - Annotation for service to check.
 *
 *  Returns:
 *      hrNone if it's ok to start the backup, an error otherwise.
 *
 */
HRESULT
HrRRestoreCheckLogsForBackup(
    handle_t hBinding,
    WSZ wszBackupAnnotation
    )
{
    HRESULT hr;

    if (hr = HrValidateInitialRestoreSecurity()) {
        return(hr);
    }

    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return(HrRestoreCheckLogsForBackup(wszBackupAnnotation));
}

HRESULT
HrRestoreCheckLogsForBackup(
    WSZ wszBackupAnnotation
    )
/*++

Description:

    True worker routine of HrRRestoreCheckLogsForBackup(), see it's
    description for details.  This was created so HrRBackupPrepare()
    didn't have to call this function through RPC/ntdsbcli.dll
    
--*/
{
    HRESULT hr;
    PRESTORE_DATABASE_LOCATIONS prqdl;
    HINSTANCE hinstDll;
    WCHAR   rgwcRegistryBuffer[ MAX_PATH ];
    CHAR    rgchInterestingComponentBuffer[ MAX_PATH * 4];
    CHAR    rgchMaxLogFilename[ MAX_PATH ];
    SZ      szLogDirectory = NULL;
    HKEY    hkey;
    DWORD   dwCurrentLogNumber;
    DWORD   dwType;
    DWORD   cbLogNumber;
    DWORD   cbInterestingBuffer;
    BOOL    fCircularLogging;


    //
    //  First check to see if we know what the last log was.
    //

    hr = StringCchPrintfW(rgwcRegistryBuffer,
                         sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
                         L"%ls%ls",
                         BACKUP_INFO,
                         wszBackupAnnotation);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return(hr);
    }

    if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, KEY_READ, &hkey))
    {
        //
        //  If we can't find the registry key, this means that we've never done a full backup.
        //
        if (hr == ERROR_FILE_NOT_FOUND)
        {
            return(hrFullBackupNotTaken);
        }

        return(hr);
    }

    dwType = REG_DWORD;
    cbLogNumber = sizeof(DWORD);
    hr = RegQueryValueExW(hkey, LAST_BACKUP_LOG, 0, &dwType, (LPBYTE)&dwCurrentLogNumber, &cbLogNumber);

    if (hr != hrNone)
    {
        RegCloseKey(hkey);
        return hrNone;
    }

    if (dwCurrentLogNumber == BACKUP_DISABLE_INCREMENTAL)
    {
        RegCloseKey(hkey);
        return hrIncrementalBackupDisabled;
    }

    //
    //  We now know the last log number, we backed up, check to see if the next
    //  log is there.
    //

    hr = EcDsaQueryDatabaseLocations(rgchInterestingComponentBuffer, &cbInterestingBuffer, NULL, 0, &fCircularLogging);

    if (hr != hrNone)
    {
        RegCloseKey(hkey);
        return hr;
    }

    //
    //  This is a bit late to figure this out, but it's the first time we
    //  have an opportunity to look for circular logging.
    //
    if (fCircularLogging)
    {
        RegCloseKey(hkey);
        return hrCircularLogging;
    }

    //
    //  The log path is the 2nd path in the buffer returned (the 1st is the system database directory).
    //

    // Temp:
    // #22467:  Restore.cxx was changed in #20416, and some special characters are put in the path.
    //          So here I am advancing by one more byte to accomodate the change in restore.cxx.
    //          The change is only temporary.
    
    szLogDirectory = &rgchInterestingComponentBuffer[strlen(rgchInterestingComponentBuffer)+2];

    Assert(szLogDirectory+MAX_PATH < rgchInterestingComponentBuffer+sizeof(rgchInterestingComponentBuffer));

    hr = StringCchPrintfA(rgchMaxLogFilename, MAX_PATH, "%s\\EDB%-5.5x.LOG", szLogDirectory, dwCurrentLogNumber);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return(hr);
    }

    if (GetFileAttributesA(rgchMaxLogFilename) == -1)
    {
        hr = hrLogFileNotFound;
    }

    RegCloseKey(hkey);
    return hr;
}


/*
 -  HrRRestoreSetCurrentLogNumber
 -
 *
 *  Purpose:
 *      This routine checks to verify
 *
 *  Parameters:
 *      hBinding - binding handle (ignored)
 *      wszAnnotation - Annotation for service to check.
 *      dwNewCurrentLog - New current log number
 *
 *  Returns:
 *      hrNone if it's ok to start the backup, an error otherwise.
 *
 */
HRESULT
HrRRestoreSetCurrentLogNumber(
    handle_t hBinding,
    WSZ wszBackupAnnotation,
    DWORD dwNewCurrentLog
    )
{
    HRESULT hr;

    if (hr = HrValidateInitialRestoreSecurity()) {
        return(hr);
    }

    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    return(HrSetCurrentLogNumber(wszBackupAnnotation, dwNewCurrentLog));
}

HrSetCurrentLogNumber(
    WSZ wszBackupAnnotation,
    DWORD dwNewCurrentLog
    )
/*++

Description:

    True worker routine of HrRRestoreSetCurrentLogNumber(), see it's
    description for details.  This was created so HrRBackupPrepare()
    didn't have to call this function through RPC/ntdsbcli.dll
    
--*/
{
    HRESULT hr;
    WCHAR   rgwcRegistryBuffer[ MAX_PATH ];
    HKEY hkey;
    
    //
    //  First check to see if we know what the last log was.
    //

    hr = StringCchPrintfW(rgwcRegistryBuffer, 
                          sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
                          L"%ls%ls",
                          BACKUP_INFO,
                          wszBackupAnnotation);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        return(hr);
    }

    if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, KEY_WRITE, &hkey))
    {
        //
        //  We want to ignore file_not_found - it is ok.
        //
        if (hr == ERROR_FILE_NOT_FOUND)
        {
            return(hrNone);
        }

        return(hr);
    }

    hr = RegSetValueExW(hkey, LAST_BACKUP_LOG, 0, REG_DWORD, (LPBYTE)&dwNewCurrentLog, sizeof(DWORD));

    RegCloseKey(hkey);

    return hr;
}


/*
 -  ErrRestoreRegister
 *
 *  Purpose:
 *  
 *      This routine to register a process for restore.  It is called by either the store or DS.
 *
 *  Parameters:
 *
 *
 *  Returns:
 *
 *      EC - Status of operation.  hrNone if successful, reasonable value if not.
 *
 */

DWORD
ErrRestoreRegister()
{
    DWORD err = 0;

    if (!fRestoreRegistered) {
        err = RegisterRpcInterface(JetRest_ServerIfHandle, g_wszRestoreAnnotation);
        if (!err) {
            fRestoreRegistered = fTrue;
        }
    }

    if (!fSnapshotRegistered) {
        err = DsSnapshotRegister();
        if (!err) {
            fSnapshotRegistered = fTrue;
        }
    }
    return(err);
}

/*
 -  ErrRestoreUnregister
 -  
 *  Purpose:
 *
 *  This routine will unregister a process for restore.  It is called by either the store or DS.
 *
 *  Parameters:
 *      szEndpointAnnotation - the endpoint we are going to unregister.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 */


DWORD
ErrRestoreUnregister()
{
    return(ERROR_SUCCESS);
}

BOOL
FInitializeRestore(
    VOID
    )
/*
 -  FInitializeRestore
 -  
 *
 *  Purpose:
 *      This routine initializes the global variables used for the JET restore DLL.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      BOOL - false if uninitialize fails
 */

{
    return(fTrue);
}

BOOL
FUninitializeRestore(
    VOID
    )
/*
 -  FUninitializeRestore
 -  
 *
 *  Purpose:
 *      This routine cleans up all the global variables used for the JET restore DLL.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      BOOL - false if uninitialize fails
 */

{
    BOOL ok1 = TRUE, ok2 = TRUE;

    // Initiate shutdown proceedings in parallel
    if (fSnapshotRegistered) {
        (void) DsSnapshotShutdownTrigger();
    }

    if (fRestoreRegistered) {
        ok1 = (ERROR_SUCCESS == UnregisterRpcInterface(JetRest_ServerIfHandle));

        if (ok1) {
            fRestoreRegistered = FALSE;
        }
    }

    if (fSnapshotRegistered) {
        ok2 = (ERROR_SUCCESS == DsSnapshotShutdownWait());

        if (ok2) {
            fSnapshotRegistered = FALSE;
        }
    }

    return ok1 && ok2;
}

/*
 -  RestoreRundown
 -  
 *
 *  Purpose:
 *      This routine will perform any and all rundown operations needed for the restore.
 *
 *  Parameters:
 *      pjsc - Jet backup/restore server context
 *
 *  Returns:
 *      None.
 */
VOID
RestoreRundown(
    PJETBACK_SERVER_CONTEXT pjsc
    )
{
    Assert(pjsc->fRestoreOperation);

    fRestoreInProgress = fFalse;

    return;
}

DWORD
AdjustBackupRestorePrivilege(
    BOOL fEnable,
    BOOL fRestoreOperation,
    PTOKEN_PRIVILEGES ptpPrevious,
    DWORD *pcbptpPrevious
    )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tpNew;
    DWORD err;
    //
    //  Open either the thread or process token for this process.
    //

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, fTrue, &hToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
            return(GetLastError());
        }
    }

    if (fEnable)
    {
        LUID luid;
        tpNew.PrivilegeCount = 1;
    
        if (!LookupPrivilegeValue(NULL, fRestoreOperation ? SE_RESTORE_NAME : SE_BACKUP_NAME, &luid)) {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    
        tpNew.Privileges[0].Luid = luid;
        tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    
        if (!AdjustTokenPrivileges(hToken, fFalse, &tpNew, sizeof(tpNew), ptpPrevious, pcbptpPrevious))
        {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    }
    else
    {
        if (!AdjustTokenPrivileges(hToken, fFalse, ptpPrevious, *pcbptpPrevious, NULL, NULL))
        {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    }

    CloseHandle(hToken);

    return(ERROR_SUCCESS);
}


/*
 -	FIsBackupPrivilegeEnabled
 -
 *	Purpose:
 *		Determines if the client process is in the backup operators group.
 *
 *              Note: we should be impersonating the client at this point
 *
 *	Parameters:
 *		None.
 *
 *	Returns:
 *		fTrue if client can legally back up the machine.
 *
 */
BOOL
FIsBackupPrivilegeEnabled(
    BOOL fRestoreOperation)
{
    HANDLE hToken;
    PRIVILEGE_SET psPrivileges;
    BOOL fGranted = fFalse;
    LUID luid;
#if 0
    BOOL fHeld = FALSE;
    CHAR buffer[1024];
    PTOKEN_PRIVILEGES ptpTokenPrivileges = (PTOKEN_PRIVILEGES) buffer;
    DWORD returnLength, i, oldAttributes = 0;
#endif

    //
    //	Open either the thread or process token for this process.
    //

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, fTrue, &hToken))
    {
        return(fFalse);
    }

    Assert(ANYSIZE_ARRAY >= 1);

    // Look up privilege value

    psPrivileges.PrivilegeCount = 1;	//	We only have 1 privilege to check.
    psPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;	// And it must be set.
    
    luid = RtlConvertLongToLuid((fRestoreOperation) ? 
                              SE_RESTORE_PRIVILEGE :
                              SE_BACKUP_PRIVILEGE);

    // Historical Note:
    // There was a bug in Win2k that because of the way RPC transport authentication
    // security tracking works, the held privilege may or may not already be enabled
    // so we had this code that's been #if 0'd out that basically enabled the privilege
    // if the user should have it. 
    //
    // This should no longer be needed, but we're going to leave it here, until we're
    // sure that we don't break something for the app-compat team, because some badly
    // behaving app might have become unknowingly dependant on the fact that we enable 
    // the privilege for them.
#if 0
    // Get current privileges
    
    if (!GetTokenInformation( hToken,
                              TokenPrivileges,
                              ptpTokenPrivileges,
                              sizeof( buffer ),
                              &returnLength )) {
        DebugTrace(("GetTokenInfo failed with error %d\n", GetLastError()));
        fGranted = fFalse;
        goto cleanup;
    }

    // See if held

    for( i = 0; i < ptpTokenPrivileges->PrivilegeCount; i++ ) {
        LUID_AND_ATTRIBUTES *laaPrivilege =
            &(ptpTokenPrivileges->Privileges[i]);
        if (memcmp( &luid, &(laaPrivilege->Luid), sizeof(LUID) ) == 0 ) {
            oldAttributes = laaPrivilege->Attributes;
            fHeld = TRUE;
            break;
        }
    }
    if (!fHeld) {
        DebugTrace(("Token does not hold privilege, fRest=%d\n",
                    fRestoreOperation ));
        fGranted = fFalse;
        goto cleanup;
    }

    DebugTrace(("FIsBackupPrivilegeEnabled, fRest=%d, attributes=0x%x\n", fRestoreOperation, oldAttributes ));

    // Enable if not already

    if ( (oldAttributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED)) == 0 ) {

        ptpTokenPrivileges->PrivilegeCount = 1;
        memcpy( &(ptpTokenPrivileges->Privileges[0].Luid), &luid, sizeof(LUID) );
        ptpTokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(
            hToken,
            fFalse,
            ptpTokenPrivileges,
            sizeof(TOKEN_PRIVILEGES),
            NULL,
            NULL))
        {
            DebugTrace(("AdjustTokenPriv(Enable) failed with error %d\n", GetLastError()));
            fGranted = fFalse;
            goto cleanup;
        }
    }
#endif

    psPrivileges.Privilege[0].Luid = luid;
    psPrivileges.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    //	Now check to see if the backup privilege is enabled.
    //

    if (!PrivilegeCheck(hToken, &psPrivileges, &fGranted)){
        //
        //	When in doubt, fail the API.
        //
        DebugTrace(("PrivilegeCheck() failed with error %d\n", GetLastError()));
        fGranted = fFalse;
    }
#if 0
    // Disable if necessary
    if ( (oldAttributes & (SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED)) == 0 ) {

        ptpTokenPrivileges->PrivilegeCount = 1;
        memcpy( &(ptpTokenPrivileges->Privileges[0].Luid), &luid, sizeof(LUID) );
        ptpTokenPrivileges->Privileges[0].Attributes = oldAttributes;

        if (!AdjustTokenPrivileges(
            hToken,
            fFalse,
            ptpTokenPrivileges,
            sizeof(TOKEN_PRIVILEGES),
            NULL,
            NULL))
        {
            DebugTrace(("AdjustTokenPriv(Disable) failed with error %d\n", GetLastError()));
            // Keep going
        }
    }

cleanup:
#endif
    
    CloseHandle(hToken);
    return(fGranted);

}


/*
 -	FBackupServerAccessCheck
 -
 *	Purpose:
 *		Performs the necessary access checks to validate the client
 *		security for backup.
 *
 *	Parameters:
 *		None.
 *
 *	Returns:
 *		fTrue if client can legally back up the machine.
 *
 */

E_REASON
BackupServerAccessCheck(
	BOOL fRestoreOperation)
{
    PSID psidCurrentUser = NULL;
    PSID psidRemoteUser = NULL;
    BOOL fSidCurrentUserValid = fFalse;
    HRESULT hr;

    DebugTrace(("BackupServerAccessCheck(%s)\n", fRestoreOperation ? "Restore" : "Backup"));

    GetCurrentSid(&psidCurrentUser);

#if DBG
	{
        WSZ wszSid = NULL;
        DWORD cbBuffer = 256*sizeof(WCHAR);

        wszSid = MIDL_user_allocate(cbBuffer);

        if (wszSid == NULL)
        {
            DebugTrace(("Unable to allocate memory for SID"));
        } else if (!GetTextualSid(psidCurrentUser, wszSid, &cbBuffer)) {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
				MIDL_user_free(wszSid);
				wszSid = MIDL_user_allocate(cbBuffer);

				if (wszSid != NULL)
				{
					if (!GetTextualSid(psidCurrentUser, wszSid, &cbBuffer)) {
                        DebugTrace(("Unable to print out current SID: %d\n", GetLastError()));
                        MIDL_user_free(wszSid);
                        wszSid = NULL;
					}
				}
            }
            else
            {
                DebugTrace(("Unable to determine SID: %d\n", GetLastError()));
            }
        }
		
        if (wszSid) {
            DebugTrace(("Current SID is %S.  %d bytes required\n", wszSid, cbBuffer));
            MIDL_user_free(wszSid);
        }
        else
        {
            DebugTrace(("Unable to determine current SID\n"));
        }
    }
#endif
    
    if (RpcImpersonateClient(NULL) != hrNone)
    {
        DebugTrace(("BackupServerAccessCheck: Failed to impersonate client - deny access."));
        if (psidCurrentUser)
        {
            LocalFree(psidCurrentUser);
        }
        return(eImpersonateFailed);
    }

    if (psidCurrentUser)
    {
        GetCurrentSid(&psidRemoteUser);
#if DBG
		{
			if (psidRemoteUser)
			{
				WSZ wszSid = NULL;
				DWORD cbBuffer = 256*sizeof(WCHAR);
		
				wszSid = MIDL_user_allocate(cbBuffer);

				if (wszSid == NULL)
				{
					DebugTrace(("Unable to allocate memory for SID"));
				} else if (!GetTextualSid(psidRemoteUser, wszSid, &cbBuffer)) {
					if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						MIDL_user_free(wszSid);

						wszSid = MIDL_user_allocate(cbBuffer);
						
						if (wszSid != NULL)
						{
							if (!GetTextualSid(psidRemoteUser, wszSid, &cbBuffer)) {
								DebugTrace(("Unable to print out remote SID: %d\n", GetLastError()));
								MIDL_user_free(wszSid);
								wszSid = NULL;
							}
						}
					}
					else
					{
						DebugTrace(("Unable to determine SID: %d\n", GetLastError()));
					}
				}
		
				if (wszSid) {
					DebugTrace(("Remote SID is %S.  %d bytes required\n", wszSid, cbBuffer));
					MIDL_user_free(wszSid);
				}
				else
				{
					DebugTrace(("Unable to determine remote SID\n"));
				}
			}
			else
			{
				DebugTrace(("Could not determine remote sid: %d\n", GetLastError()));
			}
		}
#endif

        // Note: psidCurrentUser isn't nessecary, but makes code clearer.
    	if (psidRemoteUser && psidCurrentUser && EqualSid(psidRemoteUser, psidCurrentUser))
    	{
            hr = RpcRevertToSelf();
            Assert(hr == RPC_S_OK);

            LocalFree(psidRemoteUser);
            LocalFree(psidCurrentUser);
            DebugTrace(("Remote user is running in service account, access granted\n"));
            return(eOk);
    	}
    }

    if (psidRemoteUser)
    {
        LocalFree(psidRemoteUser);
    }

    if (psidCurrentUser)
    {
       	LocalFree(psidCurrentUser);
    }

    //
    //	Now make sure that the user has the backup privilege enabled.
    //
    //	Please note that when the user does a network logon, all privileges
    //	that they might have will automatically be enabled.
    //

    if (!FIsBackupPrivilegeEnabled(fRestoreOperation))
    {

        hr = RpcRevertToSelf();
        Assert(hr == RPC_S_OK);
    	DebugTrace(("Remote user does not have the backup/restore privilege enabled.\n"));
        return( (fRestoreOperation) ? eNoRestorePrivilege : eNoBackupPrivilege );
    }


    DebugTrace(("Remote user is in backup or admin group, access granted.\n"));
    hr = RpcRevertToSelf();
    Assert(hr == RPC_S_OK);
    return(eOk);

}

HRESULT
HrValidateContextAndSecurity(
    BOOL                      fRestoreOp,
    BOOL                      fLooseRestoreCheck,
    BOOL                      fIniting,
    PJETBACK_SERVER_CONTEXT   pjsc
    )
/*++

Routine Description:

    This is a function that with the various parameters is used at the beginning 
    of each RPC function to check security and validate the server context if 
    necessary.
    
    Really, almost no one calls this function directly, I made some sensible 
    shortcut functions with better names, that set the flags correctly.
    
        from jetbp.h:
        HrValidateInitialBackupSecurity()            HrValidateContextAndSecurity(FALSE, FALSE, TRUE, NULL)
        HrValidateBackupContextAndSecurity(x)        HrValidateContextAndSecurity(FALSE, FALSE, FALSE, (x))
        HrValidateInitialRestoreSecurity()           HrValidateContextAndSecurity(TRUE, TRUE,   TRUE, NULL)
        HrValidateRestoreContextAndSecurity(x)       HrValidateContextAndSecurity(TRUE, FALSE,  FALSE, (x))
        HrValidateRestoreContextAndSecurityLoose(x)  HrValidateContextAndSecurity(TRUE, TRUE,   FALSE, (x))

Arguments:

    fRestoreOp - This is TRUE for any normal restore RPC call from the restore 
        interface (see jetbak.idl).
        
    fLooseRestoreCheck - There are several functions that are allowed to be called
        during backup while the DS is online.  So we have to make a loose check
        that can check both if either the restore or backup priviledge is granted.
        These includes these functions:
            HrRRestorePrepare()
            HrRRestoreGetDatabaseLocations()
            HrRRestoreEnd()
            HrRRestoreSetCurrentLogNumber()
            HrRRestoreCheckLogsForBackup()
            
    fIniting - This is for calls where you need to specify a NULL pjsc argument,
        because you've just got an RPC binding handle, not a full fledged jetback
        context handle.  Obviously the two HrR[Restore|Backup]Prepare functions
        need to set this to true but these do as well:
            HrRRestorePrepare()  -   the obvious one
            HrRBackupPrepare()   -   the other obvious one
            HrRBackupPing()
            HrRRestoreSetCurrentLogNumber()
            HrRRestoreCheckLogsForBackup()
            
    pjsc - A jetback server context handle.  Supposed to never be NULL, except when
        we're initing.

Return Values:

    hrNone or (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED), _never_ anything else as
    a more specific could be considered data disclosure.

--*/
{
    HRESULT hr = hrNone;
    E_REASON eReason = eUnknown;
    
    __try{

        if (!fIniting &&
            pjsc == NULL) {
            // ISSUE-2002/04/07-BrettSh - The RPC Guys swore that this should never ever
            // happen.  If this does happen, we need to fix a major hole in Win2k.
            Assert(!"This shouldn't happen.");
            eReason = eNullContextHandle;
            __leave;
        }

        Assert(pjsc == NULL || fRestoreOp == pjsc->fRestoreOperation);
        
        if (fRestoreOp &&
            !fLooseRestoreCheck &&
            g_fBootedOffNTDS) {
            eReason = eAttemptToRestoreOnline;
            __leave;
        }

        if (eReason = BackupServerAccessCheck(fRestoreOp)) {
            if (fRestoreOp && fLooseRestoreCheck) {
                // If we have a fake restore operation, someone might be calling this
                // from backup.  So retry as if we're backup.
                if (eReason = BackupServerAccessCheck(FALSE)) {
                    __leave;
                }
            } else {
                __leave;
            }
        }

        eReason = eOk;

    } __finally {

        // FUTURE-2002/04/08-BrettSh - Logging?
        // Optionally do damped logging here, by eReason. Important that it be significantly
        // damped, because otherwise a mallicious user could fill the event log.  Suggest
        // you track how many times each eReason happens, and when you decide to log, you
        // log how many times each eReason happened ... or log how many times a given
        // eReason happened.

        DebugTrace(("HrValidateContextAndSecurity: eReason = %d (eOK = 0, is success)", eReason));

    }

    // Did we find a reason to deny access?
    return( (eReason) ? HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) : hrNone );
}


RPC_STATUS RPC_ENTRY
DSBackupRestoreIfSecurityCallback(
    RPC_IF_HANDLE   InterfaceUuid,
    void *          pRpcCtx
    ){
    BOOL             fIsAllowed = FALSE;
    BOOL             fIsRemoteOp = FALSE;
    WCHAR *          szRpcBinding = NULL;
    WCHAR *          szProtSeq = NULL;
    ULONG            ulAuthnLevel = 0;

#ifdef DBG
    WCHAR *          szObjectUuid = NULL;
    WCHAR *          szNetworkAddr = NULL;
    WCHAR *          szEndPoint = NULL;
    WCHAR *          szNetworkOptions = NULL;
#endif

    KdPrint(("Entering DSBackupRestoreIfSecurityCallback()"));

    //
    // We're going to do several checks, to determine if this
    // client connection is OK.
    //

    //
    // 1) First we check the protecol sequence.
    //
    if (RpcBindingToStringBinding(pRpcCtx, &szRpcBinding) == RPC_S_OK) {
        
        if (RpcStringBindingParse(szRpcBinding,
#ifdef DBG
                                  &szObjectUuid, // ObjectUuid
                                  &szProtSeq, // ProtSeq
                                  &szNetworkAddr, // NetworkAddr
                                  &szEndPoint, // EndPoint
                                  &szNetworkOptions  // NetworkOptions
#else
                                  NULL, // ObjectUuid
                                  &szProtSeq, // ProtSeq
                                  NULL, // NetworkAddr
                                  NULL, // EndPoint
                                  NULL  // NetworkOptions
#endif
                                  ) == RPC_S_OK) {

            if (szProtSeq &&
                wcscmp(szProtSeq, LPC_PROTSEQW) == 0) {
                
                // This is LRPC, we like LRPC
                fIsAllowed = TRUE;

            } else if (szProtSeq &&
                       wcscmp(szProtSeq, TCP_PROTSEQW) == 0) {

                fIsRemoteOp = TRUE;
                // We're tempermental about TCP/IP, we like it only 
                // if the registry said so.
                fIsAllowed = g_fAllowRemoteOp;

            } // else fIsAllowed = FALSE; implicit

            KdPrint(("RPC Connection - Allowed: %d, RemoteConnAllowed:%d\r\n"
                     "\tObjectUuid:%ws\r\n"
                     "\tProtSeq:%ws\r\n"
                     "\tNetworkAddr:%ws\r\n"
                     "\tEndPoint:%ws\r\n"
                     "\tNetworkOptions:%ws", 
                     fIsAllowed, g_fAllowRemoteOp, 
                     szObjectUuid,
                     szProtSeq,
                     szNetworkAddr,
                     szEndPoint,
                     szNetworkOptions)
                    );

            if (szProtSeq) { RpcStringFree(&szProtSeq); }
#ifdef DBG
            if (szObjectUuid) { RpcStringFree(&szObjectUuid); }
            if (szNetworkAddr) { RpcStringFree(&szNetworkAddr); }
            if (szEndPoint) { RpcStringFree(&szEndPoint); }
            if (szNetworkOptions) { RpcStringFree(&szNetworkOptions); }
#endif
        }

        if (szRpcBinding) {
            RpcStringFree(&szRpcBinding);
        }
    }

    //
    // 2) We check the level of service is appropriate.
    //
    //    local requires PRIVACY || INTEGRITY
    //    remote requires PRIVACY
    if (fIsAllowed) {
        // Protocol Sequence checks out OK, lets try permissions
        fIsAllowed = FALSE;
        
        if (RpcBindingInqAuthClient(pRpcCtx,
                                    NULL, // Privs
                                    NULL, // ServerPrincName
                                    &ulAuthnLevel, // AuthnLevel
                                    NULL, // ulAuthnSvc
                                    NULL // AuthzSvc
                                    ) == RPC_S_OK) {
            if (fIsRemoteOp &&
                ulAuthnLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
                Assert(g_fAllowRemoteOp); // Should've been checked before.
                fIsAllowed = TRUE;
            } else if (!fIsRemoteOp &&
                       (ulAuthnLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY ||
                        ulAuthnLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY) ) {
                fIsAllowed = TRUE;
            }
        } 
    }

    //
    // 3) Finally, we check if the client is allowed
    //
    if (fIsAllowed) {
        // This will check for both the backup and the restore 
        // privilege, so we can do this access check here, even though
        // we don't know which kind of op we're about to do yet.
        // The security check however, must be done that the beginning 
        // of each RPC call as well, BTW.
        if(HrValidateContextAndSecurity(TRUE, TRUE, TRUE, NULL) != hrNone){
            fIsAllowed = FALSE;
        }
    }
    
#ifdef DBG
    if (!fIsAllowed) {
        DebugTrace(("*** Failed security callback."));
    } else {
        DebugTrace(("Passed security callback."));
    }
#endif
    return( (fIsAllowed) ? RPC_S_OK : ERROR_ACCESS_DENIED );
}

DWORD
RegisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf,
    IN  LPWSTR          pszAnnotation
    )
/*++

Routine Description:

    Registers the given (backup or restore) RPC interface.

Arguments:

    hRpcIf (IN) - Interface to register.
    
    pszAnnotation (IN) - Interface description.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err, i;
    RPC_BINDING_VECTOR *rgrbvVector = NULL;
    BOOL fEpsRegistered = FALSE;
    BOOL fIfRegistered = FALSE;
    BOOL fTcpRegistered = FALSE;
    BOOL fLRpcRegistered = FALSE;
    LPSTR pszStringBinding = NULL, pszProtseq = NULL;

    __try {
        DebugTrace(("RegisterRpcInterface: Register %S\n", pszAnnotation));
    
        err = RpcServerInqBindings(&rgrbvVector);
    
        if (err != RPC_S_NO_BINDINGS) {
            Assert( rgrbvVector );

            // Inspect the binding vector
            for (i=0; i<rgrbvVector->Count; i++) {
                err = RpcBindingToStringBindingA( rgrbvVector->BindingH[i], &pszStringBinding );
                if (!err && pszStringBinding) {
                    DebugTrace(("Binding[%d] = %s\n", i, pszStringBinding));
                    err = RpcStringBindingParseA( pszStringBinding,
                                                 NULL, &pszProtseq, NULL, NULL, NULL );
                    if (!err && pszProtseq) {
                        if (!_stricmp(pszProtseq, TCP_PROTSEQ)) {
                            fTcpRegistered = TRUE;
                        }
                        if (!_stricmp(pszProtseq, LPC_PROTSEQ)) {
                            fLRpcRegistered = TRUE;
                        }
                        RpcStringFreeA( &pszProtseq );
                        pszProtseq = NULL;
                    }
                    RpcStringFreeA( &pszStringBinding );
                    pszStringBinding = NULL;
                }
            }
        }
    
        // Register our selves for LRPC and optionally TCP/IP (g_fAllowRemoteOp).
        if (!fLRpcRegistered) {
            err = RpcServerUseProtseqA(LPC_PROTSEQ, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL);
            if (err) {
                __leave;
            }
            DebugTrace(("Binding[] = %s\n", LPC_PROTSEQ));
        }
        if (g_fAllowRemoteOp &&
            !fTcpRegistered) {
            err = RpcServerUseProtseqA(TCP_PROTSEQ, RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL);
            if (err) {
                __leave;
            }
            DebugTrace(("Binding[] = %s\n", TCP_PROTSEQ));
        }

        RpcBindingVectorFree(&rgrbvVector);
        rgrbvVector = NULL;

        // Get the final list to be registered
        err = RpcServerInqBindings(&rgrbvVector);
        if (err) {
            __leave;
        }

        err = RpcEpRegisterW(hRpcIf, rgrbvVector, NULL, pszAnnotation);
        if (err) {
            __leave;
        }

        fEpsRegistered = TRUE;
    
        //
        //  Now register the interface with RPC.
        //
        err = RpcServerRegisterIf2(hRpcIf, NULL, NULL,
                                   RPC_IF_ALLOW_SECURE_ONLY,
                                   RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                   -1, // We probably could specify this to something reasonable.
                                   DSBackupRestoreIfSecurityCallback
                                   );

        if (err) {
            __leave;
        }

        fIfRegistered = TRUE;
    
        //
        //  Now make this endpoint secure using WinNt security.
        //
    
        err = RpcServerRegisterAuthInfoA(NULL, RPC_C_AUTHN_GSS_NEGOTIATE , NULL, NULL);
        if (err) {
            __leave;
        }
    
        err = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, fTrue);
    
        //
        //  We want to ignore the "already listening" error.
        //
    
        if (RPC_S_ALREADY_LISTENING == err) {
            err = 0;
        }
    
    } __finally {
        if (err) {
            if (fEpsRegistered) {
                RpcEpUnregister(hRpcIf, rgrbvVector, NULL);
            }
            
            if (fIfRegistered) {
                RpcServerUnregisterIf(hRpcIf, NULL, TRUE);
            }
        }

        if (NULL != rgrbvVector) {
            RpcBindingVectorFree(&rgrbvVector);
        }
    }

    DebugTrace(("RegisterRpcInterface = %d\n", err));

    return err;
}

DWORD
UnregisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf
    )
/*++

Routine Description:

    Unregisters the given (backup or restore) RPC interface, which presumably
    was previously registered successfully via RegisterRpcInterface().

Arguments:

    hRpcIf (IN) - Interface to unregister.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err;
    RPC_BINDING_VECTOR *rgrbvVector;

    err = RpcServerInqBindings(&rgrbvVector);
    
    if (!err) {
        RpcEpUnregister(hRpcIf, rgrbvVector, NULL);
        
        RpcBindingVectorFree(&rgrbvVector);
        
        err = RpcServerUnregisterIf(hRpcIf, NULL, TRUE);
    }

    return err;
}



DWORD
ErrGetRegString(
    IN WCHAR *KeyName,
    OUT WCHAR **OutputString
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    KeyName - Supplies the name of the key to query.
    OutputString - Returns a pointer to the buffer containing the string
        retrieved.
    Optional - Supplies whether or not the given key MUST be in the registry
        (i.e. if this is false and it is not found, that that is an error).

Return Value:

     0 - Success
    !0 - Failure

--*/
{

    DWORD returnValue = 0;
    DWORD err;
    HKEY keyHandle = NULL;
    DWORD size;
    DWORD keyType;

    *OutputString = NULL;
    
    err = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_QUERY_VALUE,
                        &keyHandle);
    
    if (err != ERROR_SUCCESS)
    {
        returnValue = err;
        goto CleanUp;
    } 
    
    err = RegQueryValueEx(keyHandle,
                          KeyName,
                          NULL,
                          &keyType,
                          NULL,
                          &size);
    
    if ((err != ERROR_SUCCESS) || (keyType != REG_SZ))
    {
        // invent an error if the keytype is bad
        if ( err == ERROR_SUCCESS ) {
            err = ERROR_INVALID_PARAMETER;
        }
        returnValue = err;
        goto CleanUp;
    }

    *OutputString = MIDL_user_allocate(size);
    
    if ( *OutputString == NULL ) {
        returnValue = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto CleanUp;
    }
    
    err = RegQueryValueEx(keyHandle,
                          KeyName,
                          NULL,
                          &keyType,
                          (LPBYTE)(*OutputString),
                          &size);
    
    if ((err != ERROR_SUCCESS) || (keyType != REG_SZ))
    {
        returnValue = err;
        goto CleanUp;
    }

    
CleanUp:

    if (keyHandle != NULL)
    {
        err = RegCloseKey(keyHandle);
        
        if (err != ERROR_SUCCESS && returnValue == ERROR_SUCCESS)
        {
            returnValue = err;
        }
    }

    return returnValue;

} // ErrGetRegString


/*
 -  ErrRecoverAfterRestoreW
 -  
 *  Purpose:
 *
 *  This routine will recover a database after a restore if necessary.
 *
 *  Parameters:
 *      szParametersRoot - the root of the parameters section for the service in the registry.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 *
 *  The NTBACKUP program will place a key at the location:
 *      $(wszParametersRoot)\Restore in Progress
 *
 *  This key contains the following values:
 *      BackupLogPath - The full path for the logs after a backup
 *      CheckpointFilePath - The full path for the path that contains the checkpoint
 *     *HighLogNumber - The maximum log file number found.
 *     *LowLogNumber - The minimum log file number found.
 *      LogPath - The current path for the logs.
 *      JET_RstMap - Restore map for database - this is a REG_MULTISZ, where odd entries go into the szDatabase field,
 *          and the even entries go into the szNewDatabase field of a JET_RstMap
 *     *JET_RstMap Size - The number of entries in the restoremap.
 *
 *      * - These entries are REG_DWORD's.  All others are REG_SZ's (except where mentioned).
 */
DWORD
ErrRecoverAfterRestoreW(
    WCHAR * wszParametersRoot,
    WCHAR * wszAnnotation,
    BOOL fInSafeMode
    )
{
    DWORD err = 0;
    WCHAR   rgwcRegistryPath[ MAX_PATH ];
    WCHAR   rgwcCheckpointFilePath[ MAX_PATH ];
    DWORD   cbCheckpointFilePath = sizeof(rgwcCheckpointFilePath);
    WCHAR   rgwcBackupLogPath[ MAX_PATH ];
    DWORD   cbBackupLogPath = sizeof(rgwcBackupLogPath);
    WCHAR   rgwcLogPath[ MAX_PATH ];
    DWORD   cbLogPath = sizeof(rgwcLogPath);
    HKEY    hkey = NULL;
    WCHAR   *pwszRestoreMap = NULL;
    PEDB_RSTMAPW prgRstMap = NULL;
    DWORD    crgRstMap;
    I        irgRstMap;
    DWORD   genLow, genHigh;
    DWORD   cbGen = sizeof(DWORD);
    WSZ     wsz;
    DWORD   dwType;
    BOOL    fBackupEnabled = fFalse;
    CHAR    rgTokenPrivileges[1024];
    DWORD   cbTokenPrivileges = sizeof(rgTokenPrivileges);
    HRESULT hrRestoreError;
    WSZ     wszCheckpointFilePath = rgwcCheckpointFilePath;
    WSZ     wszBackupLogPath = rgwcBackupLogPath;
    WSZ     wszLogPath = rgwcLogPath;
    BOOLEAN fDatabaseRecovered = fFalse;
    BOOLEAN fRestoreInProgressKeyPresent;
    DWORD   cchEnvString;
    WCHAR   envString[100];
    WIN32_FIND_DATA findData;
    JET_DBINFOMISC jetDbInfoMisc;
    CHAR *  paszDatabasePath = NULL;
    HRESULT hr;

    if (wcslen(wszParametersRoot)+wcslen(RESTORE_IN_PROGRESS) > sizeof(rgwcRegistryPath)/sizeof(WCHAR))
    {
        err = ERROR_INVALID_PARAMETER;
        LogAndAlertEvent(
                DS_EVENT_CAT_BACKUP,
		        DS_EVENT_SEV_ALWAYS,
		        DIRLOG_PREPARE_RESTORE_FAILED,
	    	    szInsertWin32ErrCode( err ),
	    	    szInsertHex( err ),
    		    szInsertWin32Msg( err ) );
        return(err);
    }
    hr = StringCchCopy(rgwcRegistryPath, MAX_PATH, wszParametersRoot);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        LogAndAlertEvent(
                DS_EVENT_CAT_BACKUP,
		        DS_EVENT_SEV_ALWAYS,
		        DIRLOG_PREPARE_RESTORE_FAILED,
	    	    szInsertHResultCode( hr ),
	    	    szInsertHex( hr ),
    		    szInsertHResultMsg( hr ) );
        return(hr);
    }
    hr = StringCchCat(rgwcRegistryPath, MAX_PATH, RESTORE_IN_PROGRESS);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        LogAndAlertEvent(
                DS_EVENT_CAT_BACKUP,
		        DS_EVENT_SEV_ALWAYS,
		        DIRLOG_PREPARE_RESTORE_FAILED,
	    	    szInsertHResultCode( hr ),
	    	    szInsertHex( hr ),
    		    szInsertHResultMsg( hr ) );
        return(hr);
    }

    try {

        err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            rgwcRegistryPath,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkey);
        if ((err != ERROR_SUCCESS) && (err != ERROR_FILE_NOT_FOUND))
        {
            // This is only taken on bad registry.
            __leave;
        }

        fRestoreInProgressKeyPresent = (err == ERROR_SUCCESS);
        
        //
        //  if there's a restore in progress, then fail to perform any other restore operations.
        // Note that we check this before checking whether there is a restore in progress
        // key. The reason is that in the case of a snapshot-based restore, this key
        // is not used.
        //  

        dwType = REG_DWORD;
        cbBackupLogPath = sizeof(DWORD);
        if ((err = RegQueryValueExW(hkey, RESTORE_STATUS, 0, &dwType, (LPBYTE)&hrRestoreError, &cbBackupLogPath)) == ERROR_SUCCESS)
        {
            err = hrRestoreError;
            __leave;
        }

        // If there was no key present, then there is nothing left to do.
        if (!fRestoreInProgressKeyPresent)
        {
            //
            // Success
            //
            // The most normal exit path of this routine, this means that
            // no restore is in progress, and that this is a normal boot.
            //
            err = 0;
            __leave;
        }

        //
        //  We have now opened the restore-in-progress key.  This means that we have
        //  something to do now.  Find out what it is.
        //

        //
        //  First, let's get the backup log file path.
        //

        dwType = REG_SZ;
        cbBackupLogPath = sizeof(rgwcBackupLogPath);

        if (err = RegQueryValueExW(hkey, BACKUP_LOG_PATH, 0, &dwType, (LPBYTE)rgwcBackupLogPath, &cbBackupLogPath))
        {
            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszBackupLogPath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the checkpoint file path.
        //

        if (err = RegQueryValueExW(hkey, CHECKPOINT_FILE_PATH, 0, &dwType, (LPBYTE)rgwcCheckpointFilePath, &cbCheckpointFilePath))
        {

            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszCheckpointFilePath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the Log path.
        //

        if (err = RegQueryValueExW(hkey, LOG_PATH, 0, &dwType, (LPBYTE)rgwcLogPath, &cbLogPath))
        {
            if (err == ERROR_FILE_NOT_FOUND)
            {
                wszLogPath = NULL;
            }
            else
            {
                __leave;
            }
        }

        //
        //  Then, the low log number.
        //

        dwType = REG_DWORD;
        if (err = RegQueryValueExW(hkey, LOW_LOG_NUMBER, 0, &dwType, (LPBYTE)&genLow, &cbGen))
        {
            __leave;
        }

        //
        //  And, the high log number.
        //

        if (err = RegQueryValueExW(hkey, HIGH_LOG_NUMBER, 0, &dwType, (LPBYTE)&genHigh, &cbGen))
        {
            __leave;
        }

        //
        //  Now determine if we had previously recovered the database.
        //

        dwType = REG_BINARY;
        cbGen = sizeof(fDatabaseRecovered);

        if ((err = RegQueryValueExW(hkey, JET_DATABASE_RECOVERED, 0, &dwType, &fDatabaseRecovered, &cbGen)) != ERROR_SUCCESS &&
            (err !=  ERROR_FILE_NOT_FOUND))
        {
            //
            //  If there was an error other than "value doesn't exist", bail.
            //

            __leave;
        }

        //
        //  Now the tricky one.  We want to get the restore map.
        //
        //
        //  First we figure out how big it is.
        //

        dwType = REG_DWORD;
        cbGen = sizeof(crgRstMap);
        if (err = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&crgRstMap, &cbGen))
        {
            __leave;
        }

        prgRstMap = (PEDB_RSTMAPW)MIDL_user_allocate(sizeof(EDB_RSTMAPW)*crgRstMap);

        if (prgRstMap == NULL)
        {
            err = GetLastError();
            __leave;
        }

        //
        //  First find out how much memory is needed to hold the restore map.
        //

        dwType = REG_MULTI_SZ;
        if (err = RegQueryValueExW(hkey, JET_RSTMAP_NAME, 0, &dwType, NULL, &cbGen))
        {
            if (err != ERROR_MORE_DATA)
            {
                __leave;
            }
        }

        pwszRestoreMap = MIDL_user_allocate(cbGen);

        if (pwszRestoreMap == NULL)
        {
            err = GetLastError();
            __leave;
        }

        if (err = RegQueryValueExW(hkey, JET_RSTMAP_NAME, 0, &dwType, (LPBYTE)pwszRestoreMap, &cbGen))
        {
            __leave;
        }
        
        wsz = pwszRestoreMap;

        for (irgRstMap = 0; irgRstMap < (I)crgRstMap; irgRstMap += 1)
        {
            prgRstMap[irgRstMap].wszDatabaseName = wsz;
            wsz += wcslen(wsz)+1;
            prgRstMap[irgRstMap].wszNewDatabaseName = wsz;
            wsz += wcslen(wsz)+1;
        }

        if (*wsz != L'\0')
        {
            err = ERROR_INVALID_PARAMETER;
            __leave;
        }

        err = AdjustBackupRestorePrivilege(fTrue /* enable */, fTrue /* restore */, (PTOKEN_PRIVILEGES)rgTokenPrivileges, &cbTokenPrivileges);

        fBackupEnabled = fTrue;
        
        // Get the name of the DB ("ntds.dit") file to check if it's been recovered.
        Assert(crgRstMap == 1 && "The AD should only have one Jet DB file.");
        err = HrJetFileNameFromMungedFileName(prgRstMap[0].wszNewDatabaseName,
                                              &paszDatabasePath);
        if (err != hrNone) {
            __leave;
        }

        // Check to see if the DB has been recovered already
        err = JetGetDatabaseFileInfo(paszDatabasePath,
                                     &jetDbInfoMisc,
                                     sizeof(jetDbInfoMisc),
                                     JET_DbInfoMisc);

        if (err == JET_errSuccess && 
            jetDbInfoMisc.bkinfoFullCur.genLow == 0) {
            // This means that the JET database is clean and has been recovered (probably
            // by ntdsutil->Authritative Restore).
            fDatabaseRecovered = TRUE;
        }

        // 
        // Modified to call into local function instead of going through ntdsbcli.dll
        //

        err = HrRestoreLocal(
                        wszCheckpointFilePath,
                        wszLogPath,
                        prgRstMap,
                        crgRstMap,
                        wszBackupLogPath,
                        genLow,
                        genHigh,
                        &fDatabaseRecovered
                        );

        if (err != ERROR_SUCCESS)
        {
            //
            //  The recovery failed.
            //
            //  If we succeeded in recovering the JET database, we want to
            //  indicate that in the registry so we don't try again.
            //
            //  Ignore any errors from the SetValue, because the recovery error
            //  is more important.
            //

            RegSetValueExW(hkey, JET_DATABASE_RECOVERED, 0, REG_BINARY,
                                (LPBYTE)&fDatabaseRecovered, sizeof(fDatabaseRecovered));
            __leave;
        }

        //
        //  Ok, we're all done.  We can now delete the key, since we're done
        //  with it.
        //
        //  Note that we do not do this when run in safe mode -- see bug 426148.
        //

        if (!fInSafeMode) {
            err = RegDeleteKeyW(HKEY_LOCAL_MACHINE, rgwcRegistryPath);
        }

    } finally {
        if (fBackupEnabled)
        {
            AdjustBackupRestorePrivilege(fFalse /* disable */, fTrue /* Restore */, (PTOKEN_PRIVILEGES)rgTokenPrivileges, &cbTokenPrivileges);
            
        }

        if (pwszRestoreMap != NULL)
        {
            MIDL_user_free(pwszRestoreMap);
        }

        if (prgRstMap)
        {
            MIDL_user_free(prgRstMap);
        }

        if (hkey != NULL)
        {
            RegCloseKey(hkey);
        }

        if (paszDatabasePath != NULL)
        {
            MIDL_user_free(paszDatabasePath);
        }

        if ( ERROR_SUCCESS != err )
        {
            LogAndAlertEvent(
                    DS_EVENT_CAT_BACKUP,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_RECOVER_RESTORED_FAILED,
                    szInsertWin32ErrCode( err ),
                    szInsertHex( err ),
                    szInsertWin32Msg( err ) );
        }
    }

    return(err);
}

/*
 -  ErrRecoverAfterRestoreA
 -  
 *  Purpose:
 *
 *  This routine will recover a database after a restore if necessary.  This is the ANSI stub for this operation.
 *
 *  Parameters:
 *      szParametersRoot - the root of the parameters section for the service in the registry.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 */
DWORD
ErrRecoverAfterRestoreA(
    char * szParametersRoot,
    char * szRestoreAnnotation,
    BOOL fInSafeMode
    )
{
    DWORD err;
    WSZ wszParametersRoot = WszFromSz(szParametersRoot);
    WSZ wszRestoreAnnotation = NULL;

    if (wszParametersRoot == NULL)
    {
        err = GetLastError();
        LogAndAlertEvent(
                DS_EVENT_CAT_BACKUP,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_PREPARE_RESTORE_FAILED,
                szInsertWin32ErrCode( err ),
                szInsertHex( err ),
                szInsertWin32Msg( err ) );
        return err;
    }

    wszRestoreAnnotation = WszFromSz(szRestoreAnnotation);

    if (wszRestoreAnnotation == NULL)
    {
        err = GetLastError();
        LogAndAlertEvent(
                DS_EVENT_CAT_BACKUP,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_PREPARE_RESTORE_FAILED,
                szInsertWin32ErrCode( err ),
                szInsertHex( err ),
                szInsertWin32Msg( err ) );
        MIDL_user_free(wszParametersRoot);
        return err;
    }

    err = ErrRecoverAfterRestoreW(wszParametersRoot,
                                  wszRestoreAnnotation,
                                  fInSafeMode);

    MIDL_user_free(wszParametersRoot);
    MIDL_user_free(wszRestoreAnnotation);

    return(err);
}

/*
 -  EcDsarQueryStatus
 -
 *  Purpose:
 *
 *      This routine will return progress information about the restore process
 *
 *  Parameters:
 *      pcUnitDone - The number of "units" completed.
 *      pcUnitTotal - The total # of "units" completed.
 *
 *  Returns:
 *      ec
 *
 */
EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    )
{
        return HrLocalQueryDatabaseLocations(
            szDatabaseLocation,
            pcbDatabaseLocationSize,
            szRegistryBase,
            cbRegistryBase,
            pfCircularLogging
            );
}




/*
 -  EcDsarPerformRestore
 -
 *  Purpose:
 *
 *      This routine will do all the DSA related operations necessary to
 *      perform a restore operation.
 *
 *      It will:
 *
 *          1) Fix up the registry values for the database names to match the
 *              new database location (and names).
 *
 *          2) Patch the public and private MDB's.
 *
 *  Parameters:
 *      szLogPath - New database log path.
 *      szBackupLogPath - Original database log path.
 *      crstmap - Number of entries in rgrstmap.
 *      rgrstmap - Restore map that maps old database names to new names.
 *
 *  Returns:
 *      ec
 *
 */
EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    )
{
    EC ec;
    HKEY hkeyDs;

    ec = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);

    if (ec != hrNone)
    {
        return(ec);
    }

    ec = RegSetValueExA(hkeyDs, DSA_RESTORED_DB_KEY, 0, REG_DWORD, (BYTE *)&ec, sizeof(ec));

    RegCloseKey(hkeyDs);

    return(ec);
}



DWORD
ErrGetNewInvocationId(
    IN      DWORD   dwFlags,
    OUT     GUID *  NewId
    )
/*++

Routine Description:

    This function finds a given key in the DSA Configuration section of the
    registry.

Arguments:

    dwFlags - Zero or more of the following bits:
        NEW_INVOCID_CREATE_IF_NONE - If no GUID was stored, create one through
            UuidCreate
        NEW_INVOCID_DELETE - If the GUID key exists, delete it after
            reading
        NEW_INVOCID_SAVE - If a GUID was generated, save it to the regkey
        
    pusnAtBackup - high USN at time of backup.  If no backup-time USN has yet
        been registered and dwFlags & NEW_INVOCID_SAVE, this USN will be
        saved for future callers.  The consumer of this information is the
        logic in the DS that saves retired DSA signatures on the DSA object
        following a restore (and possibly one or more authoritative restores
        on top of that).  If a backup-time USN has been registered, that
        value is returned here.
    
    NewId - pointer to the buffer to receive the UUID

Return Value:

     0 - Success
    !0 - Failure

--*/
{
    DWORD err;
    HKEY  keyHandle = NULL;
    DWORD size;
    DWORD keyType;
    USN   usnSaved;

    //
    // preallocate uuid string. String is at most twice the sizeof UUID
    // (since we represent each byte with 2 chars) plus some dashes. Multiply
    // by 4 to cover everything else.
    //

    WCHAR szUuid[sizeof(UUID)*4];

    //
    // Check the registry and see if a uuid have already been 
    // allocated by prior authoritative restore.
    //

    err = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_ALL_ACCESS,
                        &keyHandle);
    
    if (err != ERROR_SUCCESS) {
        keyHandle = NULL;
        goto CleanUp;
    } 
    
    size = sizeof(szUuid);
    err = RegQueryValueEx(keyHandle,
                          RESTORE_NEW_DB_GUID,
                          NULL,
                          &keyType,
                          (PCHAR)szUuid,
                          &size);
    
    if (err != ERROR_SUCCESS) {

        //
        // Key not present. Create a new one
        //

        if (dwFlags & NEW_INVOCID_CREATE_IF_NONE) {
            err = CreateNewInvocationId(dwFlags & NEW_INVOCID_SAVE, NewId);
        }
    }
    else if (keyType != REG_SZ) {
        err = ERROR_INVALID_PARAMETER;
    }
    else {
        //
        // got it. Convert to uuid.
        //
    
        err = UuidFromStringW(szUuid,NewId);
        if (err != RPC_S_OK) {
            goto CleanUp;
        }
    
        //
        // delete?
        //
    
        if (dwFlags & NEW_INVOCID_DELETE) {
    
            DWORD dwErr = RegDeleteValue(keyHandle, RESTORE_NEW_DB_GUID);
    
            if ( dwErr != NO_ERROR ) {
                LogNtdsErrorEvent(DIRLOG_FAILED_TO_DELETE_NEW_DB_GUID_KEY, dwErr);
            }
        }
    }

CleanUp:

    if (keyHandle != NULL) {
        (VOID)RegCloseKey(keyHandle);
    }

    return err;

} // ErrGetNewInvocationId


JET_ERR
updateBackupUsn(
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_COLUMNID  backupusnid,
    IN  USN *         pusnAtBackup  OPTIONAL
    )
/*++

Routine Description:

    Writes the given backup USN to the hidden record.

Arguments:

    hiddensesid (IN) - Jet session to use to access the hidden table.
    
    hiddentblid (IN) - Open cursor for the hidden table.
    
    pusnAtBackup (OUT) - High USN at time of backup.  If NULL, the value
        will be removed from the hidden table.

Return Value:

    0 -- success
    non-0 -- JET error.

--*/
{
    JET_ERR err;
    BOOL    fInTransaction = FALSE;

    err = JetBeginTransaction(hiddensesid);
    if (err) {
        Assert(!"JetBeginTransaction failed!");
        return err;
    }

    __try {
        fInTransaction = TRUE;
        
        err = JetMove(hiddensesid, hiddentblid, JET_MoveFirst, 0);
        if (err) {
            Assert(!"JetMove failed!");
            __leave;
        }

        err = JetPrepareUpdate(hiddensesid, hiddentblid, JET_prepReplace);
        if (err) {
            Assert(!"JetPrepareUpdate failed!");
            __leave;
        }
    
        err = JetSetColumn(hiddensesid,
                           hiddentblid,
                           backupusnid,
                           pusnAtBackup,
                           pusnAtBackup ? sizeof(*pusnAtBackup) : 0,
                           0,
                           NULL);
        if (err) {
            Assert(!"JetSetColumn failed!");
            __leave;
        }

        err = JetUpdate(hiddensesid, hiddentblid, NULL, 0, 0);
        if (err) {
            Assert(!"JetUpdate failed!");
            __leave;
        }
    
        err = JetCommitTransaction(hiddensesid, 0);
        fInTransaction = FALSE;
        
        if (err) {
            Assert(!"JetCommitTransaction failed!");
            __leave;
        }
    }
    __finally {
        if (fInTransaction) {
            JetRollback(hiddensesid, 0);
        }
    }

    return err;
}

#define SZBACKUPUSN       "backupusn_col"       /* name of backup USN column */
#define SZBACKUPEXPIRATION   "backupexpiration_col"   /* name of backup expires column (used for tombstone) */
#define SZHIDDENTABLE     "hiddentable"         /* name of JET hidden table */


DWORD
ErrGetBackupUsn(
               IN  JET_DBID      dbid,
               IN  JET_SESID     hiddensesid,
               IN  JET_TABLEID   hiddentblid,
               OUT USN *         pusnAtBackup,
               OUT DSTIME *      pllExpiration
               )
/*++

Routine Description:

    Returns the usn at backup as written by the backup preparation functions.

Arguments:

    dbid (IN) - Jet database ID.
    
    hiddensesid (IN) - Jet session to use to access the hidden table.
    
    hiddentblid (IN) - Open cursor for the hidden table.
    
    pusnAtBackup (OUT) - Highest commited USN plus one at time of backup.  We assert
        that any change made lower then this USN under our invocation ID is
        present on this machine.
    
    This isn't guarenteed to be an exact value for the database.  There may
    be changes present on this machine with USN's higher than the returned value.
    There is a window between when this value was written and when the backup actually
    began reading the database to write the backup when these changes could
    have been commited.  This is an identical race condition to that of 
    DRA_GetNCChanges when it replicates changes to other machines:  it may 
    replicate off committed changes with USN higher than it reports to it's 
    replication partner.  This is acceptable to the replication algorithm, and 
    is acceptable to the backup/restore algorithm.

Return Value:

    0 -- success
    non-0 -- JET error.

--*/
{
    JET_ERR         err;
    DWORD           cb;
    USN             usnFound;
    JET_COLUMNBASE  colbase;
    JET_COLUMNID    backupusnid;
    JET_COLUMNID    jcidBackupExpiration;

    __try {
        // Find the backup USN column in the hidden table.
        err = JetGetColumnInfo(hiddensesid,
                               dbid,
                               SZHIDDENTABLE,
                               SZBACKUPUSN,
                               &colbase,
                               sizeof(colbase),
                               JET_ColInfoBase);
        if (err) {
            Assert(!"The usn-at-backup column doesn't exist!  Backups must be restored to the same OS which created them.");
            __leave;
        } 
        else {
            backupusnid = colbase.columnid;
        }

        err = JetMove(hiddensesid, hiddentblid, JET_MoveFirst, 0);
        if (err) {
            Assert(!"JetMove failed!");
            __leave;
        }

        err = JetRetrieveColumn(hiddensesid,
                                hiddentblid,
                                backupusnid,
                                &usnFound,
                                sizeof(usnFound),
                                &cb,
                                0,
                                NULL);
        if (0 == err) { 
            Assert(cb == sizeof(usnFound));
            Assert(0 != usnFound);
        } 
        else {
            Assert(!"JetRetrieveColumn failed!  The usn-at-backup column wasn't set!  Backups must be restored to the OS which created them.");
            __leave;
        }

        if (pllExpiration != NULL) {

            err = JetGetColumnInfo(hiddensesid,
                       dbid,
                       SZHIDDENTABLE,
                       SZBACKUPEXPIRATION,
                       &colbase,
                       sizeof(colbase),
                       JET_ColInfoBase);

            if (err) {
                Assert(!"The backup expiration column doesn't exist!  Backups must be restored to the same OS which created them.");
                __leave;
            } else {
                jcidBackupExpiration = colbase.columnid;
            }
            
            err = JetRetrieveColumn(hiddensesid,
                        hiddentblid,
                        jcidBackupExpiration,
                        pllExpiration,
                        sizeof(*pllExpiration),
                        &cb,
                        0,
                        NULL);
            if (0 == err) { 
                Assert(cb == sizeof(*pllExpiration));
                // FUTURE-2002/11/27-BrettSh We should set the backup expiration on legacy
                // backups, as well as snapshot, then we can enable this assert() and things
                // would be more consistent
                // Assert(0 != *pllExpiration); 
            } else if (JET_wrnColumnNull == err) {
                // We treat this as zero.
                *pllExpiration = 0;
                err = 0;
            } else {
                Assert(!"JetRetrieveColumn failed!  The ditstate column wasn't set!");
                __leave;
            }

        }
    }

    __finally {
        if (err) {
            Assert(!"Failed to retrieve/save backup USN!");
            usnFound = 0;
        }
    }

    *pusnAtBackup = usnFound;

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbcli\jetbcli.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1984 - 1999
//
//  File:       jetbcli.cxx
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1984 - 1999

Module Name:

    jetbcli.cxx

Abstract:

    This module is the client side header file for the MDB/DS backup APIs.


Author:

    Larry Osterman (larryo) 19-Aug-1994


Revision History:


--*/
#define UNICODE

#include <mxsutil.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsbcli.h>
#include <jetbak.h>
#include <jetbp.h>
#include <dsconfig.h>
#include <winldap.h>
#include <stdlib.h>
#include <fileno.h>
#include <msrpc.h>
#define FILENO    FILENO_JETBACK_JETBCLI_JETBCLI

#include <overflow.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

PSEC_WINNT_AUTH_IDENTITY_W g_pAuthIdentity = NULL;


/*************************************************************************************
Routine Description: 
    
      DsIsNTDSOnline
        Checks to see if the NTDS is Online on the given server. This call is 
        guaranteed to return quickly.

  Arguments:
    [in] szServerName - UNC name of the server to check
    [out] pfNTDSOnline - pointer to receive the bool result (TRUE if NTDS is
                            online; FALSE, otherwise)

Return Value:

    ERROR_SUCCESS if the call executed successfully;
    Failure code otherwise.
**************************************************************************************/
HRESULT 
NTDSBCLI_API
DsIsNTDSOnlineA(
    LPCSTR szServerName,
    BOOL *pfNTDSOnline
    )
{
    WSZ wszServerName;
    HRESULT hr;

    // Parameter checking is done in the xxxW version of the routine

    if (szServerName == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszServerName = WszFromSz(szServerName);
    if (!wszServerName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hr = DsIsNTDSOnlineW(wszServerName, pfNTDSOnline);

    MIDL_user_free(wszServerName);

    return hr;
}

HRESULT
NTDSBCLI_API
DsIsNTDSOnlineW(
    LPCWSTR szServerName,
    BOOL *pfNTDSOnline
    )
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOLEAN fRet;
    BOOL fAllowRemoteOp = FALSE;
    ULONG iszProtSeq = 0;

    if ( (szServerName == NULL) || (pfNTDSOnline == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    DebugTrace(("FIsNTDSOnlineW: \\%S (%S service)\n", szServerName, g_wszBackupAnnotation));

    __try {

        DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

        hr = HrJetbpConnectToBackupServer((WSZ) szServerName, g_wszRestoreAnnotation, JetRest_ClientIfHandle, &hBinding, &iszProtSeq);

        if (hr != hrNone)
        {
            DebugTrace(("FIsNTDSOnlineW: Error %d connecting to backup server\n", hr));
            return hr;
        }

        //
        //  We've found an endpoint that matches the one we're looking for, now
        //  lets contact the remote server.
        //

RetrySecurity:
        RpcTryExcept
        {
            hr = RpcBindingSetAuthInfo(hBinding, NULL, alRpc,
                                       RPC_C_AUTHN_WINNT, 
                                       (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity, RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {
                //
                //  If we couldn't set privacy (encryption), fall back to packet integrity.
                //

                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto RetrySecurity;
            }
            
            if (hr != hrNone)
            {
                    return hr;
            }

            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRIsNTDSOnline(hBinding, &fRet);

            // RPC returned - set the return value
            if (pfNTDSOnline)
            {
                *pfNTDSOnline = (BOOL) fRet;
            }

            return hr;
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
                hr = RpcExceptionCode();

                DebugTrace(("FIsNTDSOnlineW: Error %d raised when connecting to backup server\n", hr));

                //  If the client knows about encryption, but the server doesn't,
                //  fall back to unencrypted RPC's.
                //

                if (hr == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                        hr == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                        hr == RPC_S_UNKNOWN_AUTHN_TYPE ||
                        hr == RPC_S_INVALID_AUTH_IDENTITY)
                {
                        alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                        goto RetrySecurity;
                }

                //
                //  Return the error from the RPC if it fails.
                //

                return hr;
        }
        RpcEndExcept;

    } __finally {
        if (hr != hrNone)
        {
            DebugTrace(("FIsNTDSOnlineW: Error %d returned after connecting to backup server\n", hr));
        } 

        if (hBinding != NULL)
        {
            UnbindRpc(&hBinding);
        }

    }

    return hr;
}

/*
 -  DsBackupPrepare
 -
 *
 *  Purpose:
 *  DsBackupPrepare will connect to a remote JET database and "prepare" it for
 *      backup.
 *
 *  The remote database is described by the name of the server
 *      (pszBackupServer), and an "annotation" of the server - The only 2
 *      currently defined annotations are:
 *          "Exchange MDB Database"
 *  and "Exchange DS Database"
 *
 *      However there is nothing in this implementation that prevents other databases
 *  from being backed up with this mechanism.
 *
 *  This API requires that the caller have the "Backup Server" privilege held.
 *
 *  Parameters:
 *      LPSTR pszBackupServer - The name of the server that contains the database to
 *                                  back up (\\SERVER).
 *      LPSTR pszBackupAnnotation - The "annotation" of the database in question.
 *
 *      ppvExpiryToken - pointer that will receive the pointer to the
 *              Expiry Token associated with this backup; Client should save
 *              this token and send it back through HrRestorePrepare() when
 *              attempting a restore; allocated memory should be freed using
 *              DsBackupFree() API by the caller when it is no longer needed.
 *      pcbExpiryTokenSize - pointer to receive the size of the expiry token
 *              returned.
 *
 *      phbcBackupContext - Client side context for this API.
 *
 *  Returns:
 *      Hr - The status of the operation.
 *          HrNone if successful, some other reasonable error if not.
 *
 */
HRESULT
DsBackupPrepareA(
    IN  LPCSTR szBackupServer,
    unsigned long grbit,
    unsigned long btBackupType,
    OUT PVOID *ppvExpiryToken,
    OUT LPDWORD pcbExpiryTokenSize,
    OUT PVOID *phbcBackupContext
    )
{
    HRESULT hr;
    WSZ wszBackupServer;

    // Parameter checking is done in the xxxW version of the routine

    if (szBackupServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszBackupServer = WszFromSz(szBackupServer);

    if (wszBackupServer == NULL)
    {
        return(GetLastError());
    }

    hr = DsBackupPrepareW(wszBackupServer, grbit, btBackupType, 
            ppvExpiryToken, pcbExpiryTokenSize, phbcBackupContext);

    MIDL_user_free(wszBackupServer);
    return(hr);
}

HRESULT
DsBackupPrepareW(
    IN LPCWSTR wszBackupServer,
    unsigned long grbit,
    unsigned long btBackupType,
    OUT PVOID *ppvExpiryToken,
    OUT LPDWORD pcbExpiryTokenSize,
    OUT PVOID *phbcBackupContext
    )
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = NULL;
    RPC_BINDING_HANDLE hBinding;
    EXPIRY_TOKEN *pToken = NULL;
    ULONG iszProtSeq = 0;

    if ( (wszBackupServer == NULL) ||
         (phbcBackupContext == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }


    *phbcBackupContext = NULL;

    if (!ppvExpiryToken || !pcbExpiryTokenSize)
    {
        // These are required. We should fail the API, if the backup
        // doesn't want to take the expiry token info (restore would require this
        // and no point in backing up something that cannot be restored)
        //
        return hrInvalidParam;
    }
    else
    {
       *ppvExpiryToken = NULL;
       *pcbExpiryTokenSize = 0;
    }


    pbcContext = (pBackupContext)LocalAlloc(LMEM_ZEROINIT, sizeof(BackupContext));

    DebugTrace(("DsBackupPrepare: \\%S (%S service)\n", wszBackupServer, g_wszBackupAnnotation));

    __try {
        DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

        if (pbcContext == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        pToken = (EXPIRY_TOKEN *) MIDL_user_allocate(sizeof(EXPIRY_TOKEN));
        if (!pToken)
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            __leave;
        }

        pToken->dwVersion = 1;
        pToken->dsBackupTime = GetSecsSince1601();
        hr = HrGetTombstoneLifeTime( wszBackupServer,
                                     &(pToken->dwTombstoneLifeTimeInDays) );
        if (FAILED(hr)) {
            DebugTrace(("DsBackupPrepare: Error %d getting tombstone lifetime from backup server\n", hr));
            __leave;
        }

        pbcContext->sock = INVALID_SOCKET;

        hr = HrJetbpConnectToBackupServer((WSZ) wszBackupServer, g_wszBackupAnnotation, JetBack_ClientIfHandle, &hBinding, &iszProtSeq);

        if (hr != hrNone)
        {
            DebugTrace(("DsBackupPrepare: Error %d connecting to backup server\n", hr));
            __leave;
        }

        //
        //  We've found an endpoint that matches the one we're looking for, now
        //  lets contact the remote server.
        //

        pbcContext->hBinding = hBinding;

ResetSecurity:
        RpcTryExcept
        {
            hr = RpcBindingSetAuthInfo(hBinding,
                                       NULL,
                                       alRpc,
                                       RPC_C_AUTHN_WINNT, //RPC_C_AUTHN_GSS_NEGOTIATE, 
                                       (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity,
                                       RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY && IsLocalProtSeq(iszProtSeq))
            {

                //
                //  If we couldn't set privacy (encryption), fall back to packet integrity.
                //

                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto ResetSecurity;
            }

            if (hr != hrNone)
            {
                // Note this will leave the innermost enclosing try
                __leave;
            }

            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRBackupPrepare(hBinding, grbit, btBackupType, g_wszBackupAnnotation, GetCurrentProcessId(), &pbcContext->cxh);

            if (hr == hrNone)
            {
                pbcContext->fLoopbacked = FIsLoopbackedBinding((WSZ) wszBackupServer);
            }

            // Fall out of try block with hr set...
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            DWORD dwExceptionCode = RpcExceptionCode();

            DebugTrace(("DsBackupPrepare: Error %d raised when connecting to backup server\n", hr));

#if 0
            if (dwExceptionCode == ERROR_ACCESS_DENIED)
            {
                SendMagicBullet("AccessDenied");
            }
#endif   // #if 0
            //
            //  If the client knows about encryption, but the server doesn't,
            //  fall back to unencrypted RPC's.
            //

            if (dwExceptionCode == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                dwExceptionCode == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                dwExceptionCode == RPC_S_UNKNOWN_AUTHN_TYPE ||
                dwExceptionCode == RPC_S_INVALID_AUTH_IDENTITY)
            {
                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                goto ResetSecurity;
            }

            //
            //  Return the error from the RPC if it fails.
            //

            hr = HRESULT_FROM_WIN32( dwExceptionCode );
            // Fall out of except block with hr set...
        }
        RpcEndExcept;

    } __finally {
        if (hr != hrNone)
        {
            DebugTrace(("DsBackupPrepare: Error %d returned after connecting to backup server\n", hr));

            if (pbcContext != NULL)
            {
                if (pbcContext->hBinding != NULL)
                {
                    UnbindRpc(&pbcContext->hBinding);
                }
                LocalFree((void *)pbcContext);
            }

            if (pToken)
            {
                MIDL_user_free(pToken);
            }
        } else
        {
            // backup prepare successful - set correct values on the out parameters
            *phbcBackupContext = pbcContext;

            if (ppvExpiryToken)
            {
                *ppvExpiryToken = pToken;                
            }
            else
            {
                MIDL_user_free(pToken);
            }

            if (pcbExpiryTokenSize)
            {
                *pcbExpiryTokenSize = sizeof(EXPIRY_TOKEN);
            }            
        }

    }

    DebugTrace(("DsBackupPrepare: Returning error %d\n", hr));
    return(hr);
}

/*
 -  DsBackupGetDatabaseNames
 -
 *      DsBackupGetDatabaseNames will return the list of the attached
 *  databases on the remote machine.  The information returned in
 *  ppszAttachmentInformation should not be interpreted, as it only has meaning on
 *  the server being backed up.
 *  
 *      This API will allocate a buffer of sufficient size to hold the entire
 *  attachment list, which must be later freed with DsBackupFree.
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      ppszAttachmentInformation - A buffer containing null terminated
 *              strings.  It has the format <string>\0<string>\0
 *      pcbSize - The number of bytes in the buffer returned.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *          hrNone if successful, some other reasonable error if not.
 *
 */

HRESULT
DsBackupGetDatabaseNamesA(
    IN PVOID hbcBackupContext,
    OUT LPSTR *ppszAttachmentInformation,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszAttachmentInfo = NULL;
    CB cbwSize;
    WSZ wszAttachment;
    CB cbAttachment = 0;
    CB cbTmp = 0;
    SZ szAttachmentInfo;
    SZ szAttachment;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszAttachmentInformation == NULL) ||
         (pcbSize == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    hr = DsBackupGetDatabaseNamesW(hbcBackupContext, &wszAttachmentInfo,
                                            &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszAttachment = wszAttachmentInfo;

    while (*wszAttachment != TEXT('\0'))
    {
        BOOL fUsedDefault;

        cbTmp = WideCharToMultiByte(CP_ACP, 0, wszAttachment, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbTmp == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszAttachmentInfo);
            return(hr);
        }

        cbAttachment += cbTmp;

        wszAttachment += wcslen(wszAttachment)+1;
    }

    //
    //  Account for the final null in the buffer.
    //

    cbAttachment += 1;

    *pcbSize = cbAttachment;

    szAttachmentInfo = MIDL_user_allocate(cbAttachment);

    if (szAttachmentInfo == NULL)
    {
        DsBackupFree(wszAttachmentInfo);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szAttachment = szAttachmentInfo;

    wszAttachment = wszAttachmentInfo;

    while (*wszAttachment != TEXT('\0'))
    {
        CB cbThisAttachment;
        BOOL fUsedDefault;

        cbThisAttachment = WideCharToMultiByte(CP_ACP, 0, wszAttachment, -1,
                                          szAttachment,
                                          cbAttachment,
                                          "?", &fUsedDefault);
        if (cbThisAttachment == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszAttachmentInfo);
            DsBackupFree(szAttachmentInfo);
            return(hr);
        }

        wszAttachment += wcslen(wszAttachment)+1;
        //
        // PREFIX: PREFIX complains that szAttachment may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szAttachement is if cbAttachment
        // was zero as well.  This is impossible since cbAttachent will be 
        // atleast 1 at this point.
        //
        szAttachment += strlen(szAttachment)+1;
        cbAttachment -= cbThisAttachment;
    }

    //
    //  Double null terminate the string.
    //
    *szAttachment = '\0';

    *ppszAttachmentInformation = szAttachmentInfo;
    DsBackupFree(wszAttachmentInfo);

    return(hr);
}

HRESULT
DsBackupGetDatabaseNamesW(
    IN PVOID hbcBackupContext,
    OUT LPWSTR *ppwszAttachmentInformation,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    DebugTrace(("DsBackupGetDatabaseNames\n"));

    if ( (hbcBackupContext == NULL) ||
         (ppwszAttachmentInformation == NULL) ||
         (pcbSize == NULL)
        )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        hr = HrRBackupGetAttachmentInformation(pbcContext->cxh, pcbSize, (SZ *)ppwszAttachmentInformation);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    DebugTrace(("DsBackupGetDatabaseNames returned %d\n", hr));
    return(hr);
}


/*
 -  DsBackupOpenFile
 -
 *
 *  Purpose:
 *      DsBackupOpenFile will open a remote file for backup, and will perform
 *      whatever client and server side operations to prepare for the backup.
 *
 *      It takes in a hint of the size of the buffer that will later be passed into
 *      the DsBackupRead API that can be used to optimize the network traffic for the
 *      API.
 *      
 *      It will return (in pliFileSize) a LARGE_INTEGER that describes the size of
 *      the file.
 *
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      pszAttachmentName - The name of the file to be backed up.
 *      cbReadHintSize - A hint of the number of bytes that will be read in each
 *          DsBackupRead API.
 *      pliFileSize - The size of the file to be backed up.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *      hrNone if successful, some other reasonable error if not.
 */

HRESULT
DsBackupOpenFileA(
    IN PVOID hbcBackupContext,
    IN LPCSTR szAttachmentName,
    IN DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize
    )
{
    HRESULT hr;
    WSZ wszAttachmentName;
    CCH cchWstr;

    // Parameter checking is done in the xxxW version of the routine

    if (szAttachmentName == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    cchWstr = MultiByteToWideChar(CP_ACP, 0, szAttachmentName, -1, NULL, 0);

    if (cchWstr == 0)
    {
        return(GetLastError());
    }

    wszAttachmentName = MIDL_user_allocate(cchWstr*sizeof(WCHAR));

    if (wszAttachmentName == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    if (MultiByteToWideChar(CP_ACP, 0, szAttachmentName, -1, wszAttachmentName, cchWstr) == 0) {
        MIDL_user_free(wszAttachmentName);
        return(GetLastError());
    }

    hr = DsBackupOpenFileW(hbcBackupContext, wszAttachmentName, cbReadHintSize, pliFileSize);

    MIDL_user_free(wszAttachmentName);

    return(hr);
}

HRESULT
DsBackupOpenFileW(
    IN PVOID hbcBackupContext,
    IN LPCWSTR wszAttachmentName,
    IN DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize
    )
{
    HRESULT hr;
    hyper hyperFileSize = 0;
    SOCKADDR rgsockaddrAddresses[MAX_SOCKETS];
    BOOLEAN fUseSockets = fFalse;
    SYSTEM_INFO si;
    C csockaddr = 0;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if ( (hbcBackupContext == NULL) ||
         (wszAttachmentName == NULL) ||
         (pliFileSize == NULL)
        )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(("DsBackupOpenFile: %S\n", wszAttachmentName));

    pbcContext->cSockets = MAX_SOCKETS;
    hr = HrCreateBackupSockets(pbcContext->rgsockSocketHandles, pbcContext->rgprotvalProtocolsUsed,
                                &pbcContext->cSockets);

    if (hr == hrNone)
    {
        I iT;

        pbcContext->fUseSockets = fTrue;

        for (iT = 0 ; iT < pbcContext->cSockets ; iT += 1)
        {
            C cSockets;

            //
            //  Convert the socket we just got back into
            //  one or more sockaddr structures that we can use to pass
            //  to the remote machine.
            //

            hr = HrSockAddrsFromSocket(&rgsockaddrAddresses[csockaddr], &cSockets, pbcContext->rgsockSocketHandles[iT],
                                        pbcContext->rgprotvalProtocolsUsed[iT]);
            if (hr != hrNone)
            {
                //
                //  If we could open the sockets, but couldn't get their names,
                //  that's a fatal error.
                //
                return hr;
            }

            csockaddr += cSockets;
        }
    }

    //
    //  Take cbReadHintSize, and round it up to the nearest page size (on the client).
    //

    GetSystemInfo(&si);

    //
    //  Guarantee that dwPageSize is a power of 2
    //

    Assert ((si.dwPageSize != 0) && ((si.dwPageSize & (si.dwPageSize - 1)) == 0));

    //
    //  Round the read size up to the nearest page boundary.
    //

    cbReadHintSize = (cbReadHintSize + (si.dwPageSize-1) ) & ~(si.dwPageSize-1);

    if (pbcContext->fLoopbacked)
    {

        //
        //  We're loopbacked.  We want to create the shared memory section we're going to use for the
        //  data, the mutex that protects access to the shared memory meta-data, the read blocked event,
        //  and the write blocked event.
        //

        pbcContext->fUseSharedMemory = FCreateSharedMemorySection(&pbcContext->jsc, GetCurrentProcessId(), fTrue, cbReadHintSize * READAHEAD_MULTIPLIER);

    }

    RpcTryExcept
    {
        //
        //  Now tell the remote machine to open the file and to connect to the socket.
        //

        hr = HrRBackupOpenFile(pbcContext->cxh, (WSZ) wszAttachmentName,
                                            cbReadHintSize,
                                            &pbcContext->fUseSockets,
                                            csockaddr,
                                            rgsockaddrAddresses,
                                            &pbcContext->fUseSharedMemory,
                                            &hyperFileSize);

    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    }
    RpcEndExcept;

    pliFileSize->QuadPart = hyperFileSize;
    DebugTrace(("DsBackupOpenFile returns: %d\n", hr));

    return(hr);
}

DWORD
HrPerformBackupRead(
    PVOID context
    )
{
    //
    //  Just issue the read API.  We provide a buffer of 256 bytes because RPC will not allow
    //  us to specify a null pointer for the buffer.
    //
    CHAR rgbBuffer[256];
    DWORD cbRead = 256;
    HRESULT hr;

    pBackupContext pbcContext = (pBackupContext)context;

    if (context == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupRead(pbcContext->cxh, cbRead, rgbBuffer, &cbRead);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept
    //
    //  Tell the real read API what status we got back from the server.
    //

    pbcContext->hrApiStatus = hr;

    //
    //  And return, terminating the thread.
    //

    return(hr);
}

DWORD
HrPingServer(
    PVOID context
    )
{
    HRESULT hr;
    BOOL fContinue = fTrue;
    pBackupContext pbcContext = (pBackupContext)context;

    if (context == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    Assert(pbcContext->fUseSharedMemory);

    do {
        DWORD dwWaitReason = WAIT_OBJECT_0;

        RpcTryExcept
                hr = HrRBackupPing(pbcContext->hBinding);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
                hr = RpcExceptionCode();
        RpcEndExcept;

        //
        //  Sleep for BACKUP_WAIT_TIMEOUT/4 milliseconds (2.5 minutes or 30 seconds)
        //

        if (pbcContext->hReadThread)
            dwWaitReason = WaitForSingleObject(pbcContext->hReadThread, BACKUP_WAIT_TIMEOUT/4);

        if (dwWaitReason == WAIT_OBJECT_0 )
        {
            fContinue = fFalse;
        }
        else
        {
            Assert(dwWaitReason == WAIT_TIMEOUT);
        }
        
    } while (fContinue);

    return hr;
}


HRESULT
HrReadSharedData(
    IN PJETBACK_SHARED_HEADER pjsh,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
{
    DWORD   cbToCopy;
    DWORD   dwReadEnd;

    if ( (pjsh == NULL) ||
         (pvBuffer == NULL) ||
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    Assert (pjsh->cbReadDataAvailable <= (LONG)pjsh->cbSharedBuffer);

    //
    //  If the read is > write, this means that the write has wrapped past the end of the
    //  shared memory region.  If the read pointer is less than the write pointer, it means
    //  that the read pointer is on the same side as the write pointer, thus the write pointer
    //  is the end of the read.  If the read is equal to the write pointer, if there is data to
    //  be read, it means that we're going to read to the end of the buffer
    //
    if (pjsh->dwReadPointer > pjsh->dwWritePointer ||
        (DWORD) pjsh->cbReadDataAvailable == pjsh->cbSharedBuffer)
    {
        dwReadEnd = pjsh->cbSharedBuffer;
    }
    else
    {
        dwReadEnd = pjsh->dwWritePointer;
    }

    Assert(dwReadEnd > pjsh->dwReadPointer);

    cbToCopy = min(dwReadEnd-pjsh->dwReadPointer, cbBuffer);

    Assert(cbToCopy > 0);

    //
    //  The read pointer doesn't match the write pointer!  This means that
    //  there's something in the buffer for us to read.
    //  

    CopyMemory(pvBuffer,
                (void *)((CHAR *)pjsh+
                    pjsh->cbPage+pjsh->dwReadPointer),
                cbToCopy);

    *pcbRead = cbToCopy;

    pjsh->dwReadPointer += cbToCopy;

    pjsh->cbReadDataAvailable -= cbToCopy;

    //
    //  Make sure that the data count didn't go negative.
    //
    Assert (pjsh->cbReadDataAvailable >= 0);

    //
    //  And make sure that we have less data than in the buffer.
    //

    Assert (pjsh->cbReadDataAvailable < (LONG)pjsh->cbSharedBuffer);

    Assert (pjsh->cbReadDataAvailable <= ((LONG)pjsh->cbSharedBuffer-(LONG)cbToCopy));

    //
    //  If we've stepped to the end of the buffer, we want to wrap the pointer
    //  back to the beginning.
    //

    if (pjsh->dwReadPointer == pjsh->cbSharedBuffer)
    {
        pjsh->dwReadPointer = 0;
    }

#if DBG
    //
    //  The number of bytes available is always the same as the
    //  the number of bytes in the buffer - the # of bytes read, unless
    //  the read and write pointers are the same, in which case, it is either
    //  0 or the total # of bytes available.
    //
    //  If the read is blocked, then there must be 0 bytes available, otherwise there
    //  must be the entire buffer available.
    //

    if (pjsh->dwWritePointer == pjsh->dwReadPointer)
    {
        Assert (pjsh->cbReadDataAvailable == 0);
    }
    else
    {
        CB cbAvailable;
        if (pjsh->dwWritePointer > pjsh->dwReadPointer)
        {
            cbAvailable = pjsh->dwWritePointer - pjsh->dwReadPointer;
        }
        else
        {
            cbAvailable = pjsh->cbSharedBuffer - pjsh->dwReadPointer;
            cbAvailable += pjsh->dwWritePointer;
        }

        Assert (cbAvailable >= 0);
        Assert (pjsh->cbReadDataAvailable == cbAvailable);
    
    }
#endif

    return hrNone;
}

HRESULT
HrSocketRead(
    pBackupContext pbcContext,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
{
    HANDLE hWaitList[3];
    DWORD dwWaitReason;
    OVERLAPPED overlap = {0};
    HRESULT hr = hrNone;

    if ( (pbcContext == NULL) ||
         (pvBuffer == NULL) ||
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  First create an event that will be signalled when the read on the socket completes.
    //

    overlap.hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);

    if (overlap.hEvent == NULL)
    {
        return(GetLastError());
    }
    
    //
    //  If this is the first time through, we need to wait for the
    //  server to connect back to the client, and we need to create
    //  the client side API read thread.
    //
    //  This code is kinda wierd - it works by creating a thread
    //  on the client side that will issue a EcRBackupRead API to
    //  the server side.  This will create an RPC thread on the server
    //  side that will then proceed to shove data down the wire to the client
    //  until either the entire file has been transmitted to the client
    //  or until there was some form of error.
    //

    if (pbcContext->sock == INVALID_SOCKET)
    {
        DWORD cbReceiveBuffer;
        //
        //  First wait until the server connects to the client.
        //
        
        pbcContext->sock = SockWaitForConnections(pbcContext->rgsockSocketHandles, pbcContext->cSockets);
        
        if (pbcContext->sock == INVALID_SOCKET)
        {
            return(GetLastError());
        }
        
        
        //
        //  We need to make sure that the receive buffer is at least
        //  as long as the default (8K).
        //
        
        cbReceiveBuffer = max(8096, cbBuffer);
        
        if (setsockopt(pbcContext->sock, SOL_SOCKET, SO_RCVBUF,
                       (char *)&cbReceiveBuffer, sizeof(DWORD)) == SOCKET_ERROR)
        {   
            //
            //  We couldn't set the receive buffer to the appropriate
            //  size, do something reasonable.
            //
        }

        //
        //  Boolean socket operations just need a pointer to a non-
        //  zero buffer.
        //
        Assert(cbReceiveBuffer != 0);

        if (setsockopt(pbcContext->sock, SOL_SOCKET, SO_KEEPALIVE,
                       (char *)&cbReceiveBuffer, sizeof(DWORD)))
        {
            //
            //  We couldn't set the receive buffer to the appropriate
            //  size, do something reasonable.
            //
        }

        //
        //  Now create a thread for the read operation.
        //

        pbcContext->hReadThread = CreateThread(NULL, 0, HrPerformBackupRead, pbcContext, 0, &pbcContext->tidThreadId);

        //
        //  If we couldn't create the thread for the read, then we need to bail right now.
        //
            
        if (pbcContext->hReadThread == NULL)
        {
            return(GetLastError());
        }
        
    }
    
    //
    //  Now receive the users data from the socket.
    //
    
    if (!ReadFile((HANDLE)pbcContext->sock, pvBuffer, cbBuffer, pcbRead, &overlap))
    {
        //
        //  It's ok to get the error ERROR_IO_PENDING from this request.
        //
        
        if ((hr = GetLastError()) != ERROR_IO_PENDING)
        {
            closesocket(pbcContext->sock);
            
            pbcContext->sock = INVALID_SOCKET;
            
            //
            //  Now make sure that the read thread goes away.
            //
            
            CloseHandle(pbcContext->hReadThread);
            pbcContext->hReadThread = NULL;

            return(hr);
        }
    }

    hWaitList[0] = pbcContext->hReadThread;
    hWaitList[1] = overlap.hEvent;

    //
    //  Wait for either the read thread to terminate or for the read on the socket to
    //  complete.
    //
    
    dwWaitReason = WaitForMultipleObjects(2, hWaitList, FALSE, INFINITE);

    if (dwWaitReason == WAIT_OBJECT_0)
    {
        
        //
        //  The API (or at least the API thread) completed, lets wait for the read to complete now.
        //
        
        if (!GetOverlappedResult((HANDLE)pbcContext->sock, &overlap, pcbRead, TRUE))
        {
            //
            //  If the API succeeded, and the read failed, set the error
            //  to the error from the read.
            //
            if (pbcContext->hrApiStatus == hrNone)
            {
                pbcContext->hrApiStatus = GetLastError();
            }
        }
        
        //
        //  Shut down the receive event, we don't need it anymore.
        //
        
        CloseHandle(overlap.hEvent);
        
        return(pbcContext->hrApiStatus);
    }
    else
    {
        //
        //  The read completed before the API completed.  See if there was an error.
        //

        Assert (dwWaitReason == WAIT_OBJECT_0+1);

        if (!GetOverlappedResult((HANDLE)pbcContext->sock, &overlap, pcbRead, TRUE))
        {
            //
            //  Save away the error code.
            //

            hr = GetLastError();

            //
            //  The read failed.  This is not good, it indicates that there
            //  was some form of network error between the client and the server.
            //
            //  We want to close down the socket and wait until the read on the
            //  server completes.
            //

            closesocket(pbcContext->sock);
            
            pbcContext->sock = INVALID_SOCKET;

            //
            //  Shut down the event, we don't need it anymore.
            //

            CloseHandle(overlap.hEvent);

            //
            //  Now wait for the read thread to complete.  We know
            //  that the read thread will complete soon because
            //  we closed down the client side of the socket, and
            //  that will cause the write on the server side
            //  to complete, which will cause the server side to
            //  abort, which will cause the RPC to complete, which
            //  will cause the thread to complete....
            //

            WaitForSingleObject(pbcContext->hReadThread, INFINITE);

            //
            //  Then make the read thread go away.
            //

            CloseHandle(pbcContext->hReadThread);

            pbcContext->hReadThread = NULL;

            //
            //  And return the error.
            //

            return(hr);

        }
        else
        {
            //
            //  Shut down the event, we don't need it anymore.
            //

            CloseHandle(overlap.hEvent);

            //
            //  There was no error, return to the caller.
            //

            return(hrNone);
        }
    }
    return hr;
}

HRESULT
DsBackupRead(
    IN PVOID hbcBackupContext,
    IN PVOID pvBuffer,
    IN DWORD cbBuffer,
    OUT PDWORD pcbRead
    )
/*+++

    DsBackupRead will read one block from a backup file.

Inputs:
    hbcBackupContext - Client side context for this API.
    pvBuffer - Buffer to hold the data being backed up.
    cbBuffer - The size of the buffer.
    pcbRead - The number of bytes read.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        ERROR_END_OF_FILE if the end of file was reached while being
backed up
        Other Win32 and RPC error code.

Note:
    It is important to realize that pcbRead may be less than cbBuffer.  This
does not indicate an error, some transports may choose to fragment the buffer
being transmitted instead of returning the entire buffers worth of data.

Comments on the loopback case:
DsBackupRead synchronizes with HrSharedWrite using two events:
heventRead and heventWrite.
heventRead is the data available event from writer to reader
heventWrite is the data consumed event from reader to writer
This side is the reading side.
Writing side is at jetback\jetback.c:HrSharedWrite()

Here is the algorithm:
while ()
     read blocked = false
     if (data available)
        consume data
        if (write blocked) set data consumed event
     else
        read blocked = true
        wait on data available event
        if (error) set data consumed event, return

---*/
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;
    HANDLE hWaitList[3];
    DWORD dwWaitReason;

    if ( (hbcBackupContext == NULL) ||
         (pvBuffer == NULL) ||
         (cbBuffer == 0) || 
         (pcbRead == NULL)
        ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *pcbRead = 0;

    if (pbcContext->fUseSharedMemory)
    {
        //
        //  We're using shared memory to perform the read operation.  First of all, we want to kick off the thread
        //  that supports the read on the server side, if we need to.
        //

        if (pbcContext->hReadThread == NULL)
        {
            pbcContext->hReadThread = CreateThread(NULL, 0, HrPerformBackupRead, pbcContext, 0, &pbcContext->tidThreadId);

            //
            //  If we couldn't create the thread for the read, then we need to bail right now.
            //
            
            if (pbcContext->hReadThread == NULL)
            {
                return(GetLastError());
            }

            //
            //  Ok, our read thread is away.  It will eventually get to the server, so we can proceed as if it were
            //  already there.
            //
            pbcContext->hPingThread = CreateThread(NULL, 0, HrPingServer, pbcContext, 0, &pbcContext->tidThreadIdPing);
        }

        hWaitList[0] = pbcContext->hReadThread;

        do
        {

            //
            //  Ok.  Now we need to try to read data from the shared memory region.
            //
    
    
            //
            //  Acquire the lock that protects the shared memory region.
            //

            hWaitList[1] = pbcContext->jsc.hmutexSection;
            hWaitList[2] = pbcContext->hPingThread;
    
            dwWaitReason = WaitForMultipleObjects(3, hWaitList, FALSE, INFINITE);
    
            if (dwWaitReason == WAIT_OBJECT_0 || dwWaitReason == WAIT_OBJECT_0+2)
            {
                //
                //  The thread terminated.  This will happen when all the data on the server
                //  has been read, or there was an error on the read.
                //
                //  If there's been no error on the read, then we want to pull data until we've read
                //  all the data from the file.
                //

                pbcContext->jsc.pjshSection->hrApi = pbcContext->hrApiStatus;

                if (pbcContext->hrApiStatus == hrNone)
                {
                    //
                    //  There were no errors - read the data from the shared memory section.
                    //

                    if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
                    {
                        //
                        //  Read enough data from the shared memory section for this read.
                        //

                        pbcContext->hrApiStatus = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);
                    }
                    else
                    {
                        //
                        //  A read at EOF returns ERROR_HANDLE_EOF.
                        //

                        *pcbRead = 0;

                        pbcContext->hrApiStatus = ERROR_HANDLE_EOF;
                    }
                }

                //
                //  For whatever reason, the thread went away - we have to blow this read away.
                //

                return pbcContext->hrApiStatus;
            }
    
            Assert (dwWaitReason == WAIT_OBJECT_0+1 || dwWaitReason == WAIT_ABANDONED_0+1);
    
            //
            //  The read thread is no longer blocked (if it used to be).
            //

            pbcContext->jsc.pjshSection->fReadBlocked = fFalse;

            //
            //  Let's see if we can read anything from the buffer.
            //
    
            if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
            {
                //
                //  Yipeee!  There's data in the buffer.  Read it out.
                //

                hr = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);

                if (pbcContext->jsc.pjshSection->fWriteBlocked)
                {
                    //
                    //  Kick the write event - we can let ourselves loose now.
                    //

                    SetEvent(pbcContext->jsc.heventWrite);
                }

                ReleaseMutex(pbcContext->jsc.hmutexSection);


            } else {
                Assert (pbcContext->jsc.pjshSection->cbReadDataAvailable == 0);
                //
                //  Bummer!  There's no data in the buffer.  Wait until someone puts something in the buffer.
                //


                //
                //  We want to release the mutex and wait until the server puts
                //  something there for us.
                //

                pbcContext->jsc.pjshSection->fReadBlocked = fTrue;

                ReleaseMutex(pbcContext->jsc.hmutexSection);

                hWaitList[1] = pbcContext->jsc.heventRead;
                Assert(hWaitList[2] == pbcContext->hPingThread);

                //
                //  Wait until there's something for us to read.
                //

                dwWaitReason = WaitForMultipleObjects(3, hWaitList, FALSE, BACKUP_WAIT_TIMEOUT);
    
                if (dwWaitReason == WAIT_TIMEOUT)
                {
                    return hrCommunicationError;
                }
                else if (dwWaitReason == WAIT_OBJECT_0 || dwWaitReason == WAIT_OBJECT_0+2)
                {
                    //
                    //  The remote side completed.
                    //

                    pbcContext->jsc.pjshSection->hrApi = pbcContext->hrApiStatus;

                    if (pbcContext->hrApiStatus != hrNone)
                    {
                        return pbcContext->hrApiStatus;
                    }
                    //
                    //  Hmmm...  Since the remote side completed, that means that we're done reading the
                    //  data.  Now we want to copy the remaining data from the shared memory section.
                    //

                    if (pbcContext->jsc.pjshSection->cbReadDataAvailable > 0)
                    {
                        //
                        //  Read enough data from the shared memory section for this read.
                        //

                        pbcContext->hrApiStatus = HrReadSharedData(pbcContext->jsc.pjshSection, pvBuffer, cbBuffer, pcbRead);
                    }
                    else
                    {
                        Assert (pbcContext->jsc.pjshSection->cbReadDataAvailable == 0);
                        //
                        //  A read at EOF returns ERROR_HANDLE_EOF.
                        //

                        *pcbRead = 0;

                        pbcContext->hrApiStatus = ERROR_HANDLE_EOF;
                    }

                    return pbcContext->hrApiStatus;
                }
    
                Assert (dwWaitReason == WAIT_OBJECT_0+1 || dwWaitReason == WAIT_ABANDONED_0+1);
    
            }
    
        } while ( *pcbRead == 0 );

        if (hr != hrNone)
        {
            //
            //  Mark that the read had an error to allow the server to wake up and continue.
            //
            pbcContext->jsc.pjshSection->hrApi = hr;

            //
            //  Kick the server if it's blocked waiting on a read.
            //

            SetEvent(pbcContext->jsc.heventWrite);

        }

    } else if (pbcContext->fUseSockets)
    {
        hr = HrSocketRead(pbcContext, pvBuffer, cbBuffer, pcbRead);

    }
    else
    {
        RpcTryExcept
            //
            //  We're not using sockets, fall back to the
            //  core RPC protocols.
            //

            hr = HrRBackupRead(pbcContext->cxh, cbBuffer, pvBuffer, pcbRead);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            hr = RpcExceptionCode();
        RpcEndExcept

    }

    return(hr);
}

HRESULT
DsBackupClose(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupCloseFile will close the current file being backed up.

Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HR - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    if (pbcContext->sock != INVALID_SOCKET)
    {
        //
        //  Shut down the current socket.
        //

        closesocket(pbcContext->sock);

        //
        //  Mark the socket as being invalid for a later open.
        //

        pbcContext->sock = INVALID_SOCKET;
    }

    //
    //  If we've created a read thread, shut it down.
    //


    if (pbcContext->hReadThread != NULL)
    {
        //
        //  Now wait for the read thread to complete.
        //

        if (pbcContext->fUseSharedMemory) {
            pbcContext->jsc.pjshSection->hrApi = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            SetEvent(pbcContext->jsc.heventWrite);
        }

        WaitForSingleObject(pbcContext->hReadThread, INFINITE);

    }

    //
    //  If we've created a ping thread, shut it down.
    //

    if (pbcContext->hPingThread != NULL)
    {
        //
        //  Now wait for the read thread to complete.
        //

        WaitForSingleObject(pbcContext->hPingThread, INFINITE);

    }

    // Both the read thread and ping thread are done - close handles

    if (pbcContext->hReadThread != NULL)
    {

        CloseHandle(pbcContext->hReadThread);

        pbcContext->hReadThread = NULL;
    }

    if (pbcContext->hPingThread != NULL)
    {

        CloseHandle(pbcContext->hPingThread);

        pbcContext->hPingThread = NULL;
    }

    CloseSharedControl(&pbcContext->jsc);

    RpcTryExcept

        hr = HrRBackupClose(pbcContext->cxh);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept

    return(hr);
}

/*
 -  DsBackupGetBackupLogs
 -
 *
 *  Purpose:
 *      DsBackupGetBackupLogs will retrieve the list of additional files that need
 *  to be backed up.
 *
 *
 *      This API will allocate a buffer of sufficient size to hold the entire
 *  backup log list, which must be later freed with DsBackupFree.
 *
 *
 *  Parameters:
 *      hbcBackupContext - Client side context for this API.
 *      ppszBackupLogFile - A buffer containing null terminated
 *          strings.  It has the format <string>\0<string>\0
 *      pcbSize - The number of bytes in the buffer returned.
 *
 *  Returns:
 *      HRESULT - The status of the operation.
 *          hrNone if successful.
 *          Other Win32 and RPC error code.
 *
 */

HRESULT
DsBackupGetBackupLogsA(
    IN PVOID hbcBackupContext,
    OUT LPSTR *ppszLogInformation,
    OUT PDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszLogInfo = NULL;
    CB cbwSize;
    WSZ wszLog;
    CB cbLog = 0;
    CB cbTmp = 0;
    SZ szLogInfo;
    SZ szLog;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszLogInformation == NULL) ||
         (pcbSize == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }
    hr = DsBackupGetBackupLogsW(hbcBackupContext, &wszLogInfo, &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszLog = wszLogInfo;

    while (*wszLog != TEXT('\0'))
    {
        BOOL fUsedDefault;
        cbTmp = WideCharToMultiByte(CP_ACP, 0, wszLog, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbTmp == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszLogInfo);
            return(hr);
        }

        cbLog += cbTmp;

        wszLog += wcslen(wszLog)+1;
    }

    //
    //  Account for the null at the end of the buffer.
    //

    cbLog += 1;

    *pcbSize = cbLog;

    szLogInfo = MIDL_user_allocate(cbLog);

    if (szLogInfo == NULL)
    {
        DsBackupFree(wszLogInfo);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szLog = szLogInfo;

    wszLog = wszLogInfo;

    while (*wszLog != TEXT('\0'))
    {
        CB cbThisLog;
        BOOL fUsedDefault;

        cbThisLog = WideCharToMultiByte(CP_ACP, 0, wszLog, -1,
                                          szLog,
                                          cbLog,
                                          "?", &fUsedDefault);
        if (cbThisLog == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszLogInfo);
            DsBackupFree(szLogInfo);
            return(hr);
        }

        wszLog += wcslen(wszLog)+1;
        //
        // PREFIX: PREFIX complains that szLog may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szAttachement is if cbLog
        // was zero as well.  This is impossible since cbLog will be 
        // atleast 1 at this point.
        //
        szLog += strlen(szLog)+1;
        cbLog -= cbThisLog;
    }

    //
    //  Double null terminate the string.
    //
    *szLog = '\0';

    *ppszLogInformation = szLogInfo;
    DsBackupFree(wszLogInfo);
    return(hr);
}

HRESULT
DsBackupGetBackupLogsW(
    IN PVOID hbcBackupContext,
    OUT LPWSTR *ppwszBackupLogFile,
    OUT PDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if ( (hbcBackupContext == NULL) ||
         (ppwszBackupLogFile == NULL) ||
         (pcbSize == NULL) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupGetBackupLogs(pbcContext->cxh,
                                    pcbSize,
                                    (SZ *)ppwszBackupLogFile);

    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept;
    return(hr);
}

HRESULT
DsBackupTruncateLogs(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupTruncateLogs will terminate the backup operation.  It is to be
    called when the backup has completed successfully.

Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

NOTE:
    Again, this API may have to take a grbit parameter to be passed to the
server to indicate the backup type.

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
        hr = HrRBackupTruncateLogs(pbcContext->cxh);
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        hr = RpcExceptionCode();
    RpcEndExcept;

    return(hr);
}

HRESULT
DsBackupEnd(
    IN PVOID hbcBackupContext
    )
/*+++

    DsBackupEnd will clean up after a backup operation has been performed.  This
API will close outstanding binding handles, and do whatever is necessary to
clean up after a successful (or unsuccesful) backup attempt.


Inputs:
    hbcBackupContext - Client side context for this API.

Returns:
    HRESULT - The status of the operation.
        hrNone if successful.
        Other Win32 and RPC error code.

NOTE:

---*/
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pbcContext->hBinding != NULL)
    {
        I irgsock;

        //
        //  Close the file (and shut down the thread) if it is still open.
        //

        DsBackupClose(hbcBackupContext);

        RpcTryExcept
            hr = HrRBackupEnd(&pbcContext->cxh);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            hr = RpcExceptionCode();
        RpcEndExcept;

        RpcBindingFree(&pbcContext->hBinding);

        //
        //  Now close down the listening socket handles, we're
        //  done.
        //
        for (irgsock = 0; irgsock < pbcContext->cSockets; irgsock += 1)
        {
            closesocket(pbcContext->rgsockSocketHandles[irgsock]);
        }

    }

    MIDL_user_free(pbcContext);

    return(hrNone);
}
VOID
DsBackupFree(
    IN PVOID pvBuffer
    )
/*+++

    DsBackupFree will free memory allocated during one of the backup APIs.

Inputs:
    pvBuffer - Buffer to free

Returns:
    None.

NOTE:
    This is simply a wrapper for MIDL_user_free().

---*/

{
    MIDL_user_free(pvBuffer);
}


void *
MIDL_user_allocate(
    size_t cbBytes
    )
{
    return(LocalAlloc(0, cbBytes));
}

void
MIDL_user_free(
    void *pvBuffer
    )
{
    LocalFree(pvBuffer);
}


// supported protocol sequences
WSZ rgszProtSeq[] =
{	
    // NOTE: IF YOU CHANGE THIS GO CHANGE IsLocalProtSeq() and IsRemoteProtSeq()
    LPC_PROTSEQW, // LRPC
    TCP_PROTSEQW, // TCP/IP
};


long
cszProtSeq = sizeof(rgszProtSeq) / sizeof(rgszProtSeq[0]);



/*
 -	HrCreateRpcBinding
 *
 *	Purpose:
 *		Tries to bind to a particular RPC protocol sequence
 *
 *	Parameters:
 *		iszProtoseq		index into array of protocol sequences
 *		szServer		server name as a string
 *		phBinding		used to return RPC binding on success
 *
 *	Returns:
 *		binding handle filled in.  Returns no error, but null handle if xport
 *		is not valid on this machine.
 */
HRESULT
HrCreateRpcBinding( I iszProtoseq, WSZ szServer, handle_t * phBinding )
{
	RPC_STATUS			rpc_status;
	WCHAR				rgchServer[256];
	WSZ					wszStringBinding = NULL;
	HRESULT				hr = hrNone;

	Assert(iszProtoseq>=0 && iszProtoseq < cszProtSeq);

	wszStringBinding = NULL;
	*phBinding = 0;
	if ( (szServer == NULL) || (phBinding == NULL) ) 
		return hrInvalidParam;

	// Allow caller to specify the leading "\\" or not.
	if (szServer[0] == TEXT('\\') && szServer[1] == TEXT('\\'))
		szServer += 2;

    // Note that LPC may or may not be used even when the server name identifies
    // the local system. LPC only accepts NULL or the NETBIOS name of the computer.
    // If a dns name or dns alias name of the local system is used, LPC will not
    // work.  This corresponds with the check in FIsLoopbacked().
    hr = StringCchCopy(rgchServer, sizeof(rgchServer)/sizeof(rgchServer[0]), szServer);
    if (hr) {
        Assert(!"Should this be allowed?");
        return(hr);
    }

	if (RpcNetworkIsProtseqValidW(rgszProtSeq[iszProtoseq]) == NO_ERROR)
	{
		/* Set up the RPC binding */
		rpc_status = RpcStringBindingComposeW( NULL,
				   			  rgszProtSeq[iszProtoseq],
				   			  rgchServer,
				   			  NULL,
				   			  NULL,
				   			  &wszStringBinding );
		if (rpc_status)
			return rpc_status;
		
		rpc_status = RpcBindingFromStringBindingW(wszStringBinding, phBinding);
		(void) RpcStringFreeW(&wszStringBinding);
		if (rpc_status)
			return rpc_status;

		Assert(*phBinding);
	}

	return hrNone;
}

/*
 -	UnbindRpc
 -
 *	Purpose:
 *		Tear down RPC binding
 *
 *	Parameters:
 *		phBinding
 *
 *	Returns:
 */
void
UnbindRpc( handle_t *phBinding )
{
	(void) RpcBindingFree(phBinding);
}

BOOLEAN
FIsLoopbackedBinding(
    WSZ wszServerName
	)
{
	BOOLEAN fLoopbacked = FALSE;
    WCHAR wszLocalServer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD csz = MAX_COMPUTERNAME_LENGTH + 1;
    WSZ wszRemoteServer = wszServerName;

    if (!GetComputerNameW(wszLocalServer, &csz))
    {
        return fFalse;
    }

    if (L'\\' == *wszRemoteServer)
    {
        Assert(L'\\' == *(wszRemoteServer + 1));

        // skip the "\\" prefix to go to the start of the server name
        wszRemoteServer += 2;
    }

    fLoopbacked = (0 == _wcsicmp(wszRemoteServer, wszLocalServer));

	if (fLoopbacked)
	{
		HRESULT hr;
		HKEY hkey;
		DWORD fLoopbackDisabled;
		DWORD dwType;
		DWORD cbLoopbackDisabled;

		//
		//	Let's check the registry just in case someone has disabled us.
		//
		if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, BACKUP_INFO, 0, KEY_READ, &hkey))
		{
			//
			//	We couldn't open the key, so return what we deduced.
			//
			return fLoopbacked;
		}

		dwType = REG_DWORD;
		cbLoopbackDisabled = sizeof(fLoopbackDisabled);
		hr = RegQueryValueExW(hkey, DISABLE_LOOPBACK, 0, &dwType, (LPBYTE)&fLoopbackDisabled, &cbLoopbackDisabled);
	
		if (hr != hrNone)
		{
			RegCloseKey(hkey);
			return fLoopbacked;
		}
	
		//
		//	If the registry told us to disable loopbacked access, then respect it.
		//
		if (fLoopbackDisabled)
		{
			fLoopbacked = fFalse;
		}

		RegCloseKey(hkey);
	}

	return fLoopbacked;
}

HRESULT
HrJetbpConnectToBackupServer(
    WSZ wszBackupServer,
    WSZ wszBackupAnnotation,
    RPC_IF_HANDLE rifHandle,
    handle_t *prbhBinding,
    ULONG * piszProtSeq
    )
/*+++

    HrJetbpConnectToBackupServer will create an RPC binding handle that talks to the specified remote backup server
    with the specified annotation.

Inputs:
    wszBackupServer - The name of the server to contact.  It can be of the form \\server or server.
    szBackupAnnotation -The "annotation" that allows us to choose the backup server in question.
    rifHandle - The RPC binding handle we wish to connect to.
    prbhBinding - Holds the returned binding handle.

Returns:
    Status of operation.  hrNone if successful, some reasonable error if not.

---*/
{
    RPC_EP_INQ_HANDLE inqcontext = NULL;
    RPC_BINDING_HANDLE rbhHandle = NULL;
    I iszProtSeq;
    RPC_BINDING_HANDLE hBinding = NULL;
    HRESULT hr;
    WSZ szStringBinding = NULL;
    WSZ szProtocolSequence = NULL;
    WSZ wszAnnotation = NULL;

    if ( (wszBackupServer == NULL) ||
         (wszBackupAnnotation == NULL) ||
         (rifHandle == NULL) ||
         (prbhBinding == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    *prbhBinding = NULL;

    DebugTrace(("ConnectToBackup, server = %ws, annot = %ws\n",
                wszBackupServer, wszBackupAnnotation));
    __try {
        for (iszProtSeq = 0; iszProtSeq < cszProtSeq; iszProtSeq++) {
            RPC_IF_ID ifid;
    
            if (NULL != hBinding) {
                UnbindRpc(&hBinding);
            }

            hr = HrCreateRpcBinding(iszProtSeq, wszBackupServer, &hBinding);
            if (hr != hrNone) {
                DebugTrace(("HrCreateRpcBinding, %ws binding to %ws failed 0x%x\n",
                            rgszProtSeq[iszProtSeq], wszBackupServer, hr));
                continue;
            }
    
            //
            //  If the binding handle isn't active locally, don't bother.
            //

            if (hBinding == NULL) {
                DebugTrace(("ConnectToBackup, binding %ws is not active\n",
                            rgszProtSeq[iszProtSeq]));
                continue;
            }

            DebugTrace(("ConnectToBackup, binding %ws is active\n",
                        rgszProtSeq[iszProtSeq]));

            RpcTryExcept {
                hr = RpcIfInqId(rifHandle, &ifid);
                if (hr != hrNone) {
                    DebugTrace(("ConnectToBackup, failed to inquire interface handle 0x%x\n",
                                hr));
                    continue;
                }
    
                if (inqcontext != NULL) {
                    RpcMgmtEpEltInqDone(&inqcontext);
                    inqcontext = NULL;
                }

                hr = RpcMgmtEpEltInqBegin(hBinding,
                                          RPC_C_EP_MATCH_BY_IF,
                                          &ifid,
                                          RPC_C_VERS_EXACT,
                                          NULL,
                                          &inqcontext);
                //
                //  Try the next interface if this fails.
                //
                if (hr != hrNone) {
                    DebugTrace(("RpcMgmtEpEltInqBegin failed 0x%x\n",
                                hr));
                    continue;
                }
    
                do {
                    if (NULL != wszAnnotation) {
                        RpcStringFreeW(&wszAnnotation);
                        wszAnnotation = NULL;
                    }

                    if (NULL != rbhHandle) {
                        RpcBindingFree(&rbhHandle);
                        rbhHandle = NULL;
                    }

                    hr = RpcMgmtEpEltInqNextW(inqcontext,
                                              &ifid,
                                              &rbhHandle, // Binding
                                              NULL,   // UUID
                                              &wszAnnotation
                                              );
        
                    //
                    //  We don't get any errors from RpcMgmtEpEltInqBegin,
                    //  so take the error from InqNext and continue....
                    //
                    //  Please note that if a transport is present on the server but
                    //  not present on the client, we will get RPC_S_PROTSEQ_NOT_SUPPORTED
                    //  from RpcMgmtEpEltInqNext(), so we want to skip to the next endpoint.
                    //

                    if (hr != hrNone) {
                        DebugTrace(("RpcMgmtEpEltInqNextW failed 0x%x\n",
                                    hr));
                        if (hr == RPC_S_PROTSEQ_NOT_SUPPORTED) {
                            hr = hrNone;
                        }
                        continue;
                    }
    
                    //
                    //  Check this endpoints annotation against the annotation
                    //  supplied.  If it matches, we're done.
                    //
    
                    if (0 == _wcsicmp(wszAnnotation, wszBackupAnnotation)) {
                        //
                        //  Ok, this is on the right endpoint, now lets
                        //  check to make sure that it's on the right
                        //  transport.
                        //

                        if (NULL != szStringBinding) {
                            RpcStringFreeW(&szStringBinding);
                            szStringBinding = NULL;
                        }

                        hr = RpcBindingToStringBindingW(rbhHandle, &szStringBinding);
                        if (hr != hrNone) {
                            DebugTrace(("RpcBindingToStringBindingW failed 0x%x\n",
                                        hr));
                            break;
                        }
    
                        if (NULL != szProtocolSequence) {
                            RpcStringFreeW(&szProtocolSequence);
                            szProtocolSequence = NULL;
                        }
                        
                        hr = RpcStringBindingParseW(szStringBinding, NULL, &szProtocolSequence, NULL, NULL, NULL);
                        if (hr != hrNone) {
                            DebugTrace(("RpcStringBindingParseW failed 0x%x\n",
                                        hr));
                            break;
                        }
    

                        //
                        //  Now check to see if this binding handle goes over the
                        //  right protocol.
                        //
    
                        DebugTrace(("Endpoint %ws parsed protseq %ws table protseq %ws\n",
                                    szStringBinding, szProtocolSequence, rgszProtSeq[iszProtSeq]));

                        if (0 == wcscmp(szProtocolSequence, rgszProtSeq[iszProtSeq])) {
                            DebugTrace(("ConnectToBackup, binding = %ws\n",
                                        szStringBinding));
                            //
                            //  Ok, the annotation and the protocol sequence
                            //  both match, we can use this binding
                            //  handle for our API.
                            //
    
                            *prbhBinding = rbhHandle;
                            *piszProtSeq = iszProtSeq;
                            rbhHandle = NULL; // i.e., don't RpcBindingFree

                            return(hrNone);
                        }
                    }  // compare annotation
                } while (hr == hrNone);  // endpoint enumeration
            } RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) ) {
                DebugTrace(("Caught exception %d\n",
                            RpcExceptionCode()));
                continue;
            } RpcEndExcept;
        } // protseq enumeration
    } __finally {
        if (inqcontext != NULL) {
            RpcMgmtEpEltInqDone(&inqcontext);
        }

        if (NULL != szStringBinding) {
            RpcStringFreeW(&szStringBinding);
        }

        if (NULL != szProtocolSequence) {
            RpcStringFreeW(&szProtocolSequence);
        }

        if (NULL != wszAnnotation) {
            RpcStringFreeW(&wszAnnotation);
        }

        if (NULL != rbhHandle) {
            RpcBindingFree(&rbhHandle);
        }
    
        if (NULL != hBinding) {
            RpcBindingFree(&hBinding);
        }
    }

    return(hrCouldNotConnect);

}

/*
 -  DsSetCurrentBackupLogs
 -
 *  Purpose:
 *      This routine remotes an API to the server to check to make sure that all the necessary
 *      are present for the backup to proceed.  It is called for Incremental and Differential backups.
 *
 *  Parameters:
 *      puuidService - an Object UUID for the service.
 *      char *szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which endpoint to bind to.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
DsSetCurrentBackupLogA(
    LPCSTR szServer,
    DWORD dwCurrentLog
    )
{
    HRESULT hr;
    WSZ wszServer;

    // Parameter checking is done in the xxxW version of the routine

    if (szServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    wszServer = WszFromSz(szServer);

    if (wszServer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    hr = DsSetCurrentBackupLogW(wszServer, dwCurrentLog);

    MIDL_user_free(wszServer);

    return hr;
}

HRESULT
DsSetCurrentBackupLogW(
    LPCWSTR wszServer,
    DWORD dwCurrentLog
    )
{
    HRESULT hr;
    RPC_BINDING_HANDLE hBinding = NULL;
    I iszProtSeq;

    if (wszServer == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    for (iszProtSeq = 0; iszProtSeq < cszProtSeq ; iszProtSeq += 1)
    {
    
        Assert(hBinding == NULL);
        hr = HrCreateRpcBinding(iszProtSeq, (WSZ) wszServer, &hBinding);

        if (hr != hrNone)
        {
            return hr;
        }

        if (hBinding == NULL)
        {
            continue;
        }

        RpcTryExcept
        {
            hr = HrRRestoreSetCurrentLogNumber(hBinding, g_wszRestoreAnnotation, dwCurrentLog);
        }
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        {
            hr = RpcExceptionCode();
            UnbindRpc(&hBinding);
            continue;
        }
        RpcEndExcept

        break;
    }

    if (hBinding)
    {
        UnbindRpc(&hBinding);
    }

    return hr;
}


/*
 -  DsCheckBackupLogs
 -
 *  Purpose:
 *      This routine remotes an API to the server to check to make sure that all the necessary
 *      are present for the backup to proceed.  It is called for Incremental and Differential backups.
 *
 *  Parameters:
 *      puuidService - an Object UUID for the service.
 *      char *szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which endpoint to bind to.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
I_DsCheckBackupLogs(
    WSZ wszBackupAnnotation
    )
{
    HRESULT hr;
    handle_t hBinding;
    WCHAR rgwcComputer[ MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbComputerName = sizeof(rgwcComputer) / sizeof(rgwcComputer[0]);

    if (wszBackupAnnotation == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!GetComputerNameW(rgwcComputer, &cbComputerName))
    {
        return GetLastError();
    }

    hr = HrCreateRpcBinding(1, rgwcComputer, &hBinding);

    if (hr != hrNone)
    {
        return hr;
    }

    //
    //  If somehow named pipes weren't available, punt.
    //

    if (hBinding == NULL)
    {
        return hrCouldNotConnect;
    }

    RpcTryExcept
    {
        hr = HrRRestoreCheckLogsForBackup(hBinding, wszBackupAnnotation);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    UnbindRpc(&hBinding);

    return hr;
}


BOOL
DllEntryPoint(
    HINSTANCE hinstDll,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.

Arguments:

    hinstDll - an instance handle for the DLL.
    dwReason - The reason the routine was called.
    pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

    BOOL - TRUE if the DLL initialization was successful, FALSE if not.

--*/
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    {
        LPSTR rgpszDebugParams[] = {"ntdsbcli.dll", "-noconsole"};
        DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);

        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ntdsbcli");
        
        //
        //  We don't do anything on thread attach/detach, so we don't
        //  need to be called.
        //
        DisableThreadLibraryCalls(hinstDll);

        return(FInitializeSocketClient());
    }
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        DEBUGTERM();
        if (pvReserved == NULL)
        {
            //
            //  We were called because of an FreeLibrary call.  Clean up what ever is
            //  appropriate.
            //
            return(FUninitializeSocketClient());
        } else
        {
            //
            //  The system will free up resources we have loaded.
            //
        }
        break;
    default:
        break;
    }
    return(TRUE);
}


/*************************************************************************************
Routine Description: 
    
      DsSetAuthIdentity
        Used to set the security context under which the client APIs are to be
        called. If this function is not called, security context of the current
        process is assumed.

  Arguments:
    [in]    szUserName - name of the user
    [in]    szDomainName -  name of the domain the user belongs to
    [in]    szPassword - password of the user in the specified domain

Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsSetAuthIdentityA(
    LPCSTR szUserName,
    LPCSTR szDomainName,
    LPCSTR szPassword
    )
{
    WSZ wszUserName = NULL;
    WSZ wszDomainName = NULL;
    WSZ wszPassword = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

    if ( (szUserName == NULL) ||
         (szDomainName == NULL) ||
         (szPassword == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    wszUserName = WszFromSz(szUserName);
    wszDomainName = WszFromSz(szDomainName);
    wszPassword = WszFromSz(szPassword);

    if (wszUserName && wszDomainName && wszPassword)
    {
        hr = DsSetAuthIdentityW(wszUserName, wszDomainName, wszPassword);
    }

    if (wszUserName)
        MIDL_user_free(wszUserName);

    if (wszDomainName)
        MIDL_user_free(wszDomainName);

    if (wszPassword)
        MIDL_user_free(wszPassword);

    return hr;
}

HRESULT
NTDSBCLI_API
DsSetAuthIdentityW(
    LPCWSTR szUserName,
    LPCWSTR szDomainName,
    LPCWSTR szPassword
    )
{
    HRESULT hr = ERROR_SUCCESS;

    if ( (szUserName == NULL) ||
         (szDomainName == NULL) ||
         (szPassword == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    g_pAuthIdentity = MIDL_user_allocate(sizeof(SEC_WINNT_AUTH_IDENTITY_W));

    if (!g_pAuthIdentity)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    memset(g_pAuthIdentity, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_W));

    // set the user name
    g_pAuthIdentity->UserLength = wcslen(szUserName);
    g_pAuthIdentity->User = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->UserLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->User)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    // set the domain name
    g_pAuthIdentity->DomainLength = wcslen(szDomainName);
    g_pAuthIdentity->Domain = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->DomainLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->Domain)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    // set the password
    g_pAuthIdentity->PasswordLength = wcslen(szPassword);
    g_pAuthIdentity->Password = (WCHAR *) MIDL_user_allocate((g_pAuthIdentity->PasswordLength + 1) * sizeof(WCHAR));
    if (!g_pAuthIdentity->Password)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (ERROR_SUCCESS == hr)
    {
        wcscpy(g_pAuthIdentity->User, szUserName);
        wcscpy(g_pAuthIdentity->Domain, szDomainName);
        wcscpy(g_pAuthIdentity->Password, szPassword);
        g_pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        // unable to allocate space for some parts - free everything and set g_pAuthIdentity to NULL
        if (g_pAuthIdentity->User)
            MIDL_user_free(g_pAuthIdentity->User);

        if (g_pAuthIdentity->Domain)
            MIDL_user_free(g_pAuthIdentity->Domain);

        if (g_pAuthIdentity->Password)
            MIDL_user_free(g_pAuthIdentity->Password);

        MIDL_user_free(g_pAuthIdentity);

        g_pAuthIdentity = NULL;
    }
    
    return hr;
}

LONGLONG
GetSecsSince1601()
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;

    LONGLONG  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );
    
    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);
    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    // Ok. now we have the no. of 100 ns intervals since 1601
    // in dsTime. Convert to seconds and return
    
    return(dsTime/(10*1000*1000L));
}

HRESULT
HrGetTombstoneLifeTime(
    LPCWSTR wszBackupServer,
    LPDWORD pdwTombstoneLifeTimeDays
    )
{
    DWORD err, ldStatus, length;
    LDAP *hld;
    static LPSTR rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    static CHAR pszDirectoryService[] = "CN=Directory Service,CN=Windows NT,CN=Services,";
    static LPSTR rgpszDsAttrsToRead[] = {"tombstoneLifetime", NULL};
    LDAPMessage *pRootResults = NULL;
    LDAPMessage *pDsResults = NULL;
    LPSTR *ppszConfigNC = NULL;
    LPSTR pszDsDn = NULL;
    LPSTR *ppszValues = NULL;
    ULONG ulOptions = PtrToUlong(LDAP_OPT_ON);

    // Get the tombstone lifetime using ldap

    // Get rid of leading backslashes if present
    if (*wszBackupServer == L'\\') {
        wszBackupServer++;
        if (*wszBackupServer == L'\\') {
            wszBackupServer++;
        }
    }

    // Connect & bind to target DSA.
    hld = ldap_initW((LPWSTR)wszBackupServer, LDAP_PORT);
    if (NULL == hld) {
        ldStatus = LdapGetLastError();
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }

    // We have the ldap server name to connect to, so we just have to do a DNS A Record lookup
    
    ldStatus = ldap_set_option(hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }

    ldStatus = ldap_connect(hld, NULL);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }
    ldStatus = ldap_bind_s(hld, NULL, (WCHAR *) g_pAuthIdentity, LDAP_AUTH_SSPI);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }

    // Get the config container
    ldStatus = ldap_search_sA(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pRootResults);
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }
    if (pRootResults == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }
    ppszConfigNC = ldap_get_valuesA(hld, pRootResults, "configurationNamingContext");
    if (ppszConfigNC == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    // Construct dn to directory service object
    length = strlen( *ppszConfigNC ) +
        strlen( pszDirectoryService ) + 1;
    pszDsDn = malloc( length );
    if (pszDsDn == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    strcpy( pszDsDn, pszDirectoryService );
    strcat( pszDsDn, *ppszConfigNC );

    // Read tombstone lifetime, if present
    ldStatus = ldap_search_sA(hld, pszDsDn, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszDsAttrsToRead, 0, &pDsResults);
    if (ldStatus == LDAP_NO_SUCH_ATTRIBUTE) {
        // Not present - use default
        *pdwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        err = ERROR_SUCCESS;
        goto error;
    }
    if (ldStatus != LDAP_SUCCESS) {
        err = LdapMapErrorToWin32( ldStatus );
        goto error;
    }
    if (pDsResults == NULL) {
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }
    ppszValues = ldap_get_valuesA(hld, pDsResults, "tombstoneLifetime");
    if (ppszValues == NULL) {
        // Not present - use default
        *pdwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
        err = ERROR_SUCCESS;
        goto error;
    }

    *pdwTombstoneLifeTimeDays = strtoul( *ppszValues, NULL, 10 );
    err = ERROR_SUCCESS;

error:
    if (ppszValues) {
        ldap_value_freeA( ppszValues );
    }
    if (pDsResults) {
        ldap_msgfree(pDsResults);
    }
    if (pszDsDn) {
        free( pszDsDn );
    }
    if (ppszConfigNC) {
        ldap_value_freeA( ppszConfigNC );
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    ldap_unbind( hld );

    // This function returns a HRESULT status
    return err ? HRESULT_FROM_WIN32( err ) : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\utest\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       main.c
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    main.c

Abstract:

    This module implements a command line utility that uses the NTDS backup/restore
    client API to perform backup and restore. The API used by this utility is identical
    to the one that is used by the NT Tape backup utility except that this utility stores
    the backup files in a disk directory instead of a tape.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created     04/04/97    rsraghav
    
    Modified    10/15/1999  BrettSh - Added support for expiry tokens.

NOTES:

WARNING: THIS IS NOT A FULL ACTIVE DIRECTORY BACKUP UTILITY.
 
    This is not a full DS backup utility, this utility is merely for 
    demonstrating the remote backup API.  Other things (registry, system 
    ini files, etc) need to be backed up to perform a full backup of a 
    Domain Controller (DC), so that it will be able to recover from a 
    complete crash.  

Local Case Backup/Restore:
------------------------------------------------- Local Backup
rem This is the local case of a backup.
dsback /backup -s brettsh-posh -dir C:\dsbackup

------------------------------------------------- Local Restore
rem This is for the local case, obviously some of the commands should be 
rem     changed in the remote cases.  One should change drive letters, and 
rem     windows directories as appropriate.
rem Note: This machine must be started up in DS repair mode before running 
rem     these commands.
rem Step 1: Remove old DS files ------------------------------
del C:\winnt\ntds\*
rem Step 2: Move over backup files ---------------------------
xcopy  C:\dsbackup\*  C:\winnt\ntds\
rem Step 3: Run restore utility ----------------------------------
rem Note: You must use the UNC name of the ntds directory
dsback /restore -s brettsh-posh -dir \\brettsh-posh\c$\winnt\ntds <lowLog #> <highLog #>
rem restart machine.

Remote Case Backup/Restore:
------------------------------------------------- Remote Backup
rem This is the remote case of a backup.  This backs up brettsh-baby's
rem    directory onto the local machine (the machine this command should
rem    be run from) brettsh-ginger.
dsback /backup -s brettsh-baby -dir C:\dsbackup

------------------------------------------------- Remote Restore
rem This is the remote machine.  The DC being restored is brettsh-baby.  The 
rem    machine that has the backed up DS files is brettsh-ginger.  These 
rem    commands would be run from brettsh-ginger.
rem Note: before this brettsh-baby must be restarted in DS repair mode.
rem Step 1: Remove old DS files ------------------------------
del \\brettsh-baby\winnt\ntds\*
rem Step 2: Move over backup files ---------------------------
rem Note: that C:\dsbackup is on brettsh-ginger.
xcopy  C:\dsbackup\*  \\brettsh-baby\winnt\ntds\
rem Step 3: Run restore utility ----------------------------------
rem Note: You must use the UNC name of the ntds directory
dsback /restore -s brettsh-baby -dir \\brettsh-baby\c$\winnt\ntds <lowLog #> <highLog #>

rem restart brettsh-baby, note this is the remote machine.

---------------------------------------------------
Suggested that one uses NT backup normally, unless you are developing
your own backup utility, then this code provides a framework to start
your Active Directory backup utility.

--*/


#include <windows.h>
#include <stdio.h>
#include <ntdsbcli.h>
#include <stdarg.h>
#include <stdlib.h>

#define ERROR_MODE      (0)
#define WARNING_MODE    (1)
#define INFO_MODE       (2)
#define VERBOSE_MODE    (3)

#define DSBACK_DATABASE_LOCATIONS_FILE "dsback.txt"
#define DEFAULT_BUFFER_SIZE 32768
#define TOKEN_FILE_NAME "token.dat"

typedef enum
{
    CMD_STATUS,
    CMD_BACKUP,
    CMD_RESTORE,
    CMD_HELP
} CMD_TYPE;

BOOL g_fVerbose = FALSE;
char *g_szServer = NULL;
char *g_szBackupDir = NULL;
char *g_szBackupLogDir = NULL;
ULONG g_ulLowLog = 0;
ULONG g_ulHighLog = 0;

// Proto-type all internal functions
int Print(int nLevel, const char *format, ...);
void PrintUsage();
CMD_TYPE GetCommand(const char *szCmd);
int Status(int argc, char *argv[]);
int Backup(int argc, char *argv[]);
int Restore(int argc, char *argv[]);
DWORD ReadTokenFile(PVOID * ppvExpiryToken, PDWORD pcbExpiryToken);
DWORD WriteTokenFile(PVOID pvExpiryToken, DWORD cbExpiryToken);

void DoBackup();
void DoRestore();

BOOL FBackupAttachments(HBC hbc, char *szAttachmentList);

// returns the number of params processed
int ProcessCommonParams(int argc, char *argv[]);

// returns the number of params processed
int ImpersonateClient(int argc, char *argv[]);

// returns the number of params processed
int ProcessBackupDir(int argc, char *argv[], int argIndex);

// returns a pointer to the filename part of the given full path'ed filename
// NULL, if there is no filename part
char *SzFileName(char *szPath);

// Adjust the client token privilege for backup or restore
DWORD AdjustTokenPrivilege(BOOL fBackup);

int __cdecl main(int argc, char *argv[])
{

    int nRet = 0;
    BOOL fRet;
    HRESULT hr;

    if (argc < 2)
    {
        PrintUsage();
        return 0;
    }

    switch (GetCommand(argv[1]))
    {
        case CMD_STATUS:
            nRet = Status(argc, argv);
            break;

        case CMD_BACKUP:
            nRet = Backup(argc, argv);
            break;

        case CMD_RESTORE:
            nRet = Restore(argc, argv);
            break;

        case CMD_HELP:
            PrintUsage();
            break;

        default:
            printf("Unknown Command!\n");
            break;
    }

    return nRet;
}

int Status(int argc, char *argv[])
{
    HRESULT hr; 
    BOOL fOnline;
    
    if (ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far - find out the DS Online status
        if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
        {
            Print(INFO_MODE, "NT Directory Service is %s on %s!\n", fOnline ? "ONLINE" : "OFFLINE", g_szServer);
        }
        else
        {
            Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        }
    }

    return 0;
}

int Backup(int argc, char *argv[])
{
    int nProcessed = 0;
    int nBackupDirArgIndex = 0;

    if (nProcessed = ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far
        nBackupDirArgIndex = nProcessed + 2;
        
        if (ProcessBackupDir(argc, argv, nBackupDirArgIndex))
        {
            // all command-line arguments are valid so far
            // no more command-line processing needed
            DoBackup();
        }
    }

    return 0;
}

int Restore(int argc, char *argv[])
{
    int nProcessed = 0;
    int nBackupDirArgIndex = 0;
    
    if (nProcessed = ProcessCommonParams(argc, argv))
    {
        // the command-line arguments are valid so far
        nBackupDirArgIndex = nProcessed + 2;
        
        if (nProcessed = ProcessBackupDir(argc, argv, nBackupDirArgIndex))
        {
            if (argc < (nBackupDirArgIndex + nProcessed + 2))
            {
                PrintUsage();
                return 0;
            }

            g_ulLowLog = strtoul(argv[nBackupDirArgIndex + nProcessed], NULL, 16);
            g_ulHighLog = strtoul(argv[nBackupDirArgIndex + nProcessed + 1], NULL, 16);

            // all command-line arguments are valid so far
            // no more command-line processing needed
            DoRestore();
        }
    }

    return 0;
}

void DoBackup()
{
    HBC hbc = NULL;
    HRESULT hr;
    LPSTR szAttachmentInfo = NULL;
    LPSTR szLogfileInfo = NULL;
    DWORD cbAttachmentInfo =0;
    DWORD cbLogfileInfo = 0;
    BOOL fOnline = FALSE;
    DWORD dwRet;
    PVOID pvExpiryToken = NULL;
    DWORD cbExpiryToken = 0;

    // Adjust token privileges for backup
    dwRet = AdjustTokenPrivilege(TRUE);

    if (ERROR_SUCCESS != dwRet)
    {
        Print(VERBOSE_MODE, "AdjustTokenPrivilege() failed for enabling backup privilege - Error Code: %u\n", dwRet);
    }

    if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
    {
        if (!fOnline)
        {
            Print(ERROR_MODE, "DS on server %s in NOT online! Offline backup is not supported!\n", g_szServer);
            return;
        }
    }
    else
    {
        Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        return;
    }

    // Prepare for backup
    hr = DsBackupPrepare(g_szServer, 0, BACKUP_TYPE_FULL, 
                &pvExpiryToken, &cbExpiryToken, &hbc);
    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsBackupPrepare() failed for server %s - Error Code: %d\n",
              g_szServer, hr);
        return;
    }

    Print(VERBOSE_MODE, "DsBackupPrepare() for server %s successful!\n", g_szServer);

    __try
    {
        // Get Database names and back them up
        hr = DsBackupGetDatabaseNames(hbc, &szAttachmentInfo, &cbAttachmentInfo);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupGetDatabaseNames() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsBackupGetDatabaseNames() for server %s successful!\n", g_szServer);

        if (!FBackupAttachments(hbc, szAttachmentInfo))
        {
            __leave;
        }
        DsBackupFree(szAttachmentInfo);

        // Get logfile names and back them up
        hr = DsBackupGetBackupLogs(hbc, &szLogfileInfo, &cbLogfileInfo);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupGetBackupLogs() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsBackupGetBackupLogs() for server %s successful!\n", g_szServer);

        if (!FBackupAttachments(hbc, szLogfileInfo))
        {
            __leave;
        }
        DsBackupFree(szLogfileInfo);

        // All logs are backed up - truncate logs
        hr = DsBackupTruncateLogs(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupTruncateLogs() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "DB logs truncated successfully on server %s!\n", g_szServer);
        }
        
        // Write the token that we got up at the top in DsBackupPrepare().
        dwRet = WriteTokenFile(pvExpiryToken, cbExpiryToken);
        if(dwRet != ERROR_SUCCESS){
            // The error is printed/success msg is printed by WriteTokenFile()
            __leave;
        }


    }
    __finally
    {

        // close the backup context
        hr = DsBackupEnd(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupEnd() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "Server %s successfully backed up into directory %s\n", g_szServer, g_szBackupDir);
        }
    }
}

void DoRestore()
{
    HBC hbc = NULL;
    HRESULT hr;
    EDB_RSTMAP rstMap;
    LPSTR szDatabaseLocations = NULL;
    DWORD cbDatabaseLocations = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten = 0;
    char szFileName[MAX_PATH];
    char szOldDBName[MAX_PATH];
    char szNewDBName[MAX_PATH];
    BOOL fOnline = TRUE;
    DWORD dwRet;
    PVOID pvExpiryToken = NULL;
    DWORD cbExpiryToken = 0;

    // Adjust token privileges for restore
    dwRet = AdjustTokenPrivilege(FALSE);

    if (ERROR_SUCCESS != dwRet)
    {
        Print(VERBOSE_MODE, "AdjustTokenPrivilege() failed for enabling restore privilege - Error Code: %u\n", dwRet);
    }

    if (hrNone == (hr = DsIsNTDSOnline(g_szServer, &fOnline)))
    {
        if (fOnline)
        {
            Print(ERROR_MODE, "DS on server %s is Online! Online restore is NOT supported!\n", g_szServer);
            return;
        }
    }
    else
    {
        Print(ERROR_MODE, "Unable to contact %s - Error Code: %d\n", g_szServer, hr);
        return;
    }

    dwRet = ReadTokenFile(&pvExpiryToken, &cbExpiryToken);
    if (dwRet != ERROR_SUCCESS) {
        // Error printed in ReadTokenFile()
        return;
    }

    hr = DsRestorePrepare(g_szServer, RESTORE_TYPE_CATCHUP, 
            pvExpiryToken, cbExpiryToken, &hbc); 
    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsRestorePrepare() failed for server %s - Error Code: %d\n", g_szServer, hr);
        if(pvExpiryToken) { LocalFree(pvExpiryToken); }
        return;
    }

    Print(VERBOSE_MODE, "DsRestorePrepare() for server %s successful!\n", g_szServer);

    __try
    {
        // Get the Database locations and store it in a file for later use
        hr = DsRestoreGetDatabaseLocations(hbc, &szDatabaseLocations, &cbDatabaseLocations);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreGetDatabaseLocations() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }

        Print(VERBOSE_MODE, "DsRestoreGetDatabaseLocations() for server %s successful!\n", g_szServer);

        DsBackupFree(szDatabaseLocations);

        // register the restore
        strcpy(szOldDBName, g_szBackupDir);
        strcat(szOldDBName, "\\ntds.dit");
        strcpy(szNewDBName, szOldDBName);

        rstMap.szDatabaseName = szOldDBName;
        rstMap.szNewDatabaseName = szNewDBName;                                   
        hr = DsRestoreRegister(hbc, g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, 
                g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, &rstMap, 1, 
                g_szBackupLogDir ? g_szBackupLogDir : g_szBackupDir, g_ulLowLog, g_ulHighLog);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreRegister() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsRestoreRegister() for server %s successful!\n", g_szServer);

        // do actual file copy here!!

        //Register restore as complete
        hr = DsRestoreRegisterComplete(hbc, hrNone);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreRegisterComplete() failed for server %s - Error Code: %d\n", g_szServer, hr);
            __leave;
        }
        Print(VERBOSE_MODE, "DsRestoreRegisterComplete() for server %s successful!\n", g_szServer);
    
    }
    __finally
    {
        // close the restore context
        hr = DsRestoreEnd(hbc);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsRestoreEnd() failed for server %s - Error Code: %d\n", g_szServer, hr);
        }
        else
        {
            Print(INFO_MODE, "Server %s successfully restored!\n", g_szServer);
        }
        if(pvExpiryToken) { LocalFree(pvExpiryToken); }
    }
}


CMD_TYPE GetCommand(const char *szCmd)
{
    if (!_stricmp(szCmd, "/Status"))
        return CMD_STATUS;

    if (!_stricmp(szCmd, "/Backup"))
        return CMD_BACKUP;

    if (!_stricmp(szCmd, "/Restore"))
        return CMD_RESTORE;

    return CMD_HELP;
}

// returns the number of params processed
int ProcessCommonParams(int argc, char *argv[])
{
    int nProcessed = 0;

    int nArgBase = 2;

    if ((argc < 4) || (_stricmp(argv[2], "-s") && _stricmp(argv[2], "-v")))
    {
        // -s or -v expected
        PrintUsage();
        return 0;
    }

    if (!_stricmp(argv[2], "-v"))
    {
        g_fVerbose = TRUE;
        nArgBase++;

        if (_stricmp(argv[3], "-s"))
        {
            // server name argument not present
            PrintUsage();
            return 0;
        }
    }

    // get the server name
    g_szServer = argv[nArgBase + 1];

    nProcessed = ImpersonateClient(argc, argv);
    if (nProcessed < 0)
    {
        // some error occurred while getting params for impersonate client
        return 0;
    }

    return (nProcessed + nArgBase);    
}

// returns the number of params processed
int ImpersonateClient(int argc, char *argv[])
{
    HRESULT hr;

    int nArgBase = 4;

    if (g_fVerbose)
        nArgBase++;

    if ((argc < (nArgBase + 1)) || _stricmp(argv[nArgBase], "-d"))
    {
        // 5th parameter is not -d, no need to impersonate client
        return 0;
    }

    // Need to impersonate client - make sure all parameters needed to impersonate client are available
    if ((argc < (nArgBase + 6)) || _stricmp(argv[nArgBase + 2], "-u") || _stricmp(argv[nArgBase + 4], "-p"))
    {
        // command-line args for impersonation are incorrect
        PrintUsage();
        return -1;
    }

    // We have all parameter - call the API to set security context
    hr = DsSetAuthIdentity(argv[nArgBase + 3], argv[nArgBase + 1], argv[nArgBase + 5]);

    if (hr != hrNone)
    {
        Print(ERROR_MODE, "DsSetAuthIdentity() failed for domain: %s, user: %s, password: %s\n", argv[nArgBase + 1], argv[nArgBase + 3], argv[nArgBase + 5]);
        return -1;
    }

    return 6;
}

int ProcessBackupDir(int argc, char *argv[], int argIndex)
{
    int nParamsProcessed = 0;

    if (argIndex < 4 || argc < (argIndex + 2) || _stricmp(argv[argIndex], "-dir"))
    {
        // error 
        PrintUsage();
        return 0;
    }

    // get the back dir
    g_szBackupDir = argv[argIndex + 1];
    nParamsProcessed += 2;

    // Check to see if there is a separate log dir specified
    if (argc >= (argIndex + 4) && !_stricmp(argv[argIndex + 2], "-logdir"))
    {
        g_szBackupLogDir = argv[argIndex + 3];
        nParamsProcessed += 2;
    }

    // return number of parameters processed
    return nParamsProcessed;
}

void PrintUsage()
{
    printf("Usage:: dsback /<cmd> [-v] -s server [-d <domain> -u <user> -p <password>] <cmd specific params>\n");
    printf("<cmd>:\n");
    printf("       /status   : tells if the NTDS is online on the specified server\n");
    printf("       /backup   : backs up the NTDS (if it is online) into the given dir\n");
    printf("                   <params>: -dir <backup dir>\n");
    printf("       /restore  : configures the specified server for NTDS restore\n");
    printf("                   <params>: -dir <UNC path of the database dir> [-logdir <UNC path of the db log dir]<lowLog#> <highLog#>\n");
    printf(" -v : executes the specified command in verbose mode\n");
    printf("  Note: That before running the restore command, the old directory files\n");
    printf("        should be deleted from %%windir%%\\ntds\\, and all the backup files should\n");
    printf("        be copied into this directory.  High and Low log numbers are in hex.\n");
}

int Print(int nLevel, const char *format, ...)
{
    va_list arglist;
    int nRet = 0;

    va_start(arglist, format);

    switch(nLevel)
    {
        case VERBOSE_MODE:
            if (g_fVerbose)
            {
                nRet = vprintf(format, arglist);
            }
            break;

        case INFO_MODE:
            nRet = vprintf(format, arglist);
            break;
            
        case WARNING_MODE:
            nRet = vprintf(format, arglist);
            break;
            
        case ERROR_MODE:
            nRet = vprintf(format, arglist);
            break;

        default:
            nRet = vprintf(format, arglist);
            break;
    }

    va_end(arglist);

    return nRet;
}

char *SzFileName(char *szPath)
{
    char *szRet;

    if ((szRet = strrchr(szPath, '\\')))
        return (szRet+1);

    return NULL;
}

BOOL FBackupAttachments(HBC hbc, char *szAttachmentList)
{
    LPSTR szTemp = NULL;
    char szFileName[MAX_PATH];
    BYTE pb[DEFAULT_BUFFER_SIZE];
    DWORD cb = DEFAULT_BUFFER_SIZE;
    DWORD cbRead = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten = 0;
    HRESULT hr;

    szTemp = szAttachmentList;
    while (*szTemp != 0)
    {
        LARGE_INTEGER liFileSize;
        DWORD cbExpected;
        char *chTmp;

        szTemp++; // skip the BFT char
        hr = DsBackupOpenFile(hbc, szTemp, cb, &liFileSize);
        if (hr != hrNone)
        {
            Print(ERROR_MODE, "DsBackupOpenFile() failed for server %s - Error Code: %d\n", g_szServer, hr);
            return FALSE;
        }

        cbExpected = liFileSize.LowPart;

        // backup file is opened in the backup context - create a disk file
        strcpy(szFileName, g_szBackupDir);
        strcat(szFileName, "\\");
        if (NULL == (chTmp = SzFileName(szTemp))) {
            Print(ERROR_MODE, "DsBackupOpenFile() failed to parse file name\n");
            return FALSE;
        }
        strcat(szFileName, chTmp); 
        hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            Print(ERROR_MODE, "Unable to Create the file %s\n!", szFileName);
            return FALSE;            
        }

        // read the file data through the API and write it to the disk file
        do 
        {
            cbRead = 0;

            hr = DsBackupRead(hbc, pb, cb, &cbRead);
            if (hr != hrNone &&  hr != ERROR_HANDLE_EOF)
            {
                Print(ERROR_MODE, "DsBackupRead() failed for server %s  - Error Code: %d\n", g_szServer, hr);
                return FALSE;
            }

            if (cbRead)
            {
                if (!WriteFile(hFile, pb, cbRead, &cbWritten, NULL) || (cbWritten != cbRead))
                {
                    Print(ERROR_MODE, "WriteFile failed for %s \n!", szFileName);
                    return FALSE;
                }
                
                cbExpected -= cbRead;
            }
            else
                break;

        } while ((hrNone == hr) && (cbExpected > 0));
        
        Print(VERBOSE_MODE, "Finished backing up %s!\n", SzFileName(szTemp));

        hr = DsBackupClose(hbc);
        if (hr !=hrNone)
        {
            Print(ERROR_MODE, "DsBackupClose() failed for server %s - Error Code: %d\n", g_szServer, hr);
            return FALSE;
        }
        
        CloseHandle(hFile);

        szTemp += (strlen(szTemp) + 1);
    }

    return TRUE;
}

DWORD AdjustTokenPrivilege(BOOL fBackup)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tpNew;
    LUID luid;
    DWORD dwRet;

    // Open the process token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        dwRet = GetLastError();
        return dwRet;
    }

    // Get the local unique id 
    if (!LookupPrivilegeValue(NULL, fBackup ? SE_BACKUP_NAME : SE_RESTORE_NAME, &luid))
    {
        dwRet = GetLastError();
        CloseHandle(hToken);
        return dwRet;
    }

    // Fill-in the TOKEN_PRIVILEGE struct
    tpNew.PrivilegeCount = 1;
    tpNew.Privileges[0].Luid = luid;
    tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tpNew, sizeof(tpNew), NULL, NULL))
    {
        dwRet = GetLastError();
        CloseHandle(hToken);
        return dwRet;
    }

    
    CloseHandle(hToken);
    
    return ERROR_SUCCESS;
}


DWORD
WriteSmallFile(
    LPSTR                    szFileName,
    BYTE *                   pbBuffer,
    DWORD                    cbBuffLen
    )
/*++

Description: Takes the a buffer (pbBuffer), and the size of the buffer 
    (cBuffLen), and writes it to the file szFileName.  Note can only handle 
    files of 4 GB or less.
    
Arguments:
    szFileName (IN) - String of the filename.
    pbBuffer (IN) - The buffer to write to disk.
    cBuffLen (IN) - The length of the buffer in pbBuffer.    
    
Return Value: Returns a Win32 error.

--*/
{
    HANDLE                   hFile = INVALID_HANDLE_VALUE;
    DWORD                    cbWritten = 0;

    hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile){
        return(GetLastError());
    }
    
    if (!WriteFile(hFile, pbBuffer, cbBuffLen, &cbWritten, NULL) || (cbWritten != cbBuffLen)){
        CloseHandle(hFile);
        return(GetLastError());
    }

    CloseHandle(hFile);
    return(ERROR_SUCCESS);
}

DWORD
ReadSmallFile(
    LPSTR                    szFileName,
    BYTE **                  ppbBuffer,
    PDWORD                   pcbBuffLen
    )
/*++
Description: Takes the name of a file (szFileName), and returns in *pcbBuffLen 
    bytes of LocalAlloc'd memory pointed to by *ppbBuffer.

Arguments:
    szFileName (IN) - String of the filename.
    ppbBuffer (OUT) - A pointer to the loc of the pointer of the LocalAlloc'd 
        buffer that gets returned.
    pcBuffLen (OUT) - The length of the buffer returned.
    
Return Value: Returns a Win32 error.

--*/
{
    HANDLE                   hFile = INVALID_HANDLE_VALUE;
    DWORD                    cbRead = 0;

    hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile){
        return(GetLastError());
    }
    
    *pcbBuffLen = GetFileSize(hFile, NULL);
    if(*pcbBuffLen == -1){
        CloseHandle(hFile);
        return(GetLastError());
    }
    *ppbBuffer = LocalAlloc(LMEM_FIXED, *pcbBuffLen);
    if(*ppbBuffer == NULL){
        CloseHandle(hFile);
        return(GetLastError());
    }

    if (!ReadFile(hFile, *ppbBuffer, *pcbBuffLen, &cbRead, NULL) || (*pcbBuffLen != cbRead)){
        CloseHandle(hFile);
        LocalFree(*ppbBuffer);
        return(GetLastError());
    }

    CloseHandle(hFile);
    return(ERROR_SUCCESS);
}

DWORD
ReadTokenFile(
    PVOID *                 ppvExpiryToken,
    PDWORD                  pcbExpiryToken
    )
/*++
Description: This constructs the filename of the Expiry Token, and then
    writes this out to a file in the backup dir.
    
Arguments:
    ppvExpiryToken (OUT) - This is a LocalAlloc'd version of the Expiry Token.
    pcbExpiryToken (OUT) - This is the size of the LocalAlloc'd Expiry Token.
    
Return Value: Returns a Win32 error.

--*/
{
    CHAR                     szFileName[MAX_PATH];
    DWORD                    dwRet;

    strcpy(szFileName, g_szBackupDir);
    strcat(szFileName, "\\");
    strcat(szFileName, TOKEN_FILE_NAME); 

    dwRet = ReadSmallFile(szFileName, (BYTE **) ppvExpiryToken, pcbExpiryToken);
    if(dwRet != ERROR_SUCCESS){
        Print(ERROR_MODE, "There was an error (%d) reading the Expiry Token file (%s).\n",
              dwRet, szFileName);
        return(dwRet);
    }
    Print(VERBOSE_MODE, "Finished reading Expiry Token file!\n");
    return(ERROR_SUCCESS);
}

DWORD
WriteTokenFile(
    PVOID                   pvExpiryToken,
    DWORD                   cbExpiryToken
    )
/*++
Description: This constructs the file name of the Expiry Token, and then
    writes the token out.
    
Arguments:
    pvExpiryToken (IN) - This is the Expiry Token to write out.
    cbExpiryToken (IN) - This is the Expiry Token's size to write out.

Return Values: Returns a Win32 error.  

--*/
{
    CHAR                     szFileName[MAX_PATH];
    DWORD                    dwRet;

    strcpy(szFileName, g_szBackupDir);
    strcat(szFileName, "\\");
    strcat(szFileName, TOKEN_FILE_NAME);

    dwRet = WriteSmallFile(szFileName, pvExpiryToken, cbExpiryToken);
    if(dwRet != ERROR_SUCCESS){
        Print(ERROR_MODE, "There was an error (%d) writing the token file (%s).\n",
              dwRet, szFileName);
        return(dwRet);
    }
    Print(VERBOSE_MODE, "Finnished writing out Expiry Token file!\n");
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetback\snapshot.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    snapshot.cxx

Abstract:

    Support for Jet Snapshot Backup

    The code instantiates a COM object which performs snapshot writer functions.
    We override some of the methods of the interface in order to receive notification
    when important events occur.  The events are:

    o PrepareBackupBegin
    o PrepareBackupEnd
    o BackupCompleteEnd
    o RestoreBegin
    o RestoreEnd

    It is not necessary to call any Jet functions after the restore.

    The snapshot writer operates under the same model as the file-based backup facility.
    The backup occurs online with the NTDS, and the restore occurs when the NTDS is
    offline.  We enforce this and will reject the snapshot operation if the NTDS is not
    in the proper mode. The snapshot facility supports online restore, but we continue
    to require an offline restore, because currently we have no mechanism to synchronize
    the directory with an instantaneous change in the database.

    We continue to enforce the concept of backup expiration. If a backup is older than a
    tombstone lifetime, we refuse to restore it.

    The way we communicate information about the backup to the restoration is through the
    use of "backup metadata". This is a string that we provide at backup-time that is
    given back to us at restore time. We impose a simple keyword=value structure on this
    string. This is how we communicate the backup expiration.  This mechanism can be
    extended in the future to pass whatever we want.

    After the restore is done, we update the registry to inform the directory that a
    restore has taken place. Two actions are done (see OnRestoreEnd):

    1. We create a new invocation id to represent the new database identity
    2. We set the key in the registry to indicate we are restored.

    Note that we do not set the "restore in progress" key that is used by the
    RecoverAfterRestore facility, because that is only required for a file-based
    restore.

Author:

    Will Lees (wlees) 22-Dec-2000

Environment:

Notes:

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "snapshot.hxx"

extern "C" {

// Core DSA headers.
#include <ntdsa.h>
#include "dsexcept.h"

#include <windows.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <ntdsbsrv.h>
#include <ntdsbmsg.h>
#include <dsconfig.h>
#include <taskq.h>
#include <dsutil.h> // SZDSTIME_LEN
#include <sddl.h>  // ConvertStringSecurityDescriptorToSecurityDescriptor()
#include "local.h"

#define DEBSUB "SNAPSHOT:"       // define the subsystem for debugging
#include "debug.h"              // standard debugging header
#include <fileno.h>
#define  FILENO FILENO_SNAPSHOT
#include "dsevent.h"
#include "mdcodes.h"            // header for error codes
#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

} // extern "C"

#include <vss.h>
#include <vswriter.h>
#include <jetwriter.h>
#include <esent.h>

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#define EXPIRATION_TIME_KEYWORD L"ExpirationTime"
#define EXPIRATION_TIME_LENGTH (ARRAY_SIZE(EXPIRATION_TIME_KEYWORD) - 1)
#define WRITERLESS_RESTORE L"WriterlessRestore"
#define WRITERLESS_RESTORE_LENGTH (ARRAY_SIZE(WRITERLESS_RESTORE) - 1)


#define LOG_UNHANDLED_BACKUP_ERROR( error ) logUnhandledBackupError( error, DSID( FILENO, __LINE__ ))

#define EVENT_SERVICE "EventSystem"

/* External */

extern "C" {
    extern BOOL g_fBootedOffNTDS;
    extern BOOL g_fAllowOnlineSnapshotRestore;
} // extern "C"

/* Static */

HANDLE  hSnapshotJetWriterThread = NULL;
HANDLE hServDoneEvent = NULL;
unsigned int tidSnapshotJetWriterThread = 0;

static UUID guuidWriter = { /* b2014c9e-8711-4c5c-a5a9-3cf384484757 */
    0xb2014c9e,
    0x8711,
    0x4c5c,
    {0xa5, 0xa9, 0x3c, 0xf3, 0x84, 0x48, 0x47, 0x57}
  };

/* Forward */

DWORD
DsSnapshotJetWriter(
    VOID
    );

/* End Forward */




// Override writer class with custom restore function

class CVssJetWriterLocal : public CVssJetWriter
    {
public:

    // Backup Functions
    virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);
    virtual bool STDMETHODCALLTYPE OnPrepareBackupBegin(IN IVssWriterComponents *pWriterComponents);
    virtual bool STDMETHODCALLTYPE OnPrepareBackupEnd(IN IVssWriterComponents *pWriterComponents,
							  IN bool fJetPrepareSucceeded);
    virtual bool STDMETHODCALLTYPE OnPrepareSnapshotBegin(void);
    // FUTURE-2002/08/09-BrettSh - Snapshot guys (Ran Kalach) told me that 
    // this (OnPrepareSnapshotEnd()) would be a better place to prepare our
    // database, BUT it wasn't being called, if they fix this, we should 
    // consider moving OnPrepareSnapshotBegin() to be OnPrepareSnapshotEnd()
    virtual bool STDMETHODCALLTYPE OnPrepareSnapshotEnd(void);
    virtual bool STDMETHODCALLTYPE OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							   IN bool fJetBackupCompleteSucceeded);
    virtual bool STDMETHODCALLTYPE OnThawEnd(bool bJetSuccessfulThaw);
    virtual void STDMETHODCALLTYPE OnAbortEnd();

    // Restore Functions
    virtual bool STDMETHODCALLTYPE OnPreRestoreBegin(IVssWriterComponents *pComponents);
    virtual bool STDMETHODCALLTYPE OnPreRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
    virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);


};


VOID
logUnhandledBackupError(
    DWORD dwError,
    DWORD dsid
    )

/*++

Routine Description:

    Log an error for an unexpected condition.

Arguments:

    dwError - Error code
    dsid - position of caller

Return Value:

    None

--*/

{
    DPRINT3(0,"Unhandled BACKUP error %d (0x%X) with DSID %X\n",
            dwError, dwError, dsid);

    LogEvent8(DS_EVENT_CAT_BACKUP,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_BACKUP_UNEXPECTED_WIN32_ERROR,
              szInsertWin32Msg(dwError),
              szInsertHex(dsid),
              szInsertWin32ErrCode(dwError),
              NULL, NULL, NULL, NULL, NULL );
} /* logUnhandledBackupError */


unsigned int
__stdcall
writerThread(
    PVOID StartupParam
    )

/*++

Routine Description:

    The dedicated thread in which the snapshot writer runs

Arguments:

    StartupParam - UNUSED

Return Value:

    unsigned int - thread exit status

--*/

{
    DWORD dwError = 0;

    __try
    {
        if (!DsaWaitUntilServiceIsRunning(EVENT_SERVICE))
        {
            // Normally, this WaitUntil function doesn't timeout. But because EventSystem
            // is a manual start service, the WaitUntil function eventually does timeout
            // if the service doesn't start.

            dwError = GetLastError();
            DPRINT1( 0, "Failed to wait for event service, error %d\n", dwError );
            // Don't log during setup
            if (!IsSetupRunning()) {
                LOG_UNHANDLED_BACKUP_ERROR( dwError );
            }
            __leave;
        }

        // This call will not return until shutdown
        dwError = DsSnapshotJetWriter();
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwError = GetExceptionCode();
        DPRINT1( 0, "Caught exception in writerThread 0x%x\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
    }

    return dwError;
} /* writerThread */


DWORD
DsSnapshotRegister(
    VOID
    )

/*++

Routine Description:

    Call to initialize the DS Jet Snapshot Writer.

    Called when the backup server dll is initialized.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError;

    DPRINT(1, "DsSnapshotRegister()\n" );

    // Create the server done event
    hServDoneEvent = CreateEvent( NULL, // default sd
                                  FALSE, // auto reset
                                  FALSE, // initial state, not set
                                  NULL // name, none
                                  );
    if (hServDoneEvent == NULL) {
        dwError = GetLastError();
        DPRINT1( 0, "CreateEvent failed with error %d\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        goto cleanup;
    }

    // Start snapshot thread
    hSnapshotJetWriterThread = (HANDLE)
        _beginthreadex(NULL,
                       0,
                       writerThread,
                       NULL,
                       0,
                       &tidSnapshotJetWriterThread);
    if (0 == hSnapshotJetWriterThread) {
        DPRINT1( 0, "Failed to create Snapshot Jet Writer thread, errno = %d\n", errno );
        LOG_UNHANDLED_BACKUP_ERROR( errno );
        dwError = ERROR_SERVICE_NO_THREAD;
        goto cleanup;
    }

    dwError = ERROR_SUCCESS;

 cleanup:

    // Cleanup on error
    if (dwError) {
        if (hServDoneEvent != NULL) {
            CloseHandle( hServDoneEvent );
            hServDoneEvent = NULL;
        }
        if (hSnapshotJetWriterThread != NULL) {
            CloseHandle( hSnapshotJetWriterThread );
            hSnapshotJetWriterThread = NULL;
        }
    }

    return dwError;
} /* DsSnapshotRegister */


DWORD
DsSnapshotShutdownTrigger(
    VOID
    )

/*++

Routine Description:

    Initiate the termination of the DS Jet Snapshot Writer

    Called when the backup server dll is terminated.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError;

    DPRINT(1, "DsSnapshotShutdownTrigger()\n" );

    // Check parameters
    if ( (hServDoneEvent == NULL) ||
         (hSnapshotJetWriterThread == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Set server done event
    if (!SetEvent( hServDoneEvent )) {
        dwError = GetLastError();
        DPRINT1( 0, "SetEvent failed with error %d\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        return dwError;
    }

    return ERROR_SUCCESS;
}


DWORD
DsSnapshotShutdownWait(
    VOID
    )

/*++

Routine Description:

    Wait for the DS Jet Snapshot Writer to exit

    Called when the backup server dll is terminated.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError, waitStatus;

    DPRINT(1, "DsSnapshotShutdownWait()\n" );

    // Check parameters
    if ( (hServDoneEvent == NULL) ||
         (hSnapshotJetWriterThread == NULL) ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Server done event should have already been set
    // If not, no big deal, we will timeout after a small delay

    // Wait a fixed length of time for thread to exit
    waitStatus = WaitForSingleObject(hSnapshotJetWriterThread,5*1000);
    if (waitStatus == WAIT_TIMEOUT) {
        DPRINT1( 0, "Snapshot Jet writer thread 0x%x did not exit promptly, timeout.\n",
                 hSnapshotJetWriterThread );
        dwError = ERROR_TIMEOUT;
        goto cleanup;
    } else if (waitStatus != WAIT_OBJECT_0 ) {
        dwError = GetLastError();
        DPRINT2(0, "Failure waiting for writer thread to exit, wait status=%d, error=%d\n",
                waitStatus, dwError);
        goto cleanup;
    }

    dwError = ERROR_BAD_THREADID_ADDR;
    GetExitCodeThread( hSnapshotJetWriterThread, &dwError );

    if (dwError == STILL_ACTIVE) {
        DPRINT( 0, "Snapshot Jet Writer thread did not exit\n" );
    } else if (dwError != ERROR_SUCCESS) {
        DPRINT1( 0, "Snapshot Jet Writer thread exited with non success code %d\n",
                 dwError );
    }

 cleanup:
    if (hServDoneEvent != NULL) {
        CloseHandle( hServDoneEvent );
        hServDoneEvent = NULL;
    }
    if (hSnapshotJetWriterThread != NULL) {
        CloseHandle( hSnapshotJetWriterThread );
        hSnapshotJetWriterThread = NULL;
    }
    return dwError;
} /* DsSnapshotShutdownWait */


DWORD
DsSnapshotJetWriter(
    VOID
    )

/*++

Routine Description:

    This function embodies the C++ environment of the DS JET WRITER thread.
    It constructs a writer instance, initializes COM, initializes the writer,
    hangs around until shutdown, then cleans up.
    This call does not return until the DSA is shutdown.

    Even though control returns from the writer->Initialize call, the thread
    must be kept available for the life of the writer. This is because the thread
    that called CoInitialize must be available in order for the writer to function.

Arguments:

    None.

Return Value:

    DWORD - Win32 error status

--*/

{
    DWORD dwRet = ERROR_SUCCESS;
    HRESULT hrStatus;
    BOOL fComInit = FALSE, fWriterInit = FALSE;
    CVssJetWriterLocal writer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pASD = NULL;
    PSID pOwner = NULL;
    PSID pGroup = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD cbASD, cbOwner, cbGroup, cbDacl, cbSacl;

    DPRINT( 1, "DsSnapshotJetWriter enter\n" );

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CoInitializeEx failed with HRESULT 0x%x\n", hrStatus );
        LOG_UNHANDLED_BACKUP_ERROR( hrStatus );
        dwRet = ERROR_DLL_INIT_FAILED;
        goto cleanup;
    }
    fComInit = TRUE;
    DPRINT(2, "CoInitializeEx() succeeded\n");

    // Basically this security descriptor gives LocalSystem ("SY" in 
    // SDDL), Backup Operators ("BO"), and Domain Administrators ("DA") 
    // the "COM Execute" ("CC") permission.
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
                    g_fBootedOffNTDS ? 
                        "O:SYG:SYD:(A;;CC;;;SY)(A;;CC;;;DA)(A;;CC;;;BO)" :  // Online Backup SD
                        "O:SYG:SYD:(A;;CC;;;SY)(A;;CC;;;BA)",               // Restore mode SD
                    SDDL_REVISION_1,
                    &pSD,
                    &cbASD)) 
    {
        dwRet = GetLastError();
        DPRINT1(0, "Error %d constructing a security descriptor\n", dwRet);
        Assert(dwRet != ERROR_NOT_ENOUGH_MEMORY && "We shouldn't hit this!");
        goto cleanup;
    }

    // Apparently, we need an absolute security descriptor, does 
    // ConvertStringSecurityDescriptorToSecurityDescriptor have a flag for that,
    // of course not.

    DPRINT(2, "ConvertStringSecurityDescriptorToSecurityDescriptor() successful.\n");

    // Call once to get our sizes.
    cbASD = cbOwner = cbGroup = cbDacl = cbSacl = 0;
    dwRet = MakeAbsoluteSD(pSD, NULL, &cbASD, NULL, &cbDacl, NULL, &cbSacl, NULL, &cbOwner, NULL, &cbGroup);
    if (dwRet == 0){ // failure is zero
        dwRet = GetLastError();
        if(dwRet != ERROR_INSUFFICIENT_BUFFER){
            DPRINT1(0, "Error %d getting buffer sizes for an absolute security descriptor\n", dwRet);
            Assert(!"MakeAbsoluteSD() shouldn't fail!");
            goto cleanup;
        }		
    }

    pASD = LocalAlloc(LMEM_FIXED, cbASD);
    pOwner = LocalAlloc(LMEM_FIXED, cbOwner);
    pGroup = LocalAlloc(LMEM_FIXED, cbGroup);
    pDacl = (PACL) LocalAlloc(LMEM_FIXED, cbDacl);
    pSacl = (PACL) LocalAlloc(LMEM_FIXED, cbSacl);
    if (!(pASD && pOwner && pGroup && pDacl && pSacl)){
        dwRet = GetLastError();
        DPRINT2(0, "Error %d allocating %d bytes\n", dwRet, cbASD + cbOwner + cbGroup + cbDacl + cbSacl);
        goto cleanup;
    }		

    // Now, call for real
    dwRet = MakeAbsoluteSD(pSD, pASD, &cbASD, pDacl, &cbDacl, pSacl, &cbSacl, pOwner, &cbOwner, pGroup, &cbGroup);
    if (dwRet == 0){ // failure is zero
        dwRet = GetLastError();
        DPRINT1(0, "Error %d creating an absolute security descriptor with MakeAbsoluteSD()\n", dwRet);
        Assert(!"MakeAbsoluteSD() shouldn't fail!");
        goto cleanup;
    }		

    DPRINT(2, "MakeAbsoluteSD() was successful.\n");

    hrStatus = CoInitializeSecurity (
        pASD,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
        -1,                                  //  IN LONG                         cAuthSvc,
        NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
        NULL,                                //  IN void                        *pReserved1,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,       //  IN DWORD                        dwAuthnLevel,
        RPC_C_IMP_LEVEL_IDENTIFY,            //  IN DWORD                        dwImpLevel,
        NULL,                                //  IN void                        *pAuthList,
        EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
        NULL                                 //  IN void                        *pReserved3
        );

    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CoInitializeSecurity failed with HRESULT 0x%x\n", hrStatus );
        LOG_UNHANDLED_BACKUP_ERROR( hrStatus );
        dwRet = ERROR_NO_SECURITY_ON_OBJECT;
        goto cleanup;
    }

    hrStatus = writer.Initialize(guuidWriter,		// id of writer
                                 L"NTDS",	// name of writer
                                 TRUE,		// system service
                                 TRUE,		// bootable state
                                 NULL,	// files to include
                                 NULL);	// files to exclude
    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CVssJetWriter Initialize failed with HRESULT 0x%x\n", hrStatus );
        LogEvent8(DS_EVENT_CAT_BACKUP,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_BACKUP_JET_WRITER_INIT_FAILURE,
                  szInsertWin32Msg(hrStatus),
                  szInsertHResultCode(hrStatus),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        dwRet = ERROR_FULL_BACKUP;
        goto cleanup;
    }
    fWriterInit = TRUE;

    // No Reason to leave these lying around in memory.
    if (pSD)    { LocalFree(pSD); pSD = NULL; }
    if (pASD)   { LocalFree(pASD); pASD = NULL; }
    if (pOwner) { LocalFree(pOwner); pOwner = NULL; }
    if (pGroup) { LocalFree(pGroup); pGroup = NULL; }
    if (pDacl)  { LocalFree(pDacl); pDacl = NULL; }
    if (pSacl)  { LocalFree(pSacl); pSacl = NULL; }

    DPRINT( 1, "cVssJetWriter successfully initialized.\n" );

    // Wait for shutdown
    WaitForSingleObject(hServDoneEvent, INFINITE);

 cleanup:
    if (pSD)    { LocalFree(pSD); }
    if (pASD)   { LocalFree(pASD); }
    if (pOwner) { LocalFree(pOwner); }
    if (pGroup) { LocalFree(pGroup); }
    if (pDacl)  { LocalFree(pDacl); }
    if (pSacl)  { LocalFree(pSacl); }
    
    if (fWriterInit) {
        writer.Uninitialize();
    }

    if (fComInit) {
        CoUninitialize();
    }

    DPRINT1( 1, "DsSnapshotJetWriter exit, dwRet = 0x%x\n", dwRet );

    return dwRet;
} /* DsSnapshotJetWriter */




/******************************************************************
 *
 *    Backup Functions
 *
 ******************************************************************/




bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnIdentify(
    IVssCreateWriterMetadata *pMeta
    )
/*++

Routine Description:

    Method to set our on meta data so that when we're restored, we're restored
    in place.  If we ever want to be able to restore while a DC is online, we'll
    need to take this SetRestoreMethod() out.  Perhaps ADAM will want to be able
    to restore online, then it could leverage this.  
    
    The reason we're doing this is in win2k and the expectation will be in .NET 
    that right after you restore in DS Restore Mode, you can run ntdsutil to do
    an authoritative restore on the restored JET DB.  We've decided to disable
    online restore in favor of allowing a consistent (with the win2k experience) 
    and expected experience for the user.

Arguments:

    pMeta - Writer Meta Data to set.

Return Value:

    STDMETHODCALLTYPE - 

--*/
{
    bool bRet;
    HRESULT hr;

    // In case the normal Jet writer does initialization above and beyond our
    // measly initialization.
    bRet = CVssJetWriter::OnIdentify(pMeta);
        
    if (!g_fAllowOnlineSnapshotRestore) {
        hr = pMeta->SetRestoreMethod(VSS_RME_RESTORE_IF_CAN_REPLACE,
                                     NULL, NULL, VSS_WRE_ALWAYS, TRUE);
        if (FAILED(hr)) {
            return(false);
        }
    }

    return(bRet); // success
}


bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareBackupBegin(
    IN IVssWriterComponents *pWriterComponents
    )

/*++

Routine Description:

    Method called at the start of the backup preparation phase

Arguments:

    pWriterComponents - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    DPRINT1( 1, "OnPrepareBackupBegin(%p)\n", pWriterComponents );

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        return true;
    }

    // If not running as NTDS, do not allow backup
    if (!g_fBootedOffNTDS){
        // Not online, no backup
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_NO_NTDS_NO_BACKUP,
                 NULL, NULL, NULL );
        return false;
    }

    return true;
} /* CVssJetWriterLocal::OnPrepareBackupBegin */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareBackupEnd(
    IN IVssWriterComponents *pWriterComponents,
    IN bool fJetPrepareSucceeded
    )

/*++

Routine Description:

    Method called at the end of the backup preparation phase
    We use this opportunity to calculate the backup metadata, which is any
    string data we want to associate with the backup. We store the backup
    expiration time presently.

    The backup metadata takes this form:

    keyword=value[;keyword=value]...

    Note that the parser is simple and does not tolerate whitespace before or after
    the equal or semicolon.

Arguments:

    pWriterComponents - Component being backed up

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    HRESULT hr;
    DWORD dwErr;
    UINT cComponents;
    IVssComponent *pComponent = NULL;
    bool fSuccess;
    WCHAR wszBuffer[128];
    DSTIME dstime;
    DWORD days;

    // If the prepare phase did not succeed, don't do anything
    if (!fJetPrepareSucceeded) {
        DPRINT(0,"DS Snapshot backup prepare failed.");
        return true;
    } 

    DPRINT2(1, "OnPrepareBackupEnd(%p,%d)\n",
            pWriterComponents,fJetPrepareSucceeded);

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        return false;
    }

    // Calculate expiration time of backup
    dstime = GetSecondsSince1601();

    days = getTombstoneLifetimeInDays();

    dstime += (days * 24 * 60 * 60);

    hr = StringCbPrintfW(wszBuffer, sizeof(wszBuffer),
                         L"%ws=%I64d;%ws=Y", EXPIRATION_TIME_KEYWORD, dstime, WRITERLESS_RESTORE );
    Assert(hr == 0);
    if (hr) {
        return false;
    }

    // Get the 1 database component

    __try {
        hr = pWriterComponents->GetComponentCount( &cComponents );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        if (cComponents == 0) {
            // WORKAROUND - TOLERATE BACKUP WITHOUT A COMPONENT
            // We do this because conventional ntbackup creates a snapshot
            // but never uses it. Without this check we would generate errors
            // during regular backups.
            DPRINT( 0, "Warning: AD snapshot backup expiration not recorded.\n" );
            // KEEP GOING
            fSuccess = true;
            __leave;
        }

        hr = pWriterComponents->GetComponent( 0, &pComponent );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        // Set the backup metadata for the component

        hr = pComponent->SetBackupMetadata( wszBuffer );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        DPRINT1( 1, "Wrote backup metadata: %ws\n", wszBuffer );

        fSuccess = true;

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        DWORD dwError = GetExceptionCode();
        DPRINT1( 0, "Caught exception in OnPrepareBackupEnd 0x%x\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        fSuccess = false;
    }

    if (pComponent) {
        pComponent->Release();
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPrepareBackupEnd */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareSnapshotBegin(
    void
    )
/*++

Routine Description:

    This is called _right_ before the snapshot takes place.  This is the last chance 
    to prepare the backup DIT to be a backedup DIT.  The other thing, is we're 
    guaranteed a Thaw or Abort after this point.

Arguments:

    void

Return Value:

    STDMETHODCALLTYPE - 

--*/
{
    DSTIME dstime;
    DWORD days;
    DWORD dwErr;

    // Calculate expiration time of backup
    dstime = GetSecondsSince1601();

    days = getTombstoneLifetimeInDays();

    dstime += (days * 24 * 60 * 60);

    dwErr = DBDsReplBackupSnapshotPrepare(dstime);
    if (dwErr) {  
        // Logged event in DBDsRepl...
        DPRINT1(0, "DBDsReplBackupPrepare() failed 0x%x\n", dwErr);
        return(false);
    }

    return(true);
}

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareSnapshotEnd(
    void
    )
/*++

Routine Description:

    This is called _right_ before the snapshot takes place.  This is the last chance 
    to prepare the backup DIT to be a backedup DIT.  The other thing, is we're 
    guaranteed a Thaw or Abort after this point.

Arguments:

    void

Return Value:

    STDMETHODCALLTYPE - 

--*/
{
    return(true);
}


bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnBackupCompleteEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Method called when the backup completes, successfully or not

Arguments:

    pWriter - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    DWORD dwEvent;

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        // keep going
    }

    if (!bRestoreSucceeded) {
        DPRINT(0,"DS Snapshot Backup failed.\n");
        dwEvent = DIRLOG_BACKUP_SNAPSHOT_FAILURE;
    } else {
        DPRINT(0,"DS Snapshot Backup succeeded.\n");
        dwEvent = DIRLOG_BACKUP_SNAPSHOT_SUCCESS;
    }
    LogEvent(DS_EVENT_CAT_BACKUP,
             DS_EVENT_SEV_ALWAYS,
             dwEvent,
             NULL, NULL, NULL );

    return true;
} /* CVssJetWriterLocal::OnBackupCompleteEnd */

void
SnapshotBackupEndCommon(void)
/*++

Routine Description:

    This routine just does the common things that we'd want to do in
    both VSSXxxx:OnThaw() and VSSXxxx:OnAbort().
    
    Basically, we call into a ntdsa.dll export to fix the DB to not
    be in the "eBackedupDit" state, and erase the DB expiration time.
    
    An error will mean that this DC will think it's been restored 
    after reboot, and will change it's Invocation ID and flush it's
    RID pool.  Unfortunately there isn't much we can do about this,
    except for maybe retry?  However, performing a restore on reboot
    isn't the end of the world, and errors in this DB function are
    extremely unlikely, as the DB table used for this operation is
    very infrequently used.  So we accept the possibility of an
    error, because we also have the possibility of this condition
    if we crash before we get a chance to clean up our backup state.

Arguments:

    none.

Return Value:

    none.

--*/
{
    DWORD  dwRet;

    dwRet = DBDsReplBackupSnapshotEnd();

    if (dwRet) {
        // Event logged in DBDsRepl...
        DPRINT2(0,"DBDsReplBackupSnapshotEnd %d (0x%X)\n", dwRet, dwRet);
    }

}

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnThawEnd(
    bool bJetSuccessfulThaw
    )
/*++

Routine Description:

    After we get a OnBackupPrepareEnd() we are guaranteed to get a "thaw"
    or "abort".  This is the cleanup actions we take at that time.  Note:
    this isn't the real OnThaw

Arguments:

    bJetSuccessfulThaw - 

Return Value:

    STDMETHODCALLTYPE - 

--*/
{
    // This probably won't succeed if bJetSuccessfulThaw is false, because
    // JET failed to Thaw(), but we'll try anyway.
    SnapshotBackupEndCommon();

    return(true); // success
}
    
void
STDMETHODCALLTYPE
CVssJetWriterLocal::OnAbortEnd(void)
/*++

Routine Description:

    After we get a OnBackupPrepareEnd() we are guaranteed to get a "thaw"
    or "abort".  This is the cleanup actions we take at that time.

Arguments:

    none

Return Value:

    STDMETHODCALLTYPE - 

--*/
{
    SnapshotBackupEndCommon();

}



/******************************************************************
 *
 *    Restore Functions
 *
 ******************************************************************/



bool
getComponent(
    IVssWriterComponents *pWriterComponents,
    IVssComponent **ppComponent
    )

/*++

Routine Description:

    Description

Arguments:

    pWriterComponents - 
    ppComponent - 

Return Value:

    bool - 

--*/

{
    HRESULT hr;
    UINT cComponents;
    bool fSuccess = false;

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        goto cleanup;
    }

    // Get the 1st database component
    hr = pWriterComponents->GetComponentCount( &cComponents );
    if (!SUCCEEDED(hr)) {
        LOG_UNHANDLED_BACKUP_ERROR( hr );
        goto cleanup;
    }

    // Must have at least one component
    if (cComponents == 0) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        goto cleanup;
    }
    Assert(cComponents == 1); // should have only one component.

    hr = pWriterComponents->GetComponent( 0, ppComponent );
    if (!SUCCEEDED(hr)) {
        LOG_UNHANDLED_BACKUP_ERROR( hr );
        goto cleanup;
    }

    fSuccess = true;

 cleanup:

    return fSuccess;
} /* getComponent */



BOOL
processBackupMetadata(
    BSTR bstrBackupMetadata
    )

/*++

Routine Description:

    Apply the backup metadata, if any

Arguments:

    bstrBackupMetadata - 

Return Value:

    BOOL - Whether we should allow the restore to continue

--*/

{
    LONGLONG dstimeCurrent, dstimeExpiration;
    LPWSTR pszOptions, pszEqual;
    BOOL fIsWriterlessRestoreCapable = FALSE;

    if (bstrBackupMetadata == NULL) {
        DPRINT( 0, "No backup metadata found.\n" );
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_FILE_NOT_FOUND );
        return false;
    }

    DPRINT1( 0, "Read backup metadata: %ws\n", bstrBackupMetadata );

    // Parse the metadata
    // Note that for backward compatibility with older backups, we must continue to support
    // keywords from older versions, or atleast ignore them. Similarly, to provide some
    // tolerance for future versions, we ignore keywords we do not recognize without
    // generating an error.

    dstimeCurrent = GetSecondsSince1601();

    pszOptions = bstrBackupMetadata;
    dstimeExpiration = 0;
    while (1) {
        pszEqual = wcschr( pszOptions, L'=' );
        if (!pszEqual) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
            break;
        }
        if ( (((DWORD) (pszEqual - pszOptions)) == EXPIRATION_TIME_LENGTH) &&
             (wcsncmp( pszOptions, EXPIRATION_TIME_KEYWORD, EXPIRATION_TIME_LENGTH ) == 0) ) {
            if (swscanf( pszEqual + 1, L"%I64d", &dstimeExpiration ) == 1) {

                // Validate expiration here
                if (dstimeExpiration < dstimeCurrent) {
                    CHAR buf1[SZDSTIME_LEN + 1];
                    DPRINT( 0, "Can't restore AD snapshot because it is expired\n" );
                    LogEvent(DS_EVENT_CAT_BACKUP,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_BACKUP_SNAPSHOT_TOO_OLD,
                             szInsertDSTIME( dstimeExpiration, buf1 ),
                             NULL, NULL );
                    return false;
                }
            }
        } else if ((((DWORD) (pszEqual - pszOptions)) == WRITERLESS_RESTORE_LENGTH) &&
             (wcsncmp( pszOptions, WRITERLESS_RESTORE, WRITERLESS_RESTORE_LENGTH ) == 0)) {
            fIsWriterlessRestoreCapable = TRUE;
        }
        pszOptions = wcschr( pszOptions, L';' );
        if (!pszOptions) {
            break;
        }
        pszOptions++;
    }

    if (!fIsWriterlessRestoreCapable) {
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRMSG_INSTALL_BACKUP_FROM_OLD_BUILD,
                 NULL, NULL, NULL );
        return false;
    }

    return true;
} /* processBackupMetadata */


bool
isRestoreToAlternateLocation(
    IVssComponent *pComponent,
    bool *pfAlternate
    )

/*++

Routine Description:

    Test whether the component is marked for restore to an alternate location

Arguments:

    pComponent - 
    pfAlternate - is alternate or not

Return Value:

    bool - A determination was found, or error

--*/

{
    HRESULT hr;
    bool fSuccess = false;
    UINT cNewTarget = 0;

    // How many new targets
    hr = pComponent->GetNewTargetCount( &cNewTarget );
    if (!SUCCEEDED(hr)) {
        LOG_UNHANDLED_BACKUP_ERROR( hr );
        goto cleanup;
    }

    fSuccess = true;
    *pfAlternate = cNewTarget > 0;

 cleanup:

    return fSuccess;
} /* isRestoreToAlternateLocation */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPreRestoreBegin(
    IVssWriterComponents *pWriterComponents
    )

/*++

Routine Description:

    Method called before the restore begins, at the start of the "pre-restore" phase.
    We take this opportunity to read the backup metadata.
    We validate that the backup is still good.

Arguments:

    pComponents - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    HRESULT hr;
    IVssComponent *pComponent = NULL;
    bool fSuccess = false, fAlternate;
    BSTR bstrBackupMetadata = NULL;

    DPRINT1(0, "OnPreRestoreBegin(%p)\n", pWriterComponents );

    __try {
        if (!getComponent( pWriterComponents, &pComponent )) {
            __leave;
        }

        // Read the metadata
        hr = pComponent->GetBackupMetadata( &bstrBackupMetadata );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            __leave;
        }

        // First do the metadata checks
        // We want to do this regardless of restore target
        if (!processBackupMetadata( bstrBackupMetadata )) {
            // Error already logged
            __leave;
        }

        // If this is a restore to alternate location, we are done
        if (!isRestoreToAlternateLocation( pComponent, &fAlternate )) {
            __leave;
        }
        if (fAlternate) {
            fSuccess = true;
            __leave;
        }

        // If doing a conventional restore, ie not doing a alternate restore,
        // do not allow to have NTDS online.
        if (g_fBootedOffNTDS && !g_fAllowOnlineSnapshotRestore){
            // Not offline, no restore
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                     NULL, NULL, NULL );
            __leave;
        }

        fSuccess = true;
    } __finally {
        // Cleanup processing for function

        if (AbnormalTermination()) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_EXCEPTION_IN_SERVICE );
        }

        if (bstrBackupMetadata) {
            SysFreeString( bstrBackupMetadata );
        }

        if (pComponent) {
            pComponent->Release();
        }
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPreRestoreBegin */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPreRestoreEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Called at the end of pre-restore phase. The data on disk has not been changed yet.

    We set the following registry key to indicate a restore is in progress.

    DSA_CONFIG_SECTION \ RESTORE_STATUS - Restore is in progress key

    We rely on the fact that RecoverAfterRestore will check for this key and abort if it
    is present. Note that although snapshot restore does not require RecoverAfterRestore
    functionality for restore reasons, we do depend on it being called in order to
    check the restore status key.

Arguments:

    pWriterComponents - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    IVssComponent *pComponent = NULL;
    bool fSuccess = false, fAlternate;
    HRESULT hr;
    DWORD dwWin32Status;
    HKEY hkeyDs = NULL;

    DPRINT2(0, "OnPreRestoreEnd(%p,%d)\n", pWriterComponents, bRestoreSucceeded);

    __try {
        // Pre-restore failed, we are done
        if (!bRestoreSucceeded) {
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_SNAPSHOT_PRERESTORE_FAILURE,
                     NULL, NULL, NULL );
            __leave;
        }

        if (!getComponent( pWriterComponents, &pComponent )) {
            Assert( !"should have been caught earlier" );
            __leave;
        }

        // If this is a restore to alternate location, we are done
        if (!isRestoreToAlternateLocation( pComponent, &fAlternate )) {
            __leave;
        }
        if (fAlternate) {
            fSuccess = true;
            __leave;
        }

        // If doing a conventional restore, ie not doing a alternate restore,
        // do not allow to have NTDS online.
        if (g_fBootedOffNTDS && !g_fAllowOnlineSnapshotRestore){
            // Not offline, no restore
            Assert( !"should have been caught earlier" );
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                     NULL, NULL, NULL );
            __leave;
        }

        // Indicate a restore is in progress
        // See similar logic in HrLocalRestoreRegister

        dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        } else {
            hr = hrRestoreInProgress;

            dwWin32Status = RegSetValueExW(hkeyDs, RESTORE_STATUS, 0, REG_DWORD, (LPBYTE)&hr, sizeof(HRESULT));
            if (dwWin32Status != ERROR_SUCCESS) {
                LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
            }
        }

        fSuccess = (dwWin32Status == ERROR_SUCCESS) ? true : false;
    } __finally {
        // Cleanup processing for function
        if (AbnormalTermination()) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_EXCEPTION_IN_SERVICE );
        }

        if (pComponent) {
            pComponent->Release();
        }

        if (hkeyDs) {
            RegCloseKey(hkeyDs);
        }
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPreRestoreEnd */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPostRestoreEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Called at the end of post-restore phase. The data on disk has been changed.
    This routine may not be called on some error scenarios.

    On success, set up the registry keys that let the DS know that we have been
    restored.

    They are:

    DSA_CONFIG_SECTION \ DSA_RESTORED_DB_KEY - if present, we were restored
    DSA_CONFIG_SECTION \ RESTORE_NEW_DB_GUID - new invocation id to use

Arguments:

    pWriterComponents - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    IVssComponent *pComponent = NULL;
    bool fSuccess = false, fAlternate;
    DWORD dwWin32Status;
    HRESULT hr;
    HKEY hkeyDs = NULL;

    DPRINT2(0, "OnPostRestoreEnd(%p,%d)\n", pWriterComponents,bRestoreSucceeded);

    __try {
        if (!getComponent( pWriterComponents, &pComponent )) {
            Assert( !"should have been caught earlier" );
            __leave;
        }

        // If this is a restore to alternate location, we are done
        if (!isRestoreToAlternateLocation( pComponent, &fAlternate )) {
            __leave;
        }
        if (fAlternate) {
            fSuccess = true;
            __leave;
        }

        // If doing a conventional restore, ie not doing a alternate restore,
        //do not allow to have NTDS online.
        if (g_fBootedOffNTDS && !g_fAllowOnlineSnapshotRestore){
            // Not offline, no restore
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                     NULL, NULL, NULL );
            __leave;
        }

        //
        // Handle restore failure
        //

        if (!bRestoreSucceeded) {
            DPRINT(0,"DS Snapshot Restore failed.\n");

            dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
            if (dwWin32Status != ERROR_SUCCESS) {
                LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
            } else {

                // Make sure restored key is not present
                dwWin32Status = RegDeleteValue(hkeyDs, DSA_RESTORED_DB_KEY);
                // May fail if key not present

                // Update restore status with error indication
                hr = hrError;
                dwWin32Status = RegSetValueExW(hkeyDs, RESTORE_STATUS, 0, REG_DWORD, (BYTE *)&hr, sizeof(HRESULT));
            }

            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_SNAPSHOT_RESTORE_FAILURE,
                     NULL, NULL, NULL );

            __leave;
        }

        //
        // Handle restore success
        //

        // Clear the RESTORE_STATUS key
        dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        } else {
            // Make sure restored key is not present
            dwWin32Status = RegDeleteValueW(hkeyDs, RESTORE_STATUS);
            if (dwWin32Status != ERROR_SUCCESS) {
                LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
            }
        }

        if (dwWin32Status == ERROR_SUCCESS) {
            DPRINT(0,"DS Snapshot Restore was successful.\n");
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_SNAPSHOT_RESTORE_SUCCESS,
                     NULL, NULL, NULL );
        }

        fSuccess = (dwWin32Status == ERROR_SUCCESS) ? true : false;
    } __finally {
        // Cleanup processing for function
        if (AbnormalTermination()) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_EXCEPTION_IN_SERVICE );
        }

        if (pComponent) {
            pComponent->Release();
        }

        if (hkeyDs) {
            RegCloseKey(hkeyDs);
        }
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPreRestoreEnd */

/* end snapshot.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetback\jetback.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetback.c
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetback.c

Abstract:

    This module is the server side header file for the NTDS backup APIs.


Author:

    Larry Osterman (larryo) 19-Aug-1994
    R.S. Raghavan  (rsraghav) 03/24/97 Modified to use with backing up NTDS.


Revision History:

Note:
    Exchange backup is performed via 3 mechanisms:
        The first is a straightforward extension of the JET backup APIs.
        The second uses a private socket based mechanism for performance.
        The third is used when loopbacked - we read and write to a shared memory section.


--*/

#define UNICODE

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <jetbak.h>
#include <rpc.h>
#include <stdlib.h>

#include <debug.h>              // standard debugging header
#define DEBSUB "JETBACK:"       // define the subsystem for debugging

#include <dsconfig.h>

#include <ntdsa.h>
#include <dsevent.h>

#include <fileno.h>
#define FILENO   FILENO_JETBACK_JETBACK

#include <strsafe.h>

#include <overflow.h>

BOOL
fBackupRegistered = fFalse;

BOOL
g_fAllowRemoteOp = fFalse;

BOOL
g_fAllowOnlineSnapshotRestore = fFalse;

WCHAR
rgchComputerName[MAX_COMPUTERNAME_LENGTH+1];

// 
// Global flag that tells if the System is booted off the DS
//
BOOL g_fBootedOffNTDS = FALSE;

extern BOOL fRestoreInProgress;

// proto-types
EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    );


HRESULT
HrFromJetErr(
    JET_ERR jetError
    )
{
    HRESULT hr = 0;

    if (jetError == JET_errSuccess)
    {
        return(hrNone);
    }

    //
    //  Set the error code.
    //

    if (jetError < 0)
    {
        hr = (STATUS_SEVERITY_ERROR << 30) | (FACILITY_NTDSB << 16) | -jetError;
    }
    else
    {
        hr = (STATUS_SEVERITY_WARNING << 30) | (FACILITY_NTDSB << 16) | jetError;
    }

    DebugTrace(("HrFromJetErr: %d maps to 0x%x\n", jetError, hr));

    return(hr);
}


//
//  JET backup server side interface.
//

void SetNTDSOnlineStatus(BOOL fBootedOffNTDS)
{
    g_fBootedOffNTDS = fBootedOffNTDS;
}

/*
 -  HrBackupRegister
 -
 *  Purpose:
 *      This routine to register a process for backup.  It is called by either the store or DS.
 *
 *  Parameters:
 *
 *      puuidService - an Object UUID for the service.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
HrBackupRegister()
{
    HRESULT hr;

    Assert(!fBackupRegistered);

    hr = RegisterRpcInterface(JetBack_ServerIfHandle, g_wszBackupAnnotation);
    if (hrNone == hr) {
        fBackupRegistered = fTrue;
    }

    return(hr);
}

/*
 -  HrBackupUnregister
 -
 *  Purpose:
 *
 *      This routine will unregister a process for backup.  It is called by either the store or DS.
 *
 *  Parameters:
 *      None.
 *
 *  Return Value:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
HrBackupUnregister()
{
    HRESULT hr = hrNone;

    hr = UnregisterRpcInterface(JetBack_ServerIfHandle);
    if (hrNone == hr) {
        fBackupRegistered = FALSE;
    }

    return(hr);
}


/*
 -  MIDL_user_allocate
 -
 *  Purpose:
 *      Allocates memory for RPC operations.
 *
 *  Parameters:
 *      cbBytes - # of bytes to allocate
 *
 *  Returns:
 *      Memory allocated, or NULL if not enough memory.
 */

void *
MIDL_user_allocate(
    size_t cbBytes
    )
{
    return(LocalAlloc(LMEM_ZEROINIT, cbBytes));
}


/*
 -  MIDL_user_free
 -
 *  Purpose:
 *      Frees memory allocated via MIDL_user_allocate.
 *
 *  Parameters:
 *      pvBuffer - The buffer to free.
 *
 *  Returns:
 *      None.
 */
void
MIDL_user_free(
    void *pvBuffer
    )
{
    LocalFree(pvBuffer);
}




//
//
//  The actual JET backup APIs.
//



HRESULT
HrRBackupPrepare(
    handle_t hBinding,
    unsigned long grbit,
    unsigned long btBackupType,
    WSZ wszBackupAnnotation,
    DWORD dwClientIdentifier,
    CXH *pcxh
    )
/*++

Routine Description:

    This routine is called to notify JET that a backup is in progress.  It will also allocate
    and initialize the server side RPC binding context

Arguments:
    hBinding - the initial binding handle.  Ignored by this routine, and not needed from now on.
    pcxh - Pointer to a context handle for this client.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrNone;
    DWORD dwRet;
    PJETBACK_SERVER_CONTEXT pjsc;
    unsigned long cInstance;
    JET_INSTANCE_INFO* rgInstanceInfo;
    unsigned long iInstance;
    ULONG cbAnnotation;
    
#if DBG
    if (!FInitializeTraceLog())
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
#endif
    
    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(("HrrBackupPrepare.\n", hr));
    //
    //  Check to make sure that the client can perform the backup.
    //

    if (hr = HrValidateInitialBackupSecurity()) {
        DebugTrace(("HrrBackupPrepare: Returns ACCESS_DENIED"));
        return(hr);
    }

    // 
    //  Allow the replication protocol to prepare for the backup.
    //
    dwRet = DBDsReplBackupLegacyPrepare();
    if (dwRet) {
        DebugTrace(("HrRBackupPrepare:  DS repl is unable to prepare for a backup 0x%x", dwRet)); 
        return(HRESULT_FROM_WIN32(dwRet)); 
    }

    switch (btBackupType)
    {
    case BACKUP_TYPE_FULL:

        //
        //  When we come in for a full backup, we want to reset our current max
        //  log number.
        //

        HrSetCurrentLogNumber(g_wszRestoreAnnotation, 0); 
        // NOTE: We use restore annotation because that's what the old RPC 
        // DsSetCurrentBackupLog(rgchComputerName, 0); that used to be called
        // here was using.  Didn't want to change the context of this call at all.
        DebugTrace(("HrSetCurrentBackupLog (%S, 0) returns %d", rgchComputerName, hr));
        break;
    case BACKUP_TYPE_LOGS_ONLY:
        //
        //  When we come in for an incremental or differential backup, we want
        //  to check to make sure that the right logs are there.
        //

        // Disabled this case
        //
        // We don't support these kind of backups in the AD, but the only way 
        // we do that is through documentation, so lets fully support our decision 
        // to not support incremental/differntial backups!  We can't do this kind
        // of backup (at least by default), because the AD uses JET with circular
        // logging.
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        //
        HrRestoreCheckLogsForBackup(g_wszBackupAnnotation);
        // NOTE: This one actually uses the backup annotation ... hmm how odd.
        DebugTrace(("I_DsCheckBackupLogs (%S) returns %d", g_wszBackupAnnotation, hr));
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (hr != hrNone)
    {
        DebugTrace(("Failing HrBackupPrepare with %d", hr));
        return hr;
    }
    pjsc = MIDL_user_allocate(sizeof(JETBACK_SERVER_CONTEXT));

    if (pjsc == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    cbAnnotation = (wcslen(wszBackupAnnotation)+1)*sizeof(WCHAR);
    pjsc->u.Backup.wszBackupAnnotation = MIDL_user_allocate(cbAnnotation);

    if (pjsc->u.Backup.wszBackupAnnotation == NULL)
    {
        MIDL_user_free(pjsc);
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    hr = StringCbCopy(pjsc->u.Backup.wszBackupAnnotation, cbAnnotation, wszBackupAnnotation);
    if (hr) {
        Assert(!"NOT ENOUGH BUFFER");
        MIDL_user_free(pjsc);
        return(hr);
    }

    //
    //  Get the NTDSA instance ID for this process
    //

    hr = HrFromJetErr(JetGetInstanceInfo(&cInstance, &rgInstanceInfo));

    if (hr == hrNone)
    {
        for (iInstance = 0; iInstance < cInstance; iInstance++)
        {
            if (!_stricmp(rgInstanceInfo[iInstance].szInstanceName, "NTDSA"))
            {   
                pjsc->u.Backup.instance = rgInstanceInfo[iInstance].hInstanceId;
                break;
            }
        }
        JetFreeBuffer((void*)rgInstanceInfo);
    }
    else
    {
        DebugTrace(("JetGetInstanceInfo failed with 0x%x", hr));
        MIDL_user_free(pjsc);
        return(hr);
    }

    //
    //  Remember the PID of the client.  We'll use this later to set up our shared memory
    //  segment.
    //

    pjsc->u.Backup.dwClientIdentifier = dwClientIdentifier;

    pjsc->fRestoreOperation = fFalse;

    pjsc->u.Backup.fHandleIsValid = fFalse;

    pjsc->u.Backup.sockClient = INVALID_SOCKET;

    pjsc->u.Backup.awszAllowedFiles = NULL;

    *pcxh = (CXH)pjsc;

    //
    //  Now tell Jet that this guy is starting a backup process.
    //

    pjsc->u.Backup.fBackupIsRegistered = fFalse;

    hr = HrFromJetErr(JetBeginExternalBackupInstance(pjsc->u.Backup.instance, grbit));

    if (hr == hrNone)
    {
        pjsc->u.Backup.fBackupIsRegistered = fTrue;
    }
    else
    {
        DebugTrace(("JetBeginExternalBackupInstance failed with 0x%x", hr));
        MIDL_user_free(pjsc->u.Backup.wszBackupAnnotation);
        pjsc->u.Backup.wszBackupAnnotation = NULL;
        MIDL_user_free(pjsc);
        *pcxh = NULL;
    }

    DebugTrace(("HrrBackupPrepare returns 0x%x", hr));
    return(hr);
}


HRESULT
HrRBackupTruncateLogs(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called to notify JET that the backup is complete.
    It should only be called when the backup has successfully completed.

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrError;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    hr = HrFromJetErr(JetTruncateLogInstance(pjsc->u.Backup.instance));

    return(hr);
}

HRESULT
AddAllowedFilesToContextHandle(
    PJETBACK_SERVER_CONTEXT     pjsc,
    WCHAR *                     wszFileList
    )
/*++

Routine Description:

    This routine a list of files that are packed into one gigantic buffer, with
    a double NULL to signify the end of the list of files.

Arguments:
    pjsc - the server side context handle for this operation.
    wszFileList - NULL terminates list of NULL terminated strings, packed into
        one buffer.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/

{
    ULONG     cFiles, iFile, cOldFiles, cbLen;
    WCHAR **  awszTemp = NULL;
    WCHAR *   wszT;
    HRESULT   hr;

    Assert(!pjsc->fRestoreOperation);

    // First count the files.
    cFiles = 0;
    wszT = wszFileList;
    while (*wszT){
        cFiles++;
        // Increment to next file path
        wszT += wcslen(wszT)+1;
    }
    Assert(cFiles);

    cOldFiles = 0;
    if (pjsc->u.Backup.awszAllowedFiles) {
        // We already have some files, so count those first
        for(cOldFiles = 0; pjsc->u.Backup.awszAllowedFiles[cOldFiles]; cOldFiles++){
            ; // Do nothing, just counting.
        }
        cFiles += cOldFiles; 
    }
     
    awszTemp = MIDL_user_allocate( (cFiles+1) * sizeof(WCHAR *));
    // Note: this zero mems the list, so the list will be a NULL terminated list of files
    // thats why we allocate cFiles+1.
    if (awszTemp == NULL) {
        return(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_SERVER_MEMORY));
    }
    if (pjsc->u.Backup.awszAllowedFiles) {
        // Copy over old files if there were any
        memcpy(awszTemp, pjsc->u.Backup.awszAllowedFiles, sizeof(WCHAR*) * cOldFiles);
        MIDL_user_free(pjsc->u.Backup.awszAllowedFiles);
    }
    pjsc->u.Backup.awszAllowedFiles = awszTemp;

    Assert( cOldFiles == 0 ||
            (pjsc->u.Backup.awszAllowedFiles[cOldFiles-1] != NULL && 
             pjsc->u.Backup.awszAllowedFiles[cOldFiles] == NULL) );

    // Finally copy in the old files
    iFile = cOldFiles;
    wszT = wszFileList;
    while (*wszT){
        cbLen = sizeof(WCHAR) * (wcslen(wszT)+1);
        pjsc->u.Backup.awszAllowedFiles[iFile] = MIDL_user_allocate(cbLen);
        if (pjsc->u.Backup.awszAllowedFiles[iFile] == NULL) {
            return(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_SERVER_MEMORY));
        }

        // Add file path to buffer.
        hr = StringCbCopy(pjsc->u.Backup.awszAllowedFiles[iFile], cbLen, wszT);
        if (hr) {
            return(hr);
        }

        Assert(iFile < cFiles);
        // Increment to next file path
        wszT += wcslen(wszT)+1;
        // Increment to next file slot
        iFile++;
    }

    if (pjsc->u.Backup.awszAllowedFiles) {
        for(iFile = 0; pjsc->u.Backup.awszAllowedFiles[iFile]; iFile++){
            DebugTrace(("  Allowed File [%d]: %ws", iFile, pjsc->u.Backup.awszAllowedFiles[iFile]));
        }
    }

    return(hrNone);
}

HRESULT
HrRBackupGetBackupLogs(
    CXH cxh,
    CB *pcbSize,
    char **pszBackupLogs
    )
/*++

Routine Description:

    This routine is called to return the list of log files for the current database.

Arguments:
    cxh - the server side context handle for this operation.
    pszBackupLogs - the name of the file to open.
    pcbSize - The size of the attachment, in bytes.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrError;
    SZ szJetBackupLogs;
    unsigned long cbJetSize;
    unsigned long cbOldJetSize;
    WSZ wszBackupLogs;
    CB cbBackupLogs;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    //
    //  Figure out how much storage is needed to hold the logs.
    //

    hr = HrFromJetErr(JetGetLogInfoInstance(pjsc->u.Backup.instance, NULL, 0, &cbJetSize));

    if (hr != hrNone)
    {
        return(hr);
    }
    do
    {
        szJetBackupLogs = MIDL_user_allocate(cbJetSize);

        if (szJetBackupLogs == NULL)
        {
            return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        }

        //
        //  Now actually retrieve the logs.
        //

        cbOldJetSize = cbJetSize;

        hr = HrFromJetErr(JetGetLogInfoInstance(pjsc->u.Backup.instance, szJetBackupLogs, cbJetSize, &cbJetSize));

        if (hr != hrNone)
        {
            MIDL_user_free(szJetBackupLogs);
            return(hr);
        }

        if (cbJetSize != cbOldJetSize)
        {
            MIDL_user_free(szJetBackupLogs);
        }

    } while ( cbOldJetSize != cbJetSize  );

    //
    //  Now convert the log name from JET to a uniform name that
    //  can be accessed from the client.
    //

    hr = HrMungedFileNamesFromJetFileNames(&wszBackupLogs, &cbBackupLogs, szJetBackupLogs, cbJetSize, fFalse);

    //
    //  Ok, we're not quite done yet.
    //
    //  Now we need to annotate the list of files being returned.
    //
    //  This means that we need to re-allocate the buffer being returned (again).
    //

    if (hr == hrNone)
    {
        hr = HrAnnotateMungedFileList(cxh, wszBackupLogs, cbBackupLogs, (WSZ *)pszBackupLogs, pcbSize);

    }

    if (hr == hrNone) {

        hr = AddAllowedFilesToContextHandle(pjsc, wszBackupLogs);

    }
    
    MIDL_user_free(wszBackupLogs);

    MIDL_user_free(szJetBackupLogs);
    
    return(hr);
}


HRESULT
HrRBackupGetAttachmentInformation(
    CXH cxh,
    CB *pcbSize,
    SZ *pszAttachmentInformation
    )
/*++

Routine Description:

    This routine is called to return the list of attachments to the current database.

Arguments:
    cxh - the server side context handle for this operation.
    szAttachmentInformation - the name of the file to open.
    pcbSize - The size of the attachment, in bytes.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrError;
    SZ szJetAttachmentList;
    CB cbJetSize;
    WSZ wszAttachmentInformation;
    CB cbAttachmentInformation;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    //
    //  Figure out how much storage is needed to hold the logs.
    //

    hr = HrFromJetErr(JetGetAttachInfoInstance(pjsc->u.Backup.instance, NULL, 0, &cbJetSize));

    if (hr != hrNone)
    {
        return(hr);
    }

    szJetAttachmentList = MIDL_user_allocate(cbJetSize);

    if (szJetAttachmentList == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    hr = HrFromJetErr(JetGetAttachInfoInstance(pjsc->u.Backup.instance, szJetAttachmentList, cbJetSize, &cbJetSize));

    if (hr != hrNone)
    {
        MIDL_user_free(szJetAttachmentList);
        return(hr);
    }

    //
    //  Now convert the log name from JET to a uniform name that
    //  can be accessed from the client.
    //

    hr = HrMungedFileNamesFromJetFileNames(&wszAttachmentInformation, &cbAttachmentInformation, szJetAttachmentList, cbJetSize, fFalse);

    //
    //  Ok, we're not quite done yet.
    //
    //  Now we need to annotate the list of files being returned.
    //
    //  This means that we need to re-allocate the buffer being returned (again).
    //

    if (hr == hrNone)
    {
        hr = HrAnnotateMungedFileList(cxh, wszAttachmentInformation, cbAttachmentInformation, (WSZ *)pszAttachmentInformation, pcbSize);

    }

    if (hr == hrNone) {

        hr = AddAllowedFilesToContextHandle(pjsc, wszAttachmentInformation);

    }

    MIDL_user_free(wszAttachmentInformation);

    MIDL_user_free(szJetAttachmentList);

    return(hr);
}

BOOL
FIsLogFile(
    SZ szName,
    LPDWORD pdwGeneration
    )
{
    char rgchDrive[_MAX_DRIVE];
    char rgchDir[_MAX_DIR];
    char rgchFileName[_MAX_FNAME];
    char rgchExtension[_MAX_EXT];

    _splitpath(szName, rgchDrive, rgchDir, rgchFileName, rgchExtension);
    
    if (_stricmp(rgchExtension, ".log"))
    {
        return fFalse;
    }

    if (_strnicmp(rgchFileName, "edb", 3))
    {
        return fFalse;
    }

    //
    //  It's a log file.
    //

    if (pdwGeneration != NULL)
    {
        SZ szT = rgchFileName;

        *pdwGeneration = 0;
        //
        //  We want to find out the generation of this file if it's a log file.
        //
        while (*szT)
        {
            if (isdigit(*szT))
            {
                int iResult = sscanf(szT, "%x", pdwGeneration);
                if ( (iResult == 0) || (iResult == EOF) ) {
                    return fFalse;
                }
                break;
            }
            szT += 1;
        }
    }

    return fTrue;
}

HRESULT
HrRBackupOpenFile(
    CXH cxh,
    WSZ szAttachment,
    CB cbReadHintSize,
    BOOLEAN *pfUseSockets,
    C cProtocols,
    struct sockaddr rgsockaddrSockets[],
    BOOLEAN *pfUseSharedMemory,
    unsigned hyper *plicbFile
    )
/*++

Routine Description:

    This routine is called to open a file for Jet backup.

Arguments:
    cxh - the server side context handle for this operation.
    szAttachment - the name of the file to open.
    cbReadHintSize - A hint of the size of the reads that are to be done on the file.
    pulLengthLow - Low 32 bit of the file size.
    pulLengthHigh - High 32 bits of the file size.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrError;
    LARGE_INTEGER liFileSize;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;
    SZ szJetName;
    DWORD dwFileGeneration;
    WCHAR rgwcDrive[4];
    DWORD dwDummy;
    ULONG iFile;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    if (pjsc->u.Backup.awszAllowedFiles == NULL) {
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }
    for(iFile = 0; pjsc->u.Backup.awszAllowedFiles[iFile]; iFile++){
        if (_wcsicmp(szAttachment, pjsc->u.Backup.awszAllowedFiles[iFile]) == 0) {
            break;
        }
    }
    if (pjsc->u.Backup.awszAllowedFiles[iFile] == NULL) {
        // This file wasn't in the list
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    if (pjsc->u.Backup.fHandleIsValid)
    {
        return(hrAlreadyOpen);
    }

    hr = HrJetFileNameFromMungedFileName(szAttachment, &szJetName);

    if (hr != hrNone)
    {
        return(hr);
    }

    Assert(isascii(*szJetName));
    Assert(szJetName[1] == ':');
    Assert(szJetName[2] == '\\');
    rgwcDrive[0] = szJetName[0];
    rgwcDrive[1] = ':';
    rgwcDrive[2] = '\\';
    rgwcDrive[3] = '\0';

    //
    //  Figure out the granularity of the drive.
    //

    if (!GetDiskFreeSpaceW(rgwcDrive, &dwDummy, &pjsc->u.Backup.dwFileSystemGranularity, &dwDummy, &dwDummy))
    {
        MIDL_user_free(szJetName);
        return GetLastError();
    }

    //
    //  Open the file.
    //

    hr = HrFromJetErr(JetOpenFileInstance(pjsc->u.Backup.instance, szJetName, &pjsc->u.Backup.hFile, &liFileSize.LowPart, &liFileSize.HighPart));

    if (hr != hrNone)
    {

        MIDL_user_free(szJetName);
        return(hr);
    }

    pjsc->u.Backup.fHandleIsValid = fTrue;

    //
    //  Now save away state information about the read.
    //

    *plicbFile = liFileSize.QuadPart;
    pjsc->u.Backup.liFileSize = liFileSize;
    pjsc->u.Backup.cbReadHint = cbReadHintSize;

    if (FIsLogFile(szJetName, &dwFileGeneration))
    {
        if (dwFileGeneration != -1)
        {
            HKEY hkey;
            DWORD dwDisposition;
            DWORD   dwCurrentLogNumber = 0;
            DWORD   dwType;
            DWORD   cbLogNumber;
            WCHAR   rgwcRegistryBuffer[ MAX_PATH ];

            // This (Backup.wszBackupAnnotation) parameter's length is set by RPC 
            // packet from HrRBackupPrepare
            hr = StringCchPrintfW(rgwcRegistryBuffer,
                                  sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
                                  L"%ls%ls",
                                  BACKUP_INFO,
                                  pjsc->u.Backup.wszBackupAnnotation);
            if (hr) {
                Assert(!"NOT ENOUGH BUFFER");
                return(hr);
            }

            if (hr = RegCreateKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, NULL, 0, KEY_WRITE | KEY_READ, NULL, &hkey, &dwDisposition))
            {
                MIDL_user_free(szJetName);
                return(hr);
            }

            dwType = REG_DWORD;
            cbLogNumber = sizeof(DWORD);
            hr = RegQueryValueExW(hkey, LAST_BACKUP_LOG, 0, &dwType, (LPBYTE)&dwCurrentLogNumber, &cbLogNumber);

            if (hr && hr != ERROR_FILE_NOT_FOUND)
            {
                MIDL_user_free(szJetName);
                RegCloseKey(hkey);
                return(hr);
            }


            if (dwFileGeneration >= dwCurrentLogNumber)
            {

                hr = RegSetValueExW(hkey, LAST_BACKUP_LOG, 0, REG_DWORD, (LPBYTE)&dwFileGeneration, sizeof(DWORD));

                if (hr)
                {
                    MIDL_user_free(szJetName);
                    RegCloseKey(hkey);
                    return(hr);
                }

            }
            RegCloseKey(hkey);
        }
    }

    MIDL_user_free(szJetName);

    if (*pfUseSharedMemory)
    {
        pjsc->u.Backup.fUseSharedMemory =
            *pfUseSharedMemory =
                FCreateSharedMemorySection(&pjsc->u.Backup.jsc,
                                            pjsc->u.Backup.dwClientIdentifier,
                                            fFalse,
                                            cbReadHintSize*READAHEAD_MULTIPLIER);
    }

    
    //
    //  If the client can use sockets, and isn't using shared memory, connect back to the client.
    //
    
    // NTRAID#NTBUG9-596785-2002/04/07-BrettSh - See this bug, for the full discussion, but
    // basically sockets, are unsafe, no encryption, data disclosure leak, so we disabled
    // them altogether.  LaurionB is fixing this code for Exchange team, so if you need
    // sockets again suggest you look into the bug and talk to LaurionB.
    *pfUseSockets = fFalse;
#ifdef JETBACK_USE_SOCKETS
    if (!*pfUseSharedMemory && *pfUseSockets)
    {
        //
        //  Connect back to the client.
        //

        pjsc->u.Backup.sockClient = SockConnectToRemote(rgsockaddrSockets, cProtocols);

        if (pjsc->u.Backup.sockClient != INVALID_SOCKET)
        {

            //
            //  We connected back to the client, we're in luck.
            //

            //
            //  Now tell winsock the buffer size of the transfer.
            //

            setsockopt(pjsc->u.Backup.sockClient, SOL_SOCKET, SO_SNDBUF, (char *)&cbReadHintSize, sizeof(DWORD));               

            //
            //  And tell it to turn on keepalives.
            //

            //
            //  Boolean socket operations just need a pointer to a non-
            //  zero buffer.
            //
            Assert(cbReadHintSize != 0);

            setsockopt(pjsc->u.Backup.sockClient, SOL_SOCKET, SO_KEEPALIVE, (char *)&cbReadHintSize, sizeof(DWORD));

            //
            //  Indicate that we're using sockets.
            //

            pjsc->u.Backup.fUseSockets = fTrue;

            //
            //  And make sure that nobody else can close this socket.
            //

            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);

        }
        else
        {
            //
            //  We couldn't connect - continue, but we can't use sockets.
            //

            *pfUseSockets = fFalse;

            pjsc->u.Backup.fUseSockets = fFalse;

        }

    }
#endif

    return(hr);
}

DWORD
dwPingCounter = 0;

HRESULT
HrRBackupPing(
    handle_t hBinding
    )
{
    HRESULT hr = hrNone;
    //
    //  Monotonically increase the ping counter.
    //

    if (hr = HrValidateInitialBackupSecurity()) {
        return(hr);
    }

    InterlockedIncrement(&dwPingCounter);

    return hrNone;
}

HRESULT
HrSharedWrite(
    PJETBACK_SERVER_CONTEXT pjsc,
    char *pvBuffer,
    CB cbBuffer,
    CB *pcbRead
    )
/*++

Routine Description:

Write data to the shared memory segment, synchronizing with the reader.

HrSharedWrite synchronizes with HrBackupRead using two events:
heventRead and heventWrite.
heventRead is the data available event from writer to reader
heventWrite is the data consumed event from reader to writer
This side is the writing side.
Reading side is at jetbcli\jetbcli.c:HrBackupRead()

Here is the algorithm:
while()
    write blocked = false
    Make data available
    if (read blocked) set data available
    write blocked = true
    wait for data consumed

One purpose of the read block flag is to determine whether the reader is
waiting or not.  The reader may or may not block depending on whether he
finds data in buffer.

I've come to the conclusion that the if (reader blocked) set event constructs
to serve a purpose.  The reader may or may not wait, depending on whether he
finds data in the buffer.  The producer avoids setting the event if the
consumer isn't waiting.  

I've toned down my complaining in common.c since the code really is pretty
reasonble using the mutex to keep things orderly.  The only problem was the
use of pulse event.  I can sort of see the reasoning now: if you use
synchronized flags to tell that your partner is waiting, pulse event does the
job since it only wakes a waiting waiter.  The problem no one saw is that
reader blocked = true
release mutex
wait for event
is not atomic.  If the producer runs between steps two and three, the pulse
is lost.  This is why the SetEvent is now used.

Arguments:

    pjsc - 
    pvBuffer - 
    cbBuffer - 
    pcbRead - 

Return Value:

    HRESULT - 

--*/
{
    HRESULT hr = hrNone;
    PJETBACK_SHARED_HEADER pjsh = pjsc->u.Backup.jsc.pjshSection;
    LARGE_INTEGER liBytesRead;
    liBytesRead.QuadPart = 0;

    //
    //  We're writing the file using shared memory.
    //

    WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);

    //
    //  We've now got the shared memory region locked.  See if there's enough room in the shared
    //  memory region available to read the data from the file, and if so, read it and update our pointers.
    //

    while (liBytesRead.QuadPart < pjsc->u.Backup.liFileSize.QuadPart)
    {
        DWORD dwWriteEnd;
        BOOLEAN fWriteOk;
        pjsc->u.Backup.jsc.pjshSection->fWriteBlocked = fFalse;

        //
        //  If the read side of the API returned while we were blocked, we want to return
        //  right away.
        //

                
        if ((hr = pjsh->hrApi) != hrNone)
        {
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);
            return hr;
        }
        
        //
        //  If the write is ahead of the read pointer, we want to read one buffers worth of data.
        //
        
        if (pjsh->dwWritePointer > pjsh->dwReadPointer || pjsh->cbReadDataAvailable == 0)
        {
            //
            //  The end of this write is either the end of the buffer, or 1 read-hint length into
            //  the buffer.
            //

            dwWriteEnd = min(pjsh->dwWritePointer + pjsc->u.Backup.cbReadHint,
                             pjsh->cbSharedBuffer);
            
            fWriteOk = fTrue;
        }
        else
        {
            //
            //  In this case, the start of the write is before the start of the read pointer,
            //  so the end of the write is 1 read-hint length ahead of the write pointer.
            //
            //  There are basically 3 cases:
            //      1)  Read pointer is > 1 read-hint length ahead of the write pointer -
            //              In this case we can read data into the buffer.
            //      2)  Read pointer is < 1 read-hint length ahead of the write pointer -
            //              In this case, we need to block until read data is taken
            //      3)  Read pointer is == write pointer.
            //              In this case, we need to follow the comment below.
            //

            dwWriteEnd = pjsh->dwWritePointer + pjsc->u.Backup.cbReadHint;
            
            //
            //  We can write iff the end of the write is before the read offset.
            //
            
            if (dwWriteEnd < pjsh->dwReadPointer)
            {
                fWriteOk = fTrue;
            }
            else if (dwWriteEnd == pjsh->dwReadPointer)
            {
                //
                //  if dwWriteEnd == dwReadPointer, it means that there is either no data
                //  available in the buffer, or all the data is available in the buffer.
                //
                //  If there's no data available in the buffer, we can write more, if the buffer
                //  is full, we can't.
                //
                
                fWriteOk = ((DWORD)pjsh->cbReadDataAvailable !=
                            pjsh->cbSharedBuffer);
            }   
            else
            {
                //
                //  The write extends into the read data.  We can't do the write.
                //
                
                fWriteOk = fFalse;
            }
        }
        
        if (fWriteOk)
        {
            DWORD cbBackupRead;
            LARGE_INTEGER cbBytesRemaining;
            
            //
            //  We want to read either the full amount of data for the read or to the end of the file.
            //

            cbBackupRead = dwWriteEnd - pjsh->dwWritePointer;
            
            cbBytesRemaining.QuadPart = pjsc->u.Backup.liFileSize.QuadPart - liBytesRead.QuadPart;

            if (cbBytesRemaining.HighPart == 0)
            {
                cbBackupRead = min(cbBackupRead, cbBytesRemaining.LowPart);
            }

            Assert (pjsh->cbReadDataAvailable   <
                    (LONG)pjsh->cbSharedBuffer);

            Assert (pjsh->cbReadDataAvailable   <=
                    (LONG)pjsh->cbSharedBuffer-(LONG)cbBackupRead);
            //
            //  We want to release the mutex, read the data, and re-acquire after writing the data.
            //
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);

            //
            //  Now read the data from JET into the shared memory region.
            //

            //
            //  Read either the read hint or the amount remaining in the
            //  file.  If the read hint size is > the size of the file, JetReadFileInstance
            //  will simply return ecDiskIO.
            //
        
            Assert (cbBackupRead);
            hr = HrFromJetErr(JetReadFileInstance(pjsc->u.Backup.instance,
                                                  pjsc->u.Backup.hFile,
                                                  (void *)((CHAR *)pjsh+
                                                  pjsh->cbPage+
                                                  pjsh->dwWritePointer),
                                                  cbBackupRead,
                                                  pcbRead));
        
            //
            //  If the read failed, bail out now.  We don't own any resources, so we can just return.
            //

            if (hr != hrNone)
            {
                pjsh->hrApi = hr;
                return hr;
            }

            liBytesRead.QuadPart += *pcbRead;

            //
            //  We were woken up.  Reacquire the shared mutex and wait again.
            //

            WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);

            Assert (pjsh->cbReadDataAvailable < (LONG)pjsh->cbSharedBuffer);

            //
            //  Bump the number of available data bytes.
            //

            pjsh->cbReadDataAvailable   += *pcbRead;

            //
            //  There is always less data than the size of the buffer available.
            //

            Assert (pjsh->cbReadDataAvailable <= pjsh->cbReadDataAvailable);

            //
            //  Advance the write end pointer.
            //

            pjsh->dwWritePointer += *pcbRead;

            if (pjsh->dwWritePointer >= pjsh->cbSharedBuffer)
            {
                pjsh->dwWritePointer -= pjsh->cbSharedBuffer;
            }

            if (pjsh->fReadBlocked)
            {
                //
                //  Kick the reader - there's data for him.
                //
                
                SetEvent(pjsc->u.Backup.jsc.heventRead);
            }

#if DBG
            //
            //  The number of bytes available is always the same as the
            //  the number of bytes in the buffer - the # of bytes read, unless
            //  the read and write pointers are the same, in which case, it is either
            //  0 or the total # of bytes available.
            //
            //  If the read is blocked, then there must be 0 bytes available, otherwise there
            //  must be the entire buffer available.
            //
                
            if (pjsh->dwWritePointer == pjsh->dwReadPointer)
            {
                Assert (pjsh->cbReadDataAvailable == 0 ||
                        pjsh->cbReadDataAvailable == (LONG)pjsh->cbSharedBuffer);
            }
            else
            {
                CB cbAvailable;
                if (pjsh->dwWritePointer > pjsh->dwReadPointer)
                {
                    cbAvailable = pjsh->dwWritePointer - pjsh->dwReadPointer;
                }
                else
                {
                    cbAvailable = pjsh->cbSharedBuffer - pjsh->dwReadPointer;
                    cbAvailable += pjsh->dwWritePointer;
                }
                
                Assert (cbAvailable >= 0);
                Assert (pjsh->cbReadDataAvailable == cbAvailable);
                    
            }
#endif
        }
        else
        {
            DWORD dwOldPingCounter;
            pjsh->fWriteBlocked = fTrue;

            //
            //  Ok, we think we've got to block.  Make sure that the write event
            //  is really going to block.
            //

            
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);

            //
            //  Wait for the client to read the data.  If the wait times out and
            //  the client hasn't pinged the server since we started the wait,
            //  then we need to punt - the client is probably long gone.
            //
            //  Please note that the client pings the server 4 times in a wait timeout,
            //  so we should never incorrectly detect the client going away - even if the client
            //  was CPU bound for some period of time, at least one of the pings should have
            //  made it in.
            //


            do
            {
                DWORD dwWin32Error;

                dwOldPingCounter = dwPingCounter;
                dwWin32Error = WaitForSingleObject(pjsc->u.Backup.jsc.heventWrite, BACKUP_WAIT_TIMEOUT);
                hr = HRESULT_FROM_WIN32( dwWin32Error );
            } while (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT) && dwPingCounter != dwOldPingCounter );
            
            if (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT))
            {
                return hrCommunicationError;
            }
            //
            //  We were woken up.  Reacquire the shared mutex and wait again.
            //

            WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);
            
        }
    }

    return hr;
}

#ifdef JETBACK_USE_SOCKETS
HRESULT
HrSocketWrite(
    PJETBACK_SERVER_CONTEXT pjsc,
    char *pvBuffer,
    CB cbBuffer,
    CB *pcbRead
    )
{
    HRESULT hr;
    HANDLE hWriteCompleteEvent;
    DWORD cbWritten;
    OVERLAPPED overlapped;
    CHAR *pbBufferRead;
    CHAR *pbBufferSend;
    LARGE_INTEGER liBytesRead;

    liBytesRead.QuadPart = 0;

#error "This code is disabled."
    // NTRAID#NTBUG9-596785-2002/04/07-BrettSh - See bug for full details
    // or similar tag above for brief details.
    
    DebugTrace(("HrSocketWrite\n"));

    //
    //  We're reading the file using sockets.
    //

    //
    //  Create an event in the signalled state.
    //
    
    hWriteCompleteEvent = CreateEvent(NULL, fFalse, fTrue, NULL);
    
    if (hWriteCompleteEvent == NULL)
    {
        DebugTrace(("HrSocketWrite: Could not create completion event\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    //
    //  Zero the contents of the overlapped structure.  This is actually important, because
    //  it allows us to call GetOverlappedResult() on a handle that doesn't have I/O
    //  outstanding on it yet.
    //
    
    memset(&overlapped, 0, sizeof(overlapped));
    
    overlapped.hEvent = hWriteCompleteEvent;
    
    //
    //  Ok, we're using sockets for this API, we want to read the data from the file and
    //  return it to the client.
    //
            
    pbBufferSend = VirtualAlloc(NULL, pjsc->u.Backup.cbReadHint, MEM_COMMIT, PAGE_READWRITE);
    
    if (pbBufferSend == NULL)
    {
        CloseHandle(hWriteCompleteEvent);
        DebugTrace(("HrSocketWrite: Could not allocate send buffer\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    pbBufferRead = VirtualAlloc(NULL, pjsc->u.Backup.cbReadHint, MEM_COMMIT, PAGE_READWRITE);
    
    if (pbBufferRead == NULL)
    {
        CloseHandle(hWriteCompleteEvent);
        VirtualFree(pbBufferSend, 0, MEM_RELEASE);
        DebugTrace(("HrSocketWrite: Could not allocate read buffer\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    //
    //  Now loop reading data from the file and sending it to the
    //  client.
    //
    //  Please note that there is a fundimental assumption here that it takes longer
    //  to transmit the data to the client than it does to read the data from the file,
    //  if this is incorrect, then we probably want to queue up multiple writes to the
    //  client.  We also attempt to improve performance by overlapping the read with the network write.
    //
    
    while (liBytesRead.QuadPart < pjsc->u.Backup.liFileSize.QuadPart)
    {
        DWORD cbBytesToRead = pjsc->u.Backup.cbReadHint;
        LARGE_INTEGER cbBytesRemaining;
        CHAR *pbTemp;
        cbBytesRemaining.QuadPart = pjsc->u.Backup.liFileSize.QuadPart - liBytesRead.QuadPart;
    
        if (cbBytesRemaining.HighPart == 0)
        {
            cbBytesToRead = min(cbBytesToRead, cbBytesRemaining.LowPart);
        }
        
        //
        //  Read either the read hint or the amount remaining in the
        //  file.  If the read hint size is > the size of the file, JetReadFileInstance
        //  will simply return ecDiskIO.
        //
    
        hr = HrFromJetErr(JetReadFileInstance(pjsc->u.Backup.instance,
                                              pjsc->u.Backup.hFile,
                                              pbBufferRead,
                                              cbBytesToRead,
                                              pcbRead));
        
        if (hr != hrNone)
        {
            DebugTrace(("HrSocketWrite: JetReadFileInstance failed with %x\n", hr));
            //
            //  Wait for any previous writes to complete before returning the JET error.
            //
            WaitForSingleObject(hWriteCompleteEvent, INFINITE);
    
            GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue);
            CloseHandle(hWriteCompleteEvent);
            
            //
            //  We're going to close the socket - make sure we can get away with it.
            //
            
            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
            
            closesocket(pjsc->u.Backup.sockClient);
            pjsc->u.Backup.sockClient = INVALID_SOCKET;
            VirtualFree(pbBufferSend, 0, MEM_RELEASE);
            VirtualFree(pbBufferRead, 0, MEM_RELEASE);
            return(hr);
        }
    
        //
        //  Wait for the previous write to complete.
        //
        
        WaitForSingleObject(hWriteCompleteEvent, INFINITE);
        
        if (!GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue)) {

            DebugTrace(("HrSocketWrite: Previous write failed with %d\n", GetLastError()));
            //
            //  The previous I/O failed.  Return the error to the client
            //
            hr = GetLastError();
            CloseHandle(hWriteCompleteEvent);
            //
            //  We're going to close the socket - make sure we can get away with it.
            //

            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);

            closesocket(pjsc->u.Backup.sockClient);
            pjsc->u.Backup.sockClient = INVALID_SOCKET;
            VirtualFree(pbBufferSend, 0, MEM_RELEASE);
            VirtualFree(pbBufferRead, 0, MEM_RELEASE);
            return(hr);
        }
    
        //
        //  Now swap the send and read buffers - Thus the buffer we just read will be
        //  in pbBufferSend, and pbBufferRead will point to the buffer we just completed
        //  sending.
        //
        pbTemp = pbBufferSend;
        pbBufferSend = pbBufferRead;
        pbBufferRead = pbTemp;
        
        //
        //  Now transmit the next portion of the file to the client.
        //
        
        if (!WriteFile((HANDLE)pjsc->u.Backup.sockClient, pbBufferSend, *pcbRead, &cbWritten, &overlapped))
        {
            //
            //  The write failed with something other than I/O pending,
            //  we need to return that error to the client.
            //
            if (GetLastError() != ERROR_IO_PENDING)
            {
                hr = GetLastError();
                DebugTrace(("HrSocketWrite: Immediate write failed with %d\n", hr));
                CloseHandle(hWriteCompleteEvent);
                //
                //  We're going to close the socket - make sure we can get away with it.
                //
                
                SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
                
                closesocket(pjsc->u.Backup.sockClient);
                pjsc->u.Backup.sockClient = INVALID_SOCKET;
                VirtualFree(pbBufferSend, 0, MEM_RELEASE);
                VirtualFree(pbBufferRead, 0, MEM_RELEASE);
                return(hr);
            }
        }
        
        //
        //  The write is on its way - mark that we've read and transmitted the
        //  data and continue sending.
        //
        
        liBytesRead.QuadPart += *pcbRead;
    }
    
    //
    //  We've transmitted the entire file to the client,
    //  we want to wait for the last outstanding I/O on the file to
    //  complete and then return to the client.
    //
    
    WaitForSingleObject(hWriteCompleteEvent, INFINITE);
    
    if (!GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue)) {
        //
        //  The previous I/O failed.  Return the error to the client
        //
        hr = GetLastError();
        DebugTrace(("HrSocketWrite: Final write failed with %d\n", hr));
    }
    else
    {
        hr = hrNone;
    }
    
    //
    //  Indicate that 0 bytes were read to the read API - if we don't
    //  do this, then RPC will attempt to transfer bogus data
    //  to the client.
    //
    
    *pcbRead = 0;
    
    CloseHandle(hWriteCompleteEvent);
    
    VirtualFree(pbBufferSend, 0, MEM_RELEASE);
    VirtualFree(pbBufferRead, 0, MEM_RELEASE);
    
    return hr;
}
#endif

HRESULT
HrRBackupRead(
    CXH cxh,
    CB cbBuffer,
    char *pvBuffer,
    CB *pcbRead
    )
{
    HRESULT hr = hrNone;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;
    LARGE_INTEGER liBytesRead;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    if (!pjsc->u.Backup.fHandleIsValid)
    {
        return(hrInvalidHandle);
    }

    liBytesRead.QuadPart = 0;

    //
    //  If we're not using sockets, just perform the read using JET, and
    //  return it to the caller.
    //

    if (pjsc->u.Backup.fUseSharedMemory)
    {
        hr = HrSharedWrite(pjsc, pvBuffer, cbBuffer, pcbRead);
#ifdef JETBACK_USE_SOCKETS
    } else if (pjsc->u.Backup.fUseSockets)
    {
        hr = HrSocketWrite(pjsc, pvBuffer, cbBuffer, pcbRead);
#endif
    } else {
        char *pvReadBuffer;

        if (!g_fAllowRemoteOp) {
            Assert(!"We should've been blocked long before this, but just in case");
            return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        }
        
        pvReadBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, PAGE_READWRITE);

        if (pvReadBuffer == NULL)
        {
            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }

        hr = HrFromJetErr(JetReadFileInstance(pjsc->u.Backup.instance, pjsc->u.Backup.hFile, pvReadBuffer, cbBuffer, pcbRead));
        
        if (hr != hrNone)
        {
            VirtualFree(pvReadBuffer, 0, MEM_RELEASE);
            return hr;
        }

        //
        //  Now copy the data from our buffer to the RPC buffer and free our buffer.
        //

        memcpy(pvBuffer, pvReadBuffer, cbBuffer);

        VirtualFree(pvReadBuffer, 0, MEM_RELEASE);

        return(hr);
    }
    
    return(hr);
}


HRESULT
HrRBackupClose(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called to close a handle that was opened via a cal to HrRBackupOpenFile.

Arguments:
    cxh - The context handle for the client for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrInvalidHandle;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

    if (hr = HrValidateBackupContextAndSecurity(pjsc)) {
        return(hr);
    }

    if (!pjsc->u.Backup.fHandleIsValid)
    {
        return(hrInvalidHandle);
    }

    //
    //  Tell Jet to close the backup file.
    //

    hr = HrFromJetErr(JetCloseFileInstance(pjsc->u.Backup.instance, pjsc->u.Backup.hFile));

    pjsc->u.Backup.fHandleIsValid = fFalse;

    if (pjsc->u.Backup.fUseSharedMemory)
    {
        CloseSharedControl(&pjsc->u.Backup.jsc);
    }

#ifdef JETBACK_USE_SOCKETS
    if (pjsc->u.Backup.fUseSockets)
    {
        if (pjsc->u.Backup.sockClient != INVALID_SOCKET)
        {
            //
            //  We're going to close the socket - make sure we can get away with it.
            //

            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);

            closesocket(pjsc->u.Backup.sockClient);
        }
    }
#endif

    return(hr);
}

/*++

Routine Description:

    This routine retrieves the database locations for the specified component.

Arguments:
    wszBackupAnnotation - the annoation for the component to query.
    pwszDatabases - a pointer that will hold the locations of the databases
    pcbDatabases - the size of the buffer.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
HRESULT
HrGetDatabaseLocations(
    WSZ *pwszDatabases,
    CB *pcbDatabases
    )
{
    HRESULT hr = hrNone;
    char *szDatabases = NULL;
    CB cbSize;

    *pwszDatabases = NULL;
    __try 
    {
        // First find out how big the database locations are.
        hr = EcDsaQueryDatabaseLocations(NULL, &cbSize, NULL, 0, NULL);
        if (hr != hrNone)
        {
            return hr;
        }

        // Allocate memory to receive database locations
        szDatabases = MIDL_user_allocate(cbSize);
        if (!szDatabases)
        {
            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }

        // Now actually get the database locations
        hr = EcDsaQueryDatabaseLocations(szDatabases, &cbSize, NULL, 0, NULL);
        if (hr != hrNone)
        {
            return hr;
        }

        // Now create munged file name from Jet file names
        hr = HrMungedFileNamesFromJetFileNames((WSZ *)pwszDatabases, pcbDatabases, 
                szDatabases, cbSize, fTrue);

        return hr;
    }
    __finally
    {
        if (szDatabases)
        {
            MIDL_user_free(szDatabases);
        }

        if (hr != hrNone)
        {
            if (*pwszDatabases)
            {
                MIDL_user_free(*pwszDatabases);
            }

            *pwszDatabases = NULL;
            *pcbDatabases = 0;
        }
    }

    return hr;
}


HRESULT
HrRBackupEnd(
    CXH *pcxh
    )
/*++

Routine Description:

    This routine is called when a backup is complete.  It terminates the server side
    operation.

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrNone;

    if (pcxh == NULL){
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    if (HrValidateBackupContextAndSecurity(*pcxh)) {
        return(hr);
    }

    HrDestroyCxh(*pcxh);

    MIDL_user_free(*pcxh);

    *pcxh = NULL;

    return hr;
}


HRESULT
HrDestroyCxh(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called when a client has disconnected from the server.  It will do whatever actions are necessary
    to clean up any client state that is remaining.
    

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    ULONG iFile;

    if (cxh != NULL)
    {
        PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

        if (pjsc->fRestoreOperation)
        {
            RestoreRundown(pjsc);
        }
        else
        {
            //
            //  Close the backup if appropriate.
            //
    
            if (pjsc->u.Backup.fHandleIsValid)
            {
                HrRBackupClose(cxh);
            }
    
            //
            // Free the list of allowed files
            //
            if (pjsc->u.Backup.awszAllowedFiles)
            {

                for(iFile = 0; pjsc->u.Backup.awszAllowedFiles[iFile]; iFile++){
                    MIDL_user_free(pjsc->u.Backup.awszAllowedFiles[iFile]);
                }
                MIDL_user_free(pjsc->u.Backup.awszAllowedFiles);
                pjsc->u.Backup.awszAllowedFiles = NULL;

            }

            //
            //  Tell JET we're done doing the backup.
            //
    
            if (pjsc->u.Backup.fBackupIsRegistered)
            {
                JetEndExternalBackupInstance(pjsc->u.Backup.instance);
            }

            if (pjsc->u.Backup.wszBackupAnnotation)
            {
                MIDL_user_free(pjsc->u.Backup.wszBackupAnnotation);
                pjsc->u.Backup.wszBackupAnnotation = NULL;
            }

            if (pjsc->u.Backup.fUseSharedMemory)
            {
                CloseSharedControl(&pjsc->u.Backup.jsc);
            }

#if DBG
            UninitializeTraceLog();
#endif
        }

    }

    return(hrNone);
}

BFT
BftClassify(
    WSZ wszFileName,
    WSZ wszDatabaseLocations,
    CB cbLocations
    )
{
    BFT bft = BFT_UNKNOWN;
    WCHAR rgwcPath[ _MAX_PATH ];
    WCHAR rgwcExt[ _MAX_EXT ];
    WSZ wszT;

    _wsplitpath(wszFileName, NULL, rgwcPath, NULL, rgwcExt);

    //
    //  Do the easy cases first.
    //

    if (_wcsicmp(rgwcExt, L".PAT") == 0)
    {
        return BFT_PATCH_FILE;
    }
    else if (_wcsicmp(rgwcExt, L".LOG") == 0)
    {
        return BFT_LOG;
    }
    else if (_wcsicmp(rgwcExt, L".DIT") == 0)
    {
        //
        //  This guy's a database.  We need to look and find out which database
        //  it is.
        //

        wszT = wszDatabaseLocations;
        bft = *wszT++;
        while (*wszT)
        {
            if ((bft & BFT_DATABASE_DIRECTORY) &&
                _wcsicmp(wszT, wszFileName)==0)
            {
                
                return bft;
            }
            wszT += wcslen(wszT)+1;
            bft = *wszT++;
        }
    }

    //
    //  Ok, I give up.  I don't know anything about this guy at all, so I need to
    //  try to figure out what I can tell the user about him.
    //

    wszT = wszDatabaseLocations;
    bft = *wszT++;

    rgwcPath[wcslen(rgwcPath)-1] = L'\0';

    while (*wszT)
    {
        if (bft & BFT_DIRECTORY)
        {
            //
            //  If the directory this file is in matches the directory I'm looking at,
            //  I know where it needs to go on the restore.
            //

            if (_wcsicmp(wszT, rgwcPath) == 0)
            {
                return bft;
            }
        }

        wszT += wcslen(wszT)+1;
        bft = *wszT++;
    }

    return BFT_UNKNOWN;
}

HRESULT
HrAnnotateMungedFileList(
    PJETBACK_SERVER_CONTEXT pjsc,
    WSZ wszFileList,
    CB cbFileList,
    WSZ *pwszAnnotatedList,
    CB *pcbAnnotatedList
    )
{
    HRESULT hr;
    WSZ wszDatabaseLocations = NULL;
    WSZ wszAnnotatedList = NULL;
    CB cbLocations;
    WSZ wszT;
    C cFileList = 0;
    C cbAnnotBuffLeft;

    hr = HrGetDatabaseLocations(&wszDatabaseLocations, &cbLocations);

    if (hr != hrNone)
    {
        return hr;
    }

    //
    //  First figure out how long the file list is.  This indicates how many items we've got to add to the list.
    //

    wszT = wszFileList;
    while (*wszT)
    {
        cFileList += 1;
        wszT += wcslen(wszT)+1;
    }

    *pcbAnnotatedList = cbFileList+cFileList*sizeof(WCHAR);

    *pwszAnnotatedList = wszAnnotatedList = MIDL_user_allocate( *pcbAnnotatedList );

    if (*pwszAnnotatedList == NULL)
    {
        MIDL_user_free(wszDatabaseLocations);
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    cbAnnotBuffLeft = *pcbAnnotatedList;
    wszT = wszFileList;
    while (*wszT)
    {
        // Add annotation in front of file path.
        *wszAnnotatedList++ = BftClassify(wszT, wszDatabaseLocations, cbLocations);
        cbAnnotBuffLeft -= sizeof(wszAnnotatedList[0]);
        
        // Add file path to buffer.
        hr = StringCbCopy(wszAnnotatedList, cbAnnotBuffLeft, wszT);
        if (hr) {
            Assert(!"NOT ENOUGH BUFFER");
            MIDL_user_free(wszDatabaseLocations);
            MIDL_user_free(*pwszAnnotatedList);
            *pwszAnnotatedList = NULL;
            return(hr);
        }
        wszAnnotatedList += wcslen(wszAnnotatedList)+1;
        cbAnnotBuffLeft -= (wcslen(wszAnnotatedList)+1) * sizeof(WCHAR);
        
        // Increment to next file path
        wszT += wcslen(wszT)+1;
    }

    MIDL_user_free(wszDatabaseLocations);

    return hrNone;
}

HRESULT
HrMungedFileNamesFromJetFileNames(
    WSZ *pszMungedList,
    CB *pcbSize,
    SZ szJetFileNameList,
    CB cbJetSize,
    BOOL fAnnotated
    )
/*++

Routine Description:

    This routine will convert the database names returned from JET into a form
    that the client can use.  This is primarily there for restore - the client
    will get the names in UNC format relative to the root of the server, so they
    can restore the files to that location.
    
Arguments:
    pszMungedList - The resulting munged list.
    pcbSize - the length of the list.
    szJetFileNameList - the list of files returned from JET.
    cbJetSize - the length of the JET list.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    SZ szJetString;
    WSZ wszMungedList;
    CCH cchMungeString = 0;
    HRESULT hr = hrNone;
    C cchMungeBuffLeft;

    szJetString = szJetFileNameList;

    //
    //  First go through and figure out how large the converted strings will be.
    //

    while (*szJetString != '\0')
    {
        WSZ wszMungedName;

        if (fAnnotated)
        {
            szJetString++;
        }

        hr = HrMungedFileNameFromJetFileName(szJetString, &wszMungedName);

        if (hr != hrNone)
        {
            return(hr);
        }

        cchMungeString += wcslen(wszMungedName)+1+(fAnnotated != 0);

        MIDL_user_free(wszMungedName);

        // Increment to next file path
        szJetString += strlen(szJetString)+1;
    }

    //
    //  Account for the final null at the end of the string.
    //

    cchMungeString += 1;

    *pcbSize = cchMungeString*sizeof(WCHAR);

    wszMungedList = MIDL_user_allocate(cchMungeString*sizeof(WCHAR));

    *pszMungedList = wszMungedList;

    if (wszMungedList == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    szJetString = szJetFileNameList;
    cchMungeBuffLeft = cchMungeString;

    //
    //  Now actually go through and convert the names.
    //

    while (*szJetString != '\0')
    {
        WSZ wszMungedName;

        //
        //  Copy over the annotation.
        //

        if (fAnnotated)
        {
            *wszMungedList++ = (*szJetString++ & 0xFF);
            cchMungeBuffLeft--;
        }
    
        hr = HrMungedFileNameFromJetFileName(szJetString, &wszMungedName);

        if (hr != hrNone)
        {
            MIDL_user_free(wszMungedList);

            *pszMungedList = NULL;
            return(hr);
        }

        // Add this filepath to the buffer
        hr = StringCchCopy(wszMungedList, cchMungeBuffLeft, wszMungedName);
        if (hr) {
            Assert(!"NOT ENOUGH BUFFER");
            MIDL_user_free(wszMungedName);
            MIDL_user_free(*pszMungedList);
            *pszMungedList = NULL;
            return(hr);
        }
        // Leave a NULL between strings
        wszMungedList += wcslen(wszMungedList)+1; 
        cchMungeBuffLeft -= (wcslen(wszMungedList) + 1);

        MIDL_user_free(wszMungedName);

        // Increment to next file path
        szJetString += strlen(szJetString)+1;
    }
    
    return(hrNone);
}

HRESULT
HrMungedFileNameFromJetFileName(
    SZ szJetFileName,
    WSZ *pszMungedFileName
    )
/*++

Routine Description:

    This routine will convert the database names returned from JET into a form
    that the client can use.  This is primarily there for restore - the client
    will get the names in UNC format relative to the root of the server, so they
    can restore the files to that location.
    

Arguments:
    pszMungedFileName - the list of files returned from JET.
    szJetFileName - The resulting munged list.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

Note:
    This routine will allocate memory for the returned munged file name.

--*/
{
    //
    //  First check to see if this is a JET absolute file name or a JET relative file name.
    //
    if (FIsAbsoluteFileName(szJetFileName))
    {
        C cchConvertedName;
        WSZ wszMungedFileName;
        WSZ szT;
        HRESULT hr;
        //
        //  Convert this name to an absolute name.
        //
        cchConvertedName = strlen(szJetFileName) + wcslen(rgchComputerName) + 3/* for \\ */ + 1;

        wszMungedFileName = MIDL_user_allocate(cchConvertedName * sizeof(WCHAR));

        if (wszMungedFileName == NULL)
        {
            return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        }

        wszMungedFileName[0] = TEXT('\\');
        wszMungedFileName[1] = TEXT('\\');  //  form \\.
        hr = StringCchCat(wszMungedFileName, cchConvertedName, rgchComputerName);        // form \\server
        if (hr) {
            Assert(!"NOT ENOUGH BUFFER");
            return(hr);
        }

        szT = wszMungedFileName + wcslen(wszMungedFileName);
        *szT++ = TEXT('\\');                //  form \\server\.
        *szT++ = *szJetFileName;    //  form \\server\<drive>
        *szT++ = '$';               //  Form \\server\<drive>$

        if (MultiByteToWideChar(CP_ACP, 0, &szJetFileName[2], -1, szT, cchConvertedName-wcslen(rgchComputerName) - 5) == 0) {
            MIDL_user_free(wszMungedFileName);
            return(GetLastError());
        }
        
        *pszMungedFileName = wszMungedFileName;

        return(hrNone);
    }
    else
    {
        //
        //  We don't handle relative file names.
        //
        return(ERROR_INVALID_PARAMETER);
    }
}

BOOL
FIsAbsoluteFileName(
    SZ szFileName
    )
/*++

Routine Description:

        

Arguments:
    szFileName - the file name to check.

Return Value:

    BOOL - fTrue if the file is an absolute filename, fFalse if not.

--*/
{
    return(isalpha(*szFileName) && szFileName[1] == ':' && szFileName[2] == '\\');
}


//
//  RPC related management routines.
//

void
CXH_rundown(
    CXH cxh
    )
/*++

Routine Description:

    This routine is invoked when the connection to the remote client is abortively
    disconnected.

Arguments:

    cxh - The context handle for the client.

Return Value:

    None.

--*/
{
    HrDestroyCxh(cxh);

    //
    //  Free up the context handle
    //

    MIDL_user_free(cxh);
}

BOOL
DllEntryPoint(
    HINSTANCE hinstDll,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.

Arguments:

    hinstDll - an instance handle for the DLL.
    dwReason - The reason the routine was called.
    pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

    BOOL - fTrue if the DLL initialization was successful, fFalse if not.

--*/
{
    BOOL fReturn;
    HANDLE hevLogging;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    {
        LPSTR rgpszDebugParams[] = {"ntdsbsrv.dll", "-noconsole"};
        DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
        CB cbComputerName = sizeof(rgchComputerName)/sizeof(rgchComputerName[0]);

        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ntdsbsrv");

        if (!FInitializeRestore())
        {
            return(fFalse);
        }

        if (!GetComputerNameW(rgchComputerName, &cbComputerName))
        {
            FUninitializeRestore();
            return(fFalse);
        }

        // Note that the reason we don't use the shared event initialization mechanism
        // (DS_EVENT_CONFIG, see dsevent.h) is that ntdsa.dll is not always initialized
        // when we are.
        hevLogging = LoadEventTable();
        if (hevLogging == NULL) {
            DPRINT( 0, "Failed to load event table.\n" );
        }

#ifdef DBG
        // Do we allow remote connections?
        //      Only in debug mode, and with the right registry entry!
        //
        // NTRAID#NTBUG9-596785-2002/04/07-BrettSh - So remote backup has been disabled
        // except for in debug mode.  Remote backup is secure, except for backup via
        // sockets, which has been disabled altogether.  See bug for more details, talk
        // to LaurionB about fixing out sockets code.
        if(GetConfigParamW(ALLOW_REMOTE_SERVER_OP, 
                           &g_fAllowRemoteOp,
                           sizeof(g_fAllowRemoteOp))){
            // Error means not allowed
            g_fAllowRemoteOp = FALSE;
        }
        if(GetConfigParamW(ALLOW_ONLINE_SNAPSHOT_RESTORE_OP, 
                           &g_fAllowOnlineSnapshotRestore,
                           sizeof(g_fAllowOnlineSnapshotRestore))){
            // Error means not allowed
            g_fAllowOnlineSnapshotRestore = FALSE;
        }
#endif

        // Set our selves up as not being restored right now.
        fRestoreInProgress = FALSE;

        //
        //  We don't do anything on thread attach/detach, so we don't
        //  need to be called.
        //
        DisableThreadLibraryCalls(hinstDll);

        return(FInitializeSocketServer());

    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        Assert(fFalse);
        break;
    case DLL_PROCESS_DETACH:
        if (pvReserved == NULL)
        {
            //
            //  We were called because of an FreeLibrary call.  Clean up what ever is
            //  appropriate.
            //
            FUninitializeSocketServer();
        } else
        {
            //
            //  The system will free up resources we have loaded.
            //
        }

        fReturn = FUninitializeRestore();
        if (!fReturn)
        {
            return(fFalse);
        }

        //
        //  We want to unregister ourselves if we haven't already.
        //

        if (fBackupRegistered)
        {
            HrBackupUnregister();
        }

        UnloadEventTable();

        DEBUGTERM();
        
        break;
    default:
        break;
    }
    return(fTrue);
}


#if 0
// ISSUE-2002/03/18-BrettSh - This code was mostly commented out, see deperecated code
// comments below, so we moved the function here, and someday when we're confidant we
// don't need any of this code, we'll kill it.

HRESULT
HrRBackupEnd(
    CXH *pcxh
    )
/*++

Routine Description:

    This routine is called when a backup is complete.  It terminates the server side
    operation.

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrNone;

// deprecated code
// #if 0

    CB cbDatabases;
    WSZ wszDatabases = NULL;
    WSZ wszDatabasesOrg = NULL;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) *pcxh;

    hr = HrGetDatabaseLocations(&wszDatabases, &cbDatabases);

    if (hr == hrNone)
    {
        WCHAR rgwcLogFiles[ MAX_PATH ];
        WSZ wszLogBaseEnd;
        BFT bftLocation;
        BOOLEAN fLogFound = fFalse;
        C cchLogBaseEndBuffLeft, cchBuffLeft;

        wszDatabasesOrg = wszDatabases;

        //
        //  Remember the log directory.
        //
        while (*wszDatabases)
        {
            bftLocation = *wszDatabases++;
    
            if (bftLocation == BFT_LOG_DIR)
            {
                hr = StringCchCopy(rgwcLogFiles, MAX_PATH, wszDatabases);
                if (hr) {
                    Assert(!"NOT ENOUGH BUFFER");
                    return(hr);
                }
                fLogFound = fTrue;
                break;
            }

            wszDatabases += wcslen(wszDatabases)+1;
        }

        if (fLogFound)
        {
            //
            //  Remember the start of the patch file name location.
            //
    
            wszLogBaseEnd = rgwcLogFiles+wcslen(rgwcLogFiles);
            cchLogBaseEndBuffLeft = MAX_PATH - wcslen(rgwcLogFilees);
    
            //
            //  Start back at the beginning.
            //
            wszDatabases = wszDatabasesOrg;
    
            while (*wszDatabases)
            {
                bftLocation = *wszDatabases++;

                //
                //  If this thing is a database, then it had a patch file.
                //

                if (bftLocation & BFT_DATABASE_DIRECTORY)
                {
                    WSZ wszDatabaseName;
                    //
                    //  Skip to the start of the database names.
                    //
            
                    wszDatabaseName = wcsrchr(wszDatabases, L'\\');
        
                    if (wszDatabaseName)
                    {
                        // Need to move to: StringCchCopy, but we've got problems with this ... complicated size
                        cchBuffLeft = cchLogBaseEndBuffLeft;
                        hr = StringCchCopy(wszLogBaseEnd, cchBuffLeft, wszDatabaseName);
                        if (hr) {
                            Assert(!"NOT ENOUGH BUFFER");
                            // try next file!
                            continue;
                        }
                        cchBuffLeft -= wcslen(wszDatabaseName);

                        //
                        //  Change the extension of the name from EDB to PAT
                        //
        
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-4]== L'.');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-3]== L'E' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-3]== L'e');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-2]== L'D' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-2]== L'd');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-1]== L'B' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-1]== L'b');

                        hr = StringCchCopy(&wszLogBaseEnd[wcslen(wszDatabaseName)-3], cchBuffLeft + 3, L"PAT");
                        Assert(hr == hrNone);
        
                        //
                        //  Now delete the patch file.
                        //
        
                        DeleteFileW(rgwcLogFiles);
        
                    }
        
                }

                wszDatabases += wcslen(wszDatabases)+1;
            }
        }
    }

    if (wszDatabasesOrg != NULL)
    {
        BackupFree(wszDatabasesOrg);
    }
// End of deprecated code
// #endif 

    HrDestroyCxh(*pcxh);

    MIDL_user_free(*pcxh);

    *pcxh = NULL;

    return hr;
}
#endif //#if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccbridge.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccbridge.cxx

ABSTRACT:

    KCC_BRIDGE class.

DETAILS:

    This class represents the DS notion of bridges.

CREATED:

    03/12/97    Jeff Parham (jeffparh)

REVISION HISTORY:

    06/21/00    Will Lees (wlees)

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kccdynar.hxx"
#include "kccsite.hxx"
#include "kccbridge.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kccdsa.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "dsconfig.h"
#include "dsutil.h"

#define FILENO FILENO_KCC_KCCBRIDGE


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_BRIDGE methods
//

void
KCC_BRIDGE::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized        = FALSE;
    m_pdnBridgeObject     = NULL;
    m_SiteLinkArray.RemoveAll();
}

BOOL
KCC_BRIDGE::Init(
    IN KCC_TRANSPORT *pTransport,
    IN  ENTINF *    pEntInf
    )
// Init the object given its ds properties
// Note, do not store any pointers to the memory in the pEntInf.
// It will be deallocated shortly.
{

    DWORD   iAttr, cAttr, iAttrVal;
    ATTR *  pAttr;
    DWORD   cbVal;
    BYTE *  pbVal;

    Reset();

    m_pdnBridgeObject = (DSNAME *) new BYTE [pEntInf->pName->structLen];
    memcpy( m_pdnBridgeObject, pEntInf->pName, pEntInf->pName->structLen );

    for ( iAttr = 0, cAttr = pEntInf->AttrBlock.attrCount; 
            iAttr < cAttr; 
                iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        Assert( pAttr->attrTyp == ATT_SITE_LINK_LIST || 1 == pAttr->AttrVal.valCount ); // all should be single-valued
        Assert( pbVal );

        switch ( pAttr->attrTyp )
        {
        case ATT_SITE_LINK_LIST:
            for ( iAttrVal = 0; iAttrVal < pAttr->AttrVal.valCount; iAttrVal++ )
            {
                DSNAME *pdnSiteLink = (DSNAME *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;
                KCC_SITE_LINK *pSiteLink = pTransport->GetSiteLinkList()->GetSiteLink( pdnSiteLink );

                // Validation: Check that Site Link was loaded
                if (pSiteLink) {
                    m_SiteLinkArray.Add( pSiteLink );
                } else {
                    DPRINT2(0, "Bridge %ls references site link %ls, but not found in site link list.\n",
                            m_pdnBridgeObject->StringName,
                            pdnSiteLink->StringName );
                    LogEvent(DS_EVENT_CAT_KCC,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_KCC_BRIDGE_SITE_LINK_NOT_IN_SITE_LINK_LIST,
                             szInsertDN(m_pdnBridgeObject),
                             szInsertDN(pdnSiteLink),
                             0); 
                    // keep going
                }
            }
            // This does not need to be sorted
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    if (m_SiteLinkArray.GetCount() >= 2) {
        m_fIsInitialized = TRUE;
    } else {
        DPRINT1(0, "Site link bridge %ls does not have enough site links.\n",
                m_pdnBridgeObject->StringName );
        LogEvent(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_SITE_LINK_BRIDGE_TOO_SMALL,
                 szInsertDN(m_pdnBridgeObject),
                 0,
                 0); 

        delete [] m_pdnBridgeObject;
        m_pdnBridgeObject = NULL;
    }

    return m_fIsInitialized;
}

BOOL
KCC_BRIDGE::InitForKey(
    IN  DSNAME   *    pdnBridge
    )
//
// Init a KCC_BRIDGE object for use as a key (i.e., solely for comparison use
// by bsearch()).
//
// WARNING: The DSNAME argument pdnSite must be valid for the lifetime of this
// object!
//
{
    Reset();

    m_pdnBridgeObject = pdnBridge;

    m_fIsInitialized = TRUE;

    return TRUE;
}


BOOL
KCC_BRIDGE::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

PDSNAME
KCC_BRIDGE::GetObjectDN()
{
    ASSERT_VALID( this );

    return m_pdnBridgeObject;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_BRIDGE_LIST methods
//

BOOL
KCC_BRIDGE_LIST::IsValid()
//
// Is this object internally consistent?
//
{
    return m_fIsInitialized;
}

BOOL
KCC_BRIDGE_LIST::Init(
    IN KCC_TRANSPORT *pTransport
    )
{

    ATTR      rgAttrs[] =
    {
        { ATT_SITE_LINK_LIST, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    // Find all the site objects.
    DSNAME * pdnBridgeCat = DsGetDefaultObjCategory(CLASS_SITE_LINK_BRIDGE);

    ULONG               dirError;
    FILTER              filtObjCat;
    SEARCHRES *         pResults;
    ENTINFLIST *        pEntInfList;

    // Clear the member variables
    Reset();

    Assert(NULL != pdnBridgeCat);

    // Set up the search filter
    memset( &filtObjCat, 0, sizeof( filtObjCat ) );
    filtObjCat.choice                  = FILTER_CHOICE_ITEM;
    filtObjCat.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnBridgeCat->structLen;
    filtObjCat.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnBridgeCat;

    dirError = KccSearch(
        pTransport->GetDN(),
        SE_CHOICE_IMMED_CHLDRN,
        &filtObjCat,
        &Sel,
        &pResults
        );

    if ( 0 != dirError )
    {
        KCC_LOG_SEARCH_FAILURE( pTransport->GetDN(), dirError );

        return FALSE;
    }
    else
    {
        if ( 0 == pResults->count )
        {
           DPRINT1( 1, "No bridge objects found for transport %ls.\n",
               pTransport->GetDN() );
        }
        else
        {
            for ( pEntInfList = &pResults->FirstEntInf;
                  NULL != pEntInfList;
                  pEntInfList = pEntInfList->pNextEntInf
                )
            {
                KCC_BRIDGE * pBridge = new KCC_BRIDGE;

                if ( pBridge->Init( pTransport, &pEntInfList->Entinf ) )
                {
                    m_BridgeArray.Add( pBridge );
                } else {
                    delete pBridge;
                    // Error already logged
                    // Keep going
                }
            }
        }

        // On debug builds we hold on to the search results in order to
        // make debugging DirSearch problems easier
        #if DBG
            m_dbgSearchResults = pResults;
            DirFreeSearchRes( pResults, TRUE );
        #else
            DirFreeSearchRes( pResults, FALSE );
        #endif

        // Bridge array does not need to be sorted

        m_fIsInitialized = TRUE;
    }

    return m_fIsInitialized;
}

ULONG
KCC_BRIDGE_LIST::GetCount()
//
// Get the number of site.
//
{
    return m_BridgeArray.GetCount();
}

KCC_BRIDGE *
KCC_BRIDGE_LIST::GetBridge(
        IN  DWORD   iBridge
        )
//
// Get the site requested
//
{
    ASSERT_VALID( this );

    return m_BridgeArray[iBridge];
}

KCC_BRIDGE *
KCC_BRIDGE_LIST::GetBridge(
    IN  DSNAME *  pdnBridge
    )
//
// Retrieve the KCC_BRIDGE object with the given DSNAME.
//
{
    ASSERT_VALID(this);

    return m_BridgeArray.Find( pdnBridge );
}

void
KCC_BRIDGE_LIST::Reset()
//
// Set member variables to their pre-Init() state.
//
{
    m_fIsInitialized = FALSE;
    m_BridgeArray.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\jetback\jetbcli\jetrcli.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jetrcli.c
//
//--------------------------------------------------------------------------

/*
 *  JETRCLI.C
 *  
 *  JET restore client API support.
 *  
 *  
 */
#define UNICODE 1
#include <windows.h>
#include <mxsutil.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <dsconfig.h>
#include <fileno.h>
#define FILENO    FILENO_JETBACK_JETBCLI_JETRCLI

#include "local.h"  // common functions shared by client and server

extern PSEC_WINNT_AUTH_IDENTITY_W g_pAuthIdentity;

// Forward

HRESULT
DsRestoreCheckExpiryToken(
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize
    );

HRESULT
DsRestorePrepareA(
    LPCSTR szServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbcBackupContext)
{
    HRESULT hr;
    WSZ wszServerName;

    // Parameter checking is done in the xxxW version of the routine

    if (szServerName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    wszServerName = WszFromSz(szServerName);

    if (wszServerName == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    hr = DsRestorePrepareW(wszServerName, rtFlag, 
                pvExpiryToken, cbExpiryTokenSize, phbcBackupContext);

    MIDL_user_free(wszServerName);
    return(hr);
}

// The presense of the expiry token is optional at this point.
// If it is present, it is checked.
// The context is marked whether the expiry token was checked or not

HRESULT
DsRestorePrepareW(
    LPCWSTR wszServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbcBackupContext)
{
    HRESULT hr = hrCouldNotConnect;
    pBackupContext pbcContext = NULL;
    RPC_BINDING_HANDLE hBinding = NULL;
    I iszProtSeq;

    if ( (wszServerName == NULL) ||
         (phbcBackupContext == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    *phbcBackupContext = NULL;

    pbcContext = (pBackupContext)MIDL_user_allocate(sizeof(BackupContext));

    if (pbcContext == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    pbcContext->hBinding = NULL;
    pbcContext->sock = INVALID_SOCKET;

    __try
    {
        if (!pvExpiryToken || !cbExpiryTokenSize)
        {
            // Note that expiry token was not provided.  We will check for it later
            pbcContext->fExpiryTokenChecked = FALSE;
        }
        else
        {
            // Check the supplied token and note that we saw it
            hr = DsRestoreCheckExpiryToken( pvExpiryToken, cbExpiryTokenSize );
            if (hr != hrNone) {
                __leave;
            }
            pbcContext->fExpiryTokenChecked = TRUE;
        }

        for (iszProtSeq = 0; iszProtSeq < cszProtSeq ; iszProtSeq += 1)
        {
            DWORD alRpc = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;

            if (hBinding != NULL)
            {
                RpcBindingFree(&hBinding);
            }

            hr = HrCreateRpcBinding(iszProtSeq, (WSZ) wszServerName, &hBinding);

            if (hr != hrNone)
            {
                continue;
            }

            //
            //  If we couldn't get a binding handle with this protocol sequence,
            //  try the next one.
            //

            if (hBinding == NULL)
            {
                continue;
            }

            //
            //  Enable security on the binding handle.
            //

            pbcContext->hBinding = hBinding;

            
ResetSecurity:

            hr = RpcBindingSetAuthInfo(hBinding, NULL, alRpc,
                            RPC_C_AUTHN_WINNT, (RPC_AUTH_IDENTITY_HANDLE) g_pAuthIdentity, RPC_C_AUTHZ_NAME);

            if (hr != hrNone && alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {
                alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;

                goto ResetSecurity;
            }

            if (hr != hrNone)
            {
                return hr;
            }
            //
            //  Now remote the API to the remote machine.
            //

            RpcTryExcept
            {
                hr = HrRRestorePrepare(hBinding, g_wszRestoreAnnotation, &pbcContext->cxh);
            }
            RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            {
                hr = RpcExceptionCode();

                //
                //  If the client knows about encryption, but the server doesn't,
                //  fall back to unencrypted RPC's.
                //

                if ((hr == RPC_S_UNKNOWN_AUTHN_LEVEL ||
                     hr == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                     hr == RPC_S_UNKNOWN_AUTHN_TYPE ||
                     hr == RPC_S_INVALID_AUTH_IDENTITY) &&
                    alRpc != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
                {
                    alRpc = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
                    goto ResetSecurity;
                }

                continue;
            }
            RpcEndExcept

            return(hr);
        }

        hr = hrCouldNotConnect;
    }
    __finally
    {
        if (hr != hrNone)
        {
            if (pbcContext != NULL)
            {
                if (pbcContext->hBinding != NULL)
                {
                    RpcBindingFree(&pbcContext->hBinding);
                }

                MIDL_user_free(pbcContext);
            }

            //
            //  Make sure we return null.
            //
            *phbcBackupContext = NULL;
        }
        else
        {
            //
            //  Make sure we return NON null.
            //
            Assert(pbcContext != NULL);
            *phbcBackupContext = (HBC)pbcContext;
        }
    }

    return hr;
}

/*
 -  DsRestoreGetDatabaseLocations
 -
 *  Purpose:
 *      Retrieves the locations of the databases for the restore target.
 *
 *  Parameters:
 *      hbcRestoreContext - restore context
 *      LPSTR *ppszDatabaseLocationList - Allocated buffer that holds the result of the list.
 *      LPDWORD - the size of the list
 *
 *  Returns:
 *      HRESULT - status of operation.
 *
 *  Note:
 *      This API returns only the fully qualified path of the databases, not the name
 *      of the databases.
 *
 */
HRESULT
DsRestoreGetDatabaseLocationsA(
    IN HBC hbcRestoreContext,
    OUT LPSTR *ppszDatabaseLocationList,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    WSZ wszDatabaseLocations = NULL;
    CB cbwSize;
    WSZ wszDatabaseLocation;
    CB cbDatabase = 0;
    SZ szDatabaseLocations;
    SZ szDatabase;

    // Parameter checking is done in the xxxW version of the routine

    if ( (ppszDatabaseLocationList == NULL) ||
         (pcbSize == NULL) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    hr = DsRestoreGetDatabaseLocationsW(hbcRestoreContext, &wszDatabaseLocations,
                                            &cbwSize);

    if (hr != hrNone)
    {
        return(hr);
    }

    wszDatabaseLocation = wszDatabaseLocations;

    while (*wszDatabaseLocation != TEXT('\0'))
    {
        BOOL fUsedDefault;

        cbDatabase += WideCharToMultiByte(CP_ACP, 0, wszDatabaseLocation, -1,
                                          NULL,
                                          0,
                                          "?", &fUsedDefault);
        if (cbDatabase == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszDatabaseLocations);
            return(hr);
        }

        wszDatabaseLocation += wcslen(wszDatabaseLocation)+1;
    }

    //
    //  Account for the final null in the buffer.
    //

    cbDatabase += 1;

    *pcbSize = cbDatabase;

    szDatabaseLocations = MIDL_user_allocate(cbDatabase);

    if (szDatabaseLocations == NULL)
    {
        DsBackupFree(wszDatabaseLocations);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    szDatabase = szDatabaseLocations;

    wszDatabaseLocation = wszDatabaseLocations;

    while (*wszDatabaseLocation != TEXT('\0'))
    {
        CB cbThisDatabase;
        BOOL fUsedDefault;

        //
        //  Copy over the backup file type.
        //
        *szDatabase++ = (char)*wszDatabaseLocation;

        wszDatabaseLocation++;

        cbThisDatabase = WideCharToMultiByte(CP_ACP, 0, wszDatabaseLocation, -1,
                                          szDatabase,
                                          cbDatabase,
                                          "?", &fUsedDefault);
        //
        //  Assume the conversion didn't need to use the defaults.
        //

        Assert (!fUsedDefault);

        if (cbThisDatabase == 0)
        {
            hr = GetLastError();
            DsBackupFree(wszDatabaseLocations);
            DsBackupFree(szDatabaseLocations);
            return(hr);
        }

        wszDatabaseLocation += wcslen(wszDatabaseLocation)+1;
        //
        // PREFIX: PREFIX complains that szDatabase may be uninitialized,
        // however this is impossible at this point.  We checked the return
        // value of WideCharToMultiByte and if it's zero then we return.  
        // The only way that the return value of WideCharToMultiByte could
        // be non-zero and still not initialize szDatabase is if cbDatabase
        // was zero as well.  This is impossible since cbDatabase will be 
        // atleast 1 at this point.
        //
        szDatabase += strlen(szDatabase)+1;
        cbDatabase -= cbThisDatabase;
    }

    //
    //  Double null terminate the string.
    //
    *szDatabase = '\0';

    *ppszDatabaseLocationList = szDatabaseLocations;
    DsBackupFree(wszDatabaseLocations);

    return(hr);

}
HRESULT
DsRestoreGetDatabaseLocationsW(
    IN HBC hbcRestoreContext,
    OUT LPWSTR *ppwszDatabaseLocationList,
    OUT LPDWORD pcbSize
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbcRestoreContext;

    if ( (hbcRestoreContext == NULL) ||
         (ppwszDatabaseLocationList == NULL) ||
         (pcbSize == NULL) )
    {
        return(ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept
    {
        hr = HrRRestoreGetDatabaseLocations(pbcContext->cxh, pcbSize, (SZ *)ppwszDatabaseLocationList);
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

    return(hr);
}

HRESULT
DsRestoreRegisterA(
    HBC hbc,    
    LPCSTR szCheckpointFilePath,
    LPCSTR szLogPath,
    EDB_RSTMAPA rgrstmap[],
    C crstmap,
    LPCSTR szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh
    )
{
    WSZ wszCheckpointFilePath = NULL;
    WSZ wszLogPath = NULL;
    WSZ wszBackupLogPath = NULL;
#ifdef  UNICODE_RSTMAP
    EDB_RSTMAPW *rgrstmapw = NULL;
    I irgrstmapw;
#endif
    HRESULT hr;

    // Parameter checking also done in the xxxW version of the routine

    if (szCheckpointFilePath == NULL ||
        szBackupLogPath == NULL ||
        szLogPath == NULL ||
        rgrstmap == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    try
    {

        if (szCheckpointFilePath != NULL)
        {
            wszCheckpointFilePath = WszFromSz(szCheckpointFilePath);
    
            if (wszCheckpointFilePath == NULL)
            {
                return(GetLastError());
            }
        }

        if (szLogPath != NULL)
        {
            wszLogPath = WszFromSz(szLogPath);
    
            if (wszLogPath == NULL)
            {
                return(GetLastError());
            }
        }

        if (szBackupLogPath != NULL)
        {
            wszBackupLogPath = WszFromSz(szBackupLogPath);
    
            if (wszBackupLogPath == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        rgrstmapw = MIDL_user_allocate(sizeof(EDB_RSTMAPW)*crstmap);        

        if (rgrstmapw == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // This is to make sure that no matter how we get into the finally clause
        // below that the checks for NULL will be valid.
        //
        memset(rgrstmapw, 0, sizeof(EDB_RSTMAPW)*crstmap);
        
        for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
        {
            if (rgrstmap[irgrstmapw].szDatabaseName == NULL ||
                rgrstmap[irgrstmapw].szNewDatabaseName == NULL)
            {
                return ERROR_INVALID_PARAMETER;
            }

            rgrstmapw[irgrstmapw].wszDatabaseName = WszFromSz(rgrstmap[irgrstmapw].szDatabaseName);

            if (rgrstmapw[irgrstmapw].wszDatabaseName == NULL)
            {
                return(GetLastError());
            }

            rgrstmapw[irgrstmapw].wszNewDatabaseName = WszFromSz(rgrstmap[irgrstmapw].szNewDatabaseName);

            if (rgrstmapw[irgrstmapw].wszNewDatabaseName == NULL)
            {
                return(GetLastError());
            }
        }

        hr = DsRestoreRegisterW(hbc, wszCheckpointFilePath, wszLogPath,
                                rgrstmapw,
                                crstmap, wszBackupLogPath, genLow, genHigh);

    }
    finally
    {
        if (rgrstmapw != NULL)
        {
            I irgrstmapw;

            for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
            {
                if (rgrstmapw[irgrstmapw].wszDatabaseName != NULL)
                {
                    MIDL_user_free(rgrstmapw[irgrstmapw].wszDatabaseName);
                }
                if (rgrstmapw[irgrstmapw].wszNewDatabaseName != NULL)
                {
                    MIDL_user_free(rgrstmapw[irgrstmapw].wszNewDatabaseName);
                }
            }

            MIDL_user_free(rgrstmapw);
        }

        if (wszBackupLogPath != NULL)
        {
            MIDL_user_free(wszBackupLogPath);
        }
        if (wszLogPath != NULL)
        {
            MIDL_user_free(wszLogPath);
        }
        if (wszCheckpointFilePath != NULL)
        {
            MIDL_user_free(wszCheckpointFilePath);
        }
    }

    return(hr);
}


HRESULT
DsRestoreCheckExpiryToken(
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize
    )

/*++

Routine Description:

Check an expiry token to see if it has expired.

Arguments:

    pvExpiryToken - Expiry token as returned by DsBackupPrepare
    cbExpiryTokenSize - size of token

Return Value:

    HRESULT - 
    hrNone
    hrMissingExpiryToken
    hrUnknownExpiryTokenFormat
    hrContentsExpired
    hrOutOfMemory

--*/

{
    EXPIRY_TOKEN *pToken = NULL;
    LONGLONG dsCurrentTime;
    DWORD dwDaysElapsedSinceBackup;
    HRESULT hrResult = hrNone;

    if (!pvExpiryToken || !cbExpiryTokenSize) {
        // These are required. We should fail the API, if the restore
        // doesn't pass the expiry token
        //
        return hrMissingExpiryToken;
    }

    if (cbExpiryTokenSize != sizeof(EXPIRY_TOKEN))
    {
        return hrUnknownExpiryTokenFormat;
    }           

    // Copy the token to its own aligned buffer
    pToken = (EXPIRY_TOKEN *) MIDL_user_allocate( cbExpiryTokenSize );
    if (!pToken) {
        return hrOutOfMemory;
    }
    memcpy( pToken, pvExpiryToken, cbExpiryTokenSize );

    __try {
        // Check that the expiry token is correct
        if (1 != pToken->dwVersion)
        {
            hrResult = hrUnknownExpiryTokenFormat;
            __leave;
        }           
            
        // check to see if the copy has expired or not
        dsCurrentTime = GetSecsSince1601();

        dwDaysElapsedSinceBackup = (DWORD) ((dsCurrentTime - pToken->dsBackupTime) / (24 * 3600));

        if (dwDaysElapsedSinceBackup >= pToken->dwTombstoneLifeTimeInDays)
        {
            hrResult = hrContentsExpired;
            __leave;
        }            

        hrResult = hrNone;
    } __finally {
        MIDL_user_free( pToken );
    }

    return hrResult;
} /* DsCheckExpiryToken */

HRESULT
DsRestoreRegisterW(
    HBC hbc,    
    LPCWSTR szCheckpointFilePath,
    LPCWSTR szLogPath,
    EDB_RSTMAPW rgrstmap[],
    C crstmap,
    LPCWSTR szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbc;
    I irgrstmapw;

    // hbc is allowed to be null
    if ( (szCheckpointFilePath == NULL) ||
         (szLogPath == NULL) ||
         (rgrstmap == NULL) ||
         (szBackupLogPath == NULL)
        ) {
        return ERROR_INVALID_PARAMETER;
    }

    for (irgrstmapw = 0 ; irgrstmapw < crstmap ; irgrstmapw += 1)
    {
        if (rgrstmap[irgrstmapw].wszDatabaseName == NULL ||
            rgrstmap[irgrstmapw].wszNewDatabaseName == NULL)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    RpcTryExcept

    // Use the presence of the context to determine if we go remote
    if (hbc) {

        //
        // Perform the operation remotely
        //

        // Check that an expiry token was supplied and checked

        if (!pbcContext->fExpiryTokenChecked) {
            return hrMissingExpiryToken;
        }

        //
        //  Now tell the server side to prepare for a backup.
        //

        hr = HrRRestoreRegister(pbcContext->cxh,
                        (WSZ) szCheckpointFilePath,
                        (szLogPath ? (WSZ) szLogPath : (WSZ) szCheckpointFilePath),
                        crstmap,
                        rgrstmap,
                        (szBackupLogPath ? (WSZ) szBackupLogPath : (WSZ) szCheckpointFilePath),
                        genLow,
                        genHigh
                        );

    } else {

        //
        // Perform the operation locally
        //

        hr = HrLocalRestoreRegister(
                        (WSZ) szCheckpointFilePath,
                        (szLogPath ? (WSZ) szLogPath : (WSZ) szCheckpointFilePath),
                        rgrstmap,
                        crstmap,
                        (szBackupLogPath ? (WSZ) szBackupLogPath : (WSZ) szCheckpointFilePath),
                        genLow,
                        genHigh
                        );


    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    RpcEndExcept;

    return(hr);

}
  

HRESULT
DsRestoreRegisterComplete(
    HBC hbc,    
    HRESULT hrRestore
    )
{
    HRESULT hr;
    pBackupContext pbcContext = (pBackupContext)hbc;

    // Parameter checking: hbc allowed to be null

    RpcTryExcept
    // Use the presence of the context to determine if we go remote
    if (hbc) {
        //
        //  Now tell the server side to prepare for a backup.
        //

        hr = HrRRestoreRegisterComplete(pbcContext->cxh,
                        hrRestore
                        );
    } else {
        //
        // Perform the operation locally
        //

        hr = HrLocalRestoreRegisterComplete(
                        hrRestore
                        );
    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
        //
        //  Return the error from the RPC if it fails.
        //
        return(RpcExceptionCode());
    RpcEndExcept;

    return(hr);

}

HRESULT
DsRestoreEnd(
    HBC hbcBackupContext
    )
{
    HRESULT hr = hrNone;
    pBackupContext pbcContext = (pBackupContext)hbcBackupContext;

    if (hbcBackupContext == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pbcContext->hBinding != NULL)
    {
        RpcTryExcept
            //
            //  Now tell the server side to prepare for a backup.
            //

            hr = HrRRestoreEnd(&pbcContext->cxh);

            //
            //  We're done with the RPC binding now.
            //
            RpcBindingFree(&pbcContext->hBinding);
        RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
            //
            //  Return the error from the RPC if it fails.
            //
            return(RpcExceptionCode());
        RpcEndExcept;
    }

    MIDL_user_free(pbcContext);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kccconn.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kccconn.cxx

ABSTRACT:

    KCC_CONNECTION and KCC_CONNECTION_LIST classes.

DETAILS:

    These classes represent a single NTDS-Connection DS object and a
    collection thereof, resp.

    NTDS-Connection objects represent a uni-directional replication link,
    with the parent server object being the destination and the From-Server
    attribute holding the source.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <sddl.h>
#include "kcc.hxx"
#include "kcctrans.hxx"
#include "kccconn.hxx"
#include "kcclink.hxx"
#include "kccdsa.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"
#include "kcccref.hxx"
#include "kccstale.hxx"
#include "kccsite.hxx"
#include <dsutil.h>
#include <winsock.h>                    // host <--> net long conversions

extern "C"
{
#include "permit.h"
}


#define FILENO FILENO_KCC_KCCCONN


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION methods
//

ATTR KCC_CONNECTION::AttrList[7] = {
    { ATT_ENABLED_CONNECTION,           { 0, NULL } },
    { ATT_FROM_SERVER,                  { 0, NULL } },
    { ATT_OPTIONS,                      { 0, NULL } },
    { ATT_SCHEDULE,                     { 0, NULL } },
    { ATT_WHEN_CREATED,                 { 0, NULL } },
    { ATT_TRANSPORT_TYPE,               { 0, NULL } },
    { ATT_MS_DS_REPLICATES_NC_REASON,   { 0, NULL } }
    // If adding or removing entries from this list, be sure to update array
    // size in kccconn.hxx.
};

DSNAME *
KCC_CONNECTION::GetConnectionDN()
//
// Retrieve the DN of the corresponding NTDS-Connection DS object.
//
{
    ASSERT_VALID( this );
    return m_pdnConnection;
}

DSNAME *
KCC_CONNECTION::GetSourceDSADN()
//
// Retrieve the DN of the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA->GetDsName();
}

KCC_DSA *
KCC_CONNECTION::GetSourceDSA()
//
// Retrieve the source DSA's NTDS-DSA DS object.
//
{
    ASSERT_VALID( this );
    return m_pSourceDSA;
}

DSNAME *
KCC_CONNECTION::GetSourceSiteDN()
//
// Retrieve the DN of the source DSA's site object.
//
{
    ASSERT_VALID(this);

    return m_pSourceDSA->GetSiteDN();
}

DSNAME *
KCC_CONNECTION::GetDestinationDSADN()
//
// Retrieve the DN of the destination DSA's NTDS-DSA DS object.
//
{
    return GetDestinationDSA()->GetDsName();
}

KCC_DSA *
KCC_CONNECTION::GetDestinationDSA()
//
// Get the destination DSA object
//
{
    DSNAME *pdnDestinationDSA;
    
    ASSERT_VALID(this);
    
    if (NULL == m_pDestDSA) {
        Assert(m_pdnConnection && "Can't currently call this if obj not yet added!");
    
        // Destination ntdsDsa is the parent of the ntdsConnection object.
        pdnDestinationDSA = (DSNAME *) new BYTE[m_pdnConnection->structLen];
        TrimDSNameBy(m_pdnConnection, 1, pdnDestinationDSA);

        // We can quickly find the KCC_DSA object in our global list of DSAs.
        m_pDestDSA = gpDSCache->GetGlobalDSAListByString()
                        ->GetDsa( pdnDestinationDSA, NULL );
        if( !m_pDestDSA ) {
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_DESTINATION_DSA_NOT_FOUND,
                szInsertDN( m_pdnConnection ),
                0,
                0
                );
            KCC_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, 0);
        }
    }

    return m_pDestDSA;
}

BOOL
KCC_CONNECTION::IsEnabled()
//
// Is the connection enabled?
//
{
    ASSERT_VALID( this );
    return !!m_fIsEnabled;
}

BOOL
KCC_CONNECTION::IsIntrasite()
//
// Is this an intra-site connection?
// This is determined by checking if the source DSA is in the local site.
//
{
    // Note that we implicitly assume here that all connections loaded have their
    // destination DSA in the local site. In the future, we may load connections
    // from other sites as well.
    return NamePrefix( gpDSCache->GetLocalSite()->GetObjectDN(), GetSourceDSADN() );
}

BOOL
KCC_CONNECTION::IsGenerated()
//
// Was the connection generated by the KCC (as opposed to being created by
// an administrator)?
//
{
    ASSERT_VALID( this );
    return !!( m_dwOptions & NTDSCONN_OPT_IS_GENERATED );
}

BOOL
KCC_CONNECTION::IsTwoWaySynced()
//
// Does completion of a sync of this NC trigger a sync in the opposite
// direction?
//
{
    ASSERT_VALID(this);
    return !!(m_dwOptions & NTDSCONN_OPT_TWOWAY_SYNC);
}

BOOL
KCC_CONNECTION::IsCompressionEnabled()
//
// Is compression enabled over this connection? 
// For intra-site connections, compression is never enabled.
// For inter-site connections, compression is enabled unless the option
// has been set to disable it.
//
{
    ASSERT_VALID(this);
    if( IsIntrasite() ) {
        return FALSE;
    } else {
        return !(m_dwOptions & NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION);
    }
}

BOOL
KCC_CONNECTION::IsUserOwnedSchedule()
//
// Does this connection have a user-owned schedule? If so, the KCC should never
// touch the schedule.
//
// If this connection is not KCC-generated, this method always returns FALSE.
//
{
    ASSERT_VALID(this);
    if( !IsGenerated() ) {
        return FALSE;
    } else {
        return !!(m_dwOptions & NTDSCONN_OPT_USER_OWNED_SCHEDULE);
    }
}

BOOL
KCC_CONNECTION::UsesNotification()
//
// Override the default notification based on intra/inter site.
// Force the notification to be as specified
//
{
    BOOL fUsesNotification;
    ASSERT_VALID(this);

    if (m_dwOptions & NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT) {
        fUsesNotification = !!(m_dwOptions & NTDSCONN_OPT_USE_NOTIFY);
    } else {
        // True if in same site
        fUsesNotification = IsIntrasite();
    }

    return fUsesNotification;
}

TOPL_SCHEDULE
KCC_CONNECTION::GetSchedule()
//
// Retrieve the periodic replication schedule.
//
{
    ASSERT_VALID( this );
    return m_toplSchedule;
}

KCC_CONNECTION &
KCC_CONNECTION::SetConnectionDN(
    IN  DSNAME *    pdn
    )
//
// Set the DN of the corresponding NTDS-Connection DS object.
//
{
    m_pdnConnection = (DSNAME *) new BYTE[ pdn->structLen ];
    memcpy( m_pdnConnection, pdn, pdn->structLen );

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetSourceDSA(
    IN KCC_DSA *pDsa
    )
//
// Set the DN of the source DSA's NTDS-DSA DS object.
//
{
    m_pSourceDSA = pDsa;

    return *this;
}
    
KCC_CONNECTION &
KCC_CONNECTION::SetEnabled(
    IN  BOOL    fIsEnabled
    )
//
// Set the is-enabled flag to the given value.
//
{
    m_fIsEnabled = !!fIsEnabled;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetGenerated(
    IN  BOOL    fIsGenerated
    )
//
// Set the is-generated flag to the given value.
//
{
    if ( fIsGenerated )
    {
        m_dwOptions |= NTDSCONN_OPT_IS_GENERATED;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_IS_GENERATED;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetOverrideNotification(
    IN  BOOL    fUsesNotification
    )
//
// Override the default notification of the connection
//
{
    m_dwOptions |= NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT;
    if ( fUsesNotification )
    {
        m_dwOptions |= NTDSCONN_OPT_USE_NOTIFY;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_USE_NOTIFY;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetTwoWaySync(
    IN  BOOL    fIsTwoWaySync
    )
//
// Set the TwoWaySync'd state of the connection
//
{
    if ( fIsTwoWaySync )
    {
        m_dwOptions |= NTDSCONN_OPT_TWOWAY_SYNC;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_TWOWAY_SYNC;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetDisableIntersiteCompression(
    IN  BOOL    fDisableCompression
    )
//
// If this flag is set, compression of replication traffic across
// this connection is disabled. This function may only be called
// for inter-site connections.
//
{
    if ( fDisableCompression )
    {
        m_dwOptions |= NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }
    else
    {
        m_dwOptions &= ~NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION;
    }

    m_fUpdatedOptions = TRUE;

    return *this;
}

KCC_CONNECTION &
KCC_CONNECTION::SetSchedule(
    IN  TOPL_SCHEDULE toplSchedule
    )
//
// Set the periodic replication schedule.
//
{
    Assert( ToplScheduleValid(toplSchedule) );
    Assert( !IsUserOwnedSchedule() );
    m_toplSchedule = toplSchedule;
    m_fUpdatedSchedule = TRUE;
    return *this;
}

BOOL
KCC_CONNECTION::IsValid()
//
// Is this object internally consistent?
//
{
    return ( NULL!=m_pSourceDSA );
}

BOOL
KCC_CONNECTION::Init(
    IN  ENTINF *    pEntInf
    )
//
// Initialize the internal object from an ENTINF describing a corresponding
// NTDS-Connection DS object.
//
{
    DWORD               iAttr, iAttrVal;
    ATTR                *pAttr;
    DWORD               cbVal;
    BYTE                *pbVal;
    DSNAME              *pdnSourceDSA = NULL;
    KCC_TRANSPORT_LIST  *pTransportList = gpDSCache->GetTransportList();
    KCC_TRANSPORT       *pTransport = NULL;
    
    Reset();

    m_pdnConnection = (DSNAME *) new BYTE[ pEntInf->pName->structLen ];
    memcpy( m_pdnConnection, pEntInf->pName, pEntInf->pName->structLen );
    DPRINT1( 5, "Parsing connection %ls.\n", m_pdnConnection->StringName );

    for ( iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++ )
    {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];
        cbVal = pAttr->AttrVal.pAVal->valLen;
        pbVal = pAttr->AttrVal.pAVal->pVal;

        switch ( pAttr->attrTyp )
        {
        case ATT_ENABLED_CONNECTION:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_fIsEnabled ) );
            memcpy( &m_fIsEnabled, pbVal, sizeof( m_fIsEnabled ) );

            // Validation: Ensure value is 0 or 1
            m_fIsEnabled = !! m_fIsEnabled;
            break;

        case ATT_FROM_SERVER:
            Assert( 1 == pAttr->AttrVal.valCount );
            pdnSourceDSA = (DSNAME*) pbVal;

            // Defense against deleted DSA's. We look up the DSA by guid in the cache.
            // The DSA should not be in the cache if it is deleted, since the
            // cache is populated using a search of the site servers container which
            // does not pick up deleted objects.

            // Validation: Convert DSNAME to KCC_DSA*
            // m_pSourceDSA may be null if DSA not found, deleted, etc. Checked below
            // with IsValid() and by returning FALSE.
            m_pSourceDSA = gpDSCache->GetGlobalDSAListByGUID()->GetDsa( pdnSourceDSA );
            break;

        case ATT_OPTIONS:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_dwOptions ) );
            memcpy( &m_dwOptions, pbVal, sizeof( m_dwOptions ) );

            // Validation: Not semantically validated
            break;

        case ATT_SCHEDULE:
            Assert( 1 == pAttr->AttrVal.valCount );

            // Validation: Check that PSCHEDULE and byte count are OK
            if( IS_VALID_SCHEDULE((PSCHEDULE) pbVal, cbVal) ) {

                // Schedule is okay. Load it into the cache and store it in
                // this connection object.
                m_toplSchedule = ToplScheduleImport(
                    gpDSCache->GetScheduleCache(),
                    (PSCHEDULE) pbVal );

            } else {
                // improper schedule format - default schedule used; complain 
                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_CHK_BAD_SCHEDULE,
                    szInsertDN( m_pdnConnection ),
                    0, 0 );
                DPRINT1( 0,
                    "The value of the schedule attribute on the connection "
                        "object %ls is invalid.  A default schedule will be "
                        "substituted.\n",
                    m_pdnConnection->StringName );

                m_toplSchedule = NULL;
            }
            break;

        case ATT_WHEN_CREATED:
            Assert( 1 == pAttr->AttrVal.valCount );
            Assert( cbVal == sizeof( m_timeCreated ) );
            memcpy( &m_timeCreated, pbVal, sizeof( m_timeCreated ) );
            // Validation: Not semantically validated
            break;

        case ATT_TRANSPORT_TYPE:
            Assert( 1 == pAttr->AttrVal.valCount );
            m_pdnTransport = (DSNAME*) new BYTE[ cbVal ];
            memcpy( m_pdnTransport, pbVal, cbVal );
            // Validation: transportType is checked against known transports below.
            break;

        case ATT_MS_DS_REPLICATES_NC_REASON:
            m_pOldNCs = new DN_AND_REASON[ pAttr->AttrVal.valCount ];
            m_cOldNCs = pAttr->AttrVal.valCount;
            for ( iAttrVal = 0; iAttrVal < m_cOldNCs; iAttrVal++ )
            {
                SYNTAX_DISTNAME_BINARY *pdnb;
                DSNAME *pdn;
                SYNTAX_ADDRESS *psa;
                DWORD  dwTemp;

                pdnb = (SYNTAX_DISTNAME_BINARY *) pAttr->AttrVal.pAVal[ iAttrVal ].pVal;

                // Retrieve the dsname part.
                pdn = NAMEPTR(pdnb);
                m_pOldNCs[ iAttrVal ].dn = (DSNAME *) new BYTE [pdn->structLen];
                memcpy( m_pOldNCs[ iAttrVal ].dn, pdn, pdn->structLen );
                // Validation: DN not semantically validated
                
                psa = DATAPTR(pdnb);
                
                // Validation: Binary data is syntactically validated but not
                // semantically validated.
                // Check that the binary blob is at least as long as we expect.
                Assert(psa->structLen >= 2*sizeof(DWORD)); // Length + Data DWORD
                if( psa->structLen < 2*sizeof(DWORD) ) {
                    KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
                }
                
                // Copy the data to a temp variable to avoid alignment problems,
                // then convert to 'host' byte-ordering.
                memcpy(&dwTemp, &psa->byteVal[0], sizeof(DWORD));
                m_pOldNCs[ iAttrVal ].reason = (DWORD) ntohl(dwTemp);
            }
            break;

        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    if ( IsValid() )
    {
        // A connection object must store the DN of its destination DSA,
        // (including the GUID). In order to find the DN+GUID, we trim the name and
        // read the directory. This presents a race condition, since the connection
        // object and the destination DSA are read from the directory in two
        // transations. If we postpone construction of the destination DSA DN until
        // it is needed (i.e. read on demand) then we increase the severity of the
        // race condition. We mitigate the severity by reading it as soon as possible.
        GetDestinationDSADN();

        // We don't want to permit KCC-Generated connection with the NEVER
        // schedule. If we see this, we set it to the Always schedule.
        if( IsGenerated() && ToplScheduleDuration(m_toplSchedule)==0 ) {
            m_toplSchedule = ToplGetAlwaysSchedule( gpDSCache->GetScheduleCache() );
        }

        // Check the transportType attribute
        if( NULL!=m_pdnTransport ) {
            pTransport = pTransportList->GetTransport(m_pdnTransport);
            if( NULL==pTransport ) {
                // The connection had a non-NULL but invalid transport DN.
                // We update the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                LogEvent(DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_KCC_CONNECTION_BAD_TRANSPORT,
                    szInsertDN(m_pdnConnection),
                    szInsertDN(m_pdnTransport),
                    0);

                // Remove bad transportType DN, update DS object too.
                delete[] m_pdnTransport;
                SetTransport( gpDSCache->GetIPTransportDN() );
                UpdateDS();
            }
        }

        return TRUE;
    } else {
        // WARNING: A FALSE return implies the KCC_CONNECTION_LIST::Init()
        // routine should delete this NTDS-Connection object from the DIT.
        DPRINT1( 4, "Connection %ls is invalid.\n", m_pdnConnection->StringName );
        return FALSE;
    }
}

// When we add a connection, it will have at most 7 attributes.
#define NUM_CONNECTION_ATTRS 7

DWORD
KCC_CONNECTION::Add(
    DSNAME *    pdnDestinationDSA,
    DWORD       dsid
    )
//
// Convert to an NTDS-Connection DS object and write it to the DS.
// If the connection object DN has not been set, it will be constructed
// from the pdnDSA argument and a unique RDN.
//
{
    ULONG           dirError;
    DWORD           WinError;
    DWORD           dwConnectionClass = CLASS_NTDS_CONNECTION;
    DWORD           dwSystemFlags = FLAG_CONFIG_ALLOW_MOVE;
    ATTRBLOCK       AttrBlock;
    ATTR            rgAttr[ NUM_CONNECTION_ATTRS ];
    ATTRVALBLOCK    rgAttrValBlock[ NUM_CONNECTION_ATTRS ];
    ATTRVAL         rgAttrVal[ NUM_CONNECTION_ATTRS ];
    DSNAME *        pdnSourceDSA;

    ASSERT_VALID( this );

    Assert( NTDSCONN_OPT_IS_GENERATED & m_dwOptions );

    if ( NULL == m_pdnConnection )
    {
        //
        // Generate unique RDN.
        //

        RPC_STATUS      rpcStatus;
        UUID            uuid;
        WCHAR *         pwszUuid;

        rpcStatus = UuidCreate( &uuid );
        
        // Note: Global uniqueness is not really critical here -- we only seek
        // to make sure the RDN is unique in its container.  Thus, "local only"
        // UUIDs are okay.  (If a collision occurs, the add will fail, and we'll
        // try again next time -- with a different UUID.)

        if (    ( RPC_S_OK              != rpcStatus )
             && ( RPC_S_UUID_LOCAL_ONLY != rpcStatus )
           )
        {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        rpcStatus = UuidToStringW( &uuid, &pwszUuid );
        if( RPC_S_OK!=rpcStatus || NULL==pwszUuid) {
            KCC_EXCEPT( rpcStatus, 0 );
        }

        __try {

            DWORD cbConnectionDN =  pdnDestinationDSA->structLen +
                          ( MAX_RDN_SIZE+MAX_RDN_KEY_SIZE )*sizeof(WCHAR);
            m_pdnConnection = (DSNAME *) new BYTE[ cbConnectionDN ];
            AppendRDN( pdnDestinationDSA,
                      m_pdnConnection,
                      cbConnectionDN,
                      pwszUuid,
                      0,
                      ATT_COMMON_NAME );

        } __finally {
            // Free the string representation of the UUID
            RpcStringFreeW(&pwszUuid);
        }
        
    }

    //
    // Add NTDS-Connection object to the DS.
    //
    ULONG cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    PSCHEDULE pSchedule;
    Assert( scheduleCache );
    pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
    Assert( pSchedule );

    pdnSourceDSA = m_pSourceDSA->GetDsName();

    AttrBlock.attrCount = NUM_CONNECTION_ATTRS;
    AttrBlock.pAttr     = new ATTR [AttrBlock.attrCount];

    AttrBlock.pAttr[ 0 ].attrTyp          = ATT_ENABLED_CONNECTION;
    AttrBlock.pAttr[ 0 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 0 ].AttrVal.pAVal    = &rgAttrVal[ 0 ];
    rgAttrVal[ 0 ].valLen                 = sizeof( m_fIsEnabled );
    rgAttrVal[ 0 ].pVal                   = (BYTE *) &m_fIsEnabled;

    AttrBlock.pAttr[ 1 ].attrTyp          = ATT_FROM_SERVER;
    AttrBlock.pAttr[ 1 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 1 ].AttrVal.pAVal    = &rgAttrVal[ 1 ];
    rgAttrVal[ 1 ].valLen                 = pdnSourceDSA->structLen;
    rgAttrVal[ 1 ].pVal                   = (BYTE *) pdnSourceDSA;

    AttrBlock.pAttr[ 2 ].attrTyp          = ATT_OPTIONS;
    AttrBlock.pAttr[ 2 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 2 ].AttrVal.pAVal    = &rgAttrVal[ 2 ];
    rgAttrVal[ 2 ].valLen                 = sizeof( m_dwOptions );
    rgAttrVal[ 2 ].pVal                   = (BYTE *) &m_dwOptions;

    AttrBlock.pAttr[ 3 ].attrTyp          = ATT_SCHEDULE;
    AttrBlock.pAttr[ 3 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 3 ].AttrVal.pAVal    = &rgAttrVal[ 3 ];
    rgAttrVal[ 3 ].valLen                 = cbSchedule;
    rgAttrVal[ 3 ].pVal                   = (BYTE *) pSchedule;

    AttrBlock.pAttr[ 4 ].attrTyp          = ATT_OBJECT_CLASS;
    AttrBlock.pAttr[ 4 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 4 ].AttrVal.pAVal    = &rgAttrVal[ 4 ];
    rgAttrVal[ 4 ].valLen                 = sizeof( dwConnectionClass );
    rgAttrVal[ 4 ].pVal                   = (BYTE *) &dwConnectionClass;

    AttrBlock.pAttr[ 5 ].attrTyp          = ATT_SYSTEM_FLAGS;
    AttrBlock.pAttr[ 5 ].AttrVal.valCount = 1;
    AttrBlock.pAttr[ 5 ].AttrVal.pAVal    = &rgAttrVal[ 5 ];
    rgAttrVal[ 5 ].valLen                 = sizeof( dwSystemFlags );
    rgAttrVal[ 5 ].pVal                   = (BYTE *) &dwSystemFlags;

    if ( m_pdnTransport )
    {
        AttrBlock.pAttr[ 6 ].attrTyp          = ATT_TRANSPORT_TYPE;
        AttrBlock.pAttr[ 6 ].AttrVal.valCount = 1;
        AttrBlock.pAttr[ 6 ].AttrVal.pAVal    = &rgAttrVal[ 6 ];
        rgAttrVal[ 6 ].valLen                 = m_pdnTransport->structLen;
        rgAttrVal[ 6 ].pVal                   = (BYTE *) m_pdnTransport;
    }
    else
    {
        //
        // No transport type attribute to add
        //
        AttrBlock.attrCount--;
    }


    dirError = KccAddEntry( m_pdnConnection, &AttrBlock );
    if (dirError != 0 ) {
        KCC_LOG_ADDENTRY_FAILURE( m_pdnConnection, dirError );
    }
    
    if ( 0 != dirError )
    {
        DPRINT1( 0, "Failed to add connection object, error %d.\n", dirError );
    
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
            szInsertDN(GetSourceDSADN()),
            szInsertDN(pdnDestinationDSA),
            szInsertHex(dsid)
            ); 
    }
    else
    {
        DWORD dwLogCode;

        DPRINT3( 3,
                 "Created connection object, localdsa:%ws, sourcedsa:%ws, transportdn:%ws\n",
                 pdnDestinationDSA->StringName,
                 GetSourceDSADN()->StringName,
                 GetTransportDN()->StringName
            );

        if (m_ReasonForConnection & KCC_SITE_FAILOVER_TOPOLOGY) {
            dwLogCode = DIRLOG_KCC_CONNECTION_SITE_FAILOVER_CREATED;
        } else if (m_ReasonForConnection & KCC_SERVER_FAILOVER_TOPOLOGY) {
            dwLogCode = DIRLOG_KCC_CONNECTION_SERVER_FAILOVER_CREATED;
        } else {
            dwLogCode = DIRLOG_KCC_CONNECTION_OBJECT_CREATED;
        }
            
        LogEvent8(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            dwLogCode,
            szInsertDN(GetSourceDSADN()),
            szInsertDN(pdnDestinationDSA),
            szInsertHex(m_ReasonForConnection),
            szInsertHex(dsid),
            NULL, NULL, NULL, NULL
            );
            
    }

    return dirError;
}


DWORD
KCC_CONNECTION::UpdateDS()
//
// Update the ntdsConnection object in the DS with recent changes made to the
// in-memory KCC_CONNECTION representation.
//
{
    ATTRMODLIST rgMods[3] = {0};
    ATTRVAL     rgAttrVals[3] = {0};
    DWORD       dirError;
    USHORT      cNumMods = 0;
    const DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    PSCHEDULE   pSchedule;


    Assert(m_fUpdatedOptions
           || m_fUpdatedSchedule 
           || m_fUpdatedTransport);

    if (m_fUpdatedOptions) {
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_OPTIONS;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = sizeof(m_dwOptions);
        rgAttrVals[cNumMods].pVal   = (BYTE *) &m_dwOptions;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
    
    if (m_fUpdatedSchedule) {
        TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
        Assert( scheduleCache );
        pSchedule = ToplScheduleExportReadonly( scheduleCache, m_toplSchedule );
        Assert( pSchedule );
        
        rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
        rgMods[cNumMods].AttrInf.attrTyp          = ATT_SCHEDULE;
        rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
        rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
        
        rgAttrVals[cNumMods].valLen = cbSchedule;
        rgAttrVals[cNumMods].pVal   = (BYTE *) pSchedule;

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }

    if (m_fUpdatedTransport) {
        if (NULL == m_pdnTransport) {
            // Transport removed (i.e., changed from inter-site to intra-site).
            rgMods[cNumMods].choice          = AT_CHOICE_REMOVE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp = ATT_TRANSPORT_TYPE;
        } else {
            // Transport added/updated.
            rgMods[cNumMods].choice                   = AT_CHOICE_REPLACE_ATT;
            rgMods[cNumMods].AttrInf.attrTyp          = ATT_TRANSPORT_TYPE;
            rgMods[cNumMods].AttrInf.AttrVal.valCount = 1;
            rgMods[cNumMods].AttrInf.AttrVal.pAVal    = &rgAttrVals[cNumMods];
            
            rgAttrVals[cNumMods].valLen = m_pdnTransport->structLen;
            rgAttrVals[cNumMods].pVal   = (BYTE *) m_pdnTransport;
        }

        if (cNumMods) {
            rgMods[cNumMods-1].pNextMod = &rgMods[cNumMods];
        }

        cNumMods++;
    }
        
    Assert(cNumMods <= ARRAY_SIZE(rgMods));
    Assert(cNumMods <= ARRAY_SIZE(rgAttrVals));

    dirError = KccModifyEntry(GetConnectionDN(), cNumMods, rgMods);

    if (0 == dirError) {
        // Success.
        DPRINT1(0, "Updated connection object %ws.\n",
                GetConnectionDN()->StringName);
        m_fUpdatedOptions = m_fUpdatedSchedule = m_fUpdatedTransport = FALSE;
    } else {
        // Failure.
        KCC_LOG_MODIFYENTRY_FAILURE(GetConnectionDN(), dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    return dirError;
}


KCC_CONNECTION &
KCC_CONNECTION::SetTransport(
        IN DSNAME *pdn
        )
// Set transport associated with this connection.
{
    m_pdnTransport = pdn;

    m_fUpdatedTransport = TRUE;
    
    return *this;
}

DSNAME*
KCC_CONNECTION::GetTransportDN()
// Get the transport associated with this connection.
{
    return m_pdnTransport;
}

DWORD
KCC_CONNECTION::Remove(
    DWORD dsid
    )
//
// Remove the connection object from the ds. Note that the in memory copy of the
// object remains.
//
{
    ULONG dirError;

    ASSERT_VALID( this );
    Assert( IsGenerated() );

    dirError = KccRemoveEntry( m_pdnConnection );
    if (0 == dirError) {
        // Success.
        gConnectionDeletionCache.Add( this );

        DPRINT1(0, "Deleted connection object %ls from the database.\n",
                GetConnectionDN()->StringName);
        
        LogEvent8(DS_EVENT_CAT_KCC,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_KCC_CONNECTION_OBJECT_DELETED,
                 szInsertDN(GetSourceDSADN()),
                 szInsertDN(GetDestinationDSADN()),
                 szInsertHex(m_ReasonForConnection),
                 szInsertHex(dsid),
                 NULL, NULL, NULL, NULL);
    }
    else {
        // Failure.
        KCC_LOG_REMOVEENTRY_FAILURE( m_pdnConnection, dirError );

        LogEvent8(DS_EVENT_CAT_KCC,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED,
                  szInsertDN(GetSourceDSADN()),
                  szInsertDN(GetDestinationDSADN()),
                  szInsertThStateErrMsg(),
                  szInsertHex(dsid),
                  NULL, NULL, NULL, NULL);
    }

    return dirError;
}

void
KCC_CONNECTION::UpdateLink(
    IN  KCC_LINK *              plink,
    IN  KCC_CROSSREF *          pCrossRef,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Update pre-existing repsFrom link to reflect the state of this connection
// object.
//
{
    BOOL fUpdateLink = FALSE;
    BOOL fIsDSRPCReplica;
    BOOL fInSameSite;
    DWORD cbSchedule = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    TOPL_SCHEDULE_CACHE scheduleCache = gpDSCache->GetScheduleCache();
    
    ASSERT_VALID( this );
    Assert( scheduleCache );
    Assert(0 == memcmp(plink->GetDSAUUID(), &GetSourceDSADN()->Guid, sizeof(GUID)));

    if (IsGenerated() && IsIntrasite()) {
        // Auto-generated, intra-site connection.
        
        Assert( gfIntrasiteSchedInited );
        if (!ToplScheduleIsEqual(scheduleCache,
                                 m_toplSchedule,
                                 gpIntrasiteSchedule))
        {
            // The auto-generated, intra-site connection object has the wrong
            // schedule.  Update it.
            ATTRMODLIST rgMods[1] = {0};
            ATTRVAL     AttrVal;
            ULONG       dirError;
        
            Assert( gfIntrasiteSchedInited );
            if( IsUserOwnedSchedule() ) {
                // Don't update the schedule because the connection has a
                // user-owned schedule
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_KCC_CONNECTION_SCHEDULE_NOT_UPDATED,
                         szInsertDN(GetConnectionDN()),
                         0,0);
            } else {
                SetSchedule(gpIntrasiteSchedule);
            }

            UpdateDS();

            DPRINT1(0, "Updated intra-site schedule on %ls.\n",
                    GetConnectionDN()->StringName);

            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_CHK_UPDATED_SCHEDULE,
                     szInsertDN(GetConnectionDN()),
                     szInsertDN(GetSourceDSADN()),
                     szInsertDN(GetDestinationDSADN()));
        }
    }

    REPLTIMES *linkRT, *connRT;

    linkRT = plink->GetSchedule();
    connRT = KccConvertToplScheduleToReplTimes( m_toplSchedule );

    if ( 0 != memcmp( linkRT, connRT, sizeof(REPLTIMES) ) )
    {
        // update schedule
        DPRINT2(
            0,
            "Updating schedule in Reps-From %hs on %ls.\n",
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetSchedule( connRT );
        fUpdateLink = TRUE;
    }

    // Free the REPLTIMES structure that was allocated
    delete[] connRT;

    if ( plink->IsEnabled() != IsEnabled() )
    {
        // update enabled flag
        DPRINT3(
            0,
            "Changing Enabled flag to 0x%x in Reps-From %hs on %ls.\n",
            IsEnabled(),
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetEnabled( IsEnabled() );
        fUpdateLink = TRUE;
    }

    if ( IsIntrasite() )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    if ( fIsDSRPCReplica != plink->IsDSRPCReplica() )
    {
        // update mail replica flag
        DPRINT3(
            0,
            "Changing Is-DS-RPC-Replica flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsDSRPCReplica,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSRPCReplica( fIsDSRPCReplica );
        fUpdateLink = TRUE;
    }

    DSNAME * pdnTransport = NULL;

    if (fIsDSRPCReplica) {
        // fIsDSRPCReplica trumps GetTransportDN()
        Assert( pdnTransport == NULL );

        // Note that the call to UpdateRepsFromRef in ReplicateNC expects that
        // the transport uuid is fNullUuid for RPC-based links
        if (!fNullUuid( plink->GetTransportUUID() )) {
            // update transport
            DPRINT2(
                0,
                "Changing transport in Reps-From %hs on %ls to NULL for RPC link.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
            plink->SetTransportUUID( &gNullUuid );
            fUpdateLink = TRUE;
        }
    } else {
        pdnTransport = GetTransportDN();
        Assert( pdnTransport != NULL );
        if ( (pdnTransport != NULL) &&
             (0 != memcmp(&pdnTransport->Guid,
                          plink->GetTransportUUID(),
                          sizeof(UUID)))) {
            // update transport
            DPRINT3(
                0,
                "Changing transport in Reps-From %hs on %ls to %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                pdnTransport->StringName
                );
            plink->SetTransportUUID( &pdnTransport->Guid );
            fUpdateLink = TRUE;
        }
    }

    BOOL fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
    if ( fIsPeriodic != plink->IsPeriodicSynced() )
    {
        // update periodic flag
        DPRINT3(
            0,
            "Changing Periodic-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsPeriodic,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetPeriodicSync( fIsPeriodic );
        fUpdateLink = TRUE;
    }

    BOOL fUseCompression=IsCompressionEnabled();
    if ( fUseCompression != plink->UsesCompression() )
    {
        // update compression flag
        DPRINT3(
            0,
            "Changing Use-Compression flag to 0x%x in Reps-From %hs on %ls.\n",
            fUseCompression,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetCompression( fUseCompression );
        fUpdateLink = TRUE;
    }

    BOOL fIsNeverNotified = !UsesNotification();

    if ( fIsNeverNotified != plink->IsNeverNotified() )
    {
        // update is-never-notified flag
        DPRINT3(
            0,
            "Changing Is-Never-Notified flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsNeverNotified,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetNeverNotified( fIsNeverNotified );
        fUpdateLink = TRUE;
    }

    BOOL fIsInitSync = fInSameSite;

    if ( fIsInitSync != plink->IsInitSynced() )
    {
        // update init-sync flag
        DPRINT3(
            0,
            "Changing Init-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
            fIsInitSync,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetInitSync( fIsInitSync );
        fUpdateLink = TRUE;
    }

    if (IsTwoWaySynced() != plink->IsTwoWaySynced()) {
        // update two-way-synced flag
        DPRINT3(0,
                "Changing Two-Way-Sync flag to 0x%x in Reps-From %hs on %ls.\n",
                IsTwoWaySynced(),
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName);
        plink->SetTwoWaySync(IsTwoWaySynced());
        fUpdateLink = TRUE;
    }

    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);

    MTX_ADDR *pmtx = m_pSourceDSA->GetMtxAddr(pTransport);

    if (    ( NULL != pmtx )
         && !MtxSame( plink->GetDSAAddr(), pmtx )
       )
    {
        // update source dsa address
        DPRINT3(
            0,
            "Changing Mtx-Addr flag to %hs in Reps-From %hs on %ls.\n",
            pmtx->mtx_name,
            plink->GetDSAAddr()->mtx_name,
            pdnNC->StringName
            );
        plink->SetDSAAddr( pmtx );
        fUpdateLink = TRUE;
    }

    if ( fUpdateLink )
    {
        DWORD draError = plink->Update( pdnNC, ATT_REPS_FROM );

        if ( DRAERR_Success == draError )
        {
            DPRINT2(
                0,
                "Successfully updated link to %hs in Reps-From on %ls.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName
                );
        }
        else
        {
            DPRINT3(
                0,
                "Failed to update link to %hs in Reps-From on %ls, DRA error %d.\n",
                plink->GetDSAAddr()->mtx_name,
                pdnNC->StringName,
                draError
                );
        }
    }
}

BOOL
KCC_CONNECTION::ShouldSkipDraAdd(
    KCC_DSA *pRemoteDSA,
    DWORD   *pdwDraError OPTIONAL
    )
//
// Check the connection failure cache for any failures communicating with
// pRemoteDSA. If an error has already occurred during this run of the KCC,
// then we decide to skip the DirReplicaAdd() since it is quite likely we will
// hit the same error again (and thus have to wait for the DirReplicaAdd() call
// to timeout).
// 
{
    DWORD draError;
    BOOL  fErrorOccurredThisRun;

    if( ! gConnectionFailureCache.Get( pRemoteDSA->GetDsName(),
                                       NULL, /* TimeSinceFirstAttempt */
                                       NULL, /* NumberOfFailures */
                                       NULL, /* fUserNotifiedOfStaleness */
                                       &draError,
                                       &fErrorOccurredThisRun ) )
    {
        // No error in the cache, so we shouldn't skip DirReplicaAdd()
        return FALSE;
    }

    if( !fErrorOccurredThisRun ) {
        // The error in the cache didn't happen during this run of the KCC
        // so we don't want to skip the DirReplicaAdd().
        return FALSE;
    }

    switch( draError ) {
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_SERVER_TOO_BUSY:
        case ERROR_DS_DNS_LOOKUP_FAILURE:
            // These transient errors might cause DirReplicaAdd() to take
            // a long time.
            if( pdwDraError ) {
                *pdwDraError = draError;
            }
            return TRUE;
        default:
            return FALSE;
    }

    return FALSE;
}


void
KCC_CONNECTION::AddLink(
    IN  KCC_CROSSREF *          pCrossRef,
    IN  BOOL                    fIsLocalMaster,
    IN  DSNAME *                pdnLocalSite,
    IN  KCC_DSA *               pLocalDSA,
    IN  KCC_DSA *               pRemoteDSA,
    IN  KCC_TRANSPORT_LIST *    pTransportList
    )
//
// Derive new repsFrom link from this connection object.
//
{
    DSNAME *pdnNC = pCrossRef->GetNCDN();
    BOOL fInSameSite = IsIntrasite();
    BOOL fIsDSRPCReplica;

    DPRINT3( 3, "AddLink: nc %ws isLocMaster:%d remote:%ws\n",
             pdnNC->StringName,
             fIsLocalMaster,
             pRemoteDSA->GetDsName()->StringName );

    if ( fInSameSite )
    {
        // DSAs in the same site always replicate via DS RPC
        fIsDSRPCReplica = TRUE;
        fInSameSite = TRUE;
    }
    else
    {
        // DSAs in different sites can replicate via RPC or mail.
        // Intersite IP connections send/receive using DS RPC,
        // though we still use the ISM IP plug-in for topology
        // queries.
        fIsDSRPCReplica = (NULL == GetTransportDN())
                          || IsOverIntersiteIP();
        fInSameSite = FALSE;
    }

    DSNAME * pdnTransport = GetTransportDN();
    KCC_TRANSPORT * pTransport
        = (NULL == pdnTransport)
            ? NULL
            : pTransportList->GetTransport(pdnTransport);
    LPWSTR pszTransportAddr = pRemoteDSA->GetTransportAddr(pTransport);
    LPWSTR pszLocalTransportAddr = pLocalDSA->GetTransportAddr(pTransport);
    
    if ( (NULL != pszTransportAddr) &&
         (NULL != pszLocalTransportAddr) ) {
        BOOL            fIsPeriodic;
        DWORD           dwOptions = DRS_ASYNC_REP;

        // See comments in UpdateLink regarding periodic sync criteria
        fIsPeriodic = ( 0 != ToplScheduleDuration(m_toplSchedule) );
        if ( fIsPeriodic )
        {
            // connection has a non-empty schedule, so we periodically sync
            dwOptions |= DRS_PER_SYNC;
        }

        if ( !fInSameSite )
        {
            if(IsCompressionEnabled()) {
                dwOptions |= DRS_USE_COMPRESSION;
            }
            if (!fIsDSRPCReplica) {
                dwOptions |= DRS_MAIL_REP;
            }
        }
        else
        {
            // sync RPC-based replicas on startup, too
            dwOptions |= DRS_INIT_SYNC;
        }

        if ( fIsLocalMaster )
        {
            dwOptions |= DRS_WRIT_REP;
        }

        if (IsTwoWaySynced()) {
            dwOptions |= DRS_TWOWAY_SYNC;
        }
    
        if (!UsesNotification()) {
            dwOptions |= DRS_NEVER_NOTIFY;
        }
    
        
        // Don't try to add the replica link if we have previously encountered
        // a transient error while contacting this DSA.
        DWORD draError;
        if( ShouldSkipDraAdd(pRemoteDSA, &draError) )
        {          
            DPRINT3(
                1,
                "Didn't try to add link for %ls from %ls due to previous error %d.\n",
                pdnNC->StringName,
                pszTransportAddr,
                draError
                );

            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SKIPPED_DIRREPLICAADD,
                szInsertDN( pdnNC ),
                szInsertWC( pszTransportAddr ),
                szInsertWin32Msg( draError ),
                szInsertDN( pRemoteDSA->GetDsName() ),
                pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                szInsertWin32ErrCode( draError ),
                NULL,
                NULL );
        
        } else {
            
            // DirReplicaAdd takes its schedules as REPLTIMES.
            // We convert our TOPL_SCHEDULE here.
            REPLTIMES* pRT;
            pRT = KccConvertToplScheduleToReplTimes(m_toplSchedule);
            Assert( NULL!=pRT );

            draError = DirReplicaAdd(
                            pdnNC,
                            pRemoteDSA->GetDsName(),
                            pdnTransport,
                            pszTransportAddr,
                            NULL,
                            pRT,
                            dwOptions
#ifdef KCC_PERF_TEST
                                // When doing KCC testing, don't want DirReplicaAdd to block
                                // when adding IP links. So we initially make them as SMTP
                                // links, // then they will get repaired on the second run. This
                                // is just a temporary workaround.
                                | DRS_ASYNC_REP | DRS_MAIL_REP
#endif
                            );

            // Free the REPLTIMES structure that was allocated.
            delete[] pRT;

            if ( DRAERR_Success == draError )
            {
                DPRINT3(
                    0,
                    "Added link for %ls from %ls with options 0x%x.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions
                    );

                LogEvent(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_MINIMAL,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_SUCCESS
                      : DIRLOG_CHK_LINK_ADD_REPLICA_SUCCESS,
                    szInsertDN( pdnNC ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    NULL);

                //
                // Remove this server from the list of servers that have
                // failed in the past
                //
                gConnectionFailureCache.Remove( pRemoteDSA->GetDsName() );

            }
            else
            {
                DPRINT4(
                    0,
                    "Failed to add link for %ls from %ls with options 0x%x, error %d.\n",
                    pdnNC->StringName,
                    pszTransportAddr,
                    dwOptions,
                    draError
                    );

                LogEvent8(
                    DS_EVENT_CAT_KCC,
                    DS_EVENT_SEV_ALWAYS,
                    fIsLocalMaster
                      ? DIRLOG_CHK_LINK_ADD_MASTER_FAILURE
                      : DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
                    szInsertDN( pdnNC ),
                    szInsertWC( pszTransportAddr ),
                    szInsertWin32Msg( draError ),
                    szInsertDN( pRemoteDSA->GetDsName() ),
                    pdnTransport ? szInsertDN(pdnTransport) : szInsertSz(""),
                    szInsertWin32ErrCode( draError ),
                    NULL,
                    NULL );

                //
                // Add this server from the list of servers with whom
                // we have failed to initiate a link with
                //
                if ( !gConnectionFailureCache.Add(pRemoteDSA->GetDsName(), draError, FALSE) )
                {
                    DPRINT1(
                        3,
                        "Failed to add %ws in gConnectionFailureCache\n",
                        pszTransportAddr
                        );

                }
            }       // End DirReplicaAdd() failed
        }       // End No Cached RPC Failure

    } else {
        // We've committed to a certain connection and transport, but one
        // of the dsas is not configured for it. Error out.
        // If we could back out and try another connection, we should.
        // It would be better if we didn't get to this point, and instead
        // decided earlier on not to use this transport.
        // Do we need a way to tell the user that we could use a given transprt
        // if he would only configure it on the dsas?

        // JeffParh 03-19-99: This should never happen for auto-generated
        // connections.  We should have verified that the source and destination
        // bridgeheads supported the transport in KccGetNcBridgeheadForTransport.

        DPRINT3( 0, "Failed to add link for %ws from %ws, transport %ws because transport-specific address is missing!\n",
                 pdnNC->StringName,
                 pRemoteDSA->GetDsName()->StringName,
                 pdnTransport->StringName );
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING,
            szInsertDN( pdnNC ),
            szInsertDN( pRemoteDSA->GetDsName() ),
            szInsertDN( pdnTransport ) );
    }
}

// Register an NC as being replicated over this connection.
void
KCC_CONNECTION::AddReplicatedNC(
    IN  DSNAME * pNC,
    IN  BOOL     fGCTopology
    )
{
    KCC_REPLICATED_NC * pReplNC;

    pReplNC = m_ReplicatedNCArray.Find(pNC);

    if (NULL == pReplNC) {
        // No entry yet exists.
        pReplNC = new KCC_REPLICATED_NC;
    
        pReplNC->pNC = pNC;
        pReplNC->fReadOnly = fGCTopology;

        m_ReplicatedNCArray.Add(pReplNC);
    }
    else {
        // Entry already exists -- update it if necessary.
        if (!fGCTopology && pReplNC->fReadOnly) {
            // This connection used to replicate both writeable and read-only.
            pReplNC->fReadOnly = FALSE;
        }
    }
}

// Enumerate the NCs replicated over this connection (as previously
// registered via AddReplicatedNC()).
DSNAME *
KCC_CONNECTION::GetReplicatedNC(
    IN  DWORD    iNC,
    OUT BOOL *   pfGCTopology
    )
{
    DSNAME * pNC = NULL;

    if (iNC < m_ReplicatedNCArray.GetCount()) {
        KCC_REPLICATED_NC * pReplNC = m_ReplicatedNCArray[iNC];
        pNC = pReplNC->pNC;
        *pfGCTopology = pReplNC->fReadOnly;
    }

    return pNC;
}

// Return the number of replicated NCs that are writeable.
DWORD
KCC_CONNECTION::GetReplicatedWriteableNCCount()
{
    DWORD cReplNCCount = m_ReplicatedNCArray.GetCount();
    DWORD cWriteable = 0;
    DWORD i;

    for (i = 0; i < cReplNCCount; i++) {
        if (!m_ReplicatedNCArray[i]->fReadOnly) {
            cWriteable++;
        }
    }

    return cWriteable;
}

// Is the connection used by the given naming context?
//
// There are two special cases:
// 1. Schema does not appear specifically. It is assumed that if Config
//    is replicated, schema is also
// 2. Admin generated connections are assumed to carry all common ncs
//
// Note that you should not use this to filter which which replica links
// should be created on behalf of which connections. Applications make
// assumptions that each connection may replicate all common NC's.
//
BOOL
KCC_CONNECTION::ReplicatesNC(
    IN KCC_CROSSREF *pCrossRef
    )
{
    if (!IsGenerated()) {
        // Admin generated connections carry all common, compatible nc's
        return TRUE;
    } else {
        DSNAME *pNC;

        // If they ask for Schema, use Config since they share the same topology
        if (pCrossRef->GetNCType() == KCC_NC_TYPE_SCHEMA) {
            pNC = gpDSCache->GetConfigNC();
        } else {
            pNC = pCrossRef->GetNCDN();
        }

        return (m_ReplicatedNCArray.IsElementOf( pNC ));
    }
}

// Determine whether the info replicated by this connection is a subset of that
// replicated by the specified connection.
BOOL
KCC_CONNECTION::ReplicatesSubsetOf(
    IN KCC_CONNECTION * pcn2
    )
{
    DWORD cNumReplNCs1 = m_ReplicatedNCArray.GetCount();
    DWORD cNumReplNCs2 = pcn2->m_ReplicatedNCArray.GetCount();
    BOOL fIsSubset;

    if (cNumReplNCs1 > cNumReplNCs2) {
        // *this replicates more NCs, so it can't be a subset.
        fIsSubset = FALSE;
    }
    else {
        DWORD iReplNC1, iReplNC2;

        m_ReplicatedNCArray.Sort();
        pcn2->m_ReplicatedNCArray.Sort();

        fIsSubset = TRUE;
        iReplNC2 = 0;
        for (iReplNC1 = 0; iReplNC1 < cNumReplNCs1; iReplNC1++) {
            KCC_REPLICATED_NC * pReplNC1 = m_ReplicatedNCArray[iReplNC1];
            KCC_REPLICATED_NC * pReplNC2;
            int nDiff;

            if (iReplNC2 >= cNumReplNCs2) {
                // Remaining NC(s) replicated by 1 are not replicated by 2.
                // 1 is not a subset of 2.
                fIsSubset = FALSE;
                break;
            }

            // Skip over NCs replicated by 2 that are not replicated by 1 --
            // they're irrelevant.

            do {
                pReplNC2 = pcn2->m_ReplicatedNCArray[iReplNC2++];
            } while (((nDiff = CompareDsName(&pReplNC2->pNC, &pReplNC1->pNC))
                      < 0)
                     && (iReplNC2 < cNumReplNCs2));

            if (nDiff) {
                // NC replicated by 1 not replicated by 2 -- not a subset.
                fIsSubset = FALSE;
                break;
            }

            Assert(NameMatched(pReplNC1->pNC, pReplNC2->pNC));
            
            if (!pReplNC1->fReadOnly && pReplNC2->fReadOnly) {
                // 1 supports writeable replication of this NC; 2 solely
                // supports read-only -- not a subset.
                fIsSubset = FALSE;
                break;
            }
        }
    }

    return fIsSubset;
}


BOOL
KCC_CONNECTION::IsSourceSiteUnreachable()
/*++

Routine Description:

    This function should only be called after the spanning-tree algorithm has
    completed. If the source site was found to be unreachable from the local
    site for any NC, this function will return TRUE.

Parameters:

    None.

Return value:

    TRUE  - The source site is unreachable.
    FALSE - Otherwise.

--*/
{
    KCC_SITE_LIST   *pSiteList;
    DSNAME          *pdnSourceSite;
    KCC_SITE        *pSourceSite;

    pSiteList = gpDSCache->GetSiteList();
    ASSERT_VALID( pSiteList );

    pdnSourceSite = GetSourceSiteDN();
    Assert( pdnSourceSite );

    pSourceSite = pSiteList->GetSite(pdnSourceSite);
    ASSERT_VALID( pSourceSite );

    return pSourceSite->IsUnreachable();
}


BOOL
KCC_CONNECTION::OnProbation()
/*++

Routine Description:

    When a connection has been newly created, we cannot immediately
    determine if replication is succeeding over this connection.
    
    For example, an ISTG may create a connection inbound to another
    bridgehead server. In order to determine if replication is succeeding
    over this connection, the following steps must occur:

      - The connection must replicate to the bridgehead server
      - The KCC on the bridgehead server must run and fail to create the
        repsFrom more than gcIntersiteLinkFailuresAllowed times.
      - At least gcSecsUntilIntersiteLinkFailure seconds must elapse.
      - The KCC must run on the ISTG and retrieve the staleness entries
        from the bridgehead server.

    Thus, it takes a fair amount of time before we can assert that
    replication is succeeding over a connection.

    When a connection is newly created, it goes 'on probation' for a
    certain period of time. The intention is that, by the time the connection
    is no longer 'on probation', we will have had sufficient time to determined
    whether or not replication is succeeding over that connection.
    
    This function determines if this connection is it its 'probation period'.

Parameters:

    None

Return value:

    TRUE  - Connection is on probation
    FALSE - Connection is not on probation

--*/
{
    DSTIME timeNow, timeCreated, cSecsCalculatedProbation;
    const DWORD MINS_IN_SECS=60;
    
    timeNow = GetSecondsSince1601();
    timeCreated = GetWhenCreated();
    
    // If 'timeCreated' is 0, this connection was created during this run of
    // the KCC and is therefore still in its probation period.
    if( timeCreated==0 ) {
        return TRUE;
    }

    // If the connection was created in the future, we consider it to be _not_
    // on probation. Otherwise, if the administrator set the clocks far into the
    // future, created some connections, and then set the clocks back to normal,
    // the connections would be on probation for a very long time.
    if(timeCreated > timeNow) {
        return FALSE;
    }

    // If this connection was created less than gcConnectionProbationSecs ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < (DSTIME) gcConnectionProbationSecs) {
        return TRUE;
    }

#ifndef DBG
    // At the bare minimum, the KCC must run at least
    // (gcIntersiteLinkFailuresAllowed+1) times plus a fudge factor of 1 hour
    // to determine that a connection is stale.
    cSecsCalculatedProbation = (DSTIME) (60 * MINS_IN_SECS)
        + ((gcIntersiteLinkFailuresAllowed+1) * gcSecsBetweenTopologyUpdates);
    
    // If this connection was created less than cSecsCalculatedProbation ago,
    // it is therefore still in its probation period.
    if(timeNow-timeCreated < cSecsCalculatedProbation) {
        return TRUE;
    }
#endif
    
    return FALSE;
}


BOOL
KCC_CONNECTION::Supercedes(
    IN  KCC_CONNECTION *pcn
    )
/*++

Routine Description:

    Determine if this connection 'supercedes' pcn. The requirements are
    that this connection is not stale and that this connection replicates a
    superset of the NCs that pcn does.

    Note: This connection cannot supercede pcn if pcn is an admin-created
    connection.

Parameters:

    pcn - The connection to compare against.

Return value:

    TRUE  - this supercedes pcn
    FALSE - Otherwise

--*/
{
    BOOL fPcnAdminCreated, fIsDuplicate;
    BOOL fOnProbation, fReplicatesSubset, fShouldSupercede;
    PDSNAME pdnTransport1, pdnTransport2;

    fPcnAdminCreated = ( !pcn->IsGenerated() );
    pdnTransport1 = this->GetTransportDN();
    pdnTransport2 = pcn->GetTransportDN();

    // A duplicate connection is defined to be one with identical source/dest
    // servers and the same transport.
    fIsDuplicate = FALSE;
    if(   (this->GetSourceDSA() == pcn->GetSourceDSA())
        && (this->GetDestinationDSA() == pcn->GetDestinationDSA())
        && (0==CompareDsName(&pdnTransport1, &pdnTransport2)) )
    {
        fIsDuplicate = TRUE;
    }

    fReplicatesSubset = pcn->ReplicatesSubsetOf(this);
    fShouldSupercede = ( !this->IsStale() && fReplicatesSubset );
    fOnProbation = this->OnProbation();
    
    // The overriding rule is that admin-created connections
    // cannot be superceded because the KCC should never touch them.
    if( fPcnAdminCreated ) {
        return FALSE;
    }

    // If pcn is KCC-generated and is a duplicate of this connection
    // then pcn can be superceded regardless of staleness, probation, etc.
    if( fIsDuplicate ) {
        return TRUE;
    }

    if( fShouldSupercede ) {

        if( fOnProbation ) {
            // this should supercede pcn but it can't because it's
            // on probation.
            DPRINT2(2,"Connection %ls would supercede %ls but did not "
                      "because it is on probation.\n",
                    this->GetConnectionDN()->StringName,
                    pcn->GetConnectionDN()->StringName);
            LogEvent(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_INTERNAL,
                     DIRLOG_KCC_CONN_ON_PROBATION,
                     szInsertDN(this->GetConnectionDN()),
                     szInsertDN(pcn->GetConnectionDN()),
                     0);
            return FALSE;
        } else {
            // this supercedes pcn and this is not on probation
            return TRUE;
        }

    } else {
        // Does not supercede
        return FALSE;
    }
}


int __cdecl
KCC_CONNECTION::CompareDNAndReason(
    const void *elem1,
    const void *elem2
    )
//
// Compare two DN_AND_REASON elements by their DN.
//
{
    DN_AND_REASON *p1 = (DN_AND_REASON *) elem1;
    DN_AND_REASON *p2 = (DN_AND_REASON *) elem2;
    int nDiff;

    Assert(!fNullUuid(&p1->dn->Guid));
    Assert(!fNullUuid(&p2->dn->Guid));

    nDiff = CompareDsName(&p1->dn, &p2->dn);
    
    return nDiff;
}

BOOL
KCC_CONNECTION::NewNCsSameAsOld(
    void
    )
//
// Determine if the new set of replicated NCs and their reasons are
// identical to the old set of replicated NCs and their reasons.
// To do this, we sort the lists and compare the corresponding elements.
//
{
    DSNAME      *dnOld, *dnNew;
    DWORD       iNC;

    // If the two arrays differ in size, they are obviously not the same.
    if( m_cOldNCs != m_ReplicatedNCArray.GetCount() ) {
        return FALSE;
    }

    // Special case: No NCs
    if( 0==m_cOldNCs ) {
        return TRUE;
    }

    // Sort both arrays by the NC DNs
    Assert( NULL!=m_pOldNCs )
    qsort( m_pOldNCs, m_cOldNCs, sizeof(DN_AND_REASON), CompareDNAndReason );
    m_ReplicatedNCArray.Sort();

    // Now that the arrays are sorted, we can compare their contents one-by-one.
    for( iNC=0; iNC<m_cOldNCs; iNC++ ) {
    
        dnOld = m_pOldNCs[iNC].dn;
        dnNew = m_ReplicatedNCArray[iNC]->pNC;

        // Check that the same NC is in both lists
        if( 0!=CompareDsName(&dnOld,&dnNew) ) {
            return FALSE;
        }

        // Check that the reason has not changed
        if( m_pOldNCs[iNC].reason != m_ReasonForConnection ) {
            return FALSE;
        }
    }

    return TRUE;
}


// The binary data in the replicatesNCReason distname-binary
// Note that each DWORD is encoded in network byte order.
// Another example of distname-binary values is dsamain\src\xdommove.c

#define REASON_BINARY_DATA_SIZE (STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(DWORD)))

void
KCC_CONNECTION::UpdateReason(
    void
    )
//
// Update reason fields in object
//
{
    ATTRMODLIST rgMods[1];
    ULONG       dirError;
    DWORD       cReplNCCount = m_ReplicatedNCArray.GetCount();
    ATTRVAL    *pAttrValNC;
    DWORD       iNC;
    SYNTAX_ADDRESS *pBinaryData;
    SYNTAX_DISTNAME_BINARY *pReason;

    
    // We want to avoid updating the reason fields in the DB if the new reasons
    // are identical to the old reasons.
    if( NewNCsSameAsOld() ) {
        DPRINT1(1,
            "Not updating NC reasons for connection %ls because they haven't changed.\n",
            m_pdnConnection->StringName );
        return;
    }
    
    DPRINT3(1,
        "Updated connection %ls with rep nc count %d, reason flags 0x%x.\n",
        m_pdnConnection->StringName,
        cReplNCCount,
        m_ReasonForConnection );
    
    // Fill out binary data
    pBinaryData = (SYNTAX_ADDRESS *) new BYTE[ REASON_BINARY_DATA_SIZE ];
    pBinaryData->structLen = REASON_BINARY_DATA_SIZE;
    // Someday make this reason NC specific. Move inside loop.
    Assert( (((ULONG_PTR)pBinaryData) & 0x3) == 0 );  // DWORD alignment
    *((LPDWORD) &(pBinaryData->byteVal)) = htonl(m_ReasonForConnection);

    memset(rgMods, 0, sizeof(rgMods));

    rgMods[0].choice = ( (0 == cReplNCCount) ? AT_CHOICE_REMOVE_ATT
                                             : AT_CHOICE_REPLACE_ATT );        
    rgMods[0].AttrInf.attrTyp          = ATT_MS_DS_REPLICATES_NC_REASON;
    rgMods[0].AttrInf.AttrVal.valCount = cReplNCCount;
    if (cReplNCCount) {
        pAttrValNC = new ATTRVAL [cReplNCCount];
        rgMods[0].AttrInf.AttrVal.pAVal= pAttrValNC;

        for( iNC = 0; iNC < cReplNCCount; iNC++ ) {
            BOOL fGCTopology;
            DSNAME *pNC = GetReplicatedNC( iNC, &fGCTopology );
            DWORD cbDistNameBinary = DERIVE_NAME_DATA_SIZE( pNC, pBinaryData );

            pReason = (SYNTAX_DISTNAME_BINARY *) new BYTE [cbDistNameBinary];
            BUILD_NAME_DATA( pReason, pNC, pBinaryData );

            pAttrValNC[ iNC ].valLen      = cbDistNameBinary;
            pAttrValNC[ iNC ].pVal        = (LPBYTE) pReason;

            // Supportability logging event 7, dump reason for connection
            LogEvent8(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_VERBOSE,
                DIRLOG_KCC_CONNECTION_REPLICATES_NC,
                szInsertDN( GetConnectionDN() ),
                szInsertDN( pNC ),
                szInsertDN( GetTransportDN() ),
                szInsertDN( GetSourceSiteDN() ),
                szInsertHex( GetReasonForConnection() ),
                szInsertUL( fGCTopology ),
                0, 0
                ); 
        }
    }
    // rgMod[0].pNextMod is zero

    dirError = KccModifyEntry(m_pdnConnection,
                              ARRAY_SIZE(rgMods),
                              rgMods);
    if (0 != dirError) {
        KCC_LOG_MODIFYENTRY_FAILURE( m_pdnConnection, dirError);
        KCC_EXCEPT(ERROR_DS_DATABASE_ERROR, 0);
    }

    delete[] pBinaryData;
}

int __cdecl
KCC_CONNECTION::CompareForRemoval(
    IN  const void *  pv1,
    IN  const void *  pv2
    )
/*++

Routine Description:

    Order the connections by:
    
        increasing source site (as per wcscmp())
        increasing number of writeable NCs supported
        increasing number of read-only NCs supported
        KCC-generated connections come before "created by admin" connections
        stale connections come before non-stale connections
        Newer connections come before older connections
        increasing connection objectGuid

    Note that some of the checks in this function compute nDiff by simple
    subtraction of operands and others explicitly compare and set the value.
    The latter technique is used in cases where overflow is possible.
    
Parameters:

    pv1, pv2 -- KCC_CONNECTION **'s of the connections to order.

Returns:

    0   identical
    <0  pcn1 "less than" pcn2
    >0  pcn1 "greater than" pcn2
    
--*/
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    Assert(!fNullUuid(&pcn1->GetConnectionDN()->Guid));
    Assert(!fNullUuid(&pcn2->GetConnectionDN()->Guid));

    // Sort first by ascending source site.  Note that the GUIDs are not
    // filled in on the site DNs, so GUID-based order is not currently an option.
    // Shouldn't need to use case-insensitive version, since both names are from
    // the DS and the DS preserves case.  (Case-insensitive compares are much
    // more expensive.)
    nDiff = wcscmp(pcn1->GetSourceSiteDN()->StringName,
                   pcn2->GetSourceSiteDN()->StringName);

    if (0 == nDiff) {
        // Same source site; use ascending number of writeable NCs.
        nDiff = pcn1->GetReplicatedWriteableNCCount()
                - pcn2->GetReplicatedWriteableNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable NCs; use ascending number of
        // read-only NCs.
        nDiff = pcn1->GetReplicatedNCCount() - pcn2->GetReplicatedNCCount();
    }

    if (0 == nDiff) {
        // Same source site, same number of writeable/read-only NCs supported;
        // those created by admins sort after those that are KCC-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
    	// Stale connections can be superceded by non-stale connections, so the
    	// stale connections must come first in the sorted array.
        nDiff = !pcn1->IsStale() - !pcn2->IsStale();
    }

    if (0 == nDiff) {
        // Connections which are on probation should come before connections
        // which are not on probation.
        if( pcn1->OnProbation() && !pcn2->OnProbation() ) {
            nDiff = -1;
        } else if( !pcn1->OnProbation() && pcn2->OnProbation() ) {
            nDiff = 1;
        }
    }

    if (0 == nDiff) {
        // Connections with lower GUID come first.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }
    
    return nDiff;
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_CONNECTION_LIST methods
//

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::ComparePConnByDsname(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two connection objects by their source site DSNames. This function
// defines the ordering used by the m_dsnameSearchTree. The parameters a and b
// are pointers to pointers to connection objects.
{
    KCC_CONNECTION *conn1, *conn2;
    DSNAME         *dn1, *dn2;
    int             r;

    Assert( a!=NULL && b!=NULL );

    conn1 = *((KCC_CONNECTION**) a);
    conn2 = *((KCC_CONNECTION**) b);

    ASSERT_VALID( conn1 );
    ASSERT_VALID( conn2 );

    dn1 = conn1->GetConnectionDN();
    dn2 = conn2->GetConnectionDN();

    Assert( dn1!=NULL );
    Assert( dn2!=NULL );

    r = CompareDsName( &dn1, &dn2 );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceDsaTreeEntry(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceDsaSearchTree by their GUIDs. The
// parameters, a and b, are pointers to SOURCE_DSA_CONN_ARRAYs.
{
    SOURCE_DSA_CONN_ARRAY   *sde1, *sde2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sde1 = (SOURCE_DSA_CONN_ARRAY*) a;
    sde2 = (SOURCE_DSA_CONN_ARRAY*) b;

    Assert( !fNullUuid(&sde1->uuid) );
    Assert( !fNullUuid(&sde2->uuid) );
    
    r = memcmp( &sde1->uuid, &sde2->uuid, sizeof(UUID) );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

RTL_GENERIC_COMPARE_RESULTS
KCC_CONNECTION_LIST::CompareSourceSiteConnArray(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID a,
    PVOID b
    )
// Compare two nodes in the m_sourceSiteSearchTree by the sites' DSNAMEs.
// The parameters, a and b, are pointers to SOURCE_SITE_CONN_ARRAY's.
{
    SOURCE_SITE_CONN_ARRAY  *sse1, *sse2;
    int                     r;

    Assert( a!=NULL && b!=NULL );

    sse1 = (SOURCE_SITE_CONN_ARRAY*) a;
    sse2 = (SOURCE_SITE_CONN_ARRAY*) b;

    Assert( sse1->siteDN!=NULL );
    Assert( sse2->siteDN!=NULL );

    r = CompareDsName( &sse1->siteDN, &sse2->siteDN );

    if( r<0 ) return GenericLessThan;
    else if( r>0 ) return GenericGreaterThan;
    return GenericEqual;
}

PVOID NTAPI
KCC_CONNECTION_LIST::KccTreeAlloc(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )
// This function is used to allocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    return new BYTE[ ByteSize ];
}

VOID NTAPI
KCC_CONNECTION_LIST::KccTreeFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )
// This function is used to deallocate memory by the three search
// trees in the KCC_CONNECTION_LIST class.
{
    delete[] Buffer;
}

void
KCC_CONNECTION_LIST::Reset()
//
// Reset member variables to their pre-Init() state.
// This includes creating the three empty search trees.
//
{
    SOURCE_DSA_CONN_ARRAY      *psde;
    SOURCE_SITE_CONN_ARRAY     *psse;
    KCC_CONNECTION            **ppcn;
    DWORD                       i;
    BOOLEAN                     fSuccess;

    if( m_fTreesInited ) {

        // Clear the dsname search tree
        for( i=0; i<m_ccn; i++ ) {
            fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &m_ppcn[i] );
            Assert( fSuccess==TRUE );
        }
        Assert( RtlIsGenericTableEmpty(&m_dsnameSearchTree) );

        // The source dsa search tree is a tree of lists -- each node corresponds
        // to a distinct source dsa and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) ) {
            psde = (SOURCE_DSA_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceDsaSearchTree, TRUE );
            Assert( psde!=NULL );
            Assert( psde->numConnections>0 && psde->numConnections<=m_ccn );
            ppcn = psde->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, psde );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
        Assert( RtlIsGenericTableEmpty(&m_sourceDsaSearchTree) );

        // The sourceSite search tree is a tree of lists -- each node corresponds
        // to a distinct source site and contains a linked list of connections. We
        // must enumerate the tree to find every list, free the list, and then delete
        // the node from the tree.
        while( ! RtlIsGenericTableEmpty(&m_sourceSiteSearchTree) ) {
            psse = (SOURCE_SITE_CONN_ARRAY*) RtlEnumerateGenericTable(
                &m_sourceSiteSearchTree, TRUE );
            Assert( psse!=NULL );
            Assert( psse->numConnections>0 && psse->numConnections<=m_ccn );
            ppcn = psse->connection;
            Assert( NULL!=ppcn );

            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, psse );
            Assert( fSuccess==TRUE );
            THFree( ppcn );
        }
    }

    m_cnAllocated    = 0;
    m_ccn            = 0;
    m_ppcn           = NULL;
    m_fIsInitialized = FALSE;
    m_fTreesInited   = FALSE;
}

void
KCC_CONNECTION_LIST::InitTrees()
// Initialize the three search trees
{

    RtlInitializeGenericTable(
       &m_dsnameSearchTree,
        ComparePConnByDsname,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceDsaSearchTree,
        CompareSourceDsaTreeEntry,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );
    RtlInitializeGenericTable(
       &m_sourceSiteSearchTree,
        CompareSourceSiteConnArray,
        KccTreeAlloc,
        KccTreeFree,
        NULL
    );

    m_fTreesInited = TRUE;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnection(
    IN  DWORD   iConnection
    )
//
// Retrieve the KCC_CONNECTION object at the given index.
//
{
    KCC_CONNECTION * pcn;

    ASSERT_VALID( this );

    if ( iConnection < m_ccn )
    {
        pcn = m_ppcn[ iConnection ];
        ASSERT_VALID( pcn );
    }
    else
    {
        pcn = NULL;
    }

    return pcn;
}

KCC_CONNECTION *
KCC_CONNECTION_LIST::GetConnectionWithSameGUID(
    IN  KCC_CONNECTION *pConnection
    )
//
// Retrieve the KCC_CONNECTION object which has the same GUID
// as the connection we passed in.
//
{
    KCC_CONNECTION  *pcn;
    KCC_CONNECTION  *pcnReturn = NULL;
    KCC_CONNECTION **ppcn;

    ASSERT_VALID(this);
    ASSERT_VALID(pConnection);
    Assert( !fNullUuid(&pConnection->GetConnectionDN()->Guid) );

    ppcn = (KCC_CONNECTION**) RtlLookupElementGenericTable(
        &m_dsnameSearchTree, &pConnection );

    if( ppcn!=NULL ) {
        pcnReturn = *ppcn;
    }

    return pcnReturn;
}

KCC_CONNECTION*
KCC_CONNECTION_LIST::GetConnectionFromSourceDSAUUID(
    IN  UUID *  puuid
    )
//
// Retrieve a KCC_CONNECTION object with source DSA matching the given
// UUID.  Returns NULL if none found. Note that there could very well
// be more than one matching connection (for example, if there were manually
// created duplicate connections). In the future, if any callers of this
// function actually need to enumerate all matching connections, we will need
// to rewrite this function slightly.
//
{
    SOURCE_DSA_CONN_ARRAY   *pSearchResult, searchKey;

    ASSERT_VALID( this );
    Assert( !fNullUuid(puuid) );

    memcpy( &searchKey.uuid, puuid, sizeof(UUID) );
    pSearchResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &searchKey );

    if( pSearchResult!=NULL ) {
        Assert( pSearchResult->numConnections>=1 );
        Assert( NULL!=pSearchResult->connection );
        ASSERT_VALID( pSearchResult->connection[0] );
        return pSearchResult->connection[0];
    }

    return NULL;
}

KCC_CONNECTION_LIST::SOURCE_SITE_CONN_ARRAY*
KCC_CONNECTION_LIST::GetConnectionsFromSite(
    IN  DSNAME * pSourceSiteDN
    )
//
// Retrieve a list of KCC_CONNECTION objects, all of which source from the
// site pSourceSiteDN. Returns NULL if none found.
//
{
    SOURCE_SITE_CONN_ARRAY sseKey, *sseResult;

    Assert( NULL!=pSourceSiteDN );

    // Find this list of connections corresponding to this source site in the
    // source dsa search tree
    sseKey.siteDN = pSourceSiteDN;
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );

    if( sseResult ) {
        // If the list is empty, we would have removed it from the tree
        // in KCC_CONNECTION_LIST::RemoveFromList().
        Assert( sseResult->numConnections!=0 );
    }
    
    return sseResult;
}

BOOL
KCC_CONNECTION_LIST::IsValid()
//
// Is the collection initialized and internally consistent?
//
{
    return m_fIsInitialized;
}

VOID
KCC_CONNECTION_LIST::AddConnectionToSearchTrees(
    IN KCC_CONNECTION* pcn
    )
//
// After adding new connections to the list (either in Init() or
// AddToList()), we must add the new entries to the search trees for
// efficient retrieval. This function adds new connections to all
// three search trees.
//
{
    SOURCE_DSA_CONN_ARRAY     *sdeResult, sdeKey;
    SOURCE_SITE_CONN_ARRAY    *sseResult, sseKey;
    BOOLEAN                    fNewElement;

    ASSERT_VALID(pcn);
    Assert( m_fTreesInited );


    // Add this connection to the dsname search tree
    // Note: Allocation function raises an exception if allocation fails
    RtlInsertElementGenericTable( &m_dsnameSearchTree, &pcn,
        sizeof(KCC_CONNECTION*), &fNewElement );
    Assert( fNewElement==TRUE );


    // Add this connection to the source dsa search tree
    // Note: Allocation function raises an exception if allocation fails
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceDsaSearchTree,
        &sdeKey,
        sizeof(SOURCE_DSA_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this dsa,
        // we must allocate the list of connections
        sdeResult->numConnections = 1;
        sdeResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sdeResult->numConnections++;
        sdeResult->connection = (KCC_CONNECTION**) THReAlloc(
            sdeResult->connection,
            sdeResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sdeResult->connection) {
            KCC_MEM_EXCEPT(sdeResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sdeResult->connection[sdeResult->numConnections-1] = pcn;
    }


    // Add this connection to the appropriate list in the source site search tree
    // Note: Allocation function raises an exception if allocation fails
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlInsertElementGenericTable(
        &m_sourceSiteSearchTree,
        &sseKey,
        sizeof(SOURCE_SITE_CONN_ARRAY),
        &fNewElement );

    if( fNewElement ) {
        // If this is the first connection which sources from this site,
        // we must allocate the list of connections
        sseResult->numConnections = 1;
        sseResult->connection = (KCC_CONNECTION**) THAlloc(sizeof(KCC_CONNECTION*));
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[0] = pcn;
    } else {
        // If this is not the first connection which sources from this site,
        // we must grow (reallocate) the list of connections.
        sseResult->numConnections++;
        sseResult->connection = (KCC_CONNECTION**) THReAlloc(
            sseResult->connection,
            sseResult->numConnections * sizeof(KCC_CONNECTION*) );
        if(!sseResult->connection) {
            KCC_MEM_EXCEPT(sseResult->numConnections*sizeof(KCC_CONNECTION*));
        }
        sseResult->connection[sseResult->numConnections-1] = pcn;
    }

}


VOID
KCC_CONNECTION_LIST::CheckList(
    IN  BOOL        fIntraSite
    )
//
// Check the connection list.
// If this is an intra-site list, the connection should have no transportType.
// Otherwise, the connection should have a transportType.
//
{
    KCC_CONNECTION  *pcn;
    DWORD            iConn, cConn;

    cConn = GetCount();
    for( iConn=0; iConn<cConn; iConn++ ) {
        pcn = GetConnection(iConn);
        if( fIntraSite ) {
            Assert( NULL==pcn->GetTransportDN() );
        } else {
            Assert( NULL!=pcn->GetTransportDN() );
        }
    }
}

BOOL
KCC_CONNECTION_LIST::Init(
    IN DSNAME *     pdnDestinationDSA,
    IN BOOL         fIntraSite
    )
//
// Initialize the collection from the set of NTDS-Connection DS objects
// that are direct children of the given DSA.
//
{

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { ARRAY_SIZE(KCC_CONNECTION::AttrList), KCC_CONNECTION::AttrList },
        EN_INFOTYPES_TYPES_VALS
    };

    DSNAME           *pdnConnectionCat = NULL;
    ULONG           dirError;
    FILTER          filtTop = {0};
    FILTER          filtConnectionObject = {0};
    FILTER          filtIntersite = {0};
    FILTER          filtNotIntersite = {0};
    SEARCHRES *     pResults;
    
    Reset();
    InitTrees();

    pdnConnectionCat = DsGetDefaultObjCategory(CLASS_NTDS_CONNECTION);
    if( NULL==pdnConnectionCat ) {
        Assert( !"DsGetDefaultObjCategory() returned NULL" );
        KCC_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    filtTop.choice                       = FILTER_CHOICE_AND;
    filtTop.FilterTypes.And.count        = 2;
    filtTop.FilterTypes.And.pFirstFilter = &filtConnectionObject;
    
    filtConnectionObject.choice                                     = FILTER_CHOICE_ITEM;
    filtConnectionObject.FilterTypes.Item.choice                    = FI_CHOICE_EQUALITY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.valLen = pdnConnectionCat->structLen;
    filtConnectionObject.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pdnConnectionCat;
    
    if (fIntraSite) {
        filtConnectionObject.pNextFilter = &filtNotIntersite;
    
        filtNotIntersite.choice           = FILTER_CHOICE_NOT;
        filtNotIntersite.FilterTypes.pNot = &filtIntersite;
    } else {
        filtConnectionObject.pNextFilter = &filtIntersite;
    }

    filtIntersite.choice                            = FILTER_CHOICE_ITEM;
    filtIntersite.FilterTypes.Item.choice           = FI_CHOICE_PRESENT;
    filtIntersite.FilterTypes.Item.FilTypes.present = ATT_TRANSPORT_TYPE;

    dirError = KccSearch(
        pdnDestinationDSA,
        SE_CHOICE_IMMED_CHLDRN,
        &filtTop,
        &Sel,
        &pResults
        );

    if (0 != dirError) {
        KCC_LOG_SEARCH_FAILURE(pdnDestinationDSA, dirError);
    } else {
        Init( pdnDestinationDSA, pResults->count, &pResults->FirstEntInf );

        // On debug builds we hold on to the search results in order to
        // make debugging DirSearch problems easier
        #if DBG
            m_dbgSearchResults = pResults;
            DirFreeSearchRes( pResults, TRUE );
        #else
            DirFreeSearchRes( pResults, FALSE );
        #endif

        #if DBG
            CheckList(fIntraSite);
        #endif
    }

    return m_fIsInitialized;
}

BOOL
KCC_CONNECTION_LIST::Init(
    IN  DSNAME *        pdnDestinationDSA,
    IN  DWORD           cNumEntInfs,
    IN  ENTINFLIST *    pEntInfList
    )
//
// Initialize connection list from the given search results.
//
{
    ULONG    dirError;
    DSNAME * pdnLocalDSA = gpDSCache->GetLocalDSADN();
    DWORD    iConn;

    Reset();
    InitTrees();
    
    if (0 == cNumEntInfs) {
        DPRINT1(4, "No connection objects found inbound to %ls.\n",
            pdnDestinationDSA->StringName);
        m_fIsInitialized = TRUE;
    } else {
        m_cnAllocated = cNumEntInfs;
        m_ppcn = (KCC_CONNECTION**) THAlloc( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        if(!m_ppcn) {
            KCC_MEM_EXCEPT( cNumEntInfs*sizeof(KCC_CONNECTION*) );
        }

        m_ccn = 0;
        while (NULL != pEntInfList) {
            KCC_CONNECTION * pcn = new KCC_CONNECTION;
            m_ppcn[ m_ccn ] = pcn;

            if (pcn->Init(&pEntInfList->Entinf)) {
                m_ccn++;
            } else {

                // NTDS-Connection object is invalid.  The only case in which
                // this could happen currently is if the DSA referenced by the
                // From-Server attribute has been deleted.  In this case, we
                // ignore the connection object and, if it's inbound to the
                // local DSA, delete it from the DS.

                //
                // Only delete connection under local server's ntds-dsa object
                //
                if (KccIsEqualGUID(&pdnDestinationDSA->Guid,
                                   &pdnLocalDSA->Guid)) {
                    dirError = KccRemoveEntry( pEntInfList->Entinf.pName );
                    if (0 == dirError) {
                        LogEvent(DS_EVENT_CAT_KCC,
                                 DS_EVENT_SEV_ALWAYS,
                                 DIRLOG_CHK_REMOVED_CONN_FROM_DEAD_SERVER,
                                 szInsertDN(pEntInfList->Entinf.pName),
                                 0,
                                 0);

                        DPRINT1(0,
                                "Deleted connection %ls as it sourced from"
                                    " a deleted server.\n",
                                pEntInfList->Entinf.pName->StringName);
                    } else {
                        KCC_LOG_REMOVEENTRY_FAILURE(pEntInfList->Entinf.pName,
                                                    dirError);
                    }
                }


                //
                // Remove the from server from the list of failed
                // servers to initiate a link with since the server
                // no longer exists
                //
                ULONG iAttr;
                BYTE* pbVal;
                ATTR* pAttr;
                for (iAttr = 0;
                     iAttr < pEntInfList->Entinf.AttrBlock.attrCount;
                     iAttr++) {
                    pAttr = &(pEntInfList->Entinf.AttrBlock.pAttr[ iAttr ]);
            
                    if (ATT_FROM_SERVER == pAttr->attrTyp) {
                        Assert(1 == pAttr->AttrVal.valCount);
                        pbVal = pAttr->AttrVal.pAVal->pVal;
                        gConnectionFailureCache.Remove( (DSNAME *) pbVal );
                    }
                }

                //
                // Finally, delete the KCC_CONNECTION we allocated yet
                // failed to initialize.
                //
                delete pcn;
            }
            
            pEntInfList = pEntInfList->pNextEntInf;
        }
    }

    Assert(m_ccn <= cNumEntInfs);

    // Ensure that the search trees are all kept up to date.
    for( iConn=0; iConn<m_ccn; iConn++ ) {
        AddConnectionToSearchTrees( m_ppcn[iConn] );
    }
    m_fIsInitialized = TRUE;

    return m_fIsInitialized;
}

void
KCC_CONNECTION_LIST::AddToList(
    IN  KCC_CONNECTION *  pcn
    )
/*++

Routine Description:

    Add a new connection to the list. If the list is full, we must reallocate
    (by doubling its size). We then add this new connection to our search trees.
    
Parameters:

    pcn - New connection to add.

Returns:

    None.
    
--*/
{
    KCC_CONNECTION    **ppcnNew;
    DWORD               newIndex;

    // Increase the size of the KCC_CONNECTION array, and add the new
    // connection to it
    newIndex = m_ccn;
    m_ccn++;

    if( m_ccn > m_cnAllocated ) {
        m_cnAllocated = 2*(m_cnAllocated+10);
        if( m_ppcn ) {
            m_ppcn = (KCC_CONNECTION**) THReAlloc( m_ppcn,
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        } else {
            m_ppcn = (KCC_CONNECTION**) THAlloc(
                m_cnAllocated * sizeof(KCC_CONNECTION*) );
        }
        if(!m_ppcn) {
            KCC_MEM_EXCEPT(m_cnAllocated*sizeof(KCC_CONNECTION*));
        }
    }

    m_ppcn[newIndex] = pcn;

    // Now, update our three search trees
    AddConnectionToSearchTrees( pcn );
}

void
KCC_CONNECTION_LIST::RemoveDuplicates(
    IN  BOOL  fDeleteDuplicatesFromDatabase
    )
//
// Scan the collection of connection objects and remove duplicates.  Two
// connection objects are duplicates if they refer to the same source
// DSA.  When we do encounter duplicates, we keep only one of them.
// The general idea is that we first prefer admin-generated connections
// over auto-generated connections and newer connections over older ones,
// in that order.
//
{
    // First, sort 'em by preference.
    qsort(m_ppcn, m_ccn, sizeof(*m_ppcn), CompareForDuplicateCheck);

    // Now, any connections that source from the same DSA will be next to
    // each other in the list.  Moreover, the one that occurs later in the
    // sequence is preferred.  Remove the duplicates, leaving just the most
    // preferred connections in the list.
    DWORD icn = 0;
    while (icn+1 < m_ccn) {
        KCC_CONNECTION * pcnCurr = m_ppcn[icn];
        KCC_CONNECTION * pcnNext = m_ppcn[icn+1];

        if (0 == memcmp(&pcnCurr->GetSourceDSADN()->Guid,
                        &pcnNext->GetSourceDSADN()->Guid,
                        sizeof(GUID))) {
            // icn is a duplicate of icn+1, and icn+1 is the one we want to
            // keep.
            DPRINT2(0, "Ignoring duplicate connection object %ls in favor of %ls.\n",
                    pcnCurr->GetConnectionDN()->StringName,
                    pcnNext->GetConnectionDN()->StringName);
            
            if (!pcnCurr->IsGenerated()) {
                // The connection object we're ignoring was created by an admin.
                // Inform him of his dastardly deed.
                LogEvent(DS_EVENT_CAT_KCC,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CHK_DUPLICATE_CONNECTION,
                         szInsertDN(pcnCurr->GetConnectionDN()),
                         szInsertDN(pcnNext->GetConnectionDN()),
                         0);
            }
            else if (fDeleteDuplicatesFromDatabase &&
                     (!gConnectionDeletionCache.PreventRepeatedDeletion(
                         pcnCurr, DSID(FILENO,__LINE__) )) ) {
                // Delete duplicate connection object from the database.
                pcnCurr->Remove( DSID(FILENO,__LINE__) );
            }

            // ISSUE-2000/08/01-nickhar  Removing duplicate connections from list.
            // Performance could be improved here by using lazy deletion and a
            // final sweep to remove deleted entries. (Although we probably don't
            // remove connections very often).
            //
            // Remove connection from the in-memory connection list and free it.
            RemoveFromList(icn);
            delete pcnCurr;
        }
        else {
            // Not a duplicate; move on.
            icn++;
        }
    }
}

int __cdecl
KCC_CONNECTION_LIST::CompareForDuplicateCheck(
    IN  const void *    pv1,
    IN  const void *    pv2
    )
//
// QSort helper routine to sort connection list by preference.  If two
// connection objects have the same source DSA, the connection that is
// "greater" is preferred (and it is the one that will be translated into a
// repsFrom link).
//
{
    int nDiff;

    KCC_CONNECTION * pcn1 = *((KCC_CONNECTION **) pv1);
    KCC_CONNECTION * pcn2 = *((KCC_CONNECTION **) pv2);

    // Don't allow just one of the Guids to be NULL
    Assert( ! (   fNullUuid(&pcn1->GetSourceDSADN()->Guid)
                ^ fNullUuid(&pcn2->GetSourceDSADN()->Guid) ) );
    
    // Sort first by ascending source ntdsDsa objectGuid.
    nDiff = memcmp(&pcn1->GetSourceDSADN()->Guid,
                   &pcn2->GetSourceDSADN()->Guid,
                   sizeof(GUID));
    
    if (0 == nDiff) {
        // Same source; prefer admin-generated over auto-generated.
        nDiff = !pcn1->IsGenerated() - !pcn2->IsGenerated();
    }

    if (0 == nDiff) {
        // Same source, same "generatedness"; prefer newer connections over
        // older ones.
        nDiff = (int)(pcn1->GetWhenCreated() - pcn2->GetWhenCreated());
    }

    if (0 == nDiff) {
        // This will probably never happen.  This indicates we have two
        // connections with the same source, "generatedness", and creation time.
        // Arbitrarily choose the one with the larger objectGuid.
        nDiff = memcmp(&pcn1->GetConnectionDN()->Guid,
                       &pcn2->GetConnectionDN()->Guid,
                       sizeof(GUID));

        Assert((0 != nDiff) && "Same connection appears twice in list!");
    }

    return nDiff;
}

void
KCC_CONNECTION_LIST::UpdateTransportTypeForSite(
    IN      BOOL                    fIntraSite,
    IN OUT  KCC_CONNECTION_LIST *   pMisfitCnList
    )
//
// Scan connection list and update transport type attribute for admin generated
// connections. If the source is in the same site, and there is a transport type
// attribute, remove it. If the source is in a different site but there is no
// transport type attribute, create one, defaulting to the IP transport.
//
{
    ATTRMODLIST rgMods[1];
    ATTRVAL     AttrVal;
    ULONG       dirError;
    KCC_SITE *  pLocalSite = gpDSCache->GetLocalSite();

    for (DWORD icn = 0; icn < m_ccn; /* icn++/m_ccn-- below */ ) {
        KCC_CONNECTION *pcn = m_ppcn[icn];
        KCC_TRANSPORT  *pTransport;
        BOOL            fUpdate, fInSameSite;
        DSNAME         *pTransportDN, *pDn1, *pDn2, *pNewTransportDN;

        fUpdate = FALSE;
        pDn1 = pLocalSite->GetObjectDN();
        pDn2 = pcn->GetSourceDSA()->GetSiteDN();
        fInSameSite = (CompareDsName( &pDn1, &pDn2 ) == 0);
        pTransportDN = pcn->GetTransportDN();

        if (!fIntraSite) {

            // We're processing inter-site connections. They should always
            // have a transportType.            
            Assert( NULL != pTransportDN );
            pTransport = gpDSCache->GetTransportList()->GetTransport( pTransportDN );

            if( fInSameSite ) {
                // Connection with a transport type but source and destination
                // are in the same site.  Remove the transport type.                
                fUpdate = TRUE;
                pNewTransportDN = NULL;
            } else if( NULL==pTransport ) {
                // The connection had a non-NULL but invalid transport DN.
                // We update the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }

        } else {
            // We're processing intra-site connections. They should have no
            // transportType.
            Assert( NULL == pTransportDN );

            if( !fInSameSite ) {
                // The two endpoints of this connection are not in the same
                // site -- this is in fact an inter-site connection.
                // We set the transport type to IP. If IP is not the
                // correct transport, the KCC will have the opportunity to
                // correct this later on.
                fUpdate = TRUE;
                pNewTransportDN = gpDSCache->GetIPTransportDN();
            }
        }
        
        if (fUpdate) {
            // Update in-memory and DS objects.
            pcn->SetTransport(pNewTransportDN);
            pcn->UpdateDS();
            
            DPRINT2(0, "Updated transport type on %ls to %ls.\n",
                    pcn->GetConnectionDN()->StringName,
                    pNewTransportDN ? pNewTransportDN->StringName : L"RPC" );
            LogEvent8(DS_EVENT_CAT_KCC,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CHK_UPDATED_TRANSPORT_TYPE,
                     szInsertDN(pcn->GetConnectionDN()),
                     szInsertDN(pcn->GetSourceDSADN()),
                     szInsertDN(pcn->GetDestinationDSADN()),
                     pNewTransportDN
                        ? szInsertDN(pNewTransportDN)
                        : szInsertSz("RPC"),
                     0,0,0,0
                     );

            // Remove connection from this list and add it to the misfit list.
            RemoveFromList(icn);
            pMisfitCnList->AddToList(pcn);

        } else {
            // No connection update needed.
            icn++;
        }
    }
}
void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  DWORD   icn
    )
//
// Remove connection from the in-memory connection list.
// Does NOT delete the connection object from the DS.
//
{
    SOURCE_DSA_CONN_ARRAY    sdeKey, *sdeResult;
    SOURCE_SITE_CONN_ARRAY   sseKey, *sseResult;
    KCC_CONNECTION          *pcn;
    DWORD                    iConn, cConn;
    BOOLEAN                  fSuccess;

    Assert( m_fTreesInited );
    Assert(icn < m_ccn);
    pcn = m_ppcn[icn];

    // Remove this connection from the connection array.
    memmove(&m_ppcn[icn],
            &m_ppcn[icn+1],
            (m_ccn - icn - 1) * sizeof(*m_ppcn));
    m_ccn--;


    // Remove this connection from the dsname search tree
    fSuccess = RtlDeleteElementGenericTable( &m_dsnameSearchTree, &pcn );
    Assert( TRUE==fSuccess );

    
    // Find this list of connections corresponding to this source dsa in the
    // source dsa search tree
    Assert( !fNullUuid(&pcn->GetSourceDSA()->GetDsName()->Guid) );
    memcpy( &sdeKey.uuid, &pcn->GetSourceDSA()->GetDsName()->Guid, sizeof(UUID) );
    sdeKey.numConnections = 0;
    sdeKey.connection = NULL;
    sdeResult = (SOURCE_DSA_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceDsaSearchTree, &sdeKey );
    if( NULL==sdeResult ) {

        Assert( !"RtlLookupElementGenericTable() returned NULL unexpectedly" );
    
    } else {

        // Scan the list of connections corresponding to this source dsa, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sdeResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sdeResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sdeResult->connection[iConn],
                &sdeResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sdeResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this dsa, we remove this list from the sourceDsaSearchTree.
        if( sdeResult->numConnections==0 ) {
            THFree( sdeResult->connection );
            sdeResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceDsaSearchTree, sdeResult );
            Assert( TRUE==fSuccess );
        }
    }

    // Find this list of connections corresponding to this source site in the
    // source site search tree
    sseKey.siteDN = pcn->GetSourceSiteDN();
    sseKey.numConnections = 0;
    sseKey.connection = NULL;
    sseResult = (SOURCE_SITE_CONN_ARRAY*) RtlLookupElementGenericTable(
        &m_sourceSiteSearchTree, &sseKey );
    if( NULL==sseResult ) {

        Assert( NULL!=sseResult );

    } else {
    
        // Scan the list of connections corresponding to this source site, and
        // remove entry 'pcn'
        fSuccess = FALSE;
        cConn = sseResult->numConnections;
        for( iConn=0; iConn<cConn; iConn++ ) {
    
            if( sseResult->connection[iConn]!=pcn ) {
                continue;
            }
    
            // We found the entry to remove. Slide its successors down,
            // but don't bother to reclaim the memory.
            memmove(
                &sseResult->connection[iConn],
                &sseResult->connection[iConn+1],
                (cConn-1-iConn) * sizeof(KCC_CONNECTION*)
                );
            sseResult->numConnections--;
            fSuccess = TRUE;
            break;
        }
        Assert( TRUE==fSuccess );
    
        // If all items have been removed from the list of connections corresponding
        // to this site, we remove this list from the sourceSiteSearchTree.
        if( sseResult->numConnections==0 ) {
            THFree( sseResult->connection );
            sseResult->connection=NULL;
    
            fSuccess = RtlDeleteElementGenericTable( &m_sourceSiteSearchTree, sseResult );
            Assert( TRUE==fSuccess );
        }
    }
}

void
KCC_CONNECTION_LIST::RemoveFromList(
    IN  KCC_CONNECTION *  pcn
    )
//
// Remove connection from the in-memory connection list.
//
{
    for (DWORD icn = 0; icn < m_ccn; icn++) {
        if (pcn == m_ppcn[icn]) {
            break;
        }
    }

    Assert((icn < m_ccn) && "pcn must be in list!");
    
    RemoveFromList(icn);
}


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTRASITE_CONNECTION_LIST methods
//

/* (All inlined.) */


///////////////////////////////////////////////////////////////////////////////
//
//  KCC_INTERSITE_CONNECTION_LIST methods
//

VOID
KCC_INTERSITE_CONNECTION_LIST::UpdateStaleServerCache()
//
// Update the stale server cache with info from the destination bridgeheads.
//
{
    HANDLE                      hDS;
    DSNAME *                    pdnDestDSA;
    DWORD                       err;
    LPWSTR                      pszDestAddr;
    DS_REPL_KCC_DSA_FAILURESW * pFailures = NULL;
    DS_REPL_KCC_DSA_FAILUREW *  pFailure;
    DWORD                       iFail;
    DSNAME *                    pdnLocalDSA = gpDSCache->GetLocalDSADN();
    
    ASSERT_VALID(this);

    if (0 == m_ccn) {
        return;
    }

    pdnDestDSA = m_ppcn[0]->GetDestinationDSADN();

    // Note that we already have a cache of our own failures.
    if (NameMatched(pdnDestDSA, pdnLocalDSA)) {
        return;
    }

    // Contact the inbound bridgehead and ask it how replication is doing.
    pszDestAddr = GuidBasedDNSNameFromDSName(pdnDestDSA);

    err = DsBindW(pszDestAddr, NULL, &hDS);
    if (err) {
        // Inbound bridgehead not reachable.
        DPRINT2(0, "Cannot reach %ls to get staleness info, error %d.\n",
                pdnDestDSA->StringName, err);
        gConnectionFailureCache.Add(pdnDestDSA, err, FALSE);
        return;
    }

    __try {
        // Destination contacted; remove it if it's in the stale cache.
        gConnectionFailureCache.Remove(pdnDestDSA);

        Assert(NULL == pFailures);

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err || !pFailures) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gConnectionFailureCache.UpdateEntry(pFailure);
                }
            }
        }
    
        if (NULL != pFailures) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, pFailures);
            pFailures = NULL;
        }

        err = DsReplicaGetInfoW(hDS,
                                DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                NULL,
                                NULL,
                                (void **) &pFailures);
        if (err) {
            DPRINT2(0, "DsReplicaGetInfoW() from %ls failed with error %d.\n",
                    pdnDestDSA->StringName, err);
        }
        else {
            // Update failure cache with any reported failures with respect
            // to remote site bridgeheads we believe the local bridgehead
            // should be replicating from.

            for (iFail = 0; iFail < pFailures->cNumEntries; iFail++) {
                pFailure = &pFailures->rgDsaFailure[iFail];
                if (NULL != GetConnectionFromSourceDSAUUID(
                                &pFailure->uuidDsaObjGuid)) {
                    gLinkFailureCache.UpdateEntry(pFailure);
                }
            }
        }
    }
    __finally {
        if (NULL != pFailures) {
            // LINK_FAILURES and CONNECT_FAILURES are allocated/freed the
            // same way, so it doesn't matter which it is.
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                              pFailures);
            pFailures = NULL;
        }

        DsUnBindW(&hDS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\kcc\kcccref.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcccref.cxx

ABSTRACT:

    KCC_CROSSREF and KCC_CROSSREF_LIST classes.

DETAILS:

    These classes represent a single Cross-Ref DS object and a collection
    thereof, resp.

    Cross-Ref DS objects are found in the CN=Partitions,CN=Configuration,...
    container.  They represent partitions of the DS namespace (NCs) in the
    enterprise, be they hosted by NT DS or by a foreign DS.

CREATED:

    01/21/97    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include "kcc.hxx"
#include "kcccref.hxx"
#include "kccduapi.hxx"
#include "kcctools.hxx"

#define FILENO FILENO_KCC_KCCCREF

void
KCC_CROSSREF::Reset()
//
// Reset member variables to their pre-Init() state.
//
{
    m_pdnNC              = NULL;
    m_fIsReplicatedToGCs = FALSE;
    m_NCType             = KCC_NC_TYPE_INVALID;
    m_crCategory         = KCC_CR_CAT_INVALID;
    m_pLinkList          = NULL;
    m_fSiteArraysInited  = FALSE;

    m_NCReplicaLocationsArray.RemoveAll();
}

BOOL
KCC_CROSSREF::IsValid()
//
// Is this object internally consistent?
//
{
    return (NULL != m_pdnNC)
           && (KCC_NC_TYPE_INVALID != m_NCType)
           && m_NCReplicaLocationsArray.IsValid();
}

BOOL
KCC_CROSSREF::IsDSAPresentInNCReplicaLocations(
    IN  KCC_DSA *   pDSA
    )
//
// Is the given DSA a value for the NC-Replica-Locations attribute of this
// cross-ref object?
//
{
    Assert(KCC_NC_TYPE_NONDOMAIN == m_NCType);
    return m_NCReplicaLocationsArray.IsElementOf(pDSA->GetDsName());
}

BOOL
KCC_CROSSREF::Init(
    IN  ENTINF *    pEntInf
    )
//
// Initialize the internal object from an ENTINF describing a corresponding
// Cross-Ref DS object.
//
{
    DWORD   iAttr;
    ATTR *  pAttr;
    BOOL    fSuccess = FALSE;
    DWORD   dwSystemFlags = 0;

    Reset();

    DPRINT1(5, "Parsing cross-ref %ls.\n", pEntInf->pName->StringName );

    for (iAttr = 0; iAttr < pEntInf->AttrBlock.attrCount; iAttr++) {
        pAttr = &pEntInf->AttrBlock.pAttr[ iAttr ];

        switch (pAttr->attrTyp) {
        case ATT_NC_NAME:
            Assert(1 == pAttr->AttrVal.valCount);
            m_pdnNC = (DSNAME *) pAttr->AttrVal.pAVal->pVal;
            // Validation: DN not semantically validated
            break;

        case ATT_SYSTEM_FLAGS:
            Assert(1 == pAttr->AttrVal.valCount);
            dwSystemFlags = *((DWORD *) pAttr->AttrVal.pAVal->pVal);
            // Validation: Bitmap not semantically validated
            break;

        case ATT_MS_DS_NC_REPLICA_LOCATIONS:
            for (DWORD iValue = 0; iValue < pAttr->AttrVal.valCount; iValue++) {
                DSNAME * pDN = (DSNAME *) pAttr->AttrVal.pAVal[iValue].pVal;
                m_NCReplicaLocationsArray.Add(pDN);
                // Validation: DN not semantically validated because it doesn't
                // need to be.
            }
            break;
        
        default:
            DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pAttr->attrTyp );
            break;
        }
    }

    // NC-Name is a System-Must-Have on Cross-Ref objects.
    Assert(NULL != m_pdnNC);

    if (!(dwSystemFlags & FLAG_CR_NTDS_NC)) {
        // This partition lives e.g. on a Netscape, NDS, or other-forest NT5
        // server.
        DPRINT1(3, "Ignoring crossRef for NC %ls not hosted by our forest.\n",
                m_pdnNC->StringName);
    }
    else if (fNullUuid(&m_pdnNC->Guid)) {
        // This can occur for crossRefs for a new domain at the root of a new
        // tree in our forest.  Lack of a guid indicates that replication of
        // the guid in the config NC (which happens after DCPROMO, when pre-
        // existing DCs replicate the config NC from the newly installed DC)
        // has not yet occurred.
        DPRINT1(0, "Ignoring cross-ref for NC %ls because the NC has no guid.\n",
                m_pdnNC->StringName);
        LogEvent(
            DS_EVENT_CAT_KCC,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_KCC_NC_HEAD_NOT_FOUND,
            szInsertDN(m_pdnNC),
            NULL, 
            NULL
            );
    }
    else {
        // Cross-ref is viable for topology generation.
        
        if (dwSystemFlags & FLAG_CR_NTDS_DOMAIN) {
            m_NCType = KCC_NC_TYPE_DOMAIN;
        } else if (KccIsSchemaNc(m_pdnNC)) {
            m_NCType = KCC_NC_TYPE_SCHEMA;
        } else if (KccIsConfigurationNc(m_pdnNC)) {
            m_NCType = KCC_NC_TYPE_CONFIG;
        } else {
            m_NCType = KCC_NC_TYPE_NONDOMAIN;
        }

        if (KCC_NC_TYPE_NONDOMAIN == m_NCType) {
            // Is a cross-ref for a native non-(domain|config|schema) NC.
            m_NCReplicaLocationsArray.Sort();
        } else {
            // This is not a cross-ref for a non-domain NC -- ignore any values
            // for NC-Replica-Locations.
            m_NCReplicaLocationsArray.RemoveAll();
        }

        m_fIsReplicatedToGCs = !(m_NCType & FLAG_CR_NTDS_NOT_GC_REPLICATED);
        
        fSuccess = TRUE;
    }

    return fSuccess;
}

VOID
KCC_CROSSREF::InitSiteArrays()
//
// Create two arrays: m_writeableSites and m_partialSites.
// The former contains pointers to sites which host a writeable copy of
// this NC. The latter contains pointers to sites which only have a
// partial copy of this NC.
//
{
    KCC_SITE_LIST*  pSiteList = gpDSCache->GetSiteList();
    DWORD           isite, csite;

    ASSERT_VALID(this);
    if( m_fSiteArraysInited ) {
        // Already initialized -- no work to do here.
        return;
    }

    // Site arrays have not been inited yet -- must be empty.
    Assert( m_writeableSites.GetCount()==0 );
    Assert( m_partialSites.GetCount()==0 );

    ASSERT_VALID( pSiteList );
    csite = pSiteList->GetCount();

    for( isite=0; isite<csite; isite++ ) {
        KCC_SITE *      psite = pSiteList->GetSite(isite);
        BOOL            fIsLocal = (psite == gpDSCache->GetLocalSite());
        KCC_DSA_LIST *  pDsaList = psite->GetDsaList();
        DWORD           idsa, cdsa = pDsaList->GetCount();
        BOOL            fPartialExists=FALSE, fWriteableExists=FALSE;

        ASSERT_VALID(psite);
        ASSERT_VALID(pDsaList);

        for( idsa=0; idsa<cdsa; idsa++ ) {
            BOOL      fIsMaster;
            KCC_DSA * pdsa = pDsaList->GetDsa( idsa );

            ASSERT_VALID(pdsa);
            if (pdsa->IsNCHost(this, fIsLocal, &fIsMaster)) {
                if (fIsMaster) {
                    // This site contains a ds with a writable copy of 
                    // this naming context
                    m_writeableSites.Add( psite );
                    fWriteableExists = TRUE;
                    break;
                } else {
                    // This NC is instantiated as a partial replica on this DSA
                    // Remember this as we need this info there are no writeable
                    // copies of the NC in the site
                    fPartialExists = TRUE;
                }
            }
        } // end iteration over DSAs in the site

        if (!fWriteableExists && fPartialExists) {
            // There are no writeable replicas of this NC in this site,
            // but a partial replica exists - candidate for GC inter-site topology
            m_partialSites.Add( psite );
        }
    } // end iteration over the sites 

    m_fSiteArraysInited = TRUE;
}


VOID
KCC_CROSSREF::CheckForOrphans()
//
// Log an event if the NC is either:
//  - hosted only at this site, but has not been instantiated here yet.
//  - partial at this site, but no writeable copies exist.
//
{
    KCC_SITE           *pLocalSite = gpDSCache->GetLocalSite();
    KCC_DSA_LIST       *pDsaList = pLocalSite->GetDsaList();
    KCC_NC_COMING_TYPE  isComing;
    BOOL                fInstantiated=FALSE;
    DWORD               idsa, cdsa;

    ASSERT_VALID(this);
    ASSERT_VALID(pDsaList);
    InitSiteArrays();

    if (   (   m_writeableSites.GetCount()==1
            && m_writeableSites.IsElementOf(pLocalSite) )
        || (   m_partialSites.GetCount()==1
            && m_writeableSites.GetCount()==0                    
            && m_partialSites.IsElementOf(pLocalSite) ) )
    {
        // Examine all DSAs in the local site to see if NC has
        // been instantiated somewhere.
        cdsa = pDsaList->GetCount();
        for( idsa=0; idsa<cdsa; idsa++ ) {
            KCC_DSA * pdsa = pDsaList->GetDsa( idsa );
            ASSERT_VALID(pdsa);
            
            if(   pdsa->IsNCInstantiated(GetNCDN(), NULL, &isComing)
               && KCC_NC_IS_COMING!=isComing )
            {
                // If the NC is instantiated, and we do not have any
                // evidence that it is still in the 'coming' stage, we
                // accept the fact that the NC is instantiated.
                fInstantiated=TRUE;
                break;
            }
        }

        if( ! fInstantiated ) {
            DPRINT1(0, "NC %ws is not instantiated at local site, but not "
                    "hosted in any other sites either!\n",
                    GetNCDN()->StringName);
            LogEvent(
                DS_EVENT_CAT_KCC,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_KCC_NC_NOT_INSTANTIATED_ANYWHERE,
                szInsertDN(GetNCDN()),
                szInsertDN(pLocalSite->GetObjectDN()),                        
                NULL
                ); 
        }           
    }

    // Check if we have a partial replica but no writeable replicas exist.
    if(   (m_partialSites.GetCount() > 0)
       && (m_partialSites.IsElementOf(pLocalSite))
       && (m_writeableSites.GetCount()==0) )
    {
        DPRINT1(0, "A partial repl