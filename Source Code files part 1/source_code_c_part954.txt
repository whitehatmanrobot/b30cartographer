HELPCTR_BASE_HSI                              (DISPID_PCH_HELPCTR_BASE + 0x0600) // IPCHHelpSessionItem

#define DISPID_PCH_HELPCTR_BASE_US2                              (DISPID_PCH_HELPCTR_BASE + 0x0700) // IPCHUserSettings2
#define DISPID_PCH_HELPCTR_BASE_FAV                              (DISPID_PCH_HELPCTR_BASE + 0x0800) // IPCHFavorites
#define DISPID_PCH_HELPCTR_BASE_O                                (DISPID_PCH_HELPCTR_BASE + 0x0900) // IPCHOptions

#define DISPID_PCH_HELPCTR_BASE_CM                               (DISPID_PCH_HELPCTR_BASE + 0x0980) // IPCHContextMenu

#define DISPID_PCH_HELPCTR_BASE_PE                               (DISPID_PCH_HELPCTR_BASE + 0x0A00) // IPCHPrintEngine
#define DISPID_PCH_HELPCTR_BASE_PEE                              (DISPID_PCH_HELPCTR_BASE + 0x0A50) // DPCHPrintEngineEvents

#define DISPID_PCH_HELPCTR_BASE_TB                               (DISPID_PCH_HELPCTR_BASE + 0x0B00) // IPCHToolBar
#define DISPID_PCH_HELPCTR_BASE_TBE                              (DISPID_PCH_HELPCTR_BASE + 0x0B20) // DPCHToolBarEvents

#define DISPID_PCH_HELPCTR_BASE_PB                               (DISPID_PCH_HELPCTR_BASE + 0x0B40) // IPCHProgressBar

#define DISPID_PCH_HELPCTR_BASE_C                                (DISPID_PCH_HELPCTR_BASE + 0x0C00) // IPCHConnectivity
#define DISPID_PCH_HELPCTR_BASE_CN                               (DISPID_PCH_HELPCTR_BASE + 0x0C40) // IPCHConnectionCheck
#define DISPID_PCH_HELPCTR_BASE_CNE                              (DISPID_PCH_HELPCTR_BASE + 0x0C80) // DPCHConnectionCheckEvents

#define DISPID_PCH_HELPCTR_BASE_INC                              (DISPID_PCH_HELPCTR_BASE + 0x0D00) // ISAFIntercomClient
#define DISPID_PCH_HELPCTR_BASE_INCE                             (DISPID_PCH_HELPCTR_BASE + 0x0D40) // DSAFIntercomClientEvents

#define DISPID_PCH_HELPCTR_BASE_INS                              (DISPID_PCH_HELPCTR_BASE + 0x0E00) // ISAFIntercomServer
#define DISPID_PCH_HELPCTR_BASE_INSE                             (DISPID_PCH_HELPCTR_BASE + 0x0E40) // DSAFIntercomServerEvents

#define DISPID_PCH_HELPCTR_BASE_TH                               (DISPID_PCH_HELPCTR_BASE + 0x0F00) // IPCHTextHelpers
#define DISPID_PCH_HELPCTR_BASE_PU                               (DISPID_PCH_HELPCTR_BASE + 0x0F40) // IPCHParsedURL

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DISPID_PCH_HCE__HELPSESSION                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x00)
#define DISPID_PCH_HCE__CHANNELS                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x01)
#define DISPID_PCH_HCE__USERSETTINGS                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x02)
#define DISPID_PCH_HCE__SECURITY                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x03)
#define DISPID_PCH_HCE__CONNECTIVITY                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x04)
#define DISPID_PCH_HCE__DATABASE                                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x05)
#define DISPID_PCH_HCE__TEXTHELPERS                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x06)
#define DISPID_PCH_HCE__EXTRAARGUMENT                            (DISPID_PCH_HELPCTR_BASE_HCE   + 0x07)
																									
#define DISPID_PCH_HCE__HELPVIEWER                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x10)
#define DISPID_PCH_HCE__UI_NAVBAR                                (DISPID_PCH_HELPCTR_BASE_HCE   + 0x11)
#define DISPID_PCH_HCE__UI_MININAVBAR                            (DISPID_PCH_HELPCTR_BASE_HCE   + 0x12)
#define DISPID_PCH_HCE__UI_CONTEXT                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x13)
#define DISPID_PCH_HCE__UI_CONTENTS                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x14)
#define DISPID_PCH_HCE__UI_HHWINDOW                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x15)
																									
#define DISPID_PCH_HCE__WEB_CONTEXT                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x18)
#define DISPID_PCH_HCE__WEB_CONTENTS                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x19)
#define DISPID_PCH_HCE__WEB_HHWINDOW                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x1A)
																									
#define DISPID_PCH_HCE__REGISTEREVENTS                           (DISPID_PCH_HELPCTR_BASE_HCE   + 0x20)
#define DISPID_PCH_HCE__UNREGISTEREVENTS                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x21)
																									
																									
#define DISPID_PCH_HCE__CREATEOBJECT_SEARCHENGINEMGR             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x30)
#define DISPID_PCH_HCE__CREATEOBJECT_DATACOLLECTION              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x31)
#define DISPID_PCH_HCE__CREATEOBJECT_CABINET                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x32)
#define DISPID_PCH_HCE__CREATEOBJECT_ENCRYPTION                  (DISPID_PCH_HELPCTR_BASE_HCE   + 0x33)
#define DISPID_PCH_HCE__CREATEOBJECT_INCIDENT                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x34)
#define DISPID_PCH_HCE__CREATEOBJECT_CHANNEL                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x35)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPSESSION        (DISPID_PCH_HELPCTR_BASE_HCE   + 0x36)
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPMANAGER        (DISPID_PCH_HELPCTR_BASE_HCE   + 0x37)
#define DISPID_PCH_HCE__CREATEOBJECT_REMOTEDESKTOPCONNECTION     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x38)
#define DISPID_PCH_HCE__CONNECTTOEXPERT                          (DISPID_PCH_HELPCTR_BASE_HCE   + 0x39)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_INTERCOMCLIENT              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3B)
#define DISPID_PCH_HCE__CREATEOBJECT_INTERCOMSERVER              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3C)
																									
#define DISPID_PCH_HCE__CREATEOBJECT_CONTEXTMENU                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3D)
#define DISPID_PCH_HCE__CREATEOBJECT_PRINTENGINE                 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x3E)
																									
																									
#define DISPID_PCH_HCE__OPENFILEASSTREAM                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x50)
#define DISPID_PCH_HCE__CREATEFILEASSTREAM                       (DISPID_PCH_HELPCTR_BASE_HCE   + 0x51)
#define DISPID_PCH_HCE__COPYSTREAMTOFILE                         (DISPID_PCH_HELPCTR_BASE_HCE   + 0x52)
																									
#define DISPID_PCH_HCE__NETWORKALIVE                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x60)
#define DISPID_PCH_HCE__DESTINATIONREACHABLE                     (DISPID_PCH_HELPCTR_BASE_HCE   + 0x61)
#define DISPID_PCH_HCE__FORMATERROR                              (DISPID_PCH_HELPCTR_BASE_HCE   + 0x62)
#define DISPID_PCH_HCE__REGREAD                               	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x63)
#define DISPID_PCH_HCE__REGWRITE                              	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x64)
#define DISPID_PCH_HCE__REGDELETE                              	 (DISPID_PCH_HELPCTR_BASE_HCE   + 0x65)
																									
#define DISPID_PCH_HCE__CLOSE                                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x70)
#define DISPID_PCH_HCE__REFRESHUI                                (DISPID_PCH_HELPCTR_BASE_HCE   + 0x71)
#define DISPID_PCH_HCE__PRINT                                    (DISPID_PCH_HELPCTR_BASE_HCE   + 0x72)
#define DISPID_PCH_HCE__HIGHLIGHTWORDS                           (DISPID_PCH_HELPCTR_BASE_HCE   + 0x73)
#define DISPID_PCH_HCE__MESSAGEBOX                               (DISPID_PCH_HELPCTR_BASE_HCE   + 0x74)
#define DISPID_PCH_HCE__SELECTFOLDER                             (DISPID_PCH_HELPCTR_BASE_HCE   + 0x75)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_E__ACTION                                     (DISPID_PCH_HELPCTR_BASE_E     + 0x00)
#define DISPID_PCH_E__CANCEL                                     (DISPID_PCH_HELPCTR_BASE_E     + 0x01)
																									
#define DISPID_PCH_E__URL                                        (DISPID_PCH_HELPCTR_BASE_E     + 0x02)
#define DISPID_PCH_E__FRAME                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x03)
#define DISPID_PCH_E__PANEL                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x04)
#define DISPID_PCH_E__PLACE                                      (DISPID_PCH_HELPCTR_BASE_E     + 0x05)
																									
#define DISPID_PCH_E__CURRENTCONTEXT                             (DISPID_PCH_HELPCTR_BASE_E     + 0x10)
#define DISPID_PCH_E__PREVIOUSCONTEXT                            (DISPID_PCH_HELPCTR_BASE_E     + 0x11)
#define DISPID_PCH_E__NEXTCONTEXT                                (DISPID_PCH_HELPCTR_BASE_E     + 0x12)
																									
																									
#define DISPID_PCH_E_FIRSTEVENT                                  (DISPID_PCH_HELPCTR_BASE_E     + 0x80) //#### MARKER
#define DISPID_PCH_E_BEFORENAVIGATE                              (DISPID_PCH_E_FIRSTEVENT       + 0x00)
#define DISPID_PCH_E_NAVIGATECOMPLETE                            (DISPID_PCH_E_FIRSTEVENT       + 0x01)
#define DISPID_PCH_E_BEFORETRANSITION                            (DISPID_PCH_E_FIRSTEVENT       + 0x02)
#define DISPID_PCH_E_TRANSITION                                  (DISPID_PCH_E_FIRSTEVENT       + 0x03)
#define DISPID_PCH_E_BEFORECONTEXTSWITCH                         (DISPID_PCH_E_FIRSTEVENT       + 0x04)
#define DISPID_PCH_E_CONTEXTSWITCH                               (DISPID_PCH_E_FIRSTEVENT       + 0x05)
#define DISPID_PCH_E_PERSISTLOAD                                 (DISPID_PCH_E_FIRSTEVENT       + 0x06)
#define DISPID_PCH_E_PERSISTSAVE                                 (DISPID_PCH_E_FIRSTEVENT       + 0x07)
#define DISPID_PCH_E_TRAVELDONE                                  (DISPID_PCH_E_FIRSTEVENT       + 0x08)
#define DISPID_PCH_E_SHUTDOWN                                    (DISPID_PCH_E_FIRSTEVENT       + 0x09)
#define DISPID_PCH_E_PRINT                                       (DISPID_PCH_E_FIRSTEVENT       + 0x0A)
#define DISPID_PCH_E_SWITCHEDHELPFILES                           (DISPID_PCH_E_FIRSTEVENT       + 0x0B)
#define DISPID_PCH_E_FAVORITESUPDATE                             (DISPID_PCH_E_FIRSTEVENT       + 0x0C)
#define DISPID_PCH_E_OPTIONSCHANGED                              (DISPID_PCH_E_FIRSTEVENT       + 0x0D)
#define DISPID_PCH_E_CSSCHANGED                                  (DISPID_PCH_E_FIRSTEVENT       + 0x0E)
#define DISPID_PCH_E_LASTEVENT                                   (DISPID_PCH_E_FIRSTEVENT       + 0x0F) //##### MARKER
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_SS__SIZE                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x00)
																									
#define DISPID_PCH_SS__READ                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x01)
#define DISPID_PCH_SS__READHEX                                   (DISPID_PCH_HELPCTR_BASE_SS    + 0x02)
																									
#define DISPID_PCH_SS__WRITE                                     (DISPID_PCH_HELPCTR_BASE_SS    + 0x03)
#define DISPID_PCH_SS__WRITEHEX                                  (DISPID_PCH_HELPCTR_BASE_SS    + 0x04)
																									
#define DISPID_PCH_SS__SEEK                                      (DISPID_PCH_HELPCTR_BASE_SS    + 0x05)
#define DISPID_PCH_SS__CLOSE                                     (DISPID_PCH_HELPCTR_BASE_SS    + 0x06)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HCIPC__NAVIGATE                               (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x00)
#define DISPID_PCH_HCIPC__CLOSE                                  (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x01)
#define DISPID_PCH_HCIPC__POPUP                                  (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x02)
#define DISPID_PCH_HCIPC__PING                                   (DISPID_PCH_HELPCTR_BASE_HCIPC + 0x03)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HVW__WEBBROWSER                               (DISPID_PCH_HELPCTR_BASE_HVW   + 0x00)
																									
#define DISPID_PCH_HVW__NAVIGATE                                 (DISPID_PCH_HELPCTR_BASE_HVW   + 0x10)
#define DISPID_PCH_HVW__PRINT                                    (DISPID_PCH_HELPCTR_BASE_HVW   + 0x11)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HS__CURRENTCONTEXT                            (DISPID_PCH_HELPCTR_BASE_HS    + 0x00)
																									
#define DISPID_PCH_HS__VISITEDHELPPAGES                          (DISPID_PCH_HELPCTR_BASE_HS    + 0x10)
																									
#define DISPID_PCH_HS__SETTITLE                                  (DISPID_PCH_HELPCTR_BASE_HS    + 0x20)
#define DISPID_PCH_HS__FORCENAVIGATION                           (DISPID_PCH_HELPCTR_BASE_HS    + 0x21)
#define DISPID_PCH_HS__IGNORENAVIGATION                          (DISPID_PCH_HELPCTR_BASE_HS    + 0x22)
#define DISPID_PCH_HS__ERASENAVIGATION                           (DISPID_PCH_HELPCTR_BASE_HS    + 0x23)
#define DISPID_PCH_HS__ISNAVIGATING                              (DISPID_PCH_HELPCTR_BASE_HS    + 0x24)
																									
#define DISPID_PCH_HS__BACK                                      (DISPID_PCH_HELPCTR_BASE_HS    + 0x30)
#define DISPID_PCH_HS__FORWARD                                   (DISPID_PCH_HELPCTR_BASE_HS    + 0x31)
#define DISPID_PCH_HS__ISVALID                                   (DISPID_PCH_HELPCTR_BASE_HS    + 0x32)
#define DISPID_PCH_HS__NAVIGATE                                  (DISPID_PCH_HELPCTR_BASE_HS    + 0x33)
																									
#define DISPID_PCH_HS__CHANGECONTEXT                             (DISPID_PCH_HELPCTR_BASE_HS    + 0x40)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_HSI__SKU                                      (DISPID_PCH_HELPCTR_BASE_HSI   + 0x00)
#define DISPID_PCH_HSI__LANGUAGE                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x01)
																									
#define DISPID_PCH_HSI__URL                                      (DISPID_PCH_HELPCTR_BASE_HSI   + 0x02)
#define DISPID_PCH_HSI__TITLE                                    (DISPID_PCH_HELPCTR_BASE_HSI   + 0x03)
#define DISPID_PCH_HSI__LASTVISITED                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x04)
#define DISPID_PCH_HSI__DURATION                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x05)
#define DISPID_PCH_HSI__NUMOFHITS                                (DISPID_PCH_HELPCTR_BASE_HSI   + 0x06)
																									
#define DISPID_PCH_HSI__CONTEXTNAME                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x07)
#define DISPID_PCH_HSI__CONTEXTINFO                              (DISPID_PCH_HELPCTR_BASE_HSI   + 0x08)
#define DISPID_PCH_HSI__CONTEXTURL                               (DISPID_PCH_HELPCTR_BASE_HSI   + 0x09)
																									
#define DISPID_PCH_HSI__PROPERTY                                 (DISPID_PCH_HELPCTR_BASE_HSI   + 0x0A)
																									
#define DISPID_PCH_HSI__CHECKPROPERTY                            (DISPID_PCH_HELPCTR_BASE_HSI   + 0x10)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_US2__FAVORITES                                (DISPID_PCH_HELPCTR_BASE_US2   + 0x00)
#define DISPID_PCH_US2__OPTIONS                                  (DISPID_PCH_HELPCTR_BASE_US2   + 0x01)
#define DISPID_PCH_US2__SCOPE                                    (DISPID_PCH_HELPCTR_BASE_US2   + 0x02)
																									
#define DISPID_PCH_US2__ISREMOTESESSION                          (DISPID_PCH_HELPCTR_BASE_US2   + 0x10)
#define DISPID_PCH_US2__ISTERMINALSERVER                         (DISPID_PCH_HELPCTR_BASE_US2   + 0x11)
#define DISPID_PCH_US2__ISDESKTOPVERSION                         (DISPID_PCH_HELPCTR_BASE_US2   + 0x12)
																									
#define DISPID_PCH_US2__ISADMIN                                  (DISPID_PCH_HELPCTR_BASE_US2   + 0x20)
#define DISPID_PCH_US2__ISPOWERUSER                              (DISPID_PCH_HELPCTR_BASE_US2   + 0x21)
																									
#define DISPID_PCH_US2__ISSTARTPANELON                           (DISPID_PCH_HELPCTR_BASE_US2   + 0x30)
#define DISPID_PCH_US2__ISWEBVIEWBARRICADEON                     (DISPID_PCH_HELPCTR_BASE_US2   + 0x31)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_FAV__ISDUPLICATE                              (DISPID_PCH_HELPCTR_BASE_FAV   + 0x00)
#define DISPID_PCH_FAV__ADD                                      (DISPID_PCH_HELPCTR_BASE_FAV   + 0x01)
#define DISPID_PCH_FAV__RENAME                                   (DISPID_PCH_HELPCTR_BASE_FAV   + 0x02)
#define DISPID_PCH_FAV__MOVE                                     (DISPID_PCH_HELPCTR_BASE_FAV   + 0x03)
#define DISPID_PCH_FAV__DELETE                                   (DISPID_PCH_HELPCTR_BASE_FAV   + 0x04)

/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_O__SHOWFAVORITES                              (DISPID_PCH_HELPCTR_BASE_O 	+ 0x00)
#define DISPID_PCH_O__SHOWHISTORY                                (DISPID_PCH_HELPCTR_BASE_O 	+ 0x01)
#define DISPID_PCH_O__FONTSIZE                                   (DISPID_PCH_HELPCTR_BASE_O 	+ 0x02)
#define DISPID_PCH_O__TEXTLABELS                                 (DISPID_PCH_HELPCTR_BASE_O 	+ 0x03)
#define DISPID_PCH_O__DISABLESCRIPTDEBUGGER                      (DISPID_PCH_HELPCTR_BASE_O 	+ 0x04)

#define DISPID_PCH_O__APPLY                                      (DISPID_PCH_HELPCTR_BASE_O 	+ 0x10)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_CM__ADDITEM                                   (DISPID_PCH_HELPCTR_BASE_CM    + 0x00)
#define DISPID_PCH_CM__ADDSEPARATOR                              (DISPID_PCH_HELPCTR_BASE_CM    + 0x01)
#define DISPID_PCH_CM__DISPLAY                                   (DISPID_PCH_HELPCTR_BASE_CM    + 0x02)

/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PE__ONPROGRESS                                (DISPID_PCH_HELPCTR_BASE_PE    + 0x00)
#define DISPID_PCH_PE__ONCOMPLETE                                (DISPID_PCH_HELPCTR_BASE_PE    + 0x01)
																									
#define DISPID_PCH_PE__ADDTOPIC                                  (DISPID_PCH_HELPCTR_BASE_PE    + 0x10)
#define DISPID_PCH_PE__START                                     (DISPID_PCH_HELPCTR_BASE_PE    + 0x11)
#define DISPID_PCH_PE__ABORT                                     (DISPID_PCH_HELPCTR_BASE_PE    + 0x12)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PEE__ONPROGRESS                               (DISPID_PCH_HELPCTR_BASE_PEE   + 0x00)
#define DISPID_PCH_PEE__ONCOMPLETE                               (DISPID_PCH_HELPCTR_BASE_PEE   + 0x01)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_TB__DEFINITION                                (DISPID_PCH_HELPCTR_BASE_TB    + 0x00)
#define DISPID_PCH_TB__MODE                                      (DISPID_PCH_HELPCTR_BASE_TB    + 0x01)
																									
#define DISPID_PCH_TB__SETSTATE                                  (DISPID_PCH_HELPCTR_BASE_TB    + 0x08)
#define DISPID_PCH_TB__SETVISIBILITY                             (DISPID_PCH_HELPCTR_BASE_TB    + 0x09)
																									
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_TBE__ONCOMMAND                                (DISPID_PCH_HELPCTR_BASE_TBE   + 0x00)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_PB__LOWLIMIT                                  (DISPID_PCH_HELPCTR_BASE_PB    + 0x00)
#define DISPID_PCH_PB__HIGHLIMIT                                 (DISPID_PCH_HELPCTR_BASE_PB    + 0x01)
#define DISPID_PCH_PB__POS                                       (DISPID_PCH_HELPCTR_BASE_PB    + 0x02)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_INC__CONNECT                                  (DISPID_PCH_HELPCTR_BASE_INC   + 0x21)
#define DISPID_PCH_INC__DISCONNECT                               (DISPID_PCH_HELPCTR_BASE_INC   + 0x22)
#define DISPID_PCH_INC__STOPVOICE                                (DISPID_PCH_HELPCTR_BASE_INC   + 0x23)
#define DISPID_PCH_INC__STARTVOICE                               (DISPID_PCH_HELPCTR_BASE_INC   + 0x24)
#define DISPID_PCH_INC__EXIT                                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x25)
																									
#define DISPID_PCH_INC__RUNSETUPWIZARD							 (DISPID_PCH_HELPCTR_BASE_INC   + 0x30)
#define DISPID_PCH_INC__SAMPLINGRATE							 (DISPID_PCH_HELPCTR_BASE_INC   + 0x31)
																									
// Property Put IDs																					
#define DISPID_PCH_INC__ONCONNECTIONCOMPLETE                     (DISPID_PCH_HELPCTR_BASE_INC   + 0x25)
#define DISPID_PCH_INC__ONNEWCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INC   + 0x26)
#define DISPID_PCH_INC__ONDISCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INC   + 0x27)
#define DISPID_PCH_INC__ONVOICECONNECTED                         (DISPID_PCH_HELPCTR_BASE_INC   + 0x28)
#define DISPID_PCH_INC__ONVOICEDISCONNECTED                      (DISPID_PCH_HELPCTR_BASE_INC   + 0x29)
#define DISPID_PCH_INC__ONVOICEDISABLED                          (DISPID_PCH_HELPCTR_BASE_INC   + 0x2A)
																									
/////////////////////////////////////////////////////////////////////////							
																									
// DispInterface Events																				
#define DISPID_PCH_INCE__ONCONNECTIONCOMPLETE                    (DISPID_PCH_HELPCTR_BASE_INCE  + 0x10)
#define DISPID_PCH_INCE__ONNEWCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INCE  + 0x11)
#define DISPID_PCH_INCE__ONDISCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INCE  + 0x12)
#define DISPID_PCH_INCE__ONVOICECONNECTED                        (DISPID_PCH_HELPCTR_BASE_INCE  + 0x13)
#define DISPID_PCH_INCE__ONVOICEDISCONNECTED                     (DISPID_PCH_HELPCTR_BASE_INCE  + 0x14)
#define DISPID_PCH_INCE__ONVOICEDISABLED                         (DISPID_PCH_HELPCTR_BASE_INCE  + 0x15)
																									
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_INS__LISTEN                                   (DISPID_PCH_HELPCTR_BASE_INS   + 0x20)
#define DISPID_PCH_INS__DISCONNECT                               (DISPID_PCH_HELPCTR_BASE_INS   + 0x22)
#define DISPID_PCH_INS__STOPVOICE                                (DISPID_PCH_HELPCTR_BASE_INS   + 0x23)
#define DISPID_PCH_INS__STARTVOICE                               (DISPID_PCH_HELPCTR_BASE_INS   + 0x24)
#define DISPID_PCH_INS__RESET                                    (DISPID_PCH_HELPCTR_BASE_INS   + 0x25)
#define DISPID_PCH_INS__EXIT                                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x26)
																									
#define DISPID_PCH_INS__RUNSETUPWIZARD							 (DISPID_PCH_HELPCTR_BASE_INS   + 0x30)
#define DISPID_PCH_INS__SAMPLINGRATE							 (DISPID_PCH_HELPCTR_BASE_INS   + 0x31)
																									
// Property IDs																						
#define DISPID_PCH_INS__ONCONNECTIONCOMPLETE                     (DISPID_PCH_HELPCTR_BASE_INS   + 0x26)
#define DISPID_PCH_INS__ONNEWCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INS   + 0x27)
#define DISPID_PCH_INS__ONDISCONNECTED                           (DISPID_PCH_HELPCTR_BASE_INS   + 0x28)
#define DISPID_PCH_INS__ONVOICECONNECTED                         (DISPID_PCH_HELPCTR_BASE_INS   + 0x29)
#define DISPID_PCH_INS__ONVOICEDISCONNECTED                      (DISPID_PCH_HELPCTR_BASE_INS   + 0x2A)
#define DISPID_PCH_INS__ONVOICEDISABLED                          (DISPID_PCH_HELPCTR_BASE_INS   + 0x2B)

																									
#define DISPID_PCH_INS__CRYPTKEY		                         (DISPID_PCH_HELPCTR_BASE_INS   + 0x2C)
																									
/////////////////////////////////////////////////////////////////////////							
																									
// DispInterface Events																				
#define DISPID_PCH_INSE__ONCONNECTIONCOMPLETE                    (DISPID_PCH_HELPCTR_BASE_INSE  + 0x10)
#define DISPID_PCH_INSE__ONNEWCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INSE  + 0x11)
#define DISPID_PCH_INSE__ONDISCONNECTED                          (DISPID_PCH_HELPCTR_BASE_INSE  + 0x12)
#define DISPID_PCH_INSE__ONVOICECONNECTED                        (DISPID_PCH_HELPCTR_BASE_INSE  + 0x13)
#define DISPID_PCH_INSE__ONVOICEDISCONNECTED                     (DISPID_PCH_HELPCTR_BASE_INSE  + 0x14)
#define DISPID_PCH_INSE__ONVOICEDISABLED                         (DISPID_PCH_HELPCTR_BASE_INSE  + 0x15)
																									
/////////////////////////////////////////////////////////////////////////							
/////////////////////////////////////////////////////////////////////////							
																									
#define DISPID_PCH_C__ISAMODEM                      			 (DISPID_PCH_HELPCTR_BASE_C     + 0x00)
#define DISPID_PCH_C__ISALAN                       			     (DISPID_PCH_HELPCTR_BASE_C     + 0x01)
#define DISPID_PCH_C__AUTODIALENABLED               			 (DISPID_PCH_HELPCTR_BASE_C     + 0x02)
#define DISPID_PCH_C__HASCONNECTOID                 			 (DISPID_PCH_HELPCTR_BASE_C     + 0x03)
#define DISPID_PCH_C__IPADDRESSES                   			 (DISPID_PCH_HELPCTR_BASE_C     + 0x04)
																									
																									
#define DISPID_PCH_C__CREATEOBJECT_CONNECTIONCHECK               (DISPID_PCH_HELPCTR_BASE_C     + 0x10)
																									
#define DISPID_PCH_C__NETWORKALIVE                               (DISPID_PCH_HELPCTR_BASE_C     + 0x11)
#define DISPID_PCH_C__DESTINATIONREACHABLE                       (DISPID_PCH_HELPCTR_BASE_C     + 0x12)
																									
#define DISPID_PCH_C__AUTODIAL                                   (DISPID_PCH_HELPCTR_BASE_C     + 0x13)
#define DISPID_PCH_C__AUTODIALHANGUP                             (DISPID_PCH_HELPCTR_BASE_C     + 0x14)

#define DISPID_PCH_C__NAVIGATEONLINE                             (DISPID_PCH_HELPCTR_BASE_C     + 0x15)
																									
////////////////////////////////////////															
																									
#define DISPID_PCH_CN__ONCHECKDONE                               (DISPID_PCH_HELPCTR_BASE_CN    + 0x00)
#define DISPID_PCH_CN__ONSTATUSCHANGE                            (DISPID_PCH_HELPCTR_BASE_CN    + 0x01)
#define DISPID_PCH_CN__STATUS                                    (DISPID_PCH_HELPCTR_BASE_CN    + 0x02)
																									
#define DISPID_PCH_CN__STARTURLCHECK                             (DISPID_PCH_HELPCTR_BASE_CN    + 0x10)
#define DISPID_PCH_CN__ABORT                                     (DISPID_PCH_HELPCTR_BASE_CN    + 0x11)
																									
////////////////////////////////////////															
																									
#define DISPID_PCH_CNE__ONCHECKDONE                              (DISPID_PCH_HELPCTR_BASE_CNE   + 0x00)
#define DISPID_PCH_CNE__ONSTATUSCHANGE                           (DISPID_PCH_HELPCTR_BASE_CNE   + 0x01)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
																									
#define DISPID_PCH_TH__QUOTEESCAPE  			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x00)
#define DISPID_PCH_TH__URLUNESCAPE  			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x01)
#define DISPID_PCH_TH__URLESCAPE    			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x02)
#define DISPID_PCH_TH__HTMLESCAPE   			 				 (DISPID_PCH_HELPCTR_BASE_TH	+ 0x03)
				   								 									
#define DISPID_PCH_TH__PARSEURL                  				 (DISPID_PCH_HELPCTR_BASE_TH    + 0x10)
#define DISPID_PCH_TH__GETLCIDDISPLAYSTRING        				 (DISPID_PCH_HELPCTR_BASE_TH    + 0x11)

////////////////////////////////////////															
																									
#define DISPID_PCH_PU__BASEPART                           		 (DISPID_PCH_HELPCTR_BASE_PU    + 0x00)
#define DISPID_PCH_PU__BASEPART                           		 (DISPID_PCH_HELPCTR_BASE_PU    + 0x00)
#define DISPID_PCH_PU__QUERYPARAMETERS                           (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x01)

#define DISPID_PCH_PU__GETQUERYPARAMETER                         (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x10)
#define DISPID_PCH_PU__SETQUERYPARAMETER                         (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x11)
#define DISPID_PCH_PU__DELETEQUERYPARAMETER                      (DISPID_PCH_HELPCTR_BASE_PU 	+ 0x12)

#define DISPID_PCH_PU__BUILDFULLURL                              (DISPID_PCH_HELPCTR_BASE_PU    + 0x13)

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPCTRUIDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\makefile.inc ===
$(O)\HelpCenterInterfaces_i.c : $(LOCALLIBPATH)\HelpCenterTypeLib_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\htmlprogressbar.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the declaration of the ActiveX control that makes Win32 ProgressBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HTMLPROGRESSBAR_H___)
#define __INCLUDED___PCH___HTMLPROGRESSBAR_H___

#include <HelpCenter.h>

class ATL_NO_VTABLE CPCHProgressBar :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl                 <CPCHProgressBar, IPCHProgressBar, &IID_IPCHProgressBar, &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHProgressBar>,
    public IPersistPropertyBagImpl        <CPCHProgressBar>,
    public IOleControlImpl                <CPCHProgressBar>,
    public IOleObjectImpl                 <CPCHProgressBar>,
    public IOleInPlaceActiveObjectImpl    <CPCHProgressBar>,
    public IViewObjectExImpl              <CPCHProgressBar>,
    public IOleInPlaceObjectWindowlessImpl<CPCHProgressBar>,
    public CComCoClass                    <CPCHProgressBar, &CLSID_PCHProgressBar>
{
    HWND m_hwndPB;
		 
	long m_lLowLimit;
	long m_lHighLimit;
	long m_lPos;

    ////////////////////////////////////////

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHProgressBar)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHProgressBar)
    COM_INTERFACE_ENTRY(IPCHProgressBar)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHProgressBar)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY2(IPersist, IPersistPropertyBag)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHProgressBar)
	PROP_ENTRY("LowLimit" , DISPID_PCH_PB__LOWLIMIT , CLSID_NULL)
	PROP_ENTRY("HighLimit", DISPID_PCH_PB__HIGHLIMIT, CLSID_NULL)
END_PROP_MAP()

    CPCHProgressBar();

    BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IPCHProgressBar
public:
    STDMETHOD(get_LowLimit )( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_LowLimit )( /*[in         ]*/ long  newVal );
    STDMETHOD(get_HighLimit)( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_HighLimit)( /*[in         ]*/ long  newVal );
    STDMETHOD(get_Pos  	   )( /*[out, retval]*/ long *  pVal );
    STDMETHOD(put_Pos  	   )( /*[in         ]*/ long  newVal );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HTMLPROGRESSBAR_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\htmltoolbar.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    Toolbar.cpp

Abstract:
    This file contains the declaration of the ActiveX control that makes Win32 ToolBars available to HTML.

Revision History:
    Davide Massarenti   (Dmassare)  03/04/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HTMLTOOLBAR_H___)
#define __INCLUDED___PCH___HTMLTOOLBAR_H___

#include <HelpCenter.h>

MIDL_INTERFACE("FC7D9EA1-3F9E-11d3-93C0-00C04F72DAF7")
IPCHToolBarPrivate : public IUnknown
{
public:
    STDMETHOD(SameObject)( /*[in]*/ IPCHToolBar* ptr );
};

class ATL_NO_VTABLE CPCHToolBar :
    public MPC::ConnectionPointImpl       <      CPCHToolBar, &DIID_DPCHToolBarEvents, CComSingleThreadModel   >,
	public IProvideClassInfo2Impl         <&CLSID_PCHToolBar, &DIID_DPCHToolBarEvents, &LIBID_HelpCenterTypeLib>,
    public IDispatchImpl                  <      IPCHToolBar, & IID_IPCHToolBar      , &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHToolBar>,
    public IPersistPropertyBagImpl        <CPCHToolBar>,
    public IOleControlImpl                <CPCHToolBar>,
    public IOleObjectImpl                 <CPCHToolBar>,
    public IOleInPlaceActiveObjectImpl    <CPCHToolBar>,
    public IViewObjectExImpl              <CPCHToolBar>,
    public IOleInPlaceObjectWindowlessImpl<CPCHToolBar>,
    public CComCoClass                    <CPCHToolBar, &CLSID_PCHToolBar>,
	public IPCHToolBarPrivate               
{
	typedef enum
    {
		TYPE_invalid  ,
		TYPE_back     ,
		TYPE_forward  ,
		TYPE_separator,
		TYPE_generic  ,
	} Types;
	
	static const MPC::StringToBitField c_TypeLookup[];

    class Button : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Button);

    public:
        MPC::wstring m_strID;
        WCHAR        m_wch;
        bool     	 m_fEnabled;
        bool     	 m_fVisible;
        bool     	 m_fHideText;
        bool     	 m_fSystemMenu;
        DWORD        m_dwType;
	
        MPC::wstring m_strImage_Normal;
        MPC::wstring m_strImage_Hot;
        MPC::wstring m_strText;
        MPC::wstring m_strToolTip;

		int          m_idCmd;
		int          m_iImage_Normal;
		int          m_iImage_Hot;

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

		Button();

		void UpdateState( /*[in]*/ HWND hwndTB );
    };

    class Config : public MPC::Config::TypeConstructor
    {
        DECLARE_CONFIG_MAP(Config);

    public:
        typedef std::list< Button >        ButtonList;
        typedef ButtonList::iterator       ButtonIter;
        typedef ButtonList::const_iterator ButtonIterConst;

		long	   m_lWidth;
		long	   m_lHeight;
		long	   m_lIconSize;
		bool       m_fRTL;

		TB_MODE    m_mode;
        ButtonList m_lstButtons;

		HIMAGELIST m_himlNormal;
		HIMAGELIST m_himlHot;
							

        ////////////////////////////////////////
        //
        // MPC::Config::TypeConstructor
        //
        DEFINE_CONFIG_DEFAULTTAG();
        DECLARE_CONFIG_METHODS();
        //
        ////////////////////////////////////////

		Config();

        Button* LookupButton( /*[in]*/ LPCWSTR szID, /*[in]*/ int idCmd );


		void    Reset(                                                                                   );
		HRESULT Load ( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szDefinition, /*[in]*/ LPCWSTR szDir );

		HRESULT CreateButtons( /*[in]*/ HWND hwndTB                                                 );
		void    UpdateSize   ( /*[in]*/ HWND hwndTB, /*[in]*/ HWND hwndRB, /*[out]*/ SIZEL& ptIdeal );

		////////////////////

		HRESULT MergeImage( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[in ]*/ HIMAGELIST himl, /*[out]*/ int& iImage );
    };

	////////////////////////////////////////////////////////////////////////////////


    CPCHHelpCenterExternal* m_parent;
    HWND                    m_hwndRB;
    HWND                    m_hwndTB;
							
	CComBSTR                m_bstrBaseURL;
	CComBSTR                m_bstrDefinition;

	Config                  m_cfg;
	bool                    m_fLoaded;

    ////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onCommand( /*[in]*/ Button*  bt   );
    HRESULT Fire_onCommand( /*[in]*/ UINT_PTR iCmd );

    ////////////////////////////////////////

    HRESULT OnTooltipRequest ( int idCtrl, LPNMTBGETINFOTIPW tool );
    HRESULT OnDispInfoRequest( int idCtrl, LPNMTBDISPINFOW   info );
    HRESULT OnDropDown       ( int idCtrl, LPNMTOOLBAR       tool );
	HRESULT OnChevron        ( int idCtrl, LPNMREBARCHEVRON  chev );

	void UpdateSize();

	void    Config_Clear();
	HRESULT Config_Load ();

	HRESULT Toolbar_Create();
	HRESULT Rebar_Create  ();
	HRESULT Rebar_AddBand ();

public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHToolBar)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHToolBar)
    COM_INTERFACE_ENTRY(IPCHToolBar)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHToolBar)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY2(IPersist, IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPCHToolBarPrivate)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHToolBar)
	PROP_ENTRY("Definition", DISPID_PCH_TB__DEFINITION, CLSID_NULL)
END_PROP_MAP()

    CPCHToolBar();
    virtual ~CPCHToolBar();

    BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

	BOOL ProcessAccessKey( UINT uMsg, WPARAM wParam, LPARAM lParam );

    BOOL PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleObject
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetExtent    )(DWORD dwDrawAspect, SIZEL *psizel);

// IPCHToolBar
public:
    STDMETHOD(get_Definition)( /*[out, retval]*/ BSTR 	 *  pVal );
    STDMETHOD(put_Definition)( /*[in         ]*/ BSTR 	  newVal );
    STDMETHOD(get_Mode	    )( /*[out, retval]*/ TB_MODE *  pVal );
    STDMETHOD(put_Mode	    )( /*[in         ]*/ TB_MODE  newVal );

    STDMETHOD(SetState     )( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fEnabled );
    STDMETHOD(SetVisibility)( /*[in]*/ BSTR bstrText, /*[in]*/ VARIANT_BOOL fVisible );

// IPCHToolBarPrivate
public:
    STDMETHOD(SameObject)( /*[in]*/ IPCHToolBar* ptr ) { return this == ptr ? S_OK : E_FAIL; }

	HRESULT FindElementThroughThunking( /*[out]*/ CComPtr<IHTMLElement>& elem );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HTMLTOOLBAR_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\hyperlinkslib.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HyperLinksLib.h

Abstract:
    This file contains the declaration of the HyperLinks library of classes.

Revision History:
    Davide Massarenti   (Dmassare)  11/28/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HYPERLINKSLIB_H___)
#define __INCLUDED___PCH___HYPERLINKSLIB_H___

#include <MPC_COM.h>
#include <MPC_Utils.h>
#include <MPC_HTML.h>

////////////////////////////////////////////////////////////////////////////////

namespace HyperLinks
{
    typedef enum
    {
        FMT_INVALID            ,

        FMT_INTERNET_UNKNOWN   ,
        FMT_INTERNET_FTP       , // InternetCrackUrl returned INTERNET_SCHEME_FTP
        FMT_INTERNET_GOPHER    , // InternetCrackUrl returned INTERNET_SCHEME_GOPHER
        FMT_INTERNET_HTTP      , // InternetCrackUrl returned INTERNET_SCHEME_HTTP
        FMT_INTERNET_HTTPS     , // InternetCrackUrl returned INTERNET_SCHEME_HTTPS
        FMT_INTERNET_FILE      , // InternetCrackUrl returned INTERNET_SCHEME_FILE
        FMT_INTERNET_NEWS      , // InternetCrackUrl returned INTERNET_SCHEME_NEWS
        FMT_INTERNET_MAILTO    , // InternetCrackUrl returned INTERNET_SCHEME_MAILTO
        FMT_INTERNET_SOCKS     , // InternetCrackUrl returned INTERNET_SCHEME_SOCKS
        FMT_INTERNET_JAVASCRIPT, // InternetCrackUrl returned INTERNET_SCHEME_JAVASCRIPT
        FMT_INTERNET_VBSCRIPT  , // InternetCrackUrl returned INTERNET_SCHEME_VBSCRIPT

        FMT_HCP                , // hcp://<something>
        FMT_HCP_REDIR          , // hcp:<something>
        FMT_MSITS              , // ms-its:<file name>::/<stream name>

        FMT_CENTER_HOMEPAGE    , // hcp://services/centers/homepage
        FMT_CENTER_SUPPORT     , // hcp://services/centers/support
        FMT_CENTER_OPTIONS     , // hcp://services/centers/options
        FMT_CENTER_UPDATE      , // hcp://services/centers/update
        FMT_CENTER_COMPAT      , // hcp://services/centers/compat
        FMT_CENTER_TOOLS       , // hcp://services/centers/tools
        FMT_CENTER_ERRMSG      , // hcp://services/centers/errmsg

        FMT_SEARCH             , // hcp://services/search?query=<text to look up>
        FMT_INDEX              , // hcp://services/index?application=<optional island of help ID>
        FMT_SUBSITE            , // hcp://services/subsite?node=<subsite location>&topic=<url of the topic to display>&select=<subnode to highlight>

        FMT_LAYOUT_FULLWINDOW  , // hcp://services/layout/fullwindow?topic=<url of the topic to display>
        FMT_LAYOUT_CONTENTONLY , // hcp://services/layout/contentonly?topic=<url of the topic to display>
        FMT_LAYOUT_KIOSK       , // hcp://services/layout/kiosk?topic=<url of the topic to display>
        FMT_LAYOUT_XML         , // hcp://services/layout/xml?definition=<url of the layout definition>&topic=<url of the topic to display>

        FMT_REDIRECT           , // hcp://services/redirect?online=<url>&offline=<backup url>

        FMT_APPLICATION        , // app:<application to launch>?arg=<optional arguments>&topic=<url of optional topic to display>

        FMT_RESOURCE           , // res://<file path>/<resource name>

    } Format;

    typedef enum
    {
        STATE_INVALID     ,
        STATE_NOTPROCESSED,
        STATE_CHECKING    ,
        STATE_MALFORMED   ,
        STATE_ALIVE       ,
        STATE_NOTFOUND    ,
        STATE_UNREACHABLE ,
        STATE_OFFLINE     ,
    } State;

    ////////////////////

    struct ParsedUrl
    {
        MPC::wstring       m_strURL;
        Format             m_fmt;
        State              m_state;
        DATE               m_dLastChecked;
        bool               m_fBackground;

        MPC::wstring       m_strBasePart;
        MPC::WStringLookup m_mapQuery;

        ////////////////////

        ParsedUrl();

        HRESULT Initialize( /*[in]*/ LPCWSTR szURL );

        bool  IsLocal      (                                     );
        State CheckState   ( /*[in/out]*/ bool& fFirstWinInetUse );
        bool  IsOkToProceed(                                     );

        bool HasQueryField( /*[in]*/ LPCWSTR szField                               );
        bool GetQueryField( /*[in]*/ LPCWSTR szField, /*[in]*/ CComBSTR& bstrValue );
    };

    class UrlHandle
    {
        friend class Lookup;

        Lookup*    m_main; // We have a lock on it.
        ParsedUrl* m_pu;

        void Attach( /*[in]*/ Lookup* main, /*[in]*/ ParsedUrl* pu );

    public:
        UrlHandle();
        ~UrlHandle();

        void Release();

        operator ParsedUrl*()   { return m_pu; }
        ParsedUrl* operator->() { return m_pu; }
    };

    class Lookup :
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>, // For locking...
        public MPC::Thread< Lookup, IUnknown >
    {
        typedef std::list<ParsedUrl*>              PendingUrlList;
        typedef PendingUrlList::iterator           PendingUrlIter;
        typedef PendingUrlList::const_iterator     PendingUrlIterConst;

        typedef std::map<MPC::wstringUC,ParsedUrl> UrlMap;
        typedef UrlMap::iterator                   UrlIter;
        typedef UrlMap::const_iterator             UrlIterConst;

        PendingUrlList m_lst;
        UrlMap         m_map;

        HRESULT RunChecker();

        HRESULT CreateItem( /*[in]*/ LPCWSTR szURL, /*[out]*/ ParsedUrl*& pu );

    public:
        Lookup();
        ~Lookup();

        ////////////////////////////////////////////////////////////////////////////////

        static Lookup* s_GLOBAL;

        static HRESULT InitializeSystem();
        static void    FinalizeSystem  ();

        ////////////////////////////////////////////////////////////////////////////////

        HRESULT Queue( /*[in]*/ LPCWSTR szURL                                                                                          );
        HRESULT Get  ( /*[in]*/ LPCWSTR szURL, /*[in]*/ UrlHandle& uh, /*[in]*/ DWORD dwWaitForCheck = 0, /*[in]*/ bool fForce = false );
    };

    HRESULT IsValid( /*[in/out]*/ LPCWSTR szURL );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HYPERLINKSLIB_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\helpviewerwrapper.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpViewerWrapper.h

Abstract:
    This file contains the declaration of the class used to wrap the HTML Help Viewer.

Revision History:
    Davide Massarenti   (dmassare)  01/20/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPVIEWERWRAPPER_H___)
#define __INCLUDED___PCH___HELPVIEWERWRAPPER_H___

#include <HelpCenter.h>

#include <htmlhelp.h>

#include <oleacc.h>


#define ID_NOTIFY_FROM_HH (12345)
#define WINDOW_STYLE      "HCStyle"


class ATL_NO_VTABLE CPCHHelpViewerWrapper :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl                 <CPCHHelpViewerWrapper, IPCHHelpViewerWrapper, &IID_IPCHHelpViewerWrapper, &LIBID_HelpCenterTypeLib>,
    public CComControl                    <CPCHHelpViewerWrapper>,
    public IPersistStreamInitImpl         <CPCHHelpViewerWrapper>,
    public IOleControlImpl                <CPCHHelpViewerWrapper>,
    public IOleObjectImpl                 <CPCHHelpViewerWrapper>,
    public IOleInPlaceActiveObjectImpl    <CPCHHelpViewerWrapper>,
    public IViewObjectExImpl              <CPCHHelpViewerWrapper>,
    public IOleInPlaceObjectWindowlessImpl<CPCHHelpViewerWrapper>,
    public CComCoClass                    <CPCHHelpViewerWrapper, &CLSID_PCHHelpViewerWrapper>
{
    static MPC::CComSafeAutoCriticalSection s_csec;
    static bool                    			s_fInitialized;
    static DWORD                   			s_dwLastStyle;
    static MPC::WStringList        			s_lstAvailable;

    //
    // This is the OLEACC stuff used to access the WebBrowser object inside the HTMLHelp viewer.
    //
    static HINSTANCE               s_hInst;
    static LPFNOBJECTFROMLRESULT   s_pfObjectFromLresult;

    ////////////////////////////////////////

    class ATL_NO_VTABLE ServiceProvider :
        public CComObjectRootEx<CComSingleThreadModel>,
        public IServiceProvider
    {
        CPCHHelpCenterExternal* m_parent;
		HWND                    m_hWnd;

    public:
    BEGIN_COM_MAP(ServiceProvider)
        COM_INTERFACE_ENTRY(IServiceProvider)
    END_COM_MAP()

        ServiceProvider();
        virtual ~ServiceProvider();

        HRESULT Attach( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ HWND hWnd );
        void    Detach(                                                             );

        //
        // IServiceProvider
        //
        STDMETHOD(QueryService)( REFGUID guidService, REFIID riid, void **ppv );
    };

    ////////////////////////////////////////

    CPCHHelpCenterExternal*          		m_parent;
	CPCHHelpViewerWrapper::ServiceProvider* m_ServiceProvider;

    bool                           	 		m_fFirstTime;
    MPC::wstring                   	 		m_szWindowStyle;
    HWND                           	 		m_hwndHH;
  		 
    CComPtr<IHTMLDocument2>        	 		m_spDoc;
    CComPtr<IWebBrowser2>          	 		m_WB2;
	CComBSTR                         		m_bstrPendingNavigation;

    ////////////////////////////////////////

    void AcquireWindowStyle();
    void ReleaseWindowStyle();
    void ExtractWebBrowser();

    void InternalDisplayTopic( /*[in]*/ LPCWSTR szURL );


public:
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CPCHHelpViewerWrapper)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY(IPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY2(IDispatch, IPCHHelpViewerWrapper)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_PROP_MAP(CPCHHelpViewerWrapper)
END_PROP_MAP()

    CPCHHelpViewerWrapper();
    virtual ~CPCHHelpViewerWrapper();

	BOOL ProcessWindowMessage( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0 );

    BOOL PreTranslateAccelerator( LPMSG pMsg, HRESULT& hRet );

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleObject
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

// IPCHHelpViewerWrapper
public:
	STDMETHOD(get_WebBrowser)( /*[out,retval]*/ IUnknown* *pVal );

    STDMETHOD(Navigate)( /*[in]*/ BSTR bstrURL );
    STDMETHOD(Print   )(                       );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPVIEWERWRAPPER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\helpcenter.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenter.h

Abstract:
    This file contains the declaration of the class used to implement
    the Help Center Application.

Revision History:
    Sridhar Chandrashekar   (SridharC)  07/21/99
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___HELPCENTER_H___)
#define __INCLUDED___PCH___HELPCENTER_H___

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>

#include <exdisp.h>
#include <exdispid.h>

#include <HelpCenterExternal.h>

#include <shobjidl.h>
#include <marscore.h>

#include <ScriptingFrameworkDID.h>

#include <Perhist.h>

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHBootstrapper : // Hungarian: hcpbs
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public CComCoClass<CPCHBootstrapper, &CLSID_PCHBootstrapper>,
    public IObjectWithSite,
    public IObjectSafety
{
    CComPtr<IUnknown> m_spUnkSite;
    CComPtr<IUnknown> m_parent;

    ////////////////////

    static HRESULT ForwardQueryInterface( void* pv, REFIID iid, void** ppvObject, DWORD_PTR offset );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CPCHBootstrapper)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC_BLIND(0, ForwardQueryInterface)
END_COM_MAP()

    //
    // IObjectWithSite
    //
    STDMETHOD(SetSite)(IUnknown *pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    //
    // IObjectSafety
    //
    STDMETHOD(GetInterfaceSafetyOptions)( /*[in ]*/ REFIID  riid                ,  // Interface that we want options for
                                          /*[out]*/ DWORD  *pdwSupportedOptions ,  // Options meaningful on this interface
                                          /*[out]*/ DWORD  *pdwEnabledOptions   ); // current option values on this interface

    STDMETHOD(SetInterfaceSafetyOptions)( /*[in]*/ REFIID riid             ,  // Interface to set options for
										  /*[in]*/ DWORD  dwOptionSetMask  ,  // Options to change
										  /*[in]*/ DWORD  dwEnabledOptions ); // New option values
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHMarsHost : // Hungarian: hcpmh
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IMarsHost
{
    CPCHHelpCenterExternal* m_parent;
    MPC::wstring            m_strTitle;
	MPC::wstring            m_strCmdLine;
    MARSTHREADPARAM         m_mtp;

public:
BEGIN_COM_MAP(CPCHMarsHost)
    COM_INTERFACE_ENTRY(IMarsHost)
END_COM_MAP()

    CPCHMarsHost();

    //////////////////////////////////////////////////////////////////////

    HRESULT Init( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ const MPC::wstring& szTitle, /*[out]*/ MARSTHREADPARAM*& pMTP );

    //
    // IMarsHost
    //
    STDMETHOD(OnHostNotify)( /*[in]*/ MARSHOSTEVENT event, /*[in]*/ IUnknown *punk, /*[in]*/ LPARAM lParam );

    STDMETHOD(PreTranslateMessage)( /*[in]*/ MSG* msg );
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHScriptableStream : // Hungarian: pchss
    public MPC::FileStream,
    public IDispatchImpl<IPCHScriptableStream, &IID_IPCHScriptableStream, &LIBID_HelpCenterTypeLib>
{
    HRESULT ReadToHGLOBAL( /*[in]*/ long lCount, /*[out]*/ HGLOBAL& hg, /*[out]*/ ULONG& lReadTotal );

public:
BEGIN_COM_MAP(CPCHScriptableStream)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHScriptableStream)
    COM_INTERFACE_ENTRY_CHAIN(MPC::FileStream)
END_COM_MAP()

    //////////////////////////////////////////////////////////////////////

    // IPCHScriptableStream
    STDMETHOD(get_Size)( /*[out, retval]*/ long *plSize );

    STDMETHOD(Read    )( /*[in]*/ long lCount , /*[out, retval]*/ VARIANT *   pvData                                      );
    STDMETHOD(ReadHex )( /*[in]*/ long lCount , /*[out, retval]*/ BSTR    *pbstrData                                      );

    STDMETHOD(Write   )( /*[in]*/ long lCount , /*[in         ]*/ VARIANT      vData  , /*[out, retval]*/ long *plWritten );
    STDMETHOD(WriteHex)( /*[in]*/ long lCount , /*[in         ]*/ BSTR      bstrData  , /*[out, retval]*/ long *plWritten );

    STDMETHOD(Seek    )( /*[in]*/ long lOffset, /*[in         ]*/ BSTR      bstrOrigin, /*[out, retval]*/ long *plNewPos  );
    STDMETHOD(Close   )(                                                                                                  );
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___HELPCENTER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\mpc_html2.h ===
/******************************************************************************

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:
    MPC_html2.h

Abstract:
    This file contains the declaration of various functions and classes
    designed to help the handling of HTML elements.

Revision History:
    Davide Massarenti   (Dmassare)  18/03/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___MPC___HTML2_H___)
#define __INCLUDED___MPC___HTML2_H___

#include <MPC_html.h>

/////////////////////////////////////////////////////////////////////////

namespace MPC
{
    namespace HTML
    {

        HRESULT OpenStream    ( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[out]*/ CComPtr<IStream>& stream               );
        HRESULT DownloadBitmap( /*[in]*/ LPCWSTR szBaseURL, /*[in]*/ LPCWSTR szRelativeURL, /*[in]*/ COLORREF crMask, /*[out]*/ HBITMAP& hbm );

    }; // namespace HTML

}; // namespace MPC

/////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHTextHelpers : // Hungarian: pchth
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHTextHelpers, &IID_IPCHTextHelpers, &LIBID_HelpCenterTypeLib>
{
public:
BEGIN_COM_MAP(CPCHTextHelpers)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHTextHelpers)
END_COM_MAP()

    ////////////////////////////////////////////////////////////////////////////////

public:
    // IPCHTextHelpers
    STDMETHOD(QuoteEscape)( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vQuote        , /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(URLUnescape)( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vAsQueryString, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(URLEscape  )( /*[in]*/ BSTR bstrText, /*[in,optional]*/ VARIANT vAsQueryString, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(HTMLEscape )( /*[in]*/ BSTR bstrText,                                           /*[out, retval]*/ BSTR *pVal );

    STDMETHOD(ParseURL            )( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ IPCHParsedURL* *pVal );
    STDMETHOD(GetLCIDDisplayString)( /*[in]*/ long lLCID  , /*[out, retval]*/ BSTR           *pVal );
};

class ATL_NO_VTABLE CPCHParsedURL : // Hungarian: pchpu
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHParsedURL, &IID_IPCHParsedURL, &LIBID_HelpCenterTypeLib>
{
	MPC::wstring       m_strBaseURL;
	MPC::WStringLookup m_mapQuery;

public:
BEGIN_COM_MAP(CPCHParsedURL)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHParsedURL)
END_COM_MAP()

	HRESULT Initialize( /*[in]*/ LPCWSTR szURL );

    ////////////////////////////////////////////////////////////////////////////////

public:
    // IPCHParsedURL
    STDMETHOD(get_BasePart		 )( /*[out, retval]*/ BSTR 	  *  pVal );
    STDMETHOD(put_BasePart		 )( /*[in         ]*/ BSTR 	   newVal );
    STDMETHOD(get_QueryParameters)( /*[out, retval]*/ VARIANT *  pVal );

    STDMETHOD(GetQueryParameter   )( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT*   pvValue );
    STDMETHOD(SetQueryParameter   )( /*[in]*/ BSTR bstrName, /*[in         ]*/ BSTR     bstrValue );
    STDMETHOD(DeleteQueryParameter)( /*[in]*/ BSTR bstrName                                       );

    STDMETHOD(BuildFullURL)( /*[out, retval]*/ BSTR *pVal );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___MPC___HTML2_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\namespace_impl.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    NameSpace_Impl.h

Abstract:
    This file contains the declaration of the classes used to implement the
    pluggable protocol: CHCPProtocol, CHCPProtocolInfo and CHCPBindStatusCallback.

Revision History:
    Davide Massarenti   (Dmassare)  07/05/99
        created
    Davide Massarenti   (Dmassare)  07/23/99
        moved to "include"

******************************************************************************/

#if !defined(__INCLUDED___HCP___NAMESPACE_H___)
#define __INCLUDED___HCP___NAMESPACE_H___

#include <MPC_utils.h>
#include <MPC_streams.h>

#include <TaxonomyDatabase.h>

/////////////////////////////////////////////////////////////////////////////

extern bool  g_Debug_BLOCKERRORS;
extern bool  g_Debug_CONTEXTMENU;
extern bool  g_Debug_BUILDTREE;
extern WCHAR g_Debug_FORCESTYLE[];

////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG_PROTOCOLLEAK

#include <set>

class CHCPProtocol;

class DEBUG_ProtocolLeak
{
    typedef std::set<CHCPProtocol*> Set;
    typedef Set::iterator           Iter;
    typedef Set::const_iterator     IterConst;

    Set m_set;
    Set m_setStart;
    Set m_setComplete;
    int m_num;
    int m_numOut;
    int m_numStart;
    int m_numComplete;

public:
    DEBUG_ProtocolLeak();
    ~DEBUG_ProtocolLeak();

    void Add( CHCPProtocol* ptr );
    void Del( CHCPProtocol* ptr );

    void CheckStart( CHCPProtocol* ptr );
    void Completed ( CHCPProtocol* ptr );
};

#endif

/////////////////////////////////////////////////////////////////////////////

class CHCPBindStatusCallback;

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE ISimpleBindStatusCallback : public IUnknown
{
public:
    STDMETHOD(ForwardQueryInterface)( REFIID riid, void** ppv );

    STDMETHOD(GetBindInfo)( BINDINFO *pbindInfo );

    STDMETHOD(PreBindMoniker)( IBindCtx* pBindCtx, IMoniker* pMoniker );

    STDMETHOD(OnProgress)( ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText );

    STDMETHOD(OnData)( CHCPBindStatusCallback* pbsc, BYTE* pBytes, DWORD dwSize, DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed );

    STDMETHOD(OnBindingFailure)( HRESULT hr, LPCWSTR szError );
};

class ATL_NO_VTABLE CHCPBindStatusCallback : // Hungarian: bscb
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IBindStatusCallback,
    public IHttpNegotiate
{
    CComPtr<ISimpleBindStatusCallback> m_pT;
    DWORD                              m_dwTotalRead;
    DWORD                              m_dwAvailableToRead;

    CComPtr<IMoniker>                  m_spMoniker;
    CComPtr<IBindCtx>                  m_spBindCtx;
    CComPtr<IBinding>                  m_spBinding;
    CComPtr<IStream>                   m_spStream;

public:

BEGIN_COM_MAP(CHCPBindStatusCallback)
    COM_INTERFACE_ENTRY(IBindStatusCallback)
    COM_INTERFACE_ENTRY(IHttpNegotiate)
    //  COM_INTERFACE_ENTRY_FUNC_BLIND(0,TestQuery)
    //  COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

    CHCPBindStatusCallback();
    virtual ~CHCPBindStatusCallback();

    //static HRESULT TestQuery( void* pv, REFIID iid, void** ppvObject, DWORD dw )
    //{
    //    *ppvObject = NULL;
    //    return E_NOINTERFACE;
    //}

    /////////////////////////////////////////////////////////////////////////////
    // IBindStatusCallback
    STDMETHOD(OnStartBinding)( DWORD     dwReserved ,
                               IBinding *pBinding   );

    STDMETHOD(GetPriority)( LONG *pnPriority );

    STDMETHOD(OnLowResource)( DWORD reserved );

    STDMETHOD(OnProgress)( ULONG   ulProgress    ,
                           ULONG   ulProgressMax ,
                           ULONG   ulStatusCode  ,
                           LPCWSTR szStatusText  );

    STDMETHOD(OnStopBinding)( HRESULT hresult ,
                              LPCWSTR szError );

    STDMETHOD(GetBindInfo)( DWORD    *pgrfBINDF ,
                            BINDINFO *pbindInfo );

    STDMETHOD(OnDataAvailable)( DWORD      grfBSCF    ,
                                DWORD      dwSize     ,
                                FORMATETC *pformatetc ,
                                STGMEDIUM *pstgmed    );

    STDMETHOD(OnObjectAvailable)( REFIID    riid ,
                                  IUnknown *punk );

    /////////////////////////////////////////////////////////////////////////////
    // IHttpNegotiate
    STDMETHOD(BeginningTransaction)( LPCWSTR  szURL                ,
                                     LPCWSTR  szHeaders            ,
                                     DWORD    dwReserved           ,
                                     LPWSTR  *pszAdditionalHeaders );

    STDMETHOD(OnResponse)( DWORD    dwResponseCode              ,
                           LPCWSTR  szResponseHeaders           ,
                           LPCWSTR  szRequestHeaders            ,
                           LPWSTR  *pszAdditionalRequestHeaders );

    /////////////////////////////////////////////////////////////////////////////

    HRESULT StartAsyncDownload( ISimpleBindStatusCallback* pT, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE );

    HRESULT Abort();
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CHCPProtocol :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHCPProtocol>,
    public ISimpleBindStatusCallback,
    public IInternetProtocol,
	public IWinInetInfo
{
#ifdef DEBUG
    friend class DEBUG_ProtocolLeak;
#endif

    typedef CComObject< CHCPBindStatusCallback > InnerDownloader;


    bool                           	m_fDone;                     // Indicates whether we've received LASTDATANOTIFICATION yet
    bool                           	m_fReportResult;             // Indicates whether we've called ReportResult on the sink.
                                   								 //
    DWORD                          	m_cbAvailableSize;           // Amount of data received up to now.
    DWORD                          	m_cbTotalSize;               // Total number of bytes to be expected. For redirected requests,
                                   								 // it comes from "ulProgressMax" parm to OnProgress for BEGINDOWNLOADDATA
                                   								 //
    CComPtr<IStream>               	m_pstrmRead;                 // Streams used for redirected request. We use two stream pointers to allow
    CComPtr<IStream>               	m_pstrmWrite;                // concurrent access to the same bits from two seek ptrs.
                                   								 //
    CComPtr<IInternetProtocolSink> 	m_pIProtSink;                // Sink interface through which we should report progress.
    CComPtr<IInternetBindInfo>     	m_pIBindInfo;                // BindInfo interface used to get info about the binding.
    DWORD                          	m_grfSTI;                    // STI flags handed to us
    BINDINFO                       	m_bindinfo;                  // From m_pIBindInfo
    DWORD                          	m_bindf;                     // From m_pIBindInfo
                                   								 //
    CComBSTR                       	m_bstrUrlComplete;           // The complete URL requested.
    CComBSTR                       	m_bstrUrlRedirected;         // The part that has been used as a redirection.
    InnerDownloader*                m_pDownloader;               // The object that performs the redirection.
                                   								 //
    bool                           	m_fRedirected;               // The request has been redirected.
    bool                           	m_fCSS;                      // The request has been redirected.
    bool                           	m_fBypass;                   // The request has been sent to ms-its, with a bypass.
                                   								 //
    CComPtr<IInternetProtocol>     	m_ipiBypass;                 // Aggregated object.
                                   								 //
    CComBSTR                       	m_bstrMimeType;              // Type of the content.
    DWORD                          	m_dwContentLength;           // Length of the page.
                                   								 //
    HANDLE                         	m_hCache;                    // Handle for the cache entry.
    WCHAR                          	m_szCacheFileName[MAX_PATH]; // Name of the file inside the cache.

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT InnerReportProgress( /*[in]*/ ULONG ulStatusCode, /*[in]*/ LPCWSTR szStatusText );

    HRESULT InnerReportData( /*[in]*/ DWORD grfBSCF, /*[in]*/ ULONG ulProgress, /*[in]*/ ULONG ulProgressMax );

    HRESULT InnerReportResult( /*[in]*/ HRESULT hrResult, /*[in]*/ DWORD dwError, /*[in]*/ LPCWSTR szResult );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocol)
    COM_INTERFACE_ENTRY(IInternetProtocol    )
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
    COM_INTERFACE_ENTRY(IWinInetInfo)
END_COM_MAP()

    CHCPProtocol();
    virtual ~CHCPProtocol();

    ////////////////////////////////////////////////////////////////////////////////

    bool OpenCacheEntry (                                           );
    void WriteCacheEntry( /*[in]*/ void *pv, /*[in]*/ ULONG  cbRead );
    void CloseCacheEntry( /*[in]*/ bool fDelete                     );

    ////////////////////////////////////////////////////////////////////////////////

    void Shutdown( /*[in]*/ bool fAll = true );

    /////////////////////////////////////////////////////////////////////////////
    // IInternetProtocol interface
    STDMETHOD(Start)( LPCWSTR                szUrl      ,
                      IInternetProtocolSink *pIProtSink ,
                      IInternetBindInfo     *pIBindInfo ,
                      DWORD                  grfSTI     ,
                      HANDLE_PTR             dwReserved );

    STDMETHOD(Continue)( PROTOCOLDATA *pStateInfo );

    STDMETHOD(Abort    )( HRESULT hrReason, DWORD dwOptions );
    STDMETHOD(Terminate)(                   DWORD dwOptions );
    STDMETHOD(Suspend  )(                                   );
    STDMETHOD(Resume   )(                                   );

    STDMETHOD(Read)( void *pv, ULONG cb, ULONG *pcbRead                                      );
    STDMETHOD(Seek)( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition );

    STDMETHOD(LockRequest  )( DWORD dwOptions );
    STDMETHOD(UnlockRequest)(                 );


    /////////////////////////////////////////////////////////////////////////////
    // IWinInetInfo interface
    STDMETHOD(QueryOption)( DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf );

public:
    HRESULT DoParse( /*[in]*/ LPCWSTR wstr );
    HRESULT DoBind();

    HRESULT DoBind_Exists( /*[in] */ MPC::FileSystemObject& fso, /*[out]*/ bool& fFound, /*[out]*/ bool& fIsAFile );

    HRESULT DoBind_Redirect_UrlMoniker();
    HRESULT DoBind_Redirect_MSITS     ();
    HRESULT DoBind_CSS                ();
    HRESULT DoBind_File               ();
    HRESULT DoBind_ReturnData         ( /*[in]*/ bool fCloneStream, /*[in]*/ LPCWSTR szMimeType );

    /////////////////////////////////////////////////////////////////////////////
    // ISimpleBindStatusCallback
    STDMETHOD(ForwardQueryInterface)( REFIID riid, void** ppv );

    STDMETHOD(GetBindInfo)( BINDINFO *pbindInfo );

    STDMETHOD(PreBindMoniker)( IBindCtx* pBindCtx, IMoniker* pMoniker );

    STDMETHOD(OnBindingFailure)( HRESULT hr, LPCWSTR szError );

    STDMETHOD(OnProgress)( ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText );

    STDMETHOD(OnData)( CHCPBindStatusCallback* pbsc, BYTE* pBytes, DWORD dwSize, DWORD grfBSCF, FORMATETC *pformatetc, STGMEDIUM *pstgmed );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CHCPProtocolInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IClassFactory,
    public IInternetProtocolInfo
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocolInfo)
    COM_INTERFACE_ENTRY(IClassFactory)
    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
END_COM_MAP()

    CHCPProtocolInfo();
    virtual ~CHCPProtocolInfo();


    // IClassFactory interface
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);


    // IInternetProtocolInfo interface
    STDMETHOD(ParseUrl)( LPCWSTR      pwzUrl      ,
                         PARSEACTION  ParseAction ,
                         DWORD        dwParseFlags,
                         LPWSTR       pwzResult   ,
                         DWORD        cchResult   ,
                         DWORD       *pcchResult  ,
                         DWORD        dwReserved  );

    STDMETHOD(CombineUrl)( LPCWSTR pwzBaseUrl    ,
                           LPCWSTR pwzRelativeUrl,
                           DWORD   dwCombineFlags,
                           LPWSTR  pwzResult     ,
                           DWORD   cchResult     ,
                           DWORD  *pcchResult    ,
                           DWORD   dwReserved    );

    STDMETHOD(CompareUrl)( LPCWSTR pwzUrl1        ,
                           LPCWSTR pwzUrl2        ,
                           DWORD   dwCompareFlags );

    STDMETHOD(QueryInfo)( LPCWSTR      pwzUrl      ,
                          QUERYOPTION  QueryOption ,
                          DWORD        dwQueryFlags,
                          LPVOID       pBuffer     ,
                          DWORD        cbBuffer    ,
                          DWORD       *pcbBuf      ,
                          DWORD        dwReserved  );

    /////////////////////////////////////////////////////////////////////////////

    static bool LookForHCP( LPCWSTR pwzUrl, bool& fRedirect, LPCWSTR& pwzRedirect );
};

/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHWrapProtocolInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IClassFactory,
    public IInternetProtocolInfo
{
    CComPtr<IClassFactory>         m_realClass;
    CComPtr<IInternetProtocolInfo> m_realInfo;

	static void ExpandAndConcat( /*[out]*/ CComBSTR& bstrStorageName, /*[in]*/ LPCWSTR szVariable, /*[in]*/ LPCWSTR szAppend );

public:
DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CHCPProtocolInfo)
    COM_INTERFACE_ENTRY(IClassFactory)
    COM_INTERFACE_ENTRY(IInternetProtocolInfo)
END_COM_MAP()

    CPCHWrapProtocolInfo();
    virtual ~CPCHWrapProtocolInfo();

    HRESULT Init( REFGUID realClass );

	////////////////////

	static void NormalizeUrl( /*[in]*/ LPCWSTR pwzUrl, /*[out]*/ MPC::wstring& strUrlModified, /*[in]*/ bool fReverse );

	////////////////////

    // IClassFactory interface
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);


    // IInternetProtocolInfo interface
    STDMETHOD(ParseUrl)( LPCWSTR      pwzUrl      ,
                         PARSEACTION  ParseAction ,
                         DWORD        dwParseFlags,
                         LPWSTR       pwzResult   ,
                         DWORD        cchResult   ,
                         DWORD       *pcchResult  ,
                         DWORD        dwReserved  );

    STDMETHOD(CombineUrl)( LPCWSTR pwzBaseUrl    ,
                           LPCWSTR pwzRelativeUrl,
                           DWORD   dwCombineFlags,
                           LPWSTR  pwzResult     ,
                           DWORD   cchResult     ,
                           DWORD  *pcchResult    ,
                           DWORD   dwReserved    );

    STDMETHOD(CompareUrl)( LPCWSTR pwzUrl1        ,
                           LPCWSTR pwzUrl2        ,
                           DWORD   dwCompareFlags );

    STDMETHOD(QueryInfo)( LPCWSTR      pwzUrl      ,
                          QUERYOPTION  QueryOption ,
                          DWORD        dwQueryFlags,
                          LPVOID       pBuffer     ,
                          DWORD        cbBuffer    ,
                          DWORD       *pcbBuf      ,
                          DWORD        dwReserved  );
};

////////////////////////////////////////////////////////////////////////////////

class CHCPProtocolEnvironment
{
    bool     		   m_fHighContrast;
    bool     		   m_f16Colors;
	Taxonomy::Instance m_inst;

	MPC::string        m_strCSS;

	////////////////////

	HRESULT ProcessCSS();

public:
    CHCPProtocolEnvironment();
    ~CHCPProtocolEnvironment();

	////////////////////////////////////////////////////////////////////////////////

	static CHCPProtocolEnvironment* s_GLOBAL;

	static HRESULT InitializeSystem();
	static void    FinalizeSystem  ();
		
	////////////////////////////////////////////////////////////////////////////////

    bool UpdateState();

    void ReformatURL( CComBSTR& bstrURL );

    void    				  SetHelpLocation( /*[in]*/ const Taxonomy::Instance& inst );
    LPCWSTR 				  HelpLocation   (                                         );
    LPCWSTR 				  System         (                                         );
	const Taxonomy::Instance& Instance       (                                         );

    HRESULT GetCSS( /*[out]*/ CComPtr<IStream>& stream );
};

#endif // !defined(__INCLUDED___HCP___NAMESPACE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\options.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Options.h

Abstract:
    This file contains the declaration of the class used to implement
    the Options inside the Help Center Application.

Revision History:
    Davide Massarenti   (dmassare)  04/08/2001
        created

******************************************************************************/

#if !defined(__INCLUDED___PCH___OPTIONS_H___)
#define __INCLUDED___PCH___OPTIONS_H___

/////////////////////////////////////////////////////////////////////////////

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>


#include <TaxonomyDatabase.h>

class ATL_NO_VTABLE CPCHOptions : // Hungarian: pcho
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPCHOptions, &IID_IPCHOptions, &LIBID_HelpCenterTypeLib>
{
	typedef enum
	{
		c_Type_bool        ,
		c_Type_long        ,
		c_Type_DWORD       ,
		c_Type_VARIANT_BOOL,
		c_Type_STRING      ,
		c_Type_FONTSIZE    ,
		c_Type_TEXTLABELS  ,
	} OptType;

	struct OptionsDef
	{
		LPCWSTR szKey;
		LPCWSTR szValue;
		size_t  iOffset;
		size_t  iOffsetFlag;
		OptType iType;
		bool    fSaveAlways;
	};

	static const OptionsDef c_tbl   [];
	static const OptionsDef c_tbl_TS[];

    bool              m_fLoaded;
    bool              m_fDirty;
    bool              m_fNoSave;

    Taxonomy::HelpSet m_ths;
    Taxonomy::HelpSet m_ths_TS;
    VARIANT_BOOL      m_ShowFavorites;         bool m_flag_ShowFavorites;
    VARIANT_BOOL      m_ShowHistory;           bool m_flag_ShowHistory;
    OPT_FONTSIZE      m_FontSize;              bool m_flag_FontSize;
	TB_MODE           m_TextLabels;            bool m_flag_TextLabels;

    DWORD             m_DisableScriptDebugger; bool m_flag_DisableScriptDebugger;

	void ReadTable ( /*[in]*/ const OptionsDef* tbl, /*[in]*/ int len, /*[in]*/ MPC::RegKey& rk );
	void WriteTable( /*[in]*/ const OptionsDef* tbl, /*[in]*/ int len, /*[in]*/ MPC::RegKey& rk );

public:
BEGIN_COM_MAP(CPCHOptions)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHOptions)
END_COM_MAP()

    CPCHOptions();

    ////////////////////////////////////////////////////////////////////////////////

    static CPCHOptions* s_GLOBAL;

    static HRESULT InitializeSystem();
    static void    FinalizeSystem  ();

    ////////////////////////////////////////////////////////////////////////////////

    HRESULT Load( /*[in]*/ bool fForce = false );
    HRESULT Save( /*[in]*/ bool fForce = false );

    void DontPersistSKU() { m_fNoSave = true; }

    Taxonomy::HelpSet& CurrentHelpSet       () { return m_ths                                                 ; }
    Taxonomy::HelpSet& TerminalServerHelpSet() { return m_ths_TS                                              ; }
    VARIANT_BOOL       ShowFavorites        () { return m_ShowFavorites                                       ; }
    VARIANT_BOOL       ShowHistory          () { return m_ShowHistory                                         ; }
    OPT_FONTSIZE       FontSize             () { return m_FontSize                                            ; }
    TB_MODE            TextLabels           () { return m_TextLabels                                          ; }
    VARIANT_BOOL       DisableScriptDebugger() { return m_DisableScriptDebugger ? VARIANT_TRUE : VARIANT_FALSE; }

	HRESULT ApplySettings( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in]*/ IUnknown* unk );

public:
    // IPCHOptions
    STDMETHOD(get_ShowFavorites        )( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_ShowFavorites        )( /*[in         ]*/	VARIANT_BOOL  newVal );
    STDMETHOD(get_ShowHistory          )( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_ShowHistory          )( /*[in         ]*/	VARIANT_BOOL  newVal );
    STDMETHOD(get_FontSize             )( /*[out, retval]*/	OPT_FONTSIZE *  pVal );
    STDMETHOD(put_FontSize             )( /*[in         ]*/	OPT_FONTSIZE  newVal );
    STDMETHOD(get_TextLabels           )( /*[out, retval]*/	TB_MODE 	 *  pVal );
    STDMETHOD(put_TextLabels           )( /*[in         ]*/	TB_MODE 	  newVal );
    STDMETHOD(get_DisableScriptDebugger)( /*[out, retval]*/	VARIANT_BOOL *  pVal );
    STDMETHOD(put_DisableScriptDebugger)( /*[in         ]*/	VARIANT_BOOL  newVal );

    STDMETHOD(Apply)();

    HRESULT put_CurrentHelpSet( /*[in]*/ Taxonomy::HelpSet& ths ); // INTERNAL_METHOD
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___OPTIONS_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\serviceproxy.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ServiceProxy.h

Abstract:
    All the interaction with the Help Service is done through this class.
    It's responsible for kickstarting the service as late as possible.

Revision History:
    Davide Massarenti   (dmassare) 07/17/2000
        created

    Kalyani Narlanka    (KalyaniN)  03/15/01
	    Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.
******************************************************************************/

#if !defined(__INCLUDED___PCH___SERVICEPROXY_H___)
#define __INCLUDED___PCH___SERVICEPROXY_H___

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>


#include <MPC_COM.h>

#include <Events.h>
#include <HelpSession.h>
#include <Options.h>

#include <ConnectivityLib.h>
#include <OfflineCache.h>

/////////////////////////////////////////////////////////////////////////////

class CPCHProxy_IPCHService;
class CPCHProxy_IPCHUtility;
class CPCHProxy_IPCHUserSettings2;
class CPCHProxy_IPCHSetOfHelpTopics;
class CPCHProxy_IPCHTaxonomyDatabase;
class CPCHHelpCenterExternal;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// IDispatchEx (We override the default implementation to get a chance to look at the TRUSTED/UNTRUSTED settings)
//
#define INTERNETSECURITY__INVOKEEX()                                                               \
    STDMETHOD(InvokeEx)( DISPID            id        ,                                             \
                         LCID              lcid      ,                                             \
                         WORD              wFlags    ,                                             \
                         DISPPARAMS*       pdp       ,                                             \
                         VARIANT*          pvarRes   ,                                             \
                         EXCEPINFO*        pei       ,                                             \
                         IServiceProvider* pspCaller )                                             \
    {                                                                                              \
        return m_SecurityHandle.ForwardInvokeEx( id, lcid, wFlags, pdp, pvarRes, pei, pspCaller ); \
    }

#define INTERNETSECURITY__CHECK_TRUST()  __MPC_EXIT_IF_METHOD_FAILS(hr, m_SecurityHandle.IsTrusted())
#define INTERNETSECURITY__CHECK_SYSTEM() __MPC_EXIT_IF_METHOD_FAILS(hr, m_SecurityHandle.IsSystem())

class CPCHSecurityHandle
{
    CPCHHelpCenterExternal* m_ext;
    IDispatch*              m_object;

public:
    CPCHSecurityHandle();

    void Initialize( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in] */ IDispatch* object );
    void Passivate (                                                                   );

	operator CPCHHelpCenterExternal*() const { return m_ext; }

    ////////////////////

    HRESULT ForwardInvokeEx( /*[in] */ DISPID            id        ,
                             /*[in] */ LCID              lcid      ,
                             /*[in] */ WORD              wFlags    ,
                             /*[in] */ DISPPARAMS*       pdp       ,
                             /*[out]*/ VARIANT*          pvarRes   ,
                             /*[out]*/ EXCEPINFO*        pei       ,
                             /*[in] */ IServiceProvider* pspCaller );

    HRESULT IsTrusted();
    HRESULT IsSystem ();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

namespace AsynchronousTaxonomyDatabase
{
    class Notifier;
    class QueryStore;
    class Engine;

    ////////////////////

    class NotifyHandle : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // For locking and reference counting...
    {
        friend class Notifier;

        int                        m_iType;
        CComBSTR                   m_bstrID;

        bool                       m_fAttached;
        HANDLE                     m_hEvent;

        HRESULT                    m_hr;
        CPCHQueryResultCollection* m_pColl;

        ////////////////////

        HRESULT Init(                                           );
        void    Bind( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID );

        virtual void Call( /*[in]*/ QueryStore* qs );

    public:
        NotifyHandle();
        virtual ~NotifyHandle();

        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        virtual void Detach();
        virtual bool IsAttached();

        HRESULT GetData( /*[out]*/ CPCHQueryResultCollection* *pColl                );
        HRESULT Wait   ( /*[in]*/  DWORD                       dwTimeout = INFINITE );
    };

    template <class C> class NotifyHandle_Method : public NotifyHandle
    {
        typedef void (C::*CLASS_METHOD)( /*[in]*/ NotifyHandle* notify );

        C*           m_pThis;
        CLASS_METHOD m_pCallback;

        ////////////////////

        void Call( /*[in]*/ QueryStore* qs )
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            NotifyHandle::Call( qs );

            if(m_pThis)
            {
                (m_pThis->*m_pCallback)( this );
            }
        }

    public:
        NotifyHandle_Method( /*[in]*/ C* pThis, /*[in]*/ CLASS_METHOD pCallback )
        {
            m_pThis     = pThis;
            m_pCallback = pCallback;
        }

        void Detach()
        {
            MPC::SmartLock<_ThreadModel> lock( this );

            NotifyHandle::Detach( qs );

            m_pThis = NULL;
        }
    };

    class Notifier : public CComObjectRootEx<MPC::CComSafeMultiThreadModel> // For locking...
    {
        typedef std::list< NotifyHandle* > List;
        typedef List::iterator             Iter;
        typedef List::const_iterator       IterConst;

        List m_lstCallback;

        ////////////////////

    private: // Disable copy constructors...
        Notifier           ( /*[in]*/ const Notifier& );
        Notifier& operator=( /*[in]*/ const Notifier& );

    public:
        Notifier();
        ~Notifier();

        ////////////////////

        void Notify( /*[in]*/ QueryStore* qs );

        ////////////////////

        HRESULT AddNotification( /*[in]*/ QueryStore* qs, /*[in]*/ NotifyHandle* nb );
    };

    ////////////////////

    class QueryStore
    {
        friend class Notifier;
        friend class Engine;

        int              m_iType;
        CComBSTR         m_bstrID;
		CComVariant      m_vOption;

        bool             m_fDone;
        HRESULT          m_hr;
        MPC::CComHGLOBAL m_hgData;
        FILETIME         m_dLastUsed;

    private: // Disable copy constructors...
        QueryStore           ( /*[in]*/ const QueryStore& );
        QueryStore& operator=( /*[in]*/ const QueryStore& );

    public:
        QueryStore( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option );
        ~QueryStore();

        bool LessThen ( /*[in]*/ QueryStore const &qs ) const;
        bool NewerThen( /*[in]*/ QueryStore const &qs ) const;

        ////////////////////

        HRESULT Execute( /*[in]*/ OfflineCache::Handle* handle, /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent, /*[in]*/ bool fForce = false );

        HRESULT GetData( /*[out]*/ CPCHQueryResultCollection* *pColl );

        void Invalidate();
    };

    ////////////////////

    class Engine :
        public MPC::Thread<Engine,IUnknown>,
        public CComObjectRootEx<MPC::CComSafeMultiThreadModel>
    {
        class CompareQueryStores
        {
        public:
            bool operator()( /*[in]*/ const QueryStore *, /*[in]*/ const QueryStore * ) const;
        };

        typedef std::set<QueryStore *,CompareQueryStores> Set;
        typedef Set::iterator                             Iter;
        typedef Set::const_iterator                       IterConst;

        CPCHProxy_IPCHTaxonomyDatabase* m_parent;
        Set                             m_setQueries;
        Notifier                        m_notifier;

        ////////////////////

        bool LookupCache( /*[out]*/ OfflineCache::Handle& handle );

        HRESULT Run();

        void InvalidateQueries();

    public:
        Engine( /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent );
        virtual ~Engine();

        void Passivate        ();
        void RefreshConnection();

        ////////////////////

        HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option, /*[in]*/          NotifyHandle*               nb  );
        HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option, /*[out, retval]*/ CPCHQueryResultCollection* *ppC );
    };
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef MPC::SmartLockGeneric<MPC::CComSafeAutoCriticalSection> ProxySmartLock;

class ATL_NO_VTABLE CPCHProxy_IPCHService :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl< IPCHService, &IID_IPCHService, &LIBID_HelpServiceTypeLib>
{
    CPCHSecurityHandle                     m_SecurityHandle;
    CPCHHelpCenterExternal*                m_parent;

	MPC::CComSafeAutoCriticalSection       m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHService> m_Direct_Service;
    bool                                   m_fContentStoreTested;

    CPCHProxy_IPCHUtility*                 m_Utility;

public:
BEGIN_COM_MAP(CPCHProxy_IPCHService)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHService)
END_COM_MAP()

    CPCHProxy_IPCHService();
    virtual ~CPCHProxy_IPCHService();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHHelpCenterExternal* Parent     () { return   m_parent;         }
    bool                    IsConnected() { return !!m_Direct_Service; }

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHHelpCenterExternal* parent                             );
    void    Passivate             (                                                                     );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHService>& svc, /*[in]*/ bool fRefresh = false );
    HRESULT EnsureContentStore    (                                                                     );

    HRESULT GetUtility( /*[out]*/ CPCHProxy_IPCHUtility* *pVal = NULL );

    ////////////////////

public:
    // IPCHService
    STDMETHOD(get_RemoteSKUs)( /*[out, retval]*/ IPCHCollection* *pVal ) { return E_NOTIMPL; }

    STDMETHOD(IsTrusted)( /*[in]*/ BSTR bstrURL, /*[out, retval]*/ VARIANT_BOOL *pfTrusted ) { return E_NOTIMPL; }

    STDMETHOD(Utility           )( /*[in]*/ BSTR bstrSKU, /*[in]*/ long	lLCID, /*[out]*/ IPCHUtility*            *pVal ) { return E_NOTIMPL; }
    STDMETHOD(RemoteHelpContents)( /*[in]*/ BSTR bstrSKU, /*[in]*/ long	lLCID, /*[out]*/ IPCHRemoteHelpContents* *pVal ) { return E_NOTIMPL; }

    STDMETHOD(RegisterHost       )(                           /*[in]*/ BSTR bstrID  ,                        /*[in ]*/ IUnknown*   pObj ) { return E_NOTIMPL; }
    STDMETHOD(CreateScriptWrapper)( /*[in]*/ REFCLSID rclsid, /*[in]*/ BSTR bstrCode, /*[in]*/ BSTR bstrURL, /*[out]*/ IUnknown* *ppObj );

    STDMETHOD(TriggerScheduledDataCollection)( /*[in]*/ VARIANT_BOOL fStart ) { return E_NOTIMPL; }
    STDMETHOD(PrepareForShutdown            )(                              ) { return E_NOTIMPL; }

    STDMETHOD(ForceSystemRestore)(                                            ) { return E_NOTIMPL; }
    STDMETHOD(UpgradeDetected	)(                                            ) { return E_NOTIMPL; }
    STDMETHOD(MUI_Install  	 	)( /*[in]*/ long LCID, /*[in]*/ BSTR bstrFile ) { return E_NOTIMPL; }
    STDMETHOD(MUI_Uninstall	 	)( /*[in]*/ long LCID                         ) { return E_NOTIMPL; }


    STDMETHOD(RemoteConnectionParms)( /*[in	]*/ BSTR 			 bstrUserName          ,
									  /*[in	]*/ BSTR 			 bstrDomainName        ,
									  /*[in	]*/ long 			 lSessionID            ,
									  /*[in	]*/ BSTR 			 bstrUserHelpBlob      ,
									  /*[out]*/ BSTR            *pbstrConnectionString ) { return E_NOTIMPL; }
    STDMETHOD(RemoteUserSessionInfo)( /*[out]*/ IPCHCollection* *pVal                  ) { return E_NOTIMPL; }
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHUtility :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl< IPCHUtility, &IID_IPCHUtility, &LIBID_HelpServiceTypeLib>
{
    CPCHSecurityHandle                     m_SecurityHandle;
    CPCHProxy_IPCHService*                 m_parent;
										   
	MPC::CComSafeAutoCriticalSection       m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHUtility> m_Direct_Utility;

    CPCHProxy_IPCHUserSettings2*    	   m_UserSettings2;
    CPCHProxy_IPCHTaxonomyDatabase* 	   m_TaxonomyDatabase;

public:
BEGIN_COM_MAP(CPCHProxy_IPCHUtility)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHUtility)
END_COM_MAP()

    CPCHProxy_IPCHUtility();
    virtual ~CPCHProxy_IPCHUtility();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHProxy_IPCHService* Parent     () { return   m_parent;         }
    bool                   IsConnected() { return !!m_Direct_Utility; }

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHProxy_IPCHService* parent, /*[in]*/ CPCHHelpCenterExternal* ext );
    void    Passivate             (                                                                              );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHUtility>& util, /*[in]*/ bool fRefresh = false         );

    HRESULT GetUserSettings2( /*[out]*/ CPCHProxy_IPCHUserSettings2*    *pVal = NULL );
    HRESULT GetDatabase     ( /*[out]*/ CPCHProxy_IPCHTaxonomyDatabase* *pVal = NULL );

    ////////////////////

public:
    // IPCHUtility
    STDMETHOD(get_UserSettings)( /*[out, retval]*/ IPCHUserSettings*     *pVal );
    STDMETHOD(get_Channels    )( /*[out, retval]*/ ISAFReg*              *pVal );
    STDMETHOD(get_Security    )( /*[out, retval]*/ IPCHSecurity*         *pVal );
    STDMETHOD(get_Database    )( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal );


    STDMETHOD(FormatError)( /*[in]*/ VARIANT vError, /*[out, retval]*/ BSTR *pVal );

    STDMETHOD(CreateObject_SearchEngineMgr)(                                                          /*[out, retval]*/ IPCHSEManager*      *ppSE );
    STDMETHOD(CreateObject_DataCollection )(                                                          /*[out, retval]*/ ISAFDataCollection* *ppDC );
    STDMETHOD(CreateObject_Cabinet        )(                                                          /*[out, retval]*/ ISAFCabinet*        *ppCB );
    STDMETHOD(CreateObject_Encryption     )(                                                          /*[out, retval]*/ ISAFEncrypt*        *ppEn );
    STDMETHOD(CreateObject_Channel        )( /*[in]*/ BSTR bstrVendorID, /*[in]*/ BSTR bstrProductID, /*[out, retval]*/ ISAFChannel*        *ppCh );

	STDMETHOD(CreateObject_RemoteDesktopConnection)( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC               );
	STDMETHOD(CreateObject_RemoteDesktopSession   )( /*[in]         */ REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                     /*[in]         */ long 						 lTimeout            ,
                                                     /*[in]         */ BSTR 						 bstrConnectionParms ,
													 /*[in]         */ BSTR 						 bstrUserHelpBlob    ,
													 /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               );


    STDMETHOD(ConnectToExpert)( /*[in]*/ BSTR bstrExpertConnectParm, /*[in]*/ LONG lTimeout, /*[out, retval]*/ LONG *lSafErrorCode );

	STDMETHOD(SwitchDesktopMode)( /*[in]*/ int nMode, /* [in]*/ int nRAType );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHUserSettings2 :
    public MPC::Thread<CPCHProxy_IPCHUserSettings2,IPCHUserSettings2>,
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl<IPCHUserSettings2, &IID_IPCHUserSettings2, &LIBID_HelpCenterTypeLib>
{
    CPCHSecurityHandle                          m_SecurityHandle;
    CPCHProxy_IPCHUtility*                      m_parent;

	MPC::CComSafeAutoCriticalSection            m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHUserSettings> m_Direct_UserSettings;

    CPCHProxy_IPCHSetOfHelpTopics*     	        m_MachineSKU;
    CPCHProxy_IPCHSetOfHelpTopics*     	        m_CurrentSKU;
	Taxonomy::HelpSet                           m_ths;
	CComBSTR                                    m_bstrScope;

    bool                                        m_fReady;
	Taxonomy::Instance                          m_instMachine;
	Taxonomy::Instance                          m_instCurrent;

	bool                                        m_News_fDone;
    bool                                        m_News_fEnabled;
    MPC::CComPtrThreadNeutral<IUnknown>         m_News_xmlData;

    ////////////////////

	HRESULT PollNews   ();
	HRESULT PrepareNews();

	HRESULT GetInstanceValue( /*[in]*/ const MPC::wstring* str, /*[out, retval]*/ BSTR *pVal );

public:
BEGIN_COM_MAP(CPCHProxy_IPCHUserSettings2)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHUserSettings)
    COM_INTERFACE_ENTRY(IPCHUserSettings2)
END_COM_MAP()

    CPCHProxy_IPCHUserSettings2();
    virtual ~CPCHProxy_IPCHUserSettings2();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHProxy_IPCHUtility* Parent      	  () {                       return   m_parent;                       }
    bool                   IsConnected 	  () {                       return !!m_Direct_UserSettings;          }
    bool                   IsDesktopSKU	  () { (void)EnsureInSync(); return   m_instCurrent.m_fDesktop;       }
    Taxonomy::Instance&    MachineInstance() {                       return   m_instMachine;                  }
    Taxonomy::Instance&    CurrentInstance() {                       return   m_instCurrent;                  }
    Taxonomy::HelpSet&     THS         	  () {                       return   m_ths;                          }

    HRESULT EnsureInSync();

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHProxy_IPCHUtility* parent, /*[in]*/ CPCHHelpCenterExternal* ext );
    void    Passivate             (                                                                              );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHUserSettings>& us, /*[in]*/ bool fRefresh = false      );
    HRESULT Initialize            (                                                                              );

	HRESULT GetCurrentSKU( /*[out]*/ CPCHProxy_IPCHSetOfHelpTopics* *pVal = NULL );
	HRESULT GetMachineSKU( /*[out]*/ CPCHProxy_IPCHSetOfHelpTopics* *pVal = NULL );

    ////////////////////

    bool    CanUseUserSettings();
    HRESULT LoadUserSettings  ();
    HRESULT SaveUserSettings  ();

public:
    // IPCHUserSettings
    STDMETHOD(get_CurrentSKU)( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal );
    STDMETHOD(get_MachineSKU)( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal );

    STDMETHOD(get_HelpLocation    )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_DatabaseDir     )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_DatabaseFile    )(  							   	   /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_IndexFile       )( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_IndexDisplayName)( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal );
    STDMETHOD(get_LastUpdated     )(  							   	   /*[out, retval]*/ DATE *pVal );

    STDMETHOD(get_AreHeadlinesEnabled)( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_News               )( /*[out, retval]*/ IUnknown*    *pVal );


    STDMETHOD(Select)( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID );


    // IPCHUserSettings2
    STDMETHOD(get_Favorites)( /*[out, retval]*/ IPCHFavorites* *pVal   );
    STDMETHOD(get_Options  )( /*[out, retval]*/ IPCHOptions*   *pVal   );
    STDMETHOD(get_Scope    )( /*[out, retval]*/ BSTR           *pVal   );
    HRESULT   put_Scope     ( /*[in         ]*/ BSTR            newVal ); // INTERNAL METHOD.

    STDMETHOD(get_IsRemoteSession 	  )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IsTerminalServer	  )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IsDesktopVersion	  )( /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(get_IsAdmin             )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IsPowerUser         )( /*[out, retval]*/ VARIANT_BOOL *pVal );

    STDMETHOD(get_IsStartPanelOn      )( /*[out, retval]*/ VARIANT_BOOL *pVal );
    STDMETHOD(get_IsWebViewBarricadeOn)( /*[out, retval]*/ VARIANT_BOOL *pVal );
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHSetOfHelpTopics :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public IDispatchImpl<IPCHSetOfHelpTopics, &IID_IPCHSetOfHelpTopics, &LIBID_HelpServiceTypeLib>
{
    CPCHProxy_IPCHUserSettings2*                   m_parent;

	MPC::CComSafeAutoCriticalSection               m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHSetOfHelpTopics> m_Direct_SKU;
	bool                                           m_fMachine;

    ////////////////////

public:
BEGIN_COM_MAP(CPCHProxy_IPCHSetOfHelpTopics)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHSetOfHelpTopics)
END_COM_MAP()

    CPCHProxy_IPCHSetOfHelpTopics();
    virtual ~CPCHProxy_IPCHSetOfHelpTopics();

    ////////////////////

    CPCHProxy_IPCHUserSettings2* Parent     () { return   m_parent;     }
    bool                   		 IsConnected() { return !!m_Direct_SKU; }

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHProxy_IPCHUserSettings2* parent, /*[in]*/ bool fMachine        );
    void    Passivate             (                                                                             );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHSetOfHelpTopics>& sht, /*[in]*/ bool fRefresh = false );

    ////////////////////

public:
    // 
    // IPCHSetOfHelpTopics
    STDMETHOD(get_SKU           )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Language      )( /*[out, retval]*/ long         *pVal     );
    STDMETHOD(get_DisplayName   )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_ProductID     )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Version       )( /*[out, retval]*/ BSTR         *pVal     );

    STDMETHOD(get_Location      )( /*[out, retval]*/ BSTR         *pVal     );
    STDMETHOD(get_Exported      )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(put_Exported      )( /*[in         ]*/ VARIANT_BOOL  newVal   );

    STDMETHOD(put_onStatusChange)( /*[in         ]*/ IDispatch*    function );
    STDMETHOD(get_Status        )( /*[out, retval]*/ SHT_STATUS   *pVal     );
    STDMETHOD(get_ErrorCode     )( /*[out, retval]*/ long         *pVal     );

    STDMETHOD(get_IsMachineHelp )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_IsInstalled   )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_CanInstall    )( /*[out, retval]*/ VARIANT_BOOL *pVal     );
    STDMETHOD(get_CanUninstall  )( /*[out, retval]*/ VARIANT_BOOL *pVal     );

    STDMETHOD(Install  )();
    STDMETHOD(Uninstall)();
    STDMETHOD(Abort    )();
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHProxy_IPCHTaxonomyDatabase :
    public CComObjectRootEx<MPC::CComSafeMultiThreadModel>,
    public MPC::IDispatchExImpl< IPCHTaxonomyDatabase, &IID_IPCHTaxonomyDatabase, &LIBID_HelpServiceTypeLib>
{
    CPCHSecurityHandle                              m_SecurityHandle;
    CPCHProxy_IPCHUtility*                          m_parent;

	MPC::CComSafeAutoCriticalSection                m_DirectLock;
    MPC::CComPtrThreadNeutral<IPCHTaxonomyDatabase> m_Direct_TaxonomyDatabase;
    AsynchronousTaxonomyDatabase::Engine            m_AsyncCachingEngine;

public:
BEGIN_COM_MAP(CPCHProxy_IPCHTaxonomyDatabase)
    COM_INTERFACE_ENTRY2(IDispatch, IDispatchEx)
    COM_INTERFACE_ENTRY(IDispatchEx)
    COM_INTERFACE_ENTRY(IPCHTaxonomyDatabase)
END_COM_MAP()

    CPCHProxy_IPCHTaxonomyDatabase();
    virtual ~CPCHProxy_IPCHTaxonomyDatabase();

    INTERNETSECURITY__INVOKEEX();

    ////////////////////

    CPCHProxy_IPCHUtility* Parent     () { return   m_parent;                  };
    bool                   IsConnected() { return !!m_Direct_TaxonomyDatabase; };

    ////////////////////

    HRESULT ConnectToParent       ( /*[in]*/ CPCHProxy_IPCHUtility* parent, /*[in]*/ CPCHHelpCenterExternal* ext );
    void    Passivate             (                                                                              );
    HRESULT EnsureDirectConnection( /*[out]*/ CComPtr<IPCHTaxonomyDatabase>& db, /*[in]*/ bool fRefresh = false  );

    ////////////////////

    HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[out, retval]*/ CPCHQueryResultCollection* *ppC, /*[in]*/ VARIANT* option = NULL );
    HRESULT ExecuteQuery( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[out, retval]*/ IPCHCollection*            *ppC, /*[in]*/ VARIANT* option = NULL );

public:
    // IPCHTaxonomyDatabase
    STDMETHOD(get_InstalledSKUs      )( /*[out, retval]*/ IPCHCollection* *pVal );
    STDMETHOD(get_HasWritePermissions)( /*[out, retval]*/ VARIANT_BOOL    *pVal );

    STDMETHOD(LookupNode          )( /*[in]*/ BSTR bstrNode ,                                     /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupSubNodes      )( /*[in]*/ BSTR bstrNode , /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupNodesAndTopics)( /*[in]*/ BSTR bstrNode , /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LookupTopics        )( /*[in]*/ BSTR bstrNode , /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(LocateContext       )( /*[in]*/ BSTR bstrURL  , /*[in,optional]*/ VARIANT vSubSite, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(KeywordSearch       )( /*[in]*/ BSTR bstrQuery, /*[in,optional]*/ VARIANT vSubSite, /*[out, retval]*/ IPCHCollection* *ppC );

    STDMETHOD(GatherNodes         )( /*[in]*/ BSTR bstrNode , /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(GatherTopics        )( /*[in]*/ BSTR bstrNode , /*[in]*/ VARIANT_BOOL fVisibleOnly, /*[out, retval]*/ IPCHCollection* *ppC );

    STDMETHOD(ConnectToDisk  )( /*[in]*/ BSTR bstrDirectory , /*[in]*/ IDispatch* notify, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(ConnectToServer)( /*[in]*/ BSTR bstrServerName, /*[in]*/ IDispatch* notify, /*[out, retval]*/ IPCHCollection* *ppC );
    STDMETHOD(Abort          )(                                                                                                  );
};

////////////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___PCH___SERVICEPROXY_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\intercom\client\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__SAFINTERCOMCLIENT)
#define AFX_STDAFX_H__SAFINTERCOMCLIENT

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <userenv.h>

//JP://#include <Debug.h>

//////

#include <HelpCenter.h>
#include <HelpCenterExternal.h>

// To define GUIDS
#include <initguid.h>

#include <SAFIntercomClient.h>



//#include <atlcom.h> 

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__SAFINTERCOMCLIENT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\printing.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Printing.h

Abstract:
    Trident control hosting code for multi-topic printing.

Revision History:
    Davide Massarenti   (Dmassare)  05/07/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___HCP___PRINTING_H___)
#define __INCLUDED___HCP___PRINTING_H___

#include <commdlg.h>
#include <shlobj.h>
#include <exdisp.h>
#include <exdispid.h>

namespace Printing
{
    class HostWindow :
        public CAxHostWindow,
        public IOleCommandTarget
    {
        ULONG        m_cRef;

        MPC::wstring m_szPrintFileName;
        bool         m_fMultiTopic;

        bool         m_fShowPrintDlg;
		LPDEVMODEW   m_pDevMode;
		CComBSTR     m_bstrPrinterName;

		bool         m_fAborted;
		HANDLE       m_hEvent;

    public:
        HostWindow();
        virtual ~HostWindow();

        DECLARE_GET_CONTROLLING_UNKNOWN()
        DECLARE_PROTECT_FINAL_CONSTRUCT()

        BEGIN_COM_MAP(HostWindow)
            COM_INTERFACE_ENTRY(IOleCommandTarget)
            COM_INTERFACE_ENTRY_CHAIN(CAxHostWindow)
        END_COM_MAP()

        //
        // IOleCommandTarget
        //
        STDMETHODIMP QueryStatus( /*[in]    */ const GUID* pguidCmdGroup ,
                                  /*[in]    */ ULONG       cCmds         ,
                                  /*[in/out]*/ OLECMD     *prgCmds       ,
                                  /*[in/out]*/ OLECMDTEXT *pCmdText      );

        STDMETHODIMP Exec( /*[in] */ const GUID* pguidCmdGroup ,
                           /*[in] */ DWORD       nCmdID        ,
                           /*[in] */ DWORD       nCmdExecOpt   ,
                           /*[in] */ VARIANTARG* pvaIn         ,
                           /*[out]*/ VARIANTARG* pvaOut        );


        void SetMultiTopic   ( /*[in]*/ bool    fMulti          );
        void SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName );
		void SetAbortEvent   ( /*[in]*/ HANDLE  hEvent          );
		bool GetAbortState   (                                  );
        BSTR GetPrinterName  (                                  );
    };

    template <typename TDerived, typename TWindow = CAxWindow> class WindowImplT : public CWindowImplBaseT< TWindow >
    {
    public:
        typedef WindowImplT<TWindow> thisClass;

        BEGIN_MSG_MAP(thisClass)
            MESSAGE_HANDLER(WM_CREATE,OnCreate)
            MESSAGE_HANDLER(WM_NCDESTROY,OnNCDestroy)
        END_MSG_MAP()

        DECLARE_WND_SUPERCLASS(_T("AtlPchAxWin"), CAxWindow::GetWndClassName())

        virtual HRESULT PrivateCreateControlEx( LPCOLESTR  lpszName       ,
												HWND       hWnd           ,
												IStream*   pStream        ,
												IUnknown* *ppUnkContainer ,
												IUnknown* *ppUnkControl   ,
												REFIID     iidSink        ,
												IUnknown*  punkSink       )
	    {
            return AtlAxCreateControlEx( lpszName       ,
										 hWnd           ,
										 pStream        ,
										 ppUnkContainer ,
										 ppUnkControl   ,
										 iidSink        ,
										 punkSink       );
		}

        HWND Create( HWND    hWndParent,
                     RECT&   rcPos,
                     LPCTSTR szWindowName  = NULL ,
                     DWORD   dwStyle       = 0    ,
                     DWORD   dwExStyle     = 0    ,
                     UINT    nID           = 0    ,
                     LPVOID  lpCreateParam = NULL )
        {
            if(GetWndClassInfo().m_lpszOrigName == NULL)
            {
                GetWndClassInfo().m_lpszOrigName = GetWndClassName();
            }

            ATOM atom = GetWndClassInfo().Register( &m_pfnSuperWindowProc );

            dwStyle   = GetWndStyle  ( dwStyle   );
            dwExStyle = GetWndExStyle( dwExStyle );

            return CWindowImplBaseT<TWindow>::Create( hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, atom, lpCreateParam );
        }

        ////////////////////////////////////////////////////////////////////////////////

        LRESULT OnCreate( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
        {
            USES_CONVERSION;

            CREATESTRUCT*     lpCreate    = (CREATESTRUCT*)lParam;
            int               nLen        = ::GetWindowTextLength( m_hWnd );
            LPTSTR            lpstrName   = (LPTSTR)_alloca( (nLen + 1) * sizeof(TCHAR) );
            IAxWinHostWindow* pAxWindow   = NULL;
            int               nCreateSize = 0;
            CComPtr<IUnknown> spUnk;
            CComPtr<IStream>  spStream;



            ::GetWindowText( m_hWnd, lpstrName, nLen + 1 );
            ::SetWindowText( m_hWnd, _T("")              );

            if(lpCreate && lpCreate->lpCreateParams)
            {
                nCreateSize = *((WORD*)lpCreate->lpCreateParams);
            }

            //
            // Get the data for the initialization stream.
            //
            if(nCreateSize)
            {
                HGLOBAL h = GlobalAlloc( GHND, nCreateSize );

                if(h)
                {
                    BYTE* pBytes  =  (BYTE*)GlobalLock( h );
                    BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD);

                    //Align to DWORD
                    //pSource += (((~((DWORD)pSource)) + 1) & 3);
                    memcpy( pBytes, pSource, nCreateSize );

                    ::GlobalUnlock( h );
                    ::CreateStreamOnHGlobal( h, TRUE, &spStream );
                }
            }

            //
            // call the real creation routine here...
            //
            HRESULT hRet = PrivateCreateControlEx( T2COLE( lpstrName ), m_hWnd, spStream, &spUnk, NULL, IID_NULL, NULL );
            if(FAILED(hRet)) return -1; // abort window creation

            hRet = spUnk->QueryInterface( IID_IAxWinHostWindow, (void**)&pAxWindow );
            if(FAILED(hRet)) return -1; // abort window creation

			::SetWindowLongPtr( m_hWnd, GWLP_USERDATA, (LONG_PTR)pAxWindow );

            //
            // check for control parent style if control has a window
            //
            {
                HWND hWndChild = ::GetWindow( m_hWnd, GW_CHILD );

                if(hWndChild != NULL)
                {
                    if(::GetWindowLong( hWndChild, GWL_EXSTYLE ) & WS_EX_CONTROLPARENT)
                    {
                        DWORD dwExStyle = ::GetWindowLong( m_hWnd, GWL_EXSTYLE );

                        dwExStyle |= WS_EX_CONTROLPARENT;

                        ::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle );
                    }
                }
            }

            bHandled = TRUE;
            return 0L;
        }

        LRESULT OnNCDestroy( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
        {
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr( m_hWnd, GWLP_USERDATA );

            if(pAxWindow != NULL) pAxWindow->Release();

            m_hWnd   = NULL;
            bHandled = TRUE;

            return 0L;
        }
    };

	////////////////////////////////////////////////////////////////////////////////

    class WindowHandle : public WindowImplT<WindowHandle>
    {
    public:
        typedef WindowImplT<WindowHandle> baseClass;
        typedef CComObject<HostWindow>    theSite;

    private:
        theSite*      m_pSiteObject;
        bool          m_fMultiTopic;
        MPC::wstring  m_szPrintFileName;
		HANDLE        m_hEvent;

    public:
        WindowHandle();
        ~WindowHandle();

        BEGIN_MSG_MAP(WindowHandle)
            CHAIN_MSG_MAP(baseClass)
        END_MSG_MAP()

        virtual HRESULT PrivateCreateControlEx( LPCOLESTR  lpszName       ,
												HWND       hWnd           ,
												IStream*   pStream        ,
												IUnknown* *ppUnkContainer ,
												IUnknown* *ppUnkControl   ,
												REFIID     iidSink        ,
												IUnknown*  punkSink       );

		void SetMultiTopic   ( /*[in]*/ bool    fMulti          );
		void SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName );
		void SetAbortEvent   ( /*[in]*/ HANDLE  hEvent          );
		bool GetAbortState   (                                  );
		BSTR GetPrinterName  (                                  );
	};

	////////////////////////////////////////////////////////////////////////////////

	class ATL_NO_VTABLE CDispatchSink :
		public CComObjectRootEx<CComSingleThreadModel>,
		public IDispatch
	{
		HANDLE   m_hEvent;
		CComBSTR m_URL;

	public:
		BEGIN_COM_MAP(CDispatchSink)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
		END_COM_MAP()

		CDispatchSink();

		void SetNotificationEvent( /*[in]*/ HANDLE hEvent );
		BSTR GetCurrentURL       (                        );

		STDMETHOD(GetTypeInfoCount)(UINT* pctinfo);
		STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
		STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);

		STDMETHOD(Invoke)( DISPID      dispidMember ,
						   REFIID      riid         ,
						   LCID        lcid         ,
						   WORD        wFlags       ,
						   DISPPARAMS* pdispparams  ,
						   VARIANT*    pvarResult   ,
						   EXCEPINFO*  pexcepinfo   ,
						   UINT*       puArgErr     );
	};

	////////////////////////////////////////////////////////////////////////////////

	class Print
	{
	public:
		class Notification
		{
		public:
			virtual HRESULT Progress( /*[in]*/ LPCWSTR szURL, /*[in]*/ int iDone, /*[in]*/ int iTotal ) = 0;
		};

	private:
		Notification*              m_pCallback;               // Client for notification.
                                                              //
		MPC::WStringList      	   m_lstURLs;                 // list of urls to be printed
                                                              //
		HWND                       m_hwnd;                    // parent window.
		WindowHandle          	   m_wnd;                     // window for hosting Trident
		CComPtr<IWebBrowser2>      m_spWebBrowser2;           // pointer for Navigate call
                                                              //
		CComPtr<CDispatchSink>     m_spObjDisp;               // our sink object for Trident events
		HANDLE                     m_eventDocComplete;	      // this event is for notifying our code when the webbrowser is done loading a topic
		HANDLE                     m_eventAbortPrint;         // this event is for notifying our code when the webbrowser is done printing a topic
                                                              //
		CComPtr<IUnknown>     	   m_spUnkControl;            // IUnknown of our control
		DWORD                 	   m_dwCookie;                // cookie for our Unadvise call
		CComPtr<IOleCommandTarget> m_spOleCmdTarg;            // pointer we need to tell Trident to print
		MPC::wstring			   m_szPrintDir;   			  // directory to print to
		MPC::wstring			   m_szPrintFile;  			  // file to print to
                                                              //
		CComPtr<IStream>           m_streamPrintData;         // pointer to raw printer data


		HRESULT PrintSingleURL( /*[in]*/ MPC::wstring& szUrl );	// print a single URL

		HRESULT HookUpEventSink();      // hook up our event sink
		HRESULT PreparePrintFileLoc();  // prepare our temporary print files
		HRESULT WaitForDocComplete();   // wait for Trident to load the page
		HRESULT DoPrint();              // send the print command to Trident
		HRESULT WaitForPrintComplete(); // wait for Trident to finish printing
		HRESULT UpdatePrintBuffer();    // load the print file data into our buffer
		HRESULT RawDataToPrinter();     // dump a raw stream of data to the printer

	public:
		Print();
		~Print();

		HRESULT Initialize( /*[in]*/ HWND hwnd );
		HRESULT Terminate (                    );

		HRESULT AddUrl( /*[in]*/ LPCWSTR szUrl );

		HRESULT PrintAll( /*[in]*/ Notification* pCallback );
	};
};

////////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CPCHPrintEngine : // Hungarian: hcppe
    public MPC::Thread             < CPCHPrintEngine, IPCHPrintEngine, COINIT_APARTMENTTHREADED                  >,
    public MPC::ConnectionPointImpl< CPCHPrintEngine, &DIID_DPCHPrintEngineEvents, MPC::CComSafeMultiThreadModel >,
    public IDispatchImpl           < IPCHPrintEngine, &IID_IPCHPrintEngine, &LIBID_HelpCenterTypeLib             >,
	public Printing::Print::Notification
{
	Printing::Print                      m_engine;

    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onProgress;
    MPC::CComPtrThreadNeutral<IDispatch> m_sink_onComplete;

    //////////////////////////////////////////////////////////////////////

    HRESULT Run();

    HRESULT CanModifyProperties();

    //////////////////////////////////////////////////////////////////////

    //
    // Event firing methods.
    //
    HRESULT Fire_onProgress( IPCHPrintEngine* hcppe, BSTR bstrURL, long lDone, long lTotal );
    HRESULT Fire_onComplete( IPCHPrintEngine* hcppe, HRESULT hrRes                         );

	//
	// Callbacks
	//
	HRESULT Progress( /*[in]*/ LPCWSTR szURL, /*[in]*/ int iDone, /*[in]*/ int iTotal );

    //////////////////////////////////////////////////////////////////////

public:
BEGIN_COM_MAP(CPCHPrintEngine)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPCHPrintEngine)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

    CPCHPrintEngine();

    void FinalRelease();

public:
    // IPCHPrintEngine
    STDMETHOD(put_onProgress)( /*[in] */ IDispatch* function );
    STDMETHOD(put_onComplete)( /*[in] */ IDispatch* function );


    STDMETHOD(AddTopic)( /*[in]*/ BSTR bstrURL );

    STDMETHOD(Start)();
    STDMETHOD(Abort)();
};

#endif // !defined(__INCLUDED___HCP___PRINTING_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\safintercomclient.h ===
// SAFIntercomClient.h : Declaration of the CSAFIntercomClient

#ifndef __SAFIntercomClient_H_
#define __SAFIntercomClient_H_

//JP:not in connectivitylib.h//#include "resource.h"       // main symbols

#include <MPC_COM.h>
#include <MPC_Utils.h>

#include <rtccore.h>

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomClient
class ATL_NO_VTABLE CSAFIntercomClient : // Hungarian safi
	public IDispatchImpl	       < ISAFIntercomClient, &IID_ISAFIntercomClient, &LIBID_HelpCenterTypeLib             >,
	public MPC::ConnectionPointImpl< CSAFIntercomClient, &DIID_DSAFIntercomClientEvents, MPC::CComSafeMultiThreadModel >,
	public IRTCEventNotification
{
private:

	CComPtr<IRTCClient>		m_pRTCClient;
	CComPtr<IRTCSession>	m_pRTCSession;

	DWORD					m_dwSinkCookie;
	
	BOOL					m_bOnCall;
	BOOL					m_bRTCInit;
	BOOL					m_bAdvised;

	int						m_iSamplingRate;

	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceConnected;
	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceDisconnected;
	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceDisabled;

	HRESULT Fire_onVoiceConnected	 (ISAFIntercomClient * safe);
	HRESULT Fire_onVoiceDisconnected (ISAFIntercomClient * safe);
	HRESULT Fire_onVoiceDisabled	 (ISAFIntercomClient * safe);

	// Worker functions
	HRESULT Init();
	HRESULT Cleanup();


public:

	

	CSAFIntercomClient();
	~CSAFIntercomClient();



//DECLARE_PROTECT_FINAL_CONSTRUCT()	// TODO: JP: Do we need this here?

BEGIN_COM_MAP(CSAFIntercomClient)
	COM_INTERFACE_ENTRY(ISAFIntercomClient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

// ISAFIntercomClient
public:

	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)(BSTR bstrIP, BSTR bstrKey);
	STDMETHOD(RunSetupWizard)();

	STDMETHOD(Exit)();

	STDMETHOD(put_onVoiceConnected)		(/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisconnected)  (/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisabled)	    (/* in */ IDispatch * function);

	STDMETHOD(put_SamplingRate)			(/* in */ LONG newVal);
	STDMETHOD(get_SamplingRate)			(/* out, retval */ LONG * pVal);


	// IRTCEventNotification
	STDMETHOD(Event)( RTC_EVENT RTCEvent, IDispatch * pEvent );
	STDMETHOD(OnSessionChange) (IRTCSession *pSession, 
							    RTC_SESSION_STATE nState, 
								HRESULT ResCode);


};

#endif //__SAFIntercomClient_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\include\safintercomserver.h ===
// SAFIntercomServer.h : Declaration of the CSAFIntercomServer

#ifndef __SAFIntercomServer_H_
#define __SAFIntercomServer_H_

//JP:not in connectivitylib.h//#include "resource.h"       // main symbols

#include <MPC_COM.h>
#include <MPC_Utils.h>

#include <rtccore.h>

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomServer
class ATL_NO_VTABLE CSAFIntercomServer : // Hungarian safi
	public IDispatchImpl	       < ISAFIntercomServer, &IID_ISAFIntercomServer, &LIBID_HelpCenterTypeLib             >,
	public MPC::ConnectionPointImpl< CSAFIntercomServer, &DIID_DSAFIntercomServerEvents, MPC::CComSafeMultiThreadModel >,
	public IRTCEventNotification
{


private:
	
	CComPtr<IRTCClient>			m_pRTCClient;
	CComPtr<IRTCSession>		m_pRTCSession;

	DWORD						m_dwSinkCookie;

	BOOL						m_bInit;
	BOOL						m_bRTCInit;
	BOOL						m_bAdvised;
	BOOL						m_bOnCall;

	CComBSTR					m_bstrKey;

	int							m_iSamplingRate;

	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceConnected;
	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceDisconnected;
	MPC::CComPtrThreadNeutral<IDispatch> m_sink_onVoiceDisabled;

	HRESULT Fire_onVoiceConnected	 (ISAFIntercomServer * safe);
	HRESULT Fire_onVoiceDisconnected (ISAFIntercomServer * safe);
	HRESULT Fire_onVoiceDisabled	 (ISAFIntercomServer * safe);
	
	// Worker functions
	HRESULT Init();
	HRESULT Cleanup();
	DWORD GenerateRandomString(DWORD dwSizeRandomSeed, BSTR *pBstr);
	DWORD GenerateRandomBytes(DWORD dwSize, LPBYTE pbBuffer);

public:

	CSAFIntercomServer();
	~CSAFIntercomServer();



//DECLARE_PROTECT_FINAL_CONSTRUCT()	// TODO: JP: Do we need this here?

BEGIN_COM_MAP(CSAFIntercomServer)
	COM_INTERFACE_ENTRY(ISAFIntercomServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

// ISAFIntercomServer
public:
	STDMETHOD(Listen)(/* out, retval */ BSTR * pVal);
	STDMETHOD(Disconnect)();

	STDMETHOD(RunSetupWizard)();
	STDMETHOD(Exit)();


	STDMETHOD(put_onVoiceConnected)		(/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisconnected)  (/* in */ IDispatch * function);
	STDMETHOD(put_onVoiceDisabled)	    (/* in */ IDispatch * function);

	STDMETHOD(put_SamplingRate)			(/* in */ LONG newVal);
	STDMETHOD(get_SamplingRate)			(/* out, retval */ LONG * pVal);

	// IRTCEventNotification
	STDMETHOD(Event)( RTC_EVENT RTCEvent, IDispatch * pEvent );
	STDMETHOD(OnSessionChange) (IRTCSession *pSession, 
							    RTC_SESSION_STATE nState, 
								HRESULT ResCode);
};

#endif //__SAFINTERCOMCLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\intercom\client\safintercomclient.cpp ===
// SAFIntercomClient.cpp : Implementation of CSAFIntercomClient
#include "stdafx.h"

// This is the PORT that we are using for the DPlayVoice connection
//#define SAFINTERCOM_PORT 4000

// *************************************************************
// This GUID is defined for the sake of DPlay8Peer!
// *************************************************************

// {4FE80EF4-AD10-45bd-B6EB-0B7BFB95155F}
static const GUID g_guidApplication = 
{ 0x4fe80ef4, 0xad10, 0x45bd, { 0xb6, 0xeb, 0xb, 0x7b, 0xfb, 0x95, 0x15, 0x5f } };

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomClient


//
// Constructor
//
CSAFIntercomClient::CSAFIntercomClient()
{
	m_dwSinkCookie	= 0x0;
	m_bOnCall		= FALSE;
	m_bAdvised		= FALSE;
	m_bRTCInit		= FALSE;

	m_iSamplingRate = 1;			// Initalize at the low bandwidth

}

//
//	Destructor
//
CSAFIntercomClient::~CSAFIntercomClient()
{
	DebugLog(L"CSAFIntercomClient Destructor!\r\n");

	Cleanup();
}

STDMETHODIMP CSAFIntercomClient::Event(RTC_EVENT RTCEvent, IDispatch * pEvent)
{
	HRESULT hr = S_OK;

	CComPtr<IRTCSessionStateChangeEvent>	pSessEvent;
	CComPtr<IRTCMediaEvent>					pMedEvent;
	CComPtr<IRTCSession>					pSession;


	// Session State Change Locals
    HRESULT             ResCode;
    RTC_SESSION_STATE   State;  
    
    switch(RTCEvent)
    {
    case RTCE_SESSION_STATE_CHANGE:

        hr = pEvent ->QueryInterface(IID_IRTCSessionStateChangeEvent, 
            (void **)&pSessEvent);

        if(FAILED(hr))
        {
			DebugLog(L"Could not get IID_IRTCSessionStateChangeEvent!\r\n");
            return hr;
        }
    
        pSessEvent->get_StatusCode(&ResCode);
        pSessEvent->get_State(&State);

        pSessEvent->get_Session(&pSession);

        hr = OnSessionChange(pSession, State, ResCode);

        pSessEvent.Release();
        if(pSession)
        {
            pSession.Release();
        }

        break;
/*
	case RTCE_MEDIA:

		hr = pEvent->QueryInterface(IID_IRTCMediaEvent, (void **)&pMedEvent);

		if (FAILED(hr))
		{
			DebugLog(L"Could not get IID_IRTCMediaEvent!\r\n");
			return hr;
		}

		hr = MediaEvent(pMedEvent);

		if (FAILED(hr))
		{
			pMedEvent.Release();
		}

		break;

	case RTCE_CLIENT:
		//TODO: Add code here for handling RTCCET_DEVICE_CHANGE (for wizard stuff)
		break;
*/
	}
  
	return hr;
}

/*
HRESULT CSAFIntercomClient::MediaEvent(IRTCMediaEvent * pMedEvent)
{
	HRESULT hr = S_OK;


	long						lMediaType;
	RTC_MEDIA_EVENT_TYPE		EventType;
	RTC_MEDIA_EVENT_REASON		EventReason;

	// Get all the values for this Event
	pMedEvent->get_MediaType(&lMediaType);
	pMedEvent->get_EventType(&EventType);
	pMedEvent->get_EventReason(&EventReason);

	// Make sure we are talking about audio
	if (!(
		  ( lMediaType & RTCMT_AUDIO_SEND    ) | // Send 
		  ( lMediaType & RTCMT_AUDIO_RECEIVE )
		 )
	   )
	{
		// Don't handle it since it's not an audio event
		return S_OK;
	}

	switch (EventType)
	{
	case RTCMET_STOPPED:

		// Check to see if we have stopped because of a timeout
		// SPECIAL CASE:  
		//      This is the case where we are in front of a firewall

		if (EventReason == RTCMER_TIMEOUT)
		{
			// Disable Voice 
			Fire_onVoiceDisabled(this);
		}

		break;
		
	case RTCMET_FAILED:

		// Disable voice, something happened to the connection
		// Special Case:
		//	    This COULD be the case where one person is GUEST
		Fire_onVoiceDisabled(this);

		break;

	}

	return hr;
}
*/

STDMETHODIMP CSAFIntercomClient::OnSessionChange(IRTCSession *pSession, 
												  RTC_SESSION_STATE nState, 
												  HRESULT ResCode)
{
    HRESULT hr = S_OK;
    int iRet;

	switch (nState)
    {
    case RTCSS_INCOMING:
	
		// Do nothing, a client cannot answer an incoming call

		return S_OK;

        break;

	case RTCSS_CONNECTED:

		Fire_onVoiceConnected(this);

		break;
    case RTCSS_DISCONNECTED:

		if (m_pRTCSession)
		{
			Fire_onVoiceDisconnected(this);
		}

		m_bOnCall = FALSE;

		if (m_pRTCSession)
		{
			m_pRTCSession.Release();
		}

		return S_OK;

		break;
    }

	return hr;
}

STDMETHODIMP CSAFIntercomClient::Connect(BSTR bstrIP, BSTR bstrKey)
{

	HRESULT hr;
	VARIANT_BOOL vbRun;
	long	flags;

	// Make sure we are not already in a call.  If we are on a call fail, with E_FAIL;
	if (m_bOnCall)
	{
		DebugLog(L"Cannot call Connect(...) while on a call\r\n");
		return E_FAIL;
	}

	// Initialize the Call
	if (FAILED(hr = Init()))
	{
		DebugLog(L"Call to Init() failed!\r\n");

		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Get media capabilities.  
	// Question: Do we have audio send and receive capabilities on this machine?
	if (FAILED( hr = m_pRTCClient->get_MediaCapabilities(&flags)))
	{
		DebugLog(L"Call to get_MediaCapabilities failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Check results
	if ( !(flags & ( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE )) )
	{
		DebugLog(L"This machine does not have audio capabilites, Voice is Disabled!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// If we have never run the Audio wizard, run it now
	if (FAILED( hr = m_pRTCClient->get_IsTuned(&vbRun)))
	{
		DebugLog(L"Call to IsTuned failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	if (VARIANT_FALSE == vbRun)
	{
		if (FAILED(hr = RunSetupWizard()))
		{
			DebugLog(L"Call to RunSetupWizard() failed!\r\n");
			return hr;
		}

	}

	// Since we have setup at this point, lets set the m_bOnCall variable
	// Reason: We have advised the RTCClient object and are listening for events.
	// NOTE: If we fail out at this point(or beyond), we need to set this bool back to FALSE
	m_bOnCall = TRUE;

	// Make the call
	if (FAILED( hr = m_pRTCClient->CreateSession( RTCST_PC_TO_PC,
												  NULL,
												  NULL,
												  0,
												  &m_pRTCSession)))
	{
		DebugLog(L"CreateSession off of the RTCClient object failed!\r\n");

		m_bOnCall = FALSE;
		Fire_onVoiceDisabled(this);

		return hr;
	}

	// Set the key on the Client Side
	if (FAILED( hr = m_pRTCSession->put_EncryptionKey(RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE,
														bstrKey)))
	{
		DebugLog(L"put_EncryptionKey failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Call the server
	if (FAILED( hr = m_pRTCSession->AddParticipant( bstrIP, 
													L"",
													NULL)))
	{
		DebugLog(L"AddParticipant on RTCSession object failed!\r\n");

		m_bOnCall = FALSE;
		Fire_onVoiceDisabled(this);
		return hr;
	}

	return S_OK;
}

STDMETHODIMP CSAFIntercomClient::Disconnect()
{

	// TODO: make sure we handle the case where we are shutting down.  
	// Find out if we care about RTCSHUTDOWN

	HRESULT hr;

	if (!m_bOnCall)
	{
		DebugLog(L"Must be on a call to call Disconnect!\r\n");

		return E_FAIL;
	}

	if (m_pRTCSession)
	{
		if (FAILED( hr = m_pRTCSession->Terminate(RTCTR_NORMAL)))
		{
			DebugLog(L"Terminate off of the Session object failed!\r\n");

			return hr;
		}

		m_pRTCSession.Release();
	}

	return S_OK;
}

//
// This method is used to Unadvise the RTCClient object of us (CSAFIntercomClient)
//
STDMETHODIMP CSAFIntercomClient::Exit()
{

	HRESULT hr;

	DebugLog(L"Inside CSAFIntercomClient::Exit()\r\n");

	// Unadvise IRTCClient of the sink
	if (m_bAdvised)
	{
		AtlUnadvise((IUnknown *)m_pRTCClient, IID_IRTCEventNotification, m_dwSinkCookie);
	}


	return S_OK;
}


HRESULT CSAFIntercomClient::RunSetupWizard()
{
	HRESULT hr = S_OK;
	long flags;

	// Setup
	if (FAILED(hr = Init()))
	{
		DebugLog(L"Call to Init() failed!\r\n");

		Fire_onVoiceDisabled(this);
		return hr;
	}

	if (FAILED(hr = m_pRTCClient->InvokeTuningWizard(NULL)))
	{
		DebugLog(L"InvokeTuningWizard FAILED!\r\n");		
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Get media capabilities.  If the wizard failed to detect sound we can 
	// disable Voice

	if (FAILED( hr = m_pRTCClient->get_MediaCapabilities(&flags)))
	{
		DebugLog(L"Call to get_MediaCapabilities failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Check results
	if ( !(flags & ( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE )) )
	{
		DebugLog(L"This machine does not have audio capabilites, Voice is Disabled!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	return S_OK;
}

HRESULT CSAFIntercomClient::Cleanup()
{
	HRESULT hr = S_OK;

	// Shutdown if needed
	if (m_bRTCInit)
	{
		m_pRTCClient->Shutdown();
	}

	// Now release all the interfaces we used
	if (m_pRTCSession)
	{
		m_pRTCSession.Release();
	}

	if (m_pRTCClient)
	{
		m_pRTCClient.Release();
	}


	return hr;
}

HRESULT CSAFIntercomClient::Init()
{
	HRESULT hr = S_OK;

	CComPtr<IUnknown> pUnkThis;

	// Once we have initialized, do nothing
	if (!m_pRTCClient)
	{
		DWORD dwProfileFlags;

		// Check to see if we have a temporary profile
		if(GetProfileType( &dwProfileFlags ))
		{
			if (dwProfileFlags & PT_TEMPORARY)
			{
				return E_FAIL;
			}
		}

		// Create the RTCClient object
		if (FAILED(hr = m_pRTCClient.CoCreateInstance(CLSID_RTCClient)))
		{
			DebugLog(L"Could not create the RTCClient object\r\n");
			return hr;
		}
		
		if (!m_bRTCInit)
		{
			if (FAILED(hr = m_pRTCClient->Initialize()))
			{
				DebugLog(L"Call to Initialize on the RTCClient object failed!\r\n");
				return hr;
			}
			
			// Set the sampling bit rate (it may be different because of changes in the property)
			if (m_iSamplingRate == 1)
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(6400)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
			else
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(64000)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
			
			// Since we have Initialized the RTCClient, enable the flag
			m_bRTCInit = TRUE;
			
			
			if (FAILED(hr = m_pRTCClient->SetPreferredMediaTypes( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE,
				FALSE )))
			{
				DebugLog(L"Call to SetPreferredMediaType failed!\r\n");
				
				return hr;
			}
		}	
		
		// Get the IUnknown of the 'this' ptr
		if (FAILED( hr = this->QueryInterface(IID_IUnknown, (void **)&pUnkThis)))
		{
			DebugLog(L"QueryInterface for IUnknown failed!\r\n");
			
			return hr;
		}
		
		if (!m_bAdvised)
		{
			// Advise IRTCClient of the sink
			if (FAILED( hr = m_pRTCClient.Advise( pUnkThis, IID_IRTCEventNotification, &m_dwSinkCookie)))
			{
				DebugLog(L"AtlAdvise failed!\r\n");
				
				return hr;
			}
			
			m_bAdvised = TRUE;
			
			
			// TODO: Verify about RTCLM_BOTH
			if (FAILED( hr = m_pRTCClient->put_ListenForIncomingSessions(RTCLM_BOTH)))
			{
				DebugLog(L"Set ListenForIncomingSessions property failed!\r\n");
				
				return hr;
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CSAFIntercomClient::Fire_onVoiceConnected( ISAFIntercomClient * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INCE__ONDISCONNECTED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceConnected );
}

HRESULT CSAFIntercomClient::Fire_onVoiceDisconnected( ISAFIntercomClient * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INCE__ONDISCONNECTED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceDisconnected );
}

HRESULT CSAFIntercomClient::Fire_onVoiceDisabled( ISAFIntercomClient * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INCE__ONVOICEDISABLED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceDisabled );

}
//////////////////////////
//                      //
// Properties		    //
//                      //
//////////////////////////

STDMETHODIMP CSAFIntercomClient::put_onVoiceConnected( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomClient::put_onVoiceConnected",hr);

    m_sink_onVoiceConnected = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomClient::put_onVoiceDisconnected( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomClient::put_onVoiceDisconnected",hr);

    m_sink_onVoiceDisconnected = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomClient::put_onVoiceDisabled( /*[in]*/ IDispatch* function)
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomClient::put_onVoiceDisconnected",hr);

    m_sink_onVoiceDisabled = function;

    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CSAFIntercomClient::put_SamplingRate ( /*[in]*/ LONG newVal)
{
	__HCP_BEGIN_PROPERTY_PUT("CSAFIntercomServer::put_SamplingRate", hr);
	
	hr = S_OK;

	// Make sure that the newVal is correct
	if ((newVal == 1) || (newVal == 2))
	{
		// If m_pRTCClient doesn't exist then persist the m_iSamplingRate for when it is created
		m_iSamplingRate = newVal;

		if (m_pRTCClient)
		{
			// Set the MaxBitRates on the client, because it exists (m_pRTCClient)
			if (m_iSamplingRate == 1)
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(6400)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
			else
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(64000)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
		}
		
	}
	else
	{
		hr = E_INVALIDARG;
	}

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomClient::get_SamplingRate (/*[out, retval]*/ LONG * pVal  )
{
	__HCP_BEGIN_PROPERTY_GET("CSAFIntercomServer::put_SamplingRate", hr, pVal);

	*pVal = m_iSamplingRate;

	hr = S_OK;

	__HCP_END_PROPERTY(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void DebugLog(WCHAR * str, ...)
{
	WCHAR newstr[200];

	va_list marker;

	va_start(marker, str);
	wsprintf(newstr, str, marker);
	va_end(marker);

	OutputDebugString(newstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\intercom\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__SAFINTERCOMSERVER)
#define AFX_STDAFX_H__SAFINTERCOMSERVER

#include <module.h>


//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//////

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <userenv.h>

//JP://#include <Debug.h>

//////

#include <HelpCenter.h>
#include <HelpCenterExternal.h>

// To define GUIDS
#include <initguid.h>

#include <SAFIntercomServer.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__SAFINTERCOMSERVER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\events.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    Events.cpp

Abstract:
    This file contains the implementation of the classes related to events.

Revision History:
    Davide Massarenti   (dmassare) 10/31/99
        created

******************************************************************************/

#include "stdafx.h"

#include <mshtmdid.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

static void DEBUG_CheckReadyState()
{
    CComPtr<IWebBrowser2> wb2; wb2.Attach( CPCHHelpCenterExternal::s_GLOBAL->Contents() );
    tagREADYSTATE         ready;


    if(wb2 && SUCCEEDED(wb2->get_ReadyState( &ready )))
    {
        DebugLog( "#################### WEB %d\n", (int)ready );
    }
}

static HRESULT DEBUG_GetReadyStateFromBrowser( IDispatch*     pDisp ,
                                               tagREADYSTATE *pVal  )
{
    __HCP_FUNC_ENTRY( "DEBUG_GetReadyStateFromBrowser" );

    HRESULT               hr;
    CComPtr<IWebBrowser2> wb;


    *pVal = READYSTATE_UNINITIALIZED;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pDisp->QueryInterface( IID_IWebBrowser2, (LPVOID*)&wb   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, wb   ->get_ReadyState(                             pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT DEBUG_GetLocationFromBrowser( IDispatch*  pDisp ,
                                             BSTR       *pVal  )
{
    __HCP_FUNC_ENTRY( "DEBUG_GetLocationFromBrowser" );

    HRESULT               hr;
    CComPtr<IWebBrowser2> wb;


    *pVal = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, pDisp->QueryInterface ( IID_IWebBrowser2, (LPVOID*)&wb   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, wb   ->get_LocationURL(                             pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT DEBUG_GetLocationFromDocument2( IHTMLDocument2*  pDoc ,
                                         BSTR            *pVal )
{
    __HCP_FUNC_ENTRY( "DEBUG_GetLocationFromDocument2" );

    HRESULT                hr;
    CComPtr<IHTMLLocation> pLoc;


    *pVal = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, pDoc->get_location( &pLoc )); if(pLoc == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    __MPC_EXIT_IF_METHOD_FAILS(hr, pLoc->get_href    (  pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#else

inline void    DEBUG_CheckReadyState         () {}
inline HRESULT DEBUG_GetReadyStateFromBrowser() { return S_OK; }
inline HRESULT DEBUG_GetLocationFromBrowser  () { return S_OK; }
inline HRESULT DEBUG_GetLocationFromDocument2() { return S_OK; }

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static WCHAR s_eventNames_onBeforeNavigate     [] = L"onBeforeNavigate"     ;
static WCHAR s_eventNames_onNavigateComplete   [] = L"onNavigateComplete"   ;

static WCHAR s_eventNames_onBeforeTransition   [] = L"onBeforeTransition"   ;
static WCHAR s_eventNames_onTransition         [] = L"onTransition"         ;

static WCHAR s_eventNames_onBeforeContextSwitch[] = L"onBeforeContextSwitch";
static WCHAR s_eventNames_onContextSwitch      [] = L"onContextSwitch"      ;

static WCHAR s_eventNames_onPersistLoad        [] = L"onPersistLoad"        ;
static WCHAR s_eventNames_onPersistSave        [] = L"onPersistSave"        ;
static WCHAR s_eventNames_onTravelDone         [] = L"onTravelDone"         ;

static WCHAR s_eventNames_onShutdown           [] = L"onShutdown"           ;
static WCHAR s_eventNames_onPrint              [] = L"onPrint"              ;

static WCHAR s_eventNames_onSwitchedHelpFiles  [] = L"onSwitchedHelpFiles"  ;
static WCHAR s_eventNames_onFavoritesUpdate    [] = L"onFavoritesUpdate"    ;
static WCHAR s_eventNames_onOptionsChanged     [] = L"onOptionsChanged"     ;
static WCHAR s_eventNames_onCssChanged         [] = L"onCssChanged"         ;

static struct
{
    LPCWSTR szName;
    DISPID  id;
}
s_lookup[] =
{
    { s_eventNames_onBeforeNavigate     , DISPID_PCH_E_BEFORENAVIGATE      },
    { s_eventNames_onNavigateComplete   , DISPID_PCH_E_NAVIGATECOMPLETE    },

    { s_eventNames_onBeforeTransition   , DISPID_PCH_E_BEFORETRANSITION    },
    { s_eventNames_onTransition         , DISPID_PCH_E_TRANSITION          },

    { s_eventNames_onBeforeContextSwitch, DISPID_PCH_E_BEFORECONTEXTSWITCH },
    { s_eventNames_onContextSwitch      , DISPID_PCH_E_CONTEXTSWITCH       },

    { s_eventNames_onPersistLoad        , DISPID_PCH_E_PERSISTLOAD         },
    { s_eventNames_onPersistSave        , DISPID_PCH_E_PERSISTSAVE         },
    { s_eventNames_onTravelDone         , DISPID_PCH_E_TRAVELDONE          },

    { s_eventNames_onShutdown           , DISPID_PCH_E_SHUTDOWN            },
    { s_eventNames_onPrint              , DISPID_PCH_E_PRINT               },

    { s_eventNames_onSwitchedHelpFiles  , DISPID_PCH_E_SWITCHEDHELPFILES   },
    { s_eventNames_onFavoritesUpdate    , DISPID_PCH_E_FAVORITESUPDATE     },
    { s_eventNames_onOptionsChanged     , DISPID_PCH_E_OPTIONSCHANGED      },
    { s_eventNames_onCssChanged         , DISPID_PCH_E_CSSCHANGED          },
};

/////////////////////////////////////////////////////////////////////////////

bool CPCHEvents::EventRegistration::operator==( /*[in]*/ const long lCookie   ) const { return m_lCookie   == lCookie  ; }
bool CPCHEvents::EventRegistration::operator< ( /*[in]*/ const long lPriority ) const { return m_lPriority  < lPriority; }

CPCHEvents::CPCHEvents()
{
    m_parent      = NULL; // CPCHHelpCenterExternal* m_parent;
                          // List                    m_lstEvents;
                          // List                    m_lstEvents_Staging;
    m_lLastCookie = 0;    // long                    m_lLastCookie;
}

CPCHEvents::~CPCHEvents()
{
    Passivate();
}

void CPCHEvents::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
    m_parent = parent;
}

void CPCHEvents::Passivate()
{
    //
    // We don't remove the item from the main list, only FireEvent is allowed to change that list!
    //
    for(Iter it=m_lstEvents.begin(); it!=m_lstEvents.end(); it++)
    {
        it->m_fnCallback.Release();
    }

    m_lstEvents_Staging.clear();

    m_parent = NULL;
}

////////////////////

HRESULT CPCHEvents::RegisterEvents( /*[in]*/         long        id       ,
                                    /*[in]*/         long        pri      ,
                                    /*[in]*/         IDispatch*  function ,
                                    /*[out,retval]*/ long       *cookie   )
{
    __HCP_FUNC_ENTRY( "CPCHEvents::RegisterEvents" );

    HRESULT hr;
    Iter    it;


    if(id != -1) // Special case, used only internally, to pass the ID of the event through the Invoke method call.
    {
        if(CPCHEvents::ReverseLookup( id ) == NULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }
    }


    it = m_lstEvents_Staging.insert( m_lstEvents_Staging.end() ); // This line creates a new item!!

    it->m_lCookie    = ++m_lLastCookie; // long                                 m_lCookie;
    it->m_id         = id;              // DISPID                               m_id;
    it->m_lPriority  = pri;             // long                                 m_lPriority;
    it->m_fnCallback = function;        // MPC::CComPtrThreadNeutral<IDispatch> m_fnCallback;

    if(cookie) *cookie = it->m_lCookie;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::RegisterEvents( /*[in]*/         BSTR        bstrID   ,
                                    /*[in]*/         long        pri      ,
                                    /*[in]*/         IDispatch*  function ,
                                    /*[out,retval]*/ long       *cookie   )
{
    return RegisterEvents( bstrID ? CPCHEvents::Lookup( bstrID ) : -1, pri, function, cookie );
}

HRESULT CPCHEvents::UnregisterEvents( /*[in]*/ long cookie )
{
    __HCP_FUNC_ENTRY( "CPCHEvents::UnregisterEvents" );

    HRESULT hr;
    Iter    it;


    //
    // We don't remove the item from the main list, only FireEvent is allowed to change that list!
    //
    it = std::find( m_lstEvents.begin(), m_lstEvents.end(), cookie );
    if(it != m_lstEvents.end())
    {
        it->m_fnCallback.Release();
    }


    it = std::find( m_lstEvents_Staging.begin(), m_lstEvents_Staging.end(), cookie );
    if(it != m_lstEvents_Staging.end())
    {
        m_lstEvents_Staging.erase( it );
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHEvents::FireEvent( /*[in]*/ CPCHEvent* eventObj )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::FireEvent" );

    HRESULT hr;

    if(m_parent)
    {
        Iter             it;
        Iter             itStaging;
        DISPID           id     = eventObj->m_idAction;
        CComVariant      vEvent = eventObj;
        CPCHHelpSession* hs     = m_parent->HelpSession();


        eventObj->m_hsiCurrentContext  = hs->Current();
        if(eventObj->m_hsiCurrentContext)
        {
            eventObj->m_hsiPreviousContext = eventObj->m_hsiCurrentContext->Previous();
        }

        DEBUG_AppendPerf( DEBUG_PERF_EVENTS_OUT, L"CPCHHelpCenterExternal::FireEvent: %s - URL: %s - Frame: %s - Panel: %s",
                          CPCHEvents::ReverseLookup( id ),
                          SAFEBSTR( eventObj->m_bstrURL   ),
                          SAFEBSTR( eventObj->m_bstrFrame ),
                          SAFEBSTR( eventObj->m_bstrPanel ) );

        DebugLog( L"%%%%%%%%%%%%%%%%%%%% EVENT %s - URL: %s - Frame: %s - Panel: %s\n",
                  CPCHEvents::ReverseLookup( id ),
                  SAFEBSTR( eventObj->m_bstrURL   ),
                  SAFEBSTR( eventObj->m_bstrFrame ),
                  SAFEBSTR( eventObj->m_bstrPanel ) );


        //
        // Merge staging list into main list.
        //
        for(itStaging=m_lstEvents_Staging.begin(); itStaging!=m_lstEvents_Staging.end(); itStaging++)
        {
            //
            // Insert in priority order.
            //
            for(it=m_lstEvents.begin(); it!=m_lstEvents.end(); it++)
            {
                if(*it < itStaging->m_lPriority) break;
            }

            m_lstEvents.insert( it, *itStaging );
        }
        m_lstEvents_Staging.clear();


        //
        // Dispatch the event to all the sinks registered for it.
        //
        for(it=m_lstEvents.begin(); it!=m_lstEvents.end(); )
        {
            if(it->m_id == -1 || // Listen to all the events...
               it->m_id == id  )
            {
                CComPtr<IDispatch> pPtr  = it->m_fnCallback;
                CComDispatchDriver pDisp = pPtr;

                if(pDisp)
                {
                    if(SUCCEEDED(pDisp.Invoke1( it->m_id == -1 ? id : (DISPID)0, &vEvent )))
                    {
                        VARIANT_BOOL fCancel;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, eventObj->get_Cancel( &fCancel ));

                        if(fCancel == VARIANT_TRUE) break;
                    }
                    else
                    {
                        //
                        // The script is no more valid, prepare to release it.
                        //
                        it->m_fnCallback.Release();
                    }
                }
            }

			if(!m_parent) break; // We have been passivated...

            if(!it->m_fnCallback)
            {
                m_lstEvents.erase( it++ );
            }
            else
            {
                it++;
            }
        }
    }

	if(!m_parent) // We have been passivated...
	{
		m_lstEvents        .clear();
		m_lstEvents_Staging.clear();
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHEvents::FireEvent_Generic( /*[in]*/  DISPID        id     ,
                                       /*[out]*/ VARIANT_BOOL *Cancel )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::FireEvent_Generic" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction = id;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    if(Cancel) *Cancel = obj->m_fCancel;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHEvents::FireEvent_BeforeNavigate( /*[in]*/  BSTR          bstrURL   ,
                                              /*[in]*/  BSTR          bstrFrame ,
                                              /*[in]*/  HscPanel      idPanel   ,
                                              /*[out]*/ VARIANT_BOOL *Cancel    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::FireEvent_BeforeNavigate" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction  = DISPID_PCH_E_BEFORENAVIGATE;
    obj->m_bstrURL   = bstrURL;
    obj->m_bstrFrame = bstrFrame;
    obj->m_bstrPanel = m_parent->PanelName( idPanel );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    if(Cancel) *Cancel = obj->m_fCancel;

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::FireEvent_NavigateComplete( /*[in]*/  BSTR          bstrURL ,
                                                /*[in]*/  HscPanel      idPanel ,
                                                /*[out]*/ VARIANT_BOOL *Cancel  )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::FireEvent_NavigateComplete" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction  = DISPID_PCH_E_NAVIGATECOMPLETE;
    obj->m_bstrURL   = bstrURL;
    obj->m_bstrPanel = m_parent->PanelName( idPanel );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    if(Cancel) *Cancel = obj->m_fCancel;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::FireEvent_BeforeTransition( /*[in]*/  BSTR          bstrPlace ,
                                                /*[out]*/ VARIANT_BOOL *Cancel    )
{
    __HCP_FUNC_ENTRY( "CPCHEvents::FireEvent_BeforeTransition" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction  = DISPID_PCH_E_BEFORETRANSITION;
    obj->m_bstrPlace = bstrPlace;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    if(Cancel) *Cancel = obj->m_fCancel;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::FireEvent_Transition( /*[in]*/ BSTR bstrPlace )
{
    __HCP_FUNC_ENTRY( "CPCHEvents::FireEvent_Transition" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction  = DISPID_PCH_E_TRANSITION;
    obj->m_bstrPlace = bstrPlace;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::FireEvent_BeforeContextSwitch( /*[in ]*/ HscContext    iVal     ,
                                                   /*[in ]*/ BSTR          bstrInfo ,
                                                   /*[in ]*/ BSTR          bstrURL  ,
                                                   /*[out]*/ VARIANT_BOOL *Cancel   )
{
    __HCP_FUNC_ENTRY( "CPCHEvents::FireEvent_BeforeContextSwitch" );

    HRESULT            hr;
    CComPtr<CPCHEvent> obj;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &obj ));


    obj->m_idAction = DISPID_PCH_E_BEFORECONTEXTSWITCH;
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->HelpSession()->RegisterContextSwitch( iVal, bstrInfo, bstrURL, &obj->m_hsiNextContext ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent( obj ));

    if(Cancel) *Cancel = obj->m_fCancel;

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHEvents::FireEvent_ContextSwitch    (                      ) { return FireEvent_Generic( DISPID_PCH_E_CONTEXTSWITCH             ); }
HRESULT CPCHEvents::FireEvent_PersistLoad      (                      ) { return FireEvent_Generic( DISPID_PCH_E_PERSISTLOAD               ); }
HRESULT CPCHEvents::FireEvent_PersistSave      (                      ) { return FireEvent_Generic( DISPID_PCH_E_PERSISTSAVE               ); }
HRESULT CPCHEvents::FireEvent_TravelDone       (                      ) { return FireEvent_Generic( DISPID_PCH_E_TRAVELDONE                ); }
HRESULT CPCHEvents::FireEvent_Shutdown         ( VARIANT_BOOL *Cancel ) { return FireEvent_Generic( DISPID_PCH_E_SHUTDOWN         , Cancel ); }
HRESULT CPCHEvents::FireEvent_Print            ( VARIANT_BOOL *Cancel ) { return FireEvent_Generic( DISPID_PCH_E_PRINT            , Cancel ); }

HRESULT CPCHEvents::FireEvent_SwitchedHelpFiles(                      ) { return FireEvent_Generic( DISPID_PCH_E_SWITCHEDHELPFILES         ); }
HRESULT CPCHEvents::FireEvent_FavoritesUpdate  (                      ) { return FireEvent_Generic( DISPID_PCH_E_FAVORITESUPDATE           ); }
HRESULT CPCHEvents::FireEvent_OptionsChanged   (                      ) { return FireEvent_Generic( DISPID_PCH_E_OPTIONSCHANGED            ); }
HRESULT CPCHEvents::FireEvent_CssChanged       (                      ) { return FireEvent_Generic( DISPID_PCH_E_CSSCHANGED                ); }


DISPID CPCHEvents::Lookup( LPCWSTR szName )
{
    if(szName)
    {
        for(int i = 0; i<ARRAYSIZE(s_lookup); i++)
        {
            if(!_wcsicmp( s_lookup[i].szName, szName )) return s_lookup[i].id;
        }
    }

    return 0;
}

LPCWSTR CPCHEvents::ReverseLookup( DISPID idEvent )
{
    for(int i = 0; i<ARRAYSIZE(s_lookup); i++)
    {
        if(s_lookup[i].id == idEvent) return s_lookup[i].szName;
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHEvent::CPCHEvent()
{
                               // DISPID                       m_idAction;
    m_fCancel = VARIANT_FALSE; // VARIANT_BOOL                 m_fCancel;
                               //
                               // CComBSTR                     m_bstrURL;
                               // CComBSTR                     m_bstrFrame;
                               // CComBSTR                     m_bstrPanel;
                               // CComBSTR                     m_bstrPlace;
                               // CComBSTR                     m_bstrContextData;
                               //
                               // CComPtr<CPCHHelpSessionItem> m_hsiCurrentContext;
                               // CComPtr<CPCHHelpSessionItem> m_hsiPreviousContext;
}

CPCHEvent::~CPCHEvent()
{
}

////////////////////////////////////////

STDMETHODIMP CPCHEvent::get_Action( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( CPCHEvents::ReverseLookup( m_idAction ), pVal );
}

////////////////////

STDMETHODIMP CPCHEvent::put_Cancel( /*[in]*/ VARIANT_BOOL newVal )
{
    m_fCancel = newVal;

    return S_OK;
}

STDMETHODIMP CPCHEvent::get_Cancel( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    if(pVal == NULL) return E_POINTER;

    *pVal = m_fCancel;

    return S_OK;
}

////////////////////

HRESULT CPCHEvent::put_URL( /*[in]*/ BSTR newVal )
{
    return MPC::PutBSTR( m_bstrURL, newVal );
}

STDMETHODIMP CPCHEvent::get_URL( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrURL, pVal );
}

////////////////////

HRESULT CPCHEvent::put_Frame( /*[in]*/ BSTR newVal )
{
    return MPC::PutBSTR( m_bstrFrame, newVal );
}

STDMETHODIMP CPCHEvent::get_Frame( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrFrame, pVal );
}

////////////////////

HRESULT CPCHEvent::put_Panel( /*[in]*/ BSTR newVal )
{
    return MPC::PutBSTR( m_bstrPanel, newVal );
}

STDMETHODIMP CPCHEvent::get_Panel( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrPanel, pVal );
}

////////////////////

HRESULT CPCHEvent::put_Place( /*[in]*/ BSTR newVal )
{
    return MPC::PutBSTR( m_bstrPlace, newVal );
}

STDMETHODIMP CPCHEvent::get_Place( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrPlace, pVal );
}

////////////////////

STDMETHODIMP CPCHEvent::get_CurrentContext( /*[out, retval]*/ IPCHHelpSessionItem* *pVal )
{
    return MPC::CopyTo( (CPCHHelpSessionItem*)m_hsiCurrentContext, pVal );
}

STDMETHODIMP CPCHEvent::get_PreviousContext( /*[out, retval]*/ IPCHHelpSessionItem* *pVal )
{
    return MPC::CopyTo( (CPCHHelpSessionItem*)m_hsiPreviousContext, pVal );
}

STDMETHODIMP CPCHEvent::get_NextContext( /*[out, retval]*/ IPCHHelpSessionItem* *pVal )
{
    return MPC::CopyTo( (CPCHHelpSessionItem*)m_hsiNextContext, pVal );
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHTimerHandle::CallbackBase::CallbackBase()
{
    m_lRef = 1; // long m_lRef;
}

STDMETHODIMP_(ULONG) CPCHTimerHandle::CallbackBase::AddRef()
{
    return ::InterlockedIncrement( &m_lRef );
}

STDMETHODIMP_(ULONG) CPCHTimerHandle::CallbackBase::Release()
{
    ULONG l =  ::InterlockedDecrement( &m_lRef );

    if(l == 0) delete this;

    return l;
}

STDMETHODIMP CPCHTimerHandle::CallbackBase::QueryInterface( REFIID iid, void ** ppvObject )
{
    if(ppvObject == NULL) return E_POINTER;

    if(InlineIsEqualUnknown( iid                 ) ||
       InlineIsEqualGUID   ( iid, IID_ITimerSink )  )
    {
        *ppvObject = this; AddRef();
        return S_OK;
    }

    *ppvObject = NULL;

    return E_NOINTERFACE;
}

////////////////////////////////////////

CPCHTimerHandle::CPCHTimerHandle()
{
                       // CComPtr<ITimer> m_timer;
    m_dwCookie = 0;    // DWORD           m_dwCookie;
    m_callback = NULL; // CallbackBase*   m_callback;
}

CPCHTimerHandle::~CPCHTimerHandle()
{
    Unadvise();
}

void CPCHTimerHandle::Initialize( /*[in]*/ ITimer* timer )
{
    Unadvise();

    m_timer = timer;
}

HRESULT CPCHTimerHandle::Advise( /*[in]*/ CallbackBase* callback, /*[in]*/ DWORD dwWait )
{
    if(!callback) return E_OUTOFMEMORY;

    Unadvise();

    m_callback = callback;

    if(!m_timer) return E_INVALIDARG;

    CComVariant vTime = (long)(dwWait + ::GetTickCount());
    CComVariant vZero =        0;

    return m_timer->Advise( vTime, vZero, vZero, 0, callback, &m_dwCookie );
}

void CPCHTimerHandle::Unadvise()
{
    if(m_timer)
    {
        if(m_dwCookie)
        {
            m_timer->Unadvise( m_dwCookie );

            m_dwCookie = 0;
        }
    }

    if(m_callback)
    {
        m_callback->Detach ();
        m_callback->Release();

        m_callback = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

CPCHWebBrowserEvents::CPCHWebBrowserEvents()
{
    __HCP_FUNC_ENTRY( "CPCHWebBrowserEvents::CPCHWebBrowserEvents" );

    m_parent   = NULL;             // CPCHHelpCenterExternal* m_parent;
    m_idPanel  = HSCPANEL_INVALID; // HscPanel                m_idPanel;
                                   //
                                   // CComPtr<IWebBrowser2>   m_pWB2;
    m_fLoading = false;            // bool                    m_fLoading;
                                   //
                                   // CPCHTimerHandle         m_TimerDelay;
                                   // CPCHTimerHandle         m_TimerExpire;
}

CPCHWebBrowserEvents::~CPCHWebBrowserEvents()
{
    Passivate();
}

////////////////////////////////////////////////////////////////////////////////

void CPCHWebBrowserEvents::NotifyStartOfNavigation( /*[in]*/ BSTR url )
{
    CPCHHelpSession* hs = m_parent->HelpSession();

    if(hs)
    {
        m_fLoading = true;

        (void)hs->StartNavigation( url, m_idPanel );
    }
}

void CPCHWebBrowserEvents::NotifyEndOfNavigation()
{
    CPCHHelpSession* hs = m_parent->HelpSession();

    m_fLoading = false;

    if(hs)
    {
        (void)hs->CompleteNavigation( m_idPanel );
    }
}

void CPCHWebBrowserEvents::NotifyStop()
{
    TimerControl( TIMERMODE_STOP );
}

////////////////////////////////////////////////////////////////////////////////

void CPCHWebBrowserEvents::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ HscPanel idPanel )
{
    m_parent  = parent;
    m_idPanel = idPanel;
}

void CPCHWebBrowserEvents::Passivate()
{
    Detach();

    m_parent = NULL;
}

void CPCHWebBrowserEvents::Attach( /*[in]*/ IWebBrowser2* pWB )
{
    __HCP_FUNC_ENTRY( "CPCHWebBrowserEvents::Attach" );


    Detach();


    m_pWB2 = pWB;
    if(m_pWB2)
    {
        CPCHWebBrowserEvents_DWebBrowserEvents2::DispEventAdvise( m_pWB2 );
    }

    m_TimerDelay .Initialize( m_parent->Timer() );
    m_TimerExpire.Initialize( m_parent->Timer() );
}

void CPCHWebBrowserEvents::Detach()
{
    __HCP_FUNC_ENTRY( "CPCHWebBrowserEvents::Detach" );

    TimerControl( TIMERMODE_STOP );

    if(m_pWB2)
    {
        CPCHWebBrowserEvents_DWebBrowserEvents2::DispEventUnadvise( m_pWB2 );

        m_pWB2.Release();
    }
}

/////////////////////////////////////////////////////////////////////////////

void CPCHWebBrowserEvents::TimerControl( /*[in]*/ TimerMode mode )
{
    switch(mode)
    {
    case TIMERMODE_STOP:
        m_TimerDelay .Stop();
        m_TimerExpire.Stop();
        break;

    case TIMERMODE_RESTART:
        m_TimerDelay .Stop (                                                                 );
        m_TimerExpire.Start( this, (HRESULT (CPCHWebBrowserEvents::*)(VARIANT))OnTimer, 2000 );
        break;

    case TIMERMODE_MORETIME:
        m_TimerExpire.Start( this, (HRESULT (CPCHWebBrowserEvents::*)(VARIANT))OnTimer, 100 );
        break;

    case TIMERMODE_COMPLETE:
        m_TimerDelay .Start( this, (HRESULT (CPCHWebBrowserEvents::*)(VARIANT))OnTimer, 20 );
        m_TimerExpire.Stop (                                                               );
        break;
    }
}

HRESULT CPCHWebBrowserEvents::OnTimer( VARIANT vtimeAdvise )
{
    TimerControl( TIMERMODE_STOP );

    NotifyEndOfNavigation();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

void __stdcall CPCHWebBrowserEvents::BeforeNavigate2( IDispatch*    pDisp          ,
                                                      VARIANT*      URL            ,
                                                      VARIANT*      Flags          ,
                                                      VARIANT*      TargetFrameName,
                                                      VARIANT*      PostData       ,
                                                      VARIANT*      Headers        ,
                                                      VARIANT_BOOL *Cancel         )
{
    if(!m_parent) return; // Called before init or after passivate.

#ifdef DEBUG
    DebugLog( L"#################### BeforeNavigate2 %s %08x %s\n", m_parent->PanelName( m_idPanel ), pDisp, SAFEBSTR( V_BSTR( URL ) ) );
    DEBUG_CheckReadyState();
#endif

    DEBUG_AppendPerf( DEBUG_PERF_EVENTS_IN, L"CPCHWebBrowserEvents::BeforeNavigate2 : %s", SAFEBSTR( V_BSTR( URL ) ) );

    CComBSTR bstrFrame;
    BSTR     bstrURL = V_BSTR( URL );


    if(FAILED(MPC::HTML::GetFramePath( bstrFrame, pDisp )) || !bstrFrame)
    {
        if(V_VT(TargetFrameName) == VT_BSTR)
        {
            bstrFrame = V_BSTR(TargetFrameName);
        }
    }

    {
        bool fProceed = m_parent->ProcessNavigation( m_idPanel, bstrURL, bstrFrame, m_fLoading, *Cancel );
		DebugLog( L"#################### ProcessNavigation %s%s%s\n", m_fLoading ? L"loading " : L"", fProceed ? L"proceed " : L"", *Cancel ? L"cancelled " : L"" );
        if(fProceed)
        {
            if(m_fLoading)
            {
                TimerControl( TIMERMODE_MORETIME );
            }
            else
            {
                TimerControl( TIMERMODE_RESTART );

                NotifyStartOfNavigation( bstrURL );
            }
        }
    }
}

void __stdcall CPCHWebBrowserEvents::NewWindow2( IDispatch*   *ppDisp ,
                                                 VARIANT_BOOL *Cancel )
{
    // Not disabled in Whistler.
    // *Cancel = VARIANT_TRUE;
}

void __stdcall CPCHWebBrowserEvents::NavigateComplete2( IDispatch* pDisp ,
                                                        VARIANT*   URL   )
{
    if(!m_parent) return; // Called before init or after passivate.

#ifdef DEBUG
    DebugLog( L"#################### NavigateComplete2 %s %08x %s\n", m_parent->PanelName( m_idPanel ), pDisp, SAFEBSTR( V_BSTR( URL ) ) );
    DEBUG_CheckReadyState();
#endif

    DEBUG_AppendPerf( DEBUG_PERF_EVENTS_IN, L"CPCHWebBrowserEvents::NavigateComplete2 : %s", SAFEBSTR( V_BSTR( URL ) ) );

    TimerControl( TIMERMODE_MORETIME );
}

void __stdcall CPCHWebBrowserEvents::DocumentComplete( IDispatch* pDisp ,
                                                       VARIANT*   URL   )
{
    if(!m_parent) return; // Called before init or after passivate.

	BSTR bstrURL = V_BSTR( URL );

#ifdef DEBUG
    DebugLog( L"#################### DocumentComplete %s %08x %s\n", m_parent->PanelName( m_idPanel ), pDisp, SAFEBSTR( bstrURL ) );
    DEBUG_CheckReadyState();
#endif

    DEBUG_AppendPerf( DEBUG_PERF_EVENTS_IN, L"CPCHWebBrowserEvents::DocumentComplete : %s", SAFEBSTR( bstrURL ) );

    TimerControl( TIMERMODE_MORETIME );

	//
	// If it's one of the URL in the ignore list, don't queue the complete notification.
	//
	{
		CPCHHelpSession* hs = m_parent->HelpSession();

		if(hs && hs->IsUrlToIgnore( bstrURL, /*fRemove*/true ))
		{
			m_fLoading = false;
			return;
		}
    }

    //
    // Get to the document and extract its title.
    //
    {
        CComPtr<IHTMLDocument2> pDoc;

        if(SUCCEEDED(MPC::HTML::IDispatch_To_IHTMLDocument2( pDoc, pDisp )))
        {
            CComBSTR bstrTitle;

            if(SUCCEEDED(pDoc->get_title( &bstrTitle )))
            {
                (void)m_parent->HelpSession()->RecordTitle( URL->bstrVal, bstrTitle, false );
            }
        }
    }

    if(m_fLoading)
    {
        if(m_pWB2)
        {
            tagREADYSTATE readystate;

            if(SUCCEEDED(m_pWB2->get_ReadyState( &readystate )) && readystate == READYSTATE_COMPLETE)
            {
                bool fDone;

                if(SUCCEEDED(MPC::HTML::AreAllTheFramesInTheCompleteState( fDone, m_pWB2 )) && fDone)
                {
                    TimerControl( TIMERMODE_COMPLETE );
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\helpcenterexternal_com.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenterExternal.cpp

Abstract:
    This file contains the implementation of the class exposed as the "pchealth" object.

Revision History:
    Ghim-Sim Chua       (gschua)   07/23/99
        created
    Davide Massarenti   (dmassare) 07/25/99
        modified

    Kalyani Narlanka    (KalyaniN)  03/15/01
	    Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.

******************************************************************************/

#include "stdafx.h"

#include "rdshost_i.c"

#include "safrdm_i.c"

#include "rassistance.h"

#include "rassistance_i.c"

#include <mshtmcid.h>

#include <userenv.h>

/////////////////////////////////////////////////////////////////////////////

static const MPC::StringToBitField s_arrMessageBoxMap[] =
{
    { L"OK"               , MB_TYPEMASK, MB_OK               , -1 },
    { L"OKCANCEL"         , MB_TYPEMASK, MB_OKCANCEL         , -1 },
    { L"ABORTRETRYIGNORE" , MB_TYPEMASK, MB_ABORTRETRYIGNORE , -1 },
    { L"YESNOCANCEL"      , MB_TYPEMASK, MB_YESNOCANCEL      , -1 },
    { L"YESNO"            , MB_TYPEMASK, MB_YESNO            , -1 },
    { L"RETRYCANCEL"      , MB_TYPEMASK, MB_RETRYCANCEL      , -1 },
    { L"CANCELTRYCONTINUE", MB_TYPEMASK, MB_CANCELTRYCONTINUE, -1 },

    { L"ICONHAND"         , MB_ICONMASK, MB_ICONHAND         , -1 },
    { L"ICONQUESTION"     , MB_ICONMASK, MB_ICONQUESTION     , -1 },
    { L"ICONEXCLAMATION"  , MB_ICONMASK, MB_ICONEXCLAMATION  , -1 },
    { L"ICONASTERISK"     , MB_ICONMASK, MB_ICONASTERISK     , -1 },
    { L"USERICON"         , MB_ICONMASK, MB_USERICON         , -1 },

    { L"ICONWARNING"      , MB_ICONMASK, MB_ICONWARNING      , -1 },
    { L"ICONERROR"        , MB_ICONMASK, MB_ICONERROR        , -1 },
    { L"ICONINFORMATION"  , MB_ICONMASK, MB_ICONINFORMATION  , -1 },
    { L"ICONSTOP"         , MB_ICONMASK, MB_ICONSTOP         , -1 },

    { L"DEFBUTTON1"       , MB_MODEMASK, MB_DEFBUTTON1       , -1 },
    { L"DEFBUTTON2"       , MB_MODEMASK, MB_DEFBUTTON2       , -1 },
    { L"DEFBUTTON3"       , MB_MODEMASK, MB_DEFBUTTON3       , -1 },
    { L"DEFBUTTON4"       , MB_MODEMASK, MB_DEFBUTTON4       , -1 },

    { L"APPLMODAL"        , MB_MODEMASK, MB_APPLMODAL        , -1 },
    { L"SYSTEMMODAL"      , MB_MODEMASK, MB_SYSTEMMODAL      , -1 },
    { L"TASKMODAL"        , MB_MODEMASK, MB_TASKMODAL        , -1 },
    { L"HELP"             , MB_MODEMASK, MB_HELP             , -1 },

    { NULL                                                        }
};

static const CComBSTR s_bstrFunc_GlobalContextMenu( L"GlobalContextMenu" );
static const CComBSTR s_bstrFunc_BuildTree        ( L"debug_BuildTree"   );

/////////////////////////////////////////////////////////////////////////////

CPCHSecurityHandle::CPCHSecurityHandle()
{
    m_ext    = NULL; // CPCHHelpCenterExternal* m_ext;
    m_object = NULL; // IDispatch*              m_object;
}

void CPCHSecurityHandle::Initialize( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in] */ IDispatch* object )
{
    m_ext    = ext;
    m_object = object;
}

void CPCHSecurityHandle::Passivate()
{
    m_ext    = NULL;
    m_object = NULL;
}

HRESULT CPCHSecurityHandle::ForwardInvokeEx( /*[in] */ DISPID            id        ,
											 /*[in] */ LCID              lcid      ,
											 /*[in] */ WORD              wFlags    ,
											 /*[in] */ DISPPARAMS*       pdp       ,
											 /*[out]*/ VARIANT*          pvarRes   ,
											 /*[out]*/ EXCEPINFO*        pei       ,
											 /*[in] */ IServiceProvider* pspCaller )
{
	return m_ext ? m_ext->SetTLSAndInvoke( m_object, id, lcid, wFlags, pdp, pvarRes, pei, pspCaller ) : E_ACCESSDENIED;
}

HRESULT CPCHSecurityHandle::IsTrusted()
{
	return m_ext ? m_ext->IsTrusted() : E_ACCESSDENIED;
}

HRESULT CPCHSecurityHandle::IsSystem()
{
	return m_ext ? m_ext->IsSystem() : E_ACCESSDENIED;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::get_HelpSession( /*[out, retval]*/ IPCHHelpSession* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_HelpSession",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();


    if(HelpSession())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, HelpSession()->QueryInterface( IID_IPCHHelpSession, (void**)pVal ));
    }


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_Channels( /*[out, retval]*/ ISAFReg* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_Channels",hr,pVal);

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->get_Channels( pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_UserSettings( /*[out, retval]*/ IPCHUserSettings2* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_UserSettings",hr,pVal);

    if(!m_UserSettings) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
	//
	// We don't check trust at this stage, it's the object's responsibility to protect each one of its methods.
	// This is because "pchealth.UserSettings" exposes read-only properties that could be accessed from untrusted pages.
	//

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings->QueryInterface( IID_IPCHUserSettings2, (void**)pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_Security( /*[out, retval]*/ IPCHSecurity* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_Security",hr,pVal);

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->get_Security( pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_Connectivity( /*[out, retval]*/ IPCHConnectivity* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_Connectivity",hr,pVal);

	CComPtr<CPCHConnectivity> pC;

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pC ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pC->ConnectToParent( this ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pC.QueryInterface( pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_Database( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_Database",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->get_Database( pVal ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_TextHelpers( /*[out, retval]*/ IPCHTextHelpers* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_TextHelpers",hr,pVal);

    if(!m_TextHelpers)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_TextHelpers ));
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_TextHelpers.QueryInterface( pVal ));


    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::get_UI_Panel( /*[out, retval]*/ IUnknown* *pVal, /*[in]*/ HscPanel id )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_UI_Panel",hr,pVal);

    INTERNETSECURITY__CHECK_SYSTEM();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( id, (IMarsPanel**)pVal, true ));

    __HCP_END_PROPERTY(hr);
}

HRESULT CPCHHelpCenterExternal::get_WEB_Panel( /*[out, retval]*/ IUnknown* *pVal, /*[in]*/ HscPanel id )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_WEB_Panel",hr,pVal);

    CComPtr<IMarsPanel>   panel;
    CComPtr<IWebBrowser2> wb;

    INTERNETSECURITY__CHECK_SYSTEM();

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( id, &panel, true ));

    switch(id)
    {
    case HSCPANEL_CONTEXT : wb = m_panel_CONTEXT_WebBrowser ; break;
    case HSCPANEL_CONTENTS: wb = m_panel_CONTENTS_WebBrowser; break;
    case HSCPANEL_HHWINDOW: wb = m_panel_HHWINDOW_WebBrowser; break;
    }

    *pVal = wb.Detach();

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_UI_NavBar    ( /*[out, retval]*/ IUnknown* *pVal ) { return get_UI_Panel( pVal, HSCPANEL_NAVBAR     ); }
STDMETHODIMP CPCHHelpCenterExternal::get_UI_MiniNavBar( /*[out, retval]*/ IUnknown* *pVal ) { return get_UI_Panel( pVal, HSCPANEL_MININAVBAR ); }
STDMETHODIMP CPCHHelpCenterExternal::get_UI_Context   ( /*[out, retval]*/ IUnknown* *pVal ) { return get_UI_Panel( pVal, HSCPANEL_CONTEXT    ); }
STDMETHODIMP CPCHHelpCenterExternal::get_UI_Contents  ( /*[out, retval]*/ IUnknown* *pVal ) { return get_UI_Panel( pVal, HSCPANEL_CONTENTS   ); }
STDMETHODIMP CPCHHelpCenterExternal::get_UI_HHWindow  ( /*[out, retval]*/ IUnknown* *pVal ) { return get_UI_Panel( pVal, HSCPANEL_HHWINDOW   ); }

STDMETHODIMP CPCHHelpCenterExternal::get_WEB_Context ( /*[out, retval]*/ IUnknown* *pVal ) { return get_WEB_Panel( pVal, HSCPANEL_CONTEXT  ); }
STDMETHODIMP CPCHHelpCenterExternal::get_WEB_Contents( /*[out, retval]*/ IUnknown* *pVal ) { return get_WEB_Panel( pVal, HSCPANEL_CONTENTS ); }
STDMETHODIMP CPCHHelpCenterExternal::get_WEB_HHWindow( /*[out, retval]*/ IUnknown* *pVal ) { return get_WEB_Panel( pVal, HSCPANEL_HHWINDOW ); }

STDMETHODIMP CPCHHelpCenterExternal::get_ExtraArgument( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_ExtraArgument",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrExtraArgument, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::get_HelpViewer( /*[out, retval]*/ IUnknown* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::get_HelpViewer",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

	MPC::CopyTo( (IPCHHelpViewerWrapper*)m_panel_HHWINDOW_Wrapper, pVal );

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::RegisterEvents( /*[in]*/         BSTR        id       ,
                                                     /*[in]*/         long        pri      ,
                                                     /*[in]*/         IDispatch*  function ,
                                                     /*[out,retval]*/ long       *cookie   )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RegisterEvents" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(id);
        __MPC_PARAMCHECK_POINTER_AND_SET(cookie,0);
    __MPC_PARAMCHECK_END();

    INTERNETSECURITY__CHECK_TRUST();


    hr = m_Events.RegisterEvents( id, pri, function, cookie );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::UnregisterEvents( /*[in]*/ long cookie )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::UnregisterEvents" );

    HRESULT hr;

    INTERNETSECURITY__CHECK_TRUST();

    hr = m_Events.UnregisterEvents( cookie );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_SearchEngineMgr( /*[out, retval]*/ IPCHSEManager* *ppSE )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_SearchEngineMgr",hr,ppSE);

    INTERNETSECURITY__CHECK_TRUST();
    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_SearchEngineMgr( ppSE ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_DataCollection( /*[out, retval]*/ ISAFDataCollection* *ppDC )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_DataCollection",hr,ppDC);

    INTERNETSECURITY__CHECK_TRUST();

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_DataCollection( ppDC ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_Cabinet( /*[out , retval]*/ ISAFCabinet* *ppCB )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_Cabinet",hr,ppCB);

    INTERNETSECURITY__CHECK_TRUST();

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_Cabinet( ppCB ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_Encryption( /*[out, retval]*/ ISAFEncrypt* *ppEn )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_Encryption",hr,ppEn);

	bool  fTemporaryProfile = false;
	DWORD dwProfileFlags;

    INTERNETSECURITY__CHECK_TRUST();


	if(::GetProfileType( &dwProfileFlags ))
	{
		if(( dwProfileFlags & PT_MANDATORY                                   ) ||
		   ((dwProfileFlags & PT_TEMPORARY) && !(dwProfileFlags & PT_ROAMING))  )
        {
            fTemporaryProfile = true;
        }
	}

	if(fTemporaryProfile)
	{
		if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_Encryption( ppEn ));
	}
	else
	{
		CComPtr<CSAFEncrypt> pEn;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pEn ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, pEn.QueryInterface( ppEn ));
	}

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_Channel( /*[in]         */ BSTR          bstrVendorID  ,
                                                           /*[in]         */ BSTR          bstrProductID ,
                                                           /*[out, retval]*/ ISAFChannel* *ppCh          )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_Channel",hr,ppCh);

    INTERNETSECURITY__CHECK_TRUST();

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_Channel( bstrVendorID, bstrProductID, ppCh ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_Incident( /*[out, retval]*/ ISAFIncident* *ppIn )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_Incident",hr,ppIn);

	CComPtr<CSAFIncident> pIn;

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pIn ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pIn.QueryInterface( ppIn ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_RemoteDesktopSession(
                                                                        /*[in]*/          long                          lTimeout            ,
                                                                        /*[in]*/          BSTR                          bstrConnectionParms ,
																		/*[in]*/          BSTR                          bstrUserHelpBlob    ,
                                                                        /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_RemoteDesktopSession",hr,ppRCS);

    REMOTE_DESKTOP_SHARING_CLASS  sharingClass  = VIEWDESKTOP_PERMISSION_NOT_REQUIRE;

    INTERNETSECURITY__CHECK_TRUST();

	if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_RemoteDesktopSession( sharingClass, lTimeout, bstrConnectionParms, bstrUserHelpBlob, ppRCS ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::ConnectToExpert( /* [in]          */ BSTR bstrExpertConnectParm,
                                                      /* [in]          */ LONG lTimeout,
                                                      /* [retval][out] */ LONG *lSafErrorCode)

{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::ConnectToExpert",hr,lSafErrorCode);

    INTERNETSECURITY__CHECK_TRUST();

	if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->ConnectToExpert( bstrExpertConnectParm, lTimeout, lSafErrorCode));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_RemoteDesktopManager( /*[out, retval]*/ ISAFRemoteDesktopManager* *ppRDM )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_RemoteDesktopManager",hr,ppRDM);

    CComPtr<ISAFRemoteDesktopManager> pSAFRDManager;


    INTERNETSECURITY__CHECK_TRUST();

    // Instantiate ISAFRemoteDesktopManager.
    __MPC_EXIT_IF_METHOD_FAILS(hr, pSAFRDManager.CoCreateInstance( CLSID_SAFRemoteDesktopManager, NULL, CLSCTX_INPROC_SERVER ));

    *ppRDM = pSAFRDManager.Detach();


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_RemoteDesktopConnection( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_RemoteDesktopConnection",hr,ppRDC);

	INTERNETSECURITY__CHECK_TRUST();

    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->CreateObject_RemoteDesktopConnection( ppRDC ));
	
	__HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_ContextMenu( /*[out, retval]*/ IPCHContextMenu* *ppCM )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_ContextMenu",hr,ppCM);

    CComPtr<CPCHContextMenu> pObj;


    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj )); pObj->Initialize( this );

    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj.QueryInterface( ppCM ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_PrintEngine( /*[out, retval]*/ IPCHPrintEngine* *ppPE )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_PrintEngine",hr,ppPE);

    CComPtr<CPCHPrintEngine> pObj;


    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj.QueryInterface( ppPE ));


    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_IntercomClient( /* [out, retval] */ ISAFIntercomClient* *ppI )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_IntercomClient",hr,ppI);

    CComPtr<CSAFIntercomClient> pObj;


    INTERNETSECURITY__CHECK_TRUST();

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));
	
	__MPC_EXIT_IF_METHOD_FAILS(hr, pObj.QueryInterface( ppI ));


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateObject_IntercomServer( /* [out, retval] */ ISAFIntercomServer* *ppI )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::CreateObject_IntercomServer",hr,ppI);

    CComPtr<CSAFIntercomServer> pObj;


    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pObj ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pObj.QueryInterface( ppI ));


    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::OpenFileAsStream( /*[in]*/          BSTR       bstrFilename ,
                                                       /*[out, retval]*/ IUnknown* *stream       )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::OpenFileAsStream" );

    HRESULT                       hr;
    CComPtr<CPCHScriptableStream> fsStream;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_POINTER_AND_SET(stream,NULL);
    __MPC_PARAMCHECK_END();

    INTERNETSECURITY__CHECK_TRUST();


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &fsStream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream->InitForRead( bstrFilename ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream.QueryInterface( stream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CreateFileAsStream( /*[in]*/          BSTR       bstrFilename ,
                                                         /*[out, retval]*/ IUnknown* *stream       )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::OpenFileAsStream" );

    HRESULT                       hr;
    CComPtr<CPCHScriptableStream> fsStream;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_POINTER_AND_SET(stream,NULL);
    __MPC_PARAMCHECK_END();

    INTERNETSECURITY__CHECK_TRUST();


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &fsStream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream->InitForWrite( bstrFilename ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStream.QueryInterface( stream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::CopyStreamToFile( /*[in]*/ BSTR      bstrFilename ,
                                                       /*[in]*/ IUnknown* stream       )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::CopyStreamToFile" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> fsStreamDst;
    CComPtr<IStream>         fsStreamSrc;
    LARGE_INTEGER            li;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrFilename);
        __MPC_PARAMCHECK_NOTNULL(stream);
    __MPC_PARAMCHECK_END();


    //
    // Create a stream for a file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &fsStreamDst ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStreamDst->InitForWrite( bstrFilename ));


    //
    // Copy the source stream to the file.
    //
    li.LowPart  = 0;
    li.HighPart = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->QueryInterface   ( IID_IStream, (void**)&fsStreamSrc ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStreamSrc->Seek        ( li, STREAM_SEEK_SET, NULL         )); // Rewind the stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, fsStreamDst->TransferData( fsStreamSrc,          fsStreamDst ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::NetworkAlive( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::NetworkAlive" );

    HRESULT                   hr;
    CComPtr<IPCHConnectivity> pchc;

    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Connectivity( &pchc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pchc->NetworkAlive( pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::DestinationReachable( /*[in]         */ BSTR          bstrURL ,
                                                           /*[out, retval]*/ VARIANT_BOOL *pVal    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::DestinationReachable" );

    HRESULT                   hr;
    CComPtr<IPCHConnectivity> pchc;

    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, get_Connectivity( &pchc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pchc->DestinationReachable( bstrURL, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::FormatError( /*[in         ]*/ VARIANT  vError ,
												  /*[out, retval]*/ BSTR    *pVal   )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHHelpCenterExternal::FormatError",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();
    if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->FormatError( vError, pVal ));

    __HCP_END_PROPERTY(hr);
}

HRESULT CPCHHelpCenterExternal::RegInit( /*[in]*/ BSTR           bstrKey  ,
										 /*[in]*/ bool           fRead    ,
										 /*[out]*/ MPC::RegKey&  rk       ,
										 /*[out]*/ MPC::wstring& strValue ) 
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RegInit" );

	HRESULT 	 hr;
	HKEY    	 hKeyRoot = HKEY_LOCAL_MACHINE;
	MPC::wstring strKey;
	LPCWSTR      szPtr;
	LPCWSTR      szPtr2;

	
    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrKey);
    __MPC_PARAMCHECK_END();

    INTERNETSECURITY__CHECK_TRUST();


	szPtr = bstrKey;
	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey::ParsePath( szPtr, hKeyRoot, szPtr ));

	szPtr2 = wcsrchr( szPtr, '\\' );
	if(szPtr2)
	{
		strKey.assign( szPtr, szPtr2 - szPtr );
		strValue = &szPtr2[1];
	}
	else
	{
		strKey = szPtr;
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( hKeyRoot, fRead ? KEY_READ : KEY_ALL_ACCESS ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Attach ( strKey.c_str()                              ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::RegRead( /*[in]*/ BSTR bstrKey, /*[out, retval]*/ VARIANT *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RegRead" );

	HRESULT      hr;
	MPC::RegKey  rk;
	MPC::wstring strValue; 
	bool         fFound;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, RegInit( bstrKey, /*fRead*/true, rk, strValue ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, rk.get_Value( *pVal, fFound, strValue.size() ? strValue.c_str() :  NULL ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::RegWrite( /*[in]*/ BSTR bstrKey, /*[in]*/ VARIANT newVal, /*[in,optional]*/ VARIANT vKind )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RegWrite" );

	HRESULT      hr;
	MPC::RegKey  rk;
	MPC::wstring strValue; 
	CComVariant  v( newVal );
	bool         fExpand = false;


	__MPC_EXIT_IF_METHOD_FAILS(hr, RegInit( bstrKey, /*fRead*/false, rk, strValue ));


	if(vKind.vt == VT_BSTR && STRINGISPRESENT(vKind.bstrVal))
	{
		if(!_wcsicmp( vKind.bstrVal, L"REG_DWORD" ))
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_I4 ));
		}

		if(!_wcsicmp( vKind.bstrVal, L"REG_SZ" ))
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BSTR ));
		}

		if(!_wcsicmp( vKind.bstrVal, L"REG_EXPAND_SZ" ))
		{
			fExpand = true;

			__MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_BSTR ));
		}

		if(!_wcsicmp( vKind.bstrVal, L"REG_MULTI_SZ" ))
		{
			fExpand = true;

			__MPC_EXIT_IF_METHOD_FAILS(hr, v.ChangeType( VT_ARRAY | VT_BSTR ));
		}
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Create   (                                                             ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, rk.put_Value( newVal, strValue.size() ? strValue.c_str() :  NULL, fExpand ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::RegDelete( /*[in]*/ BSTR bstrKey )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RegDelete" );

	HRESULT      hr;
	MPC::RegKey  rk;
	MPC::wstring strValue; 


	__MPC_EXIT_IF_METHOD_FAILS(hr, RegInit( bstrKey, /*fRead*/false, rk, strValue ));

	if(strValue.size())
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.del_Value( strValue.c_str() ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, rk.Delete( /*fDeep*/false ));
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::Close()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::Close" );

    HRESULT hr;
    HWND    hwnd;

    INTERNETSECURITY__CHECK_TRUST();


    //
    // In case we are called really early, give the application some time to initialize properly.
    //
    MPC::SleepWithMessagePump( 100 );

    if((hwnd = Window()) != NULL)
    {
        ::PostMessage( hwnd, WM_CLOSE, 0, 0 );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::RefreshUI()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RefreshUI" );

    MSG msg;

    //
    // There is one or more window message available. Dispatch them
    //
    while(::PeekMessage( &msg, NULL, NULL, NULL, PM_REMOVE ))
    {
        ::TranslateMessage( &msg );
        ::DispatchMessage ( &msg );
    }

    __HCP_FUNC_EXIT(S_OK);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::Print( /*[in]*/ VARIANT window, /*[in]*/ VARIANT_BOOL fEvent, /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::Print" );

    HRESULT      hr;
    VARIANT_BOOL Cancel;

    if(m_fHidden)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, E_ACCESSDENIED);
    }

    if(fEvent == VARIANT_TRUE)
    {
        if(SUCCEEDED(m_Events.FireEvent_Print( &Cancel )))
        {
            if(Cancel == VARIANT_TRUE)
            {
                __MPC_FUNC_LEAVE;
            }
        }
    }

    {
        CComQIPtr<IWebBrowser2> wb2;

        if(window.vt == VT_DISPATCH)
        {
            wb2 = window.pdispVal;
        }
        else
        {
			wb2.Attach( IsHHWindowVisible() ? HHWindow() : Contents() );
        }

        if(wb2)
        {
            (void)wb2->ExecWB( OLECMDID_PRINT, OLECMDEXECOPT_DODEFAULT, NULL, NULL );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT local_HighlighDocument( /*[in]*/ IHTMLDocument2*   doc ,
									   /*[in]*/ MPC::WStringList& lst )
{
    __HCP_FUNC_ENTRY( "local_HighlighDocument" );

    HRESULT               hr;
	CComPtr<IHTMLElement> elem;


	__MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_body( &elem ));
	if(elem)
	{
		CComPtr<IHTMLBodyElement> bodyElement;
		CComBSTR              	  bstrCmd   ( L"BackColor"                               );
		CComBSTR              	  bstrCmd2  ( L"ForeColor"                               );
		CComVariant           	  vBackColor( (long)::GetSysColor( COLOR_HIGHLIGHT     ) );
		CComVariant           	  vForeColor( (long)::GetSysColor( COLOR_HIGHLIGHTTEXT ) );
		DWORD                 	  dwTimeout;
		MPC::WStringIterConst 	  it;

		__MPC_EXIT_IF_METHOD_FAILS(hr, elem.QueryInterface( &bodyElement ));


		dwTimeout = ::GetTickCount() + 6000;
		for(it = lst.begin(); it != lst.end(); it++)
		{
			CComBSTR               bstrSearchTerm( it->c_str() );
			CComPtr<IHTMLTxtRange> range;
			VARIANT_BOOL           vbRet;


			__MPC_EXIT_IF_METHOD_FAILS(hr, bodyElement->createTextRange( &range ));

			while(1)
			{
				if(FAILED(range->findText( bstrSearchTerm, 1000000, 2, &vbRet )) || vbRet != VARIANT_TRUE) break;

				if(FAILED(range->execCommand( bstrCmd2, VARIANT_FALSE, vForeColor, &vbRet )) || vbRet != VARIANT_TRUE) break;
				if(FAILED(range->execCommand( bstrCmd , VARIANT_FALSE, vBackColor, &vbRet )) || vbRet != VARIANT_TRUE) break;

				if(::GetTickCount() > dwTimeout) break;

				if(FAILED(range->collapse( VARIANT_FALSE ))) break;
			}

			if(::GetTickCount() > dwTimeout) break;
		}
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpCenterExternal::HighlightWords( /*[in]*/ VARIANT window, /*[in]*/ VARIANT words )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::HighlightWords" );

    HRESULT                         hr;
	CComPtr<IHTMLDocument2>         doc;


	if(window.vt == VT_DISPATCH)
    {
        if(FAILED(MPC::HTML::IDispatch_To_IHTMLDocument2( doc, window.pdispVal )))
		{
			doc.Release();
		}
	}

	if(!doc)
	{
		//
		// If the caller didn't specify a window, we'll get the currently displayed window.
		//
        CComPtr<IWebBrowser2> wb2; wb2.Attach( IsHHWindowVisible() ? HHWindow() : Contents() );

		if(wb2)
		{
            CComPtr<IDispatch> docDisp;

			__MPC_EXIT_IF_METHOD_FAILS(hr, wb2->get_Document( &docDisp ));

			if(docDisp)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, docDisp.QueryInterface( &doc ));
			}
		}
	}

	if(doc)
	{
		MPC::WStringList                lst;
		CComPtr<IHTMLFramesCollection2> frames;

		if(words.vt == (VT_ARRAY | VT_BSTR   ) ||
		   words.vt == (VT_ARRAY | VT_VARIANT)  )
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertSafeArrayToList( words, lst ));
		}
		else if(words.vt == VT_BSTR)
		{
			lst.push_back( SAFEWSTR( words.bstrVal ) );
		}


		(void)local_HighlighDocument( doc, lst );
		__MPC_EXIT_IF_METHOD_FAILS(hr, doc->get_frames( &frames ));
		if(frames)
		{
			long len;

			__MPC_EXIT_IF_METHOD_FAILS(hr, frames->get_length( &len ));

			for(int i=0; i<len; i++)
			{
				CComVariant vIndex = i;
				CComVariant vValue;

				__MPC_EXIT_IF_METHOD_FAILS(hr, frames->item( &vIndex, &vValue ));

				if(vValue.vt == VT_DISPATCH)
				{
					CComQIPtr<IHTMLWindow2> fb = vValue.pdispVal;
					if(fb)
					{
						CComPtr<IHTMLDocument2> docSub;

						__MPC_EXIT_IF_METHOD_FAILS(hr, fb->get_document( &docSub ));
						if(docSub)
						{
							(void)local_HighlighDocument( docSub, lst );
						}
					}
				}
			}
		}
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::MessageBox( /*[in]*/ BSTR bstrText, /*[in]*/ BSTR bstrKind, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::MessageBox" );

    HRESULT      hr;
    MPC::wstring szTitle; MPC::LocalizeString( IDS_MAINWND_TITLE, szTitle );
    DWORD        dwType = 0;
    LPCWSTR      szRes;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(m_fHidden)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, E_ACCESSDENIED);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertStringToBitField( bstrKind, dwType, s_arrMessageBoxMap ));
    if(dwType == 0) dwType = MB_OK;

    switch( ::MessageBoxW( m_hwnd, SAFEBSTR( bstrText ), szTitle.c_str(), dwType ) )
    {
    case IDABORT   : szRes = L"ABORT"   ; break;
    case IDCANCEL  : szRes = L"CANCEL"  ; break;
    case IDCONTINUE: szRes = L"CONTINUE"; break;
    case IDIGNORE  : szRes = L"IGNORE"  ; break;
    case IDNO      : szRes = L"NO"      ; break;
    case IDOK      : szRes = L"OK"      ; break;
    case IDRETRY   : szRes = L"RETRY"   ; break;
    case IDTRYAGAIN: szRes = L"TRYAGAIN"; break;
    case IDYES     : szRes = L"YES"     ; break;
    default        : szRes = L""        ; break;
    }

    hr = MPC::GetBSTR( szRes, pVal );


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

struct SelectFolder_Data
{
    BSTR bstrDefault;
    BSTR bstrPrefix;
    BSTR bstrSuffix;
};

static int CALLBACK SelectFolder_Callback( HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
    SelectFolder_Data* ptr = (SelectFolder_Data*)lpData;

    switch(uMsg)
    {
    case BFFM_INITIALIZED:
        if(ptr->bstrDefault)
        {
            ::SendMessageW( hwnd, BFFM_SETSELECTIONW, TRUE, (LPARAM)ptr->bstrDefault );
        }
        break;

    case BFFM_SELCHANGED:
        {
            BOOL fEnabled = TRUE;

            if(ptr->bstrPrefix)
            {
            }

            ::SendMessageW( hwnd, BFFM_ENABLEOK, 0, fEnabled );
        }
        break;
    }

    return 0;
}

STDMETHODIMP CPCHHelpCenterExternal::SelectFolder( /*[in]*/ BSTR bstrTitle, /*[in]*/ BSTR bstrDefault, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::SelectFolder" );

    HRESULT           hr;
    LPITEMIDLIST      pidl = NULL;
    CComPtr<IMalloc>  malloc;
    SelectFolder_Data data;
    BROWSEINFOW       bi;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ::SHGetMalloc( &malloc ));


    ::ZeroMemory( &bi, sizeof( bi ) );
    bi.hwndOwner = m_hwnd;
    bi.lpszTitle = bstrTitle;
    bi.ulFlags   = BIF_RETURNONLYFSDIRS | BIF_USENEWUI | BIF_STATUSTEXT | BIF_VALIDATE;
    bi.lpfn      = SelectFolder_Callback;
    bi.lParam    = (LPARAM)&data;

    data.bstrDefault = bstrDefault;
    data.bstrPrefix  = NULL;
    data.bstrSuffix  = NULL;

    pidl = ::SHBrowseForFolderW( &bi );
    if(pidl)
    {
        WCHAR rgPath[MAX_PATH];

        if(::SHGetPathFromIDListW( pidl, rgPath ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( rgPath, pVal ));
        }

    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    if(malloc && pidl) malloc->Free( pidl );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

CPCHHelper_IDocHostUIHandler::CPCHHelper_IDocHostUIHandler()
{
	m_parent = NULL; CPCHHelpCenterExternal* m_parent;
}

void CPCHHelper_IDocHostUIHandler::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
	m_parent = parent;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if(InlineIsEqualGUID( riid, IID_IDocHostUIHandler ))
    {
        hr = QueryInterface( riid, ppv );
    }

    return hr;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::ShowContextMenu( DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit )
{
	if(g_Debug_CONTEXTMENU)
	{
		if(::GetKeyState( VK_CONTROL ) & 0x8000) return E_NOTIMPL;
	}

	if(g_Debug_BUILDTREE)
	{
		if(::GetKeyState( VK_MENU ) & 0x8000)
		{
			CComVariant vArg( pDispatchObjectHit );

			(void)m_parent->CallFunctionOnPanel( HSCPANEL_NAVBAR, NULL, s_bstrFunc_BuildTree, &vArg, 1 );
		}
	}

    //
    // Last chance for the scripts to say something...
    //
    {
        CComVariant vArgs[4];
        CComVariant vRes;
		DWORD       dwCmd = -1;

		vArgs[3] = (long)dwID;
		vArgs[2] = pDispatchObjectHit;
		vArgs[1] = (long)pptPosition->x;
		vArgs[0] = (long)pptPosition->y;

        (void)m_parent->CallFunctionOnPanel( HSCPANEL_NAVBAR, NULL, s_bstrFunc_GlobalContextMenu, vArgs, ARRAYSIZE(vArgs), &vRes );

        if(vRes.vt == VT_BSTR && vRes.bstrVal)
		{
			if(!_wcsicmp( vRes.bstrVal, L"DELEGATE" )) return E_NOTIMPL;

			if(!_wcsicmp( vRes.bstrVal, L"SELECTALL"  )) dwCmd = OLECMDID_SELECTALL;
			if(!_wcsicmp( vRes.bstrVal, L"REFRESH"    )) dwCmd = OLECMDID_REFRESH;
			if(!_wcsicmp( vRes.bstrVal, L"PROPERTIES" )) dwCmd = OLECMDID_PROPERTIES;
		}

		if(dwCmd != -1)
		{
			CComVariant vaIn;
			CComVariant vaOut;

			switch(dwCmd)
			{
			case OLECMDID_PROPERTIES: // Trident folks say the In value must be set to the mouse pos
				vaIn = MAKELONG(pptPosition->x,pptPosition->y);
				break;
			}

			((IOleCommandTarget*)pCommandTarget)->Exec( NULL, dwCmd, OLECMDEXECOPT_DODEFAULT, &vaIn, &vaOut );
		}
    }

    return S_OK;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO* pInfo)
{
	pInfo->dwFlags       = DOCHOSTUIFLAG_NO3DBORDER |
		                   DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE |
		                   DOCHOSTUIFLAG_THEME;
	pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::HideUI()
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::UpdateUI()
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
{
	bool fCancel  	   = false;
	bool fBack    	   = false;
	bool fForward 	   = false;
	bool fPossibleBack = false;

	switch(nCmdID)
	{
	//	case IDM_CONTEXTMENU:

	case IDM_GOBACKWARD :
		fCancel = true;
		fBack   = true;
		break;

    case IDM_GOFORWARD:
		fCancel  = true;
		fForward = true;
		break;
	}


    if(lpMsg->message == WM_KEYDOWN ||
	   lpMsg->message == WM_KEYUP    )
    {
		switch(lpMsg->wParam)
		{
		case 'N': // CTRL-N (new window) disabled.
			if(::GetKeyState( VK_CONTROL ) & 0x8000)
			{
            	if (!( HIWORD(lpMsg->lParam) & KF_ALTDOWN )) // ALT not pressed
            	{ 
            		fCancel = true;
            	}
			}
			break;

		case VK_F5: // We want to disable F5 as a refresh tool.
			fCancel = true;
			break;
			
		case VK_BACK: // Enable "backspace" directly.
			fPossibleBack = true;
			break;
		}
	}

    if(lpMsg->message == WM_SYSKEYDOWN)
    {
		switch(lpMsg->wParam)
		{
		case VK_LEFT:
			fCancel = true;
			fBack   = true;
			break;

		case VK_RIGHT:
			fCancel  = true;
			fForward = true;
			break;
		}
	}


	////////////////////

	if(fPossibleBack || fBack || fForward)
	{
		if(m_parent)
		{
			CPCHHelpSession* hs = m_parent->HelpSession();

			if(hs)
			{
				if(fPossibleBack)
				{
					hs->PossibleBack();
				}

				if(fBack)
				{
					if(hs->IsTravelling() == false) (void)hs->Back( 1 );
				}

				if(fForward)
				{
					if(hs->IsTravelling() == false) (void)hs->Forward( 1 );
				}

			}
		}
	}

	if(fCancel == false)
	{
		fCancel = SUCCEEDED(m_parent->ProcessMessage( lpMsg ));
	}

	return fCancel ? S_OK : E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::GetOptionKeyPath(BSTR* pbstrKey, DWORD dwReserved)
{
	if(pbstrKey)
	{
		static const WCHAR c_options[] = HC_REGISTRY_HELPCTR_IE;

		BSTR szBuf = (BSTR)::CoTaskMemAlloc( sizeof(c_options) );
		if(szBuf)
		{
			wcscpy( *pbstrKey = szBuf, c_options );
		}
	}

    return S_OK;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::GetDropTarget(IDropTarget* pDropTarget, IDropTarget** ppDropTarget)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::GetExternal(IDispatch** ppDispatch)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHHelper_IDocHostUIHandler::FilterDataObject(IDataObject* pDO, IDataObject** ppDORet)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

CPCHContextMenu::CPCHContextMenu()
{
	m_parent    = NULL; // CPCHHelpCenterExternal* m_parent;
                     	// List 		   		   m_lstItems;
    m_iLastItem = 1; 	// int  		   		   m_iLastItem;
}

CPCHContextMenu::~CPCHContextMenu()
{
}

void CPCHContextMenu::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
	m_parent = parent;
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHContextMenu::AddItem( /*[in]*/           BSTR    bstrText ,
                                       /*[in]*/           BSTR    bstrID   ,
                                       /*[in, optional]*/ VARIANT vFlags   )
{
    __HCP_FUNC_ENTRY( "CPCHContextMenu::AddItem" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrText);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrID);
    __MPC_PARAMCHECK_END();

    {
        const UINT sAllowedFlags = MF_GRAYED |
                                   MF_CHECKED;

        Entry& ent = *(m_lstItems.insert( m_lstItems.end() ));

        ent.bstrText = bstrText;
        ent.bstrID   = bstrID;
        ent.iID      = m_iLastItem++;
        ent.uFlags   = (vFlags.vt == VT_I4 ? vFlags.lVal : 0) & sAllowedFlags;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHContextMenu::AddSeparator()
{
    __HCP_FUNC_ENTRY( "CPCHContextMenu::AddSeparator" );

    HRESULT hr;

    {
        Entry& ent = *(m_lstItems.insert( m_lstItems.end() ));

        ent.iID = -1;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHContextMenu::Display( /*[out,retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHContextMenu::Display" );

    HRESULT hr;
    HMENU   hMenu = NULL;
    Iter    it;
    int     iSelected;
	POINT   pt;


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hMenu = ::CreatePopupMenu()));

    //
    // Populate menu.
    //
    for(it = m_lstItems.begin(); it != m_lstItems.end(); it++)
    {
        Entry& ent = *it;

        if(ent.iID < 0)
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AppendMenuW( hMenu, MF_SEPARATOR, 0, 0 ));
        }
        else
        {
            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::AppendMenuW( hMenu, MF_STRING | ent.uFlags, ent.iID, ent.bstrText ));
        }
    }

    ::GetCursorPos( &pt );

	//
	// Find the active panel and its active element. If the cursor is inside its bounding rectangle, display the CM under the cursor.
	// Otherwise display the CM at the upper-left corner of the element.
	//
	{
		IMarsWindowOM*                shell = m_parent->Shell();
		CComPtr<IMarsPanelCollection> coll;

		if(shell && SUCCEEDED(shell->get_panels( &coll )) && coll)
		{
			CComPtr<IMarsPanel> panel;

			if(SUCCEEDED(coll->get_activePanel( &panel )) && panel)
			{
				CComPtr<IDispatch> disp;

				if(panel == m_parent->Panel( HSCPANEL_HHWINDOW ))
				{
					CComPtr<IWebBrowser2> wb2; wb2.Attach( m_parent->HHWindow() );

					disp = wb2;
				}
				else
				{
					(void)panel->get_content( &disp );
				}

				if(disp)
				{
					CComQIPtr<IWebBrowser2>   wb2 = disp;
					CComQIPtr<IHTMLDocument2> doc2;

					if(wb2)
					{
						disp.Release();

						wb2->get_Document( &disp );
					}

					doc2 = disp;

					//
					// Look for the inner-most active element.
					//
					{
						CComPtr<IHTMLElement> elem;

						while(doc2 && SUCCEEDED(doc2->get_activeElement( &elem )) && elem)
						{
							//
							// This could be a frame.
							//
							CComPtr<IHTMLFrameBase2> frame;

							if(SUCCEEDED(elem.QueryInterface( &frame )))
							{
								CComPtr<IHTMLWindow2> winsub;

								if(SUCCEEDED(frame->get_contentWindow( &winsub )) && winsub)
								{
									doc2.Release();
									elem.Release();

									(void)winsub->get_document( &doc2 );
									continue;
								}
							}

							break;
						}

						{
							CComQIPtr<IServiceProvider> sp = elem;
							
							if(sp)
							{
								CComPtr<IAccessible> acc;
								
								if(SUCCEEDED(sp->QueryService( IID_IAccessible, IID_IAccessible, (void**)&acc )))
								{
									long 	xLeft;
									long 	yTop;
									long 	cxWidth;
									long 	cyHeight;
									VARIANT v;

									v.vt   = VT_I4;
									v.lVal = CHILDID_SELF;

									if(SUCCEEDED(acc->accLocation( &xLeft, &yTop, &cxWidth, &cyHeight, v )))
									{
										if(pt.x < xLeft || pt.x > xLeft + cxWidth  ||
										   pt.y < yTop  || pt.y > yTop  + cyHeight  )
										{
											DWORD dwDefaultLayout;

											if(::GetProcessDefaultLayout( &dwDefaultLayout ) && (dwDefaultLayout & LAYOUT_RTL))
											{
												pt.x = xLeft + cxWidth;
												pt.y = yTop;
											}
											else
											{
												pt.x = xLeft;
												pt.y = yTop;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

	iSelected = ::TrackPopupMenu( hMenu, TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD | TPM_NONOTIFY, pt.x, pt.y, 0, m_parent->Window(), NULL );


    if(iSelected != 0)
    {
        for(it = m_lstItems.begin(); it != m_lstItems.end(); it++)
        {
            Entry& ent = *it;

            if(ent.iID == iSelected)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( ent.bstrID, pVal ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hMenu) ::DestroyMenu( hMenu );

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\favorites.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Favorites.cpp

Abstract:
    This file contains the implementation of the CPCHFavorites class,
    which is used to store the list of favorite contents.

Revision History:
    Davide Massarenti   (Dmassare)  05/10/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

const WCHAR c_szPersistFile[] = HC_ROOT_HELPCTR L"\\Favorites.stream";

static const DWORD l_dwVersion = 0x01564146; // FAV 01

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHFavorites::Entry::Init()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Entry::Init" );

    HRESULT hr;

	if(m_Data == NULL)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_Data ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHFavorites::Entry::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Entry::Load" );

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_NOTNULL(m_Data);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_Data->Load( streamIn ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHFavorites::Entry::Save( /*[in]*/ MPC::Serializer& streamOut )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Entry::Save" );

    HRESULT hr;


	if(m_Data)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_Data->Save( streamOut, true ));
	}


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHFavorites::CPCHFavorites()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::CPCHFavorites" );

    				   // List m_lstFavorites;
	m_fLoaded = false; // bool m_fLoaded;
}

CPCHFavorites::~CPCHFavorites()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::~CPCHFavorites" );
}

////////////////////

CPCHFavorites* CPCHFavorites::s_GLOBAL( NULL );

HRESULT CPCHFavorites::InitializeSystem()
{
	if(s_GLOBAL) return S_OK;

	return MPC::CreateInstance( &CPCHFavorites::s_GLOBAL );
}

void CPCHFavorites::FinalizeSystem()
{
	if(s_GLOBAL)
	{
		s_GLOBAL->Release(); s_GLOBAL = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHFavorites::FindEntry( /*[in]*/ IPCHHelpSessionItem* pItem, /*[out]*/ Iter& it )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::FindEntry" );

	HRESULT hr;

    //
    // First of all, look if the page is already present.
    //
    for(it = m_lstFavorites.begin(); it != m_lstFavorites.end(); it++)
    {
        if(it->m_Data == pItem)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, S_OK);
		}
	}

	hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHFavorites::Erase()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Erase" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);


	CPCHFavorites_Parent::Erase();

	m_lstFavorites.clear();

	m_fLoaded = false;
    hr        = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHFavorites::Load()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Load" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
    HANDLE       				 hFile = INVALID_HANDLE_VALUE;


	if(m_fLoaded == false)
	{
		MPC::wstring szFile;

		//
		// Open file and read it.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( szFile, c_szPersistFile ));

		__MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFile.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ));

		{
			MPC::Serializer_File      streamReal( hFile      );
			MPC::Serializer_Buffering streamBuf ( streamReal );
			DWORD                     dwVer;

			__MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

			while(1)
			{
				Iter it = m_lstFavorites.insert( m_lstFavorites.end() );

				__MPC_EXIT_IF_METHOD_FAILS(hr, it->Init());

				if(FAILED(it->Load( streamBuf )))
				{
					m_lstFavorites.erase( it );
					break;
				}
			}
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(FAILED(hr)) Erase();

    if(hFile != INVALID_HANDLE_VALUE) ::CloseHandle( hFile );

	m_fLoaded = true; // Anyway, flag the object as loaded.

    __HCP_FUNC_EXIT(S_OK); // Never fail.
}

HRESULT CPCHFavorites::Save()
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Save" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
    HANDLE       				 hFile = INVALID_HANDLE_VALUE;


	if(m_fLoaded)
	{
		MPC::wstring szFile;
		Iter         it;

		//
		// Create the new file.
		//
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( szFile, c_szPersistFile ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir            ( szFile                  ));

		__MPC_EXIT_IF_INVALID_HANDLE(hr, hFile, ::CreateFileW( szFile.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

		{
			MPC::Serializer_File      streamReal( hFile      );
			MPC::Serializer_Buffering streamBuf ( streamReal );

			__MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << l_dwVersion);

			for(it = m_lstFavorites.begin(); it != m_lstFavorites.end(); it++)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, it->Save( streamBuf ));
			}

			__MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, Synchronize( false ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->Events().FireEvent_FavoritesUpdate());
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        ::FlushFileBuffers( hFile );
        ::CloseHandle     ( hFile );
    }

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHFavorites::Synchronize( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Synchronize" );

	HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);


	if(fForce) Erase();

	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());

	if(m_fLoaded)
	{
		Iter                     it;
		const Taxonomy::HelpSet& ths = CPCHHelpCenterExternal::s_GLOBAL->UserSettings()->THS();


		//
		// We actually have two lists, the real one, m_lstFavorites, and the enumerator's one, m_coll.
		// So, whenever the real one changes, we need to rebuild the one held by the enumerator.
		//
		CPCHFavorites_Parent::Erase();
		for(it = m_lstFavorites.begin(); it != m_lstFavorites.end(); it++)
		{
			CPCHHelpSessionItem* data = it->m_Data;

			if(data->SameSKU( ths ))
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, AddItem( data ));
			}
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHFavorites::IsDuplicate( /*[in]*/ 		   BSTR          bstrURL ,
										 /*[out, retval]*/ VARIANT_BOOL *pfDup   )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::IsDuplicate" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
	const Taxonomy::HelpSet&     ths = CPCHHelpCenterExternal::s_GLOBAL->UserSettings()->THS();
	Iter                         it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pfDup,VARIANT_FALSE);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());

    for(it = m_lstFavorites.begin(); it != m_lstFavorites.end(); it++)
    {
		CPCHHelpSessionItem* data = it->m_Data;

		if(data->SameSKU( ths     ) &&
		   data->SameURL( bstrURL )  )
		{
			*pfDup = VARIANT_TRUE;
			break;
		}
	}

							   
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHFavorites::Add( /*[in]*/ 		   BSTR                  bstrURL ,
								 /*[in,optional]*/ VARIANT               vTitle  ,
								 /*[out, retval]*/ IPCHHelpSessionItem* *ppItem  )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Add" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
	CPCHProxy_IPCHUserSettings2* us = CPCHHelpCenterExternal::s_GLOBAL->UserSettings();
	CPCHHelpSessionItem*         data;
	CComBSTR                     bstrTitleInfer;
	BSTR                         bstrTitle;
	Iter                         it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());


	if(vTitle.vt == VT_BSTR)
	{
		bstrTitle = vTitle.bstrVal;
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->HelpSession()->LookupTitle( bstrURL, bstrTitleInfer, /*fUseCache*/false ));

		bstrTitle = bstrTitleInfer;
	}


	if(bstrTitle == NULL || bstrTitle[0] == 0) bstrTitle = bstrURL; // We need some sort of title.


	it = m_lstFavorites.insert( m_lstFavorites.end() );
	__MPC_EXIT_IF_METHOD_FAILS(hr, it->Init());

	data = it->m_Data;

	data->put_THS( us->THS() );

	__MPC_EXIT_IF_METHOD_FAILS(hr, data->put_URL  ( bstrURL   ));
	__MPC_EXIT_IF_METHOD_FAILS(hr, data->put_Title( bstrTitle ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());
							   
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHFavorites::Rename( /*[in]*/ BSTR                 bstrTitle ,
									/*[in]*/ IPCHHelpSessionItem* pItem     )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Rename" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
	Iter                         it;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrTitle);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());


	__MPC_EXIT_IF_METHOD_FAILS(hr, FindEntry( pItem, it ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, it->m_Data->put_Title( bstrTitle ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());
							   
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHFavorites::Move( /*[in]*/ IPCHHelpSessionItem* pInsertBefore ,
								  /*[in]*/ IPCHHelpSessionItem* pItem         )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Move" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
	CPCHHelpSessionItem*         data = NULL;
	Iter                         itBefore;
	Iter                         itOld;
	Iter                         itNew;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());


	//
	// If an element is passed, then we insert before it, otherwise we insert at the end.
	//
	if(pInsertBefore)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, FindEntry( pInsertBefore, itBefore ));
	}
	else
	{
		itBefore = m_lstFavorites.end();
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, FindEntry( pItem, itOld ));

	//
	// Trying to move the element on itself.
	//
	if(itOld == itBefore)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
	}
		
	//
	// Save pointer to data, erase old item, create a new one and restore pointer.
	//
	data = itOld->m_Data; data->AddRef();

	        m_lstFavorites.erase ( itOld    );
	itNew = m_lstFavorites.insert( itBefore );

	itNew->m_Data = data; data = NULL;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());
							   
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	MPC::Release( data );
	
	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHFavorites::Delete( /*[in]*/ IPCHHelpSessionItem* pItem )
{
    __HCP_FUNC_ENTRY( "CPCHFavorites::Delete" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock(this);
	Iter                         it;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Load());


	__MPC_EXIT_IF_METHOD_FAILS(hr, FindEntry( pItem, it ));


	m_lstFavorites.erase( it );

	__MPC_EXIT_IF_METHOD_FAILS(hr, Synchronize( false ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, Save());
							   
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\intercom\server\safintercomserver.cpp ===
// SAFIntercomServer.cpp : Implementation of CSAFIntercomServer
#include "stdafx.h"

// This is the PORT that we are using for the DPlayVoice connection
//#define SAFINTERCOM_PORT 4000

// *************************************************************
// This GUID is defined for the sake of DPlay8Peer!
// *************************************************************

// {4FE80EF4-AD10-45bd-B6EB-0B7BFB95155F}
static const GUID g_guidApplication = 
{ 0x4fe80ef4, 0xad10, 0x45bd, { 0xb6, 0xeb, 0xb, 0x7b, 0xfb, 0x95, 0x15, 0x5f } };

/////////////////////////////////////////////////////////////////////////////
// CSAFIntercomServer

// 
// Constructor
//
CSAFIntercomServer::CSAFIntercomServer()
{
	m_dwSinkCookie	= 0x0;
	m_bInit			= FALSE;
	m_bAdvised		= FALSE;
	m_bRTCInit		= FALSE;
	m_bOnCall		= FALSE;
	m_iSamplingRate = 1;			// Set the sampling rate to start at low
}

//
// Destructor
//
CSAFIntercomServer::~CSAFIntercomServer()
{
	DebugLog(L"CSAFIntercomServer Destructor!\r\n");

	Cleanup();
}


STDMETHODIMP CSAFIntercomServer::Event(RTC_EVENT RTCEvent, IDispatch * pEvent)
{
	HRESULT hr = S_OK;

	CComPtr<IRTCSessionStateChangeEvent>	pSessEvent;
	CComPtr<IRTCMediaEvent>					pMedEvent;
	CComPtr<IRTCSession>					pSession;


    HRESULT             ResCode;
    RTC_SESSION_STATE   State;  
    
    switch(RTCEvent)
    {
    case RTCE_SESSION_STATE_CHANGE:

        hr = pEvent ->QueryInterface(IID_IRTCSessionStateChangeEvent, 
            (void **)&pSessEvent);

        if(FAILED(hr))
        {
            return hr;
        }
    
        pSessEvent->get_StatusCode(&ResCode);
        pSessEvent->get_State(&State);

        pSessEvent->get_Session(&pSession);

        hr = OnSessionChange(pSession, State, ResCode);

        pSessEvent.Release();
        if(pSession)
        {
            pSession.Release();
        }

        break;
/*
	case RTCE_MEDIA:

		hr = pEvent->QueryInterface(IID_IRTCMediaEvent, (void **)&pMedEvent);

		if (FAILED(hr))
		{
			DebugLog(L"Could not get IID_IRTCMediaEvent!\r\n");
			return hr;
		}

		hr = MediaEvent(pMedEvent);

		if (FAILED(hr))
		{
			pMedEvent.Release();
		}

		break;
*/ 
	}
 
	return hr;
}

/*
HRESULT CSAFIntercomServer::MediaEvent(IRTCMediaEvent * pMedEvent)
{
	HRESULT hr = S_OK;

	long						lMediaType;
	RTC_MEDIA_EVENT_TYPE		EventType;
	RTC_MEDIA_EVENT_REASON		EventReason;

	// Get all the values for this Event
	pMedEvent->get_MediaType(&lMediaType);
	pMedEvent->get_EventType(&EventType);
	pMedEvent->get_EventReason(&EventReason);

	// Make sure we are talking about audio
	if (!(
		  ( lMediaType & RTCMT_AUDIO_SEND    ) | // Send 
		  ( lMediaType & RTCMT_AUDIO_RECEIVE )
		 )
	   )
	{
		// Don't handle it since it's not an audio event
		return S_OK;
	}

	switch (EventType)
	{
	case RTCMET_STOPPED:

		// Check to see if we have stopped because of a timeout
		// SPECIAL CASE:  
		//      This is the case where we are in front of a firewall

		if (EventReason == RTCMER_TIMEOUT)
		{
			// Disable Voice 
			Fire_onVoiceDisabled(this);
		}

		break;
		
	case RTCMET_FAILED:

		// Disable voice, something happened to the connection
		// Special Case:
		//	    This COULD be the case where one person is GUEST
		Fire_onVoiceDisabled(this);

		break;

	}

	return hr;
}
*/

STDMETHODIMP CSAFIntercomServer::OnSessionChange(IRTCSession *pSession, 
												  RTC_SESSION_STATE nState, 
												  HRESULT ResCode)
{
    HRESULT hr = S_OK;
    int iRet;

	switch (nState)
    {
    case RTCSS_INCOMING:

		if (m_bOnCall)
		{
			// We are on a call, reject
			pSession->Terminate(RTCTR_BUSY);

			return S_OK;
		}

		m_pRTCSession = pSession;		// Make the incoming the active session

		// Set the key on the server side
		if (FAILED(hr = m_pRTCSession->put_EncryptionKey(RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE,
														m_bstrKey)))
		{
			DebugLog(L"put_EncryptionKey failed!\r\n");
			return hr;
		}

		m_pRTCSession->Answer();

		return S_OK;

        break;

	case RTCSS_CONNECTED:

		Fire_onVoiceConnected(this);

		m_bOnCall = TRUE;

		break;
    case RTCSS_DISCONNECTED:

		if (m_pRTCSession)
		{
			Fire_onVoiceDisconnected(this);
		}

		m_bOnCall = FALSE;

		if (m_pRTCSession)
		{
			m_pRTCSession.Release();
		}

		return S_OK;

		break;
    }

	return hr;
}


STDMETHODIMP CSAFIntercomServer::Listen(/* out, retval */ BSTR * pVal)
{

	HRESULT hr = S_OK;
	VARIANT_BOOL vbRun;
	long flags;

	/*
	if (m_bInit)
	{
		DebugLog(L"Cannot call Listen(...) twice\r\n");
		return E_FAIL;
	}
	*/

	// Initialize the Server
	if (FAILED(hr = Init()))
	{
		DebugLog(L"Call to Init() failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Get media capabilities.  
	// Question: Do we have audio send and receive capabilities on this machine?
	if (FAILED( hr = m_pRTCClient->get_MediaCapabilities(&flags)))
	{
		DebugLog(L"Call to get_MediaCapabilities failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Check results
	if ( !(flags & ( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE )) )
	{
		DebugLog(L"This machine does not have audio capabilites, Voice is Disabled!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// If we have never run the Audio wizard, run it now
	if (FAILED( hr = m_pRTCClient->get_IsTuned(&vbRun)))
	{
		DebugLog(L"Call to IsTuned failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	VARIANT_BOOL	vbTCP				= VARIANT_FALSE;
	VARIANT_BOOL	vbExternal			= VARIANT_TRUE;
	VARIANT			vsaAddresses;
	VARIANT			vsaIntAddresses;

	MPC::WStringList	listIPs;
	MPC::WStringIter	listIPIter;

	CComBSTR			bstrTemp;

	// Grab the IP SAFEARRAY from the RTC object
	if (FAILED( hr = m_pRTCClient->get_NetworkAddresses(vbTCP, vbExternal, &vsaAddresses)))
	{
		DebugLog(L"call to get_NetworkAddresses failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// TODO: Convert the SAFEARRAY to a list of wstrings
	if (FAILED(hr = MPC::ConvertSafeArrayToList(vsaAddresses, listIPs)))
	{
		DebugLog(L"call to ConvertSafeArrayToList failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// If there are no EDGE/NAT Boxes in front of us, lets get our intenal IP
	if (listIPs.size() == 0)
	{
		vbExternal = VARIANT_FALSE;

		if (FAILED( hr = m_pRTCClient->get_NetworkAddresses(vbTCP, vbExternal, &vsaIntAddresses)))
		{
			DebugLog(L"call to get_NetworkAddresses failed (Internal)\r\n");
			Fire_onVoiceDisabled(this);
			return hr;
		}

		if (FAILED( hr = MPC::ConvertSafeArrayToList(vsaIntAddresses, listIPs)))
		{
			DebugLog(L"call to ConvertSafeArrayToList failed!\r\n");
			Fire_onVoiceDisabled(this);
			return hr;
		}


	}
	else
		DebugLog(L"VOIP behind a NAT!\r\n");

	if (VARIANT_FALSE == vbRun)
	{
		if (FAILED(hr = RunSetupWizard()))
		{
			DebugLog(L"Call to RunSetupWizard() failed!\r\n");
			return hr;
		}
	}

	m_bInit = TRUE;

	// Place the Key in the front of the string
	bstrTemp = m_bstrKey;

	// append all the ip:port's to the key string 
	for(listIPIter = listIPs.begin(); listIPIter != listIPs.end(); listIPIter++)
	{
		bstrTemp += L";";
		bstrTemp += (*listIPIter).c_str();
	}


	// Note: m_bstrKey could be changed by calling RunSetupWizard, thus set the return
	// value now (at the end of this function)
	*pVal = bstrTemp.Copy();
			
	return S_OK;
}


STDMETHODIMP CSAFIntercomServer::Disconnect()
{
	// TODO: make sure we handle the case where we are shutting down.  
	// Find out if we care about RTCSHUTDOWN

	HRESULT hr;

	if (!m_bOnCall)
	{
		DebugLog(L"Must be on a call to call Disconnect!\r\n");

		return E_FAIL;
	}

	if (m_pRTCSession)
	{
		if (FAILED( hr = m_pRTCSession->Terminate(RTCTR_NORMAL)))
		{
			DebugLog(L"Terminate off of the Session object failed!\r\n");

			return hr;
		}

		m_pRTCSession.Release();

	}

	return S_OK;
}

//
// This method is used to Unadvise the RTCClient object of us (CSAFIntercomServer)
//
STDMETHODIMP CSAFIntercomServer::Exit()
{

	HRESULT hr;

	DebugLog(L"Inside CSAFIntercomServer::Exit()\r\n");

	// Unadvise IRTCClient of the sink
	if (m_bAdvised)
	{
		AtlUnadvise((IUnknown *)m_pRTCClient, IID_IRTCEventNotification, m_dwSinkCookie);
	}

	return S_OK;
}


HRESULT CSAFIntercomServer::RunSetupWizard()
{
	HRESULT hr = S_OK;
	long flags;

	// Setup
	if (FAILED(hr = Init()))
	{
		DebugLog(L"Call to Init() failed!\r\n");

		Fire_onVoiceDisabled(this);
		return hr;
	}

	if (FAILED(hr = m_pRTCClient->InvokeTuningWizard(NULL)))
	{
		DebugLog(L"InvokeTuningWizard FAILED!\r\n");	
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Get media capabilities.  If the wizard failed to detect sound we can 
	// disable Voice

	if (FAILED( hr = m_pRTCClient->get_MediaCapabilities(&flags)))
	{
		DebugLog(L"Call to get_MediaCapabilities failed!\r\n");
		Fire_onVoiceDisabled(this);
		return hr;
	}

	// Check results
	if ( !(flags & ( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE )) )
	{
		DebugLog(L"This machine does not have audio capabilites, Voice is Disabled!\r\n");
		Fire_onVoiceDisabled(this);
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CSAFIntercomServer::Init()
{
	HRESULT hr = S_OK;
	
	CComPtr<IUnknown> pUnkThis;
	
	// First Generate the Key
	if (ERROR_SUCCESS != GenerateRandomString(32, &m_bstrKey))
	{
		DebugLog(L"GenerateRandomString Failed!\r\n");
		return E_FAIL;
	}	
	
	// Once the object exists, do nothing
	if (!m_pRTCClient)
	{
		DWORD dwProfileFlags;

		// Check to see if we have a temporary profile
		if(GetProfileType( &dwProfileFlags ))
		{
			if (dwProfileFlags & PT_TEMPORARY)
			{
				return E_FAIL;
			}
		}
		
		// Create the RTCClient object
		if (FAILED(hr = m_pRTCClient.CoCreateInstance(CLSID_RTCClient)))
		{
			DebugLog(L"Could not create the RTCClient object\r\n");
			return hr;
		}
		
		
		if (FAILED(hr = m_pRTCClient->Initialize()))
		{
			DebugLog(L"Call to Initialize on the RTCClient object failed!\r\n");
			return hr;
		}
		
		// Set the sampling bit rate (it may be different because of changes in the property)
		if (m_iSamplingRate == 1)
		{
			if (FAILED(hr = m_pRTCClient->put_MaxBitrate(6400)))
			{
				DebugLog(L"put_MaxBitrate failed!\r\n");
			}
		}
		else
		{
			if (FAILED(hr = m_pRTCClient->put_MaxBitrate(64000)))
			{
				DebugLog(L"put_MaxBitrate failed!\r\n");
			}
		}
		
		// Since we have Initialized the RTCClient, enable the flag
		m_bRTCInit = TRUE;
		
		
		if (FAILED(hr = m_pRTCClient->SetPreferredMediaTypes( RTCMT_AUDIO_SEND | RTCMT_AUDIO_RECEIVE,
			FALSE )))
		{
			DebugLog(L"Call to SetPreferredMediaType failed!\r\n");
			
			return hr;
		}
		
		// Get the IUnknown of the 'this' ptr
		if (FAILED( hr = this->QueryInterface(IID_IUnknown, (void **)&pUnkThis)))
		{
			DebugLog(L"QueryInterface for IUnknown failed!\r\n");
			
			return hr;
		}
		
		// Advise IRTCClient of the sink
		if (FAILED( hr = m_pRTCClient.Advise( pUnkThis, IID_IRTCEventNotification, &m_dwSinkCookie)))
		{
			DebugLog(L"AtlAdvise failed!\r\n");
			
			return hr;
		}
		
		m_bAdvised = TRUE;
		
		// TODO: Verify about RTCLM_BOTH
		if (FAILED( hr = m_pRTCClient->put_ListenForIncomingSessions(RTCLM_BOTH)))
		{
			DebugLog(L"Set ListenForIncomingSessions property failed!\r\n");
			
			return hr;
		}
		
	}
	return hr;
}

HRESULT CSAFIntercomServer::Cleanup()
{
	HRESULT hr = S_OK;
	
	// Shutdown if needed
	if (m_bRTCInit)
	{
		m_pRTCClient->Shutdown();
	}

	// Unadvise IRTCClient of the sink
	if (m_bAdvised)
	{
		AtlUnadvise((IUnknown *)m_pRTCClient, IID_IRTCEventNotification, m_dwSinkCookie);
	}

	// Now release all the interfaces we used
	if (m_pRTCSession)
	{
		m_pRTCSession.Release();
	}

	if (m_pRTCClient)
	{
		m_pRTCClient.Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CSAFIntercomServer::Fire_onVoiceConnected( ISAFIntercomServer * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INSE__ONDISCONNECTED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceConnected );
}

HRESULT CSAFIntercomServer::Fire_onVoiceDisconnected( ISAFIntercomServer * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INSE__ONDISCONNECTED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceDisconnected );
}

HRESULT CSAFIntercomServer::Fire_onVoiceDisabled( ISAFIntercomServer * safi)
{
    CComVariant pvars[1];

    pvars[0] = safi;
    
    return FireAsync_Generic( DISPID_PCH_INSE__ONVOICEDISABLED, pvars, ARRAYSIZE( pvars ), m_sink_onVoiceDisabled );

}
//////////////////////////
//                      //
// Properties		    //
//                      //
//////////////////////////


STDMETHODIMP CSAFIntercomServer::put_onVoiceConnected( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomServer::put_onVoiceConnected",hr);

    m_sink_onVoiceConnected = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomServer::put_onVoiceDisconnected( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomServer::put_onVoiceDisconnected",hr);

    m_sink_onVoiceDisconnected = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomServer::put_onVoiceDisabled( /*[in]*/ IDispatch* function)
{
    __HCP_BEGIN_PROPERTY_PUT("CSAFIntercomServer::put_onVoiceDisconnected",hr);

    m_sink_onVoiceDisabled = function;

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomServer::put_SamplingRate ( /*[in]*/ LONG newVal)
{
	__HCP_BEGIN_PROPERTY_PUT("CSAFIntercomServer::put_SamplingRate", hr);
	
	hr = S_OK;

	// Make sure that the newVal is correct
	if ((newVal == 1) || (newVal == 2))
	{
		// If m_pRTCClient doesn't exist then persist the m_iSamplingRate for when it is created
		m_iSamplingRate = newVal;

		if (m_pRTCClient)
		{
			// Set the MaxBitRates on the client, because it exists (m_pRTCClient)
			if (m_iSamplingRate == 1)
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(6400)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
			else
			{
				if (FAILED(hr = m_pRTCClient->put_MaxBitrate(64000)))
				{
					DebugLog(L"put_MaxBitrate failed!\r\n");
				}
			}
		}
		
	}
	else
	{
		hr = E_INVALIDARG;
	}

	__HCP_END_PROPERTY(hr);
}

STDMETHODIMP CSAFIntercomServer::get_SamplingRate (/*[out, retval]*/ LONG * pVal  )
{
	__HCP_BEGIN_PROPERTY_GET("CSAFIntercomServer::put_SamplingRate", hr, pVal);

	*pVal = m_iSamplingRate;

	hr = S_OK;

	__HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

DWORD
CSAFIntercomServer::GenerateRandomBytes(
    IN DWORD dwSize,
    IN OUT LPBYTE pbBuffer
    )
/*++

Description:

    Generate fill buffer with random bytes.

Parameters:

    dwSize : Size of buffer pbBuffer point to.
    pbBuffer : Pointer to buffer to hold the random bytes.

Returns:

    TRUE/FALSE

--*/
{
    HCRYPTPROV hProv = NULL;
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Create a Crypto Provider to generate random number
    //
    if( !CryptAcquireContext(
                    &hProv,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                ) )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    if( !CryptGenRandom(hProv, dwSize, pbBuffer) )
    {
        dwStatus = GetLastError();
    }

CLEANUPANDEXIT:    

    if( NULL != hProv )
    {
        CryptReleaseContext( hProv, 0 );
    }

    return dwStatus;
}


DWORD
CSAFIntercomServer::GenerateRandomString(
    IN DWORD dwSizeRandomSeed,
    IN OUT BSTR *pBstr
    )
/*++

  Generate a 

--*/
{
    PBYTE			lpBuffer = NULL;
    DWORD			dwStatus = ERROR_SUCCESS;
    BOOL			bSuccess;
    DWORD			cbConvertString = 0;
	WCHAR			*szString = NULL;
	BSTR			bstrTemp = NULL;

    if( 0 == dwSizeRandomSeed || NULL == pBstr )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    //*pBstr = NULL;

    lpBuffer = (PBYTE)LocalAlloc( LPTR, dwSizeRandomSeed );  
    if( NULL == lpBuffer )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    dwStatus = GenerateRandomBytes( dwSizeRandomSeed, lpBuffer );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    // Convert to string
    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                0,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    szString = (LPWSTR)LocalAlloc( LPTR, (cbConvertString+1)*sizeof(WCHAR) );
    if( NULL == szString )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    bSuccess = CryptBinaryToString(
                                lpBuffer,
                                dwSizeRandomSeed,
                                CRYPT_STRING_BASE64,
                                szString,
                                &cbConvertString
                            );
    if( FALSE == bSuccess )
    {
        dwStatus = GetLastError();
    }
    else
    {
        if( (szString)[cbConvertString - 1] == '\n' &&
            (szString)[cbConvertString - 2] == '\r' )
        {
            (szString)[cbConvertString - 2] = 0;
        }
    }

	// Place the string in the temp 
	bstrTemp = SysAllocString(szString);

	// Set the return value: pBstr to the BSTR that contains this generated stiring
	*pBstr = bstrTemp;

CLEANUPANDEXIT:

    if( ERROR_SUCCESS != dwStatus )
    {
        if( NULL != szString )
        {
            LocalFree(szString);
        }
    }

    if( NULL != lpBuffer )
    {
        LocalFree(lpBuffer);
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\helpcenterexternal_state.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenterExternal.cpp

Abstract:
    This file contains the implementation of the class exposed as the "pchealth" object.

Revision History:
    Ghim-Sim Chua       (gschua)   07/23/99
        created
    Davide Massarenti   (dmassare) 07/25/99
        modified

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

static const CComBSTR c_bstrPlace_Normal          ( L"Normal"      );
static const CComBSTR c_bstrPlace_FullWindow      ( L"FullWindow"  );
static const CComBSTR c_bstrPlace_ContentOnly     ( L"ContentOnly" );
static const CComBSTR c_bstrPlace_KioskMode       ( L"KioskMode"   );

static const CComBSTR c_bstrSub_Channels          ( L"hcp://system/panels/subpanels/Channels.htm"  );
static const CComBSTR c_bstrSub_Favorites         ( L"hcp://system/panels/subpanels/Favorites.htm" );
static const CComBSTR c_bstrSub_History           ( L"hcp://system/panels/subpanels/History.htm"   );
static const CComBSTR c_bstrSub_Index             ( L"hcp://system/panels/subpanels/Index.htm"     );
static const CComBSTR c_bstrSub_Options           ( L"hcp://system/panels/subpanels/Options.htm"   );
static const CComBSTR c_bstrSub_Search            ( L"hcp://system/panels/subpanels/Search.htm"    );
static const CComBSTR c_bstrSub_SubSite           ( L"hcp://system/panels/subpanels/SubSite.htm"   );

static const CComBSTR c_bstrURL_Home              ( L"hcp://system/HomePage.htm"        );
static const CComBSTR c_bstrURL_Channels          ( L"hcp://system/blurbs/isupport.htm" );
static const CComBSTR c_bstrURL_Options           ( L"hcp://system/blurbs/options.htm"  );
static const CComBSTR c_bstrURL_Fav               ( L"hcp://system/blurbs/favorites.htm");
static const CComBSTR c_bstrURL_Search            ( L"hcp://system/blurbs/searchblurb.htm");
static const CComBSTR c_bstrURL_Index             ( L"hcp://system/blurbs/index.htm"    );
static const CComBSTR c_bstrURL_History           ( L"hcp://system/blurbs/history.htm"  );

static const CComBSTR c_bstrURL_Center_Update     ( L"hcp://system/updatectr/updatecenter.htm"      );
static const CComBSTR c_bstrURL_Center_Compat     ( L"hcp://system/compatctr/CompatOffline.htm"     );
static const CComBSTR c_bstrURL_Center_ErrMsg     ( L"hcp://system/errmsg/errormessagesoffline.htm" );

static const CComBSTR c_bstrTOC_Center_Tools      ( L"_System_/Tools_Center" );

static const CComBSTR c_bstrFunc_ChangeView       ( L"onClick_ChangeView" );

static const WCHAR    c_szURL_Err_BadUrl     [] = L"hcp://system/errors/badurl.htm";
static const WCHAR    c_szURL_Err_Redirect   [] = L"hcp://system/errors/redirect.htm";
static const WCHAR    c_szURL_Err_NotFound   [] = L"hcp://system/errors/notfound.htm";
static const WCHAR    c_szURL_Err_Offline    [] = L"hcp://system/errors/offline.htm";
static const WCHAR    c_szURL_Err_Unreachable[] = L"hcp://system/errors/unreachable.htm";

static const WCHAR    c_szURL_BLANK          [] = L"hcp://system/panels/blank.htm";

////////////////////////////////////////////////////////////////////////////////

#define CTXFLG_EXPAND_CONDITIONAL     (0x00000001)
#define CTXFLG_EXPAND                 (0x00000002)
#define CTXFLG_COLLAPSE               (0x00000004)
#define CTXFLG_URL_FROM_CONTEXT       (0x00000008)
#define CTXFLG_REGISTER_CONTEXT       (0x00000010)


#define CTXFLG_NOP                    (0x00000000)
///////
#define CTXFLG_EXPAND_AND_REGISTER    (CTXFLG_EXPAND             | CTXFLG_REGISTER_CONTEXT)
#define CTXFLG_EXPAND_AND_NAVIGATE    (CTXFLG_EXPAND             | CTXFLG_URL_FROM_CONTEXT)
#define CTXFLG_COLLAPSE_AND_NAVIGATE  (CTXFLG_COLLAPSE           | CTXFLG_URL_FROM_CONTEXT)
///////
#define CTXFLG_FULL                   (CTXFLG_EXPAND_CONDITIONAL | CTXFLG_REGISTER_CONTEXT | CTXFLG_URL_FROM_CONTEXT)


struct ContextDef
{
    HscContext       iVal;

    BSTR             bstrPlace;

    HelpHost::CompId idComp;
    BSTR             bstrSubPanel;

    BSTR             bstrURL;

    DWORD            dwFlags;
};

static const ContextDef c_context[] =
{
    { HSCCONTEXT_INVALID    , NULL                   , HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_NOP                   },
    { HSCCONTEXT_STARTUP    , c_bstrPlace_FullWindow , HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_EXPAND_AND_REGISTER   },
    { HSCCONTEXT_HOMEPAGE   , c_bstrPlace_FullWindow , HelpHost::COMPID_HOMEPAGE , NULL               , c_bstrURL_Home    , CTXFLG_EXPAND_AND_REGISTER   },
    { HSCCONTEXT_CONTENT    , NULL                   , HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_URL_FROM_CONTEXT      },
    { HSCCONTEXT_SUBSITE    , c_bstrPlace_Normal     , HelpHost::COMPID_SUBSITE  , c_bstrSub_SubSite  , NULL              , CTXFLG_FULL                  },
    { HSCCONTEXT_SEARCH     , c_bstrPlace_Normal     , HelpHost::COMPID_SEARCH   , c_bstrSub_Search   , c_bstrURL_Search  , CTXFLG_FULL                  },
    { HSCCONTEXT_INDEX      , c_bstrPlace_Normal     , HelpHost::COMPID_INDEX    , c_bstrSub_Index    , c_bstrURL_Index   , CTXFLG_FULL                  },
    { HSCCONTEXT_FAVORITES  , c_bstrPlace_Normal     , HelpHost::COMPID_FAVORITES, c_bstrSub_Favorites, c_bstrURL_Fav     , CTXFLG_FULL                  },
    { HSCCONTEXT_HISTORY    , c_bstrPlace_Normal     , HelpHost::COMPID_HISTORY  , c_bstrSub_History  , c_bstrURL_History , CTXFLG_FULL                  },
    { HSCCONTEXT_CHANNELS   , c_bstrPlace_Normal     , HelpHost::COMPID_CHANNELS , c_bstrSub_Channels , c_bstrURL_Channels, CTXFLG_FULL                  },
    { HSCCONTEXT_OPTIONS    , c_bstrPlace_Normal     , HelpHost::COMPID_OPTIONS  , c_bstrSub_Options  , c_bstrURL_Options , CTXFLG_FULL                  },

    { HSCCONTEXT_CONTENTONLY, c_bstrPlace_ContentOnly, HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_COLLAPSE_AND_NAVIGATE },
    { HSCCONTEXT_FULLWINDOW , c_bstrPlace_FullWindow , HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_EXPAND_AND_NAVIGATE   },
    { HSCCONTEXT_KIOSKMODE  , c_bstrPlace_KioskMode  , HelpHost::COMPID_MAX      , NULL               , NULL              , CTXFLG_EXPAND_AND_NAVIGATE   },
};

////////////////////////////////////////////////////////////////////////////////

BSTR local_SecureURL(BSTR bstrUrl)
{

    HyperLinks::ParsedUrl pu;
    
    pu.Initialize(bstrUrl);
    
    switch (pu.m_fmt)
    {
        case HyperLinks::FMT_INTERNET_UNKNOWN   :
        case HyperLinks::FMT_INTERNET_JAVASCRIPT: 
        case HyperLinks::FMT_INTERNET_VBSCRIPT  :
            // Block potentially dangerous urls
            bstrUrl = (BSTR)c_szURL_Err_BadUrl;
            break;
        default:
            break;
    }


    return bstrUrl;
}


bool CPCHHelpCenterExternal::ProcessNavigation( /*[in]*/     HscPanel      idPanel   ,
                                                /*[in]*/     BSTR          bstrURL   ,
                                                /*[in]*/     BSTR          bstrFrame ,
                                                /*[in]*/     bool          fLoading  ,
                                                /*[in/out]*/ VARIANT_BOOL& Cancel    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ProcessNavigation" );

    HRESULT               hr;
    HyperLinks::ParsedUrl pu;
    bool                  fProceed      = true;
    bool                  fShowNormal   = false;
    bool                  fShowHTMLHELP = false;


    if(m_fPassivated || m_fShuttingDown)
    {
        Cancel   = VARIANT_TRUE;
        fProceed = false;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }


    m_dwInBeforeNavigate++;

    if(!MPC::StrICmp( bstrURL, L"about:blank" ))
    {
        fProceed = false;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Ignore Navigation.
    }


    //
    // This is the default redirection from the CONTEXT panel to the CONTENTS panel.
    //
    if(idPanel == HSCPANEL_CONTEXT)
    {
        if(!MPC::StrICmp( bstrFrame, L"HelpCtrContents" ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, SetPanelUrl( HSCPANEL_CONTENTS, bstrURL ));

            Cancel   = VARIANT_TRUE;
            fProceed = false;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Check the url and make a copy of its state.
    //
    if(m_hs->IsTravelling() == false)
    {
        HyperLinks::UrlHandle uh;

        __MPC_EXIT_IF_METHOD_FAILS(hr, HyperLinks::Lookup::s_GLOBAL->Get( bstrURL, uh, /*dwWaitForCheck*/100 ));

        if((HyperLinks::ParsedUrl*)uh) pu = *(HyperLinks::ParsedUrl*)uh;
    }
    else
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pu.Initialize( bstrURL ));
    }


    if(pu.m_fmt == HyperLinks::FMT_INTERNET_JAVASCRIPT ||
       pu.m_fmt == HyperLinks::FMT_INTERNET_VBSCRIPT    )
    {
        fProceed = false;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Ignore Navigation.
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Check for navigation/url problems.
    //
    {
        MPC::wstring strErrorURL;
        bool         fError = false;


        if(pu.m_fmt   == HyperLinks::FMT_INVALID     ||
           pu.m_state == HyperLinks::STATE_INVALID   ||
           pu.m_state == HyperLinks::STATE_MALFORMED  )
        {
            MPC::HTML::vBuildHREF( strErrorURL, c_szURL_Err_BadUrl, L"URL", bstrURL, NULL );

            fError = true;
        }
        else if(pu.m_fmt == HyperLinks::FMT_RESOURCE)
        {
            //
            // WebBrowser error redirection.
            //
            // res://C:\WINNT\System32\shdoclc.dll/dnserror.htm#file://C:\file\test.htm
            //
            MPC::wstring         strURL;
            CComBSTR             bstrURLOriginal;
            CComBSTR             bstrTitle;
            CPCHHelpSessionItem* hchsi = m_hs->Current();


            if(hchsi)
            {
                bstrURLOriginal = hchsi->GetURL();

                (void)m_hs->LookupTitle( bstrURLOriginal, bstrTitle, /*fUseIECache*/false );
            }

            MPC::HTML::vBuildHREF( strErrorURL, c_szURL_Err_Redirect, L"URL"    , bstrURL        ,
                                                                      L"FRAME"  , bstrFrame      ,
                                                                      L"REALURL", bstrURLOriginal,
                                                                      L"TITLE"  , bstrTitle      , NULL );

            fError = true;
        }
        else if(pu.m_state == HyperLinks::STATE_NOTFOUND)
        {
            CComBSTR bstrTitle; (void)m_hs->LookupTitle( bstrURL, bstrTitle, /*fUseIECache*/false );


            MPC::HTML::vBuildHREF( strErrorURL, c_szURL_Err_NotFound, L"URL"  , bstrURL  ,
                                                                      L"TITLE", bstrTitle, NULL );

            fError = true;
        }
        else if(pu.m_state == HyperLinks::STATE_UNREACHABLE)
        {
            CComBSTR bstrTitle; (void)m_hs->LookupTitle( bstrURL, bstrTitle, /*fUseIECache*/false );


            MPC::HTML::vBuildHREF( strErrorURL, c_szURL_Err_Unreachable, L"URL"  , bstrURL  ,
                                                                         L"TITLE", bstrTitle, NULL );

            fError = true;
        }
        else if(pu.m_state == HyperLinks::STATE_OFFLINE)
        {
            CComBSTR bstrTitle; (void)m_hs->LookupTitle( bstrURL, bstrTitle, /*fUseIECache*/false );


            MPC::HTML::vBuildHREF( strErrorURL, c_szURL_Err_Offline, L"URL"  , bstrURL  ,
                                                                     L"TITLE", bstrTitle, NULL );

            fError = true;
        }

        if(fError)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, SetPanelUrl( HSCPANEL_CONTENTS, strErrorURL.c_str() ));

            fProceed = false;
            Cancel   = VARIANT_TRUE;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(pu.m_fmt == HyperLinks::FMT_MSITS)
    {
        //
        // Not in the right context, redirect to the HH wrapper.
        //
        if(idPanel != HSCPANEL_HHWINDOW)
        {
            if(!m_panel_HHWINDOW_Wrapper)
            {
                //
                // Force loading of the HHWindow.
                //
                CComPtr<IMarsPanel> panel;

                __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( HSCPANEL_HHWINDOW, &panel, true ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, NavigateHH( pu.m_strURL.c_str() ));

            fProceed      = false;
            fShowHTMLHELP = true;
            Cancel        = VARIANT_TRUE;
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    switch(pu.m_fmt)
    {
    case HyperLinks::FMT_CENTER_HOMEPAGE   :
    case HyperLinks::FMT_CENTER_SUPPORT    :
    case HyperLinks::FMT_CENTER_OPTIONS    :
    case HyperLinks::FMT_CENTER_UPDATE     :
    case HyperLinks::FMT_CENTER_COMPAT     :
    case HyperLinks::FMT_CENTER_TOOLS      :
    case HyperLinks::FMT_CENTER_ERRMSG     :
    case HyperLinks::FMT_SEARCH            :
    case HyperLinks::FMT_INDEX             :
    case HyperLinks::FMT_SUBSITE           :
    case HyperLinks::FMT_LAYOUT_FULLWINDOW :
    case HyperLinks::FMT_LAYOUT_CONTENTONLY:
    case HyperLinks::FMT_LAYOUT_KIOSK      :
    case HyperLinks::FMT_LAYOUT_XML        :
    case HyperLinks::FMT_REDIRECT          :
    case HyperLinks::FMT_APPLICATION       :
        m_hs->CancelNavigation();
        break;
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_HOMEPAGE)
    {
        if(SUCCEEDED(ChangeContext( HSCCONTEXT_HOMEPAGE )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_SUPPORT)
    {
        CComBSTR bstrCtx_URL ; (void)pu.GetQueryField( L"topic", bstrCtx_URL  );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_CHANNELS, NULL, local_SecureURL(bstrCtx_URL)  )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_OPTIONS)
    {
        CComBSTR bstrCtx_URL ; (void)pu.GetQueryField( L"topic", bstrCtx_URL  );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_OPTIONS, NULL, local_SecureURL(bstrCtx_URL)  )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_UPDATE)
    {
        if(SUCCEEDED(ChangeContext( HSCCONTEXT_FULLWINDOW, NULL, c_bstrURL_Center_Update )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_COMPAT)
    {
        if(SUCCEEDED(ChangeContext( HSCCONTEXT_FULLWINDOW, NULL, c_bstrURL_Center_Compat )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_TOOLS)
    {
        CComBSTR bstrCtx_URL ; (void)pu.GetQueryField( L"topic", bstrCtx_URL );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_SUBSITE, c_bstrTOC_Center_Tools, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_CENTER_ERRMSG)
    {
        if(SUCCEEDED(ChangeContext( HSCCONTEXT_FULLWINDOW, NULL, c_bstrURL_Center_ErrMsg )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(pu.m_fmt == HyperLinks::FMT_SEARCH)
    {
        CComBSTR bstrCtx_Info; (void)pu.GetQueryField( L"query", bstrCtx_Info );
        CComBSTR bstrCtx_URL ; (void)pu.GetQueryField( L"topic", bstrCtx_URL  );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_SEARCH, bstrCtx_Info, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_INDEX)
    {
        CComBSTR bstrCtx_Info; (void)pu.GetQueryField( L"scope", bstrCtx_Info );
        CComBSTR bstrCtx_URL ; (void)pu.GetQueryField( L"topic", bstrCtx_URL   );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_INDEX, bstrCtx_Info, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_SUBSITE)
    {
        CComBSTR bstrCtx_Info ; (void)pu.GetQueryField( L"node"  , bstrCtx_Info  );
        CComBSTR bstrCtx_URL  ; (void)pu.GetQueryField( L"topic" , bstrCtx_URL   );
        CComBSTR bstrCtx_Extra; (void)pu.GetQueryField( L"select", bstrCtx_Extra );

        if(bstrCtx_Extra)
        {
            bstrCtx_Info += L" ";
            bstrCtx_Info += bstrCtx_Extra;
        }

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_SUBSITE, bstrCtx_Info, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(pu.m_fmt == HyperLinks::FMT_LAYOUT_FULLWINDOW)
    {
        CComBSTR bstrCtx_URL; (void)pu.GetQueryField( L"topic", bstrCtx_URL );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_FULLWINDOW, NULL, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_LAYOUT_CONTENTONLY)
    {
        CComBSTR bstrCtx_URL; (void)pu.GetQueryField( L"topic", bstrCtx_URL );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_CONTENTONLY, NULL, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_LAYOUT_KIOSK)
    {
        CComBSTR bstrCtx_URL; (void)pu.GetQueryField( L"topic", bstrCtx_URL );

        if(SUCCEEDED(ChangeContext( HSCCONTEXT_KIOSKMODE, NULL, local_SecureURL(bstrCtx_URL) )))
        {
        }

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_LAYOUT_XML)
    {
        // Not valid after startup....

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(pu.m_fmt == HyperLinks::FMT_REDIRECT)
    {
        CComBSTR bstrCtx_URL; (void)pu.GetQueryField( L"online", bstrCtx_URL );

        {
            HyperLinks::UrlHandle uh;

            __MPC_EXIT_IF_METHOD_FAILS(hr, HyperLinks::Lookup::s_GLOBAL->Get( bstrCtx_URL, uh, /*dwWaitForCheck*/HC_TIMEOUT_DESTINATIONREACHABLE ));

            //
            // If there's a problem with the online URL, let's use the offline one.
            //
            if(uh->IsOkToProceed() == false)
            {
                (void)pu.GetQueryField( L"offline", bstrCtx_URL );
            }
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, SetPanelUrl( HSCPANEL_CONTENTS, local_SecureURL(bstrCtx_URL) ));

        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    if(pu.m_fmt == HyperLinks::FMT_APPLICATION)
    {
        fProceed = false;
        Cancel   = VARIANT_TRUE;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(fLoading == false)
    {
        if(SUCCEEDED(m_Events.FireEvent_BeforeNavigate( bstrURL, bstrFrame, idPanel, &Cancel )))
        {
            if(Cancel == VARIANT_TRUE)
            {
                fProceed = false;
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(!fShowNormal && !fShowHTMLHELP && Cancel != VARIANT_TRUE)
    {
        //
        // No context selected, pick one based on the panel.
        //
        if(idPanel == HSCPANEL_HHWINDOW)
        {
            fShowHTMLHELP = true;
        }
        else if(idPanel == HSCPANEL_CONTENTS)
        {
            fShowNormal = true;
        }
    }

    (void)SetCorrectContentPanel( fShowNormal, fShowHTMLHELP, /*fNow*/false );

    //
    // Workaround for interception VK_BACK navigations.
    //
    if(fProceed == true)
    {
        if(m_hs->IsPossibleBack())
        {
            fProceed = false;
            Cancel   = VARIANT_TRUE;

            (void)m_hs->Back( 1 );
        }
    }

    m_dwInBeforeNavigate--;

    __HCP_FUNC_EXIT(fProceed);
}

////////////////////////////////////////////////////////////////////////////////

////HRESULT CPCHHelpCenterExternal::ExecCommand_Window( /*[in]*/ HCAPI::CmdData& cd )
////{
////    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ExecCommand_Window" );
////
////    HRESULT hr;
////
////
////    if(m_hwnd)
////    {
////        if(cd.m_fSize)
////        {
////            if(cd.m_lWidth  < 200) cd.m_lWidth  = 200;
////            if(cd.m_lHeight < 300) cd.m_lHeight = 300;
////
////            __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetWindowPos( m_hwnd       ,
////                                                                 NULL         ,
////                                                                 cd.m_lX      ,
////                                                                 cd.m_lY      ,
////                                                                 cd.m_lWidth  ,
////                                                                 cd.m_lHeight ,
////                                                                 SWP_NOZORDER ));
////        }
////
////        if(cd.m_fWindow)
////        {
////            if(cd.m_hwndParent)
////            {
////                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetWindowPos( m_hwnd                  ,
////                                                                     cd.m_hwndParent         ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     SWP_NOMOVE | SWP_NOSIZE ));
////            }
////        }
////
////        if(cd.m_fMode)
////        {
////            if(cd.m_dwFlags & HCAPI_MODE_ALWAYSONTOP)
////            {
////                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetWindowPos( m_hwnd                  ,
////                                                                     HWND_TOPMOST            ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     0                       ,
////                                                                     SWP_NOMOVE | SWP_NOSIZE ));
////            }
////        }
////    }
////
////    hr = S_OK;
////
////
////    __HCP_FUNC_CLEANUP;
////
////    __HCP_FUNC_EXIT(hr);
////}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::RequestShutdown()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RequestShutdown" );

    HRESULT              hr;
    VARIANT_BOOL         Cancel;
    CPCHHelpSessionItem* hchsi;


    if(m_fHidden == false)
    {
        if(SUCCEEDED(m_Events.FireEvent_Shutdown( &Cancel )))
        {
            if(Cancel == VARIANT_TRUE)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED); // Cancel close...
            }
        }

        if(m_hs) (void)m_hs->ForceHistoryPopulate();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static void local_HideDocument( /*[in]*/ IWebBrowser2* wb )
{
    CComPtr<IDispatch>      disp;
    CComPtr<IHTMLDocument3> doc;

    if(SUCCEEDED(wb->get_Document( &disp )) && disp)
    {
        if(SUCCEEDED(disp.QueryInterface( &doc )))
        {
            CComPtr<IHTMLElement> body;

            if(SUCCEEDED(doc->get_documentElement( &body )) && body)
            {
                MPC::HTML::IHTMLElementList lst;
                MPC::HTML::IHTMLElementIter it;

                if(SUCCEEDED(MPC::HTML::EnumerateElements( lst, body )))
                {
                    for(it = lst.begin(); it != lst.end(); it++)
                    {
                        CComPtr<IHTMLStyle> style;

                        if(SUCCEEDED((*it)->get_style( &style )) && style)
                        {
                            (void)style->put_display( CComBSTR( L"NONE" ) );
                        }
                    }
                }

                MPC::ReleaseAll( lst );
            }
        }
    }
}

HRESULT CPCHHelpCenterExternal::ChangeContext( /*[in]*/ HscContext iVal         ,
                                               /*[in]*/ BSTR       bstrInfo     ,
                                               /*[in]*/ BSTR       bstrURL      ,
                                               /*[in]*/ bool       fAlsoContent )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ChangeContext" );

    HRESULT           hr;
    const ContextDef* ptr;
    CComBSTR          bstrPage;
    bool              fFromHomePage = false;
    bool              fToHomePage   = false;


    //
    // If we are minimized, undo it and bring the window to the foreground.
    //
    if(iVal == HSCCONTEXT_CONTENT && m_hwnd && ::IsIconic( m_hwnd ) && m_shell)
    {
        (void)m_shell->put_minimized( VARIANT_FALSE );

        ::SetForegroundWindow( m_hwnd );
    }

    if(iVal == HSCCONTEXT_CONTENT)
    {
        VARIANT_BOOL Cancel = VARIANT_FALSE;

        if(ProcessNavigation( HSCPANEL_CONTENTS ,
                              bstrURL           ,
                              NULL              ,
                              false             ,
                              Cancel            ) == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    //
    // Delayed execution if inside OnBeforeNavigate.
    //
    if(m_dwInBeforeNavigate)
    {
        DelayedExecution& de = DelayedExecutionAlloc();

        de.mode          = DELAYMODE_CHANGECONTEXT;
        de.iVal          = iVal;
        de.bstrInfo      = bstrInfo;
        de.bstrURL       = bstrURL;
        de.fAlsoContent  = fAlsoContent;

        __MPC_SET_ERROR_AND_EXIT(hr, DelayedExecutionStart());
    }

    ////////////////////////////////////////////////////////////////////////////////

    if(iVal == HSCCONTEXT_STARTUP)
    {
        if(STRINGISPRESENT(m_bstrStartURL))
        {
            bstrPage.Attach( m_bstrStartURL.Detach() );
        }
        else
        {
            iVal = HSCCONTEXT_HOMEPAGE;
        }
    }
    else if(STRINGISPRESENT(m_bstrCurrentPlace))
    {
        if(STRINGISPRESENT(m_bstrStartURL))
        {
            bstrPage.Attach( m_bstrStartURL.Detach() );
            fAlsoContent = true;
        }
    }

    if(m_hs)
    {
        CPCHHelpSessionItem* item = m_hs->Current();

        if(item && item->GetContextID() == HSCCONTEXT_HOMEPAGE)
        {
            fFromHomePage = true;
        }
    }

    if(iVal == HSCCONTEXT_HOMEPAGE)
    {
        fToHomePage = true;
    }

    ////////////////////////////////////////////////////////////////////////////////

    {
        VARIANT_BOOL Cancel;

        if(SUCCEEDED(m_Events.FireEvent_BeforeContextSwitch( iVal, bstrInfo, bstrURL, &Cancel )))
        {
            if(Cancel == VARIANT_TRUE)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Navigation aborted.
            }
        }
    }

    ptr = c_context;
    for(int i=0; i<ARRAYSIZE(c_context); i++, ptr++)
    {
        if(ptr->iVal == iVal)
        {
            DWORD dwFlags   = ptr->dwFlags;
            BSTR  bstrPlace = ptr->bstrPlace;

            //
            // Always register the context if we don't have a place (it means we are starting up).
            //
            if(!STRINGISPRESENT(m_bstrCurrentPlace))
            {
                dwFlags |= CTXFLG_REGISTER_CONTEXT;
            }

            //
            // If we are not displayed (m_bstrCurrentPlace not set), force a transition to a default place.
            //
            if(!STRINGISPRESENT(bstrPlace) && !STRINGISPRESENT(m_bstrCurrentPlace))
            {
                bstrPlace = c_bstrPlace_FullWindow;
            }


            if(ptr->bstrURL)
            {
                bstrPage = ptr->bstrURL;
            }

            if((dwFlags & CTXFLG_URL_FROM_CONTEXT) && STRINGISPRESENT(bstrURL))
            {
                bstrPage = bstrURL;
            }

            //
            // When we go to KIOSKMODE, disable window size management.
            //
            if(iVal == HSCCONTEXT_KIOSKMODE)
            {
                m_pMTP->dwFlags &= ~MTF_MANAGE_WINDOW_SIZE;
            }

            if(iVal == HSCCONTEXT_SUBSITE && !STRINGISPRESENT(bstrPage))
            {
                CComPtr<CPCHProxy_IPCHTaxonomyDatabase> db;
                CComBSTR                                bstrNode;
                CComBSTR                                bstrNodeSelect;
                CComBSTR                                bstrNodeURL;
                BSTR                                    bstrToLookup = NULL;
                long                                    lNavModel;
                long                                    lCount;

                //
                // For subsite, we pass both the root node, the node to select and the URL of the topic, separated by spaces.
                //
                {
                    LPWSTR szEnd;

                    bstrNode = bstrInfo;
                    if(STRINGISPRESENT(bstrNode))
                    {
                        bstrToLookup = bstrNode;

                        szEnd = wcschr( bstrNode, ' ' );
                        if(szEnd)
                        {
                            *szEnd++ = 0;

                            bstrNodeSelect = szEnd;
                            if(STRINGISPRESENT(bstrNodeSelect))
                            {
                                bstrToLookup = bstrNodeSelect;

                                szEnd = wcschr( bstrNodeSelect, ' ' );
                                if(szEnd)
                                {
                                    *szEnd++ = 0;

                                    bstrNodeURL = szEnd;
                                }
                            }
                        }
                    }
                }


                if(!m_Utility) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->GetDatabase( &db ));

                {
                    CComPtr<CPCHQueryResult> qrNode;

                    {
                        CComPtr<CPCHQueryResultCollection> pColl;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, db->ExecuteQuery( OfflineCache::ET_NODE, bstrToLookup, &pColl ));

                        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->GetItem( 0, &qrNode ));

                        lNavModel = qrNode->GetData().m_lNavModel;
                    }

                    if(lNavModel == QR_DEFAULT)
                    {
                        if(UserSettings()->IsDesktopSKU())
                        {
                            CComPtr<CPCHQueryResultCollection> pColl;

                            __MPC_EXIT_IF_METHOD_FAILS(hr, db->ExecuteQuery( OfflineCache::ET_TOPICS_VISIBLE, bstrToLookup, &pColl ));

                            lCount    = pColl->Size();
                            lNavModel = QR_DESKTOP;
                        }
                        else
                        {
                            lCount    = 0;
                            lNavModel = QR_SERVER;
                        }
                    }

                    if(lNavModel == QR_DESKTOP && lCount)
                    {
                        MPC::wstring strURL;

                        MPC::HTML::vBuildHREF( strURL, L"hcp://system/panels/Topics.htm", L"path", bstrToLookup, NULL );

                        bstrPage = strURL.c_str();
                    }
                    else
                    {
                        bstrPage = qrNode->GetData().m_bstrTopicURL;
                    }

                    if(!STRINGISPRESENT(bstrPage)) bstrPage = c_szURL_BLANK;
                }
            }

            ////////////////////////////////////////////////////////////////////////////////

            if(dwFlags & CTXFLG_EXPAND_CONDITIONAL)
            {
                CComPtr<IMarsPanel> panel;
                VARIANT_BOOL        fContentsVisible = VARIANT_FALSE;

                GetPanelDirect( HSCPANEL_NAVBAR, panel );
                if(panel)
                {
                    (void)panel->get_visible( &fContentsVisible );
                }

                if(fContentsVisible == VARIANT_TRUE)
                {
                    dwFlags &= ~CTXFLG_EXPAND_CONDITIONAL;
                    dwFlags |= CTXFLG_EXPAND;
                }
                else if(STRINGISPRESENT(m_bstrCurrentPlace))
                {
                    bstrPlace = NULL;
                }
            }

            //
            // Fire the PersistSave event.
            //
            if(fAlsoContent)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_hs->ForceHistoryPopulate());
            }

            if(dwFlags & CTXFLG_EXPAND  ) __MPC_EXIT_IF_METHOD_FAILS(hr, SetCorrectContentView( false ));
            if(dwFlags & CTXFLG_COLLAPSE) __MPC_EXIT_IF_METHOD_FAILS(hr, SetCorrectContentView( true  ));

            if(ptr->idComp != HelpHost::COMPID_MAX && m_HelpHost->GetStatus( ptr->idComp ) == false)
            {
                if(ptr->bstrSubPanel)
                {
                    CComPtr<IWebBrowser2> wb = m_panel_CONTEXT_WebBrowser;
                    if(wb)
                    {
                        CComVariant varURL  ( ptr->bstrSubPanel );
                        CComVariant varFrame( L"SubPanels"      );
                        CComVariant varEmpty;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, wb->Navigate2( &varURL, &varEmpty, &varFrame, &varEmpty, &varEmpty ));
                    }

                    if(m_HelpHost->WaitUntilLoaded( ptr->idComp ) == false)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
                    }
                }
            }

            //
            // It's actually a navigation, so register it.
            //
            if(iVal == HSCCONTEXT_FULLWINDOW && STRINGISPRESENT(bstrPage)) dwFlags |= CTXFLG_REGISTER_CONTEXT;

            if(dwFlags & CTXFLG_REGISTER_CONTEXT)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_hs->RegisterContextSwitch( iVal, bstrInfo, bstrURL ));
            }

            if(fAlsoContent)
            {
                if(!MPC::StrICmp( bstrPage, L"<none>" )) bstrPage.Empty();

                if(STRINGISPRESENT(bstrPage))
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hs->RecordNavigationInAdvance( bstrPage ));

                    if(fFromHomePage ||
                       fToHomePage    )
                    {
                        CComPtr<IWebBrowser2> wb;

                        wb = m_panel_CONTENTS_WebBrowser; if(wb) local_HideDocument( wb );
                        wb = m_panel_HHWINDOW_WebBrowser; if(wb) local_HideDocument( wb );

                        RefreshUI();
                    }

                    __MPC_EXIT_IF_METHOD_FAILS(hr, SetPanelUrl( HSCPANEL_CONTENTS, bstrPage ));
                }
                else
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hs->DuplicateNavigation());
                }
            }

            if(STRINGISPRESENT(bstrPlace))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, TransitionToPlace( bstrPlace ));
            }

            if(fAlsoContent)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_Events.FireEvent_ContextSwitch());
            }

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    m_bstrStartURL.Empty();

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHHelpCenterExternal::SetCorrectContentView( /*[in]*/ bool fShrinked )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::SetCorrectContentView" );

    HRESULT     hr;
    LPCWSTR     szPlace;
    CComVariant v( fShrinked ? L"contentonly" : L"normal" );


    __MPC_EXIT_IF_METHOD_FAILS(hr, CallFunctionOnPanel( HSCPANEL_NAVBAR, NULL, c_bstrFunc_ChangeView, &v, 1 ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::SetCorrectContentPanel( /*[in]*/ bool fShowNormal   ,
                                                        /*[in]*/ bool fShowHTMLHELP ,
                                                        /*[in]*/ bool fDoItNow      )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::SetCorrectContentPanel" );

    HRESULT                       hr;
    CComPtr<IMarsPanelCollection> coll;
    bool                          fLocked = false;


    m_DisplayTimer.Stop();


    //
    // If there's no place, whatever we do will be lost, so delay the action.
    //
    if(!STRINGISPRESENT(m_bstrCurrentPlace)) fDoItNow = false;


    //
    // Two panels, HSCPANEL_CONTENTS and HSCPANEL_HHWINDOW, are actually overlapped, so only one at a time can be visible.
    //
    if(m_shell && SUCCEEDED(m_shell->get_panels( &coll )) && coll)
    {
        CComPtr<IMarsPanel> panel;
        CComPtr<IMarsPanel> panelOld;
        HscPanel            id;
        HscPanel            idOld;


        if(fShowNormal)
        {
            id    = HSCPANEL_CONTENTS;
            idOld = HSCPANEL_HHWINDOW;
        }
        else if(fShowHTMLHELP)
        {
            id    = HSCPANEL_HHWINDOW;
            idOld = HSCPANEL_CONTENTS;
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Nothing to do.
        }


        GetPanelDirect( id, panel );
        if(panel)
        {
            VARIANT_BOOL fVisible;

            __MPC_EXIT_IF_METHOD_FAILS(hr, panel->get_visible( &fVisible ));
            if(fVisible == VARIANT_FALSE)
            {
                if(fDoItNow == false)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_DisplayTimer.Start( this, fShowNormal ? TimerCallback_DisplayNormal : TimerCallback_DisplayHTMLHELP, 50 ));
                }
                else
                {
                    coll->lockLayout(); fLocked = true;

                    GetPanelDirect( idOld, panelOld );
                    if(panelOld)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, panelOld->put_visible( VARIANT_FALSE ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, panel   ->put_visible( VARIANT_TRUE  ));
                    }
                }
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fLocked) coll->unlockLayout();

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::TimerCallback_DisplayNormal  ( /*[in]*/ VARIANT )
{
    return SetCorrectContentPanel( /*fShowNormal*/true, /*fShowHTMLHELP*/false, /*fDoItNow*/true );
}

HRESULT CPCHHelpCenterExternal::TimerCallback_DisplayHTMLHELP( /*[in]*/ VARIANT )
{
    return SetCorrectContentPanel( /*fShowNormal*/false, /*fShowHTMLHELP*/true, /*fDoItNow*/true );
}

HRESULT CPCHHelpCenterExternal::TimerCallback_DelayedActions( /*[in]*/ VARIANT )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::TimerCallback_DelayedActions" );

    while(m_DelayedActions.size())
    {
        DelayedExecution& de = m_DelayedActions.front();

        switch(de.mode)
        {
        case DELAYMODE_NAVIGATEWEB  :             (void)SetPanelUrl  ( HSCPANEL_CONTENTS,     de.bstrURL                 ); break;
        case DELAYMODE_NAVIGATEHH   :             (void)NavigateHH   (                        de.bstrURL                 ); break;
        case DELAYMODE_CHANGECONTEXT:             (void)ChangeContext( de.iVal, de.bstrInfo, de.bstrURL, de.fAlsoContent ); break;
        case DELAYMODE_REFRESHLAYOUT: if(m_shell) (void)m_shell->refreshLayout();                                           break;
        }

        m_DelayedActions.pop_front();
    }

    __HCP_FUNC_EXIT(S_OK);
}

CPCHHelpCenterExternal::DelayedExecution& CPCHHelpCenterExternal::DelayedExecutionAlloc()
{
    return *(m_DelayedActions.insert( m_DelayedActions.end() ));
}

HRESULT CPCHHelpCenterExternal::DelayedExecutionStart()
{
    return m_ActionsTimer.Start( this, TimerCallback_DelayedActions, 2 );
}

////////////////////

HRESULT CPCHHelpCenterExternal::RefreshLayout()
{
    DelayedExecution& de = DelayedExecutionAlloc();

    de.mode = DELAYMODE_REFRESHLAYOUT;

    return DelayedExecutionStart();
}

HRESULT CPCHHelpCenterExternal::EnsurePlace()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::EnsurePlace" );

    HRESULT hr;

    //
    // If we are not displayed (m_bstrCurrentPlace not set), force a transition to a default place.
    //
    if(!STRINGISPRESENT(m_bstrCurrentPlace))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, TransitionToPlace( c_bstrPlace_FullWindow ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::TransitionToPlace( /*[in]*/ LPCWSTR szMode )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::TransitionToPlace" );

    HRESULT                       hr;
    CComPtr<IMarsPlaceCollection> coll;
    CComBSTR                      bstrPlace( szMode );


    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_shell);
    __MPC_PARAMCHECK_END();


    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(coll, m_shell, places);


    __MPC_EXIT_IF_METHOD_FAILS(hr, coll->transitionTo( bstrPlace ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, RefreshLayout());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::ExtendNavigation()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ExtendNavigation" );

    HRESULT hr;

    m_panel_CONTEXT_Events .NotifyStop();
    m_panel_CONTENTS_Events.NotifyStop();
    m_panel_HHWINDOW_Events.NotifyStop();

    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\helpsession.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpSession.cpp

Abstract:
    This file contains the implementation of the CHCPHelpSession class,
    which is used to store the list of visited contents.

Revision History:
    Davide Massarenti   (Dmassare)  07/29/99
        created

******************************************************************************/

#include "stdafx.h"

#include <urlhist.h>

/////////////////////////////////////////////////////////////////////////////

#define REMEMBER_PAGE_DELAY       (3)
#define NUM_OF_ENTRIES_TO_PERSIST (20)

static const DWORD l_dwVersion = 0x01005348; // HS 01


static const DATE l_dNewNavigationThreshold = 1.0 / (24.0 * 60.0 * 60.0); // one second.
static const int  l_iMaxCachedItems         = 10;


static const WCHAR c_szPersistFile[] = HC_ROOT_HELPCTR L"\\HelpSessionHistory.dat";

static const WCHAR c_szINDEX[] = L"Index";


static const LPCWSTR c_rgExclude[] =
{
    L"hcp://system/"
};

static const LPCWSTR c_rgBadTitles[] =
{
    L"ms-its:",
    L"hcp:"   ,
    L"http:"  ,
    L"https:" ,
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef HSS_RPRD

struct XMLHelpSessionItem : public MPC::Config::TypeConstructor
{
    DECLARE_CONFIG_MAP(XMLHelpSessionItem);

    int               m_iIndex;
    Taxonomy::HelpSet m_ths;
    DATE              m_dLastVisited;
    long              m_lDuration;

    CComBSTR          m_bstrURL;
    CComBSTR          m_bstrTitle;

    CComBSTR          m_bstrContextID;
    CComBSTR          m_bstrContextInfo;
    CComBSTR          m_bstrContextURL;

    ////////////////////////////////////////
    //
    // MPC::Config::TypeConstructor
    //
    DEFINE_CONFIG_DEFAULTTAG();
    DECLARE_CONFIG_METHODS();
    //
    ////////////////////////////////////////
};

CFG_BEGIN_FIELDS_MAP(XMLHelpSessionItem)
    CFG_ATTRIBUTE( L"ID"              , int    , m_iIndex           ),
    CFG_ATTRIBUTE( L"SKU"             , wstring, m_ths.m_strSKU     ),
    CFG_ATTRIBUTE( L"Language"        , long   , m_ths.m_lLCID      ),
    CFG_ATTRIBUTE( L"LastVisited"     , DATE   , m_dLastVisited     ),
    CFG_ATTRIBUTE( L"Duration"        , long   , m_lDuration        ),

    CFG_ELEMENT  ( L"URL"             , BSTR   , m_bstrURL          ),
    CFG_ELEMENT  ( L"Title"           , BSTR   , m_bstrTitle        ),
    CFG_ATTRIBUTE( L"Context"         , BSTR   , m_bstrContextID    ),
    CFG_ELEMENT  ( L"ContextData"     , BSTR   , m_bstrContextInfo  ),
    CFG_ELEMENT  ( L"ContextTopic"    , BSTR   , m_bstrContextURL   ),
CFG_END_FIELDS_MAP()

CFG_BEGIN_CHILD_MAP(XMLHelpSessionItem)
CFG_END_CHILD_MAP()

DEFINE_CFG_OBJECT(XMLHelpSessionItem,L"Entry")

DEFINE_CONFIG_METHODS__NOCHILD(XMLHelpSessionItem)

#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static struct ContextLookup
{
    LPCWSTR    szName;
    HscContext iValue;
    bool       fInternal;
} const s_rgContext[] =
{
    { L"INVALID"     , HSCCONTEXT_INVALID     , true  },
    { L"STARTUP"     , HSCCONTEXT_STARTUP     , true  },
    { L"HOMEPAGE"    , HSCCONTEXT_HOMEPAGE    , false },
    { L"CONTENT"     , HSCCONTEXT_CONTENT     , false },
    { L"SUBSITE"     , HSCCONTEXT_SUBSITE     , false },
    { L"SEARCH"      , HSCCONTEXT_SEARCH      , false },
    { L"INDEX"       , HSCCONTEXT_INDEX       , false },
    { L"CHANNELS"    , HSCCONTEXT_CHANNELS    , false },
    { L"FAVORITES"   , HSCCONTEXT_FAVORITES   , false },
    { L"HISTORY"     , HSCCONTEXT_HISTORY     , false },
    { L"OPTIONS"     , HSCCONTEXT_OPTIONS     , false },
    /////////////////////////////////////////////////////
    { L"CONTENTONLY" , HSCCONTEXT_CONTENTONLY , false },
    { L"FULLWINDOW"  , HSCCONTEXT_FULLWINDOW  , false },
    { L"KIOSKMODE"   , HSCCONTEXT_KIOSKMODE   , false },
};

////////////////////////////////////////////////////////////////////////////////

CPCHHelpSessionItem::State::State( /*[in]*/ CPCHHelpSessionItem* parent )
{
    m_parent   = parent; // CPCHHelpSessionItem* m_parent;
    m_fValid   = false;  // bool                 m_fValid;
    m_fDirty   = false;  // bool                 m_fDirty;
    m_dwLoaded = 0;      // DWORD                m_dwLoaded;
                         //
                         // MPC::CComHGLOBAL     m_hgWebBrowser_CONTENTS;
                         // MPC::CComHGLOBAL     m_hgWebBrowser_HHWINDOW;
                         // PropertyMap          m_mapProperties;
}

////////////////////////////////////////////////////////////////////////////////

void CPCHHelpSessionItem::State::Erase( /*[in]*/ bool fUnvalidate )
{
    m_hgWebBrowser_CONTENTS.Release();
    m_hgWebBrowser_HHWINDOW.Release();
    m_mapProperties        .clear  ();

    m_fDirty = false;

    if(fUnvalidate) m_fValid = false;
}

HRESULT CPCHHelpSessionItem::State::Load()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Load" );

    HRESULT          hr;
    CComPtr<IStream> stream;

    if(m_parent == NULL || m_parent->GetParent() == NULL) // Already passivated.
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    if(m_fValid)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->GetParent()->ItemState_GetStream( m_parent->GetIndex(), stream ));

        {
            MPC::Serializer_IStream   streamReal( stream     );
            MPC::Serializer_Buffering streamBuf ( streamReal );
            DWORD                     dwVer;

            Erase( /*fUnvalidate*/true );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer                  ); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_hgWebBrowser_CONTENTS);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_hgWebBrowser_HHWINDOW);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_mapProperties        );

            m_fValid = true;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::State::Save()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Save" );

    HRESULT hr;


    if(m_fDirty)
    {
        CComPtr<IStream> stream;

        if(m_parent == NULL || m_parent->GetParent() == NULL) // Already passivated.
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->GetParent()->ItemState_CreateStream( m_parent->GetIndex(), stream ));

        {
            MPC::Serializer_IStream   streamReal( stream     );
            MPC::Serializer_Buffering streamBuf ( streamReal );
            DWORD                     dwVer = l_dwVersion;

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << dwVer                  );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_hgWebBrowser_CONTENTS);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_hgWebBrowser_HHWINDOW);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_mapProperties        );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
        }

        m_fDirty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpSessionItem::State::AcquireState()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::AcquireState" );

    HRESULT hr;

    if(m_dwLoaded++ == 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Load());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::State::ReleaseState( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::ReleaseState" );

    HRESULT hr;

    if(m_dwLoaded)
    {
        if(fForce || --m_dwLoaded == 0)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Save());

            Erase( /*fUnvalidate*/false ); // Just unload.
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHHelpSessionItem::State::Populate( /*[in]*/ bool fUseHH )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Populate" );

    HRESULT                    hr;
    CComQIPtr<IPersistHistory> pPH;
    CPCHHelpSession*           parent2;
    CPCHHelpCenterExternal*    parent3;


    if(m_parent == NULL || (parent2 = m_parent->GetParent()) == NULL || (parent3 = parent2->GetParent()) == NULL) // Already passivated.
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    ////////////////////

    __MPC_EXIT_IF_METHOD_FAILS(hr, parent3->Events().FireEvent_PersistSave());

    ////////////////////

    m_hgWebBrowser_CONTENTS.Release();
    m_hgWebBrowser_HHWINDOW.Release();

    if(fUseHH == false)
    {
        CComPtr<IWebBrowser2> wb2; wb2.Attach( parent3->Contents() );

        pPH = wb2;
        if(pPH)
        {
            CComPtr<IStream> stream;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_hgWebBrowser_CONTENTS.NewStream( &stream ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, pPH->SaveHistory                 (  stream ));

            m_fValid = true;
            m_fDirty = true;
        }
    }
    else
    {
        CComPtr<IWebBrowser2> wb2; wb2.Attach( parent3->HHWindow() );

        pPH = wb2;
        if(pPH)
        {
            CComPtr<IStream> stream;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_hgWebBrowser_HHWINDOW.NewStream( &stream ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, pPH->SaveHistory                 (  stream ));

            m_fValid = true;
            m_fDirty = true;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::State::Restore( /*[in]*/ bool fUseHH )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Restore" );

    HRESULT                    hr;
    CComQIPtr<IPersistHistory> pPH;
    CPCHHelpSession*           parent2;
    CPCHHelpCenterExternal*    parent3;
    bool                       fAcquired = false;


    if(m_parent == NULL || (parent2 = m_parent->GetParent()) == NULL || (parent3 = parent2->GetParent()) == NULL) // Already passivated.
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, AcquireState()); fAcquired = true;

    if(fUseHH == false)
    {
        if(m_hgWebBrowser_CONTENTS.Size())
        {
            {
                CComPtr<IMarsPanel> panel;

                __MPC_EXIT_IF_METHOD_FAILS(hr, parent3->GetPanel( HSCPANEL_CONTENTS, &panel, /*fEnsurePresence*/true ));
            }

            {
                CComPtr<IWebBrowser2> wb2; wb2.Attach( parent3->Contents() );

                pPH = wb2;
                if(pPH)
                {
                    CComPtr<IStream> stream;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hgWebBrowser_CONTENTS.GetAsStream( &stream, /*fClone*/true ));
                    __MPC_EXIT_IF_METHOD_FAILS(hr, pPH->LoadHistory                   (  stream, NULL           ));
                }
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, parent3->SetCorrectContentPanel( /*fShowNormal*/true, /*fShowHTMLHELP*/false, /*fNow*/false ));
        }
    }
    else
    {
        if(m_hgWebBrowser_HHWINDOW.Size())
        {
            {
                CComPtr<IMarsPanel> panel;

                __MPC_EXIT_IF_METHOD_FAILS(hr, parent3->GetPanel( HSCPANEL_HHWINDOW, &panel, /*fEnsurePresence*/true ));
            }

            {
                CComPtr<IWebBrowser2> wb2; wb2.Attach( parent3->HHWindow() );

                pPH = wb2;
                if(pPH)
                {
                    CComPtr<IStream> stream;

                    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hgWebBrowser_HHWINDOW.GetAsStream( &stream, /*fClone*/true ));
                    __MPC_EXIT_IF_METHOD_FAILS(hr, pPH->LoadHistory                   (  stream, NULL           ));
                }
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, parent3->SetCorrectContentPanel( /*fShowNormal*/false, /*fShowHTMLHELP*/true, /*fNow*/false ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::State::Delete()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Delete" );

    HRESULT          hr;
    CPCHHelpSession* parent2;

    if(m_parent == NULL || (parent2 = m_parent->GetParent()) == NULL) // Already passivated.
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    Erase( /*fUnvalidate*/true );
    m_dwLoaded = 0;

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->GetParent()->ItemState_DeleteStream( m_parent->GetIndex() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::State::Clone( /*[out]*/ State& state )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::State::Clone" );

    HRESULT hr;
    bool    fAcquired = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, state.AcquireState()); fAcquired = true;

                                                             // CPCHHelpSessionItem* m_parent;
    m_fValid                = state.m_fValid;                // bool                 m_fValid;
    m_fDirty                = true;                          // bool                 m_fDirty;
    m_dwLoaded++;                                            // DWORD                m_dwLoaded;
                                                             //
    m_hgWebBrowser_CONTENTS = state.m_hgWebBrowser_CONTENTS; // MPC::CComHGLOBAL     m_hgWebBrowser_CONTENTS;
    m_hgWebBrowser_HHWINDOW = state.m_hgWebBrowser_HHWINDOW; // MPC::CComHGLOBAL     m_hgWebBrowser_HHWINDOW;
    m_mapProperties         = state.m_mapProperties;         // PropertyMap          m_mapProperties;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HscContext CPCHHelpSessionItem::LookupContext( /*[in]*/ LPCWSTR szName )
{
    const ContextLookup* ctx = s_rgContext;

    if(!STRINGISPRESENT(szName)) return HSCCONTEXT_HOMEPAGE;

    for(int i=0; i<ARRAYSIZE(s_rgContext); i++, ctx++)
    {
        if(!_wcsicmp( szName, ctx->szName ))
        {
            return ctx->fInternal ? HSCCONTEXT_INVALID : ctx->iValue;
        }
    }

    return HSCCONTEXT_INVALID;
}

LPCWSTR CPCHHelpSessionItem::LookupContext( /*[in]*/ HscContext iVal )
{
    const ContextLookup* ctx = s_rgContext;

    for(int i=0; i<ARRAYSIZE(s_rgContext); i++, ctx++)
    {
        if(ctx->iValue == iVal) return ctx->szName;
    }

    return NULL;
}

////////////////////////////////////////

CPCHHelpSessionItem::CPCHHelpSessionItem() : m_state( this )
{
    m_parent       = NULL;               // CPCHHelpSession*  m_parent;
                                         // State             m_state;
    m_fSaved       = false;              // bool              m_fSaved;
    m_fInitialized = false;              // bool              m_fInitialized;
                                         //
   //////////////////////////////////////////////////////////////////////////////////
                                         //
                                         // Taxonomy::HelpSet m_ths;
                                         //
                                         // CComBSTR          m_bstrURL;
                                         // CComBSTR          m_bstrTitle;
    m_dLastVisited = 0;                  // DATE              m_dLastVisited;
    m_dDuration    = 0;                  // DATE              m_dDuration;
    m_lNumOfHits   = 0;                  // DWORD             m_lNumOfHits;
                                         //
    m_iIndexPrev   = NO_LINK;            // int               m_iIndexPrev;
    m_iIndex       = NO_LINK;            // int               m_iIndex;
    m_iIndexNext   = NO_LINK;            // int               m_iIndexNext;
                                         //
    m_lContextID   = HSCCONTEXT_INVALID; // long              m_lContextID;      // HscContext
                                         // CComBSTR          m_bstrContextInfo;
                                         // CComBSTR          m_bstrContextURL;
                                         //
    m_fUseHH       = false;              // bool              m_fUseHH;
}

void CPCHHelpSessionItem::Initialize( /*[in]*/ CPCHHelpSession* parent, /*[in]*/ bool fNew )
{
    m_parent = parent;

    if(fNew)
    {
        CPCHProxy_IPCHUserSettings2* us = parent->m_parent->UserSettings();

        m_lContextID      = parent->m_lContextID     ;
        m_bstrContextInfo = parent->m_bstrContextInfo;
        m_bstrContextURL  = parent->m_bstrContextURL ;

        if(us)
        {
            m_ths = us->THS();
        }
    }
}

void CPCHHelpSessionItem::Passivate()
{
    m_state.ReleaseState( /*fForce*/true );

    m_parent = NULL;
}

////////////////////

HRESULT CPCHHelpSessionItem::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::Load" );

    HRESULT hr;


    //
    // Read its properties.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_ths            );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dLastVisited   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dDuration      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lNumOfHits     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_iIndexPrev     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_iIndex         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_iIndexNext     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_lContextID     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrContextInfo);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_bstrContextURL );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fUseHH         );

    //
    // All the item saved to disk have a valid state.
    //
    m_state.m_fValid = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSessionItem::Save( /*[in]*/ MPC::Serializer& streamOut ,
                                   /*[in]*/ bool             fForce    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::Save" );

    HRESULT hr;


    //
    // Don't save an entry if there's no IE history stream, it would be useless to reload it!
    //
    if(fForce == false && m_state.m_fValid == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // Write its properties.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_ths            );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrURL        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrTitle      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dLastVisited   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dDuration      );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lNumOfHits     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_iIndexPrev     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_iIndex         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_iIndexNext     );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_lContextID     );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrContextInfo);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_bstrContextURL );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fUseHH         );

    m_fSaved = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


void CPCHHelpSessionItem::HistorySelect()
{
    if(!m_fInitialized && m_parent && m_parent->m_parent)
    {
        m_fInitialized = true;
        m_fUseHH       = m_parent->m_parent->IsHHWindowVisible();
    }
}

HRESULT CPCHHelpSessionItem::HistoryPopulate()
{
    HistorySelect();

    return m_state.Populate( m_fUseHH );
}

HRESULT CPCHHelpSessionItem::HistoryRestore()
{
    return m_state.Restore( m_fUseHH );
}

HRESULT CPCHHelpSessionItem::HistoryDelete()
{
    return m_state.Delete();
}

HRESULT CPCHHelpSessionItem::HistoryClone( /*[in]*/ bool fContext, /*[in]*/ CPCHHelpSessionItem* hsi )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::HistoryClone" );

    HRESULT hr;
    bool    fAcquired = false;


    if(this == hsi || !hsi) __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);


    __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->m_state.AcquireState()); fAcquired = true;


                                                // CPCHHelpSession*  m_parent;
                                                // State             m_state;
    m_fSaved          = false;                  // bool              m_fSaved;
    m_fInitialized    = true;                   // bool              m_fInitialized;
                                                //
    ////////////////////////////////////////////////////////////////////////////////
                                                //
    m_ths             = hsi->m_ths;             // Taxonomy::HelpSet m_ths;
                                                //
    m_bstrURL         = hsi->m_bstrURL;         // CComBSTR          m_bstrURL;
    m_bstrTitle       = hsi->m_bstrTitle;       // CComBSTR          m_bstrTitle;
                                                // DATE              m_dLastVisited;
                                                // DATE              m_dDuration;
    m_lNumOfHits      = hsi->m_lNumOfHits;      // long              m_lNumOfHits;
                                                //
                                                // int               m_iIndexPrev;
                                                // int               m_iIndex;
                                                // int               m_iIndexNext;
                                                //
                                                // long              m_lContextID;
                                                // CComBSTR          m_bstrContextInfo;
                                                // CComBSTR          m_bstrContextURL;
                                                //
    m_fUseHH          = hsi->m_fUseHH;          // bool              m_fUseHH;

    if(fContext)
    {
        m_lContextID      = hsi->m_lContextID;
        m_bstrContextInfo = hsi->m_bstrContextInfo;
        m_bstrContextURL  = hsi->m_bstrContextURL;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_state.Clone( hsi->m_state ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)hsi->m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpSessionItem::Enter()
{
    m_dLastVisited = MPC::GetLocalTimeEx( /*fHighPrecision*/false );

    return m_state.AcquireState();
}

HRESULT CPCHHelpSessionItem::Leave()
{
    m_dDuration = MPC::GetLocalTimeEx( /*fHighPrecision*/false );

    return m_state.ReleaseState( /*fForce*/false );
}

bool CPCHHelpSessionItem::SeenLongEnough( DWORD dwSeconds ) const
{
    return (m_dDuration - m_dLastVisited) * 86400 > dwSeconds;
}

bool CPCHHelpSessionItem::SameURL( CPCHHelpSessionItem* right ) const
{
    return SameURL( right->m_bstrURL );
}

bool CPCHHelpSessionItem::SameURL( LPCWSTR right ) const
{
    return MPC::StrICmp( m_bstrURL, right ) == 0;
}

bool CPCHHelpSessionItem::SameSKU( /*[in]*/ const Taxonomy::HelpSet& ths ) const
{
    return m_ths == ths;
}

////////////////////////////////////////

void CPCHHelpSessionItem::put_THS( /*[in]*/ const Taxonomy::HelpSet& ths ) // Internal Method.
{
    m_ths = ths;
}

STDMETHODIMP CPCHHelpSessionItem::get_SKU( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_ths.GetSKU(), pVal );
}


STDMETHODIMP CPCHHelpSessionItem::get_Language( /*[out, retval]*/ long *pVal )
{
    if(!pVal) return E_POINTER;

    *pVal = m_ths.GetLanguage();
    return S_OK;
}


STDMETHODIMP CPCHHelpSessionItem::get_URL( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrURL, pVal );
}

HRESULT CPCHHelpSessionItem::put_URL( /*[in]*/ BSTR newVal ) // Internal Method.
{
    return MPC::PutBSTR( m_bstrURL, newVal );
}


STDMETHODIMP CPCHHelpSessionItem::get_Title( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( m_bstrTitle, pVal );
}

HRESULT CPCHHelpSessionItem::put_Title( /*[in]*/ BSTR  newVal ) // Internal Method.
{
    return MPC::PutBSTR( m_bstrTitle, newVal );
}


STDMETHODIMP CPCHHelpSessionItem::get_LastVisited( /*[out, retval]*/ DATE *pVal )
{
    if(pVal == NULL) return E_POINTER;

    *pVal = m_dLastVisited;

    return S_OK;
}

STDMETHODIMP CPCHHelpSessionItem::get_Duration( /*[out, retval]*/ DATE *pVal )
{
    if(pVal == NULL) return E_POINTER;

    *pVal = m_dDuration;

    return S_OK;
}

STDMETHODIMP CPCHHelpSessionItem::get_NumOfHits( /*[out, retval]*/ long *pVal )
{
    if(pVal == NULL) return E_POINTER;

    *pVal = m_lNumOfHits;

    return S_OK;
}


STDMETHODIMP CPCHHelpSessionItem::get_Property( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::get_Property" );

    HRESULT             hr;
    State::PropertyIter it;
    bool                fAcquired = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_state.AcquireState()); fAcquired = true;

    ::VariantClear( pVal );

    it = m_state.m_mapProperties.find( bstrName );
    if(it != m_state.m_mapProperties.end())
    {
        pVal->vt      = VT_BSTR;
        pVal->bstrVal = ::SysAllocString( it->second.c_str() );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSessionItem::put_Property( /*[in]*/ BSTR bstrName, /*[in]*/ VARIANT pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::put_Property" );

    HRESULT      hr;
    MPC::wstring strName;
    CComVariant  v;
    bool         fAcquired = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_state.AcquireState()); fAcquired = true;

    strName = bstrName;


    (void)::VariantChangeType( &v, &pVal, 0, VT_BSTR );
    if(v.vt == VT_BSTR && v.bstrVal && v.bstrVal[0])
    {
        m_state.m_mapProperties[ strName ] = v.bstrVal;
    }
    else
    {
        m_state.m_mapProperties.erase( strName );
    }

    m_state.m_fDirty = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHHelpSessionItem::get_ContextName( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( LookupContext( GetContextID() ), pVal );
}

STDMETHODIMP CPCHHelpSessionItem::get_ContextInfo( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( GetContextInfo(), pVal );
}

STDMETHODIMP CPCHHelpSessionItem::get_ContextURL( /*[out, retval]*/ BSTR *pVal )
{
    return MPC::GetBSTR( GetContextURL(), pVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHHelpSessionItem::CheckProperty( /*[in]*/ BSTR bstrName, /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::CheckProperty" );

    HRESULT             hr;
    State::PropertyIter it;
    bool                fAcquired = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,VARIANT_FALSE);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_state.AcquireState()); fAcquired = true;

    it = m_state.m_mapProperties.find( bstrName );
    if(it != m_state.m_mapProperties.end())
    {
        *pVal = VARIANT_TRUE;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired) (void)m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

CPCHHelpSessionItem* CPCHHelpSessionItem::Previous() { return (m_parent && m_iIndexPrev != NO_LINK) ? m_parent->FindPage( m_iIndexPrev ) : NULL; }
CPCHHelpSessionItem* CPCHHelpSessionItem::Next    () { return (m_parent && m_iIndexNext != NO_LINK) ? m_parent->FindPage( m_iIndexNext ) : NULL; }

////////////////////////////////////////

HRESULT CPCHHelpSessionItem::ExtractTitle()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSessionItem::ExtractTitle" );

    HRESULT hr;

    if(m_parent)
    {
        CPCHHelpCenterExternal* ext = m_parent->GetParent();

        HistorySelect();

        if(!STRINGISPRESENT(m_bstrTitle))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->LookupTitle( m_bstrURL, m_bstrTitle, /*fUseIECache*/false ));
        }

        if(!STRINGISPRESENT(m_bstrTitle) && ext)
        {
            CComPtr<IWebBrowser2>   wb2; wb2.Attach( m_fUseHH ? ext->HHWindow() : ext->Contents() );
            CComPtr<IHTMLDocument2> doc;

            if(SUCCEEDED(MPC::HTML::IDispatch_To_IHTMLDocument2( doc, wb2 )))
            {
                (void)doc->get_title( &m_bstrTitle );
            }
        }

        if(!STRINGISPRESENT(m_bstrTitle))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->LookupTitle( m_bstrURL, m_bstrTitle, /*fUseIECache*/true ));
        }

        if(STRINGISPRESENT(m_bstrTitle))
        {
            for(int i=0; i<ARRAYSIZE(c_rgBadTitles); i++)
            {
                LPCWSTR szPtr = c_rgBadTitles[i];

                if(!_wcsnicmp( m_bstrTitle, szPtr, wcslen( szPtr ) ))
                {
                    m_bstrTitle.Empty();
                    break;
                }
            }
        }

        if(STRINGISPRESENT(m_bstrTitle))
        {
            DebugLog( L"%%%%%%%%%%%%%%%%%%%% TITLE %s - %s\n", m_bstrURL, m_bstrTitle );
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

static const WCHAR c_rgHelpSessionLog[] = L"%TEMP%\\helpsession_debug.txt";

void CPCHHelpSession::DEBUG_DumpState_HG( /*[in]*/ MPC::FileLog&     log ,
                                          /*[in]*/ MPC::CComHGLOBAL& hg  )
{
    CComPtr<IStream> stream;

    if(SUCCEEDED(hg.GetAsStream( &stream, /*fClone*/false )))
    {
        BYTE  rgBuf[32];
        ULONG lRead;

        while(SUCCEEDED(stream->Read( rgBuf, sizeof(rgBuf), &lRead )) && lRead)
        {
            WCHAR  rgHex[2*sizeof(rgBuf)+1];
            WCHAR  rgTxt[  sizeof(rgBuf)+1];
            BYTE*  pIn      = rgBuf;
            WCHAR* szOutHex = rgHex;
            WCHAR* szOutTxt = rgTxt;

            while(lRead-- > 0)
            {
                BYTE c = *pIn++;

                *szOutHex++ = MPC::NumToHex( c >> 4 );
                *szOutHex++ = MPC::NumToHex( c      );

                *szOutTxt++ = isprint( c ) ? c : '.';
            }
            szOutHex[0] = 0;
            szOutTxt[0] = 0;

            log.LogRecord( L"    %-64s %s\n", rgHex, rgTxt );
        }
        log.LogRecord( L"\n" );
    }
}

void CPCHHelpSession::DEBUG_DumpState_BLOB( /*[in]*/ MPC::FileLog&        log ,
                                            /*[in]*/ CPCHHelpSessionItem* hsi )
{
    if(SUCCEEDED(hsi->m_state.AcquireState()))
    {
        if(hsi->m_state.m_hgWebBrowser_CONTENTS.Size())
        {
            log.LogRecord( L"  m_hgWebBrowser_CONTENTS:\n" );
            DEBUG_DumpState_HG( log, hsi->m_state.m_hgWebBrowser_CONTENTS );
        }

        if(hsi->m_state.m_hgWebBrowser_HHWINDOW.Size())
        {
            log.LogRecord( L"  m_hgWebBrowser_HHWINDOW:\n" );
            DEBUG_DumpState_HG( log, hsi->m_state.m_hgWebBrowser_HHWINDOW );
        }

        hsi->m_state.ReleaseState( /*fForce*/false );
    }
}

void CPCHHelpSession::DEBUG_DumpState( /*[in]*/ LPCWSTR szText, /*[in]*/ bool fHeader, /*[in]*/ bool fCurrent, /*[in]*/ bool fAll, /*[in]*/ bool fState )
{
    static int   iCount  = 0;
    IterConst    it;
    MPC::FileLog log;

    {
        MPC::wstring strLog( c_rgHelpSessionLog ); MPC::SubstituteEnvVariables( strLog );

        log.SetLocation( strLog.c_str() );
    }

    log.LogRecord( L"################################################################################ %d %s\n\n", ++iCount, SAFEWSTR( szText ) );

    if(fHeader)
    {
        log.LogRecord( L"  m_dwTravelling    : %d\n"  , m_dwTravelling                         );
        log.LogRecord( L"  m_fAlreadySaved   : %s\n"  , m_fAlreadySaved   ? L"true" : L"false" );
        log.LogRecord( L"  m_fAlreadyCreated : %s\n"  , m_fAlreadyCreated ? L"true" : L"false" );
        log.LogRecord( L"  m_fOverwrite      : %s\n"  , m_fOverwrite      ? L"true" : L"false" );
        log.LogRecord( L"  m_dwIgnore        : %d\n"  , m_dwIgnore                             );
        log.LogRecord( L"  m_dwNoEvents      : %d\n"  , m_dwNoEvents                           );
        log.LogRecord( L"  m_iLastIndex      : %d\n\n", m_iLastIndex                           );

        log.LogRecord( L"  ########################################\n\n" );
    }

    if(fCurrent)
    {
        if(m_hsiCurrentPage)
        {
            log.LogRecord( L"  Current URL       : %s\n"  , SAFEBSTR( m_hsiCurrentPage->m_bstrURL )  );
            log.LogRecord( L"  Current iIndexPrev: %d\n"  ,           m_hsiCurrentPage->m_iIndexPrev );
            log.LogRecord( L"  Current iIndex    : %d\n"  ,           m_hsiCurrentPage->m_iIndex     );
            log.LogRecord( L"  Current iIndexNext: %d\n\n",           m_hsiCurrentPage->m_iIndexNext );

            log.LogRecord( L"  Current m_lContextID     : %s\n"  , CPCHHelpSessionItem::LookupContext( (HscContext)m_hsiCurrentPage->m_lContextID      ) );
            log.LogRecord( L"  Current m_bstrContextInfo: %s\n"  , SAFEBSTR                          (             m_hsiCurrentPage->m_bstrContextInfo ) );
            log.LogRecord( L"  Current m_bstrContextURL : %s\n\n", SAFEBSTR                          (             m_hsiCurrentPage->m_bstrContextURL  ) );

            if(fState)
            {
                DEBUG_DumpState_BLOB( log, m_hsiCurrentPage );
            }

            log.LogRecord( L"  ########################################\n\n" );

        }
    }

    if(fAll)
    {
        for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
        {
            CPCHHelpSessionItem* hsi = *it;

            log.LogRecord( L"  URL       : %s\n"  , SAFEBSTR( hsi->m_bstrURL   ) );
            log.LogRecord( L"  iIndexPrev: %d\n"  ,           hsi->m_iIndexPrev  );
            log.LogRecord( L"  iIndex    : %d\n"  ,           hsi->m_iIndex      );
            log.LogRecord( L"  iIndexNext: %d\n"  ,           hsi->m_iIndexNext  );
            log.LogRecord( L"  bstrTitle : %s\n\n", SAFEBSTR( hsi->m_bstrTitle ) );

            log.LogRecord( L"  lContextID     : %s\n"  , CPCHHelpSessionItem::LookupContext( (HscContext)hsi->m_lContextID      ) );
            log.LogRecord( L"  bstrContextInfo: %s\n"  , SAFEBSTR                          (             hsi->m_bstrContextInfo ) );
            log.LogRecord( L"  bstrContextURL : %s\n\n", SAFEBSTR                          (             hsi->m_bstrContextURL  ) );

            if(fState)
            {
                DEBUG_DumpState_BLOB( log, hsi );
            }
        }
    }

    log.LogRecord( L"\n\n" );
}

void CPCHHelpSession::DEBUG_DumpSavedPages()
{
    IterConst    it;
    MPC::FileLog log;

    {
        MPC::wstring strLog( c_rgHelpSessionLog ); MPC::SubstituteEnvVariables( strLog );

        log.SetLocation( strLog.c_str() );
    }

    for(int pass=0; pass<2; pass++)
    {
        log.LogRecord( L"################################################################################ %sSAVED PAGES\n\n", pass == 0 ? L"" : L"NON-" );

        for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
        {
            CPCHHelpSessionItem* hsi = *it;

            if(hsi->m_fSaved == (pass == 0))
            {
                long lDuration = 86400.0 * ( hsi->m_dDuration - hsi->m_dLastVisited ); // Number of milliseconds for the page.

                log.LogRecord( L"  lDuration      : %ld\n" ,                                                 lDuration                );
                log.LogRecord( L"  URL            : %s\n"  , SAFEBSTR                          (             hsi->m_bstrURL         ) );
                log.LogRecord( L"  bstrTitle      : %s\n"  , SAFEBSTR                          (             hsi->m_bstrTitle       ) );
                log.LogRecord( L"  lContextID     : %s\n"  , CPCHHelpSessionItem::LookupContext( (HscContext)hsi->m_lContextID      ) );
                log.LogRecord( L"  bstrContextInfo: %s\n"  , SAFEBSTR                          (             hsi->m_bstrContextInfo ) );
                log.LogRecord( L"  bstrContextURL : %s\n\n", SAFEBSTR                          (             hsi->m_bstrContextURL  ) );
            }
        }

        log.LogRecord( L"\n\n" );
    }
}
#endif

////////////////////////////////////////////////////////////////////////////////

//
// ITSS.DLL is broken under IA64....
//
#ifdef _IA64_
#define HELPSESSION_STORAGETOUSE false
#else
#define HELPSESSION_STORAGETOUSE true
#endif

CPCHHelpSession::CPCHHelpSession() : m_disk( STGM_READWRITE, /*fITSS*/HELPSESSION_STORAGETOUSE )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::CPCHHelpSession" );

    m_parent          = NULL;                 // CPCHHelpCenterExternal*      m_parent;
                                              //
                                              // MPC::wstring                 m_szBackupFile;
                                              // MPC::StorageObject           m_disk;
    m_dStartOfSession = MPC::GetLocalTime();  // DATE                         m_dStartOfSession;
                                              //
                                              // CComPtr<IUrlHistoryStg>      m_pIHistory;
                                              //
                                              // MPC::WStringUCList           m_lstIgnore;
                                              // TitleMap                     m_mapTitles;
                                              // List                         m_lstVisitedPages;
                                              // List                         m_lstCachedVisitedPages;
                                              // CComPtr<CPCHHelpSessionItem> m_hsiCurrentPage;
    m_dwTravelling    = 0;                    // DWORD                        m_dwTravelling;
    m_fAlreadySaved   = false;                // bool                         m_fAlreadySaved;
    m_fAlreadyCreated = false;                // bool                         m_fAlreadyCreated;
    m_fOverwrite      = false;                // bool                         m_fOverwrite;
    m_dwIgnore        = 0;                    // DWORD                        m_dwIgnore;
    m_dwNoEvents      = 0;                    // DWORD                        m_dwNoEvents;
    m_dLastNavigation = 0.0;                  // DATE                         m_dLastNavigation;
    m_iLastIndex      = 0;                    // int                          m_iLastIndex;
                                              //
    m_lContextID      = HSCCONTEXT_INVALID;   // long                         m_lContextID;
                                              // CComBSTR                     m_bstrContextInfo;
                                              // CComBSTR                     m_bstrContextURL;
                                              //
    m_fPossibleBack   = false;                // bool                         m_fPossibleBack;
    m_dwPossibleBack  = 0;                    // DWORD                        m_dwPossibleBack;
}

CPCHHelpSession::~CPCHHelpSession()
{
    Passivate();
}

HRESULT CPCHHelpSession::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Initialize" );

    HRESULT      hr;
    MPC::wstring szFile;
    HANDLE       hFile = INVALID_HANDLE_VALUE;


    m_parent = parent;


    //
    // Copy live file onto temporary one or create a new archive.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( szFile, c_szPersistFile ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir            ( szFile                  ));


    if(parent == NULL) // No parent, point to the user file and recreate it.
    {
        m_disk = szFile.c_str();

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.Create());
    }
    else
    {
#ifdef DEBUG
        {
            MPC::wstring strLog( c_rgHelpSessionLog ); MPC::SubstituteEnvVariables( strLog );

            MPC::DeleteFile( strLog );
        }
#endif

        try
        {
            //
            // Prepare temporary file.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( m_szBackupFile )); m_disk = m_szBackupFile.c_str();

            if(MPC::FileSystemObject::IsFile( szFile.c_str() ))
            {
                if(SUCCEEDED(hr = MPC::CopyFile( szFile, m_szBackupFile )))
                {
                    hr = m_disk.Exists();
                }
            }
            else
            {
                hr = E_FAIL;
            }

            if(FAILED(hr))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_disk.Create());
            }


            if(FAILED(Load()))
            {
                (void)Erase();
            }
        }
        catch(...)
        {
            //
            // If the file is corrupted, ITSS will crash. Delete the file and exit.
            //
			MPC::DeleteFile( szFile, /*fForce*/true, /*fDelayed*/true );

            ::ExitProcess(0);
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHHelpSession::Passivate()
{
    (void)Erase();

    m_parent = NULL;

    m_disk.Release();

    (void)MPC::RemoveTemporaryFile( m_szBackupFile );
}

////////////////////

HRESULT CPCHHelpSession::Persist()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Persist" );

    HRESULT hr;

    //
    // Before shutdown, update the time information for the current entry.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, LeaveCurrentPage());

    (void)Save();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT CPCHHelpSession::Load()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Load" );

    HRESULT             hr;
    MPC::StorageObject* child;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ItemState_GetIndexObject( /*fCreate*/false, child ));
    if(child)
    {
        CComPtr<IStream> stream;

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
        if(stream)
        {
            CComPtr<CPCHHelpSessionItem> hsi;
            MPC::Serializer_IStream      streamReal( stream     );
            MPC::Serializer_Buffering    streamBuf ( streamReal );
            DWORD                        dwVer;

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> dwVer       ); if(dwVer != l_dwVersion) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf >> m_iLastIndex);

            while(1)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem( /*fNew*/false, /*fLink*/false, /*fNewIndex*/false, hsi ));

                if(FAILED(hsi->Load( streamBuf ))) break;

                m_lstVisitedPages.push_back( hsi.Detach() );
            }
        }
    }

    //
    // Cleanup broken links.
    //
    {
        CPCHHelpSessionItem* hsi;
        CPCHHelpSessionItem* hsiLast = NULL;
        IterConst            it;

        //
        // First of all, reset broken Forward and Backward pointers.
        //
        for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
        {
            hsi = *it;

            if(FindPage( hsi->m_iIndexPrev ) == NULL) hsi->m_iIndexPrev = CPCHHelpSessionItem::NO_LINK;
            if(FindPage( hsi->m_iIndexNext ) == NULL) hsi->m_iIndexNext = CPCHHelpSessionItem::NO_LINK;
        }

        //
        // Then, link in some wayFirst of all, reset broken Forward and Backward pointers.
        //
        // REMEMBER, the list is actually a reverse list, so the "Previous" element will follow in the list.
        //
        for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
        {
            hsi = *it;

            //
            // We saw an item not linked, so let's link it!
            //
            if(hsiLast)
            {
                hsiLast->m_iIndexPrev = hsi->m_iIndex; hsiLast = NULL;
            }

            //
            // Oh, unlinked item, remember pointer, probably we can link it to the next one ("previous" actually, see above).
            //
            if(hsi->m_iIndexPrev == CPCHHelpSessionItem::NO_LINK)
            {
                hsiLast = hsi;
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::Save()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Save" );

    HRESULT             hr;
    MPC::StorageObject* child;
    int                 iCount = NUM_OF_ENTRIES_TO_PERSIST;
    List                lstObject;
    IterConst           it;


    //
    // Initialize flags for deletion of unused slots.
    //
    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        CPCHHelpSessionItem* hsi = *it;

        hsi->m_state.ReleaseState( /*fForce*/true );
        hsi->m_fSaved = false;
    }


#ifdef HSS_RPRD
    //
    // If the registry value is set, create a new XML file for the current session.
    //
    {
        DWORD dwDumpSession = 0;
        bool  fFound;

        (void)MPC::RegKey_Value_Read( dwDumpSession, fFound, HC_REGISTRY_HELPCTR, L"DumpHelpSession", HKEY_LOCAL_MACHINE );

        if(dwDumpSession)
        {
            (void)DumpSession();
        }
    }
#endif

    //
    // Get the list of items to return.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, FilterPages( HS_READ, lstObject ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, ItemState_GetIndexObject( /*fCreate*/true, child ));
    if(child)
    {
        CComPtr<IStream> stream;

        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
        if(stream)
        {
            MPC::Serializer_IStream   streamReal( stream     );
            MPC::Serializer_Buffering streamBuf ( streamReal );


            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << l_dwVersion );
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf << m_iLastIndex);

            for(it = lstObject.begin(); it != lstObject.end() && iCount > 0; it++)
            {
                CPCHHelpSessionItem* hsi = *it;

                //
                // Don't save entries without a title.
                //
                if(hsi->m_bstrTitle.Length() == 0) continue;

                //
                // Don't save entries from the exclude list.
                //
                for(int i=0; i<ARRAYSIZE(c_rgExclude); i++)
                {
                    LPCWSTR szURL = hsi->GetURL();

                    if(szURL && !_wcsnicmp( szURL, c_rgExclude[i], wcslen( c_rgExclude[i] ) )) break;
                }
                if(i != ARRAYSIZE(c_rgExclude)) continue;


                __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->Save( streamBuf ));
                iCount--;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamBuf.Flush());
        }
    }

    //
    // Create a new instance of the HelpSession and copy all of valid entries into it.
    //
    {
        CComPtr<CPCHHelpSession> hsCopy;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hsCopy ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, hsCopy->Initialize( NULL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Clone( *hsCopy ));
    }

    DEBUG_DumpSavedPages();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT local_CopyStream( /*[in]*/ MPC::StorageObject* childSrc ,
                                 /*[in]*/ MPC::StorageObject* childDst )
{
    __HCP_FUNC_ENTRY( "local_CopyStream" );

    HRESULT hr;

    if(childSrc && childDst)
    {
        CComPtr<IStream> streamSrc;
        CComPtr<IStream> streamDst;

        __MPC_EXIT_IF_METHOD_FAILS(hr, childSrc->Rewind  ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, childDst->Rewind  ());
        __MPC_EXIT_IF_METHOD_FAILS(hr, childDst->Truncate());

        __MPC_EXIT_IF_METHOD_FAILS(hr, childSrc->GetStream( streamSrc ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, childDst->GetStream( streamDst ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamSrc, streamDst ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::Clone( /*[in]*/ CPCHHelpSession& hsCopy )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Clone" );

    HRESULT             hr;
    MPC::StorageObject* childSrc;
    MPC::StorageObject* childDst;
    MPC::wstring        szFile;
    IterConst           it;


    __MPC_EXIT_IF_METHOD_FAILS(hr,        ItemState_GetIndexObject( /*fCreate*/false, childSrc           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, hsCopy.ItemState_GetIndexObject( /*fCreate*/true ,           childDst ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, local_CopyStream               (                   childSrc, childDst ));

    //
    // Purge unused slots.
    //
    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        CPCHHelpSessionItem* hsi = *it;

        if(hsi->m_fSaved)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr,        ItemState_GetStorageObject( hsi->GetIndex(), /*fCreate*/false, childSrc           ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, hsCopy.ItemState_GetStorageObject( hsi->GetIndex(), /*fCreate*/true ,           childDst ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, local_CopyStream                 (                                    childSrc, childDst ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

#ifdef HSS_RPRD

HRESULT CPCHHelpSession::DumpSession()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::DumpSession" );

    HRESULT              hr;
    MPC::XmlUtil         xml;
    CComPtr<IXMLDOMNode> xdn;
    bool                 fGot = false;

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( L"TravelLog" ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetRoot( &xdn ));

    for(IterConst it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        CPCHHelpSessionItem* hsi = *it;
        XMLHelpSessionItem   dmp;

        if(m_dStartOfSession > hsi->m_dLastVisited) continue;

        dmp.m_ths             =                                                 hsi->m_ths;
        dmp.m_iIndex          =                                                 hsi->m_iIndex;
        dmp.m_dLastVisited    =                                                 hsi->m_dLastVisited;
        dmp.m_lDuration       =                                     86400.0 * ( hsi->m_dDuration - hsi->m_dLastVisited ); // Number of milliseconds for the page.

        dmp.m_bstrURL         =                                                 hsi->m_bstrURL;
        dmp.m_bstrTitle       =                                                 hsi->m_bstrTitle;

        dmp.m_bstrContextID   = CPCHHelpSessionItem::LookupContext( (HscContext)hsi->m_lContextID );
        dmp.m_bstrContextInfo =                                                 hsi->m_bstrContextInfo;
        dmp.m_bstrContextURL  =                                                 hsi->m_bstrContextURL;

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::Config::SaveSubNode( &dmp, xdn ));

        fGot = true;
    }

    if(fGot)
    {
        SYSTEMTIME   st;
        WCHAR        rgTime[512];
        MPC::wstring strFile;

        //
        // Append current time.
        //
        // <FileName>__<Year>_<Month>_<Day>_<hour>-<minute>-<second>
        //
        ::GetLocalTime( &st );
        swprintf( rgTime, L"__%04u-%02u-%02u_%02u-%02u-%02u.xml", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond );


        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( strFile, HC_ROOT_HELPCTR L"\\RPRD" )); strFile.append( rgTime );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( strFile         ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Save    ( strFile.c_str() ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#endif

////////////////////////////////////////

HRESULT CPCHHelpSession::ItemState_GetIndexObject( /*[in]*/  bool                 fCreate ,
                                                   /*[out]*/ MPC::StorageObject*& child   )
{
    return m_disk.GetChild( c_szINDEX, child, STGM_READWRITE, fCreate ? STGTY_STREAM : 0 );
}

HRESULT CPCHHelpSession::ItemState_GetStorageObject( /*[in]*/  int                  iIndex  ,
                                                     /*[in]*/  bool                 fCreate ,
                                                     /*[out]*/ MPC::StorageObject*& child   )
{
    WCHAR rgName[64]; swprintf( rgName, L"STATE_%d", iIndex );

    return m_disk.GetChild( rgName, child, STGM_READWRITE, fCreate ? STGTY_STREAM : 0 );
}

HRESULT CPCHHelpSession::ItemState_CreateStream( /*[in]*/  int               iIndex  ,
                                                 /*[out]*/ CComPtr<IStream>& stream  )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ItemState_CreateStream" );

    HRESULT             hr;
    MPC::StorageObject* child;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ItemState_GetStorageObject( iIndex, /*fCreate*/true, child ));
    if(child)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
    }

    if(!stream)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_FILENOTFOUND);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::ItemState_GetStream( /*[in]*/  int               iIndex  ,
                                              /*[out]*/ CComPtr<IStream>& stream  )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ItemState_GetStream" );

    HRESULT             hr;
    MPC::StorageObject* child;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ItemState_GetStorageObject( iIndex, /*fCreate*/false, child ));
    if(child)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, child->GetStream( stream ));
    }

    if(!stream)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, STG_E_FILENOTFOUND);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::ItemState_DeleteStream( /*[in]*/ int iIndex )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ItemState_DeleteStream" );

    HRESULT             hr;
    MPC::StorageObject* child;


    __MPC_EXIT_IF_METHOD_FAILS(hr, ItemState_GetStorageObject( iIndex, /*fCreate*/false, child ));
    if(child)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, child->Delete());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

CPCHHelpSessionItem* CPCHHelpSession::FindPage( /*[in]*/ BSTR bstrURL )
{
    IterConst it;

    //
    // First of all, look if the page is already present.
    //
    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        if((*it)->SameURL( bstrURL))
        {
            return *it;
        }
    }

    return NULL;
}

CPCHHelpSessionItem* CPCHHelpSession::FindPage( /*[in]*/ IPCHHelpSessionItem* pHSI )
{
    IterConst it;

    //
    // First of all, look if the page is already present.
    //
    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        if((*it) == pHSI)
        {
            return *it;
        }
    }

    return NULL;
}

CPCHHelpSessionItem* CPCHHelpSession::FindPage( /*[in]*/ int iIndex )
{
    IterConst it;

    //
    // First of all, look if the page is already present.
    //
    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        if((*it)->m_iIndex == iIndex)
        {
            return *it;
        }
    }

    return NULL;
}

HRESULT CPCHHelpSession::Erase()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Erase" );

    //
    // Release all the items.
    //
    MPC::ReleaseAll( m_lstVisitedPages       );
    MPC::ReleaseAll( m_lstCachedVisitedPages );
    m_hsiCurrentPage.Release();

    ResetTitles();


    __HCP_FUNC_EXIT(S_OK);
}

////////////////////////////////////////

HRESULT CPCHHelpSession::ResetTitles()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ResetTitles" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    m_mapTitles.clear();

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::RecordTitle( /*[in]*/ BSTR bstrURL   ,
                                      /*[in]*/ BSTR bstrTitle ,
                                      /*[in]*/ bool fStrong   )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::RecordTitle" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    //
    // The binding is not strong, so check if there's already a title for the url.
    //
    if(!STRINGISPRESENT(bstrTitle))
    {
        //
        // If there's already a previous page with the same URL, use its title.
        //
        CPCHHelpSessionItem* hsi = FindPage( bstrURL );

        if(hsi && hsi->m_bstrTitle.Length())
        {
            bstrTitle = hsi->m_bstrTitle;
        }
    }

    if(STRINGISPRESENT(bstrTitle))
    {
        TitleEntry& entry = m_mapTitles[ SAFEBSTR( bstrURL ) ];

        //
        // Only update the title if the new one is more "powerful".
        //
        if(entry.m_fStrong == false || fStrong)
        {
            entry.m_szTitle = bstrTitle;
            entry.m_fStrong = fStrong;
        }
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::LookupTitle( /*[in ]*/ BSTR      bstrURL     ,
                                      /*[out]*/ CComBSTR& bstrTitle   ,
                                      /*[in ]*/ bool      fUseIECache )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::LookupTitle" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    if(fUseIECache)
    {
        if(!m_pIHistory)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUrlHistoryStg, (LPVOID*)&m_pIHistory ));
        }

        if(m_pIHistory)
        {
            STATURL stat;

            if(SUCCEEDED(m_pIHistory->QueryUrl( bstrURL, 0, &stat )))
            {
                bstrTitle = stat.pwcsTitle;
            }
        }
    }
    else
    {
        TitleIter it;


        it = m_mapTitles.find( MPC::wstring( SAFEWSTR( bstrURL ) ) );
        if(it != m_mapTitles.end())
        {
            bstrTitle = it->second.m_szTitle.c_str();
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHHelpSession::FilterPages( /*[in]*/  HS_MODE hsMode    ,
                                      /*[out]*/ List&   lstObject )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::FilterPages" );

    HRESULT   hr;
    List      lstAlreadySeen;
    IterConst it;


    for(it = m_lstVisitedPages.begin(); it != m_lstVisitedPages.end(); it++)
    {
        CPCHHelpSessionItem* hsi = *it;

        if(hsMode == HS_READ)
        {
            IterConst itRead;

            if(hsi->SeenLongEnough( REMEMBER_PAGE_DELAY ) != true) continue;

            //
            // Make sure there aren't duplicate entries.
            //
            for(itRead = lstAlreadySeen.begin(); itRead != lstAlreadySeen.end(); itRead++)
            {
                if(hsi->SameURL( *itRead )) break;
            }
            if(itRead != lstAlreadySeen.end())
            {
                continue;
            }


            //
            // Add the new URL to the list of seen URLs.
            //
            lstAlreadySeen.push_back( hsi );
        }

        lstObject.push_back( hsi );
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpSession::AllocateItem( /*[in ]*/ bool                          fNew      ,
                                       /*[in ]*/ bool                          fLink     ,
                                       /*[in ]*/ bool                          fNewIndex ,
                                       /*[out]*/ CComPtr<CPCHHelpSessionItem>& hsi       )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::AllocateItem" );

    HRESULT              hr;
    CPCHHelpSessionItem* hsiPrev = m_hsiCurrentPage;

    //
    // If we are flagged to recycle the current item, let's do so.
    //
    if(fNew && fLink && m_fOverwrite)
    {
        m_fOverwrite = false;

        if(hsiPrev)
        {
            hsi = hsiPrev;

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    //
    // Create a new item and link it to the system.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &hsi )); hsi->Initialize( this, /*fNew*/fNew );

    //
    // Build the chain of predecessor-successor.
    //
    if(fNewIndex)
    {
        hsi->m_iIndex = m_iLastIndex++;
    }

    if(fLink && hsiPrev && hsi->m_ths == hsiPrev->m_ths)
    {
        hsiPrev->m_iIndexNext = hsi    ->m_iIndex;
        hsi    ->m_iIndexPrev = hsiPrev->m_iIndex;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::SetCurrentItem( /*[in]*/ bool fLink, /*[in]*/ CPCHHelpSessionItem* hsi )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::SetCurrentItem" );

    HRESULT hr;

    if(hsi != m_hsiCurrentPage)
    {
        //
        // When navigating to a new page, "Leave" the previous one and "Enter" the new one.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, LeaveCurrentPage());

        m_hsiCurrentPage = hsi; __MPC_EXIT_IF_METHOD_FAILS(hr, m_hsiCurrentPage->Enter());

        if(fLink)
		{
			m_lstVisitedPages.push_front( hsi ); hsi->AddRef();
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, AppendToCached( hsi ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::AppendToCached( /*[in]*/ CPCHHelpSessionItem* hsi )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::AppendToCached" );

    HRESULT hr;

    if(hsi)
    {
		IterConst 			 it;
		IterConst 			 itOldest;
		bool      			 fGot      = false;
		CPCHHelpSessionItem* hsiOldest = NULL;

        for(it = m_lstCachedVisitedPages.begin(); it != m_lstCachedVisitedPages.end(); it++)
        {
			CPCHHelpSessionItem* hsiObj = *it;

			if(hsiObj == hsi) { fGot = true; break; }

			if(!hsiOldest || hsiOldest->m_dLastVisited > hsiObj->m_dLastVisited)
			{
				itOldest  = it;
				hsiOldest = hsiObj;
			}
		}

		if(fGot == false)
		{
			if(m_lstCachedVisitedPages.size() > l_iMaxCachedItems && hsiOldest)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, hsiOldest->m_state.ReleaseState( /*fForce*/false ));

				m_lstCachedVisitedPages.erase( itOldest ); hsiOldest->Release();
			}

			__MPC_EXIT_IF_METHOD_FAILS(hr, hsi->m_state.AcquireState());

			m_lstCachedVisitedPages.push_front( hsi ); hsi->AddRef();
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::RegisterContextSwitch( /*[in ]*/ HscContext            iVal     ,
                                                /*[in ]*/ BSTR                  bstrInfo ,
                                                /*[in ]*/ BSTR                  bstrURL  ,
                                                /*[out]*/ CPCHHelpSessionItem* *pVal     )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::RegisterContextSwitch" );

    HRESULT hr;

    if(pVal)
    {
        CComPtr<CPCHHelpSessionItem> hsi;

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem( /*fNew*/true, /*fLink*/false, /*fNewIndex*/false, hsi ));

        hsi->m_lContextID      = iVal;
        hsi->m_bstrContextInfo = bstrInfo;
        hsi->m_bstrContextURL  = bstrURL;

        *pVal = hsi.Detach();
    }
    else
    {
        m_lContextID      = iVal;
        m_bstrContextInfo = bstrInfo;
        m_bstrContextURL  = bstrURL;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::RecordNavigationInAdvance( /*[in]*/ BSTR bstrURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::RecordNavigationInAdvance" );

    HRESULT                      hr;
    CComPtr<CPCHHelpSessionItem> hsi;


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem( /*fNew*/true, /*fLink*/true, /*fNewIndex*/true, hsi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->put_URL  ( bstrURL ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->put_Title( NULL    ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetCurrentItem( /*fLink*/true, hsi ));
    m_fAlreadyCreated = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::DuplicateNavigation()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::DuplicateNavigation" );

    HRESULT                      hr;
    CComPtr<CPCHHelpSessionItem> hsi;
    bool                         fAcquired = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem( /*fNew*/true, /*fLink*/true, /*fNewIndex*/true, hsi ));

    if(m_hsiCurrentPage)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->HistoryClone( /*fContext*/false, m_hsiCurrentPage )); fAcquired = true;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, SetCurrentItem( /*fLink*/true, hsi ));
    m_fAlreadyCreated = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired && hsi) (void)hsi->m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::CancelNavigation()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::CancelNavigation" );

    HRESULT hr;

    if(m_fAlreadyCreated) // The navigation has been cancelled but an entry was already created. Recycle it.
    {
        m_fOverwrite = true;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CPCHHelpSession::SetThreshold()
{
    m_dLastNavigation = MPC::GetSystemTimeEx( /*fHighPrecision*/false );
}

void CPCHHelpSession::CancelThreshold()
{
    m_dLastNavigation = 0.0;
}

bool CPCHHelpSession::HasThresholdExpired()
{
    DATE dStart = MPC::GetSystemTimeEx( /*fHighPrecision*/false );

#ifdef DEBUG
    if(m_dLastNavigation)
    {
        DebugLog( L"Threshold: %g\n", (dStart - m_dLastNavigation) * 86400 );
    }
#endif

    if(m_dLastNavigation && (dStart - m_dLastNavigation) < l_dNewNavigationThreshold) return false;

    return true;
}


bool CPCHHelpSession::IsUrlToIgnore( /*[in]*/ LPCWSTR szURL, /*[in]*/ bool fRemove )
{
    if(szURL)
    {
        MPC::WStringUCIter it;
        MPC::wstringUC     str( szURL );

        for(it = m_lstIgnore.begin(); it != m_lstIgnore.end(); it++)
        {
            if(str == *it)
            {
                if(fRemove) m_lstIgnore.erase( it );

                return true;
            }
        }
    }

    return false;
}

HRESULT CPCHHelpSession::IgnoreUrl( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::IgnoreUrl" );

    HRESULT hr;

    m_lstIgnore.push_back( szURL );

    hr = S_OK;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::StartNavigation( /*[in]*/ BSTR     bstrURL ,
                                          /*[in]*/ HscPanel idPanel )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::StartNavigation" );

    HRESULT hr;


    if(IsUrlToIgnore( bstrURL, /*fRemove*/false ))
    {
        DebugLog( L"StartNavigation: IsUrlToIgnore %s\n", bstrURL );
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    //
    // For now, we just consider content navigations.
    //
    if(idPanel != HSCPANEL_CONTENTS &&
       idPanel != HSCPANEL_HHWINDOW  )
    {
        DebugLog( L"StartNavigation: Wrong panel %d\n", (int)idPanel );
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

#ifdef DEBUG
    {
        WCHAR rgBuf[1024]; _snwprintf( rgBuf, MAXSTRLEN(rgBuf), L"StartNavigation: start %s", SAFEWSTR( bstrURL ) );

        DEBUG_DumpState( rgBuf, /*fHeader*/true, /*fCurrent*/false, /*fAll*/false, /*fState*/false );
    }
#endif

    //
    // When we navigate away from the Homepage, let's change the context....
    //
    {
        static const CComBSTR c_bstrURL_Home( L"hcp://system/HomePage.htm" );

        if(m_lContextID == HSCCONTEXT_HOMEPAGE && MPC::StrICmp( bstrURL, c_bstrURL_Home ) != 0)
        {
            m_lContextID = HSCCONTEXT_FULLWINDOW;
        }
    }

    //
    // Check recursion.
    //
    if(m_dwTravelling++)
    {
        DebugLog( L"StartNavigation: Travelling %d\n", (int)m_dwTravelling );
        SetThreshold();
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    //
    // If it hasn't passed enough time, ignore navigation!
    //
    if(HasThresholdExpired() == false)
    {
        if(m_dwIgnore == 0) // But only if we are not inside another controlled navigation!
        {
            m_dwIgnore++;
            m_dwNoEvents++;

            DebugLog( L"StartNavigation: Threshold Expired\n" );
        }
    }
    SetThreshold();

    //
    // Flag set, so we don't create a new node.
    //
    if(m_dwIgnore)
    {
        DebugLog( L"StartNavigation: Ignore Start %d\n", (int)m_dwIgnore );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_fAlreadyCreated == false || m_hsiCurrentPage == NULL)
    {
        CComPtr<CPCHHelpSessionItem> hsi;

        DebugLog( L"%%%%%%%%%%%%%%%%%%%% NEW ENTRY %s\n", SAFEBSTR( bstrURL ) );

        __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem( /*fNew*/true, /*fLink*/true, /*fNewIndex*/true, hsi ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SetCurrentItem( /*fLink*/true, hsi ));
    }
    else
    {
        DebugLog( L"StartNavigation: Recycle entry\n" );
    }

    if(m_hsiCurrentPage)
    {
        m_hsiCurrentPage->m_fInitialized = true;
        m_hsiCurrentPage->m_fUseHH       = (idPanel == HSCPANEL_HHWINDOW);
        m_fAlreadyCreated                = false;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_hsiCurrentPage->put_URL  ( bstrURL ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_hsiCurrentPage->put_Title( NULL    ));
    }

    DEBUG_DumpState( L"StartNavigation: end", /*fHeader*/true, /*fCurrent*/true, /*fAll*/false, /*fState*/false );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::CompleteNavigation( /*[in]*/ HscPanel idPanel )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::CompleteNavigation" );

    HRESULT hr;


    //
    // For now, we just consider content navigations.
    //
    if(idPanel != HSCPANEL_CONTENTS &&
       idPanel != HSCPANEL_HHWINDOW  )
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    DEBUG_DumpState( L"CompleteNavigation", /*fHeader*/true, /*fCurrent*/true, /*fAll*/false, /*fState*/false );


    //
    // Handle startup scenario: we cannot rely on BeforeNavigate to occur.
    //
    if(!IsTravelling())
    {
        //
        // Sometime, frequently on startup, the web browser embedded in HTMLHELP doesn't fire the BeforeNavigate event, so we are stuck with previous CPCHHelpSessionItem.
        //
        if(idPanel == HSCPANEL_HHWINDOW)
        {
            m_fAlreadyCreated = false;
        }

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK); // Spurious notification.
    }

    SetThreshold();
    m_fAlreadyCreated = false;


    //
    // Check recursion.
    //
    if(--m_dwTravelling)
    {
        if(m_dwIgnore  ) m_dwIgnore--;
        if(m_dwNoEvents) m_dwNoEvents--;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_dwIgnore)
    {
        m_dwIgnore--;
    }


    if(m_dwNoEvents == 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent_PersistLoad     (                                     ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent_NavigateComplete( m_hsiCurrentPage->GetURL(), idPanel ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->Events().FireEvent_TravelDone      (                                     ));
    }
    else
    {
        m_dwNoEvents--;
    }


    //
    // Look up the title in the map, in the IE cache or in the document.
    //
    if(m_hsiCurrentPage)
    {
        m_hsiCurrentPage->ExtractTitle();
    }


    DEBUG_DumpState( L"CompleteNavigation: end", /*fHeader*/true, /*fCurrent*/true, /*fAll*/true, /*fState*/false );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsurePlace());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::ForceHistoryPopulate()
{
    return LeaveCurrentPage( /*fSaveHistory*/true, /*fClearPage*/false );
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpSession::LeaveCurrentPage( /*[in]*/ bool fSaveHistory, /*[in]*/ bool fClearPage )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::LeaveCurrentPage" );

    HRESULT                      hr;
    CComPtr<CPCHHelpSessionItem> hsi = m_hsiCurrentPage;


    if(hsi)
    {
        hsi->ExtractTitle();

        if(fSaveHistory && m_fAlreadySaved == false)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->HistoryPopulate());
            m_fAlreadySaved = true;

            DEBUG_DumpState( L"Populate", /*fHeader*/false, /*fCurrent*/true, /*fAll*/false, /*fState*/true );
        }

        //
        // Update the time spent on this page.
        //
        if(fClearPage)
        {
            hsi->Leave();

            m_hsiCurrentPage.Release();
            m_fAlreadySaved  = false;
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHHelpSession::FindTravelLog( /*[in]*/ long lLength, /*[out]*/ CPCHHelpSessionItem*& hsi )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::FindTravelLog" );

    HRESULT hr;

    hsi = m_hsiCurrentPage;
    while(hsi && lLength)
    {
        if(lLength > 0)
        {
            lLength--;

            hsi = FindPage( hsi->m_iIndexNext );
        }
        else
        {
            lLength++;

            hsi = FindPage( hsi->m_iIndexPrev );
        }
    }

    if(hsi == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

//    DebugLog( L"Next %s\n", SAFEBSTR( hsi->GetURL() ) );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::Travel( /*[in]*/ CPCHHelpSessionItem* hsi )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Travel" );

    HRESULT      hr;
    HRESULT      hr2;
    VARIANT_BOOL Cancel;


    m_fPossibleBack = false;


#ifdef DEBUG
    {
        WCHAR rgBuf[1024]; _snwprintf( rgBuf, MAXSTRLEN(rgBuf), L"Travel %d", hsi->m_iIndex );

        DEBUG_DumpState( rgBuf, /*fHeader*/true, /*fCurrent*/false, /*fAll*/false, /*fState*/false );
    }
#endif

    //
    // Sorry, already navigating, abort...
    //
    if(IsTravelling())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Check if someone has something to say about the navigaiton.
    //

    m_dwTravelling++; // Fake counter, so scripts can check "IsNavigating" and find out this is an history navigation.

    hr2 = m_parent->Events().FireEvent_BeforeNavigate( hsi->GetURL(), NULL, HSCPANEL_CONTENTS, &Cancel );

    m_dwTravelling--; // Restore real counter.

    if(SUCCEEDED(hr2))
    {
        if(Cancel == VARIANT_TRUE)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////

    //
    // Update the state information for the page.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, SetCurrentItem( /*fLink*/false, hsi ));


    //
    // Set the new page as the current one (but don't generate a new history element!)
    //
    m_dwIgnore++;

    DEBUG_DumpState( L"Restore", /*fHeader*/true, /*fCurrent*/true, /*fAll*/false, /*fState*/true );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->ChangeContext( (HscContext)hsi->m_lContextID, hsi->m_bstrContextInfo, hsi->m_bstrContextURL, /*fAlsoContent*/false ));

    SetThreshold();

    __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->HistoryRestore());


    DEBUG_DumpState( L"Travel: end", /*fHeader*/true, /*fCurrent*/true, /*fAll*/true, /*fState*/false );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpSession::Travel( /*[in]*/ long lLength )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Travel" );

    HRESULT              hr;
    CPCHHelpSessionItem* hsi;


    __MPC_EXIT_IF_METHOD_FAILS(hr, FindTravelLog( lLength, hsi ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, Travel       (          hsi ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHHelpSession::PossibleBack()
{
    m_fPossibleBack  = true;
    m_dwPossibleBack = ::GetTickCount();
}

bool CPCHHelpSession::IsPossibleBack()
{
    //
    // Since we don't have a way to block VK_BACK in all the cases, we need to look for the sequence VK_BACK -> Navigation.
    // If the two events come within 100millisec, it's a Back navigation, not backspace.
    //
    if(m_fPossibleBack)
    {
        if(m_dwPossibleBack + 100 > ::GetTickCount())
        {
            return true;
        }
    }

    return false;
}

/////////////////////////////////////////////////////////////////////////////
// IPCHHelpSession Methods.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpSession::get_CurrentContext( /*[out, retval]*/ IPCHHelpSessionItem* *ppHSI )
{
    if(ppHSI == NULL) return E_POINTER;

    *ppHSI = NULL;

    return m_hsiCurrentPage ? m_hsiCurrentPage->QueryInterface( IID_IPCHHelpSessionItem, (void**)ppHSI ) : S_OK;
}

STDMETHODIMP CPCHHelpSession::VisitedHelpPages( /*[in]*/          HS_MODE          hsMode ,
                                                /*[out, retval]*/ IPCHCollection* *ppC    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::VisitedHelpPages" );

    HRESULT                 hr;
    List                    lstObject;
    IterConst               it;
    CComPtr<CPCHCollection> pColl;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Create the Enumerator and fill it with jobs.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    //
    // Get the list of items to return.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, FilterPages( hsMode, lstObject ));

    //
    // Fill the collection with results.
    //
    {
        const Taxonomy::HelpSet& ths = m_parent->UserSettings()->THS();

        for(it = lstObject.begin(); it != lstObject.end(); it++)
        {
            CPCHHelpSessionItem* hsi = *it;

            if(hsi->SameSKU( ths ))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->AddItem( hsi ));
            }
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->QueryInterface( IID_IPCHCollection, (void**)ppC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSession::SetTitle( /*[in]*/ BSTR bstrURL   ,
                                        /*[in]*/ BSTR bstrTitle )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::SetTitle" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
        __MPC_PARAMCHECK_NOTNULL(bstrTitle);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, RecordTitle( bstrURL, bstrTitle, /*fStrong*/true ) );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpSession::ForceNavigation( /*[in]*/ BSTR bstrURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ForceNavigation" );

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, StartNavigation   ( bstrURL, HSCPANEL_CONTENTS ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, CompleteNavigation(          HSCPANEL_CONTENTS ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSession::IgnoreNavigation()
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::IgnoreNavigation" );

    HRESULT hr;


    //
    // Save the current state of the browser.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, LeaveCurrentPage( /*fSaveHistory*/true, /*fClearPage*/false ));

    m_dwIgnore++;
    m_dwNoEvents++;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSession::EraseNavigation()
{
    m_fOverwrite = true;

    return S_OK;
}

STDMETHODIMP CPCHHelpSession::IsNavigating( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::IsNavigating" );

    HRESULT hr;


    *pVal = IsTravelling() ? VARIANT_TRUE : VARIANT_FALSE;
    hr    = S_OK;


    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpSession::Back( /*[in]*/ long lLength )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Back" );

    __HCP_FUNC_EXIT( Travel( -lLength ) );
}

STDMETHODIMP CPCHHelpSession::Forward( /*[in]*/ long lLength )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Forward" );

    __HCP_FUNC_EXIT( Travel( lLength ) );
}

STDMETHODIMP CPCHHelpSession::IsValid( /*[in]*/          long          lLength ,
                                       /*[out, retval]*/ VARIANT_BOOL *pVal    )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::IsValid" );

    HRESULT              hr;
    CPCHHelpSessionItem* hsi;


    *pVal = (SUCCEEDED(FindTravelLog( lLength, hsi )) ? VARIANT_TRUE : VARIANT_FALSE);
    hr    = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSession::Navigate( /*[in]*/ IPCHHelpSessionItem* pHSI )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::Navigate" );

    HRESULT                      hr;
    CPCHHelpSessionItem*         hsiSrc;
    CComPtr<CPCHHelpSessionItem> hsi;
    bool                         fAcquired = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pHSI);
    __MPC_PARAMCHECK_END();


    hsiSrc = FindPage( pHSI );
    if(hsiSrc == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, AllocateItem     ( /*fNew    */true, /*fLink*/true, /*fNewIndex*/true, hsi    ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, hsi->HistoryClone( /*fContext*/true,                                   hsiSrc )); fAcquired = true;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Travel( hsi ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(fAcquired && hsi) (void)hsi->m_state.ReleaseState( /*fForce*/false );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHHelpSession::ChangeContext( /*[in]*/ BSTR bstrName, /*[in,optional]*/ VARIANT vInfo, /*[in,optional]*/ VARIANT vURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpSession::ChangeContext" );

    HRESULT     hr;
    HscContext  lContextID = CPCHHelpSessionItem::LookupContext( bstrName );
    CComBSTR    bstrContextInfo;
    CComBSTR    bstrContextURL;

    if(lContextID == HSCCONTEXT_INVALID || m_parent == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    CancelThreshold();

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( bstrContextInfo, &vInfo ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::PutBSTR( bstrContextURL , &vURL  ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->ChangeContext( lContextID, bstrContextInfo, bstrContextURL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\helpcenterexternal.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    HelpCenterExternal.cpp

Abstract:
    This file contains the implementation of the class exposed as the "pchealth" object.

Revision History:
    Ghim-Sim Chua       (gschua)   07/23/99
        created
    Davide Massarenti   (dmassare) 07/25/99
        modified

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

static const WCHAR s_szPanelName_NAVBAR    [] = L"NavBar"    ;
static const WCHAR s_szPanelName_MININAVBAR[] = L"MiniNavBar";
static const WCHAR s_szPanelName_CONTEXT   [] = L"Context"   ;
static const WCHAR s_szPanelName_CONTENTS  [] = L"Contents"  ;
static const WCHAR s_szPanelName_HHWINDOW  [] = L"HHWindow"  ;

static const WCHAR c_szURL_Err_BadUrl      [] = L"hcp://system/errors/badurl.htm";

static const LPCWSTR c_szEntryUrls         [] =
{
    L"hcp://help/tshoot/Err_Hardw_Error3.htm",
    L"hcp://help/tshoot/Err_Hardw_Error10.htm",
    L"hcp://help/tshoot/hwcon.htm",
    L"hcp://help/tshoot/Err_Hardw_Error16.htm",
    L"hcp://help/tshoot/Err_Hardw_Error19.htm",
    L"hcp://help/tshoot/Err_Hardw_Error24.htm",
    L"hcp://help/tshoot/Err_Hardw_Error29.htm",
    L"hcp://help/tshoot/Err_Hardw_Error31.htm",
    L"hcp://help/tshoot/Err_Hardw_Error19.htm",
    L"hcp://help/tshoot/Err_Hardw_Error33.htm",
    L"hcp://help/tshoot/Err_Hardw_Error34.htm",
    L"hcp://help/tshoot/Err_Hardw_Error35.htm",
    L"hcp://help/tshoot/Err_Hardw_Error36.htm",
    L"hcp://help/tshoot/Err_Hardw_Error31.htm",
    L"hcp://help/tshoot/Err_Hardw_Error38.htm",
    L"hcp://help/tshoot/Err_Hardw_Error31.htm",
    L"hcp://help/tshoot/Err_Hardw_Error31.htm",
    L"hcp://help/tshoot/Err_Hardw_Error41.htm",
    L"hcp://help/tshoot/Err_Hardw_Error42.htm",
    L"hcp://help/tshoot/Err_Hardw_Error19.htm",
    L"hcp://help/tshoot/Err_Hardw_Error42.htm",
    L"hcp://help/tshoot/Err_Hardw_Error47.htm",
    L"hcp://help/tshoot/tsUSB.htm",
    L"hcp://help/tshoot/tsdrive.htm",
    L"hcp://help/tshoot/tsdisp.htm",
    L"hcp://help/tshoot/hdw_keyboard.htm",
    L"hcp://help/tshoot/tssound.htm",
    L"hcp://help/tshoot/tsmodem.htm",
    L"hcp://help/tshoot/hdw_mouse.htm",
    L"hcp://help/tshoot/tsInputDev.htm",
    L"hcp://help/tshoot/hdw_tape.htm",

    L"hcp://services/subsite?node=TopLevelBucket_3/Customizing_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_3/Customizing_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web",
    L"hcp://services/subsite?node=TopLevelBucket_1/Windows_basics",
    L"hcp://services/subsite?node=TopLevelBucket_1/Windows_basics",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%25HELP_LOCATION%25%5Carticle.chm%3A%3A/ap_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%25HELP_LOCATION%25%5Carticle.chm%3A%3A/ahn_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%25HELP_LOCATION%25%5Carticle.chm%3A%3A/asa_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%2525HELP_LOCATION%2525%5Carticle.chm%3A%3A/asa_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%2525HELP_LOCATION%2525%5Carticle.chm%3A%3A/ahn_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%2525HELP_LOCATION%2525%5Carticle.chm%3A%3A/ap_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS%3A%2525HELP_LOCATION%2525%5Carticle.chm%3A%3A/avj_intro.htm",


    L"hcp://help/tshoot/hdw_keyboard.htm",
    L"hcp://help/tshoot/tsdrive.htm",
    L"hcp://help/tshoot/hdw_mouse.htm",
    L"hcp://help/tshoot/tsInputDev.htm",


    L"hcp://help/tshoot/hdw_tape.htm",
    L"hcp://help/tshoot/tsUSB.htm",


    L"hcp://help/tshoot/tssound.htm",
    L"hcp://help/tshoot/tsgame.htm",
    L"hcp://help/tshoot/tsInputDev.htm",
    L"hcp://help/tshoot/tsgame.htm",

    L"hcp://services/subsite?node=HP_home/HP_library",

    L"hcp://services/subsite?node=Dell/Dell2",
    L"hcp://services/subsite?node=Dell/Dell1",
    L"hcp://help/tshoot/ts_dvd.htm",
    L"hcp://help/tshoot/tsdisp.htm",
    L"hcp://help/tshoot/tsdrive.htm",
    L"hcp://help/tshoot/tsnetwrk.htm",
    L"hcp://help/tshoot/tshardw.htm",
    L"hcp://help/tshoot/tshomenet.htm",
    L"hcp://help/tshoot/tsinputdev.htm",
    L"hcp://help/tshoot/tsics.htm",
    L"hcp://help/tshoot/tsie.htm",
    L"hcp://help/tshoot/tsmodem.htm",
    L"hcp://help/tshoot/tsgame.htm",
    L"hcp://help/tshoot/tsmessaging.htm",
    L"hcp://help/tshoot/tsprint.htm",
    L"hcp://help/tshoot/tssound.htm",
    L"hcp://help/tshoot/tsstartup.htm",
    L"hcp://help/tshoot/tsusb.htm",

    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_requirements.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_checklistP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_checklistW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_howto_connectP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_howto_connectW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\netcfg.chm%3A%3A/share_conn_overvw.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_determine_internet_connection.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_nohost_computerP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_nohost_computerW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_change_ics_host.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\netcfg.chm%3A%3A/hnw_understanding_bridge.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_comp_name_description.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/sharing_files_overviewP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/sharing_files_overviewW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/windows_shared_documents.htm",

    L"hcp://help/tshoot/tsInputDev.htm",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cdatetime.chm%3A%3A/windows_date_IT_overview.htm&select=Date_Time_Language_and_Regional_Settings",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_webfolders_for_file_transfer.htm&select=TopLevelBucket_2/Networking_and_the_Web/E-mail_and_the_Web/Security_online",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&select=Unmapped/Control_Panel/Appearance_and_Themes/Fonts",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewP.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewW.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewP.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewW.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://help/tshoot/hdw_generic.htm",
    L"hcp://services/subsite?node=Unmapped/Recycle_Bin",
    L"hcp://services/subsite?node=Unmapped/Briefcase",
    L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail2_moreinfo_buffer_underrun.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices",
    L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail3_moreinfo_disk_full.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices",
    L"hcp://system/netdiag/dglogs.htm",
    L"hcp://services/subsite?node=Unmapped/Search",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_shared_documents_folder.htm&select=TopLevelBucket_2/Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Printers_and_Faxes.xml",
    L"hcp://help/tshoot/tsprint.htm",

    L"hcp://services/subsite?node=TopLevelBucket_1/Music__video__games_and_photos&topic=MS-ITS%3A%25HELP_LOCATION%25%5CDisplay.chm%3A%3A/display_switch_to_256_colors.htm&select=TopLevelBucket_1/Music__video__games_and_photos/Games",

    L"hcp://services/subsite?node=TopLevelBucket_4/Fixing_a_problem&select=TopLevelBucket_4/Fixing_a_problem/Using_System_Restore_to_undo_changes",
    L"hcp://system/netdiag/dglogs.htm",
    L"hcp://system/sysinfo/msinfo.htm",
    L"hcp://help/tshoot/tsdrive.htm",
    L"hcp://help/tshoot/tsdisp.htm",
    L"hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/zawbug/start.htm",
    L"hcp://system/updatectr/updatecenter.htm",
    L"hcp://system/compatctr/compatmode.htm",

    L"hcp://help/tshoot00/DVDVideoStream.htm",
    L"hcp://help/tshoot00/DVDAudio2.htm",
    L"hcp://help/tshoot00/DVDRegion.htm",
    L"hcp://help/tshoot00/DVDCopyProtection.htm",
    L"hcp://help/tshoot00/DVDDecoder.htm",
    L"hcp://help/tshoot00/DVDOverlay.htm",
    L"hcp://help/tshoot00/DVDCopyProtection.htm",

    L"hcp://help/tshoot/DVDVideoStream.htm",
    L"hcp://help/tshoot/DVDAudio2.htm",
    L"hcp://help/tshoot/DVDRegion.htm",
    L"hcp://help/tshoot/DVDCopyProtection.htm",
    L"hcp://help/tshoot/DVDDecoder.htm",
    L"hcp://help/tshoot/DVDOverlay.htm",
    L"hcp://help/tshoot/DVDCopyProtection.htm",
    L"hcp://help/tshoot/tssound.htm",

    L"hcp://services/subsite?node=Unmapped/Network_connections&select=Unmapped/Network_connections/Getting_started",
    L"hcp://system/netdiag/dglogs.htm",
    L"hcp://system/panels/Topics.htm?path=TopLevelBucket_4/Fixing_a_problem/Home_Networking_and_network_problems",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\infrared.chm%3A%3A/WLAN_client_configure.htm",
    L"hcp://system/netdiag/dglogs.htm",
    L"hcp://help/tshoot/tsmodem.htm",
    L"hcp://help/tshoot/tsprint.htm",
    L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Scanners_and_Cameras.xml",
    L"hcp://services/subsite?node=TopLevelBucket_1/Music__video__games_and_photos&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/manage_your_pictures.htm&select=TopLevelBucket_1/Music__video__games_and_photos/photos_and_other_digital_images",
    L"hcp://help/tshoot/tsInputDev.htm",
    L"hcp://help/tshoot/tsInputDev.htm",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cdatetime.chm%3A%3A/windows_date_IT_overview.htm&select=Date_Time_Language_and_Regional_Settings",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_webfolders_for_file_transfer.htm&select=TopLevelBucket_2/Networking_and_the_Web/E-mail_and_the_Web/Security_online",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&select=Unmapped/Control_Panel/Appearance_and_Themes/Fonts",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewP.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/sharing_files_overviewW.htm&select=Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://help/tshoot/hdw_generic.htm",
    L"hcp://services/subsite?node=Unmapped/Recycle_Bin",
    L"hcp://services/subsite?node=Unmapped/Briefcase",
    L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail2_moreinfo_buffer_underrun.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices",
    L"hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Ccdmedia.chm%3A%3A/cdmedia_fail3_moreinfo_disk_full.htm&select=TopLevelBucket_4/Hardware/CDs_and_other_storage_devices",
    L"hcp://system/netdiag/dglogs.htm",

    L"hcp://services/subsite?node=Unmapped/Search",
    L"hcp://services/subsite?node=TopLevelBucket_2/Networking_and_the_Web&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cfilefold.chm%3A%3A/using_shared_documents_folder.htm&select=TopLevelBucket_2/Networking_and_the_Web/Sharing_files__printers__and_other_resources",
    L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Printers_and_Faxes.xml",
    L"hcp://help/tshoot/tsprint.htm",
    L"hcp://help/tshoot/tsdisp.htm",
    L"hcp://services/subsite?node=TopLevelBucket_1/Music__video__games_and_photos&topic=MS-ITS%3A%25HELP_LOCATION%25%5CDisplay.chm%3A%3A/display_switch_to_256_colors.htm&select=TopLevelBucket_1/Music__video__games_and_photos/Games",
    L"hcp://services/layout/contentonly?topic=ms-its%3Aarticle.chm%3A%3A/ahn_intro.htm",
    L"hcp://services/layout/contentonly?topic=MS-ITS%3Anetcfg.chm%3A%3A/Howto_conn_directparallel.htm",

    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Accessibility",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Security_and_User_Accounts",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Appearance_and_Themes",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Add_or_Remove_Programs",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Printers_and_Other_Hardware",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Network_Connections",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Performance_and_Maintenance",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Date__Time__Language_and_Regional_Settings",
    L"hcp://services/subsite?node=Unmapped/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Sounds__Speech_and_Audio_Devices",

    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Accessibility",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Security_and_User_Accounts",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Appearance_and_Themes",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Add_or_Remove_Programs",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Printers_and_Other_Hardware",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Network_Connections",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Performance_and_Maintenance",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Date__Time__Language_and_Regional_Settings",
    L"hcp://services/subsite?node=Unmapped/L/Control_Panel&topic=MS-ITS%3A%25HELP_LOCATION%25%5Chs.chm%3A%3A/hs_control_panel.htm&select=Unmapped/Control_Panel/Sounds__Speech_and_Audio_Devices",

    L"hcp://help/tshoot/tsdisp.htm",
    L"hcp://help/tshoot/ts_dvd.htm",
    L"hcp://help/tshoot/tsie.htm",
    L"hcp://help/tshoot/tsmodem.htm",
    L"hcp://help/tshoot/tshomenet.htm",
    L"hcp://help/tshoot/tsnetwrk.htm",
    L"hcp://help/tshoot/tsstartup.htm",
    L"hcp://help/tshoot/tssound.htm",

    L"hcp://help/tshoot/tssound.htm",
    L"hcp://help/tshoot/tsgame.htm",

    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_requirements.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_checklistP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_checklistW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_howto_connectP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_howto_connectW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_nohost_computerP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_nohost_computerW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_determine_internet_connection.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\network.chm%3A%3A/hnw_change_ics_host.htm",
    
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\netcfg.chm%3A%3A/share_conn_overvw.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\netcfg.chm%3A%3A/hnw_understanding_bridge.htm",

    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/sharing_files_overviewP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/sharing_files_overviewW.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3A%25help_location%25\\filefold.chm%3A%3A/windows_shared_documents.htm",

    L"hcp://system/HomePage.htm",

    L"hcp://system/sysinfo/sysinfomain.htm",
    L"hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/Escalation/Common/rcscreen1.htm",
    L"hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/Escalation/Unsolicited/UnSolicitedRCUI.htm",
    L"hcp://system/netdiag/dglogs.htm",
    L"hcp://system/sysinfo/sysInfoLaunch.htm",
    L"hcp://system/sysinfo/sysConfigLaunch.htm",
    L"hcp://system/compatctr/compatmode.htm",
    L"hcp://help/tshoot/tssetup.htm",
    L"hcp://services/centers/support?topic=hcp://system/sysinfo/sysinfomain.htm",
    L"hcp://help/tshoot/hdw_infrared.htm",
    L"hcp://services/layout/contentonly?topic=MS-ITS%3Anetcfg.chm%3A%3A/Howto_conn_directparallel.htm",
    L"hcp://services/layout/contentonly?topic=ms-its%3Aarticle.chm%3A%3A/ahn_intro.htm",
    L"hcp://system/blurbs/windows_newsgroups.htm",
    
    L"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Connection.htm",
    L"hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/Remote%20Assistance/Escalation/Common/rcscreen1.htm",
    L"hcp://services/subsite?node=Security/Public_Key_Infrastructure/Certificate_Servicestopic=MS-ITS:csconcepts.chm::/sag_CS_procs_setup.htm",
    L"hcp://system/updatectr/updatecenter.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:filefold.chm::/manage_your_pictures.htm",
    
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_calibratethepen.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationtoportraitorlandscape.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletbuttons.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletPCforleftorrighthandeduse.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_enableordisableapenbutton.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",

    L"hcp://services/subsite?node=TopLevelBucket_1/Windows_basics&topic=MS-ITS%3A%25HELP_LOCATION%25%5Cntchowto.chm.chm%3A%3A/app_tutorial.htm",

    L"hcp://services/subsite?node=TopLevelBucket_2/Working_Remotely/Remote_Desktop&topic=MS-ITS:rdesktop.chm::/rdesktop_overview.htm",
    L"hcp://services/subsite?node=Administration_and_Scripting_Tools/Remote_Administration_Tools/Remote_Administration_Using_Terminal_Services&topic=MS-ITS:rdesktop.chm::/rdesktops_chm_topnode.htm",
    L"hcp://services/subsite?node=Software_Deployment/Terminal_Services&topic=MS-ITS:termsrv.chm::/ts_chm_top.htm",
    
    L"hcp://services/layout/contentonly?topic=ms-its:article.chm::/ahn_intro.htm",
    L"hcp://services/layout/contentonly?topic=MS-ITS:netcfg.chm::/Howto_conn_directparallel.htm",

    L"hcp://services/layout/fullwindow?topic=MS-ITS:%HELP_LOCATION%\\article.chm::/ap_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%HELP_LOCATION%\\article.chm::/ahn_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%HELP_LOCATION%\\article.chm::/asa_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%25HELP_LOCATION%25\\article.chm::/asa_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%25HELP_LOCATION%25\\article.chm::/ahn_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%25HELP_LOCATION%25\\article.chm::/ap_intro.htm",
    L"hcp://services/layout/fullwindow?topic=MS-ITS:%25HELP_LOCATION%25\\article.chm::/avj_intro.htm",

    L"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Escalation/Common/rcscreen1.htm",
    L"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/Remote Assistance/Escalation/Unsolicited/UnSolicitedRCUI.htm",

    L"hcp://services/subsite?node=TopLevelBucket_1/Windows_basics&topic=MS-ITS:%HELP_LOCATION%\\ntchowto.chm.chm::/app_tutorial.htm",

    L"hcp://CN=Microsoft%20Corporation,L=Redmond,S=Washington,C=US/bugrep.htm",
    L"hcp://CN=Microsoft Corporation,L=Redmond,S=Washington,C=US/bugrep.htm",


    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_notebookoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_stickynotesoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inkballoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_overview.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_options_installs.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/AccessOptions_ct.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:pwrmn.chm::/pwrmn_managing_power.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_adjustscreenbrightness.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_intheoffice.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_athome.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_notebookoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_stickynotesoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inkballoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_overview.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_options_installs.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/AccessOptions_ct.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:pwrmn.chm::/pwrmn_managing_power.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_adjustscreenbrightness.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_intheoffice.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_athome.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://system/panels/Topics.htm?path=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen/Tablet_Pen_Overview",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_notebookoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_stickynotesoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inkballoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_overview.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_options_installs.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/AccessOptions_ct.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:pwrmn.chm::/pwrmn_managing_power.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_adjustscreenbrightness.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_intheoffice.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_athome.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizepenactions.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletbuttons.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizepenactions.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizepenactions.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizepenactions.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationtoportraitorlandscape.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationsequencesettings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_adjustscreenbrightness.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_calibratethepen.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletPCforleftorrighthandeduse.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_movemenustotheleftorright.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-its:tabsys.chm::/hsc_tabletpcoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_your_tablet_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizepenactions.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_enableordisableapenbutton.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_enableordisablepeneraser.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletbuttons.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationtoportraitorlandscape.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationsequencesettings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_TIPoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_notebookoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_stickynotesoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inkballoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_overview.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/accessibility_options_installs.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-ITS:access.chm::/AccessOptions_ct.htm&select=TopLevelBucket_3/Accessibility/Understanding_Windows_XP_accessibility_features",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:pwrmn.chm::/pwrmn_managing_power.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_adjustscreenbrightness.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Conserving_power_on_your_computer",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/hsc_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_intheoffice.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_athome.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_3/Accessibility&topic=MS-its:osk.chm::/OSK_overview.htm&select=TopLevelBucket_3/ Accessibility/Features_for_people_who_have_a_mobility_impairment",
    L"hcp://services/subsite?node=TopLevelBucket_3/Customizing_your_computer&topic=ms-its:input.chm::/input_toolbar_overview.htm&select=TopLevelBucket_3/Customizing_your_computer/Date__time__region__and_language/Region_and_language",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_inmeetings.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",

    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_calibratethepen.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationtoportraitorlandscape.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletPCforleftorrighthandeduse.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletbuttons.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_enableordisableapenbutton.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_penoverview.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Tablet_PC_Pen",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Increasing_Your_Productivitiy_with_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/About_Tablet_PC_Accessories",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_calibratethepen.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_changeyourscreenorientationtoportraitorlandscape.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletPCforleftorrighthandeduse.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_customizetabletbuttons.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&topic=MS-ITS:tabsys.chm::/HSC_enableordisableapenbutton.htm&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
    L"hcp://services/subsite?node=TopLevelBucket_1/Getting_Started_with_Tablet_PC&select=TopLevelBucket_1/Getting_Started_with_Tablet_PC/Customizing_your_Tablet_PC",
        
};


static const LPCWSTR c_szEntryUrlsPartial   [] =
{
    L"hcp://system/DVDUpgrd/dvdupgrd.htm?website=",
    L"hcp://services/layout/xml?definition=hcp://system/dfs/viewmode.xml&topic=hcp://system/dfs/uplddrvinfo.htm%3F",
    L"hcp://services/layout/contentonly?topic=hcp://system/dfs/uplddrvinfo.htm%3f",
};


static const LPCWSTR c_szEntryUrlsEnv       [] =
{
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_complete.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_confirm_select.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_confirm_undo.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_created.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_createRP.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_for_Wizard_Only.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_renamedFolder.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_select.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_undo_complete.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_unsuccessful.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_unsuccessful2.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_unsuccessful3.htm",
    L"hcp://services/layout/contentonly?topic=ms-its:%windir%\\help\\SR_ui.chm::/app_system_restore_welcome.htm",
};


static HscPanel local_LookupPanelName( /*[in]*/ BSTR bstrName )
{
    if(bstrName)
    {
        if(!wcscmp( bstrName, s_szPanelName_NAVBAR    )) return HSCPANEL_NAVBAR    ;
        if(!wcscmp( bstrName, s_szPanelName_MININAVBAR)) return HSCPANEL_MININAVBAR;
        if(!wcscmp( bstrName, s_szPanelName_CONTEXT   )) return HSCPANEL_CONTEXT   ;
        if(!wcscmp( bstrName, s_szPanelName_CONTENTS  )) return HSCPANEL_CONTENTS  ;
        if(!wcscmp( bstrName, s_szPanelName_HHWINDOW  )) return HSCPANEL_HHWINDOW  ;
    }

    return HSCPANEL_INVALID;
}

static LPCWSTR local_ReverseLookupPanelName( /*[in]*/ HscPanel id )
{
    switch(id)
    {
    case HSCPANEL_NAVBAR    : return s_szPanelName_NAVBAR    ;
    case HSCPANEL_MININAVBAR: return s_szPanelName_MININAVBAR;
    case HSCPANEL_CONTEXT   : return s_szPanelName_CONTEXT   ;
    case HSCPANEL_CONTENTS  : return s_szPanelName_CONTENTS  ;
    case HSCPANEL_HHWINDOW  : return s_szPanelName_HHWINDOW  ;
    }

    return NULL;
}

static HRESULT local_ReloadPanel( /*[in]*/ IMarsPanel* pPanel )
{
    __HCP_FUNC_ENTRY( "local_ReloadPanel" );

    HRESULT hr;


    if(pPanel)
    {
        CComPtr<IDispatch>        disp;
        CComQIPtr<IWebBrowser2>   wb2;
        CComQIPtr<IHTMLDocument2> doc2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, pPanel->get_content( &disp ));

        wb2 = disp;
        if(wb2)
        {
            disp.Release();

            __MPC_EXIT_IF_METHOD_FAILS(hr, wb2->get_Document( &disp ));
        }

        doc2 = disp;
        if(doc2)
        {
            CComPtr<IHTMLLocation> spLoc;

            __MPC_EXIT_IF_METHOD_FAILS(hr, doc2->get_location( &spLoc ));
            if(spLoc)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, spLoc->reload( VARIANT_TRUE ));

                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }
    }

    hr = E_NOINTERFACE;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT local_ReloadStyle( /*[in]*/ IHTMLWindow2* win )
{
    __HCP_FUNC_ENTRY( "local_ReloadStyle" );

    HRESULT                             hr;
    CComPtr<IHTMLDocument2>             doc;
    CComPtr<IHTMLStyleSheetsCollection> styles;
    VARIANT                             vIdx;
    long                                lNumStyles;

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(doc       , win   , document   );
    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(styles    , doc   , styleSheets);
    MPC_SCRIPTHELPER_GET__DIRECT         (lNumStyles, styles, length     );

    vIdx.vt = VT_I4;
    for(vIdx.lVal=0; vIdx.lVal<lNumStyles; vIdx.lVal++)
    {
        CComQIPtr<IHTMLStyleSheet> css;
        CComVariant                v;

        __MPC_EXIT_IF_METHOD_FAILS(hr, styles->item( &vIdx, &v ));
        if(v.vt == VT_DISPATCH && (css = v.pdispVal))
        {
            CComBSTR bstrHREF;

            MPC_SCRIPTHELPER_GET__DIRECT(bstrHREF, css, href);

            if(!MPC::StrICmp( bstrHREF, L"hcp://system/css/shared.css" ))
            {
                MPC_SCRIPTHELPER_PUT__DIRECT(css, href, bstrHREF);
                break;
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

static HRESULT local_ApplySettings( /*[in]*/ IDispatch* disp )
{
    __HCP_FUNC_ENTRY( "local_ApplySettings" );

    HRESULT                 hr;
    CComPtr<IHTMLDocument2> doc;
    CComPtr<IHTMLWindow2>   win;
    CComPtr<IHTMLWindow2>   winTop;

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::IDispatch_To_IHTMLDocument2( doc, disp ));

    MPC_SCRIPTHELPER_GET__DIRECT(win   , doc, parentWindow);
    MPC_SCRIPTHELPER_GET__DIRECT(winTop, win, top         );

    __MPC_EXIT_IF_METHOD_FAILS(hr, local_ReloadStyle( winTop ));

    {
        CComPtr<IHTMLFramesCollection2> frames;
        VARIANT                         vIdx;
        long                            lNumFrames;

        MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(frames    , winTop, frames);
        MPC_SCRIPTHELPER_GET__DIRECT         (lNumFrames, frames, length);

        vIdx.vt = VT_I4;
        for(vIdx.lVal=0; vIdx.lVal<lNumFrames; vIdx.lVal++)
        {
            CComQIPtr<IHTMLWindow2> frame;
            CComVariant             v;

            __MPC_EXIT_IF_METHOD_FAILS(hr, frames->item( &vIdx, &v ));
            if(v.vt == VT_DISPATCH && (frame = v.pdispVal))
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, local_ReloadStyle( frame ));
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

static HRESULT local_GetProperty( /*[in ]*/ CComDispatchDriver& driver ,
                                  /*[in ]*/ LPCWSTR             szName ,
                                  /*[out]*/ CComVariant&        v      )
{
    v.Clear();

    return driver.GetPropertyByName( CComBSTR( szName ), &v );
}

static HRESULT local_GetProperty( /*[in ]*/ CComDispatchDriver& driver ,
                                  /*[in ]*/ LPCWSTR             szName ,
                                  /*[out]*/ MPC::wstring&       res    )
{
    HRESULT     hr;
    CComVariant v;

    res.erase();

    if(SUCCEEDED(hr = local_GetProperty( driver, szName, v )))
    {
        if(SUCCEEDED(hr = v.ChangeType( VT_BSTR )))
        {
            res = SAFEBSTR(v.bstrVal);
        }
    }

    return hr;
}

static HRESULT local_GetProperty( /*[in ]*/ CComDispatchDriver& driver ,
                                  /*[in ]*/ LPCWSTR             szName ,
                                  /*[out]*/ long&               res    )
{
    HRESULT     hr;
    CComVariant v;

    res = 0;

    if(SUCCEEDED(hr = local_GetProperty( driver, szName, v )))
    {
        if(SUCCEEDED(hr = v.ChangeType( VT_I4 )))
        {
            res = v.lVal;
        }
    }

    return hr;
}


static bool local_IsValidTopicURL(BSTR bstrUrl)
{
    __HCP_FUNC_ENTRY( "local_IsValidTopicURL" );

    CComPtr<IPCHTaxonomyDatabase>   db;
    CComPtr<IPCHCollection>         coll;
    CComVariant                     v;
    long                            lCount;
    bool                            fValid = false;
    HRESULT                         hr;

    // Grant trust
    CPCHHelpCenterExternal::TLS* tlsOld = CPCHHelpCenterExternal::s_GLOBAL->GetTLS();                         
    CPCHHelpCenterExternal::TLS  tlsNew;  CPCHHelpCenterExternal::s_GLOBAL->SetTLS( &tlsNew );                
                                                                                     
    tlsNew.m_fSystem  = true;                                                    
    tlsNew.m_fTrusted = true;                                                    

    // Lookup database
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->get_Database(&db));
    
    __MPC_EXIT_IF_METHOD_FAILS(hr, db->LocateContext(bstrUrl, v, &coll));
    
    __MPC_EXIT_IF_METHOD_FAILS(hr, coll->get_Count(&lCount));
    
    if (lCount >= 1) fValid = true;
        
	__HCP_FUNC_CLEANUP;

    // Restore trust
    CPCHHelpCenterExternal::s_GLOBAL->SetTLS( tlsOld );

	__HCP_FUNC_EXIT(fValid);
}


static bool local_IsValidEntryURL(BSTR bstrUrl)
{
    HyperLinks::ParsedUrl   pu;
    CComBSTR                bstrTopic; 
    bool                    fValid = true;

    if (!bstrUrl) return false;
    
    pu.Initialize(bstrUrl);
    
    switch (pu.m_fmt)
    {
        case HyperLinks::FMT_CENTER_HOMEPAGE    : // hcp://services/centers/homepage
            break;
            
        case HyperLinks::FMT_CENTER_SUPPORT     : // hcp://services/centers/support
        case HyperLinks::FMT_CENTER_OPTIONS     : // hcp://services/centers/options
        case HyperLinks::FMT_CENTER_UPDATE      : // hcp://services/centers/update
        case HyperLinks::FMT_CENTER_COMPAT      : // hcp://services/centers/compat
        case HyperLinks::FMT_CENTER_TOOLS       : // hcp://services/centers/tools
        case HyperLinks::FMT_CENTER_ERRMSG      : // hcp://services/centers/errmsg

        case HyperLinks::FMT_SEARCH             : // hcp://services/search?query=<text to look up>
        case HyperLinks::FMT_INDEX              : // hcp://services/index?application=<optional island of help ID>
        case HyperLinks::FMT_SUBSITE            : // hcp://services/subsite?node=<subsite location>&topic=<url of the topic to display>&select=<subnode to highlight>

        case HyperLinks::FMT_LAYOUT_FULLWINDOW  : // hcp://services/layout/fullwindow?topic=<url of the topic to display>
        case HyperLinks::FMT_LAYOUT_CONTENTONLY : // hcp://services/layout/contentonly?topic=<url of the topic to display>
        case HyperLinks::FMT_LAYOUT_KIOSK       : // hcp://services/layout/kiosk?topic=<url of the topic to display>
            if (pu.GetQueryField(L"topic", bstrTopic))
                fValid =  local_IsValidTopicURL(bstrTopic);
            break;

        case HyperLinks::FMT_REDIRECT           : // hcp://services/redirect?online=<url>&offline=<backup url>
            if (pu.GetQueryField(L"online", bstrTopic))
                fValid = local_IsValidTopicURL(bstrTopic);
            if (fValid && pu.GetQueryField(L"offline", bstrTopic))
                fValid = local_IsValidTopicURL(bstrTopic);
            break;

        default:
            fValid = false;
            break;
    }

    if (!fValid)
    {
        // Check explicit entry URLs
        for (int i=0; i<sizeof(c_szEntryUrls)/sizeof(c_szEntryUrls[0]); i++)
        {
            if (_wcsicmp(bstrUrl, c_szEntryUrls[i]) == 0)
            {
                fValid = true; break;
            }
        }
    }

    if (!fValid)
    {
        // Check explicit entry URLs (partial)
        for (int i=0; i<sizeof(c_szEntryUrlsPartial)/sizeof(c_szEntryUrlsPartial[0]); i++)
        {
            if (wcslen(bstrUrl) >= wcslen(c_szEntryUrlsPartial[i]) && 
                _wcsnicmp(bstrUrl, c_szEntryUrlsPartial[i], wcslen(c_szEntryUrlsPartial[i])) == 0)
            {
                fValid = true; break;
            }
        }
    }

    if (!fValid)
    {
        // Check explicit entry URLs (env expanded)
        for (int i=0; i<sizeof(c_szEntryUrlsEnv)/sizeof(c_szEntryUrlsEnv[0]); i++)
        {
	        MPC::wstring strExpanded( c_szEntryUrlsEnv[i] ); MPC::SubstituteEnvVariables( strExpanded );
            if (_wcsicmp(bstrUrl, strExpanded.c_str()) == 0)
            {
                fValid = true; break;
            }
        }
    }

        
    return fValid;
}


////////////////////////////////////////////////////////////////////////////////

CPCHHelpCenterExternal::DelayedExecution::DelayedExecution()
{
    mode         = DELAYMODE_INVALID;  // DelayedExecutionMode mode;
                                       //
    iVal         = HSCCONTEXT_INVALID; // HscContext iVal;
                                       // CComBSTR   bstrInfo;
                                       // CComBSTR   bstrURL;
    fAlsoContent = false;              // bool       fAlsoContent;
}

CPCHHelpCenterExternal::CPCHHelpCenterExternal() : m_constHELPCTR( &LIBID_HelpCenterTypeLib  ),
                                                   m_constHELPSVC( &LIBID_HelpServiceTypeLib )
{
    m_fFromStartHelp     = false; // bool                                    m_fFromStartHelp;
    m_fLayout            = false; // bool                                    m_fLayout;
    m_fWindowVisible     = true;  // bool                                    m_fWindowVisible;
    m_fControlled        = false; // bool                                    m_fControlled;
    m_fPersistSettings   = false; // bool                                    m_fPersistSettings;
    m_fHidden            = false; // bool                                    m_fHidden;
                                  //
                                  // CComBSTR                                m_bstrExtraArgument
    m_HelpHostCfg        = NULL;  // HelpHost::XMLConfig*                    m_HelpHostCfg;
                                  // CComBSTR                                m_bstrStartURL;
                                  // CComBSTR                                m_bstrCurrentPlace;
    m_pMTP               = NULL;  // MARSTHREADPARAM*                        m_pMTP;
                                  //
                                  // MPC::CComConstantHolder                 m_constHELPCTR;
                                  // MPC::CComConstantHolder                 m_constHELPSVC;
                                  //
    //////////////////////////////////////////////////////////////////////////////////////////////////////
                                  //
                                  // CPCHSecurityHandle                      m_SecurityHandle;
    m_tlsID              = -1;    // DWORD                                   m_tlsID;
    m_fPassivated        = false; // bool                                    m_fPassivated;
    m_fShuttingDown      = false; // bool                                    m_fShuttingDown;
                                  //
                                  // CComPtr<HelpHost::Main>                 m_HelpHost;
                                  //
                                  // CComPtr<CPCHHelpSession>                m_hs;
                                  // CComPtr<CPCHSecurityManager>            m_SECMGR;
                                  // CComPtr<CPCHElementBehaviorFactory>     m_BEHAV;
                                  // CComPtr<CPCHHelper_IDocHostUIHandler>   m_DOCUI;
                                  //
    m_Service            = NULL;  // CPCHProxy_IPCHService*                  m_Service;
    m_Utility            = NULL;  // CPCHProxy_IPCHUtility*                  m_Utility;
    m_UserSettings       = NULL;  // CPCHProxy_IPCHUserSettings2*            m_UserSettings;
                                  //
    m_panel_ThreadID     = -1;    // DWORD                                   m_panel_ThreadID;
                                  //
                                  // CComPtr<IMarsPanel>                     m_panel_NAVBAR;
                                  // CComPtr<IMarsPanel>                     m_panel_MININAVBAR;
                                  //
                                  // CComPtr<IMarsPanel>                     m_panel_CONTEXT;
                                  // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTEXT_WebBrowser;
                                  // CPCHWebBrowserEvents                    m_panel_CONTEXT_Events;
                                  //
                                  // CComPtr<IMarsPanel>                     m_panel_CONTENTS;
                                  // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTENTS_WebBrowser;
                                  // CPCHWebBrowserEvents                    m_panel_CONTENTS_Events;
                                  //
                                  // CComPtr<IMarsPanel>                     m_panel_HHWINDOW;
                                  // CComPtr<IPCHHelpViewerWrapper>          m_panel_HHWINDOW_Wrapper;
                                  // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_HHWINDOW_WebBrowser;
                                  // CPCHWebBrowserEvents                    m_panel_HHWINDOW_Events;
                                  //
                                  // CComPtr<IMarsWindowOM>                  m_shell;
                                  // CComPtr<ITimer>                         m_timer;
                                  // CPCHTimerHandle                         m_DisplayTimer;
                                  //
    m_dwInBeforeNavigate = 0;     // DWORD                                   m_dwInBeforeNavigate;
                                  // DelayedExecList                         m_DelayedActions;
                                  // CPCHTimerHandle                         m_ActionsTimer;
                                  //
    m_hwnd               = NULL;  // HWND                                    m_hwnd;
                                  // CPCHEvents                              m_Events;
                                  //
                                  // MsgProcList                             m_lstMessageCrackers;
}

CPCHHelpCenterExternal::~CPCHHelpCenterExternal()
{
    if(m_tlsID != -1)
    {
        ::TlsFree( m_tlsID );
        m_tlsID = -1;
    }

    (void)Passivate();

    MPC::_MPC_Module.UnregisterCallback( this );
}

////////////////////

CPCHHelpCenterExternal* CPCHHelpCenterExternal::s_GLOBAL( NULL );

HRESULT CPCHHelpCenterExternal::InitializeSystem()
{
    if(s_GLOBAL) return S_OK;

    return MPC::CreateInstance( &CPCHHelpCenterExternal::s_GLOBAL );
}

void CPCHHelpCenterExternal::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        s_GLOBAL->Release(); s_GLOBAL = NULL;
    }
}

////////////////////

bool CPCHHelpCenterExternal::IsServiceRunning()
{
    bool      fResult = false;
    SC_HANDLE hSCM;

    //
    // First, let's try to query the service status.
    //
    if((hSCM = ::OpenSCManager( NULL, NULL, GENERIC_READ )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, HC_HELPSVC_NAME, SERVICE_QUERY_STATUS )))
        {
            SERVICE_STATUS ss;

            if(::QueryServiceStatus( hService, &ss ))
            {
                if(ss.dwCurrentState == SERVICE_RUNNING)
                {
                    fResult = true;
                }
            }

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }

    //
    // Then, let's make sure it's not DISABLED.
    //
    if((hSCM = ::OpenSCManager( NULL, NULL, GENERIC_READ )))
    {
        SC_HANDLE hService;

        if((hService = ::OpenServiceW( hSCM, HC_HELPSVC_NAME, SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG )))
        {
            BYTE                    rgBuf[2048];
            DWORD                   dwLen;
            LPQUERY_SERVICE_CONFIGW cfg = (LPQUERY_SERVICE_CONFIG)rgBuf;

            if(::QueryServiceConfigW( hService, cfg, sizeof(rgBuf), &dwLen ) && cfg->dwStartType == SERVICE_DISABLED)
            {
                if(::ChangeServiceConfigW( hService            ,  // handle to service
                                           cfg->dwServiceType  ,  // type of service
                                           SERVICE_AUTO_START  ,  // when to start service
                                           cfg->dwErrorControl ,  // severity of start failure
                                           NULL                ,  // service binary file name
                                           NULL                ,  // load ordering group name
                                           NULL                ,  // tag identifier
                                           NULL                ,  // array of dependency names
                                           NULL                ,  // account name
                                           NULL                ,  // account password
                                           cfg->lpDisplayName  )) // display name
                {
                }
            }

            ::CloseServiceHandle( hService );
        }

        ::CloseServiceHandle( hSCM );
    }

    //
    // In case it's not running, let's try to start it.
    //
    if(fResult == false)
    {
        if((hSCM = ::OpenSCManager( NULL, NULL, GENERIC_READ )))
        {
            SC_HANDLE hService;

            if((hService = ::OpenServiceW( hSCM, HC_HELPSVC_NAME, SERVICE_START )))
            {
                if(::StartService( hService, 0, NULL ))
                {
                    fResult = true;
                }

                ::CloseServiceHandle( hService );
            }

            ::CloseServiceHandle( hSCM );
        }
    }

    //
    // Last resort, try to connect to HelpSvc.
    //
    if(fResult == false)
    {
        CComPtr<IPCHService> svc;

        if(m_Service && SUCCEEDED(m_Service->EnsureDirectConnection( svc, false )))
        {
            fResult = true;
        }
    }

    return fResult;
}

HRESULT CPCHHelpCenterExternal::Initialize()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::Initialize" );

    HRESULT hr;
    CLSID   clsid = CLSID_PCHHelpCenter;


    //
    // Register for shutdown.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::_MPC_Module.RegisterCallback( this, (void (CPCHHelpCenterExternal::*)())Passivate ));


    m_SecurityHandle.Initialize( this, (IPCHHelpCenterExternal*)this );


    //
    // Thread Local Storage.
    //
    m_tlsID = ::TlsAlloc();
    if(m_tlsID == -1)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_NO_SYSTEM_RESOURCES);
    }
    SetTLS( NULL );

    //
    // Create Browser Events handlers.
    //
    m_panel_CONTEXT_Events .Initialize( this, HSCPANEL_CONTEXT  );
    m_panel_CONTENTS_Events.Initialize( this, HSCPANEL_CONTENTS );
    m_panel_HHWINDOW_Events.Initialize( this, HSCPANEL_HHWINDOW );
    m_Events               .Initialize( this                    );


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_hs     )); m_hs    ->Initialize( this );
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_SECMGR )); m_SECMGR->Initialize( this );
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_BEHAV  )); m_BEHAV ->Initialize( this );
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_DOCUI  )); m_DOCUI ->Initialize( this );


    //
    // Create the HelpHost objects.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_HelpHost )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_HelpHost->Initialize( this ));


    //
    // Create all the proxies.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_Service ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Service->ConnectToParent (  this           ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Service->GetUtility      ( &m_Utility      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->GetUserSettings2( &m_UserSettings ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHHelpCenterExternal::Passivate()
{
    MPC::ReleaseAll( m_lstMessageCrackers );

    if(m_fPassivated == false)
    {
        if(DoesPersistSettings())
        {
            if(m_hs) (void)m_hs->Persist();
        }
        else
        {
            //
            // Signal the option object to ignore SKU info during save.
            //
            if(CPCHOptions::s_GLOBAL) CPCHOptions::s_GLOBAL->DontPersistSKU();
        }


        if(m_UserSettings) (void)m_UserSettings->SaveUserSettings();

        if(CPCHOptions::s_GLOBAL) CPCHOptions::s_GLOBAL->Save();
    }

    ////////////////////////////////////////////////////////////////////////////////

    m_fPassivated = true;

    delete m_HelpHostCfg; m_HelpHostCfg = NULL;

    if(m_HelpHost) m_HelpHost->Passivate();
    if(m_Service ) m_Service ->Passivate();

    m_panel_CONTEXT_Events .Passivate();
    m_panel_CONTENTS_Events.Passivate();
    m_panel_HHWINDOW_Events.Passivate();
    m_Events               .Passivate();

    m_DisplayTimer.Stop();
    m_ActionsTimer.Stop();

    ////////////////////////////////////////////////////////////////////////////////

                                                         // bool                                    m_fFromStartHelp;
                                                         // bool                                    m_fLayout;
                                                         // bool                                    m_fWindowVisible;
                                                         // bool                                    m_fControlled;
                                                         // bool                                    m_fPersistSettings;
                                                         // bool                                    m_fHidden;
                                                         //
                                                         // CComBSTR                                m_bstrExtraArgument
                                                         // HelpHost::XMLConfig*                    m_HelpHostCfg;
                                                         // CComBSTR                                m_bstrStartURL;
                                                         // CComBSTR                                m_bstrCurrentPlace;
                                                         // MARSTHREADPARAM*                        m_pMTP;
                                                         //
                                                         // MPC::CComConstantHolder                 m_constHELPCTR;
                                                         // MPC::CComConstantHolder                 m_constHELPSVC;
                                                         //
                                                         // ////////////////////////////////////////
                                                         //
                                                         // CPCHSecurityHandle                      m_SecurityHandle;
                                                         // DWORD                                   m_tlsID;
                                                         // bool                                    m_fPassivated;
                                                         //
    m_HelpHost                      .Release();          // CComPtr<HelpHost::Main>                 m_HelpHost;
                                                         //
    m_hs                            .Release();          // CComPtr<CPCHHelpSession>                m_hs;
                                                         // CComPtr<CPCHSecurityManager>            m_SECMGR;
                                                         // CComPtr<CPCHElementBehaviorFactory>     m_BEHAV;
                                                         // CComPtr<CPCHHelper_IDocHostUIHandler>   m_DOCUI;
                                                         //
    MPC::Release2<IPCHService      >( m_Service       ); // CPCHProxy_IPCHService*                  m_Service;
    MPC::Release2<IPCHUtility      >( m_Utility       ); // CPCHProxy_IPCHUtility*                  m_Utility;
    MPC::Release2<IPCHUserSettings2>( m_UserSettings  ); // CPCHProxy_IPCHUserSettings2*            m_UserSettings;
                                                         //
    m_panel_ThreadID                 = -1;               // DWORD                                   m_panel_ThreadID;
                                                         //
    m_panel_NAVBAR                  .Release();          // CComPtr<IMarsPanel>                     m_panel_NAVBAR;
    m_panel_MININAVBAR              .Release();          // CComPtr<IMarsPanel>                     m_panel_MININAVBAR;
                                                         //
    m_panel_CONTEXT                 .Release();          // CComPtr<IMarsPanel>                     m_panel_CONTEXT;
    m_panel_CONTEXT_WebBrowser      .Release();          // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTEXT_WebBrowser;
                                                         // CPCHWebBrowserEvents                    m_panel_CONTEXT_Events;
                                                         //
    m_panel_CONTENTS                .Release();          // CComPtr<IMarsPanel>                     m_panel_CONTENTS;
    m_panel_CONTENTS_WebBrowser     .Release();          // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_CONTENTS_WebBrowser;
                                                         // CPCHWebBrowserEvents                    m_panel_CONTENTS_Events;
                                                         //
    m_panel_HHWINDOW                .Release();          // CComPtr<IMarsPanel>                     m_panel_HHWINDOW;
    m_panel_HHWINDOW_Wrapper        .Release();          // CComPtr<IPCHHelpViewerWrapper>          m_panel_HHWINDOW_Wrapper;
    m_panel_HHWINDOW_WebBrowser     .Release();          // MPC::CComPtrThreadNeutral<IWebBrowser2> m_panel_HHWINDOW_WebBrowser;
                                                         // CPCHWebBrowserEvents                    m_panel_HHWINDOW_Events;
                                                         //
    m_shell                         .Release();          // CComPtr<IMarsWindowOM>                  m_shell;
    m_timer                         .Release();          // CComPtr<ITimer>                         m_timer;
                                                         // CPCHTimerHandle                         m_DisplayTimer;
                                                         //
                                                         // DWORD                                   m_dwInBeforeNavigate;
                                                         // DelayedExecList                         m_DelayedActions;
                                                         // CPCHTimerHandle                         m_ActionsTimer;
                                                         //
    m_hwnd                           = NULL;             // HWND                                    m_hwnd;
                                                         // CPCHEvents                              m_Events;

    m_SecurityHandle.Passivate();
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::ProcessLayoutXML( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ProcessLayoutXML" );

    HRESULT hr;


    delete m_HelpHostCfg; __MPC_EXIT_IF_ALLOC_FAILS(hr, m_HelpHostCfg, new HelpHost::XMLConfig);


    if(FAILED(MPC::Config::LoadFile( m_HelpHostCfg, szURL )))
    {
        delete m_HelpHostCfg; m_HelpHostCfg = NULL;

        m_fLayout = false;
    }
    else
    {
        m_fLayout          = true;
        m_fPersistSettings = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::ProcessArgument( /*[in]*/ int& pos, /*[in]*/ LPCWSTR szArg, /*[in]*/ const int argc, /*[in]*/ LPCWSTR* const argv )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::ProcessArgument" );

    static bool fFromHCP = false;
    HRESULT hr;

    // From HCP, no parameters other than Url are allowed
    if (fFromHCP && _wcsicmp( szArg, L"Url" ) != 0)
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

    if(_wcsicmp( szArg, L"Url" ) == 0)
    {
        HyperLinks::ParsedUrl pu;
        bool                  fValid = true;

        if(pos >= argc) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

        m_bstrStartURL = argv[++pos];

        if (fFromHCP) fValid = local_IsValidEntryURL(m_bstrStartURL);

        if (fValid)
        {
            if(SUCCEEDED(pu.Initialize( m_bstrStartURL )) && pu.m_state == HyperLinks::STATE_NOTPROCESSED)
            {
                if(pu.m_fmt == HyperLinks::FMT_LAYOUT_XML)
                {
                    CComBSTR bstrMode;

                    (void)pu.GetQueryField( L"topic"     , m_bstrStartURL );
                    (void)pu.GetQueryField( L"definition",   bstrMode     );

                    (void)ProcessLayoutXML( bstrMode );
                }
            }
            else
            {
                m_bstrStartURL.Empty();
            }
        }
        else
        {
            CComBSTR bstrURL = m_bstrStartURL;
            m_bstrStartURL = c_szURL_Err_BadUrl;
            m_bstrStartURL.Append(L"?");
            if (bstrURL) m_bstrStartURL.Append(bstrURL);            
        }
    }
    else if(_wcsicmp( szArg, L"ExtraArgument" ) == 0)
    {
        if(pos >= argc) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

        m_bstrExtraArgument = argv[++pos];
    }
    else if(_wcsicmp( szArg, L"Hidden" ) == 0)
    {
        m_fHidden          = true;
        m_fWindowVisible   = false;
        m_fPersistSettings = false;
    }
    else if(_wcsicmp( szArg, L"FromStartHelp" ) == 0)
    {
        m_fFromStartHelp   = true;
        m_fPersistSettings = true;
    }
    else if(_wcsicmp( szArg, L"Controlled" ) == 0)
    {
        if(pos >= argc) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

        {
            CLSID clsid;

            __MPC_EXIT_IF_METHOD_FAILS(hr, ::CLSIDFromString( CComBSTR( argv[++pos] ), &clsid ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_HelpHost->Register( clsid ));
        }

        m_fWindowVisible   = false;
        m_fControlled      = true;
        m_fPersistSettings = false;
    }
    else if(_wcsicmp( szArg, L"Mode" ) == 0)
    {
        if(pos >= argc) __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);

        (void)ProcessLayoutXML( argv[++pos] );
    }
    else if(_wcsicmp( szArg, L"FromHCP" ) == 0)
    {
        fFromHCP         = true;
    }

    if(m_UserSettings)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings->Initialize());
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

bool CPCHHelpCenterExternal::DoWeNeedUI()
{
    if(IsFromStartHelp    ()) return true;
    if(IsControlled       ()) return true;
    if(HasLayoutDefinition()) return true;


    //
    // In case we are called through the HCP: shell association, try to forward to an existing instance.
    //
    {
        CComPtr<IPCHHelpHost> hhEXISTING;
        CLSID                 clsid = CLSID_PCHHelpCenter;

        if(SUCCEEDED(m_HelpHost->Locate( clsid, hhEXISTING )))
        {
            CComVariant v;

            if(SUCCEEDED(hhEXISTING->DisplayTopicFromURL( m_bstrStartURL, v )))
            {
                return false;
            }
        }

        (void)m_HelpHost->Register( clsid );
    }

    return true;
}

HRESULT CPCHHelpCenterExternal::RunUI( /*[in]*/ const MPC::wstring& szTitle, /*[in]*/ PFNMARSTHREADPROC pMarsThreadProc )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::RunUI" );

    HRESULT               hr;
    CComPtr<CPCHMarsHost> pchmh;


    {
        static LPCWSTR rgCriticalFiles[] =
        {
			L"blurbs/about_support.htm"      ,
			L"blurbs/Favorites.htm"			 ,
			L"blurbs/ftshelp.htm"			 ,
			L"blurbs/History.htm"			 ,
			L"blurbs/Index.htm"				 ,
			L"blurbs/isupport.htm"			 ,
			L"blurbs/keywordhelp.htm"		 ,
			L"blurbs/options.htm"			 ,
			L"blurbs/searchblurb.htm"		 ,
			L"blurbs/searchtips.htm"		 ,
			L"blurbs/tools.htm"				 ,
			L"blurbs/windows_newsgroups.htm" ,
			L"css/Behaviors.css"			 ,
			L"css/Layout.css"				 ,
			L"dialogs/DlgLib.js"			 ,
			L"dialogs/Print.dlg"			 ,
			L"errors/badurl.htm"			 ,
			L"errors/connection.htm"		 ,
			L"errors/indexfirstlevel.htm"	 ,
			L"errors/notfound.htm"			 ,
			L"errors/offline.htm"			 ,
			L"errors/redirect.htm"			 ,
			L"errors/unreachable.htm"		 ,
			L"Headlines.htm"				 ,
			L"HelpCtr.mmf"					 ,
			L"HomePage__DESKTOP.htm"		 ,
			L"HomePage__SERVER.htm"			 ,
			L"panels/AdvSearch.htm"			 ,
			L"panels/blank.htm"				 ,
			L"panels/Context.htm"			 ,
			L"panels/firstpage.htm"			 ,
			L"panels/HHWrapper.htm"			 ,
			L"panels/MiniNavBar.htm"		 ,
			L"panels/MiniNavBar.xml"		 ,
			L"panels/NavBar.htm"			 ,
			L"panels/NavBar.xml"			 ,
			L"panels/Options.htm"			 ,
			L"panels/RemoteHelp.htm"		 ,
			L"panels/ShareHelp.htm"			 ,
			L"panels/subpanels/Channels.htm" ,
			L"panels/subpanels/Favorites.htm",
			L"panels/subpanels/History.htm"	 ,
			L"panels/subpanels/Index.htm"	 ,
			L"panels/subpanels/Options.htm"	 ,
			L"panels/subpanels/Search.htm"	 ,
			L"panels/subpanels/Subsite.htm"	 ,
			L"panels/Topics.htm"			 ,
			L"scripts/Common.js"			 ,
			L"scripts/HomePage__DESKTOP.js"	 ,
			L"scripts/HomePage__SERVER.js"	 ,
			L"scripts/HomePage__SHARED.js"	 ,
			L"scripts/wrapperparam.js"       ,
        };

        HyperLinks::ParsedUrl pu;
        bool                  fOk              = true;
		bool                  fFirstWinInetUse = true;
		MPC::wstring          strTmp;

        for(int i=0; i<ARRAYSIZE(rgCriticalFiles); i++)
        {
			strTmp  = L"hcp://system/";
			strTmp += rgCriticalFiles[i];

            if(SUCCEEDED(pu.Initialize( strTmp.c_str() )) && pu.CheckState( fFirstWinInetUse ) != HyperLinks::STATE_ALIVE)
            {
                fOk = false; break;
            }
        }

        if(fOk == false)
        {
            CComPtr<IPCHService> svc;

            if(m_Service == NULL) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_Service->EnsureDirectConnection( svc, false ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, svc->ForceSystemRestore());
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pchmh ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pchmh->Init( this, szTitle, m_pMTP ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pMarsThreadProc( pchmh, m_pMTP ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    Passivate();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

CPCHHelpCenterExternal::TLS* CPCHHelpCenterExternal::GetTLS()
{
    if(m_tlsID != -1)
    {
        return (TLS*)::TlsGetValue( m_tlsID );
    }

    return NULL;
}

void CPCHHelpCenterExternal::SetTLS( TLS* tls )
{
    if(m_tlsID != -1)
    {
        ::TlsSetValue( m_tlsID, (LPVOID)tls );
    }
}

HRESULT CPCHHelpCenterExternal::IsTrusted()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::IsTrusted" );

    HRESULT hr  = E_ACCESSDENIED;
    TLS*    tls = GetTLS();


    if(tls)
    {
        if(tls->m_fTrusted ||
           tls->m_fSystem   )
        {
            hr = S_OK;
        }
    }


    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::IsSystem()
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::IsSystem" );

    HRESULT hr  = E_ACCESSDENIED;
    TLS*    tls = GetTLS();


    if(tls)
    {
        if(tls->m_fSystem)
        {
            hr = S_OK;
        }
    }


    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::RegisterForMessages( /*[in]*/ IOleInPlaceObjectWindowless* ptr, /*[in]*/ bool fRemove )
{
    MsgProcIter it;

    if(!ptr) return E_POINTER;

    for(it = m_lstMessageCrackers.begin(); it != m_lstMessageCrackers.end(); it++)
    {
        if(*it == ptr)
        {
            ptr->Release();
            m_lstMessageCrackers.erase( it );
            break;
        }
    }

    if(fRemove == false)
    {
        ptr->AddRef();
        m_lstMessageCrackers.push_back( ptr );
    }

    return S_OK;
}

STDMETHODIMP CPCHHelpCenterExternal::ProcessMessage( /*[in]*/ MSG* msg )
{
    if(msg->message == WM_SYSCHAR    ||
       msg->message == WM_SYSCOMMAND ||
       msg->message == WM_SETTINGCHANGE )   // (weizhao) Relay WM_SETTINGCHANGE messages to registered windows 
                                            // (i.e. HTMLToolBar activeX controls) for appropriate handling.

    {
        MsgProcIter it;

        for(it = m_lstMessageCrackers.begin(); it != m_lstMessageCrackers.end(); it++)
        {
            LRESULT lres;

            if((*it)->OnWindowMessage( msg->message, msg->wParam, msg->lParam, &lres ) == S_OK)
            {
                return S_OK;
            }
        }
    }

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::SetTLSAndInvoke( /*[in] */ IDispatch*        obj       ,
                                                 /*[in] */ DISPID            id        ,
                                                 /*[in] */ LCID              lcid      ,
                                                 /*[in] */ WORD              wFlags    ,
                                                 /*[in] */ DISPPARAMS*       pdp       ,
                                                 /*[out]*/ VARIANT*          pvarRes   ,
                                                 /*[out]*/ EXCEPINFO*        pei       ,
                                                 /*[in] */ IServiceProvider* pspCaller )
{
    HRESULT hr;
    TLS*    tlsOld = GetTLS();
    TLS     tlsNew;  SetTLS( &tlsNew );

    //
    // Let's see if the caller support the IHTMLDocument2 interface...
    //
    if(pspCaller && m_fPassivated == false)
    {
        (void)pspCaller->QueryService( SID_SContainerDispatch, IID_IHTMLDocument2, (void**)&tlsNew.m_Doc );
        (void)pspCaller->QueryService( IID_IWebBrowserApp    , IID_IWebBrowser2  , (void**)&tlsNew.m_WB  );

        if(tlsNew.m_Doc)
        {
            CComBSTR bstrURL;

            //
            // Yes! So get the URL and set the TRUSTED flag.
            //
            if(SUCCEEDED(tlsNew.m_Doc->get_URL( &bstrURL )))
            {
                tlsNew.m_fTrusted = m_SECMGR->IsUrlTrusted( SAFEBSTR( bstrURL ), &tlsNew.m_fSystem );
            }
        }
    }

    hr = obj->Invoke( id, IID_NULL, lcid, wFlags, pdp, pvarRes, pei, NULL );

    SetTLS( tlsOld );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHHelpCenterExternal::GetIDsOfNames( REFIID    riid      ,
                                                    LPOLESTR* rgszNames ,
                                                    UINT      cNames    ,
                                                    LCID      lcid      ,
                                                    DISPID*   rgdispid  )
{
    HRESULT hr = self::GetIDsOfNames( riid      ,
                                      rgszNames ,
                                      cNames    ,
                                      lcid      ,
                                      rgdispid  );

    if(FAILED(hr))
    {
        hr = m_constHELPCTR.GetIDsOfNames( rgszNames, cNames, lcid, rgdispid );
        if(FAILED(hr))
        {
            hr = m_constHELPSVC.GetIDsOfNames( rgszNames, cNames, lcid, rgdispid );
        }
    }

    return hr;
}

STDMETHODIMP CPCHHelpCenterExternal::Invoke( DISPID      dispidMember ,
                                             REFIID      riid         ,
                                             LCID        lcid         ,
                                             WORD        wFlags       ,
                                             DISPPARAMS* pdispparams  ,
                                             VARIANT*    pvarResult   ,
                                             EXCEPINFO*  pexcepinfo   ,
                                             UINT*       puArgErr     )
{
    HRESULT hr = self::Invoke( dispidMember ,
                               riid         ,
                               lcid         ,
                               wFlags       ,
                               pdispparams  ,
                               pvarResult   ,
                               pexcepinfo   ,
                               puArgErr     );

    if(FAILED(hr) && wFlags == DISPATCH_PROPERTYGET)
    {
        hr = m_constHELPCTR.GetValue( dispidMember, lcid, pvarResult );
        if(FAILED(hr))
        {
            hr = m_constHELPSVC.GetValue( dispidMember, lcid, pvarResult );
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HWND CPCHHelpCenterExternal::Window() const
{
    return m_hwnd;
}

ITimer* CPCHHelpCenterExternal::Timer() const
{
    return m_timer;
}

IMarsWindowOM* CPCHHelpCenterExternal::Shell() const
{
    return m_shell;
}

IMarsPanel* CPCHHelpCenterExternal::Panel( /*[in]*/ HscPanel id ) const
{
    switch(id)
    {
    case HSCPANEL_NAVBAR    : return m_panel_NAVBAR    ;
    case HSCPANEL_MININAVBAR: return m_panel_MININAVBAR;
    case HSCPANEL_CONTEXT   : return m_panel_CONTEXT   ;
    case HSCPANEL_CONTENTS  : return m_panel_CONTENTS  ;
    case HSCPANEL_HHWINDOW  : return m_panel_HHWINDOW  ;
    }

    return NULL;
}

LPCWSTR CPCHHelpCenterExternal::PanelName( /*[in]*/ HscPanel id ) const
{
    return local_ReverseLookupPanelName( id );
}

//////////////////////////////

IWebBrowser2* CPCHHelpCenterExternal::Context()
{
    IWebBrowser2* pRes = NULL;

    (void)m_panel_CONTEXT_WebBrowser.Access( &pRes );

    return pRes;
}

IWebBrowser2* CPCHHelpCenterExternal::Contents()
{
    IWebBrowser2* pRes = NULL;

    (void)m_panel_CONTENTS_WebBrowser.Access( &pRes );

    return pRes;
}

IWebBrowser2* CPCHHelpCenterExternal::HHWindow()
{
    IWebBrowser2* pRes = NULL;

    (void)m_panel_HHWINDOW_WebBrowser.Access( &pRes );

    return pRes;
}


bool CPCHHelpCenterExternal::IsHHWindowVisible()
{
    CComPtr<IMarsPanel> panel;
    VARIANT_BOOL        fContentsVisible;

    GetPanelDirect( HSCPANEL_HHWINDOW, panel );
    if(panel && SUCCEEDED(panel->get_visible( &fContentsVisible )) && fContentsVisible == VARIANT_TRUE) return true;

    return false;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::NavigateHH( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::NavigateHH" );

    HRESULT      hr;
    MPC::wstring strUrlModified;


    CPCHWrapProtocolInfo::NormalizeUrl( szURL, strUrlModified, /*fReverse*/false );


    //
    // Delayed execution if inside OnBeforeNavigate.
    //
    if(m_dwInBeforeNavigate)
    {
        DelayedExecution& de = DelayedExecutionAlloc();

        de.mode    = DELAYMODE_NAVIGATEHH;
        de.bstrURL = strUrlModified.c_str();

        __MPC_SET_ERROR_AND_EXIT(hr, DelayedExecutionStart());
    }


    if(!m_panel_HHWINDOW_Wrapper)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_panel_HHWINDOW_Wrapper->Navigate( CComBSTR( strUrlModified.c_str() ) ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::SetPanelUrl( /*[in]*/ HscPanel id, /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::SetPanelUrl" );

    HRESULT hr;


    //
    // Delayed execution if inside OnBeforeNavigate.
    //
    if(m_dwInBeforeNavigate)
    {
        DelayedExecution& de = DelayedExecutionAlloc();

        de.mode    = DELAYMODE_NAVIGATEWEB;
        de.bstrURL = szURL;

        __MPC_SET_ERROR_AND_EXIT(hr, DelayedExecutionStart());
    }


    if(m_shell && szURL)
    {
        IMarsPanel* panel = Panel( id );

        if(panel)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, panel->navigate( CComVariant( szURL ), CComVariant() ));
        }
        else
        {
            CComPtr<IMarsPanel> panel2; GetPanelDirect( id, panel2 );

            if(panel2)
            {
                (void)panel2->put_startUrl( CComBSTR( szURL ) );
            }
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHHelpCenterExternal::GetPanel( /*[in]*/ HscPanel id, /*[out]*/ IMarsPanel* *pVal, /*[in]*/ bool fEnsurePresence )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::GetPanel" );

    HRESULT           hr;
    IMarsPanel*      *pPanel;
    HelpHost::CompId  idComp;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    //
    // Only return the interface pointer if called from the same thread...
    //
    if(m_panel_ThreadID != ::GetCurrentThreadId())
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }


    switch(id)
    {
    case HSCPANEL_NAVBAR    : pPanel = &m_panel_NAVBAR    ; idComp = HelpHost::COMPID_NAVBAR    ; break;
    case HSCPANEL_MININAVBAR: pPanel = &m_panel_MININAVBAR; idComp = HelpHost::COMPID_MININAVBAR; break;
    case HSCPANEL_CONTEXT   : pPanel = &m_panel_CONTEXT   ; idComp = HelpHost::COMPID_CONTEXT   ; break;
    case HSCPANEL_CONTENTS  : pPanel = &m_panel_CONTENTS  ; idComp = HelpHost::COMPID_MAX       ; break; // Not gated!!
    case HSCPANEL_HHWINDOW  : pPanel = &m_panel_HHWINDOW  ; idComp = HelpHost::COMPID_HHWINDOW  ; break;

    default: __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    if(*pPanel == NULL && fEnsurePresence)
    {
        CComPtr<IMarsPanel> tmp; GetPanelDirect( id, tmp );

        if(tmp)
        {
            USES_CONVERSION;

            CComPtr<IDispatch> disp;

            //
            // Requesting the content actually triggers the creation of the control.
            //
            (void)tmp->get_content( &disp );

            DEBUG_AppendPerf( DEBUG_PERF_MARS, "Wait Panel: %s start", W2A( local_ReverseLookupPanelName( id ) ) );

            if(idComp != HelpHost::COMPID_MAX)
            {
                if(m_HelpHost->WaitUntilLoaded( idComp ) == false)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
                }
            }

            DEBUG_AppendPerf( DEBUG_PERF_MARS, "Wait Panel: %s done", W2A( local_ReverseLookupPanelName( id ) ) );
        }

        if(*pPanel == NULL)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CopyTo( *pPanel, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHHelpCenterExternal::GetPanelWindowObject( /*[in] */ HscPanel       id      ,
                                                      /*[out]*/ IHTMLWindow2* *pVal    ,
                                                      /*[in] */ LPCWSTR        szFrame )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::GetPanelWindowObject" );

    HRESULT               hr;
    CComPtr<IMarsPanel>   panel;
    CComPtr<IDispatch>    disp;
    CComPtr<IHTMLWindow2> window;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( id, &panel, true ));

    MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(disp, panel, content);


    //
    // If the panel is a web browser, we have to go through it to get to the document.
    //
    {
        CComQIPtr<IWebBrowser2> wb( disp );

        if(wb)
        {
            disp.Release();

            MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(disp, wb, Document);
        }
    }


    //
    // From the document, get to the window.
    //
    {
        CComQIPtr<IHTMLDocument2> doc( disp );

        if(doc == NULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(window, doc, parentWindow);
    }

    if(szFrame)
    {
        CComPtr<IHTMLFramesCollection2> frames;
        CComVariant                     vName( szFrame );
        CComVariant                     vRes;

        MPC_SCRIPTHELPER_GET__DIRECT__NOTNULL(frames, window, frames);

        __MPC_EXIT_IF_METHOD_FAILS(hr, frames->item( &vName, &vRes ));

        if(vRes.vt != VT_DISPATCH || vRes.pdispVal == NULL)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        window.Release();

        __MPC_EXIT_IF_METHOD_FAILS(hr, vRes.pdispVal->QueryInterface( IID_IHTMLWindow2, (void**)&window ));
    }

    *pVal = window.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHHelpCenterExternal::GetPanelDirect( /*[in ]*/ HscPanel             id   ,
                                             /*[out]*/ CComPtr<IMarsPanel>& pVal )
{
    pVal.Release();

    if(m_shell)
    {
        LPCWSTR szPanelName = local_ReverseLookupPanelName( id );

        if(szPanelName)
        {
            CComPtr<IMarsPanelCollection> coll;

            if(SUCCEEDED(m_shell->get_panels( &coll )) && coll)
            {
                (void)coll->get_item( CComVariant( szPanelName ), &pVal );
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////

static void local_GetNumber( /*[in]*/  BSTR  bstrData ,
                             /*[in]*/  LONG  lMax     ,
                             /*[out]*/ LONG& lValue   ,
                             /*[out]*/ bool& fCenter  )
{
    if(bstrData)
    {
        if(!_wcsicmp( bstrData, L"CENTER" ))
        {
            lValue  = 0;
            fCenter = true;
        }
        else
        {
            lValue = _wtoi( bstrData );

            if(wcschr( bstrData, '%' ))
            {
                if(lValue <   0) lValue =   0;
                if(lValue > 100) lValue = 100;

                lValue = lMax * lValue / 100;
            }

            fCenter = false;
        }
    }

    if(lValue <    0) lValue =    0;
    if(lValue > lMax) lValue = lMax;
}

HRESULT CPCHHelpCenterExternal::OnHostNotify( /*[in]*/ MARSHOSTEVENT  event  ,
                                              /*[in]*/ IUnknown      *punk   ,
                                              /*[in]*/ LPARAM         lParam )
{
    __HCP_FUNC_ENTRY( "CPCHHelpCenterExternal::OnHostNotify" );

    HRESULT hr;


    if(m_panel_ThreadID == -1)
    {
        m_panel_ThreadID = ::GetCurrentThreadId();
    }

    if(event == MARSHOST_ON_WIN_INIT)
    {
        CComQIPtr<IProfferService> ps = punk;

        DEBUG_AppendPerf( DEBUG_PERF_MARS, "OnHostNotify - MARSHOST_ON_WIN_INIT" );

        m_hwnd = (HWND)lParam;

        m_shell.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, punk->QueryInterface( __uuidof(IMarsWindowOM), (void**)&m_shell ));

        if(ps)
        {
            CComQIPtr<IServiceProvider> sp;


            //
            // Handle security-related things.
            //
            if((sp = m_SECMGR))
            {
                DWORD dwCookie;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ps->ProfferService( SID_SInternetSecurityManager, sp, &dwCookie ));
            }

            //
            // Handle behavior-related things.
            //
            if((sp = m_BEHAV))
            {
                DWORD dwCookie;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ps->ProfferService( SID_SElementBehaviorFactory, sp, &dwCookie ));
            }

            //
            // Handle DocUI requires.
            //
            if((sp = m_DOCUI))
            {
                DWORD dwCookie;

                __MPC_EXIT_IF_METHOD_FAILS(hr, ps->ProfferService( IID_IDocHostUIHandler, sp, &dwCookie ));
            }
        }
    }

    if(event == MARSHOST_ON_WIN_READY)
    {
        CComVariant v;

        DEBUG_AppendPerf( DEBUG_PERF_MARS, "OnHostNotify - MARSHOST_ON_WIN_READY" );

        ////////////////////////////////////////

        //
        // Force loading of the NavBar.
        //
        {
            CComPtr<IMarsPanel> panel;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( HSCPANEL_NAVBAR, &panel, true ));
        }

        //
        // Force loading of the Context.
        //
        {
            CComPtr<IMarsPanel> panel;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( HSCPANEL_CONTEXT, &panel, true ));
        }

        //
        // Force loading of the Contents.
        //
        {
            CComPtr<IMarsPanel> panel;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetPanel( HSCPANEL_CONTENTS, &panel, true ));

            if(m_HelpHost->WaitUntilLoaded( HelpHost::COMPID_FIRSTPAGE ) == false)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
            }
        }

        ////////////////////////////////////////

        //
        // If the registry cache says the system is ready, we can skip the startup phase!!
        //
        if(OfflineCache::Root::s_GLOBAL->IsReady() == false)
        {
            CComPtr<IPCHService> svc;

            if(!m_Service) __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_Service->EnsureDirectConnection( svc, false ));
        }

        ////////////////////////////////////////

        {
            HscContext iVal         = HSCCONTEXT_STARTUP;
            CComBSTR   bstrInfo;
            CComBSTR   bstrUrl;
            bool       fAlsoContent = true;


            if(m_HelpHostCfg)
            {
                for(HelpHost::XMLConfig::ApplyToIter it = m_HelpHostCfg->m_lstSessions.begin(); it != m_HelpHostCfg->m_lstSessions.end(); it++)
                {
                    HelpHost::XMLConfig::ApplyTo& at = *it;
                    Taxonomy::HelpSet             ths;

                    if(at.MatchSystem( this, ths ))
                    {
                        if(!(ths == m_UserSettings->THS()))
                        {
                            CPCHHelpCenterExternal::TLS* tlsOld = GetTLS();
                            CPCHHelpCenterExternal::TLS  tlsNew;  SetTLS( &tlsNew );

                            tlsNew.m_fSystem  = true;
                            tlsNew.m_fTrusted = true;

                            hr = m_UserSettings->Select( CComBSTR( ths.GetSKU() ), ths.GetLanguage() );

                            SetTLS( tlsOld );

                            if(FAILED(hr)) __MPC_FUNC_LEAVE;
                        }

                        iVal = HSCCONTEXT_FULLWINDOW;

                        __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings->put_Scope( at.m_bstrApplication ));

                        if(STRINGISPRESENT(m_bstrStartURL))
                        {
                            bstrUrl.Attach( m_bstrStartURL.Detach() );
                        }
                        else
                        {
                            bstrUrl = at.m_bstrTopicToDisplay;
                        }

                        if(at.m_WindowSettings)
                        {
                            if(at.m_WindowSettings->m_fPresence_Left   ||
                               at.m_WindowSettings->m_fPresence_Top    ||
                               at.m_WindowSettings->m_fPresence_Width  ||
                               at.m_WindowSettings->m_fPresence_Height  )
                            {
                                RECT rcWin;
                                RECT rcMax;

                                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetWindowRect       ( m_hwnd            , &rcWin    ));
                                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SystemParametersInfo( SPI_GETWORKAREA, 0, &rcMax, 0 ));

                                {
                                    LONG lLeft      = rcWin.left;
                                    LONG lTop       = rcWin.top;
                                    LONG lWidth     = rcWin.right  - rcWin.left;
                                    LONG lHeight    = rcWin.bottom - rcWin.top;
                                    LONG lWidthMax  = rcMax.right  - rcMax.left;
                                    LONG lHeightMax = rcMax.bottom - rcMax.top;
                                    bool fCenter;

                                    if(at.m_WindowSettings->m_fPresence_Width)
                                    {
                                        local_GetNumber( at.m_WindowSettings->m_bstrWidth, lWidthMax, lWidth, fCenter ); if(lWidth <= 0) lWidth = 100;
                                    }

                                    if(at.m_WindowSettings->m_fPresence_Height)
                                    {
                                        local_GetNumber( at.m_WindowSettings->m_bstrHeight, lHeightMax, lHeight, fCenter ); if(lHeight <= 0) lHeight = 50;
                                    }

                                    if(at.m_WindowSettings->m_fPresence_Left)
                                    {
                                        local_GetNumber( at.m_WindowSettings->m_bstrLeft, lWidthMax, lLeft, fCenter );
                                        if(fCenter)
                                        {
                                            lLeft = rcMax.left + (lWidthMax - lWidth) / 2;
                                        }
                                        else
                                        {
                                            lLeft += rcMax.left;
                                        }
                                    }

                                    if(at.m_WindowSettings->m_fPresence_Top)
                                    {
                                        local_GetNumber( at.m_WindowSettings->m_bstrTop, lHeightMax, lTop, fCenter );
                                        if(fCenter)
                                        {
                                            lTop = rcMax.top + (lHeightMax - lHeight) / 2;
                                        }
                                        else
                                        {
                                            lTop += rcMax.top;
                                        }
                                    }

                                    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetWindowPos( m_hwnd, NULL, lLeft, lTop, lWidth, lHeight, SWP_NOACTIVATE | SWP_NOZORDER ));
                                }
                            }

                            if(at.m_WindowSettings->m_fPresence_Title && STRINGISPRESENT(at.m_WindowSettings->m_bstrTitle))
                            {
                                __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetWindowTextW( m_hwnd, at.m_WindowSettings->m_bstrTitle ));
                            }

                            if(at.m_WindowSettings->m_fPresence_Maximized)
                            {
                                __MPC_EXIT_IF_METHOD_FAILS(hr, m_shell->put_maximized( at.m_WindowSettings->m_fMaximized ? VARIANT_TRUE : VARIANT_FALSE ));
                            }

                            if(at.m_WindowSettings->m_bstrLayout)
                            {
                                if(!MPC::StrICmp( at.m_WindowSettings->m_bstrLayout, L"Normal"      )) iVal = HSCCONTEXT_FULLWINDOW;
                                if(!MPC::StrICmp( at.m_WindowSettings->m_bstrLayout, L"ContentOnly" )) iVal = HSCCONTEXT_CONTENTONLY;
                                if(!MPC::StrICmp( at.m_WindowSettings->m_bstrLayout, L"Kiosk"       )) iVal = HSCCONTEXT_KIOSKMODE;
                            }


                            if(at.m_WindowSettings->m_fPresence_NoResize)
                            {
                                DWORD dwStyle = ::GetWindowLong( m_hwnd, GWL_STYLE );
                                DWORD dwNewStyle;

                                if(at.m_WindowSettings->m_fNoResize)
                                {
                                    dwNewStyle = dwStyle & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SIZEBOX);
                                }
                                else
                                {
                                    dwNewStyle = dwStyle | (WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SIZEBOX);
                                }

                                if(dwStyle != dwNewStyle)
                                {
                                    ::SetWindowLong( m_hwnd, GWL_STYLE, dwNewStyle );
                                }
                            }
                        }

                        if(at.m_Context)
                        {
                            switch( CPCHHelpSessionItem::LookupContext( at.m_Context->m_bstrID ) )
                            {
                            case HSCCONTEXT_SUBSITE  :
                                if(at.m_Context->m_bstrTaxonomyPath)
                                {
                                    iVal     = HSCCONTEXT_SUBSITE;
                                    bstrInfo = at.m_Context->m_bstrTaxonomyPath;
                                    if(at.m_Context->m_bstrNodeToHighlight)
                                    {
                                        bstrInfo += L" ";
                                        bstrInfo += at.m_Context->m_bstrNodeToHighlight;
                                    }
                                }
                                break;

                            case HSCCONTEXT_SEARCH   :
                                if(at.m_Context->m_bstrQuery)
                                {
                                    iVal     = HSCCONTEXT_SEARCH;
                                    bstrInfo = at.m_Context->m_bstrQuery;
                                }
                                break;

                            case HSCCONTEXT_INDEX    :
                                iVal = HSCCONTEXT_INDEX;
                                break;

                            case HSCCONTEXT_CHANNELS :
                                iVal = HSCCONTEXT_CHANNELS;
                                break;

                            case HSCCONTEXT_FAVORITES:
                                iVal = HSCCONTEXT_FAVORITES;
                                break;
                            case HSCCONTEXT_HISTORY  :
                                iVal = HSCCONTEXT_HISTORY;
                                break;

                            case HSCCONTEXT_OPTIONS  :
                                iVal = HSCCONTEXT_OPTIONS;
                                break;
                            }
                        }

                        break;
                    }
                }
            }

            m_pMTP->dwFlags &= ~MTF_DONT_SHOW_WINDOW;

            {
                bool fProceed;

                if(iVal == HSCCONTEXT_STARTUP && m_bstrStartURL.Length())
                {
                    VARIANT_BOOL Cancel;

                    fProceed = ProcessNavigation( HSCPANEL_CONTENTS ,
                                                  m_bstrStartURL    ,
                                                  NULL              ,
                                                  false             ,
                                                  Cancel            );
                }
                else
                {
                    fProceed = true;
                }

                if(fProceed)
                {
                    __MPC_EXIT_IF_METHOD_FAILS(hr, ChangeContext( iVal, bstrInfo, bstrUrl, fAlsoContent ));
                }
            }

            if(CPCHOptions::s_GLOBAL) (void)CPCHOptions::s_GLOBAL->Apply();

            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // This will tell Mars we have taken care of startup.
        }
    }

    if(event == MARSHOST_ON_WIN_PASSIVATE)
    {
        DEBUG_AppendPerf( DEBUG_PERF_MARS, "OnHostNotify - MARSHOST_ON_WIN_PASSIVATE" );

        m_hwnd = NULL;

        m_shell.Release();
    }

    //
    // Handle panel-related things.
    //
    if(event == MARSHOST_ON_PANEL_CONTROL_CREATE ||
       event == MARSHOST_ON_PANEL_PASSIVATE       )
    {
        bool fShutdown = (event == MARSHOST_ON_PANEL_PASSIVATE);

        CComQIPtr<IMarsPanel> panel = punk;
        if(panel)
        {
            CComBSTR name;

            __MPC_EXIT_IF_METHOD_FAILS(hr, panel->get_name( &name ));
            if(name)
            {
                HscPanel                                 id      = local_LookupPanelName( name );
                MPC::CComPtrThreadNeutral<IWebBrowser2>* browser = NULL;
                CPCHWebBrowserEvents*                    events  = NULL;
                IMarsPanel*                              pPanel;
                CComPtr<IDispatch>                       disp;

#ifdef DEBUG
                {
                    USES_CONVERSION;

                    DEBUG_AppendPerf( DEBUG_PERF_MARS, "OnHostNotify - %s : %s", fShutdown ? "MARSHOST_ON_PANEL_PASSIVATE" : "MARSHOST_ON_PANEL_CONTROL_CREATE", W2A( SAFEWSTR( name ) ) );
                }
#endif

                if(fShutdown)
                {
                    pPanel = NULL;
                }
                else
                {
                    pPanel = panel; (void)pPanel->get_content( &disp );

                    if(CPCHOptions::s_GLOBAL) (void)CPCHOptions::s_GLOBAL->ApplySettings( this, disp );
                }

                switch(id)
                {
                case HSCPANEL_NAVBAR    : m_panel_NAVBAR     = pPanel;                                                                            break;
                case HSCPANEL_MININAVBAR: m_panel_MININAVBAR = pPanel;                                                                            break;
                case HSCPANEL_CONTEXT   : m_panel_CONTEXT    = pPanel; browser = &m_panel_CONTEXT_WebBrowser ; events = &m_panel_CONTEXT_Events ; break;
                case HSCPANEL_CONTENTS  : m_panel_CONTENTS   = pPanel; browser = &m_panel_CONTENTS_WebBrowser; events = &m_panel_CONTENTS_Events; break;
                case HSCPANEL_HHWINDOW  : m_panel_HHWINDOW   = pPanel; browser = &m_panel_HHWINDOW_WebBrowser; events = &m_panel_HHWINDOW_Events; break;
                default                 : __MPC_EXIT_IF_METHOD_FAILS(hr, E_INVALIDARG);
                }

                if(!m_timer && disp)
                {
                    CComPtr<IHTMLDocument2> pDoc;

                    if(SUCCEEDED(MPC::HTML::IDispatch_To_IHTMLDocument2( pDoc, disp )))
                    {
                        CComPtr<IServiceProvider> sp;
                        CComPtr<ITimerService>    ts;

                        if(SUCCEEDED(pDoc->QueryInterface( IID_IServiceProvider, (LPVOID*)&sp )))
                        {
                            if(SUCCEEDED(sp->QueryService( SID_STimerService, IID_ITimerService, (void **)&ts )))
                            {
                                ts->CreateTimer( NULL, &m_timer );

                                m_DisplayTimer.Initialize( m_timer );
                                m_ActionsTimer.Initialize( m_timer );
                            }
                        }
                    }
                }

                if(browser && events)
                {
                    CComQIPtr<IWebBrowser2> wb2 = disp;
                    if(wb2)
                    {
                        MPC_SCRIPTHELPER_PUT__DIRECT(wb2, RegisterAsDropTarget, VARIANT_FALSE); // wb2.RegisterAsDropTarget = false;

                        events->Attach( wb2 );
                    }
                    else
                    {
                        events->Detach();
                    }

                    *browser = wb2;
                }
            }
        }
    }

    if(event == MARSHOST_ON_PANEL_INIT)
    {
        DEBUG_AppendPerf( DEBUG_PERF_MARS, "OnHostNotify - MARSHOST_ON_PANEL_INIT" );
    }

    if(event == MARSHOST_ON_PLACE_TRANSITION_DONE)
    {
        CComQIPtr<IMarsPlace> place = punk;
        if(place)
        {
            m_bstrCurrentPlace.Empty();

            MPC_SCRIPTHELPER_GET__DIRECT(m_bstrCurrentPlace, place, name);

            (void)m_Events.FireEvent_Transition( m_bstrCurrentPlace );
        }
    }

    if(event == MARSHOST_ON_SCRIPT_ERROR)
    {
        CComQIPtr<IHTMLDocument2> doc = punk;
        if(doc)
        {
            CComPtr<IHTMLWindow2> win;

            if(SUCCEEDED(doc->get_parentWindow( &win )) && win)
            {
                CComPtr<IHTMLEventObj> ev;

                if(SUCCEEDED(win->get_event( &ev )) && ev)
                {
                    CComDispatchDriver driver( ev );
                    MPC::wstring       strMessage;
                    MPC::wstring       strUrl;
                    long               lLine;
                    long               lCharacter;
                    long               lCode;

                    local_GetProperty( driver, L"errorMessage"  , strMessage );
                    local_GetProperty( driver, L"errorUrl"      , strUrl     );
                    local_GetProperty( driver, L"errorLine"     , lLine      );
                    local_GetProperty( driver, L"errorCharacter", lCharacter );
                    local_GetProperty( driver, L"errorCode"     , lCode      );

                    g_ApplicationLog.LogRecord( L"############################################################\n\n"
                                                L"Script error:\n\n"
                                                L"Message  : %s"    , strMessage.c_str() );
                    g_ApplicationLog.LogRecord( L"Url      : %s"    , strUrl    .c_str() );
                    g_ApplicationLog.LogRecord( L"Line     : %d"    , lLine              );
                    g_ApplicationLog.LogRecord( L"Character: %d"    , lCharacter         );
                    g_ApplicationLog.LogRecord( L"Code     : %d\n\n", lCode              );

                    if(g_Debug_BLOCKERRORS)
                    {
                        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
                    }
                }
            }
        }

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHHelpCenterExternal::PreTranslateMessage( /*[in]*/ MSG* msg )
{
    switch(msg->message)
    {
    ////////////////////////////////////////////////////////////////////////////////
    case WM_CLOSE:
        {
            CComPtr<IWebBrowser2> wb2;
            VARIANT_BOOL          Cancel;


            if(SUCCEEDED(m_Events.FireEvent_Shutdown( &Cancel )))
            {
                if(Cancel == VARIANT_TRUE)
                {
                    return S_OK;
                }
            }

            m_fShuttingDown = true;

            m_DisplayTimer.Stop();
            m_ActionsTimer.Stop();

            wb2.Attach( Context () ); if(wb2) (void)wb2->ExecWB( OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            wb2.Attach( Contents() ); if(wb2) (void)wb2->ExecWB( OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            wb2.Attach( HHWindow() ); if(wb2) (void)wb2->ExecWB( OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

            if(m_hs) (void)m_hs->ForceHistoryPopulate();
        }
        break;


    ////////////////////////////////////////////////////////////////////////////////
    case WM_MOUSEWHEEL:
        //
        // Handle Mouse Wheel navigation...
        //
        if(msg->wParam & MK_SHIFT)
        {
            if(m_hs->IsTravelling() == false)
            {
                if(GET_WHEEL_DELTA_WPARAM(msg->wParam) < 0)
                {
                    (void)HelpSession()->Back( 1 );
                }
                else
                {
                    (void)HelpSession()->Forward( 1 );
                }
            }

            return S_OK;
        }

        //
        // Disable Mouse Wheel zoom...
        //
        if(msg->wParam & MK_CONTROL)
        {
            return S_OK;
        }

        break;

    ////////////////////////////////////////////////////////////////////////////////
    //
    // Sense changes in the colors or resolution and reload style sheets.
    //
    case WM_THEMECHANGED:
    case WM_DISPLAYCHANGE:
    case WM_PALETTECHANGED:
    case WM_SYSCOLORCHANGE:
        if(CHCPProtocolEnvironment::s_GLOBAL->UpdateState())
        {
            for(int i = HSCPANEL_NAVBAR; i<= HSCPANEL_HHWINDOW; i++)
            {
                IMarsPanel* pPanel = Panel( (HscPanel)i );

                if(pPanel)
                {
                    CComPtr<IDispatch> disp;

                    if(i == HSCPANEL_HHWINDOW)
                    {
                        CComPtr<IWebBrowser2> wb2; wb2.Attach( HHWindow() );

                        disp = wb2;
                    }
                    else
                    {
                        (void)pPanel->get_content( &disp );
                    }

                    (void)local_ApplySettings( disp );
                }
            }

            (void)m_Events.FireEvent_CssChanged();
        }
        break;

    ////////////////////////////////////////////////////////////////////////////////
    //
    // (weizhao) Sense changes in the system settings (e.g. accessibility settings such as high-contrast mode).
    //
    case WM_SETTINGCHANGE:
        ProcessMessage( msg );
        break;
        

        //  default:
        //      DebugLog( "MSG: %d %04x %08x\n", msg->message, msg->wParam, msg->lParam );
    }

    return m_DOCUI ? m_DOCUI->TranslateAccelerator( msg, NULL, 0 ) : E_NOTIMPL;
}

////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::SetHelpViewer( /*[in]*/ IPCHHelpViewerWrapper* pWrapper )
{
    m_panel_HHWINDOW_Wrapper = pWrapper;

    if(pWrapper)
    {
        CComPtr<IUnknown>       unk; (void)pWrapper->get_WebBrowser( &unk );
        CComQIPtr<IWebBrowser2> wb = unk;

        if(wb)
        {
            m_panel_HHWINDOW_WebBrowser = wb;

            m_panel_HHWINDOW_Events.Attach( wb );
        }
    }
    else
    {
        m_panel_HHWINDOW_WebBrowser.Release();

        m_panel_HHWINDOW_Events.Detach();
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::CreateScriptWrapper( /*[in]*/ REFCLSID rclsid, /*[in]*/ BSTR bstrCode, /*[in]*/ BSTR bstrURL, /*[out]*/ IUnknown* *ppObj )
{
    return m_Service ? m_Service->CreateScriptWrapper( rclsid, bstrCode, bstrURL, ppObj ) : E_ACCESSDENIED;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHHelpCenterExternal::CallFunctionOnPanel( /*[in] */ HscPanel id         ,
                                                     /*[in] */ LPCWSTR  szFrame    ,
                                                     /*[in] */ BSTR     bstrName   ,
                                                     /*[in] */ VARIANT* pvarParams ,
                                                     /*[in] */ int      nParams    ,
                                                     /*[out]*/ VARIANT* pvarRet    )
{
    HRESULT               hr;
    CComPtr<IHTMLWindow2> win;


    if(SUCCEEDED(hr = GetPanelWindowObject( id, &win, szFrame )))
    {
        CComDispatchDriver driver( win );

        hr = driver.InvokeN( bstrName, pvarParams, nParams, pvarRet );
    }

    return hr;
}

HRESULT CPCHHelpCenterExternal::ReadVariableFromPanel( /*[in] */ HscPanel     id           ,
                                                       /*[in] */ LPCWSTR      szFrame      ,
                                                       /*[in] */ BSTR         bstrVariable ,
                                                       /*[out]*/ CComVariant& varRet       )
{
    HRESULT               hr;
    CComPtr<IHTMLWindow2> win;


    varRet.Clear();


    if(SUCCEEDED(hr = GetPanelWindowObject( id, &win, szFrame )))
    {
        CComDispatchDriver driver( win );

        hr = driver.GetPropertyByName( bstrVariable, &varRet );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\htmlutil2.cpp ===
/******************************************************************************

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:
    HtmlUtil2.cpp

Abstract:
    This file contains the implementation of various functions and classes
    designed to help the handling of HTML elements.

Revision History:
    Davide Massarenti   (Dmassare)  18/03/2001
        created

******************************************************************************/

#include "stdafx.h"

#include <MPC_html2.h>

////////////////////////////////////////////////////////////////////////////////

HRESULT MPC::HTML::OpenStream( /*[in ]*/ LPCWSTR           szBaseURL     ,
                               /*[in ]*/ LPCWSTR           szRelativeURL ,
                               /*[out]*/ CComPtr<IStream>& stream        )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::OpenStream" );

    HRESULT hr;
    WCHAR   rgBuf[MAX_PATH];
    DWORD   dwSize = MAXSTRLEN(rgBuf);

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szBaseURL);
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(szRelativeURL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::InternetCombineUrlW( szBaseURL, szRelativeURL, rgBuf, &dwSize, ICU_NO_ENCODE ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::URLOpenBlockingStreamW( NULL, rgBuf, &stream, 0, NULL ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    __MPC_FUNC_EXIT(hr);
}

HRESULT MPC::HTML::DownloadBitmap( /*[in ]*/ LPCWSTR  szBaseURL     ,
                                   /*[in ]*/ LPCWSTR  szRelativeURL ,
                                   /*[in ]*/ COLORREF crMask        ,
                                   /*[out]*/ HBITMAP& hbm           )
{
    __MPC_FUNC_ENTRY( COMMONID, "MPC::HTML::DownloadBitmap" );

    HRESULT                  hr;
    MPC::wstring             strTmp;
    CComPtr<IStream>         streamIn;
    CComPtr<MPC::FileStream> streamOut;

    if(hbm)
    {
        ::DeleteObject( hbm ); hbm = NULL;
    }


    //
    // Open stream for image.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::HTML::OpenStream( szBaseURL, szRelativeURL, streamIn ));


    //
    // Create a stream for temporary file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &streamOut ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( strTmp         ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut->InitForWrite  ( strTmp.c_str() ));

    //
    // Dump image to file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( streamIn, streamOut ));

	streamOut.Release();

    //
    // Load bitmap from file and merge it with existing list.
    //
    __MPC_EXIT_IF_ALLOC_FAILS(hr, hbm, (HBITMAP)::LoadImageW( NULL, strTmp.c_str(), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION ));

    hr = S_OK;


    __MPC_FUNC_CLEANUP;

    (void)MPC::RemoveTemporaryFile( strTmp );

    __MPC_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHTextHelpers::QuoteEscape( /*[in         ]*/ BSTR     bstrText ,
                                           /*[in,optional]*/ VARIANT  vQuote   ,
                                           /*[out, retval]*/ BSTR    *pVal     )
{
    __HCP_FUNC_ENTRY( "CPCHTextHelpers::QuoteEscape" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(STRINGISPRESENT(bstrText))
    {
        MPC::wstring str;
        WCHAR        chQuote = '"';
		CComVariant  v( vQuote );

        if(v.vt != VT_EMPTY && SUCCEEDED(v.ChangeType( VT_BSTR )) && v.bstrVal)
		{
			chQuote = v.bstrVal[0];
		}

        MPC::HTML::QuoteEscape( str, bstrText, chQuote );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( str.c_str(), pVal ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTextHelpers::URLUnescape( /*[in         ]*/ BSTR     bstrText       ,
                                           /*[in,optional]*/ VARIANT  vAsQueryString ,
                                           /*[out, retval]*/ BSTR    *pVal           )
{
    __HCP_FUNC_ENTRY( "CPCHTextHelpers::URLUnescape" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    if(STRINGISPRESENT(bstrText))
    {
        MPC::wstring str;
        bool         fAsQueryString = false;
		CComVariant  v( vAsQueryString );

        if(v.vt != VT_EMPTY && SUCCEEDED(v.ChangeType( VT_BOOL )))
		{
			fAsQueryString = (v.boolVal == VARIANT_TRUE);
		}

        MPC::HTML::UrlUnescape( str, bstrText, fAsQueryString );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( str.c_str(), pVal ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTextHelpers::URLEscape( /*[in         ]*/ BSTR     bstrText       ,
                                         /*[in,optional]*/ VARIANT  vAsQueryString ,
                                         /*[out, retval]*/ BSTR    *pVal           )
{
    __HCP_FUNC_ENTRY( "CPCHTextHelpers::URLEscape" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();

    if(STRINGISPRESENT(bstrText))
    {
        MPC::wstring str;
        bool         fAsQueryString = false;
		CComVariant  v( vAsQueryString );

        if(v.vt != VT_EMPTY && SUCCEEDED(v.ChangeType( VT_BOOL )))
		{
			fAsQueryString = (v.boolVal == VARIANT_TRUE);
		}

        MPC::HTML::UrlEscape( str, bstrText, fAsQueryString );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( str.c_str(), pVal ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTextHelpers::HTMLEscape( /*[in         ]*/ BSTR  bstrText ,
                                          /*[out, retval]*/ BSTR *pVal     )
{
	__HCP_FUNC_ENTRY( "CPCHTextHelpers::HTMLEscape" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    if(STRINGISPRESENT(bstrText))
    {
        MPC::wstring str;

        MPC::HTML::HTMLEscape( str, bstrText );

        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( str.c_str(), pVal ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTextHelpers::ParseURL( /*[in         ]*/ BSTR            bstrURL ,
                                        /*[out, retval]*/ IPCHParsedURL* *pVal    )
{
	__HCP_FUNC_ENTRY( "CPCHTextHelpers::ParseURL" );

    HRESULT                hr;
	CComPtr<CPCHParsedURL> pu;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pu ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, pu->Initialize( bstrURL ));

	*pVal = pu.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHTextHelpers::GetLCIDDisplayString( /*[in]*/          long  lLCID ,
													/*[out, retval]*/ BSTR *pVal  )
{
	__HCP_FUNC_ENTRY( "CPCHTextHelpers::GetLCIDDisplayString" );

    HRESULT hr;
	WCHAR   rgTmp[256];

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


	if(::GetLocaleInfoW( lLCID, LOCALE_SLANGUAGE, rgTmp, MAXSTRLEN(rgTmp) ) == 0) rgTmp[0] = 0;

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( rgTmp, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT CPCHParsedURL::Initialize( /*[in]*/ LPCWSTR szURL )
{
	MPC::HTML::ParseHREF( szURL, m_strBaseURL, m_mapQuery );

	return S_OK;
}

STDMETHODIMP CPCHParsedURL::get_BasePart( /*[out, retval]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_strBaseURL.c_str(), pVal );
}

STDMETHODIMP CPCHParsedURL::put_BasePart( /*[in]*/ BSTR newVal )
{
	m_strBaseURL = SAFEBSTR(newVal);

	return S_OK;
}

STDMETHODIMP CPCHParsedURL::get_QueryParameters( /*[out, retval]*/ VARIANT *pVal )
{
	__HCP_FUNC_ENTRY( "CPCHParsedURL::get_QueryParameters" );

	HRESULT                hr;
	MPC::WStringList       lst;
	MPC::WStringLookupIter it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pVal);
    __MPC_PARAMCHECK_END();


	for(it = m_mapQuery.begin(); it != m_mapQuery.end(); it++)
	{
		lst.push_back( it->first.c_str() );
	}

	::VariantClear( pVal );

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertListToSafeArray( lst, *pVal, VT_VARIANT ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////

STDMETHODIMP CPCHParsedURL::GetQueryParameter( /*[in         ]*/ BSTR     bstrName ,
											   /*[out, retval]*/ VARIANT* pvValue  )
{
	__HCP_FUNC_ENTRY( "CPCHParsedURL::GetQueryParameter" );

	HRESULT                hr;
	MPC::WStringLookupIter it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
        __MPC_PARAMCHECK_NOTNULL(pvValue);
    __MPC_PARAMCHECK_END();


	::VariantClear( pvValue );

	it = m_mapQuery.find( bstrName );
	if(it != m_mapQuery.end())
	{
		pvValue->vt      = VT_BSTR;
		pvValue->bstrVal = ::SysAllocString( it->second.c_str() );
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHParsedURL::SetQueryParameter( /*[in]*/ BSTR bstrName  ,
											   /*[in]*/ BSTR bstrValue )
{
	__HCP_FUNC_ENTRY( "CPCHParsedURL::SetQueryParameter" );

	HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
    __MPC_PARAMCHECK_END();

	m_mapQuery[bstrName] = SAFEBSTR(bstrValue);

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHParsedURL::DeleteQueryParameter( /*[in]*/ BSTR bstrName )
{
	__HCP_FUNC_ENTRY( "CPCHParsedURL::DeleteQueryParameter" );

	HRESULT                hr;
	MPC::WStringLookupIter it;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
    __MPC_PARAMCHECK_END();


	it = m_mapQuery.find( bstrName );
	if(it != m_mapQuery.end())
	{
		m_mapQuery.erase( it );
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHParsedURL::BuildFullURL( /*[out, retval]*/ BSTR *pVal )
{
	MPC::wstring strURL;

	MPC::HTML::BuildHREF( strURL, m_strBaseURL.c_str(), m_mapQuery );

	return MPC::GetBSTR( strURL.c_str(), pVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\printengine.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PrintEngine.cpp

Abstract:
    This file contains the implementation of the CPCHPrintEngine class,
    which implements the multi-topic printing.

Revision History:
    Davide Massarenti   (Dmassare)  05/08/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define CHECK_MODIFY()  __MPC_EXIT_IF_METHOD_FAILS(hr, CanModifyProperties())

/////////////////////////////////////////////////////////////////////////////

CPCHPrintEngine::CPCHPrintEngine()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::CPCHPrintEngine" );

	// Printing::Print                      m_engine;
	// 
    // MPC::CComPtrThreadNeutral<IDispatch> m_sink_onProgress;
    // MPC::CComPtrThreadNeutral<IDispatch> m_sink_onComplete;
}

void CPCHPrintEngine::FinalRelease()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::FinalRelease" );

    (void)Abort();

    Thread_Wait();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHPrintEngine::Run()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::Run" );

    HRESULT hr;


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST );

	__MPC_TRY_BEGIN();

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_engine.Initialize( CPCHHelpCenterExternal::s_GLOBAL->Window() ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_engine.PrintAll( this ));

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

	//
	// Close everything.
	//
	m_engine.Terminate();

    //
    // Keep this outside any critical section, otherwise a deadlock could occur.
    //
    Fire_onComplete( Thread_Self(), hr );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

////////////////
//            //
// Properties //
//            //
////////////////

STDMETHODIMP CPCHPrintEngine::put_onProgress( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHPrintEngine::put_onProgress",hr);

    CHECK_MODIFY();

    m_sink_onProgress = function;


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHPrintEngine::put_onComplete( /*[in]*/ IDispatch* function )
{
    __HCP_BEGIN_PROPERTY_PUT("CPCHPrintEngine::put_onComplete",hr);

    CHECK_MODIFY();

    m_sink_onComplete = function;


    __HCP_END_PROPERTY(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHPrintEngine::AddTopic( /*[in]*/ BSTR bstrURL )
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::AddTopic" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrURL);
	__MPC_PARAMCHECK_END();

    CHECK_MODIFY();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_engine.AddUrl( bstrURL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHPrintEngine::Start()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::Start" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    CHECK_MODIFY();



    //
    // Release the lock on current object, otherwise a deadlock could occur.
    //
    lock = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, this ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHPrintEngine::Abort()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::Abort" );

    Thread_Abort(); // To tell the MPC:Thread object to close the worker thread...

    __HCP_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////
//                      //
// Event Firing Methods //
//                      //
//////////////////////////

HRESULT CPCHPrintEngine::Fire_onProgress( IPCHPrintEngine* hcppe, BSTR bstrURL, long lDone, long lTotal )
{
    CComVariant pvars[4];

    pvars[3] = hcppe;
    pvars[2] = bstrURL;
    pvars[1] = lDone;
    pvars[0] = lTotal;

    return FireAsync_Generic( DISPID_PCH_PEE__ONPROGRESS, pvars, ARRAYSIZE( pvars ), m_sink_onProgress );
}

HRESULT CPCHPrintEngine::Fire_onComplete( IPCHPrintEngine* hcppe, HRESULT hrRes )
{
    CComVariant pvars[2];

    pvars[1] = hcppe;
    pvars[0] = hrRes;

    return FireAsync_Generic( DISPID_PCH_PEE__ONCOMPLETE, pvars, ARRAYSIZE( pvars ), m_sink_onComplete );
}


//////////////////////
//                  //
// Callback Methods //
//                  //
//////////////////////

HRESULT CPCHPrintEngine::Progress( /*[in]*/ LPCWSTR szURL, /*[in]*/ int iDone, /*[in]*/ int iTotal )
{
	__HCP_FUNC_ENTRY( "CPCHPrintEngine::Progress" );

	HRESULT hr;

	if(Thread_IsAborted())
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);
	}

	__MPC_EXIT_IF_METHOD_FAILS(hr, Fire_onProgress( this, CComBSTR( szURL ), iDone, iTotal ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////
//                 //
// Utility Methods //
//                 //
/////////////////////

HRESULT CPCHPrintEngine::CanModifyProperties()
{
    __HCP_FUNC_ENTRY( "CPCHPrintEngine::CanModifyProperties" );

    HRESULT hr = Thread_IsRunning() ? E_ACCESSDENIED : S_OK;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\scriptablestream.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ScriptableStream.cpp

Abstract:
    This file contains the implementation of the CPCHScriptableStream class,
	which is a scriptable wrapper for IStream.

Revision History:
    Davide Massarenti   (Dmassare)  10/06/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHScriptableStream::ReadToHGLOBAL( /*[in]*/ long lCount, /*[out]*/ HGLOBAL& hg, /*[out]*/ ULONG& lReadTotal )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::ReadToHGLOBAL" );

    HRESULT hr;


	lReadTotal = 0;


	if(lCount < 0)
	{
		static const ULONG c_BUFSIZE = 4096;

		ULONG lRead;

        __MPC_EXIT_IF_ALLOC_FAILS(hr, hg, ::GlobalAlloc( GMEM_FIXED, c_BUFSIZE ));

		while(1)
		{
			HGLOBAL hg2;

			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Read( &((BYTE*)hg)[lReadTotal], c_BUFSIZE, &lRead ));

			if(hr == S_FALSE || lRead == 0) break;

			lReadTotal += lRead;

			//
			// Increase buffer.
			//
			__MPC_EXIT_IF_ALLOC_FAILS(hr, hg2, ::GlobalReAlloc( hg, lReadTotal + c_BUFSIZE, 0 ));
			hg = hg2;
		}
	}
	else
	{
        __MPC_EXIT_IF_ALLOC_FAILS(hr, hg, ::GlobalAlloc( GMEM_FIXED, lCount ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Read( hg, lCount, &lReadTotal ));
	}


	hr = S_OK;

	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHScriptableStream::get_Size( /*[out, retval]*/ long *plSize )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::get_Size" );

    HRESULT hr;
	STATSTG stat;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(plSize,0);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Stat( &stat, STATFLAG_NONAME ));

	*plSize = (long)stat.cbSize.QuadPart;


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHScriptableStream::Read( /*[in]*/ long lCount, /*[out, retval]*/ VARIANT *pvData )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::Read" );

    HRESULT     hr;
	CComVariant vArray;
	HGLOBAL     hg = NULL;
	ULONG       lReadTotal;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(pvData);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, ReadToHGLOBAL( lCount, hg, lReadTotal ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertBufferToVariant( (BYTE*)hg, (DWORD)lReadTotal, vArray ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, vArray.Detach( pvData ));

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(hg) ::GlobalFree( hg );

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHScriptableStream::ReadHex( /*[in]*/ long lCount, /*[out, retval]*/ BSTR *pbstrData )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::ReadHex" );

    HRESULT hr;
	HGLOBAL hg = NULL; 
	ULONG   lReadTotal;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pbstrData,0);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, ReadToHGLOBAL( lCount, hg, lReadTotal ));

	if(lReadTotal)
	{
		CComBSTR bstrHex;
		HGLOBAL  hg2;

		//
		// Trim down the size of the HGLOBAL.
		//
		__MPC_EXIT_IF_ALLOC_FAILS(hr, hg2, ::GlobalReAlloc( hg, lReadTotal, 0 ));
		hg = hg2;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHGlobalToHex( hg, bstrHex ));

		*pbstrData = bstrHex.Detach();
	}

	hr = S_OK;

	__HCP_FUNC_CLEANUP;

	if(hg) ::GlobalFree( hg );

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHScriptableStream::Write( /*[in]*/ long lCount, /*[in]*/ VARIANT vData, /*[out, retval]*/ long *plWritten )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::get_Size" );

    HRESULT hr;
	BYTE*   rgBuf       = NULL;
	DWORD   dwLen       = 0;
	bool    fAccessData = false;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(plWritten,0);
    __MPC_PARAMCHECK_END();


	switch(vData.vt)
	{
	case VT_EMPTY:
	case VT_NULL:
		break;

	case VT_ARRAY | VT_UI1:
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertVariantToBuffer( &vData, rgBuf, dwLen ));
		break;

	case VT_ARRAY | VT_VARIANT:
		{
			long 	 lBound; ::SafeArrayGetLBound( vData.parray, 1, &lBound );
			long 	 uBound; ::SafeArrayGetUBound( vData.parray, 1, &uBound );
			VARIANT* pSrc;
			DWORD    dwPos;

			dwLen = uBound - lBound + 1;

			__MPC_EXIT_IF_ALLOC_FAILS(hr, rgBuf, new BYTE[dwLen]);

			__MPC_EXIT_IF_METHOD_FAILS(hr, ::SafeArrayAccessData( vData.parray, (LPVOID*)&pSrc ));
			fAccessData = true;


			for(dwPos=0; dwPos<dwLen; dwPos++, pSrc++)
			{
				CComVariant v;

				__MPC_EXIT_IF_METHOD_FAILS(hr, ::VariantChangeType( &v, pSrc, 0, VT_UI1 ));

				rgBuf[dwPos] = v.bVal;
			}
		}
		break;
	}

	if(dwLen && rgBuf)
	{
		ULONG lWritten;

		//
		// Just write the requested number of bytes.
		//
		if(lCount >= 0 && dwLen > lCount) dwLen = lCount;

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Write( rgBuf, dwLen, &lWritten ));

		*plWritten = lWritten;
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(fAccessData) ::SafeArrayUnaccessData( vData.parray );

	delete [] rgBuf;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHScriptableStream::WriteHex( /*[in]*/ long lCount, /*[in]*/ BSTR bstrData, /*[out, retval]*/ long *plWritten )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::get_Size" );

    HRESULT hr;
	HGLOBAL hg = NULL;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(plWritten,0);
    __MPC_PARAMCHECK_END();


	if(STRINGISPRESENT(bstrData))
	{
		CComBSTR bstrHex( bstrData );
		ULONG    lWritten = 0;


		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::ConvertHexToHGlobal( bstrHex, hg, true ));

		if(hg)
		{
			DWORD dwSize = ::GlobalSize( hg );

			//
			// Just write the requested number of bytes.
			//
			if(lCount >= 0 && lCount > dwSize) lCount = dwSize;
			
			__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Write( (BYTE*)hg, lCount, &lWritten ));
		}

		*plWritten = lWritten;
	}


	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(hg) ::GlobalFree( hg );

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHScriptableStream::Seek( /*[in]*/ long lOffset, /*[in]*/ BSTR bstrOrigin, /*[out, retval]*/ long *plNewPos )
{
	__HCP_FUNC_ENTRY( "CPCHScriptableStream::get_Size" );

    HRESULT 	   hr;
	DWORD   	   dwOrigin;
	LARGE_INTEGER  liMove;
	ULARGE_INTEGER liNewPos;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrOrigin);
        __MPC_PARAMCHECK_POINTER_AND_SET(plNewPos,0);
    __MPC_PARAMCHECK_END();


	if     (!_wcsicmp( bstrOrigin, L"SET" )) dwOrigin = STREAM_SEEK_SET;
	else if(!_wcsicmp( bstrOrigin, L"CUR" )) dwOrigin = STREAM_SEEK_CUR;
	else if(!_wcsicmp( bstrOrigin, L"END" )) dwOrigin = STREAM_SEEK_END;
	else __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);


	liMove.QuadPart = lOffset;

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::FileStream::Seek( liMove, dwOrigin, &liNewPos ));

	*plNewPos = liNewPos.QuadPart;

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHScriptableStream::Close()
{
    MPC::FileStream::Close();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\options.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Options.cpp

Abstract:
    This file contains the implementation of the CPCHOptions class,
    which is used to store the list of favorite contents.

Revision History:
    Davide Massarenti   (Dmassare)  05/10/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define OFFSET1(field)      offsetof(CPCHOptions, field), -1
#define OFFSET2(field,flag) offsetof(CPCHOptions, field), offsetof(CPCHOptions, flag)


static const WCHAR c_HSS_private[] = HC_REGISTRY_HELPCTR_USER;

static const WCHAR c_HSS_ie     [] = HC_REGISTRY_HELPCTR_IE;
static const WCHAR c_HSS_ie_main[] = HC_REGISTRY_HELPCTR_IE L"\\Main";


const CPCHOptions::OptionsDef CPCHOptions::c_tbl[] =
{
    { c_HSS_private, L"SKU"                    , OFFSET1(m_ths.m_strSKU                                       ), CPCHOptions::c_Type_STRING      , false },
    { c_HSS_private, L"Language"               , OFFSET1(m_ths.m_lLCID                                        ), CPCHOptions::c_Type_long        , false },

    { c_HSS_private, L"ShowFavorites"          , OFFSET2(m_ShowFavorites        , m_flag_ShowFavorites        ), CPCHOptions::c_Type_VARIANT_BOOL, true  },
    { c_HSS_private, L"ShowHistory"            , OFFSET2(m_ShowHistory          , m_flag_ShowHistory          ), CPCHOptions::c_Type_VARIANT_BOOL, true  },
    { c_HSS_private, L"FontSize"               , OFFSET2(m_FontSize             , m_flag_FontSize             ), CPCHOptions::c_Type_FONTSIZE    , true  },
    { c_HSS_private, L"TextLabels"             , OFFSET2(m_TextLabels           , m_flag_TextLabels           ), CPCHOptions::c_Type_TEXTLABELS  , true  },

    { c_HSS_ie_main, L"Disable Script Debugger", OFFSET2(m_DisableScriptDebugger, m_flag_DisableScriptDebugger), CPCHOptions::c_Type_DWORD       , true  },
};

const CPCHOptions::OptionsDef CPCHOptions::c_tbl_TS[] =
{
    { HC_REGISTRY_HELPCTR, L"DefaultTerminalServerSKU"     , OFFSET1(m_ths_TS.m_strSKU), CPCHOptions::c_Type_STRING, false },
    { HC_REGISTRY_HELPCTR, L"DefaultTerminalServerLanguage", OFFSET1(m_ths_TS.m_lLCID ), CPCHOptions::c_Type_long  , false },
};

/////////////////////////////////////////////////////////////////////////////

CPCHOptions::CPCHOptions()
{
    m_fLoaded               = false;                                              // bool              m_fLoaded;
    m_fDirty                = false;                                              // bool              m_fDirty;
    m_fNoSave               = false;                                              // bool              m_fNoSave;
                                                                                  //
                                                                                  // Taxonomy::HelpSet m_ths;
                                                                                  // Taxonomy::HelpSet m_ths_TS;
    m_ShowFavorites         = VARIANT_TRUE; m_flag_ShowFavorites         = false; // VARIANT_BOOL      m_ShowFavorites;         bool m_flag_ShowFavorites;
    m_ShowHistory           = VARIANT_TRUE; m_flag_ShowHistory           = false; // VARIANT_BOOL      m_ShowHistory;           bool m_flag_ShowHistory;
    m_FontSize              = OPT_MEDIUM;   m_flag_FontSize              = false; // OPT_FONTSIZE      m_FontSize;              bool m_flag_FontSize;
    m_TextLabels            = TB_SELECTED;  m_flag_TextLabels            = false; // TB_MODE           m_TextLabels;            bool m_flag_TextLabels;
                                                                                  //
    m_DisableScriptDebugger = 1;            m_flag_DisableScriptDebugger = false; // DWORD             m_DisableScriptDebugger; bool m_flag_DisableScriptDebugger;
}

////////////////////

CPCHOptions* CPCHOptions::s_GLOBAL( NULL );

HRESULT CPCHOptions::InitializeSystem()
{
    HRESULT hr;

    if(s_GLOBAL) return S_OK;

    if(SUCCEEDED(hr = MPC::CreateInstance( &CPCHOptions::s_GLOBAL )))
    {
        hr = CPCHOptions::s_GLOBAL->Load( /*fForce*/true );
    }

    return hr;
}

void CPCHOptions::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        s_GLOBAL->Release(); s_GLOBAL = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////////

void CPCHOptions::ReadTable( /*[in]*/ const OptionsDef* tbl ,
                             /*[in]*/ int               len ,
                             /*[in]*/ MPC::RegKey&      rk  )
{
    HRESULT           hr;
    const OptionsDef* ptr     = tbl;
    const OptionsDef* ptrLast = NULL;
    CComVariant       v;
    bool              fFound;

    for(int i=0; i<len; i++, ptr++)
    {
        if(ptr->iOffsetFlag == -1)
        {
            switch(ptr->iType)
            {
            case c_Type_bool        : *( (bool        *)((BYTE*)this + ptr->iOffset) ) = false;         break;
            case c_Type_long        : *( (long        *)((BYTE*)this + ptr->iOffset) ) = 0;             break;
            case c_Type_DWORD       : *( (DWORD       *)((BYTE*)this + ptr->iOffset) ) = 0;             break;
            case c_Type_VARIANT_BOOL: *( (VARIANT_BOOL*)((BYTE*)this + ptr->iOffset) ) = VARIANT_FALSE; break;
            case c_Type_STRING      : *( (MPC::wstring*)((BYTE*)this + ptr->iOffset) ) = L"";           break;
            case c_Type_FONTSIZE    : *( (OPT_FONTSIZE*)((BYTE*)this + ptr->iOffset) ) = OPT_MEDIUM;    break;
            case c_Type_TEXTLABELS  : *( (TB_MODE     *)((BYTE*)this + ptr->iOffset) ) = TB_SELECTED;   break;
            }
        }
        else
        {
            *( (bool*)((BYTE*)this + ptr->iOffsetFlag) ) = false;
        }


        if(!ptrLast || wcscmp( ptr->szKey, ptrLast->szKey ))
        {
            ptrLast = NULL;

            if(FAILED(rk.Attach( ptr->szKey ))) continue;

            ptrLast = ptr;
        }

        if(FAILED(rk.get_Value( v, fFound, ptr->szValue )) || !fFound) continue;

        switch(ptr->iType)
        {
        case c_Type_bool        : hr = v.ChangeType( VT_BOOL ); break;
        case c_Type_long        : hr = v.ChangeType( VT_I4   ); break;
        case c_Type_DWORD       : hr = v.ChangeType( VT_I4   ); break;
        case c_Type_VARIANT_BOOL: hr = v.ChangeType( VT_BOOL ); break;
        case c_Type_STRING      : hr = v.ChangeType( VT_BSTR ); break;
        case c_Type_FONTSIZE    : hr = v.ChangeType( VT_I4   ); break;
        case c_Type_TEXTLABELS  : hr = v.ChangeType( VT_I4   ); break;
        }

        if(FAILED(hr)) continue;

        if(ptr->iOffsetFlag != -1)
        {
            *( (bool*)((BYTE*)this + ptr->iOffsetFlag) ) = true;
        }

        switch(ptr->iType)
        {
        case c_Type_bool        : *( (bool        *)((BYTE*)this + ptr->iOffset) ) =               v.boolVal == VARIANT_TRUE; break;
        case c_Type_long        : *( (long        *)((BYTE*)this + ptr->iOffset) ) =               v.lVal                   ; break;
        case c_Type_DWORD       : *( (DWORD       *)((BYTE*)this + ptr->iOffset) ) =               v.lVal                   ; break;
        case c_Type_VARIANT_BOOL: *( (VARIANT_BOOL*)((BYTE*)this + ptr->iOffset) ) =               v.boolVal                ; break;
        case c_Type_STRING      : *( (MPC::wstring*)((BYTE*)this + ptr->iOffset) ) = SAFEBSTR(     v.bstrVal)               ; break;
        case c_Type_FONTSIZE    : *( (OPT_FONTSIZE*)((BYTE*)this + ptr->iOffset) ) = (OPT_FONTSIZE)v.lVal                   ; break;
        case c_Type_TEXTLABELS  : *( (TB_MODE     *)((BYTE*)this + ptr->iOffset) ) = (TB_MODE     )v.lVal                   ; break;
        }
    }
}

void CPCHOptions::WriteTable( /*[in]*/ const OptionsDef* tbl ,
                              /*[in]*/ int               len ,
                              /*[in]*/ MPC::RegKey&      rk  )
{
    HRESULT           hr;
    const OptionsDef* ptr     = c_tbl;
    const OptionsDef* ptrLast = NULL;
    CComVariant       v;
    bool              fFound;

    for(int i=0; i<len; i++, ptr++)
    {
        if(!ptr->fSaveAlways && m_fNoSave) continue;

        if(ptr->iOffsetFlag != -1)
        {
            if(*( (bool*)((BYTE*)this + ptr->iOffsetFlag) ) == false) continue;
        }

        if(!ptrLast || wcscmp( ptr->szKey, ptrLast->szKey ))
        {
            ptrLast = NULL;

            if(FAILED(rk.Attach( ptr->szKey ))) continue;
            if(FAILED(rk.Create(            ))) continue;

            ptrLast = ptr;
        }

        switch(ptr->iType)
        {
        case c_Type_bool        : v.Clear(); v.vt = VT_BOOL; v.boolVal =       *( (bool        *)((BYTE*)this + ptr->iOffset) ) ? VARIANT_TRUE : VARIANT_FALSE; break;
        case c_Type_long        :                            v         =       *( (long        *)((BYTE*)this + ptr->iOffset) )                               ; break;
        case c_Type_DWORD       :                            v         = (long)*( (DWORD       *)((BYTE*)this + ptr->iOffset) )                               ; break;
        case c_Type_VARIANT_BOOL: v.Clear(); v.vt = VT_BOOL; v.boolVal =       *( (VARIANT_BOOL*)((BYTE*)this + ptr->iOffset) )                               ; break;
        case c_Type_STRING      :                            v         =        ( (MPC::wstring*)((BYTE*)this + ptr->iOffset) )->c_str()                      ; break;
        case c_Type_FONTSIZE    :                            v         = (long)*( (OPT_FONTSIZE*)((BYTE*)this + ptr->iOffset) )                               ; break;
        case c_Type_TEXTLABELS  :                            v         = (long)*( (TB_MODE     *)((BYTE*)this + ptr->iOffset) )                               ; break;
        }

        (void)rk.put_Value( v, ptr->szValue, /*fExpand*/false );
    }
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHOptions::Load( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "CPCHOptions::Load" );

    HRESULT hr;


    if(!m_fLoaded || fForce)
    {
        MPC::RegKey rk;

        __MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_CURRENT_USER, KEY_READ )); ReadTable( c_tbl, ARRAYSIZE(c_tbl), rk );

        if(::GetSystemMetrics( SM_REMOTESESSION ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_LOCAL_MACHINE, KEY_READ )); ReadTable( c_tbl_TS, ARRAYSIZE(c_tbl_TS), rk );
        }

        m_fLoaded = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHOptions::Save( /*[in]*/ bool fForce )
{
    __HCP_FUNC_ENTRY( "CPCHOptions::Save" );

    HRESULT hr;

    if(m_fDirty)
    {
        MPC::RegKey rk;

        __MPC_EXIT_IF_METHOD_FAILS(hr, rk.SetRoot( HKEY_CURRENT_USER, KEY_ALL_ACCESS )); WriteTable( c_tbl, ARRAYSIZE(c_tbl), rk );

        m_fDirty = false;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

#define GET_BEGIN(hr,pVal)                                           \
    HRESULT hr;                                                      \
                                                                     \
    if(!pVal) return E_POINTER;                                      \
                                                                     \
    if(FAILED(hr = Load( /*fForce*/false ))) return hr

#define GET_END(hr)                                                  \
    return hr


#define PUT_BEGIN(hr)                                                \
    HRESULT hr;                                                      \
                                                                     \
    if(FAILED(hr = Load( /*fForce*/false ))) return hr

#define PUT_END(hr)                                                  \
    m_fDirty = true;                                                 \
    return S_OK


STDMETHODIMP CPCHOptions::get_ShowFavorites( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    GET_BEGIN(hr,pVal);

    *pVal = m_ShowFavorites;

    GET_END(hr);
}

STDMETHODIMP CPCHOptions::put_ShowFavorites( /*[in]*/ VARIANT_BOOL newVal )
{
    PUT_BEGIN(hr);

    m_ShowFavorites      = newVal;
    m_flag_ShowFavorites = true;

    PUT_END(hr);
}


STDMETHODIMP CPCHOptions::get_ShowHistory( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    GET_BEGIN(hr,pVal);

    *pVal = m_ShowHistory;

    GET_END(hr);
}

STDMETHODIMP CPCHOptions::put_ShowHistory( /*[in]*/ VARIANT_BOOL newVal )
{
    PUT_BEGIN(hr);

    m_ShowHistory      = newVal;
    m_flag_ShowHistory = true;

    PUT_END(hr);
}


STDMETHODIMP CPCHOptions::get_FontSize( /*[out, retval]*/ OPT_FONTSIZE *pVal )
{
    GET_BEGIN(hr,pVal);

    *pVal = m_FontSize;

    GET_END(hr);
}

STDMETHODIMP CPCHOptions::put_FontSize( /*[in]*/ OPT_FONTSIZE newVal )
{
    PUT_BEGIN(hr);

    m_FontSize      = newVal;
    m_flag_FontSize = true;

    PUT_END(hr);
}


STDMETHODIMP CPCHOptions::get_TextLabels( /*[out, retval]*/ TB_MODE *pVal )
{
    GET_BEGIN(hr,pVal);

    *pVal = m_TextLabels;

    GET_END(hr);
}

STDMETHODIMP CPCHOptions::put_TextLabels( /*[in]*/ TB_MODE newVal )
{
    PUT_BEGIN(hr);

    m_TextLabels      = newVal;
    m_flag_TextLabels = true;

    PUT_END(hr);
}


STDMETHODIMP CPCHOptions::get_DisableScriptDebugger( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    GET_BEGIN(hr,pVal);

    *pVal = m_DisableScriptDebugger ? VARIANT_TRUE : VARIANT_FALSE;

    GET_END(hr);
}

STDMETHODIMP CPCHOptions::put_DisableScriptDebugger( /*[in]*/ VARIANT_BOOL newVal )
{
    PUT_BEGIN(hr);

    m_DisableScriptDebugger      = (newVal == VARIANT_TRUE) ? 1 : 0;
    m_flag_DisableScriptDebugger = true;

    PUT_END(hr);
}


STDMETHODIMP CPCHOptions::Apply()
{
    __HCP_FUNC_ENTRY( "CPCHOptions::Apply" );

	HRESULT                 hr;
	CPCHHelpCenterExternal* ext = CPCHHelpCenterExternal::s_GLOBAL;

    if(!ext)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_POINTER);
	}

	(void)Save();

	__MPC_EXIT_IF_METHOD_FAILS(hr, ext->Events().FireEvent_OptionsChanged());

	{
		for(int i = HSCPANEL_NAVBAR; i<= HSCPANEL_HHWINDOW; i++)
		{
			IMarsPanel* pPanel = ext->Panel( (HscPanel)i );

			if(pPanel)
			{
                CComPtr<IDispatch> disp;

				if(i == HSCPANEL_HHWINDOW)
				{
					CComPtr<IWebBrowser2> wb2; wb2.Attach( ext->HHWindow() );

					disp = wb2;
				}
				else
				{
					(void)pPanel->get_content( &disp );
				}

				__MPC_EXIT_IF_METHOD_FAILS(hr, ApplySettings( ext, disp ));
			}
		}
	}

	{
		IMarsWindowOM* shell = ext->Shell();

		if(shell)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, shell->refreshLayout());
		}
    }

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT CPCHOptions::put_CurrentHelpSet( /*[in]*/ Taxonomy::HelpSet& ths )
{
    PUT_BEGIN(hr);

    m_ths = ths;

    PUT_END(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHOptions::ApplySettings( /*[in]*/ CPCHHelpCenterExternal* ext, /*[in]*/ IUnknown* unk )
{
    __HCP_FUNC_ENTRY( "CPCHOptions::ApplySettings" );

    HRESULT                      hr;
	CComQIPtr<IOleCommandTarget> oct( unk );

	if(oct)
	{
		CComVariant vIn;
		CComVariant vOut;

		if(SUCCEEDED(oct->Exec( 0, OLECMDID_GETZOOMRANGE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &vOut )) && vOut.vt == VT_I4)
		{
			int iZoomMin = (SHORT)LOWORD(vOut.lVal);
			int iZoomMax = (SHORT)HIWORD(vOut.lVal);
			int iZoom;

			switch(m_FontSize)
			{
			case OPT_SMALL : iZoom =  iZoomMin + 1              ; break;
			case OPT_MEDIUM: iZoom = (iZoomMin + iZoomMax + 1)/2; break;
			case OPT_LARGE : iZoom =             iZoomMax - 1   ; break;
			}

			vIn = (long)iZoom;

			(void)oct->Exec( 0, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, &vIn, &vOut );
		}
	}

	hr = S_OK;


	__HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\marshost.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    MarsHost.cpp

Abstract:
    This file contains the implementation of the CHCPMarsHost class,
    which is used to control the behavior of Mars.

Revision History:
    Davide Massarenti       (dmassare)  08/24/99
        created

******************************************************************************/

#include "stdafx.h"

#define SCREEN_WIDTH_MIN  (800)
#define SCREEN_HEIGHT_MIN (600)

#define WINDOW_WIDTH_MIN  (800)
#define WINDOW_HEIGHT_MIN (650)

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHBootstrapper::ForwardQueryInterface( void* pv, REFIID iid, void** ppvObject, DWORD_PTR offset )
{
	CPCHBootstrapper* pThis = (CPCHBootstrapper*)pv;
	
	return pThis->m_parent ? pThis->m_parent->QueryInterface( iid, ppvObject ) : E_NOINTERFACE;
}

STDMETHODIMP CPCHBootstrapper::SetSite(IUnknown *pUnkSite)
{
	CComQIPtr<IServiceProvider> sp = pUnkSite;

	m_spUnkSite = pUnkSite;

	m_parent.Release();

	if(sp)
	{
		if(FAILED(sp->QueryService( SID_SElementBehaviorFactory, IID_IPCHHelpCenterExternal, (void **)&m_parent )) || m_parent == NULL)
		{
			//
			// BIG IE BUG: dialogs don't delegate properly, so we have to fix it somehow.....
			//
			(void)CPCHHelpCenterExternal::s_GLOBAL->QueryInterface( IID_IPCHHelpCenterExternal, (void **)&m_parent );
		}
	}

	return S_OK;
}

STDMETHODIMP CPCHBootstrapper::GetSite(REFIID riid, void **ppvSite)
{
	HRESULT hRes = E_POINTER;
	
	if(ppvSite != NULL)
	{
		if(m_spUnkSite)
		{
			hRes = m_spUnkSite->QueryInterface( riid, ppvSite );
		}
		else
		{
			*ppvSite = NULL;
			hRes     = E_FAIL;
		}
	}

	return hRes;
}


STDMETHODIMP CPCHBootstrapper::GetInterfaceSafetyOptions( /*[in ]*/ REFIID  riid                ,
														  /*[out]*/ DWORD  *pdwSupportedOptions ,
														  /*[out]*/ DWORD  *pdwEnabledOptions   )
{
    if(pdwSupportedOptions) *pdwSupportedOptions = 0;
    if(pdwEnabledOptions  ) *pdwEnabledOptions   = 0;

    if(IsEqualIID(riid, IID_IDispatch  ) ||
	   IsEqualIID(riid, IID_IDispatchEx)  )
    {
        if(pdwSupportedOptions) *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        if(pdwEnabledOptions  ) *pdwEnabledOptions   = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

STDMETHODIMP CPCHBootstrapper::SetInterfaceSafetyOptions( /*[in]*/ REFIID riid             ,
														  /*[in]*/ DWORD  dwOptionSetMask  ,
														  /*[in]*/ DWORD  dwEnabledOptions )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

CPCHMarsHost::CPCHMarsHost()
{
	m_parent = NULL; // CPCHHelpCenterExternal* m_parent;
					 // MPC::wstring            m_strTitle;
					 // MPC::wstring            m_strCmdLine;
					 //	MARSTHREADPARAM         m_mtp;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHMarsHost::Init( /*[in]*/ CPCHHelpCenterExternal* parent, /*[in]*/ const MPC::wstring& szTitle, /*[out]*/ MARSTHREADPARAM*& pMTP )
{
    __HCP_FUNC_ENTRY( "CPCHMarsHost::Init" );

	HRESULT   hr;
	HINSTANCE hInst = ::GetModuleHandle( NULL );
	HICON     hIcon = ::LoadIcon( hInst, MAKEINTRESOURCE(IDI_HELPCENTER) );


	m_parent     = parent;
	m_strTitle   = szTitle;
	m_strCmdLine = HC_HELPSET_ROOT HC_HELPSET_SUB_SYSTEM L"\\HelpCtr.mmf"; MPC::SubstituteEnvVariables( m_strCmdLine );


	::ZeroMemory( &m_mtp, sizeof(m_mtp) ); m_mtp.cbSize = sizeof(m_mtp);
	m_mtp.hIcon        = hIcon;
	m_mtp.nCmdShow     = SW_SHOWDEFAULT;
	m_mtp.pwszTitle    = m_strTitle  .c_str();
	m_mtp.pwszPanelURL = m_strCmdLine.c_str();


	if(parent->DoesPersistSettings())
	{
		m_mtp.dwFlags |= MTF_MANAGE_WINDOW_SIZE;
	}

	if(parent->CanDisplayWindow   () == false ||
	   parent->HasLayoutDefinition() == true   )
	{
        m_mtp.dwFlags |= MTF_DONT_SHOW_WINDOW;
	}

	pMTP = &m_mtp;
	hr   = S_OK;


	//    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHMarsHost::OnHostNotify( /*[in]*/ MARSHOSTEVENT  event  ,
										 /*[in]*/ IUnknown      *punk   ,
										 /*[in]*/ LPARAM         lParam )
{
	if(event == MARSHOST_ON_WIN_SETPOS)
	{
		WINDOWPLACEMENT* wp = (WINDOWPLACEMENT*)lParam;
 
		//
		// Only adjust size if it's the first time through and not a controlled invocation.
		//
		if(wp && m_parent && m_parent->DoesPersistSettings() && !(m_mtp.dwFlags & MTF_RESTORING_FROM_REGISTRY))
		{
			RECT rc;

			//
			// If the screen is large enough, don't open always maximized.
			//
			if(::SystemParametersInfo( SPI_GETWORKAREA, 0, &rc, 0 ))
			{
				LONG Screen_width  = rc.right  - rc.left;
				LONG Screen_height = rc.bottom - rc.top;
				LONG Window_height = wp->rcNormalPosition.bottom - wp->rcNormalPosition.top;
			
				if(Screen_width  < SCREEN_WIDTH_MIN  ||
				   Screen_height < SCREEN_HEIGHT_MIN  )
				{
					wp->showCmd = SW_MAXIMIZE;
				}
				else if(Window_height < WINDOW_HEIGHT_MIN)
				{
					wp->rcNormalPosition.top    = rc.top + (Screen_height - WINDOW_HEIGHT_MIN) / 2;
					wp->rcNormalPosition.bottom = wp->rcNormalPosition.top + WINDOW_HEIGHT_MIN;
				}
			}
		}

		return S_OK;
	}

	return m_parent->OnHostNotify( event, punk, lParam );
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHMarsHost::PreTranslateMessage( /*[in]*/ MSG* msg )
{
	return m_parent->PreTranslateMessage( msg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\scriptwrapper_clientside.cpp ===
/********************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ScriptWrapper_ClientSide.cpp

Abstract:
    File for implementation of CPCHScriptWrapper_ClientSideRoot class,
    a generic wrapper for remoting scripting engines.

Revision History:
    Davide Massarenti created  03/28/2000

********************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool CPCHScriptWrapper_ClientSideRoot::NamedItem::operator==( /*[in]*/ LPCOLESTR szKey ) const
{
    return MPC::StrICmp( m_bstrName, szKey ) == 0;
}


bool CPCHScriptWrapper_ClientSideRoot::TypeLibItem::operator==( /*[in]*/ REFGUID rguidTypeLib ) const
{
    return ::IsEqualGUID( m_guidTypeLib, rguidTypeLib ) == TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CPCHScriptWrapper_ClientSideRoot::CPCHScriptWrapper_ClientSideRoot()
{
    m_pWrappedCLSID = NULL;                      // const CLSID*                m_pWrappedCLSID;
                                                 // NamedList                   m_lstNamed;
                                                 // TypeLibList                 m_lstTypeLib;
    m_ss            = SCRIPTSTATE_UNINITIALIZED; // SCRIPTSTATE                 m_ss;
                                                 // CComPtr<IActiveScriptSite>  m_Browser;
                                                 // CComPtr<IPCHActiveScript>   m_Script;
}

CPCHScriptWrapper_ClientSideRoot::~CPCHScriptWrapper_ClientSideRoot()
{
}


HRESULT CPCHScriptWrapper_ClientSideRoot::FinalConstructInner( /*[in]*/ const CLSID* pWrappedCLSID )
{
    m_pWrappedCLSID = pWrappedCLSID;

    return S_OK;
}

void CPCHScriptWrapper_ClientSideRoot::FinalRelease()
{
    m_Browser.Release();
    m_Script .Release();
}

////////////////////////////////////////////////////////////////////////////////
//
// IActiveScript
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::SetScriptSite( /*[in]*/ IActiveScriptSite* pass )
{
    m_Browser = pass;

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetScriptSite( /*[in ]*/ REFIID  riid      ,
                                                              /*[out]*/ void*  *ppvObject )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->QueryInterface( riid, ppvObject );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::SetScriptState( /*[in] */ SCRIPTSTATE ss )
{
    m_ss = ss;

    if(m_Script) return m_Script->Remote_SetScriptState( ss );

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetScriptState( /*[out]*/ SCRIPTSTATE *pssState )
{
    HRESULT hr = S_OK;

    if(m_Script)
    {
        hr = m_Script->Remote_GetScriptState( &m_ss );
    }

    if(pssState) *pssState = m_ss;

    return hr;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Close( void )
{
    if(m_Script) return m_Script->Remote_Close();

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::AddNamedItem( /*[in]*/ LPCOLESTR pstrName ,
                                                             /*[in]*/ DWORD     dwFlags  )
{
    NamedIter it;

    it = std::find( m_lstNamed.begin(), m_lstNamed.end(), pstrName );
    if(it == m_lstNamed.end())
    {
        it = m_lstNamed.insert( m_lstNamed.end() );

        it->m_bstrName = pstrName;
    }
    it->m_dwFlags = dwFlags;


    if(m_Script) return m_Script->Remote_AddNamedItem( CComBSTR( pstrName ), dwFlags );

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::AddTypeLib( /*[in]*/ REFGUID rguidTypeLib ,
                                                           /*[in]*/ DWORD   dwMajor      ,
                                                           /*[in]*/ DWORD   dwMinor      ,
                                                           /*[in]*/ DWORD   dwFlags      )
{
    TypeLibIter it;

    it = std::find( m_lstTypeLib.begin(), m_lstTypeLib.end(), rguidTypeLib );
    if(it == m_lstTypeLib.end())
    {
        it = m_lstTypeLib.insert( m_lstTypeLib.end() );

        it->m_guidTypeLib = rguidTypeLib;
    }
    it->m_dwMajor = dwMajor;
    it->m_dwMinor = dwMinor;
    it->m_dwFlags = dwFlags;


    if(m_Script) return m_Script->Remote_AddTypeLib( CComBSTR( rguidTypeLib ), dwMajor, dwMinor, dwFlags );

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetScriptDispatch( /*[in ]*/ LPCOLESTR   pstrItemName ,
                                                                  /*[out]*/ IDispatch* *ppdisp       )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Remote_GetScriptDispatch( CComBSTR( pstrItemName ), ppdisp );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetCurrentScriptThreadID( /*[out]*/ SCRIPTTHREADID *pstidThread )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Remote_GetCurrentScriptThreadID( pstidThread );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetScriptThreadID( /*[in ]*/ DWORD           dwWin32ThreadId ,
                                                                  /*[out]*/ SCRIPTTHREADID *pstidThread     )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Remote_GetScriptThreadID( dwWin32ThreadId, pstidThread );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::GetScriptThreadState( /*[in ]*/ SCRIPTTHREADID     stidThread ,
                                                                     /*[out]*/ SCRIPTTHREADSTATE *pstsState  )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Remote_GetScriptThreadState( stidThread, pstsState );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::InterruptScriptThread( /*[in]*/ SCRIPTTHREADID   stidThread ,
                                                                      /*[in]*/ const EXCEPINFO* pexcepinfo ,
                                                                      /*[in]*/ DWORD            dwFlags    )
{
    if(m_Script == NULL) return E_FAIL;

    return m_Script->Remote_InterruptScriptThread( stidThread, dwFlags );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Clone( /*[out]*/ IActiveScript* *ppscript )
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// IActiveScriptParse
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::InitNew( void )
{
    m_lstNamed  .clear();
    m_lstTypeLib.clear();

    m_ss = SCRIPTSTATE_INITIALIZED;

    m_Browser.Release();
    m_Script .Release();

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::AddScriptlet( /*[in ]*/ LPCOLESTR  pstrDefaultName       ,
                                                             /*[in ]*/ LPCOLESTR  pstrCode              ,
                                                             /*[in ]*/ LPCOLESTR  pstrItemName          ,
                                                             /*[in ]*/ LPCOLESTR  pstrSubItemName       ,
                                                             /*[in ]*/ LPCOLESTR  pstrEventName         ,
                                                             /*[in ]*/ LPCOLESTR  pstrDelimiter         ,
                                                             /*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
                                                             /*[in ]*/ ULONG      ulStartingLineNumber  ,
                                                             /*[in ]*/ DWORD      dwFlags               ,
                                                             /*[out]*/ BSTR      *pbstrName             ,
                                                             /*[out]*/ EXCEPINFO *pexcepinfo            )
{
    return E_NOTIMPL;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::ParseScriptText( /*[in ]*/ LPCOLESTR  pstrCode              ,
                                                                /*[in ]*/ LPCOLESTR  pstrItemName          ,
                                                                /*[in ]*/ IUnknown*  punkContext           ,
                                                                /*[in ]*/ LPCOLESTR  pstrDelimiter         ,
                                                                /*[in ]*/ DWORD_PTR  dwSourceContextCookie ,
                                                                /*[in ]*/ ULONG      ulStartingLineNumber  ,
                                                                /*[in ]*/ DWORD      dwFlags               ,
                                                                /*[out]*/ VARIANT   *pvarResult            ,
                                                                /*[out]*/ EXCEPINFO *pexcepinfo            )
{
    __HCP_FUNC_ENTRY( "CPCHScriptWrapper_ClientSideRoot::ParseScriptText" );

    HRESULT           hr;
	CComPtr<IUnknown> unk;
	CComBSTR          bstrURL;

	//
	// Extract the URL of the page containing the script.
	//
	{
		CComQIPtr<IServiceProvider> sp = m_Browser;

		if(sp)
		{
			CComPtr<IHTMLDocument2> doc;
				
			if(SUCCEEDED(sp->QueryService( CLSID_HTMLDocument, IID_IHTMLDocument2, (void**)&doc )) && doc)
			{
				(void)doc->get_URL( &bstrURL );
			}
		}
	}


	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->CreateScriptWrapper( *m_pWrappedCLSID, (BSTR)pstrCode, bstrURL, &unk ));
	if(unk == NULL)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
	}

	//
	// At this point, we have a valid script host for the vendor associated with the URL.
	//
	// Beware, IE reuses the IActiveScript object for all the script island in the same page,
	// but our engine is tied to only one vendor, so this could be a problem IF we have
	// script snippets from different vendors in the same page.
	//
	// Fortunately, we also check that the URL matches the vendor, it cannot happen that
	// the URL gets resolved as belonging to two vendors.
	//
	// In brief, thanks to the URL/vendor cross-checking, it cannot happen that we reach
	// this point in the code for two different vendors.
	//
    if(m_Script == NULL)
    {
        NamedIterConst    itNamed;
        TypeLibIterConst  itTypeLib;

        __MPC_EXIT_IF_METHOD_FAILS(hr, unk->QueryInterface( IID_IPCHActiveScript, (void**)&m_Script ));

        ////////////////////

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Script->Remote_InitNew());

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_Script->Remote_SetScriptSite( (IPCHActiveScriptSite*)this ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, SetScriptState( SCRIPTSTATE_STARTED ));

        for(itNamed = m_lstNamed.begin(); itNamed != m_lstNamed.end(); itNamed++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_Script->Remote_AddNamedItem( itNamed->m_bstrName,
                                                                          itNamed->m_dwFlags ));
        }

        for(itTypeLib = m_lstTypeLib.begin(); itTypeLib != m_lstTypeLib.end(); itTypeLib++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_Script->Remote_AddTypeLib( CComBSTR( itTypeLib->m_guidTypeLib ),
                                                                                  itTypeLib->m_dwMajor      ,
                                                                                  itTypeLib->m_dwMinor      ,
                                                                                  itTypeLib->m_dwFlags      ));
        }
    }


    hr = m_Script->Remote_ParseScriptText( CComBSTR( pstrCode              ),
                                           CComBSTR( pstrItemName          ),
                                                     punkContext            ,
                                           CComBSTR( pstrDelimiter         ),
                                                     dwSourceContextCookie  ,
                                                     ulStartingLineNumber   ,
                                                     dwFlags                ,
                                                     pvarResult             );

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// IPCHActiveScriptSite
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_GetLCID( /*[out]*/ BSTR *plcid )
{
    HRESULT     hr;
    CComBSTR    bstr;
    CComVariant v;
    LCID        lcid;

    if(m_Browser == NULL) return E_FAIL;

    if(FAILED(hr = m_Browser->GetLCID( &lcid ))) return hr;

    v = (long)lcid; v.ChangeType( VT_BSTR ); bstr = v.bstrVal;

    if(plcid) *plcid = bstr.Detach();

    return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_GetItemInfo( /*[in ]*/ BSTR        bstrName     ,
                                                                   /*[in ]*/ DWORD       dwReturnMask ,
                                                                   /*[out]*/ IUnknown*  *ppiunkItem   ,
                                                                   /*[out]*/ ITypeInfo* *ppti         )
{
	HRESULT            hr;
	CComPtr<IUnknown>  unk;
	CComPtr<ITypeInfo> pti;

    if(m_Browser == NULL) return E_FAIL;

	if(FAILED(hr = m_Browser->GetItemInfo( bstrName, dwReturnMask,
										            (dwReturnMask & SCRIPTINFO_IUNKNOWN ) ? &unk : NULL,
										            (dwReturnMask & SCRIPTINFO_ITYPEINFO) ? &pti : NULL ))) return hr;

	if(ppiunkItem)
	{
		if(FAILED(hr = CPCHDispatchWrapper::CreateInstance( unk, ppiunkItem ))) return hr;
	}

	if(ppti)
	{
		*ppti = pti.Detach();
	}

	return S_OK;
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_GetDocVersionString( /*[out]*/ BSTR *pbstrVersion )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->GetDocVersionString( pbstrVersion );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_OnScriptTerminate( /*[in]*/ VARIANT*   pvarResult )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->OnScriptTerminate( pvarResult, NULL );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_OnStateChange( /*[in]*/ SCRIPTSTATE ssScriptState )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->OnStateChange( ssScriptState );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_OnScriptError( /*[in]*/ IUnknown* pscripterror )
{
    CComQIPtr<IActiveScriptError> scripterror( pscripterror );

    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->OnScriptError( scripterror );
}

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_OnEnterScript( void )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->OnEnterScript();
};

STDMETHODIMP CPCHScriptWrapper_ClientSideRoot::Remote_OnLeaveScript( void )
{
    if(m_Browser == NULL) return E_FAIL;

    return m_Browser->OnLeaveScript();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\securitymanager.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    SecurityManager.cpp

Abstract:
    This file contains the implementation of the CSecurityManager class,
	which is used to control access to the Scripting Framework.

Revision History:
    Davide Massarenti (dmassare)  08/07/99
        created

******************************************************************************/

#include "stdafx.h"

#include <MPC_logging.h>

CPCHSecurityManager::CPCHSecurityManager()
{
	m_parent     = NULL;  // CPCHHelpCenterExternal* m_parent;
    m_fActivated = false; // bool                    m_fActivated;
}

void CPCHSecurityManager::Initialize( /*[in]*/ CPCHHelpCenterExternal* parent )
{
	m_parent = parent;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CPCHSecurityManager::ActivateService()
{
	__HCP_FUNC_ENTRY( "CPCHSecurityManager::ActivateService" );

	HRESULT              hr;
	CComPtr<IPCHService> svc;


	__MPC_EXIT_IF_METHOD_FAILS(hr, svc.CoCreateInstance( CLSID_PCHService ));

	m_fActivated = (svc !=  NULL);

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	Thread_Abort();

	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

bool CPCHSecurityManager::IsUrlTrusted( /*[in]*/ LPCWSTR pwszURL, /*[in]*/ bool *pfSystem )
{
    bool         fTrusted = false;
	MPC::wstring strUrlModified;
	MPC::wstring strVendor;

	CPCHWrapProtocolInfo::NormalizeUrl( pwszURL, strUrlModified, /*fReverse*/true );

	//
	// Don't try to use the store at first. It requires the service to be up and running...
	//
	(void)CPCHContentStore::s_GLOBAL->IsTrusted( strUrlModified.c_str(), fTrusted, NULL, false );
	if(fTrusted == false)
	{
		CPCHProxy_IPCHService* svc = m_parent->Service();

		//
		// Not a system page, we need to wake up the service...
		//
		if(m_fActivated == false)
		{
			if(SUCCEEDED(Thread_Start( this, ActivateService, NULL )))
			{
				Thread_Wait( /*fForce*/false, /*fNoMsg*/true );
			}
		}

		if(m_fActivated)
		{
			//
			// Get the trust status from the content store.
			//
			(void)CPCHContentStore::s_GLOBAL->IsTrusted( strUrlModified.c_str(), fTrusted, &strVendor );
		}
	}

	if(pfSystem)
	{
		*pfSystem = (fTrusted && strVendor.length() == 0);
	}

    return fTrusted;
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHSecurityManager::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    HRESULT hr = E_NOINTERFACE;

    if(InlineIsEqualGUID( riid, IID_IInternetSecurityManager ))
    {
        hr = QueryInterface( riid, ppv );
    }

    return hr;
}


STDMETHODIMP CPCHSecurityManager::MapUrlToZone( /*[in] */ LPCWSTR  pwszUrl ,
												/*[out]*/ DWORD   *pdwZone ,
												/*[in] */ DWORD    dwFlags )
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if(IsUrlTrusted( pwszUrl ))
    {
        if(pdwZone) *pdwZone = URLZONE_TRUSTED;

		hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CPCHSecurityManager::ProcessUrlAction( /*[in] */ LPCWSTR  pwszUrl    ,
													/*[in] */ DWORD    dwAction   ,
													/*[out]*/ BYTE    *pPolicy    ,
													/*[in] */ DWORD    cbPolicy   ,
													/*[in] */ BYTE    *pContext   ,
													/*[in] */ DWORD    cbContext  ,
													/*[in] */ DWORD    dwFlags    ,
													/*[in] */ DWORD    dwReserved )
{
    HRESULT hr;
	bool    fSystem;
	bool    fTrusted;


	fTrusted = IsUrlTrusted( pwszUrl, &fSystem );
	if(fTrusted)
	{
		//
		// If the page is trusted but not a system page, we normally map it to the TRUSTED zone.
		// However, the default settings for the trusted zone is to prompt for ActiveX not marked
		// as safe for scripting. Since this is the case for most of our objects, we allow all of them.
		//
		// Also, we enable all the script-related actions.
		//
		if(fSystem == false)
		{
			fTrusted = false;

			if(dwAction >= URLACTION_ACTIVEX_MIN &&
			   dwAction <= URLACTION_ACTIVEX_MAX  )
			{
				fTrusted = true;
			}

			if(dwAction >= URLACTION_SCRIPT_MIN &&
			   dwAction <= URLACTION_SCRIPT_MAX  )
			{
				fTrusted = true;
			}
		}
	}


	if(fTrusted)
	{
        if(cbPolicy >= sizeof (DWORD))
        {
            *(DWORD *)pPolicy = URLPOLICY_ALLOW;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
	else
	{
		hr = INET_E_DEFAULT_ACTION;
	}


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\misc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_COM.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_xml.h>

#include <HelpCenter.h>
#include <HelpViewerWrapper.h>
#include <HelpCenterExternal.h>

#include <NameSpace_Impl.h>
#include <Behaviors.h>


#include <QueryResult.h>

#include <ServiceProxy.h>

#include <Favorites.h>
#include <Printing.h>
#include <Options.h>

#include <encrypt.h>
#include <incident.h>

#include <safintercomclient.h>
#include <safintercomserver.h>

//
// Content Store
//
#include <ContentStoreMgr.h>

//
// Trusted Scripts 
//
#include <TrustedScripts.h>

#include <resource.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\bindstatuscallback.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    BindStatusCallback.h

Abstract:
    This file contains the implementation of the CPAData class, which is
    used to specify a single problem area

Revision History:
    Davide Massarenti   (Dmassare)  07/05/99
        created

******************************************************************************/

#include "stdafx.h"


CHCPBindStatusCallback::CHCPBindStatusCallback()
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::CHCPBindStatusCallback");

    m_pT                = NULL;
    m_dwTotalRead       = 0;
    m_dwAvailableToRead = 0;
}

CHCPBindStatusCallback::~CHCPBindStatusCallback()
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::~CHCPBindStatusCallback");
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHCPBindStatusCallback::OnStartBinding( DWORD     dwReserved ,
                                                     IBinding *pBinding   )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnStartBinding");

    m_spBinding = pBinding;

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CHCPBindStatusCallback::GetPriority( LONG *pnPriority )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::GetPriority");

    HRESULT hr;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pnPriority,THREAD_PRIORITY_NORMAL);
	__MPC_PARAMCHECK_END();

	hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPBindStatusCallback::OnLowResource( DWORD reserved )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnLowResource");

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CHCPBindStatusCallback::OnProgress( ULONG   ulProgress    ,
                                                 ULONG   ulProgressMax ,
                                                 ULONG   ulStatusCode  ,
                                                 LPCWSTR szStatusText  )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnProgress");

	HRESULT hr = m_pT->OnProgress( ulProgress, ulProgressMax, ulStatusCode, szStatusText );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPBindStatusCallback::OnStopBinding( HRESULT hresult ,
                                                    LPCWSTR szError )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnStopBinding");

    if(FAILED(hresult))
    {
        m_pT->OnBindingFailure( hresult, szError );
    }

    m_pT = NULL;

    m_spBinding.Release();
    m_spBindCtx.Release();
    m_spMoniker.Release();


    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CHCPBindStatusCallback::GetBindInfo( DWORD    *pgrfBINDF ,
                                                  BINDINFO *pbindInfo )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::GetBindInfo");

    HRESULT hr;
    ULONG   cbSize;

    if(pgrfBINDF         == NULL ||
       pbindInfo         == NULL ||
       pbindInfo->cbSize == 0     )
    {
		__MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
    }

    cbSize = pbindInfo->cbSize;     // remember incoming cbSize
    memset( pbindInfo, 0, cbSize ); // zero out structure
    pbindInfo->cbSize = cbSize;     // restore cbSize

    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

    hr = m_pT->GetBindInfo( pbindInfo );
    if(hr == S_FALSE)
    {
        pbindInfo->dwBindVerb = BINDVERB_GET;   // set verb
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPBindStatusCallback::OnDataAvailable( DWORD      grfBSCF    ,
                                                      DWORD      dwSize     ,
                                                      FORMATETC *pformatetc ,
                                                      STGMEDIUM *pstgmed    )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnDataAvailable");

    HRESULT hr;
	BYTE*   pBytes = NULL;

    // Get the Stream passed
    if(grfBSCF & BSCF_FIRSTDATANOTIFICATION)
    {
        if(!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
        {
            m_spStream = pstgmed->pstm;
        }
    }

    DWORD dwRead         = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
    DWORD dwActuallyRead = 0;                      // Placeholder for amount read during this pull

    // If there is some data to be read then go ahead and read them
    if(m_spStream)
    {
        if(dwRead > 0)
        {
            __MPC_EXIT_IF_ALLOC_FAILS(hr, pBytes, new BYTE[dwRead]);

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_spStream->Read( pBytes, dwRead, &dwActuallyRead ));

			if(dwActuallyRead > 0)
			{
				m_pT->OnData( this, pBytes, dwActuallyRead, grfBSCF, pformatetc , pstgmed );
				m_dwTotalRead += dwActuallyRead;
            }
        }
    }

    if(grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        m_spStream.Release();
    }

	hr = S_OK;

    __HCP_FUNC_CLEANUP;

	delete[] pBytes;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPBindStatusCallback::OnObjectAvailable( REFIID    riid ,
                                                        IUnknown *punk )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::OnObjectAvailable");

    __HCP_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHCPBindStatusCallback::BeginningTransaction( LPCWSTR  szURL                ,
														   LPCWSTR  szHeaders            ,
														   DWORD    dwReserved           ,
														   LPWSTR  *pszAdditionalHeaders )
{
	  HRESULT hr = E_NOTIMPL;

	  if(m_pT)
	  {
		  CComPtr<IHttpNegotiate> pIHttpNegotiate;

		  if(SUCCEEDED(hr = m_pT->ForwardQueryInterface( IID_IHttpNegotiate, (void **)&pIHttpNegotiate )))
		  {
			  hr = pIHttpNegotiate->BeginningTransaction( szURL                ,
														  szHeaders            ,
														  dwReserved           ,
														  pszAdditionalHeaders );
		  }
	  }

	  return hr;
}

STDMETHODIMP CHCPBindStatusCallback::OnResponse( DWORD    dwResponseCode              ,
												 LPCWSTR  szResponseHeaders           ,
												 LPCWSTR  szRequestHeaders            ,
												 LPWSTR  *pszAdditionalRequestHeaders )
{
	  HRESULT hr = E_NOTIMPL;

	  if(m_pT)
	  {
		  CComPtr<IHttpNegotiate> pIHttpNegotiate;

		  if(SUCCEEDED(hr = m_pT->ForwardQueryInterface( IID_IHttpNegotiate, (void **)&pIHttpNegotiate )))
		  {
			  hr = pIHttpNegotiate->OnResponse( dwResponseCode              ,
												szResponseHeaders           ,
												szRequestHeaders            ,
												pszAdditionalRequestHeaders );
		  }
	  }

	  return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CHCPBindStatusCallback::StartAsyncDownload( ISimpleBindStatusCallback* pT            ,
                                                    BSTR                       bstrURL       ,
                                                    IUnknown*                  pUnkContainer ,
                                                    BOOL                       bRelative     )
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::StartAsyncDownload");

    HRESULT                     hr = S_OK;
    CComQIPtr<IServiceProvider> spServiceProvider( pUnkContainer );
    CComPtr<IBindHost>          spBindHost;
    CComPtr<IStream>            spStream;

    m_pT                = pT;
    m_dwTotalRead       = 0;
    m_dwAvailableToRead = 0;

    if(spServiceProvider)
    {
        spServiceProvider->QueryService( SID_IBindHost, IID_IBindHost, (void**)&spBindHost );
    }


	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateBindCtx( 0, &m_spBindCtx ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ::RegisterBindStatusCallback( m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L ));

	if(bRelative)
	{
		if(spBindHost == NULL)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE); // relative asked for, but no IBindHost
		}

		__MPC_EXIT_IF_METHOD_FAILS(hr, spBindHost->CreateMoniker( bstrURL, m_spBindCtx, &m_spMoniker, 0 ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateURLMoniker( NULL, bstrURL, &m_spMoniker ));
	}


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_pT->PreBindMoniker( m_spBindCtx, m_spMoniker ));


	if(spBindHost == NULL)
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, m_spMoniker->BindToStorage( m_spBindCtx, 0, IID_IStream, (void**)&spStream ));
	}
	else
	{
		__MPC_EXIT_IF_METHOD_FAILS(hr, spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, this, IID_IStream, (void**)&spStream));
	}

	hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPBindStatusCallback::Abort()
{
    __HCP_FUNC_ENTRY("CHCPBindStatusCallback::Abort");

    if(m_spBinding)
    {
        m_spBinding->Abort();
    }

    __HCP_FUNC_EXIT(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\protocolroot.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ProtocolRoot.cpp

Abstract:
    This file contains the implementation of the CPAData class, which is
    used to specify a single problem area

Revision History:
    Davide Massarenti   (Dmassare)  07/05/99
        created

******************************************************************************/

#include "stdafx.h"

#include <Debug.h>

/////////////////////////////////////////////////////////////////////////////

// BINDSTATUS_FINDINGRESOURCE              01
// BINDSTATUS_CONNECTING                   02
// BINDSTATUS_REDIRECTING                  03
// BINDSTATUS_BEGINDOWNLOADDATA            04
// BINDSTATUS_DOWNLOADINGDATA              05
// BINDSTATUS_ENDDOWNLOADDATA              06
// BINDSTATUS_BEGINDOWNLOADCOMPONENTS      07
// BINDSTATUS_INSTALLINGCOMPONENTS         08
// BINDSTATUS_ENDDOWNLOADCOMPONENTS        09
// BINDSTATUS_USINGCACHEDCOPY              10
// BINDSTATUS_SENDINGREQUEST               11
// BINDSTATUS_CLASSIDAVAILABLE             12
// BINDSTATUS_MIMETYPEAVAILABLE            13
// BINDSTATUS_CACHEFILENAMEAVAILABLE       14
// BINDSTATUS_BEGINSYNCOPERATION           15
// BINDSTATUS_ENDSYNCOPERATION             16
// BINDSTATUS_BEGINUPLOADDATA              17
// BINDSTATUS_UPLOADINGDATA                18
// BINDSTATUS_ENDUPLOADDATA                19
// BINDSTATUS_PROTOCOLCLASSID              20
// BINDSTATUS_ENCODING                     21
// BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE    22
// BINDSTATUS_CLASSINSTALLLOCATION         23
// BINDSTATUS_DECODING                     24
// BINDSTATUS_LOADINGMIMEHANDLER           25
// BINDSTATUS_CONTENTDISPOSITIONATTACH     26
// BINDSTATUS_FILTERREPORTMIMETYPE         27
// BINDSTATUS_CLSIDCANINSTANTIATE          28
// BINDSTATUS_DLLNAMEAVAILABLE             29
// BINDSTATUS_DIRECTBIND                   30
// BINDSTATUS_RAWMIMETYPE                  31
// BINDSTATUS_PROXYDETECTING               32

/////////////////////////////////////////////////////////////////////////////

static const WCHAR c_szContent  [] = L"Content Type";
static const WCHAR c_szSystem   [] = L"hcp://system/";
static const WCHAR c_szHelp     [] = L"hcp://help/";
static const WCHAR c_szRoot     [] = L"hcp://";

static const WCHAR c_szSharedCSS[] = L"hcp://system/css/shared.css";

static const WCHAR c_szSystemDir   [] = HC_HELPSET_SUB_SYSTEM     L"\\";
static const WCHAR c_szSystemOEMDir[] = HC_HELPSET_SUB_SYSTEM_OEM L"\\";
static const WCHAR c_szVendorDir   [] = HC_HELPSET_SUB_VENDORS    L"\\";


typedef struct
{
    LPCWSTR szPrefix;
    int     iPrefix;

    LPCWSTR szRealSubDir;
    bool    fRelocate;
    bool    fCSS;
    bool    fSkipIfMissing;
} Lookup_Virtual_To_Real;

static const Lookup_Virtual_To_Real c_lookup[] =
{
    { c_szSharedCSS, MAXSTRLEN(c_szSharedCSS), NULL            , false, true , true  },
    { c_szHelp     , MAXSTRLEN(c_szHelp  	), NULL            , true , false, false },
	///////////////////////////////////////////////////////////////////////////////////
    { c_szSystem   , MAXSTRLEN(c_szSystem	), c_szSystemOEMDir, true , false, true  }, // First try the OEM directory...
    { c_szSystem   , MAXSTRLEN(c_szSystem	), c_szSystemDir   , true , false, true  },
    { c_szRoot     , MAXSTRLEN(c_szRoot  	), c_szVendorDir   , true , false, true  },
	///////////////////////////////////////////////////////////////////////////////////
    { c_szSystem   , MAXSTRLEN(c_szSystem	), c_szSystemOEMDir, false, false, true  }, // First try the OEM directory...
    { c_szSystem   , MAXSTRLEN(c_szSystem	), c_szSystemDir   , false, false, false },
    { c_szRoot     , MAXSTRLEN(c_szRoot  	), c_szVendorDir   , false, false, false }
};

typedef struct 
{
	LPCWSTR szExt;
	LPCWSTR szMIME;
} Lookup_Ext_To_Mime;

static const Lookup_Ext_To_Mime c_lookupMIME[] =
{
	{ L".htm" , L"text/html"                },
	{ L".html", L"text/html"                },
	{ L".css" , L"text/css"                 },
	{ L".xml" , L"text/xml"                 },
	{ L".js"  , L"application/x-javascript" },
	{ L".gif" , L"image/gif"                },
	{ L".jpg" , L"image/jpeg"               },
	{ L".bmp" , L"image/bmp"                },
};

/////////////////////////////////////////////////////////////////////////////

HRESULT GetMimeFromExt( LPCWSTR pszExt  ,
                        LPWSTR  pszMime ,
                        DWORD   cbMime  )
{
    __HCP_FUNC_ENTRY("::GetMimeFromExt");

    HRESULT      hr;
    MPC::wstring szMime;
    bool         fFound;


    hr = MPC::RegKey_Value_Read( szMime, fFound, pszExt, c_szContent, HKEY_CLASSES_ROOT );
    if(SUCCEEDED(hr) && fFound)
    {
        wcsncpy( pszMime, szMime.c_str(), cbMime );
    }
    else
    {
        pszMime[0] = L'\0';

		for(int i=0; i<ARRAYSIZE(c_lookupMIME); i++)
		{
			if(!MPC::StrICmp( c_lookupMIME[i].szExt, pszExt ))
			{
				wcsncpy( pszMime, c_lookupMIME[i].szMIME, cbMime );
				break;
			}
		}
    }


    __HCP_FUNC_EXIT(S_OK);
}

static LPCWSTR UnescapeFileName( CComBSTR& bstrFile ,
                                 LPCWSTR   szUrl    )
{
    WCHAR* rgTmpLarge;
    WCHAR  rgTmpSmall[MAX_PATH+1];
    DWORD  dwSize = MAX_PATH;

    if(::InternetCanonicalizeUrlW( szUrl, rgTmpSmall, &dwSize, ICU_DECODE | ICU_NO_ENCODE ))
    {
        bstrFile = rgTmpSmall;
    }
    else
    {
        rgTmpLarge = new WCHAR[dwSize+1];
        if(rgTmpLarge)
        {
            if(::InternetCanonicalizeUrlW( szUrl, rgTmpLarge, &dwSize, ICU_DECODE | ICU_NO_ENCODE ))
            {
                bstrFile = rgTmpLarge;
            }

            delete [] rgTmpLarge;
        }
    }

    return bstrFile;
}


/////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG_PROTOCOLLEAK

#include <Debug.h>

DEBUG_ProtocolLeak::DEBUG_ProtocolLeak()
{
    m_num         = 0;
    m_numOut      = 0;
    m_numStart    = 0;
    m_numComplete = 0;
}

DEBUG_ProtocolLeak::~DEBUG_ProtocolLeak()
{
    Iter it;

    for(it=m_set.begin(); it != m_set.end(); it++)
    {
        CHCPProtocol* ptr   = *it;
        bool          fGot  = m_setStart   .count( ptr ) != 0;
        bool          fDone = m_setComplete.count( ptr ) != 0;

        DebugLog( L"Protocol Leakage: %08x %s %s %s\n", ptr, fGot ? L"STARTED" : L"NOT STARTED", fDone ? L"DONE" : L"RECEIVING", ptr->m_bstrUrlComplete );
    }
}

void DEBUG_ProtocolLeak::Add( CHCPProtocol* ptr )
{
    DebugLog( L"Protocol Leakage: %08x CREATED %s\n", ptr, ptr->m_bstrUrlComplete );

    if(m_set.count( ptr ) != 0)
    {
        DebugBreak();
    }

    m_set.insert( ptr ); m_numOut++; m_num++;
}

void DEBUG_ProtocolLeak::Del( CHCPProtocol* ptr )
{
    DebugLog( L"Protocol Leakage: %08x RELEASED %s\n", ptr, ptr->m_bstrUrlComplete );

    if(m_setStart.erase( ptr ) == 1)
    {
        m_numStart += 0x10000;
    }

    if(m_setComplete.erase( ptr ) == 1)
    {
        m_numComplete += 0x10000;
    }

    if(m_set.erase( ptr ) == 1)
    {
        m_numOut--;
    }
    else
    {
        DebugBreak();
    }
}

void DEBUG_ProtocolLeak::CheckStart( CHCPProtocol* ptr )
{
    DebugLog( L"Protocol Leakage: %08x STARTED %s\n", ptr, ptr->m_bstrUrlComplete );

    if(m_setStart.count( ptr ) != 0)
    {
        DebugBreak();
    }

    m_setStart.insert( ptr ); m_numStart++;
}

void DEBUG_ProtocolLeak::Completed( CHCPProtocol* ptr )
{
    DebugLog( L"Protocol Leakage: %08x DONE %s\n", ptr, ptr->m_bstrUrlComplete );

    m_setComplete.insert( ptr ); m_numComplete++;
}

static DEBUG_ProtocolLeak leaker;

#endif


CHCPProtocol::CHCPProtocol()
{
#ifdef DEBUG_PROTOCOLLEAK
    leaker.Add( this );
#endif

    __HCP_FUNC_ENTRY("CHCPProtocol::CHCPProtocol");

    m_fDone               = false;  // bool                            m_fDone;
    m_fReportResult       = false;  // bool                            m_fReportResult;
                                    //
    m_cbAvailableSize     = 0;      // DWORD                           m_cbAvailableSize;
    m_cbTotalSize         = 0;      // DWORD                           m_cbTotalSize;
                                    //
                                    // CComPtr<IStream>                m_pstrmRead;
                                    // CComPtr<IStream>                m_pstrmWrite;
                                    //
                                    // CComPtr<IInternetProtocolSink>  m_pIProtSink;
                                    // CComPtr<IInternetBindInfo>      m_pIBindInfo;
    m_grfSTI              = 0;      // DWORD                           m_grfSTI;
                                    // BINDINFO                        m_bindinfo;
    m_bindf               = 0;      // DWORD                           m_bindf;
                                    //
                                    // CComBSTR                        m_bstrUrlComplete;
                                    // CComBSTR                        m_bstrUrlRedirected;
    m_pDownloader         = NULL;   // InnerDownloader*                m_pDownloader;
                                    //
    m_fRedirected         = false;  // bool                            m_fRedirected;
    m_fCSS                = false;  // bool                            m_fCSS;
    m_fBypass             = false;  // bool                            m_fBypass;
                                    //
                                    // CComPtr<IInternetProtocol>      m_ipiBypass;
                                    //
                                    // CComBSTR                        m_bstrMimeType;
    m_dwContentLength     = 0;      // DWORD                           m_dwContentLength;
                                    //
    m_hCache              = NULL;   // HANDLE                          m_hCache;
    m_szCacheFileName[0]  = 0;      // WCHAR                           m_szCacheFileName[MAX_PATH];


    memset( &m_bindinfo, 0, sizeof( m_bindinfo ) );
    m_bindinfo.cbSize = sizeof( m_bindinfo );
}

CHCPProtocol::~CHCPProtocol()
{
#ifdef DEBUG_PROTOCOLLEAK
    leaker.Del( this );
#endif

    __HCP_FUNC_ENTRY("CHCPProtocol::~CHCPProtocol");

    Shutdown();
}

////////////////////////////////////////////////////////////////////////////////

bool CHCPProtocol::OpenCacheEntry()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::OpenCacheEntry");

    bool    fRes  = false;
    LPCWSTR szUrl = m_bstrUrlComplete;
    LPCWSTR szExt;


    if((szExt = wcsrchr( szUrl, '.' ))) szExt++;

    CloseCacheEntry( true );

    if(::CreateUrlCacheEntryW( szUrl, 0, szExt, m_szCacheFileName, 0) )
    {
        if(m_szCacheFileName[0])
        {
            m_hCache = ::CreateFileW( m_szCacheFileName                 ,
                                      GENERIC_WRITE                     ,
                                      FILE_SHARE_WRITE | FILE_SHARE_READ, NULL,
                                      CREATE_ALWAYS                     ,
                                      FILE_ATTRIBUTE_NORMAL             , NULL);
            if(m_hCache == INVALID_HANDLE_VALUE)
            {
                m_hCache = NULL;
            }
            else
            {
                fRes = true;
            }
        }
    }


    __HCP_FUNC_EXIT(fRes);
}

void CHCPProtocol::WriteCacheEntry( /*[in]*/ void  *pv     ,
                                    /*[in]*/ ULONG  cbRead )
{
    if(m_hCache && cbRead)
    {
        DWORD cbWritten;

        if(::WriteFile( m_hCache, pv, cbRead, &cbWritten, NULL ) == FALSE || cbRead != cbWritten)
        {
            CloseCacheEntry( true );
        }
    }
}

void CHCPProtocol::CloseCacheEntry( /*[in]*/ bool fDelete )
{
    if(m_hCache)
    {
        ::CloseHandle( m_hCache ); m_hCache = NULL;

        if(fDelete)
        {
            ::DeleteUrlCacheEntryW( m_bstrUrlComplete );
        }
        else
        {
            WCHAR    szHeader[256];
            FILETIME ftZero = { 0, 0 };

            swprintf( szHeader, L"HTTP/1.0 200 OK \r\n Content-Length: %d \r\n Content-Type: %s \r\n\r\n", m_dwContentLength, (BSTR)m_bstrMimeType );

            ::CommitUrlCacheEntryW( m_bstrUrlComplete, m_szCacheFileName,
                                    ftZero, ftZero, NORMAL_CACHE_ENTRY,
                                    szHeader, wcslen( szHeader ), NULL, 0 );
        }
    }
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CHCPProtocol::InnerReportProgress( /*[in]*/ ULONG   ulStatusCode ,
                                           /*[in]*/ LPCWSTR szStatusText )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::InnerReportProgress");

    HRESULT hr;


    if(m_pIProtSink)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIProtSink->ReportProgress( ulStatusCode, szStatusText ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::InnerReportData( /*[in]*/ DWORD grfBSCF       ,
                                       /*[in]*/ ULONG ulProgress    ,
                                       /*[in]*/ ULONG ulProgressMax )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::InnerReportData");

    HRESULT hr;


    if(m_pIProtSink)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIProtSink->ReportData( grfBSCF, ulProgress, ulProgressMax ));
    }

    //
    // On the last data notification, also send a ReportResult.
    //
    if(grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportResult( S_OK, 0, 0 ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::InnerReportResult( /*[in]*/ HRESULT hrResult ,
                                         /*[in]*/ DWORD   dwError  ,
                                         /*[in]*/ LPCWSTR szResult )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::InnerReportResult");

    HRESULT hr;


    if(m_fReportResult == false)
    {
        m_fReportResult = true;

#ifdef DEBUG_PROTOCOLLEAK
        leaker.Completed( this );
#endif

        DEBUG_AppendPerf( DEBUG_PERF_PROTOCOL, L"CHCPProtocol::InnerReportResult  :  %s", SAFEBSTR( m_bstrUrlComplete ) );

        if(m_pIProtSink)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pIProtSink->ReportResult( hrResult, dwError, szResult ));
        }

        //
        // Release the references to the ProtSink and BindInfo objects, but not the references to the streams.
        //
        Shutdown( false );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CHCPProtocol::Shutdown( /*[in]*/ bool fAll )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Shutdown");


    m_pIBindInfo.Release();
    m_pIProtSink.Release();


    CloseCacheEntry( true );


    if(m_pDownloader)
    {
        m_pDownloader->Release();
        m_pDownloader = NULL;
    }

    if(fAll)
    {
        m_pstrmRead .Release();
        m_pstrmWrite.Release();

        // Release BINDINFO contents
        ::ReleaseBindInfo( &m_bindinfo );
    }
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHCPProtocol::Start( /*[in]*/ LPCWSTR                szUrl      ,
                                  /*[in]*/ IInternetProtocolSink *pIProtSink ,
                                  /*[in]*/ IInternetBindInfo     *pIBindInfo ,
                                  /*[in]*/ DWORD                  grfSTI     ,
                                  /*[in]*/ HANDLE_PTR             dwReserved )
{
#ifdef DEBUG_PROTOCOLLEAK
    leaker.CheckStart( this );
#endif

    __HCP_FUNC_ENTRY("CHCPProtocol::Start");

    HRESULT hr;


    DEBUG_AppendPerf( DEBUG_PERF_PROTOCOL, L"CHCPProtocol::Start  :  %s", szUrl );


    //
    // Initialize variables for new download.
    //
    Shutdown();

    m_fDone               = false;
    m_cbAvailableSize     = 0;
    m_cbTotalSize         = 0;

    m_pIProtSink          = pIProtSink;
    m_pIBindInfo          = pIBindInfo;
    m_grfSTI              = grfSTI;

    m_bstrUrlComplete     = (LPCOLESTR)NULL;
    m_bstrUrlRedirected   = (LPCOLESTR)NULL;


    //
    // Get URLMoniker BINDINFO structure from IInternetBindInfo
    //
    m_bindinfo.cbSize = sizeof( m_bindinfo );
    if(pIBindInfo)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, pIBindInfo->GetBindInfo( &m_bindf, &m_bindinfo ));
    }

    // Parse URL and store results inside
    hr = DoParse( szUrl );

    if(grfSTI & PI_PARSE_URL)
    {
        if(FAILED(hr))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    if(FAILED(hr)) __MPC_FUNC_LEAVE;


    // TODO: We could always spawn a worker thread to be more truly asynchronous.
    // Rather than complicate this code as multithreading scenarios tend to do,
    // we do everything on the main apartment thread and only pretend to be
    // working on a secondary thread if we get PI_FORCE_ASYNC
    if(!(grfSTI & PI_FORCE_ASYNC))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind());
    }
    else  // Wait for Continue to DoBind()
    {
        PROTOCOLDATA protdata;

        hr                = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState  = 1;
        protdata.pData    = NULL;
        protdata.cbData   = 0;

        // TODO: Actually, we should spawn a new worker thread and have it do the
        // bind process, then when done, it could use Switch / Continue to
        // pass data back to the apartment thread
        if(m_pIProtSink)
        {
            m_pIProtSink->Switch( &protdata );
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_INVALIDARG);
        }
    }


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        (void)InnerReportResult( hr, 0, 0 );
    }

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::Continue( /*[in]*/ PROTOCOLDATA *pStateInfo )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Continue");

    HRESULT hr;

    if(m_fBypass)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, m_ipiBypass->Continue( pStateInfo ));
    }

    // We're faking what it would be like to have a worker thread
    // communicating with the apartment thread
    // If we really did spawn off a worker thread, we should do the
    // bind there, and just use Switch/Continue to echo UI data back
    // to this thread
    if(pStateInfo->dwState == 1)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, DoBind());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::Abort( /*[in]*/ HRESULT hrReason  ,
                                  /*[in]*/ DWORD   dwOptions )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Abort");

    HRESULT hr = E_FAIL;


    if(m_fBypass)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_ipiBypass->Abort( hrReason, dwOptions ));
    }

    // Stop our own internal download process

    // TODO: If we call Abort too early on the Binding object,
    // this won't abort the download. (Too early is OnStartBinding
    // or before.) We won't bother checking, though, for clarity.
    // TODO: Make sure we set m_pDownloader to NULL when the
    // downloader object is destructed or finished.
    if(m_pDownloader)
    {
        m_pDownloader->Abort();
    }

    if(SUCCEEDED(hrReason)) // Possibly Abort could get called with 0?
    {
        hrReason = E_ABORT;
    }

    // Notify Sink of abort
    __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportResult( hrReason, 0, 0 ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::Terminate( /*[in]*/ DWORD dwOptions )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Terminate");

    HRESULT hr;

    if(m_fBypass)
    {
        (void)m_ipiBypass->Terminate( dwOptions );
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::Suspend()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Suspend");

    if(m_fBypass)
    {
        (void)m_ipiBypass->Suspend();
    }

    __HCP_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP CHCPProtocol::Resume()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Resume");

    if(m_fBypass)
    {
        (void)m_ipiBypass->Resume();
    }

    __HCP_FUNC_EXIT(E_NOTIMPL);
}

// IInternetProtocol methods
STDMETHODIMP CHCPProtocol::Read( /*[in] */ void  *pv      ,
                                 /*[in] */ ULONG  cb      ,
                                 /*[out]*/ ULONG *pcbRead )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Read");

    HRESULT hr = S_OK;


    DEBUG_AppendPerf( DEBUG_PERF_PROTOCOL_READ, L"CHCPProtocolRoot::Read  :  Enter %s %d", SAFEBSTR( m_bstrUrlComplete ), (int)cb );


    if(m_fBypass)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, m_ipiBypass->Read( pv, cb, pcbRead ));
    }

    if(m_pstrmRead == 0)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // We've hit the end of the road, jack
    }

    // One might expect URLMON to Read only the amount of data that we specified we have.
    // However, it actually reads in blocks and will go far beyond the data we have
    // specified unless we slap it around a little.
    // We must only return S_FALSE when we have hit the absolute end of the stream
    // If we think there is more data coming down the wire, then we return E_PENDING
    // here. Even if we return S_OK and no data, URLMON will still think we've hit
    // the end of the stream.
    // ASSERTION: End of data means we've received BSCF_LASTDATANOTIFICATION
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pstrmRead->Read( pv, cb, pcbRead ));

    if(hr == S_FALSE)
    {
        CloseCacheEntry( false );

        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // We've hit the end of the road, jack
    }
    else if(*pcbRead == 0)
    {
        if(m_fDone)
        {
            CloseCacheEntry( false );

            __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE); // We've hit the end of the road, jack
        }
        else
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_PENDING);
        }
    }
    else
    {
        WriteCacheEntry( pv, *pcbRead );
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::Seek( /*[in] */ LARGE_INTEGER   dlibMove        ,
                                 /*[in] */ DWORD           dwOrigin        ,
                                 /*[out]*/ ULARGE_INTEGER *plibNewPosition )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::Seek");

    if(m_fBypass)
    {
        (void)m_ipiBypass->Seek( dlibMove, dwOrigin, plibNewPosition );
    }

    __HCP_FUNC_EXIT(E_NOTIMPL);
}

STDMETHODIMP CHCPProtocol::LockRequest( /*[in]*/ DWORD dwOptions )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::LockRequest");

    if(m_fBypass)
    {
        (void)m_ipiBypass->LockRequest( dwOptions );
    }

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CHCPProtocol::UnlockRequest()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::UnlockRequest");

    if(m_fBypass)
    {
        (void)m_ipiBypass->UnlockRequest();
    }

    //
    // Release all the pointers to objects.
    //
    Shutdown();

    __HCP_FUNC_EXIT(S_OK);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHCPProtocol::QueryOption( DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf )
{
	__HCP_FUNC_ENTRY( "CHCPProtocol::QueryOption" );

    HRESULT hr;


	if(dwOption == INTERNET_OPTION_REQUEST_FLAGS && *pcbBuf == sizeof(DWORD))
	{
		*((DWORD*)pBuffer) = INTERNET_REQFLAG_FROM_CACHE;

		hr = S_OK;
	}
	else
	{
		hr = E_NOTIMPL;
	}


	__HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CHCPProtocol::DoParse( /*[in]*/ LPCWSTR szURL )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoParse");

    HRESULT  hr;
    CComBSTR bstrURLCopy;
    LPCWSTR  szURLCopy;
    LPWSTR   szQuery;
    LPCWSTR  szRedirect;
    bool     fHCP;


    m_bstrUrlComplete   =            szURL;
    m_bstrUrlRedirected = (LPCOLESTR)NULL;


    fHCP = CHCPProtocolInfo::LookForHCP( szURL, m_fRedirected, szRedirect );
    m_fRedirected = false;      // redirection should never happen here
    if(m_fRedirected)
    {
        m_bstrUrlRedirected = szRedirect;
    }
    else
    {
        const Lookup_Virtual_To_Real* ptr;
        int                           i;
		MPC::wstring                  strDir;
        LPOLESTR                      szTmp;


        szURLCopy = ::UnescapeFileName( bstrURLCopy, szURL ); if(!szURLCopy) __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

        //
        // Remove the query part of the URL.
        //
        if(szQuery = wcschr( szURLCopy, L'?' ))
        {
            szQuery[0] = 0;
        }

        //
        // Do the mapping between virtual paths and real ones.
        //
        for(ptr=c_lookup, i=0; i<ARRAYSIZE(c_lookup); i++, ptr++)
        {
            if(!_wcsnicmp( szURLCopy, ptr->szPrefix, ptr->iPrefix ))
            {
                if(ptr->fCSS)
                {
					m_bstrUrlRedirected = szURL;

					m_fCSS = true;
					break;
				}

                if(!ptr->szRealSubDir)
                {
                    strDir  = ptr->fRelocate ? CHCPProtocolEnvironment::s_GLOBAL->HelpLocation() : HC_HELPSVC_HELPFILES_DEFAULT;
                    strDir += L"\\";
                }
                else
                {
					strDir  = ptr->fRelocate ? CHCPProtocolEnvironment::s_GLOBAL->System() : HC_HELPSET_ROOT;
					strDir += ptr->szRealSubDir;
                }
                MPC::SubstituteEnvVariables( strDir );

                m_bstrUrlRedirected  =  strDir.c_str();
                m_bstrUrlRedirected += &szURLCopy[ ptr->iPrefix ];

				//
				// Convert the slashes to backslashes.
				//
				while((szTmp = wcschr( m_bstrUrlRedirected, L'/' ))) szTmp[0] = L'\\';

				//
				// Remove any trailing slash.
				//
				while((szTmp = wcsrchr( m_bstrUrlRedirected, L'/'  )) && szTmp[1] == 0) szTmp[0] = 0;
				while((szTmp = wcsrchr( m_bstrUrlRedirected, L'\\' )) && szTmp[1] == 0) szTmp[0] = 0;

				CHCPProtocolEnvironment::s_GLOBAL->ReformatURL( m_bstrUrlRedirected );

                if(ptr->fSkipIfMissing && MPC::FileSystemObject::IsFile( m_bstrUrlRedirected ) == false) continue;

                break;
            }
        }
    }

    if(!m_bstrUrlRedirected) __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CHCPProtocol::DoBind()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportProgress( BINDSTATUS_FINDINGRESOURCE, SAFEBSTR( m_bstrUrlRedirected ) ));


    if(m_fRedirected)
    {
        if(MPC::MSITS::IsCHM( SAFEBSTR( m_bstrUrlRedirected ) ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Redirect_MSITS());
        }
        else
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Redirect_UrlMoniker());
        }
    }
    else if(m_fCSS)
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_CSS());
    }
    else
    {
        MPC::wstring          szPage = SAFEBSTR(m_bstrUrlRedirected);
        MPC::FileSystemObject fso    = szPage.c_str();
        bool                  fFound;
        bool                  fIsAFile;

        __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Exists( fso, fFound, fIsAFile ));
        if(fFound && fIsAFile)
        {
            //
            // The file exists, so load its content.
            //
            __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_File());
        }
        else
        {
            //
            // The file, as is, doesn't exist, so try to find a .chm on the path.
            //
            while(1)
            {
                MPC::wstring szParent;
                MPC::wstring szCHM;

                __MPC_EXIT_IF_METHOD_FAILS(hr, fso.get_Parent( szParent ));
                if(szParent.length() == 0)
                {
                    //
                    // No parent, so exit with error.
                    //
                    __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
                }

                //
                // Point the FileSystemObject to its parent.
                //
                fso = szParent.c_str();
                __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Exists( fso, fFound, fIsAFile ));

                //
                // Parent exists, so it cannot exist a .CHM file. Exit with error.
                //
                if(fFound)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
                }

                //
                // Add the .CHM extension and look for it.
                //
                szCHM = szParent; szCHM.append( L".chm" );
                fso = szCHM.c_str();
                __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Exists( fso, fFound, fIsAFile ));

                //
                // No .CHM file, recurse up to the root.
                //
                if(fFound == false)
                {
                    continue;
                }

                //
                // The .CHM is not a file, exit with error.
                //
                if(fIsAFile == false)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
                }

                //
                // Found, so redirect to the proper protocol.
                //
                szCHM = L"ms-its:";
                szCHM.append( szParent );
                szCHM.append( L".chm"  );

                if(szParent.length() < szPage.length())
                {
                    LPWSTR szBuf = new WCHAR[szPage.length()+1];
                    if(szBuf)
                    {
                        LPWSTR szTmp;

                        wcscpy( szBuf, szPage.c_str() );

                        //
                        // Convert the backslashes to slashes.
                        //
                        while(szTmp = wcschr( szBuf, L'\\' )) szTmp[0] = L'/';

                        szCHM.append( L"::"                     );
                        szCHM.append( &szBuf[szParent.length()] );

                        delete [] szBuf;
                    }
                }

                m_bstrUrlRedirected = szCHM.c_str();

                __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_Redirect_MSITS());
                break;
            }
        }
    }

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CHCPProtocol::DoBind_Exists( /*[in] */ MPC::FileSystemObject& fso      ,
                                     /*[out]*/ bool&                  fFound   ,
                                     /*[out]*/ bool&                  fIsAFile )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_Exists");

    HRESULT hr;

    if(fso.Exists())
    {
        fFound   = true;
        fIsAFile = fso.IsFile();
    }
    else
    {
        fFound   = false;
        fIsAFile = false;
    }

    hr = S_OK;


    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::DoBind_Redirect_UrlMoniker()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_Redirect_UrlMoniker");

    HRESULT hr;


    //
    // Create the stream used to receive downloaded data.
    //
    ::CreateStreamOnHGlobal( NULL, TRUE, &m_pstrmWrite );
    if(m_pstrmWrite == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    //
    // Create the downloader object.
    //
    if(SUCCEEDED(hr = m_pDownloader->CreateInstance( &m_pDownloader )))
    {
        m_pDownloader->AddRef();

        if(FAILED(hr = m_pDownloader->StartAsyncDownload( this, m_bstrUrlRedirected, NULL, FALSE )))
		{
			if(hr != E_PENDING) __MPC_FUNC_LEAVE;
		}
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::DoBind_Redirect_MSITS()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_Redirect_MSITS");

    HRESULT  hr;
    CComBSTR bstrStorageName;
    CComBSTR bstrFilePath;
    LPCWSTR  szExt;
    WCHAR    rgMime[MAX_PATH];


    if(MPC::MSITS::IsCHM( SAFEBSTR( m_bstrUrlRedirected ), &bstrStorageName, &bstrFilePath ) == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    //
    // Try to find the Mime Type for this file.
    //
    if((szExt = wcsrchr( bstrFilePath, L'.' )))
    {
        ::GetMimeFromExt( szExt, rgMime, MAX_PATH-1 );
    }
    else
    {
        rgMime[0] = 0;
    }


    //
    // Extract the file from the CHM.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MSITS::OpenAsStream( bstrStorageName, bstrFilePath, &m_pstrmRead ));


    //
    // Signal the Protocol Sink that data is available.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_ReturnData( /*fCloneStream*/false, szExt ? rgMime : NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::DoBind_CSS()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_CSS");

    HRESULT hr;
    LPCWSTR szExt;
    WCHAR   rgMime[256];


    //
    // Try to find the Mime Type for this file.
    //
    if((szExt = wcsrchr( m_bstrUrlComplete, L'.' )))
    {
        ::GetMimeFromExt( szExt, rgMime, 255 );
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, CHCPProtocolEnvironment::s_GLOBAL->GetCSS( m_pstrmRead ));


    //
    // Signal the Protocol Sink that data is available.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_ReturnData( /*fCloneStream*/false, szExt ? rgMime : NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CHCPProtocol::DoBind_File()
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_File");

    HRESULT                  hr;
    CComPtr<MPC::FileStream> pStm;
    LPCWSTR                  szFile = m_bstrUrlRedirected;
    LPCWSTR                  szExt;
    WCHAR                    rgMime[256];


    //
    // Try to find the Mime Type for this file.
    //
    if((szExt = wcsrchr( szFile, L'.' )))
    {
        ::GetMimeFromExt( szExt, rgMime, 255 );
    }


    //
    // Create the file stream.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pStm ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->InitForRead   (                       szFile      ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, pStm->QueryInterface( IID_IStream, (void**)&m_pstrmRead ));


    //
    // Signal the Protocol Sink that data is available.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, DoBind_ReturnData( /*fCloneStream*/false, szExt ? rgMime : NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT CHCPProtocol::DoBind_ReturnData( /*[in]*/ bool    fCloneStream ,
                                         /*[in]*/ LPCWSTR szMimeType   )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::DoBind_ReturnData");

    HRESULT hr;
    STATSTG statstg;


    m_fDone = true;


    if(fCloneStream)
    {
        LARGE_INTEGER li;

        //
        // Clone the stream, so that we can hand it back to the ProtSink for data reading.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pstrmWrite->Clone( &m_pstrmRead ));

        //
        // Reset stream to beginning.
        //
        li.LowPart  = 0;
        li.HighPart = 0;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pstrmRead->Seek( li, STREAM_SEEK_SET, NULL ));
    }


    (void)m_pstrmRead->Stat( &statstg, STATFLAG_NONAME );

    m_bstrMimeType    = szMimeType;
    m_dwContentLength = statstg.cbSize.LowPart;

    //
    // Create an entry in the cache, if required.
    //
    if(m_bindf & BINDF_NEEDFILE)
    {
        (void)OpenCacheEntry();
    }

    if(szMimeType)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportProgress( BINDSTATUS_MIMETYPEAVAILABLE, szMimeType ));
    }

    if(m_hCache)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportProgress( BINDSTATUS_CACHEFILENAMEAVAILABLE, m_szCacheFileName ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportData( BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE,
                                                    statstg.cbSize.LowPart                                                          ,
                                                    statstg.cbSize.LowPart                                                          ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Implementation of the ISimpleBindStatusCallback interface.
//
STDMETHODIMP CHCPProtocol::ForwardQueryInterface( /*[in] */ REFIID riid ,
                                                  /*[out]*/ void** ppv  )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::ForwardQueryInterface");

    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    if(IsEqualIID( riid, IID_IHttpNegotiate))
    {
        CComQIPtr<IServiceProvider> pProv;

        pProv = m_pIProtSink;
        if(pProv)
        {
            if(SUCCEEDED(pProv->QueryService( riid, riid, ppv )))
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }

        pProv = m_pIBindInfo;
        if(pProv)
        {
            if(SUCCEEDED(pProv->QueryService( riid, riid, ppv )))
            {
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }
    }


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::GetBindInfo( /*[out]*/ BINDINFO *pbindInfo )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::GetBindInfo");

    HRESULT hr = ::CopyBindInfo( &m_bindinfo, pbindInfo );

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::PreBindMoniker( /*[in]*/ IBindCtx* pBindCtx ,
                                           /*[in]*/ IMoniker* pMoniker )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::PreBindMoniker");

    __HCP_FUNC_EXIT(S_OK);
}

STDMETHODIMP CHCPProtocol::OnProgress( /*[in]*/ ULONG   ulProgress   ,
                                       /*[in]*/ ULONG   ulProgressMax,
                                       /*[in]*/ ULONG   ulStatusCode ,
                                       /*[in]*/ LPCWSTR szStatusText )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::OnProgress");

    HRESULT hr;

    switch(ulStatusCode)
    {
    case BINDSTATUS_BEGINDOWNLOADDATA:
        // ulProgressMax represents the total size of the download
        // When talking HTTP, this is determined by the CONTENT_LENGTH header
        // If this header is missing or wrong, we're missing or wrong
        m_cbTotalSize = ulProgressMax;
        break;

    case BINDSTATUS_MIMETYPEAVAILABLE     :
    case BINDSTATUS_FINDINGRESOURCE       :
    case BINDSTATUS_CONNECTING            :
    case BINDSTATUS_SENDINGREQUEST        :
    case BINDSTATUS_CACHEFILENAMEAVAILABLE:
    case BINDSTATUS_REDIRECTING           :
    case BINDSTATUS_USINGCACHEDCOPY       :
    case BINDSTATUS_CLASSIDAVAILABLE      :
    case BINDSTATUS_LOADINGMIMEHANDLER    :
        // only pass on these notifications:
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportProgress( ulStatusCode, szStatusText ));
    }


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::OnData( /*[in]*/ CHCPBindStatusCallback* pbsc       ,
                                   /*[in]*/ BYTE*                   pBytes     ,
                                   /*[in]*/ DWORD                   dwSize     ,
                                   /*[in]*/ DWORD                   grfBSCF    ,
                                   /*[in]*/ FORMATETC*              pformatetc ,
                                   /*[in]*/ STGMEDIUM*              pstgmed    )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::OnData");

    HRESULT hr;
    ULONG   cbWritten;


    //
    // To handle an error, we just report result that we failed and terminate the download object
    //
    if(FAILED(hr = m_pstrmWrite->Write( pBytes, dwSize, &cbWritten )))
    {
        // Our own Abort handles this just nicely
        Abort( hr, 0 ); __MPC_FUNC_LEAVE;
    }

    m_cbAvailableSize += cbWritten;

    if(grfBSCF & BSCF_FIRSTDATANOTIFICATION)
    {
        LARGE_INTEGER li;

        // We need two concurrent seek pointers to the same stream
        // because we'll be writing to the stream at the end while
        // we're trying to read from the beginning
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pstrmWrite->Clone( &m_pstrmRead ));

        // reset stream to beginning
        li.LowPart  = 0;
        li.HighPart = 0;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_pstrmRead->Seek( li, STREAM_SEEK_SET, NULL ));
    }

    // We've got all the data, signal complete
    if(grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        // We need to remember if we've received LASTDATANOTIFICATION yet
        m_fDone = true;


        // We only need to do ReportResult if we fail somehow -
        // DATAFULLYAVAILABLE is signal enough that we succeeded
        // NOT NEEDED: m_pIProtSink->ReportResult(S_OK, 0, NULL);
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportData( BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE,
                                                        m_cbAvailableSize                                  ,
                                                        m_cbAvailableSize                                  ));
    }
    else
    {
        // Report our progress accurately using our byte count
        // of what we've read versus the total known download size

        // We know the total amount to read, the total read so far, and
        // the total written. The problem is that we can't know the total
        // amount that will be written in the end. So we estimate at
        // 1.5 * Total size and if we overrun, we just start adding some
        // extra to the end
        __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportData( grfBSCF, m_cbAvailableSize, m_cbTotalSize ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocol::OnBindingFailure( /*[in]*/ HRESULT hr      ,
                                             /*[in]*/ LPCWSTR szError )
{
    __HCP_FUNC_ENTRY("CHCPProtocol::OnBindingFailure");

    //
    // Inform protocol-sink that we've failed to download the data for some reason.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, InnerReportResult( hr, 0, szError ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\protocolshell.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ProtocolShell.cpp

Abstract:
    This file contains the implementation of the CHCPProcotolShell class,
    just a thin wrapper around CHCPProcotolRoot and CHCPProcotolInfo.

Revision History:
    Davide Massarenti   (Dmassare)  02/15/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

CHCPProtocolEnvironment::CHCPProtocolEnvironment()
{
    m_fHighContrast   = false; // bool               m_fHighContrast;
    m_f16Colors       = false; // bool               m_f16Colors;
                               // Taxonomy::Instance m_inst;
                               //
                               // MPC::string        m_strCSS;

    UpdateState();
}

CHCPProtocolEnvironment::~CHCPProtocolEnvironment()
{
}

////////////////////

CHCPProtocolEnvironment* CHCPProtocolEnvironment::s_GLOBAL( NULL );

HRESULT CHCPProtocolEnvironment::InitializeSystem()
{
    if(s_GLOBAL == NULL)
    {
        s_GLOBAL = new CHCPProtocolEnvironment;
    }

    return s_GLOBAL ? S_OK : E_OUTOFMEMORY;
}

void CHCPProtocolEnvironment::FinalizeSystem()
{
    if(s_GLOBAL)
    {
        delete s_GLOBAL; s_GLOBAL = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////


bool CHCPProtocolEnvironment::UpdateState()
{
    DEVMODE      dm;
    HIGHCONTRAST hc; hc.cbSize = sizeof( hc );
    bool         fHighContrast = false;
    bool         f16Colors     = false;
    bool         fRes;


    if(::EnumDisplaySettings( NULL, ENUM_CURRENT_SETTINGS, &dm ))
    {
        if(dm.dmBitsPerPel < 8)
        {
            f16Colors = true;
        }
    }

    if(::SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0 ))
    {
        if(hc.dwFlags & HCF_HIGHCONTRASTON)
        {
            fHighContrast = true;
        }
    }

    fRes = (m_fHighContrast != fHighContrast) ||
           (m_f16Colors     != f16Colors    ) ||
           (m_strCSS.size() != 0            ) ;

    m_fHighContrast = fHighContrast;
    m_f16Colors     = f16Colors;

    m_strCSS = "";

    return fRes;
}

void CHCPProtocolEnvironment::ReformatURL( CComBSTR& bstrURL )
{
    if(bstrURL != NULL)
    {
        WCHAR   szTmp[MAX_PATH];
        LPCWSTR szExtSrc;
        LPWSTR  szExtDst;

        wcsncpy( szTmp, bstrURL, MAXSTRLEN(szTmp) ); szTmp[MAXSTRLEN(szTmp)] = 0;

        szExtSrc = wcsrchr( bstrURL, '.' );
        szExtDst = wcsrchr( szTmp  , '.' );

        if(szExtDst)
        {
            szExtDst[0] = 0;

            if(m_inst.m_fDesktop)
            {
                wcsncat( szTmp, L"__DESKTOP", MAXSTRLEN(szTmp) - wcslen(szTmp) );
                wcsncat( szTmp, szExtSrc    , MAXSTRLEN(szTmp) - wcslen(szTmp) );

                if(MPC::FileSystemObject::IsFile( szTmp ))
                {
                    bstrURL = szTmp; return;
                }
            }

            if(m_inst.m_fServer)
            {
                wcsncat( szTmp, L"__SERVER", MAXSTRLEN(szTmp) - wcslen(szTmp) );
                wcsncat( szTmp, szExtSrc   , MAXSTRLEN(szTmp) - wcslen(szTmp) );

                if(MPC::FileSystemObject::IsFile( szTmp ))
                {
                    bstrURL = szTmp; return;
                }
            }
        }
    }
}

void CHCPProtocolEnvironment::SetHelpLocation( /*[in]*/ const Taxonomy::Instance& inst )
{
    m_inst = inst;
}

LPCWSTR CHCPProtocolEnvironment::HelpLocation()
{
    return m_inst.m_strHelpFiles.size() ? m_inst.m_strHelpFiles.c_str() : HC_HELPSVC_HELPFILES_DEFAULT;
}

LPCWSTR CHCPProtocolEnvironment::System() // Only MUI-based SKUs get relocated
{
    return (m_inst.m_fMUI && m_inst.m_strSystem.size()) ? m_inst.m_strSystem.c_str() : HC_HELPSET_ROOT;
}

const Taxonomy::Instance& CHCPProtocolEnvironment::Instance()
{
    return m_inst;
}

HRESULT CHCPProtocolEnvironment::GetCSS( /*[out]*/ CComPtr<IStream>& stream )
{
    __HCP_FUNC_ENTRY( "CHCPProtocolEnvironment::GetCSS" );

    HRESULT       hr;
    DWORD         dwWritten;
    LARGE_INTEGER liFilePos = { 0, 0 };


    __MPC_EXIT_IF_METHOD_FAILS(hr, ProcessCSS());

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Write( m_strCSS.c_str(), m_strCSS.size(), &dwWritten ));

    // Rewind the Stream.
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\protocolwrap.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    ProtocolWrap.cpp

Abstract:
    This file contains the implementation of the CPCHWrapProtocolInfo class,
    that is used to fix problems in the MS-ITS protocol.

Revision History:
    Davide Massarenti   (Dmassare)  05/07/2000
        created

******************************************************************************/

#include "stdafx.h"

static const WCHAR l_szWINDIR       [] = L"%WINDIR%";
static const WCHAR l_szHELP_LOCATION[] = L"%HELP_LOCATION%";

/////////////////////////////////////////////////////////////////////////////

CPCHWrapProtocolInfo::CPCHWrapProtocolInfo()
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::CPCHWrapProtocolInfo");

                         // CComPtr<IClassFactory>         m_realClass;
                         // CComPtr<IInternetProtocolInfo> m_realInfo;
}

CPCHWrapProtocolInfo::~CPCHWrapProtocolInfo()
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::~CPCHWrapProtocolInfo");
}

HRESULT CPCHWrapProtocolInfo::Init( REFGUID realClass )
{
    __HCP_FUNC_ENTRY( "CPCHWrapProtocolInfo::Init" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( realClass, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&m_realClass ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_realClass->CreateInstance( NULL, IID_IInternetProtocolInfo, (void **)&m_realInfo ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

void CPCHWrapProtocolInfo::ExpandAndConcat( /*[out]*/ CComBSTR& bstrStorageName ,
											/*[in]*/  LPCWSTR   szVariable      ,
											/*[in]*/  LPCWSTR   szAppend        )
{
	MPC::wstring strExpanded( szVariable ); MPC::SubstituteEnvVariables( strExpanded );

	if(szAppend)
	{
		if(szAppend[0] != '\\' &&
		   szAppend[0] != '/'   )
		{
			strExpanded += L"\\";
		}

		strExpanded += szAppend;
	}

	bstrStorageName = strExpanded.c_str();
}

void CPCHWrapProtocolInfo::NormalizeUrl( /*[in] */ LPCWSTR       pwzUrl         ,
                                         /*[out]*/ MPC::wstring& strUrlModified ,
										 /*[in] */ bool          fReverse       )
{
	CComBSTR bstrStorageName;
	CComBSTR bstrFilePath;
	bool     fModified = false;


	SANITIZEWSTR( pwzUrl );


	if(MPC::MSITS::IsCHM( pwzUrl, &bstrStorageName, &bstrFilePath ) && bstrStorageName.Length() > 0)
	{
		if(!_wcsnicmp( bstrStorageName, l_szHELP_LOCATION, MAXSTRLEN( l_szHELP_LOCATION ) ))
		{
			CComBSTR bstrTmp;

			while(1)
			{
				LPCWSTR szRest = &bstrStorageName[ MAXSTRLEN( l_szHELP_LOCATION ) ];
				WCHAR   rgDir[MAX_PATH];

				//
				// First, try the current help directory.
				//
				ExpandAndConcat( bstrTmp, CHCPProtocolEnvironment::s_GLOBAL->HelpLocation(), szRest );
				if(MPC::FileSystemObject::IsFile( bstrTmp )) break;

				//
				// Then, try the MUI version of the help directory.
				//
				_snwprintf( rgDir, MAXSTRLEN(rgDir), L"%s\\MUI\\%04lx", HC_HELPSVC_HELPFILES_DEFAULT, CHCPProtocolEnvironment::s_GLOBAL->Instance().m_ths.GetLanguage() );
				ExpandAndConcat( bstrTmp, rgDir, szRest );
				if(MPC::FileSystemObject::IsFile( bstrTmp )) break;

				//
				// Finally, try the system help directory.
				//
				ExpandAndConcat( bstrTmp, HC_HELPSVC_HELPFILES_DEFAULT, szRest );
				break;
			}

			if(MPC::FileSystemObject::IsFile( bstrTmp ))
			{
				bstrStorageName = bstrTmp;

				fModified = true;
			}
		}

		if(!_wcsnicmp( bstrStorageName, l_szWINDIR, MAXSTRLEN( l_szWINDIR ) ))
		{
			ExpandAndConcat( bstrStorageName, l_szWINDIR, &bstrStorageName[ MAXSTRLEN( l_szWINDIR ) ] );
			
			fModified = true;
		}
				
		if(::PathIsRelativeW( bstrStorageName ))
		{
			ExpandAndConcat( bstrStorageName, CHCPProtocolEnvironment::s_GLOBAL->HelpLocation(), bstrStorageName );

			fModified = true;
		}


		if(fReverse)
		{
			MPC::wstring strHelpLocation = CHCPProtocolEnvironment::s_GLOBAL->HelpLocation(); MPC::SubstituteEnvVariables( strHelpLocation );
			int          iSize           = strHelpLocation.size();

			if(!_wcsnicmp( bstrStorageName, strHelpLocation.c_str(), iSize ))
			{
				strHelpLocation  = l_szHELP_LOCATION;
				strHelpLocation += &bstrStorageName[iSize];

				bstrStorageName = strHelpLocation.c_str();
				
				fModified = true;
			}
		}
	}

	if(fModified)
	{
		strUrlModified  = L"MS-ITS:";
		strUrlModified += bstrStorageName;


		if(bstrFilePath.Length() > 0)
		{
			strUrlModified += L"::/";
			strUrlModified += bstrFilePath;
		}
	}
	else
	{
		strUrlModified = pwzUrl;
    }
}

/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHWrapProtocolInfo::CombineUrl( /*[in] */ LPCWSTR pwzBaseUrl    ,
                                               /*[in] */ LPCWSTR pwzRelativeUrl,
                                               /*[in] */ DWORD   dwCombineFlags,
                                               /*[out]*/ LPWSTR  pwzResult     ,
                                               /*[in] */ DWORD   cchResult     ,
                                               /*[out]*/ DWORD  *pcchResult    ,
                                               /*[in] */ DWORD   dwReserved    )
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::CombineUrl");

    HRESULT  hr;

	if(MPC::MSITS::IsCHM( pwzRelativeUrl ))
	{
		MPC::wstring strUrlModified;

		NormalizeUrl( pwzRelativeUrl, strUrlModified, /*fReverse*/false );

		if(strUrlModified.size() > cchResult-1)
		{
			hr = S_FALSE;
		}
		else
		{
			wcscpy( pwzResult, strUrlModified.c_str() );

			hr = S_OK;
		}

		*pcchResult = strUrlModified.size()+1;
	}
	else
	{
		hr = m_realInfo->CombineUrl( pwzBaseUrl    ,
									 pwzRelativeUrl,
									 dwCombineFlags,
									 pwzResult     ,
									 cchResult     ,
									 pcchResult    ,
									 dwReserved    );
	}

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHWrapProtocolInfo::CompareUrl( /*[in]*/ LPCWSTR pwzUrl1        ,
                                               /*[in]*/ LPCWSTR pwzUrl2        ,
                                               /*[in]*/ DWORD   dwCompareFlags )
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::CompareUrl");

    HRESULT hr;

    hr = m_realInfo->CompareUrl( pwzUrl1        ,
                                 pwzUrl2        ,
                                 dwCompareFlags );

    __HCP_FUNC_EXIT(hr);
}


STDMETHODIMP CPCHWrapProtocolInfo::ParseUrl( /*[in] */ LPCWSTR      pwzUrl      ,
                                             /*[in] */ PARSEACTION  parseAction ,
                                             /*[in] */ DWORD        dwParseFlags,
                                             /*[out]*/ LPWSTR       pwzResult   ,
                                             /*[in] */ DWORD        cchResult   ,
                                             /*[out]*/ DWORD       *pcchResult  ,
                                             /*[in] */ DWORD        dwReserved  )
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::ParseUrl");

    HRESULT      hr;
    MPC::wstring strUrlModified;


    if(parseAction == PARSE_CANONICALIZE ||
       parseAction == PARSE_SECURITY_URL  )
    {
		NormalizeUrl( pwzUrl, strUrlModified, /*fReverse*/false );

		pwzUrl = strUrlModified.c_str();
    }

    hr = m_realInfo->ParseUrl( pwzUrl      ,
                               parseAction ,
                               dwParseFlags,
                               pwzResult   ,
                               cchResult   ,
                               pcchResult  ,
                               dwReserved  );

	//
	// The MS-ITS: handler returns E_OUTOFMEMORY instead of S_FALSE on a "buffer too small" situation...
	//
	if(parseAction == PARSE_SECURITY_URL && hr == E_OUTOFMEMORY) hr = S_FALSE;
	
	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHWrapProtocolInfo::QueryInfo( /*[in] */ LPCWSTR      pwzUrl      ,
                                              /*[in] */ QUERYOPTION  QueryOption ,
                                              /*[in] */ DWORD        dwQueryFlags,
                                              /*[out]*/ LPVOID       pBuffer     ,
                                              /*[in] */ DWORD        cbBuffer    ,
                                              /*[out]*/ DWORD       *pcbBuf      ,
                                              /*[in] */ DWORD        dwReserved  )
{
    __HCP_FUNC_ENTRY("CPCHWrapProtocolInfo::QueryInfo");

    HRESULT hr;

    hr = m_realInfo->QueryInfo( pwzUrl      ,
                                QueryOption ,
                                dwQueryFlags,
                                pBuffer     ,
                                cbBuffer    ,
                                pcbBuf      ,
                                dwReserved  );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHWrapProtocolInfo::CreateInstance( /*[in] */ LPUNKNOWN  pUnkOuter ,
                                                   /*[in] */ REFIID     riid      ,
                                                   /*[out]*/ void*     *ppvObj    )
{
    HRESULT hr = E_POINTER;

    if(ppvObj)
    {
        *ppvObj = NULL;

        if(InlineIsEqualGUID( IID_IInternetProtocolInfo, riid ))
        {
            hr = QueryInterface( riid, ppvObj );
        }
        else if(InlineIsEqualGUID( IID_IUnknown             , riid ) ||
                InlineIsEqualGUID( IID_IInternetProtocol    , riid ) ||
                InlineIsEqualGUID( IID_IInternetProtocolRoot, riid )  )
        {
            hr = m_realClass->CreateInstance( pUnkOuter, riid, ppvObj );
        }
    }

    return hr;
}

STDMETHODIMP CPCHWrapProtocolInfo::LockServer( /*[in]*/ BOOL fLock )
{
    return m_realClass->LockServer( fLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\protocolinfo.cpp ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    ProtocolInfo.cpp

Abstract:
    This file contains the implementation of the CHCPProtocolInfo class.

Revision History:
    Davide Massarenti   (Dmassare)  07/05/99
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

#define CR          L'\r'
#define LF          L'\n'
#define TAB         L'\t'
#define SPC         L' '
#define SLASH       L'/'
#define WHACK       L'\\'
#define QUERY       L'?'
#define POUND       L'#'
#define SEMICOLON   L';'
#define COLON       L':'
#define BAR         L'|'
#define DOT         L'.'


static const WCHAR l_szScheme   [] = L"://";
static const WCHAR l_szProtocol [] = L"hcp://";
static const WCHAR l_szCHM      [] = L".chm";
static const WCHAR l_szCHM_end  [] = L".chm::";

/////////////////////////////////////////////////////////////////////////////

#define PU_FALLBACK   (0x01)
#define PU_DIRECT     (0x02)
#define PU_REDIRECTED (0x04)
#define PU_PREPEND    (0x08)

/////////////////////////////////////////////////////////////////////////////

CHCPProtocolInfo::CHCPProtocolInfo()
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::CHCPProtocolInfo");
}

CHCPProtocolInfo::~CHCPProtocolInfo()
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::~CHCPProtocolInfo");
}

/////////////////////////////////////////////////////////////////////////////

bool CHCPProtocolInfo::LookForHCP( LPCWSTR  pwzUrl      ,
								   bool&    fRedirect   ,
								   LPCWSTR& pwzRedirect )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::LookForHCP");

    bool    fRes = false;
    LPCWSTR pwzPosMarker;
    LPCWSTR pwzPosQuery;


    fRedirect   = false;
    pwzRedirect = NULL;

    pwzPosMarker = wcsstr( pwzUrl, l_szProtocol );
    if(pwzPosMarker)
    {
        fRes   = true;
        pwzUrl = pwzPosMarker + MAXSTRLEN( l_szProtocol );

        pwzPosMarker = wcschr( pwzUrl, COLON );
        pwzPosQuery  = wcschr( pwzUrl, QUERY );

        if(pwzPosMarker) // Found a colon, possible redirection.
        {
			if(pwzPosQuery == NULL         ||
			   pwzPosQuery >  pwzPosMarker  ) // Make sure the colon is not part of a query string.
			{
				pwzRedirect = pwzUrl;
				fRedirect   = true;
			}
        }
    }


	__HCP_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////

static inline bool IsSeparator( LPCWSTR p )
{
    return (p[0] == SLASH || p[0] == WHACK );
}

static inline BOOL IsDot( LPCWSTR p ) // if p == "." return TRUE
{
    return (p[0] == DOT && (!p[1] || IsSeparator( &p[1] )));
}

static inline BOOL IsDotDot(LPCWSTR p)  // if p == ".." return TRUE
{
    return (p[0] == DOT && p[1] == DOT && (!p[2] || IsSeparator( &p[2] )));
}

static void Safe_Cut( LPWSTR  pszStart   ,
					  LPWSTR  pszCurrent ,
					  LPWSTR  pszSlash   ,
					  DWORD & cchLength  )
{
	DWORD cchBytesToMove = cchLength - (pszSlash - pszStart);
	DWORD cchLengthOfCut =              pszSlash - pszCurrent;

	::MoveMemory( pszCurrent, pszSlash, cchBytesToMove * sizeof( WCHAR ) ); pszCurrent[cchBytesToMove] = 0;

	cchLength -= cchLengthOfCut;
}

static HRESULT Safe_UrlCanonicalizeW( LPCWSTR pszUrl            , 
									  LPWSTR  pszCanonicalized  , 
									  LPDWORD pcchCanonicalized , 
									  DWORD   dwFlags           )
{
	HRESULT hr;
	DWORD   cchLength = *pcchCanonicalized;

	hr = UrlCanonicalizeW( pszUrl,  pszCanonicalized, &cchLength, dwFlags );

	if((dwFlags & URL_DONT_SIMPLIFY) == 0)
	{
		LPWSTR pszLast    = NULL;
		LPWSTR pszCurrent = pszCanonicalized;

		while(pszCurrent[0])
		{
			LPWSTR pszSlash;

			//
			// Make 'pszSlash' point to the characted AFTER the next slash or to the end of the string.
			//
			pszSlash = wcschr( pszCurrent, SLASH );
			if(pszSlash)
			{
				pszSlash++;
			}
			else
			{
				pszSlash = pszCurrent + wcslen( pszCurrent );
			}

			if(IsDot( pszCurrent ))
			{
				Safe_Cut( pszCanonicalized, pszCurrent, pszSlash, cchLength );
				continue;
			}

			if(IsDotDot( pszCurrent ))
			{
				Safe_Cut( pszCanonicalized, pszCurrent, pszSlash, cchLength );

				if(pszLast)
				{
					Safe_Cut( pszCanonicalized, pszLast, pszCurrent, cchLength );
					pszCurrent = pszLast;
				}

				continue;
			}

			pszLast    = pszCurrent;
			pszCurrent = pszSlash;
		}
	}

	*pcchCanonicalized = cchLength;

	return hr;
}


static DWORD AppendString( LPWSTR& pwzResult      ,
						   DWORD&  cchResult      ,
						   LPCWSTR pwzString      ,
						   DWORD   dwLen     = -1 )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::AppendString");

	DWORD dwOffset = dwLen != -1 ? dwLen : wcslen( pwzString );

	if(pwzResult)
	{
		int len;

		pwzResult[cchResult-1] = 0;

		wcsncpy( pwzResult, pwzString, min( dwLen, cchResult-1 ) );

		len = wcslen( pwzResult );

		pwzResult += len;
		cchResult -= len;
	}


	__HCP_FUNC_EXIT(dwOffset);
}


STDMETHODIMP CHCPProtocolInfo::CombineUrl( LPCWSTR pwzBaseUrl    ,
										   LPCWSTR pwzRelativeUrl,
										   DWORD   dwCombineFlags,
										   LPWSTR  pwzResult     ,
										   DWORD   cchResult     ,
										   DWORD  *pcchResult    ,
										   DWORD   dwReserved    )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::CombineUrl");

    HRESULT hr;
    bool    fRedirect;
    LPCWSTR pwzRedirect;
    DWORD   dwAvailable = cchResult;
    DWORD   dwOffset    = 0;


	*pcchResult = 0;

    //
    // Don't process redirection if the second url is absolute.
    //
    if(wcsstr( pwzRelativeUrl, l_szScheme ) == NULL &&
       wcschr( pwzRelativeUrl, COLON 	  ) == NULL  )
    {
        if(LookForHCP( pwzBaseUrl, fRedirect, pwzRedirect ))
        {
            if(fRedirect)
            {
                //
                // Prepend "HCP://".
                //
                dwOffset = AppendString( pwzResult, cchResult, l_szProtocol );

                pwzBaseUrl = pwzRedirect;
            }
        }
	}

	*pcchResult = cchResult;

	//
	// Special case to handle combination for URL referring to MSITS protocol (InternetCombineUrlW doesn't do it for us...)
	//
	if(MPC::MSITS::IsCHM( pwzBaseUrl ))
	{
		LPCWSTR szEnd = wcsstr( pwzBaseUrl, l_szCHM_end );
		if(szEnd)
		{
			szEnd += MAXSTRLEN( l_szCHM_end );

			dwOffset += AppendString( pwzResult, cchResult, pwzBaseUrl, szEnd - pwzBaseUrl );

			pwzBaseUrl = szEnd;
		}
	}

	if(::InternetCombineUrlW( pwzBaseUrl, pwzRelativeUrl, pwzResult, pcchResult, dwCombineFlags ) == FALSE)
	{
		DWORD dwErr = ::GetLastError();

		__MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
	}

	*pcchResult += dwOffset;
	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(hr == S_OK)
    {
		hr = (*pcchResult > dwAvailable) ? S_FALSE : S_OK;
    }

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocolInfo::CompareUrl( LPCWSTR pwzUrl1        ,
										   LPCWSTR pwzUrl2        ,
										   DWORD   dwCompareFlags )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::CompareUrl");

	__HCP_FUNC_EXIT(E_NOTIMPL);
}


STDMETHODIMP CHCPProtocolInfo::ParseUrl( LPCWSTR      pwzUrl      ,
										 PARSEACTION  parseAction ,
										 DWORD        dwParseFlags,
										 LPWSTR       pwzResult   ,
										 DWORD        cchResult   ,
										 DWORD       *pcchResult  ,
										 DWORD        dwReserved  )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::ParseUrl");

    HRESULT  hr;
    bool     fHCP;
    bool     fRedirect;
    LPCWSTR  pwzRedirect;
    DWORD    dwAvailable = cchResult;
    DWORD    dwOffset 	 = 0;
    DWORD    dwAction 	 = PU_FALLBACK;


	*pcchResult = 0;
	if(pwzResult)
	{
		*pwzResult = 0;
	}


    switch(parseAction)
    {
    case PARSE_CANONICALIZE   : dwAction = PU_DIRECT   | PU_REDIRECTED | PU_PREPEND; break;
    case PARSE_FRIENDLY       : dwAction = PU_FALLBACK                             ; break;
    case PARSE_SECURITY_URL   : dwAction = PU_DIRECT   | PU_REDIRECTED             ; break;
    case PARSE_ROOTDOCUMENT   : dwAction = PU_DIRECT   | PU_REDIRECTED | PU_PREPEND; break;
    case PARSE_DOCUMENT       : dwAction = PU_DIRECT   | PU_REDIRECTED | PU_PREPEND; break;
    case PARSE_ANCHOR         : dwAction = PU_DIRECT                               ; break;
    case PARSE_ENCODE         : dwAction = PU_FALLBACK                             ; break;
    case PARSE_DECODE         : dwAction = PU_FALLBACK                             ; break;
    case PARSE_PATH_FROM_URL  : dwAction = PU_FALLBACK                             ; break;
    case PARSE_URL_FROM_PATH  : dwAction = PU_FALLBACK                             ; break;
    case PARSE_MIME           : dwAction = PU_FALLBACK                             ; break;
    case PARSE_SERVER         : dwAction = PU_DIRECT   | PU_REDIRECTED             ; break;
    case PARSE_SCHEMA         : dwAction = PU_DIRECT                               ; break;
    case PARSE_SITE           : dwAction = PU_FALLBACK                             ; break;
    case PARSE_DOMAIN         : dwAction = PU_DIRECT   | PU_REDIRECTED             ; break;
    case PARSE_LOCATION       : dwAction = PU_DIRECT                               ; break;
    case PARSE_SECURITY_DOMAIN: dwAction = PU_FALLBACK                             ; break;
//  case PARSE_ESCAPE         : dwAction = PU_FALLBACK                             ; break;
//  case PARSE_UNESCAPE       : dwAction = PU_FALLBACK                             ; break;
    }

    ///////

    fHCP = LookForHCP( pwzUrl, fRedirect, pwzRedirect );
    if(fHCP == false)
    {
		//
		// If it's not a HCP url, let the system use the default action (this should never happen anyway...).
		//
        dwAction = PU_FALLBACK;
    }

    if(dwAction & PU_FALLBACK)
    {
		__MPC_SET_ERROR_AND_EXIT(hr, INET_E_DEFAULT_ACTION);
    }

    ///////

	if(fRedirect == false)
	{
		dwAction &= ~PU_REDIRECTED;
		dwAction &= ~PU_PREPEND;
	}

    if(dwAction & PU_REDIRECTED)
    {
        //
        // Use the real URL part.
        //
        pwzUrl = pwzRedirect;
    }

    if(dwAction & PU_PREPEND)
    {
        //
        // Prepend "HCP://".
        //
		dwOffset = AppendString( pwzResult, cchResult, l_szProtocol );
    }

    if(dwAction & PU_DIRECT)
	{
		switch(parseAction)
		{
		case PARSE_SECURITY_URL:
			//
			// Look for the end of the hostname, skipping the eventual protocol part.
			// If we can't find the end of the hostname, copy everything.
			//
			{
				LPWSTR pwzScheme = wcsstr( pwzUrl,                            l_szScheme                   );
				LPWSTR pwzEnd    = wcschr( pwzScheme ? pwzScheme + MAXSTRLEN( l_szScheme ) : pwzUrl, SLASH );

				if(pwzEnd)
				{
					dwOffset = AppendString( pwzResult, cchResult, pwzUrl, (pwzEnd-pwzUrl) );
				}
				else
				{
					dwOffset = AppendString( pwzResult, cchResult, pwzUrl );
				}
			}
			hr = S_OK;
			break;

		case PARSE_CANONICALIZE:
			*pcchResult = cchResult;
            hr = Safe_UrlCanonicalizeW( pwzUrl, pwzResult, pcchResult, dwParseFlags );
			break;

		case PARSE_ROOTDOCUMENT:
			hr = INET_E_DEFAULT_ACTION;
			break;

		case PARSE_DOCUMENT:
			hr = INET_E_DEFAULT_ACTION;
			break;

		case PARSE_ANCHOR:
			hr = INET_E_DEFAULT_ACTION;
			break;

		case PARSE_SERVER:
			hr = INET_E_DEFAULT_ACTION;
			break;

		case PARSE_SCHEMA:
            *pcchResult = cchResult;
            hr = UrlGetPartW( pwzUrl, pwzResult, pcchResult, URL_PART_SCHEME, 0 );
			break;

		case PARSE_DOMAIN:
            *pcchResult = cchResult;
            hr = UrlGetPartW( pwzUrl, pwzResult, pcchResult, URL_PART_HOSTNAME, 0 );   
			break;

		case PARSE_LOCATION:
			hr = INET_E_DEFAULT_ACTION;
			break;
		}
	}


	__HCP_FUNC_CLEANUP;

	if(hr == S_OK)
	{
		*pcchResult += dwOffset;

		hr = (*pcchResult > dwAvailable) ? S_FALSE : S_OK;
	}

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CHCPProtocolInfo::QueryInfo( LPCWSTR      pwzUrl      ,
										  QUERYOPTION  QueryOption ,
										  DWORD        dwQueryFlags,
										  LPVOID       pBuffer     ,
										  DWORD        cbBuffer    ,
										  DWORD       *pcbBuf      ,
										  DWORD        dwReserved  )
{
	__HCP_FUNC_ENTRY("CHCPProtocolInfo::QueryInfo");

    HRESULT hr = INET_E_QUERYOPTION_UNKNOWN;
    bool    fHCP;
    bool    fRedirect;
    LPCWSTR pwzRedirect;


    fHCP = LookForHCP( pwzUrl, fRedirect, pwzRedirect );
	if(fHCP)
	{
		if(fRedirect)
		{
			hr = CoInternetQueryInfo( pwzRedirect, QueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved );
			if(hr == E_FAIL)
			{
				__MPC_SET_ERROR_AND_EXIT(hr, INET_E_QUERYOPTION_UNKNOWN);
			}
		}
		else
		{
			//
			// Implement HCP logic.
			//
		}
	}

	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHCPProtocolInfo::CreateInstance( /*[in] */ LPUNKNOWN  pUnkOuter ,
											   /*[in] */ REFIID     riid      ,
											   /*[out]*/ void*     *ppvObj    )
{
	HRESULT hr = E_POINTER;

	if(ppvObj)
	{
		*ppvObj = NULL;

		if(InlineIsEqualGUID( IID_IInternetProtocolInfo, riid ))
		{
			hr = QueryInterface( riid, ppvObj );
		}
		else if(InlineIsEqualGUID( IID_IUnknown             , riid ) ||
		        InlineIsEqualGUID( IID_IInternetProtocol    , riid ) ||
		        InlineIsEqualGUID( IID_IInternetProtocolRoot, riid )  )
		{
			CComPtr<IUnknown> obj;

			if(SUCCEEDED(hr = CHCPProtocol::CreateInstance( pUnkOuter, &obj )))
			{
				hr = obj->QueryInterface( riid, ppvObj );
			}
		}
	}

	return hr;
}

STDMETHODIMP CHCPProtocolInfo::LockServer( /*[in]*/ BOOL fLock )
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\printing\cprint.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    CPrint.cpp

Abstract:
    Class that wraps the multi-topic printing process

Revision History:
    Davide Massarenti   (Dmassare)  05/07/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static const DWORD c_MaxWait = 30000; // Max time to wait for temp file to change, before aborting.

////////////////////////////////////////////////////////////////////////////////

static DWORD WaitMultipleObjectsWithMessageLoop( HANDLE* rgEvents, DWORD dwNum )
{
	DWORD dwRet;
	MSG   msg;

	while(1)
	{
		dwRet = ::MsgWaitForMultipleObjects( dwNum, rgEvents, FALSE, INFINITE, QS_ALLINPUT );

		if(/*dwRet >= WAIT_OBJECT_0 &&*/
	         dwRet  < WAIT_OBJECT_0 + dwNum)
		{
			return dwRet - WAIT_OBJECT_0; // An event was signaled.
		}

		if(dwRet >= WAIT_ABANDONED_0         &&
		   dwRet  < WAIT_ABANDONED_0 + dwNum  )
		{
			return dwRet - WAIT_ABANDONED_0; // An event was abandoned.
		}

		if(dwRet != WAIT_OBJECT_0 + dwNum)
		{
			return -1;
		}

		// There is one or more window message available. Dispatch them
		while(PeekMessage( &msg, NULL, NULL, NULL, PM_REMOVE ))
		{
			TranslateMessage( &msg );
			DispatchMessage ( &msg );

			dwRet = ::WaitForMultipleObjects( dwNum, rgEvents, FALSE, 0 );

			if(/*dwRet >= WAIT_OBJECT_0 &&*/
		         dwRet  < WAIT_OBJECT_0 + dwNum)
			{
				return dwRet - WAIT_OBJECT_0; // An event was signaled.
			}

			if(dwRet >= WAIT_ABANDONED_0         &&
			   dwRet  < WAIT_ABANDONED_0 + dwNum  )
			{
				return dwRet - WAIT_ABANDONED_0; // An event was abandoned.
			}
		}
	}

	return -1;
}

////////////////////////////////////////////////////////////////////////////////

Printing::Print::Print()
{
    m_pCallback   	   = NULL;  // Notification*              m_pCallback;
                  				//
                  				// MPC::WStringList           m_lstURLs;
                  				//
    m_hwnd        	   = NULL;  // HWND                       m_hwnd;
                  				// WindowHandle               m_wnd;
                  				// CComPtr<IWebBrowser2>      m_spWebBrowser2;
                  				//
                                // CComPtr<CDispatchSink>     m_spObjDisp;
    m_eventDocComplete = NULL;  // HANDLE                     m_eventDocComplete;
    m_eventAbortPrint  = NULL;  // HANDLE                     m_eventAbortPrint;
                  				//
                  				// CComPtr<IUnknown>          m_spUnkControl;
    m_dwCookie    	   = 0;     // DWORD                      m_dwCookie;
                  				// CComPtr<IOleCommandTarget> m_spOleCmdTarg;
                  				// MPC::wstring               m_szPrintDir;
                  				// MPC::wstring               m_szPrintFile;
                  				//
	                            // CComPtr<IStream>           m_streamPrintData;
}

Printing::Print::~Print()
{
    Terminate();
}

////////////////////////////////////////

HRESULT Printing::Print::Initialize( /*[in]*/ HWND hwnd )
{
	__HCP_FUNC_ENTRY( "Printing::Print::Initialize" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, Terminate());

	m_hwnd = hwnd;

	__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_eventDocComplete = ::CreateEvent( NULL, FALSE, FALSE, NULL )));
	__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_eventAbortPrint  = ::CreateEvent( NULL, FALSE, FALSE, NULL )));

	m_wnd.SetAbortEvent( m_eventAbortPrint );

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

HRESULT Printing::Print::Terminate()
{
    if(m_spObjDisp)
    {
        if(m_dwCookie != 0)
        {
            ::AtlUnadvise( m_spUnkControl, DIID_DWebBrowserEvents2, m_dwCookie );
        }

        m_spObjDisp.Release();
    }

    m_spWebBrowser2.Release();
    m_spUnkControl .Release();
    m_spOleCmdTarg .Release();

    if(m_wnd.m_hWnd)
    {
        m_wnd.DestroyWindow();
    }

	//
	// Delete temp files.
	//
    m_streamPrintData.Release();

    if(m_szPrintFile.size())
    {
		(void)MPC::DeleteFile( m_szPrintFile, true, true );

        m_szPrintFile.erase();
    }

    if(m_szPrintDir.size())
    {
        if(!::RemoveDirectoryW( m_szPrintDir.c_str() ))
        {
            (void)::MoveFileExW( m_szPrintDir.c_str(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT );
        }

        m_szPrintDir.erase();
    }

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Printing::Print::AddUrl( /*[in]*/ LPCWSTR szUrl )
{
    m_lstURLs.push_back( szUrl );

    return S_OK;
}

HRESULT Printing::Print::PrintAll( /*[in]*/ Notification* pCallback )
{
    __HCP_FUNC_ENTRY( "Printing::Print::PrintAll" );

    HRESULT hr;
    int     iLen = m_lstURLs.size();
    int     iPos = 0;

    m_pCallback = pCallback;

    if(iLen > 0)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, PreparePrintFileLoc());

        //
        // Make sure the host window knows what's going on.
        //
        m_wnd.SetMultiTopic   ( true                  );
        m_wnd.SetPrintFileName( m_szPrintFile.c_str() );

        for(MPC::WStringIter it = m_lstURLs.begin(); it != m_lstURLs.end(); it++, iPos++)
        {
            if(m_pCallback)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, m_pCallback->Progress( it->c_str(), iPos, iLen ));
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, PrintSingleURL( *it ));
        }

        //
        // ok, send it all to the printer...
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, RawDataToPrinter());

        if(m_pCallback)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_pCallback->Progress( NULL, iLen, iLen ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT Printing::Print::PrintSingleURL( /*[in]*/ MPC::wstring& szUrl )
{
    __HCP_FUNC_ENTRY( "Printing::Print::PrintSingleURL" );

    HRESULT hr;

    //
    // Navigate to the url, creating the control if necessary
    //
    if(!m_wnd.m_hWnd)
    {
        RECT  rect     = { 0, 0, 800, 600 };
		DWORD dwStyles = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		if(m_hwnd) dwStyles |= WS_CHILD;

        if(!m_wnd.Create( m_hwnd, rect, szUrl.c_str(), dwStyles, WS_EX_CLIENTEDGE ))
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }

        m_wnd.ShowWindow( SW_SHOW );

        __MPC_EXIT_IF_METHOD_FAILS(hr, HookUpEventSink());
    }
    else
    {
        if(!m_spWebBrowser2)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_spUnkControl->QueryInterface( &m_spWebBrowser2 ));
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_spWebBrowser2->Navigate( CComBSTR( szUrl.c_str() ), NULL, NULL, NULL, NULL ));
    }

    //
    // Wait for document to be loaded
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, WaitForDocComplete());

	//
	// If the URL don't match, it means the URL doesn't exist...
	//
	if(MPC::StrICmp( szUrl, m_spObjDisp->GetCurrentURL() ))
	{
		__MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
	}

    __MPC_EXIT_IF_METHOD_FAILS(hr, DoPrint());

	//
	// Since we now do a synchronous print operation, there's no need for snooping at the spool directory state.
	//
    //__MPC_EXIT_IF_METHOD_FAILS(hr, WaitForPrintComplete());

    __MPC_EXIT_IF_METHOD_FAILS(hr, UpdatePrintBuffer());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(m_wnd.GetAbortState() == true)
	{
		hr = E_ABORT;
	}

    __HCP_FUNC_EXIT(hr);
}


HRESULT Printing::Print::HookUpEventSink()
{
    __HCP_FUNC_ENTRY( "Printing::Print::HookUpEventSink" );

    HRESULT hr;


    m_spUnkControl.Release();


    if(!m_wnd.m_hWnd)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    //
    // Hook up the connection point
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_spObjDisp ));

	m_spObjDisp->SetNotificationEvent( m_eventDocComplete );

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_wnd.QueryControl( &m_spUnkControl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::AtlAdvise( m_spUnkControl, m_spObjDisp, DIID_DWebBrowserEvents2, &m_dwCookie ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Printing::Print::WaitForDocComplete()
{
    __HCP_FUNC_ENTRY( "Printing::Print::WaitForDocComplete" );

	HRESULT hr;

	if(MPC::WaitForSingleObject( m_eventDocComplete ) != WAIT_OBJECT_0)
	{
		__MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);

}


HRESULT Printing::Print::WaitForPrintComplete()
{
    __HCP_FUNC_ENTRY( "Printing::Print::WaitForPrintComplete" );

	HRESULT hr;
	HANDLE 	hFileChangeNotify;
	HANDLE 	rgEventsToWait[2];


	__MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (hFileChangeNotify = ::FindFirstChangeNotificationW( m_szPrintDir.c_str(), FALSE, FILE_NOTIFY_CHANGE_SIZE )));

	rgEventsToWait[0] = hFileChangeNotify;
	rgEventsToWait[1] = m_eventAbortPrint;

    for(;;)
    {
		DWORD dwRet;

		dwRet = MPC::WaitForMultipleObjects( 2, rgEventsToWait, c_MaxWait );

		if(dwRet == WAIT_OBJECT_0)
		{
			HANDLE hFile = ::CreateFileW( m_szPrintFile.c_str(), GENERIC_READ, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );

			if(hFile != INVALID_HANDLE_VALUE)
			{
				DWORD dwSize = ::GetFileSize( hFile, NULL );

				::CloseHandle( hFile );

				if(dwSize != 0) break;
			}

			(void)::FindNextChangeNotification(hFileChangeNotify);
		}

		if(dwRet == WAIT_TIMEOUT      ||
		   dwRet == WAIT_OBJECT_0 + 1  )
		{
			__MPC_SET_ERROR_AND_EXIT(hr, E_ABORT);
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(hFileChangeNotify) ::FindCloseChangeNotification( hFileChangeNotify );

	__HCP_FUNC_EXIT(hr);
}

HRESULT Printing::Print::DoPrint()
{
    __HCP_FUNC_ENTRY( "Printing::Print::DoPrint" );

    HRESULT hr;

    // send the command to print
    if(!m_spOleCmdTarg)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, m_wnd.QueryControl( &m_spOleCmdTarg ));
    }

	//
	// Make a synchronous print operation.
	//
	{
		VARIANT vArgIN;

		vArgIN.vt   = VT_I2;
		vArgIN.iVal = PRINT_WAITFORCOMPLETION;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_spOleCmdTarg->Exec( NULL, OLECMDID_PRINT, OLECMDEXECOPT_PROMPTUSER, &vArgIN, NULL ));
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	if(m_wnd.GetAbortState() == true)
	{
		hr = E_ABORT;
	}

    __HCP_FUNC_EXIT(hr);
}

HRESULT Printing::Print::PreparePrintFileLoc()
{
    __HCP_FUNC_ENTRY( "Printing::Print::PreparePrintFileLoc" );

    HRESULT      			 hr;
    MPC::wstring 			 szWritablePath;
    MPC::wstring 			 szPrintData;
    CComPtr<MPC::FileStream> stream;


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetUserWritablePath( m_szPrintDir, HC_ROOT_HELPCTR L"\\Spool" ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( m_szPrintFile, m_szPrintDir.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetTemporaryFileName( szPrintData  , m_szPrintDir.c_str() ));


    //
    // Create a stream for a temporary file.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForReadWrite( szPrintData.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease (                     ));

	m_streamPrintData = stream;
    hr                = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Printing::Print::UpdatePrintBuffer()
{
    __HCP_FUNC_ENTRY( "Printing::Print::UpdatePrintBuffer" );

    HRESULT                  hr;
    CComPtr<MPC::FileStream> stream;


	//
	// Open the single-topic print file and copy it to the multi-topic print file.
	//
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead    ( m_szPrintFile.c_str() ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, stream->DeleteOnRelease(                       ));


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::BaseStream::TransferData( stream, m_streamPrintData ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Printing::Print::RawDataToPrinter()
{
    __HCP_FUNC_ENTRY( "Printing::Print::RawDataToPrinter" );

    HRESULT hr;
    HANDLE  hPrinter = NULL;
    DWORD   dwJob    = 0;


	//
	// Reset stream to beginning.
	//
	{
		LARGE_INTEGER li;

		li.LowPart  = 0;
		li.HighPart = 0;

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_streamPrintData->Seek( li, STREAM_SEEK_SET, NULL ));
	}


	//
	// Open the printer, create a job and copy all the data into it.
	//
	{
		DOC_INFO_1W  docinfo;
		BYTE  		 rgBuf[1024];
		ULONG 		 dwRead;
		DWORD 		 dwWritten;
		MPC::wstring strTitle; MPC::LocalizeString( IDS_HELPCTR_PRINT_TITLE, strTitle );

		// Fill in the structure with info about this "document."
		docinfo.pDocName    = (LPWSTR)strTitle.c_str();;
		docinfo.pOutputFile = NULL;
		docinfo.pDatatype   = L"RAW";


		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::OpenPrinterW( m_wnd.GetPrinterName(), &hPrinter, NULL ));


		// Inform the spooler the document is beginning.
		__MPC_EXIT_IF_CALL_RETURNS_ZERO(hr, (dwJob = ::StartDocPrinterW( hPrinter, 1, (LPBYTE)&docinfo )));

		__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::StartPagePrinter( hPrinter ));

		while(1)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, m_streamPrintData->Read( rgBuf, sizeof(rgBuf), &dwRead ));
			if(hr == S_FALSE || dwRead == 0) // End of File.
			{
				break;
			}

			__MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WritePrinter( hPrinter, rgBuf, dwRead, &dwWritten ));
		}
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(hPrinter)
	{
		if(dwJob)
		{
			// End the page.
			if(!::EndPagePrinter( hPrinter ))
			{
				if(SUCCEEDED(hr))
				{
					hr = HRESULT_FROM_WIN32(::GetLastError());
				}
			}

			// Inform the spooler that the document is ending.
			if(!::EndDocPrinter( hPrinter ))
			{
				if(SUCCEEDED(hr))
				{
					hr = HRESULT_FROM_WIN32(::GetLastError());
				}
			}
		}

        // Tidy up the printer handle.
        if(!::ClosePrinter( hPrinter ))
        {
			if(SUCCEEDED(hr))
			{
				hr = HRESULT_FROM_WIN32(::GetLastError());
			}
        }
    }

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A479F957_CC9E_11D0_A220_000000000000__INCLUDED_)
#define AFX_STDAFX_H__A479F957_CC9E_11D0_A220_000000000000__INCLUDED_

#include <module.h>

#include <atlcom.h>
#include <atlctl.h>

#include <comdef.h>

#include <wininet.h>

#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_logging.h>
#include <MPC_COM.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

#include <NameSpace_Impl.h>

#include <resource.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A479F957_CC9E_11D0_A220_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\namespace\styledefinition.cpp ===
/*
** Copyright (c) 2001 Microsoft Corporation
*/

#include <stdafx.h>

#include <UxTheme.h>

#include <MPC_HTML.h>

// CURSOR:     <text>
// MARGIN:     <text>
// FONT:       <name> <size> <weight>
// COLOR:      <color>
// BACKGROUND: <color>
// BORDER:     <color>
// GRADIENT:   <color1> <color2> <H or V> <RTZ or not>
// HYPERLINK:  <color1> <color2>

struct Environment;

struct Font
{
    LPCSTR m_szName;
    LPCSTR m_szSize;
    LPCSTR m_szStyle;
    LPCSTR m_szWeight;

    void Generate( /*[in]*/ Environment& env ) const;

    HRESULT LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn );
    void    Release    (                                                      );

#ifdef DEBUG
    HRESULT GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const;
#endif
};

struct Color
{
    LPCSTR m_szDef1;
    LPCSTR m_szDef2;
    int    m_iRatio;

    void Generate( /*[in]*/ Environment& env, /*[in]*/ LPCSTR szStyle ) const;

    HRESULT LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn );
    void    Release    (                                                      );

#ifdef DEBUG
    HRESULT GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const;
#endif
};

struct Gradient
{
    Color m_start;
    Color m_end;
    bool  m_fHorizontal;
    bool  m_fReturnToZero;

    void Generate( /*[in]*/ Environment& env ) const;

    HRESULT LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn );
    void    Release    (                                                      );

#ifdef DEBUG
    HRESULT GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const;
#endif
};

struct Hyperlink
{
    Color m_colorNormal;
    Color m_colorHover;
    Color m_colorActive;
    bool  m_fUnderlineAlways;

    enum PseudoClass
    {
        PC_NORMAL,
        PC_HOVER ,
        PC_ACTIVE,
    };

    void Generate( /*[in]*/ Environment& env, /*[in]*/ PseudoClass cls ) const;

    HRESULT LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn );
    void    Release    (                                                      );

#ifdef DEBUG
    HRESULT GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const;
#endif
};


struct ElementName
{
    LPCSTR m_szName;
    LPCSTR m_szComment;
};

struct ElementFONT
{
    const ElementName* m_name;
    const Font*        m_font;
};

struct ElementCOLOR
{
    const ElementName* m_name;
    const Color*       m_color;
};

struct ElementBACKGROUND
{
    const ElementName* m_name;
    const Color*       m_color;
};

struct ElementBORDER
{
    const ElementName* m_name;
    const Color*       m_color;
};

struct ElementGRADIENT
{
    const ElementName* m_name;
    const Gradient*    m_gradient;
};

struct ElementHYPERLINK
{
    const ElementName* m_name;
    const Hyperlink*   m_hyperlink;
};

struct StyleSheet
{
    LPCWSTR                  m_szName;

    const ElementFONT*       m_fonts      ; int m_iFonts;
    const ElementCOLOR*      m_colors     ; int m_iColors;
    const ElementBACKGROUND* m_backgrounds; int m_iBackgrounds;
    const ElementBORDER*     m_borders    ; int m_iBorders;
    const ElementGRADIENT*   m_gradients  ; int m_iGradients;
    const ElementHYPERLINK*  m_hyperlinks ; int m_iHyperlinks;
};

struct Environment
{
    MPC::string&      m_strOutput;
    NONCLIENTMETRICSA m_ncm;
    int               m_iPixel;

    MPC::XmlUtil      m_xmlOEM;
    bool              m_fOEM;
    bool              m_fCustomizing;

    ////////////////////

    Environment( /*[in]*/ MPC::string& strOutput );

    HRESULT Init();

    bool IsCustomizationPresent( /*[in]*/ const ElementName* name );

    void OpenClass ( /*[in]*/ const ElementName* name, /*[in]*/ LPCSTR szPrefix = NULL, /*[in]*/ LPCSTR szSuffix = NULL );
    void CloseClass(                                                                                                    );

    void GenerateClass( /*[in]*/ const ElementFONT&       ptr );
    void GenerateClass( /*[in]*/ const ElementCOLOR&      ptr );
    void GenerateClass( /*[in]*/ const ElementBACKGROUND& ptr );
    void GenerateClass( /*[in]*/ const ElementBORDER&     ptr );
    void GenerateClass( /*[in]*/ const ElementGRADIENT&   ptr );
    void GenerateClass( /*[in]*/ const ElementHYPERLINK&  ptr );

    void AddAttribute( /*[in]*/ LPCSTR szName, /*[in]*/ LPCSTR szValue );

    HRESULT GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ CComVariant& v );
    HRESULT GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ LPCSTR&      v );
    HRESULT GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ int&         v );
    HRESULT GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ bool&        v );

    HRESULT GenerateStyleSheet( /*[in]*/ const StyleSheet& def );

#ifdef DEBUG
    HRESULT CreateNode( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ const ElementName* elem, /*[in]*/ LPCWSTR szType, /*[in/out]*/ CComPtr<IXMLDOMNode>& xdn );

    HRESULT CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ LPCSTR       szValue );
    HRESULT CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ bool          fValue );
    HRESULT CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ int           iValue );
    HRESULT CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ CComVariant&  vValue );

    HRESULT GenerateStyleSheetXML( /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ const StyleSheet& def );

    HRESULT DumpStyle();
    HRESULT DumpStyleXML();
#endif
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

ElementName NAME_sys_bottompane_bgcolor        = { ".sys-bottompane-bgcolor"       , "primary fill color"                                                                 };
ElementName NAME_sys_bottompane_color_border   = { ".sys-bottompane-color-border"  , "outline color"                                                                      };
ElementName NAME_sys_bottompane_header_bgcolor = { ".sys-bottompane-header-bgcolor", "left to right gradient colors in the header"                                        };
ElementName NAME_sys_bottompane_header_color   = { ".sys-bottompane-header-color"  , "text color in bottom nav pane"                                                      };
ElementName NAME_sys_color_body                = { ".sys-color-body"               , "color of normal text (usually black)"                                               };
ElementName NAME_sys_color_body_alert          = { ".sys-color-body-alert"         , "used when the body text color needs to indicate an alert (usually red)"             };
ElementName NAME_sys_color_body_helpee         = { ".sys-color-body-helpee"        , "color of normal text (usually dark grey)"                                           };
ElementName NAME_sys_color_body_helper         = { ".sys-color-body-helper"        , "color of normal text (usually dark blue)"                                           };
ElementName NAME_sys_color_body_ok             = { ".sys-color-body-ok"            , "used when the body text color needs to indicate status ok (usually green)"          };
ElementName NAME_sys_color_body_sec            = { ".sys-color-body-sec"           , "used for text that is gray or demoted, such as secondary descriptive text"          };
ElementName NAME_sys_font_body                 = { ".sys-font-body"                , "used throughout the hsc, primary font that all information uses"                    };
ElementName NAME_sys_font_body_bold            = { ".sys-font-body-bold"           , "bold variant of the body text font"                                                 };
ElementName NAME_sys_font_heading1             = { ".sys-font-heading1"            , "used for the HSC logo in the header, largest font in HSC"                           };
ElementName NAME_sys_font_heading2             = { ".sys-font-heading2"            , "used on splash pages and the homepage"                                              };
ElementName NAME_sys_font_heading3             = { ".sys-font-heading3"            , "used on subsite and centers content pages and search label in header"               };
ElementName NAME_sys_font_heading4             = { ".sys-font-heading4"            , "used on splash pages as smaller message text"                                       };
ElementName NAME_sys_header_bgcolor            = { ".sys-header-bgcolor"           , "used to flat fill the header area with a solid color"                               };
ElementName NAME_sys_header_color              = { ".sys-header-color"             , "used for any text that is not a link and is meant to be demoted"                    };
ElementName NAME_sys_header_color_logo         = { ".sys-header-color-logo"        , "used for the 'Help and Support Center' logo in the header"                          };
ElementName NAME_sys_header_gradient_H         = { ".sys-header-gradient-H"        , "used to separate tool bar from content area"                                        };
ElementName NAME_sys_header_gradient_V         = { ".sys-header-gradient-V"        , "used to separate left pane from right pane"                                         };
ElementName NAME_sys_background_strong         = { ".sys-background-strong"        , "strong background, doesn't get wiped out by High-Contrast"                          };
ElementName NAME_sys_homepage_bgcolor          = { ".sys-homepage-bgcolor"         , "color fill on the homepage background"                                              };
ElementName NAME_sys_homepage_color            = { ".sys-homepage-color"           , "used for any non-hyperlink text on the homepage"                                    };
ElementName NAME_sys_inlineform_bgcolor1       = { ".sys-inlineform-bgcolor1"      , "alert or modal dialogs in the rhp"                                                  };
ElementName NAME_sys_inlineform_bgcolor2       = { ".sys-inlineform-bgcolor2"      , "forms or neutral tone dialogs in the rhp"                                           };
ElementName NAME_sys_inlineform_bgcolor3       = { ".sys-inlineform-bgcolor3"      , "table header for status in the rhp"                                                 };
ElementName NAME_sys_lhp_bgcolor               = { ".sys-lhp-bgcolor"              , "top to bottom gradient colors in the left hand pane background"                     };
ElementName NAME_sys_lhp_bgcolor_scope         = { ".sys-lhp-bgcolor-scope"        , "color used in the search scope area, just above the navigation panes"               };
ElementName NAME_sys_lhp_color                 = { ".sys-lhp-color"                , "any text that is in the lhp, not included in the task panes"                        };
ElementName NAME_sys_link_header               = { ".sys-link-header"              , "the 'set search options' link in the header"                                        };
ElementName NAME_sys_link_homepage             = { ".sys-link-homepage"            , "hyperlinks on the homepage, where the background is not white (Luna=blue)"          };
ElementName NAME_sys_link_normal               = { ".sys-link-normal"              , "links in RHP, normal blue hyperlinks used throughout hsc"                           };
ElementName NAME_sys_link_splash               = { ".sys-link-splash"              , "links in splash pages"                                                              };
ElementName NAME_sys_RA_gradient_H             = { ".sys-RA-gradient-H"            , NULL                                                                                 };
ElementName NAME_sys_RA_gradient_V             = { ".sys-RA-gradient-V"            , NULL                                                                                 };
ElementName NAME_sys_rhp_bgcolor               = { ".sys-rhp-bgcolor"              , "color used to fill the background of the content pages in the RHP (normally white)" };
ElementName NAME_sys_rhp_color_title           = { ".sys-rhp-color-title"          , "color used for titles in the content pages in the RHP"                              };
ElementName NAME_sys_rhp_splash_bgcolor        = { ".sys-rhp-splash-bgcolor"       , "color of background of the splash pages in the RHP"                                 };
ElementName NAME_sys_rhp_splash_color          = { ".sys-rhp-splash-color"         , "color of smaller message text on subsite and center splash pages"                   };
ElementName NAME_sys_rhp_splash_color_title    = { ".sys-rhp-splash-color-title"   , "color of text on subsite and center splash pages"                                   };
ElementName NAME_sys_table_cell_bgcolor1       = { ".sys-table-cell-bgcolor1"      , "alternating color 1 for table rows"                                                 };
ElementName NAME_sys_table_cell_bgcolor2       = { ".sys-table-cell-bgcolor2"      , "alternating color 2 for table rows"                                                 };
ElementName NAME_sys_table_cell_bgcolor3       = { ".sys-table-cell-bgcolor3"      , "color for vertical cells in tables and Remote Assistance"                           };
ElementName NAME_sys_table_cell_bgcolor4       = { ".sys-table-cell-bgcolor4"      , "color for empty helper screen in Remote Assistance"                                 };
ElementName NAME_sys_table_cell_bgcolor5       = { ".sys-table-cell-bgcolor5"      , "color for content panes in Remote Assistance (will be removed if no gradient)"      };
ElementName NAME_sys_table_color_border        = { ".sys-table-color-border"       , "color for all table cell outlines"                                                  };
ElementName NAME_sys_table_header_bgcolor1     = { ".sys-table-header-bgcolor1"    , "primary header color for tables of data"                                            };
ElementName NAME_sys_table_header_bgcolor2     = { ".sys-table-header-bgcolor2"    , "secondary header color for tables of data, column header color"                     };
ElementName NAME_sys_toppane_bgcolor           = { ".sys-toppane-bgcolor"          , "primary fill color"                                                                 };
ElementName NAME_sys_toppane_color_border      = { ".sys-toppane-color-border"     , "outline color"                                                                      };
ElementName NAME_sys_toppane_header_bgcolor    = { ".sys-toppane-header-bgcolor"   , "left to right gradient colors in the header"                                        };
ElementName NAME_sys_toppane_header_color      = { ".sys-toppane-header-color"     , "text color in top nav pane"                                                         };
ElementName NAME_sys_toppane_selection         = { ".sys-toppane-selection"        , "color for selected nodes in the pane"                                               };

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace THEME_Luna
{
    static const Font FONT_sys_font_body                     = { "messagebox"            , NULL  , NULL, NULL     };
    static const Font FONT_sys_font_body_bold                = { "messagebox"            , NULL  , NULL, "bold"   };
    static const Font FONT_sys_font_heading1                 = { "Franklin Gothic Medium", "18pt", NULL, "normal" };
    static const Font FONT_sys_font_heading2                 = { "Franklin Gothic Medium", "18pt", NULL, "normal" };
    static const Font FONT_sys_font_heading3                 = { "Franklin Gothic Medium", "14pt", NULL, "normal" };
    static const Font FONT_sys_font_heading4                 = { "Verdana"               , "10pt", NULL, "normal" };

    static const Color COLOR_sys_bottompane_bgcolor          = { "#EDF2FC", NULL, 0 };
    static const Color COLOR_sys_bottompane_color_border     = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_bottompane_header_color     = { "#215DC6", NULL, 0 };
    static const Color COLOR_sys_color_body                  = { "#000000", NULL, 0 };
    static const Color COLOR_sys_color_body_alert            = { "#FF0000", NULL, 0 };
    static const Color COLOR_sys_color_body_helpee           = { "#848E94", NULL, 0 };
    static const Color COLOR_sys_color_body_helper           = { "#0309C0", NULL, 0 };
    static const Color COLOR_sys_color_body_ok               = { "#009900", NULL, 0 };
    static const Color COLOR_sys_color_body_sec              = { "#808080", NULL, 0 };
    static const Color COLOR_sys_header_bgcolor              = { "#003399", NULL, 0 };
    static const Color COLOR_sys_header_color                = { "#D6DFF5", NULL, 0 };
    static const Color COLOR_sys_header_color_logo           = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_homepage_bgcolor            = { "#6375D6", NULL, 0 };
    static const Color COLOR_sys_homepage_color              = { "#D6DFF5", NULL, 0 };
    static const Color COLOR_sys_inlineform_bgcolor1         = { "#FFF7E7", NULL, 0 };
    static const Color COLOR_sys_inlineform_bgcolor2         = { "#D6DFF5", NULL, 0 };
    static const Color COLOR_sys_inlineform_bgcolor3         = { "#1051BD", NULL, 0 };
    static const Color COLOR_sys_lhp_bgcolor_scope           = { "#8CAAE6", NULL, 0 };
    static const Color COLOR_sys_lhp_color                   = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_rhp_bgcolor                 = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_rhp_color_title             = { "#5A7EDC", NULL, 0 };
    static const Color COLOR_sys_rhp_splash_bgcolor          = { "#6487DC", NULL, 0 };
    static const Color COLOR_sys_rhp_splash_color            = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_rhp_splash_color_title      = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_table_cell_bgcolor1         = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_table_cell_bgcolor2         = { "#D6DFF5", NULL, 0 };
    static const Color COLOR_sys_table_cell_bgcolor3         = { "#C6D3F7", NULL, 0 };
    static const Color COLOR_sys_table_cell_bgcolor4         = { "#EFF3FF", NULL, 0 };
    static const Color COLOR_sys_table_color_border          = { "#6681D9", NULL, 0 };
    static const Color COLOR_sys_table_header_bgcolor1       = { "#6681D9", NULL, 0 };
    static const Color COLOR_sys_table_header_bgcolor2       = { "#6681D9", NULL, 0 };
    static const Color COLOR_sys_toppane_bgcolor             = { "#EDF2FC", NULL, 0 };
    static const Color COLOR_sys_toppane_color_border        = { "#5582D2", NULL, 0 };
    static const Color COLOR_sys_toppane_header_color        = { "#FFFFFF", NULL, 0 };
    static const Color COLOR_sys_toppane_selection           = { "#C7D8FA", NULL, 0 };

    static const Hyperlink HYPER_sys_link_header             = { { "#FFFFFF", NULL, 0 }, { "#FFFFFF", NULL, 0 }, { NULL   , NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_homepage           = { { "#FFFFFF", NULL, 0 }, { "#FFFFFF", NULL, 0 }, { "black", NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_normal             = { { "#3333FF", NULL, 0 }, { "#6666FF", NULL, 0 }, { NULL   , NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_splash             = { { "#FFFFFF", NULL, 0 }, { "#FFFFFF", NULL, 0 }, { "black", NULL, 0 }, true  };

                                                                                                               /*fHorizontal fReturnToZero*/
    static const Gradient GRAD_sys_bottompane_header_bgcolor = { { "#FFFFFF", NULL, 0 }, { "#C5D2F0", NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_header_gradient_H         = { { "#2E52AF", NULL, 0 }, { "#D8EAF3", NULL, 0 }, true      , true  };
    static const Gradient GRAD_sys_header_gradient_V         = { { "#8CAAE6", NULL, 0 }, { "#C8DEFF", NULL, 0 }, false     , true  };
    static const Gradient GRAD_sys_lhp_bgcolor               = { { "#8CAAE6", NULL, 0 }, { "#6487DC", NULL, 0 }, false     , false };
    static const Gradient GRAD_sys_RA_gradient_H             = { { "#A4B9EA", NULL, 0 }, { "#7396DF", NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_RA_gradient_V             = { { "#7396DF", NULL, 0 }, { "#A4B9EA", NULL, 0 }, false     , true  };
    static const Gradient GRAD_sys_table_cell_bgcolor5       = { { "#C5D2F0", NULL, 0 }, { "#FFFFFF", NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_toppane_header_bgcolor    = { { "#0148B2", NULL, 0 }, { "#285BC5", NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_background_strong         = { { "#8CAAE6", NULL, 0 }, { "#8CAAE6", NULL, 0 }, true      , false };

    ////////////////////

    static const ElementFONT rgFONT[] =
    {
        { &NAME_sys_font_body     , & FONT_sys_font_body      },
        { &NAME_sys_font_body_bold, & FONT_sys_font_body_bold },
        { &NAME_sys_font_heading1 , & FONT_sys_font_heading1  },
        { &NAME_sys_font_heading2 , & FONT_sys_font_heading2  },
        { &NAME_sys_font_heading3 , & FONT_sys_font_heading3  },
        { &NAME_sys_font_heading4 , & FONT_sys_font_heading4  },
    };

    static const ElementCOLOR rgCOLOR[] =
    {
        { &NAME_sys_bottompane_header_color, &COLOR_sys_bottompane_header_color },
        { &NAME_sys_color_body             , &COLOR_sys_color_body              },
        { &NAME_sys_color_body_alert       , &COLOR_sys_color_body_alert        },
        { &NAME_sys_color_body_helpee      , &COLOR_sys_color_body_helpee       },
        { &NAME_sys_color_body_helper      , &COLOR_sys_color_body_helper       },
        { &NAME_sys_color_body_ok          , &COLOR_sys_color_body_ok           },
        { &NAME_sys_color_body_sec         , &COLOR_sys_color_body_sec          },
        { &NAME_sys_header_color           , &COLOR_sys_header_color            },
        { &NAME_sys_header_color_logo      , &COLOR_sys_header_color_logo       },
        { &NAME_sys_homepage_color         , &COLOR_sys_homepage_color          },
        { &NAME_sys_lhp_color              , &COLOR_sys_lhp_color               },
        { &NAME_sys_rhp_color_title        , &COLOR_sys_rhp_color_title         },
        { &NAME_sys_rhp_splash_color       , &COLOR_sys_rhp_splash_color        },
        { &NAME_sys_rhp_splash_color_title , &COLOR_sys_rhp_splash_color_title  },
        { &NAME_sys_toppane_header_color   , &COLOR_sys_toppane_header_color    },
    };

    static const ElementBACKGROUND rgBACKGROUND[] =
    {
        { &NAME_sys_bottompane_bgcolor   , &COLOR_sys_bottompane_bgcolor    },
        { &NAME_sys_header_bgcolor       , &COLOR_sys_header_bgcolor        },
        { &NAME_sys_homepage_bgcolor     , &COLOR_sys_homepage_bgcolor      },
        { &NAME_sys_inlineform_bgcolor1  , &COLOR_sys_inlineform_bgcolor1   },
        { &NAME_sys_inlineform_bgcolor2  , &COLOR_sys_inlineform_bgcolor2   },
        { &NAME_sys_inlineform_bgcolor3  , &COLOR_sys_inlineform_bgcolor3   },
        { &NAME_sys_lhp_bgcolor_scope    , &COLOR_sys_lhp_bgcolor_scope     },
        { &NAME_sys_rhp_bgcolor          , &COLOR_sys_rhp_bgcolor           },
        { &NAME_sys_rhp_splash_bgcolor   , &COLOR_sys_rhp_splash_bgcolor    },
        { &NAME_sys_table_cell_bgcolor1  , &COLOR_sys_table_cell_bgcolor1   },
        { &NAME_sys_table_cell_bgcolor2  , &COLOR_sys_table_cell_bgcolor2   },
        { &NAME_sys_table_cell_bgcolor3  , &COLOR_sys_table_cell_bgcolor3   },
        { &NAME_sys_table_cell_bgcolor4  , &COLOR_sys_table_cell_bgcolor4   },
        { &NAME_sys_table_header_bgcolor1, &COLOR_sys_table_header_bgcolor1 },
        { &NAME_sys_table_header_bgcolor2, &COLOR_sys_table_header_bgcolor2 },
        { &NAME_sys_toppane_bgcolor      , &COLOR_sys_toppane_bgcolor       },
        { &NAME_sys_toppane_selection    , &COLOR_sys_toppane_selection     },
    };

    static const ElementBORDER rgBORDER[] =
    {
        { &NAME_sys_bottompane_color_border, &COLOR_sys_bottompane_color_border },
        { &NAME_sys_table_color_border     , &COLOR_sys_table_color_border      },
        { &NAME_sys_toppane_color_border   , &COLOR_sys_toppane_color_border    },
    };

    static const ElementGRADIENT rgGRADIENT[] =
    {
        { &NAME_sys_bottompane_header_bgcolor, &GRAD_sys_bottompane_header_bgcolor },
        { &NAME_sys_header_gradient_H        , &GRAD_sys_header_gradient_H         },
        { &NAME_sys_header_gradient_V        , &GRAD_sys_header_gradient_V         },
        { &NAME_sys_background_strong        , &GRAD_sys_background_strong         },
        { &NAME_sys_lhp_bgcolor              , &GRAD_sys_lhp_bgcolor               },
        { &NAME_sys_RA_gradient_H            , &GRAD_sys_RA_gradient_H             },
        { &NAME_sys_RA_gradient_V            , &GRAD_sys_RA_gradient_V             },
        { &NAME_sys_table_cell_bgcolor5      , &GRAD_sys_table_cell_bgcolor5       },
        { &NAME_sys_toppane_header_bgcolor   , &GRAD_sys_toppane_header_bgcolor    },
    };

    static const ElementHYPERLINK rgHYPERLINK[] =
    {
        { &NAME_sys_link_header  , &HYPER_sys_link_header   },
        { &NAME_sys_link_homepage, &HYPER_sys_link_homepage },
        { &NAME_sys_link_normal  , &HYPER_sys_link_normal   },
        { &NAME_sys_link_splash  , &HYPER_sys_link_splash   },
    };

    static const StyleSheet g_def =
    {
        L"Luna",

        rgFONT      , ARRAYSIZE(rgFONT      ),
        rgCOLOR     , ARRAYSIZE(rgCOLOR     ),
        rgBACKGROUND, ARRAYSIZE(rgBACKGROUND),
        rgBORDER    , ARRAYSIZE(rgBORDER    ),
        rgGRADIENT  , ARRAYSIZE(rgGRADIENT  ),
        rgHYPERLINK , ARRAYSIZE(rgHYPERLINK ),
    };
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

namespace THEME_Classic
{
    static const Font FONT_sys_font_body                     = { "messagebox"            , NULL  , NULL, NULL     };
    static const Font FONT_sys_font_body_bold                = { "messagebox"            , NULL  , NULL, "bold"   };
    static const Font FONT_sys_font_heading1                 = { "Franklin Gothic Medium", "18pt", NULL, "normal" };
    static const Font FONT_sys_font_heading2                 = { "Franklin Gothic Medium", "18pt", NULL, "normal" };
    static const Font FONT_sys_font_heading3                 = { "Franklin Gothic Medium", "14pt", NULL, "normal" };
    static const Font FONT_sys_font_heading4                 = { "Verdana"               , "10pt", NULL, "normal" };

    static const Color COLOR_sys_bottompane_bgcolor          = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_bottompane_color_border     = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_bottompane_header_color     = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_color_body                  = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_color_body_alert            = { "#FF0000"       , NULL       ,   0 };
    static const Color COLOR_sys_color_body_helpee           = { "windowtext"    , "hotlight" , +25 };
    static const Color COLOR_sys_color_body_helper           = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_color_body_ok               = { "#009900"       , NULL       ,   0 };
    static const Color COLOR_sys_color_body_sec              = { "#808080"       , NULL       ,   0 };
    static const Color COLOR_sys_header_bgcolor              = { "activecaption" , NULL       ,   0 };
    static const Color COLOR_sys_header_color                = { "activecaption" , "window"   , +50 };
    static const Color COLOR_sys_header_color_logo           = { "captiontext"   , NULL       ,   0 };
    static const Color COLOR_sys_homepage_bgcolor            = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_homepage_color              = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_inlineform_bgcolor1         = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_inlineform_bgcolor2         = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_inlineform_bgcolor3         = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_lhp_bgcolor_scope           = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_lhp_color                   = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_rhp_bgcolor                 = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_rhp_color_title             = { "activecaption" , NULL       ,   0 };
    static const Color COLOR_sys_rhp_splash_bgcolor          = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_rhp_splash_color            = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_rhp_splash_color_title      = { "windowtext"    , NULL       ,   0 };
    static const Color COLOR_sys_table_cell_bgcolor1         = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_table_cell_bgcolor2         = { "infobackground", NULL       ,   0 };
    static const Color COLOR_sys_table_cell_bgcolor3         = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_table_cell_bgcolor4         = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_table_color_border          = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_table_header_bgcolor1       = { "activecaption" , NULL       ,   0 };
    static const Color COLOR_sys_table_header_bgcolor2       = { "buttonface"    , NULL       ,   0 };
    static const Color COLOR_sys_toppane_bgcolor             = { "window"        , NULL       ,   0 };
    static const Color COLOR_sys_toppane_color_border        = { "activecaption" , NULL       ,   0 };
    static const Color COLOR_sys_toppane_header_color        = { "captiontext"   , NULL       ,   0 };
    static const Color COLOR_sys_toppane_selection           = { "buttonface"    , NULL       ,   0 };

    static const Hyperlink HYPER_sys_link_header             = { { "captiontext", NULL, 0 }, { "captiontext", NULL, 0 }, { NULL, NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_homepage           = { { "hotlight"   , NULL, 0 }, { "hotlight"   , NULL, 0 }, { NULL, NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_normal             = { { "hotlight"   , NULL, 0 }, { "hotlight"   , NULL, 0 }, { NULL, NULL, 0 }, false };
    static const Hyperlink HYPER_sys_link_splash             = { { "hotlight"   , NULL, 0 }, { "hotlight"   , NULL, 0 }, { NULL, NULL, 0 }, false };

                                                                                                                           /*fHorizontal fReturnToZero*/
    static const Gradient GRAD_sys_bottompane_header_bgcolor = { { "buttonface"   , NULL, 0 }, { "buttonface"   , NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_header_gradient_H         = { { "activecaption", NULL, 0 }, { "window"       , NULL, 0 }, true      , true  };
    static const Gradient GRAD_sys_header_gradient_V         = { { "window"       , NULL, 0 }, { "buttonface"   , NULL, 0 }, false     , true  };
    static const Gradient GRAD_sys_lhp_bgcolor               = { { "window"       , NULL, 0 }, { "window"       , NULL, 0 }, false     , false };
    static const Gradient GRAD_sys_RA_gradient_H             = { { "window"       , NULL, 0 }, { "window"       , NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_RA_gradient_V             = { { "window"       , NULL, 0 }, { "window"       , NULL, 0 }, false     , true  };
    static const Gradient GRAD_sys_table_cell_bgcolor5       = { { "window"       , NULL, 0 }, { "window"       , NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_toppane_header_bgcolor    = { { "activecaption", NULL, 0 }, { "activecaption", NULL, 0 }, true      , false };
    static const Gradient GRAD_sys_background_strong         = { { "window"       , NULL, 0 }, { "window"       , NULL, 0 }, true      , false };


    ////////////////////

    static const ElementFONT rgFONT[] =
    {
        { &NAME_sys_font_body     , & FONT_sys_font_body      },
        { &NAME_sys_font_body_bold, & FONT_sys_font_body_bold },
        { &NAME_sys_font_heading1 , & FONT_sys_font_heading1  },
        { &NAME_sys_font_heading2 , & FONT_sys_font_heading2  },
        { &NAME_sys_font_heading3 , & FONT_sys_font_heading3  },
        { &NAME_sys_font_heading4 , & FONT_sys_font_heading4  },
    };

    static const ElementCOLOR rgCOLOR[] =
    {
        { &NAME_sys_bottompane_header_color, &COLOR_sys_bottompane_header_color },
        { &NAME_sys_color_body             , &COLOR_sys_color_body              },
        { &NAME_sys_color_body_alert       , &COLOR_sys_color_body_alert        },
        { &NAME_sys_color_body_helpee      , &COLOR_sys_color_body_helpee       },
        { &NAME_sys_color_body_helper      , &COLOR_sys_color_body_helper       },
        { &NAME_sys_color_body_ok          , &COLOR_sys_color_body_ok           },
        { &NAME_sys_color_body_sec         , &COLOR_sys_color_body_sec          },
        { &NAME_sys_header_color           , &COLOR_sys_header_color            },
        { &NAME_sys_header_color_logo      , &COLOR_sys_header_color_logo       },
        { &NAME_sys_homepage_color         , &COLOR_sys_homepage_color          },
        { &NAME_sys_lhp_color              , &COLOR_sys_lhp_color               },
        { &NAME_sys_rhp_color_title        , &COLOR_sys_rhp_color_title         },
        { &NAME_sys_rhp_splash_color       , &COLOR_sys_rhp_splash_color        },
        { &NAME_sys_rhp_splash_color_title , &COLOR_sys_rhp_splash_color_title  },
        { &NAME_sys_toppane_header_color   , &COLOR_sys_toppane_header_color    },
    };

    static const ElementBACKGROUND rgBACKGROUND[] =
    {
        { &NAME_sys_bottompane_bgcolor   , &COLOR_sys_bottompane_bgcolor    },
        { &NAME_sys_header_bgcolor       , &COLOR_sys_header_bgcolor        },
        { &NAME_sys_homepage_bgcolor     , &COLOR_sys_homepage_bgcolor      },
        { &NAME_sys_inlineform_bgcolor1  , &COLOR_sys_inlineform_bgcolor1   },
        { &NAME_sys_inlineform_bgcolor2  , &COLOR_sys_inlineform_bgcolor2   },
        { &NAME_sys_inlineform_bgcolor3  , &COLOR_sys_inlineform_bgcolor3   },
        { &NAME_sys_lhp_bgcolor_scope    , &COLOR_sys_lhp_bgcolor_scope     },
        { &NAME_sys_rhp_bgcolor          , &COLOR_sys_rhp_bgcolor           },
        { &NAME_sys_rhp_splash_bgcolor   , &COLOR_sys_rhp_splash_bgcolor    },
        { &NAME_sys_table_cell_bgcolor1  , &COLOR_sys_table_cell_bgcolor1   },
        { &NAME_sys_table_cell_bgcolor2  , &COLOR_sys_table_cell_bgcolor2   },
        { &NAME_sys_table_cell_bgcolor3  , &COLOR_sys_table_cell_bgcolor3   },
        { &NAME_sys_table_cell_bgcolor4  , &COLOR_sys_table_cell_bgcolor4   },
        { &NAME_sys_table_header_bgcolor1, &COLOR_sys_table_header_bgcolor1 },
        { &NAME_sys_table_header_bgcolor2, &COLOR_sys_table_header_bgcolor2 },
        { &NAME_sys_toppane_bgcolor      , &COLOR_sys_toppane_bgcolor       },
        { &NAME_sys_toppane_selection    , &COLOR_sys_toppane_selection     },
    };

    static const ElementBORDER rgBORDER[] =
    {
        { &NAME_sys_bottompane_color_border, &COLOR_sys_bottompane_color_border },
        { &NAME_sys_table_color_border     , &COLOR_sys_table_color_border      },
        { &NAME_sys_toppane_color_border   , &COLOR_sys_toppane_color_border    },
    };

    static const ElementGRADIENT rgGRADIENT[] =
    {
        { &NAME_sys_bottompane_header_bgcolor, &GRAD_sys_bottompane_header_bgcolor },
        { &NAME_sys_header_gradient_H        , &GRAD_sys_header_gradient_H         },
        { &NAME_sys_header_gradient_V        , &GRAD_sys_header_gradient_V         },
        { &NAME_sys_background_strong        , &GRAD_sys_background_strong         },
        { &NAME_sys_lhp_bgcolor              , &GRAD_sys_lhp_bgcolor               },
        { &NAME_sys_RA_gradient_H            , &GRAD_sys_RA_gradient_H             },
        { &NAME_sys_RA_gradient_V            , &GRAD_sys_RA_gradient_V             },
        { &NAME_sys_table_cell_bgcolor5      , &GRAD_sys_table_cell_bgcolor5       },
        { &NAME_sys_toppane_header_bgcolor   , &GRAD_sys_toppane_header_bgcolor    },
    };

    static const ElementHYPERLINK rgHYPERLINK[] =
    {
        { &NAME_sys_link_header  , &HYPER_sys_link_header   },
        { &NAME_sys_link_homepage, &HYPER_sys_link_homepage },
        { &NAME_sys_link_normal  , &HYPER_sys_link_normal   },
        { &NAME_sys_link_splash  , &HYPER_sys_link_splash   },
    };

    static const StyleSheet g_def =
    {
        L"Classic",

        rgFONT      , ARRAYSIZE(rgFONT      ),
        rgCOLOR     , ARRAYSIZE(rgCOLOR     ),
        rgBACKGROUND, ARRAYSIZE(rgBACKGROUND),
        rgBORDER    , ARRAYSIZE(rgBORDER    ),
        rgGRADIENT  , ARRAYSIZE(rgGRADIENT  ),
        rgHYPERLINK , ARRAYSIZE(rgHYPERLINK ),
    };
}

////////////////////////////////////////////////////////////////////////////////

static const StyleSheet* g_def[] =
{
    &THEME_Luna   ::g_def,
    &THEME_Classic::g_def,
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Font::Generate( /*[in]*/ Environment& env ) const
{
    CHAR rgName [64];
    CHAR rgSize [64];
    CHAR rgStyle[64];

    strncpy( rgName , SAFEASTR(m_szName ), MAXSTRLEN(rgName ) );
    strncpy( rgSize , SAFEASTR(m_szSize ), MAXSTRLEN(rgSize ) );
    strncpy( rgStyle, SAFEASTR(m_szStyle), MAXSTRLEN(rgStyle) );

    if(!strcmp( rgName, "messagebox" ))
    {
        strncpy( rgName ,          env.m_ncm.lfMessageFont.lfFaceName, MAXSTRLEN(rgName) );
        sprintf( rgSize , "%dpt", -env.m_ncm.lfMessageFont.lfHeight * 72 / env.m_iPixel  );
    }

    env.AddAttribute( "font-family", rgName     );
    env.AddAttribute( "font-size  ", rgSize     );
    env.AddAttribute( "font-style ", rgStyle    );
    env.AddAttribute( "font-weight", m_szWeight );
}

HRESULT Font::LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn )
{
    __HCP_FUNC_ENTRY( "Font::LoadFromXML" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.GetValue( xdn, L"FAMILY", m_szName   ));
    (void)                         env.GetValue( xdn, L"SIZE"  , m_szSize   );
    (void)                         env.GetValue( xdn, L"STYLE" , m_szStyle  );
    (void)                         env.GetValue( xdn, L"WEIGHT", m_szWeight );

    hr = S_OK;

    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void Font::Release()
{
    free( (void*)m_szName   );
    free( (void*)m_szSize   );
    free( (void*)m_szStyle  );
    free( (void*)m_szWeight );
}

#ifdef DEBUG
HRESULT Font::GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const
{
    __HCP_FUNC_ENTRY( "Font::GenerateXML" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"FAMILY", m_szName   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"SIZE"  , m_szSize   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"STYLE" , m_szStyle  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"WEIGHT", m_szWeight ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
#endif

////////////////////

inline int ScaleColor( int iColor1, int iColor2, int iRatio )
{
    iColor1 += ((iColor2 - iColor1) * iRatio) / 100;

    if(iColor1 <   0) iColor1 = 0;
    if(iColor1 > 255) iColor1 = 255;

    return iColor1;
}

void Color::Generate( /*[in]*/ Environment& env     ,
                      /*[in]*/ LPCSTR       szStyle ) const
{
    char     rgBuf[128];
    COLORREF color1;
    COLORREF color2;
    bool     fSystem1;
    bool     fSystem2;

    if(!MPC::HTML::ConvertColor( CComVariant( m_szDef1 ), color1, fSystem1 ))
    {
        env.AddAttribute( szStyle, m_szDef1 );
        return;
    }

    if(m_szDef2 && MPC::HTML::ConvertColor( CComVariant( m_szDef2 ), color2, fSystem2 ))
    {
        sprintf( rgBuf, "#%02x%02x%02x"                                       ,
                 ScaleColor( GetRValue(color1), GetRValue(color2), m_iRatio ) ,
                 ScaleColor( GetGValue(color1), GetGValue(color2), m_iRatio ) ,
                 ScaleColor( GetBValue(color1), GetBValue(color2), m_iRatio ) );
    }
    else
    {
        sprintf( rgBuf, "#%02x%02x%02x" ,
                 GetRValue(color1)      ,
                 GetGValue(color1)      ,
                 GetBValue(color1)      );
    }

#ifdef DEBUG
    if(strcmp( rgBuf, m_szDef1 ))
    {
        char rgBuf2[256];

        if(m_szDef1 && m_szDef2)
        {
            sprintf( rgBuf2, " /* %s -> %s at %d%% */", m_szDef1, m_szDef2, m_iRatio );
        }
        else
        {
            sprintf( rgBuf2, " /* %s */", m_szDef1 );
        }

        strcat( rgBuf, rgBuf2 );
    }
#endif

    env.AddAttribute( szStyle, rgBuf );
}

HRESULT Color::LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn )
{
    __HCP_FUNC_ENTRY( "Color::LoadFromXML" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.GetValue( xdn, L"VALUE"    , m_szDef1 ));
    (void)                         env.GetValue( xdn, L"VALUE_100", m_szDef2 );
    (void)                         env.GetValue( xdn, L"PERCENT"  , m_iRatio );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void Color::Release()
{
    free( (void*)m_szDef1 );
    free( (void*)m_szDef2 );
}

#ifdef DEBUG
HRESULT Color::GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const
{
    __HCP_FUNC_ENTRY( "Color::GenerateXML" );

    HRESULT hr;

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"VALUE"    , m_szDef1 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"VALUE_100", m_szDef2 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"PERCENT"  , m_iRatio ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
#endif

////////////////////

void Gradient::Generate( /*[in]*/ Environment& env ) const
{
    env    .AddAttribute(      "behavior      " , "url(#default#pch_gradient)" );
    m_start.Generate    ( env, "start-color   "                                );
    m_end  .Generate    ( env, "end-color     "                                );
    env    .AddAttribute(      "gradient-type " , m_fHorizontal   ? "1" : "0"  );
    env    .AddAttribute(      "return-to-zero" , m_fReturnToZero ? "1" : "0"  );
}

HRESULT Gradient::LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn )
{
    __HCP_FUNC_ENTRY( "Gradient::LoadFromXML" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdn );

    {
        CComPtr<IXMLDOMNode> xdn2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( L"COLOR_START", &xdn2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_start.LoadFromXML( env, xdn2 ));
    }

    {
        CComPtr<IXMLDOMNode> xdn2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( L"COLOR_END", &xdn2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_end.LoadFromXML( env, xdn2 ));
    }

    (void)env.GetValue( xdn, L"HORIZONTAL"  , m_fHorizontal   );
    (void)env.GetValue( xdn, L"RETURNTOZERO", m_fReturnToZero );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void Gradient::Release()
{
    m_start.Release();
    m_end  .Release();
}

#ifdef DEBUG
HRESULT Gradient::GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const
{
    __HCP_FUNC_ENTRY( "Gradient::GenerateXML" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnSub;

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"COLOR_START", &xdnSub, xdn )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_start.GenerateXML( env, xml, xdnSub )); xdnSub.Release();
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"COLOR_END"  , &xdnSub, xdn )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_end  .GenerateXML( env, xml, xdnSub )); xdnSub.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"HORIZONTAL"  , m_fHorizontal   ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"RETURNTOZERO", m_fReturnToZero ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
#endif

////////////////////

void Hyperlink::Generate( /*[in]*/ Environment& env ,
                          /*[in]*/ PseudoClass  cls ) const
{
    const Color* color;
    bool         fFlag;

    switch(cls)
    {
    case PC_NORMAL: color = &m_colorNormal; fFlag = m_fUnderlineAlways; break;
    case PC_HOVER : color = &m_colorHover ; fFlag = true              ; break;
    case PC_ACTIVE: color = &m_colorActive; fFlag = m_fUnderlineAlways; break;
    }

    if(!color->m_szDef1) color = &m_colorNormal;

    color->Generate ( env, "color          "                               );
    env.AddAttribute(      "text-decoration", fFlag ? "underline" : "none" );
}

HRESULT Hyperlink::LoadFromXML( /*[in]*/ Environment& env, /*[in]*/ IXMLDOMNode *xdn )
{
    __HCP_FUNC_ENTRY( "Hyperlink::LoadFromXML" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdn );

    {
        CComPtr<IXMLDOMNode> xdn2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( L"NORMAL", &xdn2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_colorNormal.LoadFromXML( env, xdn2 ));
    }

    {
        CComPtr<IXMLDOMNode> xdn2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetNode( L"HOVER", &xdn2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_colorHover.LoadFromXML( env, xdn2 ));
    }

    {
        CComPtr<IXMLDOMNode> xdn2;

        if(SUCCEEDED(xml.GetNode( L"ACTIVE", &xdn2 )))
        {
            (void)m_colorActive.LoadFromXML( env, xdn2 );
        }
    }

    (void)env.GetValue( xdn, L"UNDERLINEALWAYS", m_fUnderlineAlways );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void Hyperlink::Release()
{
    m_colorNormal.Release();
    m_colorHover .Release();
    m_colorActive.Release();
}

#ifdef DEBUG
HRESULT Hyperlink::GenerateXML( /*[in]*/ Environment& env, /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode *xdn ) const
{
    __HCP_FUNC_ENTRY( "Hyperlink::GenerateXML" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnSub;

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"NORMAL", &xdnSub, xdn )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_colorNormal.GenerateXML( env, xml, xdnSub )); xdnSub.Release();
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"HOVER" , &xdnSub, xdn )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_colorHover .GenerateXML( env, xml, xdnSub )); xdnSub.Release();
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"ACTIVE", &xdnSub, xdn )); __MPC_EXIT_IF_METHOD_FAILS(hr, m_colorActive.GenerateXML( env, xml, xdnSub )); xdnSub.Release();

    __MPC_EXIT_IF_METHOD_FAILS(hr, env.CreateValue( xml, xdn, L"UNDERLINEALWAYS", m_fUnderlineAlways ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
#endif

////////////////////////////////////////////////////////////////////////////////

Environment::Environment( /*[in]*/ MPC::string& strOutput ) : m_strOutput( strOutput )
{
                            // MPC::string&      m_strOutput;
                            // NONCLIENTMETRICSA m_ncm;
                            // int               m_iPixel;
                            //
                            // MPC::XmlUtil      m_xmlOEM;
    m_fOEM         = false; // bool              m_fOEM;
    m_fCustomizing = false; // bool              m_fCustomizing;
}

HRESULT Environment::Init()
{
    __HCP_FUNC_ENTRY( "Environment::Init" );

    HRESULT hr;
    HDC     hdc = NULL;


    m_ncm.cbSize  = sizeof(NONCLIENTMETRICSA);

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SystemParametersInfoA( SPI_GETNONCLIENTMETRICS, 0, &m_ncm, 0 ));

    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, hdc = ::CreateCompatibleDC( NULL ));

    m_iPixel = ::GetDeviceCaps( hdc, LOGPIXELSY ); if(!m_iPixel) m_iPixel = 60; // Pick a default.

    m_strOutput.reserve( 16384 );

    m_strOutput.assign( "/*\n"
                        "** Copyright (c) 2001 Microsoft Corporation\n"
                        "*/\n\n"
                        "BODY\n"
                        "{\n"
                        "\tcursor : default;\n"
                        "\tmargin : 0px;\n"
                        "}\n\n" );


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hdc) ::DeleteDC( hdc );

    __HCP_FUNC_EXIT(hr);
}

void Environment::OpenClass( /*[in]*/ const ElementName* name, /*[in]*/ LPCSTR szPrefix, /*[in]*/ LPCSTR szSuffix )
{
#ifdef DEBUG
    if(name->m_szComment)
    {
        m_strOutput.append( "/* "             );
        m_strOutput.append( name->m_szComment );
        m_strOutput.append( " */\n"           );
    }
#endif

    if(szPrefix) m_strOutput.append( szPrefix       );
                 m_strOutput.append( name->m_szName );
    if(szSuffix) m_strOutput.append( szSuffix       );
                 m_strOutput.append( "\n{\n"        );
}

void Environment::AddAttribute( /*[in]*/ LPCSTR szName, /*[in]*/ LPCSTR szValue )
{
    if(STRINGISPRESENT(szValue))
    {
        m_strOutput.append( "    "  );
        m_strOutput.append( szName  );
        m_strOutput.append( " : "   );
        m_strOutput.append( szValue );
        m_strOutput.append( ";\n"   );
    }
}

void Environment::CloseClass()
{
    m_strOutput.append( "}\n\n" );
}

void Environment::GenerateClass( /*[in]*/ const ElementFONT& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name );

    ptr.m_font->Generate( *this );

    CloseClass();
}

void Environment::GenerateClass( /*[in]*/ const ElementCOLOR& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name );

    ptr.m_color->Generate( *this, "color" );

    CloseClass();
}

void Environment::GenerateClass( /*[in]*/ const ElementBACKGROUND& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name );

    ptr.m_color->Generate( *this, "background-color" );

    CloseClass();
}

void Environment::GenerateClass( /*[in]*/ const ElementBORDER& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name );

    ptr.m_color->Generate( *this, "border-color" );

    CloseClass();
}

void Environment::GenerateClass( /*[in]*/ const ElementGRADIENT& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name );

    ptr.m_gradient->Generate( *this );

    CloseClass();
}

void Environment::GenerateClass( /*[in]*/ const ElementHYPERLINK& ptr )
{
    if(IsCustomizationPresent( ptr.m_name )) return;

    OpenClass( ptr.m_name, "A" );

    ptr.m_hyperlink->Generate( *this, Hyperlink::PC_NORMAL );

    CloseClass();


    OpenClass( ptr.m_name, "A", ":hover" );

    ptr.m_hyperlink->Generate( *this, Hyperlink::PC_HOVER );

    CloseClass();


    OpenClass( ptr.m_name, "A", ":active" );

    ptr.m_hyperlink->Generate( *this, Hyperlink::PC_ACTIVE );

    CloseClass();
}

////////////////////

#define MACRO_CHECK_CUSTOMIZATION( text, objectCls, elementCls ) \
    if(!MPC::StrICmp( bstrValue, text ))                         \
    {                                                            \
        objectCls obj; ::ZeroMemory( &obj, sizeof(obj) );        \
                                                                 \
        if(SUCCEEDED(obj.LoadFromXML( *this, node )))            \
        {                                                        \
            elementCls elem = { name, &obj };                    \
                                                                 \
            GenerateClass( elem );                               \
            fProcessed = true;                                   \
        }                                                        \
                                                                 \
        obj.Release();                                           \
    }

bool Environment::IsCustomizationPresent( /*[in]*/ const ElementName* name )
{
    bool fProcessed = false;

    if(m_fOEM && m_fCustomizing == false)
    {
        CComBSTR                 bstrName( name->m_szName );
        CComPtr<IXMLDOMNodeList> lst;
        bool                     fLoaded;
        bool                     fFound;

        m_fCustomizing = true;

        if(SUCCEEDED(m_xmlOEM.GetNodes( L"CLASS", &lst )) && lst)
        {
            CComPtr<IXMLDOMNode> node;

            for(;SUCCEEDED(lst->nextNode( &node )) && node != NULL; node = NULL)
            {
                CComBSTR bstrValue;

                if(SUCCEEDED(m_xmlOEM.GetAttribute( NULL, L"NAME", bstrValue, fFound, node )) && fFound)
                {
                    if(!MPC::StrICmp( bstrName, bstrValue ))
                    {
                        if(SUCCEEDED(m_xmlOEM.GetAttribute( NULL, L"TYPE", bstrValue, fFound, node )) && fFound)
                        {
                            MACRO_CHECK_CUSTOMIZATION( L"BGCOLOR"  , Color    , ElementBACKGROUND );
                            MACRO_CHECK_CUSTOMIZATION( L"BORDER"   , Color    , ElementBORDER     );
                            MACRO_CHECK_CUSTOMIZATION( L"COLOR"    , Color    , ElementCOLOR      );
                            MACRO_CHECK_CUSTOMIZATION( L"FONT"     , Font     , ElementFONT       );
                            MACRO_CHECK_CUSTOMIZATION( L"GRADIENT" , Gradient , ElementGRADIENT   );
                            MACRO_CHECK_CUSTOMIZATION( L"HYPERLINK", Hyperlink, ElementHYPERLINK  );
                        }

                        break;
                    }
                }
            }
        }

        m_fCustomizing = false;
    }

    return fProcessed;
}

////////////////////

HRESULT Environment::GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ CComVariant& v )
{
    __HCP_FUNC_ENTRY( "Environment::GetValue" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdn );
    bool         fFound;

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetValue( szName, v, fFound ));
    if(!fFound)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Environment::GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ LPCSTR& v )
{
    __HCP_FUNC_ENTRY( "Environment::GetValue" );

    USES_CONVERSION;

    HRESULT     hr;
    CComVariant v2;
    LPCSTR      val;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetValue( xdn, szName, v2 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, v2.ChangeType( VT_BSTR ));

    if(v2.bstrVal)
    {
        val = W2A( v2.bstrVal );
    }
    else
    {
        val = "";
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, v, _strdup( val ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Environment::GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ int& v )
{
    __HCP_FUNC_ENTRY( "Environment::GetValue" );

    USES_CONVERSION;

    HRESULT     hr;
    CComVariant v2;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetValue( xdn, szName, v2 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, v2.ChangeType( VT_I4 ));

    v = v2.lVal;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Environment::GetValue( /*[in]*/ IXMLDOMNode *xdn, /*[in]*/ LPCWSTR szName, /*[out]*/ bool& v )
{
    __HCP_FUNC_ENTRY( "Environment::GetValue" );

    USES_CONVERSION;

    HRESULT     hr;
    CComVariant v2;

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetValue( xdn, szName, v2 ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, v2.ChangeType( VT_BOOL ));

    v = (v2.boolVal == VARIANT_TRUE);

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

HRESULT Environment::GenerateStyleSheet( /*[in]*/ const StyleSheet& def  )
{
    __HCP_FUNC_ENTRY( "GenerateStyleSheet" );

    HRESULT hr;
    int     i;

    __MPC_EXIT_IF_METHOD_FAILS(hr, Init());

    {
        bool fLoaded;
        bool fFound;

        if(SUCCEEDED(m_xmlOEM.Load( L"hcp://system/css/shared.xml", L"STYLESHEET", fLoaded, &fFound )) && fLoaded && fFound)
        {
            CComPtr<IXMLDOMNodeList> lst;

            if(SUCCEEDED(m_xmlOEM.GetNodes( L"THEME", &lst )) && lst)
            {
                CComPtr<IXMLDOMNode> node;

                for(;SUCCEEDED(lst->nextNode( &node )) && node != NULL; node = NULL)
                {
                    CComBSTR bstrName;

                    if(SUCCEEDED(m_xmlOEM.GetAttribute( NULL, L"NAME", bstrName, fFound, node )) && fFound)
                    {
                        if(!MPC::StrICmp( bstrName, def.m_szName ))
                        {
                            m_xmlOEM = node;
                            m_fOEM   = true;
                            break;
                        }
                    }
                }
            }
        }
    }


    for(i=0; i<def.m_iFonts      ; i++) GenerateClass( def.m_fonts      [i] );
    for(i=0; i<def.m_iColors     ; i++) GenerateClass( def.m_colors     [i] );
    for(i=0; i<def.m_iBackgrounds; i++) GenerateClass( def.m_backgrounds[i] );
    for(i=0; i<def.m_iBorders    ; i++) GenerateClass( def.m_borders    [i] );
    for(i=0; i<def.m_iGradients  ; i++) GenerateClass( def.m_gradients  [i] );
    for(i=0; i<def.m_iHyperlinks ; i++) GenerateClass( def.m_hyperlinks [i] );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////

#ifdef DEBUG

HRESULT Environment::CreateNode( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ const ElementName* elem, /*[in]*/ LPCWSTR szType, /*[in/out]*/ CComPtr<IXMLDOMNode>& xdn )
{
    __HCP_FUNC_ENTRY( "Environment::CreateNode" );

    HRESULT hr;
    bool    fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"CLASS", &xdn ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, L"NAME", elem->m_szName, fFound, xdn ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, L"TYPE", szType        , fFound, xdn ));

    if(STRINGISPRESENT(elem->m_szComment))
    {
        CComPtr<IXMLDOMDocument> doc;
        CComPtr<IXMLDOMComment>  xdc;
        CComPtr<IXMLDOMNode>     xdn2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.GetDocument( &doc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, doc->createComment( CComBSTR( elem->m_szComment ), &xdc ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xdn->appendChild( xdc, &xdn2 ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Environment::CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ LPCSTR szValue )
{
    //  if(!STRINGISPRESENT(szValue)) return S_OK;

    return CreateValue( xml, xdn, szName, CComVariant( szValue ) );
}

HRESULT Environment::CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ bool fValue )
{
    return CreateValue( xml, xdn, szName, CComVariant( fValue ? L"TRUE" : L"FALSE" ) );
}

HRESULT Environment::CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ int iValue )
{
    //  if(iValue == 0) return S_OK;

    return CreateValue( xml, xdn, szName, CComVariant( iValue ) );
}

HRESULT Environment::CreateValue( /*[in]*/ MPC::XmlUtil& xml, /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ LPCWSTR szName, /*[in]*/ CComVariant& vValue )
{
    __HCP_FUNC_ENTRY( "Environment::CreateValue" );

    HRESULT              hr;
    CComPtr<IXMLDOMNode> xdnSub;
    bool                 fFound;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( szName, &xdnSub, xdn ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutValue( NULL, vValue, fFound, xdnSub ));


    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}


HRESULT Environment::GenerateStyleSheetXML( /*[in]*/ IXMLDOMNode* xdn, /*[in]*/ const StyleSheet& def )
{
    __HCP_FUNC_ENTRY( "GenerateStyleSheetXML" );

    HRESULT      hr;
    MPC::XmlUtil xml( xdn );
    int          i;


    for(i=0; i<def.m_iFonts; i++)
    {
        const ElementFONT&   ptr = def.m_fonts[i];
        CComPtr<IXMLDOMNode> xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"FONT", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_font->GenerateXML( *this, xml, xdnSub ));
    }

    for(i=0; i<def.m_iColors; i++)
    {
        const ElementCOLOR&  ptr = def.m_colors[i];
        CComPtr<IXMLDOMNode> xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"COLOR", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_color->GenerateXML( *this, xml, xdnSub ));
    }

    for(i=0; i<def.m_iBackgrounds; i++)
    {
        const ElementBACKGROUND& ptr = def.m_backgrounds[i];
        CComPtr<IXMLDOMNode>     xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"BGCOLOR", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_color->GenerateXML( *this, xml, xdnSub ));
    }

    for(i=0; i<def.m_iBorders; i++)
    {
        const ElementBORDER& ptr = def.m_borders[i];
        CComPtr<IXMLDOMNode> xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"BORDER", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_color->GenerateXML( *this, xml, xdnSub ));
    }

    for(i=0; i<def.m_iGradients; i++)
    {
        const ElementGRADIENT& ptr = def.m_gradients[i];
        CComPtr<IXMLDOMNode>   xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"GRADIENT", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_gradient->GenerateXML( *this, xml, xdnSub ));
    }

    for(i=0; i<def.m_iHyperlinks; i++)
    {
        const ElementHYPERLINK& ptr = def.m_hyperlinks[i];
        CComPtr<IXMLDOMNode>    xdnSub; __MPC_EXIT_IF_METHOD_FAILS(hr, CreateNode( xml, ptr.m_name, L"HYPERLINK", xdnSub ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ptr.m_hyperlink->GenerateXML( *this, xml, xdnSub ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT Environment::DumpStyle()
{
    __HCP_FUNC_ENTRY( "Environment::DumpStyle" );

    HRESULT      hr;
    MPC::wstring strFile( L"%TEMP%\\HSS_style.css" ); MPC::SubstituteEnvVariables( strFile );
    HANDLE       hfFile = NULL;
    DWORD        dwWritten;

    __MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hfFile, ::CreateFileW( strFile.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::WriteFile( hfFile, m_strOutput.c_str(), m_strOutput.size(), &dwWritten, NULL ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __HCP_FUNC_EXIT(hr);
}

HRESULT Environment::DumpStyleXML()
{
    __HCP_FUNC_ENTRY( "Environment::DumpStyleXML" );

    HRESULT      hr;
    MPC::wstring strFile( L"%TEMP%\\HSS_style.xml" ); MPC::SubstituteEnvVariables( strFile );
    MPC::XmlUtil xml;


    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.New( L"STYLESHEET", L"UTF-8" ));

    for(int i=0; i<ARRAYSIZE(g_def); i++)
    {
        CComPtr<IXMLDOMNode> xdn;
        bool                 fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.CreateNode( L"THEME", &xdn ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, xml.PutAttribute( NULL, L"NAME", g_def[i]->m_szName, fFound, xdn ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, GenerateStyleSheetXML( xdn, *(g_def[i]) ));
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, xml.Save( strFile.c_str() ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

#endif

////////////////////////////////////////////////////////////////////////////////

HRESULT CHCPProtocolEnvironment::ProcessCSS()
{
    HRESULT           hr;
    const StyleSheet* style = &THEME_Classic::g_def;
    WCHAR             rgName[MAX_PATH]; rgName[0] = 0;

    if(m_strCSS.size()) return S_OK;


    if(IsThemeActive())
    {
        WCHAR rgThemeFileName[MAX_PATH];
        WCHAR rgColor        [MAX_PATH];
        WCHAR rgSize         [MAX_PATH];

        if(SUCCEEDED(GetCurrentThemeName( rgThemeFileName, MAXSTRLEN(rgThemeFileName)  ,
                                          rgColor        , MAXSTRLEN(rgColor        )  ,
                                          rgSize         , MAXSTRLEN(rgSize         )  )))
        {
            if(SUCCEEDED(GetThemeDocumentationProperty( rgThemeFileName, SZ_THDOCPROP_CANONICALNAME, rgName, MAXSTRLEN( rgName ) )))
            {
                ;
            }
            else
            {
                rgName[0] = 0;
            }
        }
    }

#ifdef DEBUG
    if(g_Debug_FORCESTYLE[0])
    {
        wcsncpy( rgName, g_Debug_FORCESTYLE, MAXSTRLEN( rgName ) );
    }
#endif

    for(int i=0; i<ARRAYSIZE(g_def); i++)
    {
        if(!_wcsicmp( rgName, g_def[i]->m_szName ))
        {
            style = g_def[i];
            break;
        }
    }

    {
        Environment env( m_strCSS );

        hr = env.GenerateStyleSheet( *style );

#ifdef DEBUG
        env.DumpStyle   ();
        env.DumpStyleXML();
#endif
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\printing\printhost.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PrintHost.cpp

Abstract:
    Trident control hosting code for multi-topic printing.

Revision History:
    Davide Massarenti   (Dmassare)  05/07/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

static CComBSTR l_bstrPrintStruct    ( L"printStruct"     );
static CComBSTR l_bstrPrintToFileOk  ( L"printToFileOk"   );
static CComBSTR l_bstrPrintToFileName( L"printToFileName" );

////////////////////////////////////////////////////////////////////////////////

Printing::HostWindow::HostWindow()
{
    m_cRef          = 0;      // ULONG        m_cRef;
                              //
                              // MPC::wstring m_szPrintFileName;
    m_fMultiTopic   = false;  // bool         m_fMultiTopic;
                              //
    m_fShowPrintDlg = true;   // bool         m_fShowPrintDlg;
	m_pDevMode      = NULL;   // LPDEVMODEW   m_pDevMode;
                              // CComBSTR     m_bstrPrinterName;
                              //
	m_fAborted      = false;  // bool         m_fAborted;
	m_hEvent        = NULL;   // HANDLE       m_hEvent;
}

Printing::HostWindow::~HostWindow()
{
	if(m_pDevMode) delete m_pDevMode;
}


STDMETHODIMP Printing::HostWindow::QueryStatus( /*[in]    */ const GUID* pguidCmdGroup ,
                                                /*[in]    */ ULONG       cCmds         ,
                                                /*[in/out]*/ OLECMD     *prgCmds       ,
                                                /*[in/out]*/ OLECMDTEXT *pCmdText      )
{
    return E_NOTIMPL;
}

STDMETHODIMP Printing::HostWindow::Exec( /*[in] */ const GUID* pguidCmdGroup ,
                                         /*[in] */ DWORD       nCmdID        ,
                                         /*[in] */ DWORD       nCmdExecOpt   ,
                                         /*[in] */ VARIANTARG* pvaIn         ,
                                         /*[out]*/ VARIANTARG* pvaOut        )
{
    HRESULT   hr    = E_NOTIMPL;
    HINSTANCE hInst = NULL;


    if(nCmdID == OLECMDID_SHOWPRINT)
    {
        for(;;)
        {
            LPPRINTDLGW pPrintDlg = NULL;


			if(m_fAborted)
			{
				hr = S_FALSE;
				break;
			}


            if(pvaIn == NULL || pvaIn->vt != VT_UNKNOWN) break;


            // Get the event object
            CComQIPtr<IHTMLEventObj2> spHTMLEventObj( pvaIn->punkVal ); if(!spHTMLEventObj) break;

            // Get a pointer to the PRINTDLG struct
            {
                CComVariant var;

                if(FAILED(spHTMLEventObj->getAttribute( l_bstrPrintStruct, 0, &var ))) break;

				if(var.vt == VT_PTR)
				{
					pPrintDlg = (LPPRINTDLGW)var.byref;
				}
				else
				{
#ifdef _WIN64
					if(var.vt == VT_I8)
					{
						pPrintDlg = (LPPRINTDLGW)var.llVal;
					}
#else
					if(var.vt == VT_I4)
					{
						pPrintDlg = (LPPRINTDLGW)var.lVal;
					}
#endif
				}
				if(!pPrintDlg) break;
            }

            // do multi-topic extra stuff
            if(m_fMultiTopic)
            {
                // Get the printToFileOk attribute
                {
                    CComVariant var;

                    if(FAILED(spHTMLEventObj->getAttribute( l_bstrPrintToFileOk, 0, &var )) || var.vt != VT_BOOL) break;

                    var.boolVal = VARIANT_TRUE;

                    if(FAILED(spHTMLEventObj->setAttribute( l_bstrPrintToFileOk, var, 0 ))) break;
                }

                // Get the printToFileName attribute
                {
                    CComVariant var;

                    if(FAILED(spHTMLEventObj->getAttribute( l_bstrPrintToFileName, 0, &var )) || var.vt != VT_BSTR) break;

                    if(FAILED(spHTMLEventObj->setAttribute( l_bstrPrintToFileName, CComVariant( m_szPrintFileName.c_str() ), 0 ))) break;
                }
            }

            if(m_fShowPrintDlg || m_pDevMode == NULL)
            {
				BOOL fRes;

				// hide the print to file option here, it could mess things up
				pPrintDlg->Flags |=  PD_HIDEPRINTTOFILE;
				pPrintDlg->Flags &= ~PD_RETURNDEFAULT;

				fRes = PrintDlgW( pPrintDlg );
				if(fRes == FALSE)
				{
					hr = S_FALSE;
					break;
				}

				m_fShowPrintDlg = false;

				// get the devmode, which holds the device name
				LPDEVMODEW pdevmode = (LPDEVMODEW)::GlobalLock( pPrintDlg->hDevMode );
				if(pdevmode)
				{
					size_t size = pdevmode->dmSize + pdevmode->dmDriverExtra;

					m_pDevMode = (LPDEVMODEW)new BYTE[size];
					if(m_pDevMode == NULL)
					{
						hr = S_FALSE;
						break;
					}


					if(fRes == FALSE)
					{
						pPrintDlg->nCopies  = 0;
						pdevmode ->dmCopies = 0;
					}

					::CopyMemory( m_pDevMode, pdevmode, size );

					::GlobalUnlock( pPrintDlg->hDevMode );
				}

				// get the printer name
				LPDEVNAMES pdevnames = (LPDEVNAMES)::GlobalLock( pPrintDlg->hDevNames );
				if(pdevnames)
				{
					m_bstrPrinterName = (WCHAR*)pdevnames + pdevnames->wDeviceOffset;

					::GlobalUnlock( pPrintDlg->hDevNames );
				}
            }
			else
			{
				pPrintDlg->hDC = ::CreateDCW( NULL, m_bstrPrinterName, NULL, m_pDevMode );
			}

            // set the print to file flag for multi-topic
            if(m_fMultiTopic)
            {
				pPrintDlg->Flags |= PD_PRINTTOFILE;
			}

            // if we get here, all is ok
            hr = S_OK;
            break;
		}
    }

	if(hr == S_FALSE)
	{
		m_fAborted = true;

		if(m_hEvent)
		{
			::SetEvent( m_hEvent );
		}
	}

	if(hInst) ::FreeLibrary( hInst );

    return hr;
}

void Printing::HostWindow::SetMultiTopic   ( /*[in]*/ bool    fMulti          ) { m_fMultiTopic     = fMulti         ; }
void Printing::HostWindow::SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName ) { m_szPrintFileName = szPrintFileName; }
void Printing::HostWindow::SetAbortEvent   ( /*[in]*/ HANDLE  hEvent          ) { m_hEvent          = hEvent         ; }
bool Printing::HostWindow::GetAbortState   (                                  ) { return m_fAborted;                   }

BSTR Printing::HostWindow::GetPrinterName() { return m_bstrPrinterName; }

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Printing::WindowHandle::WindowHandle()
{
    m_pSiteObject = NULL;  // theSite*      m_pSiteObject;
    m_fMultiTopic = false; // bool          m_fMultiTopic;
                           // MPC::wstring  m_szPrintFileName;
    m_hEvent      = NULL;  // HANDLE        m_hEvent;

    AtlAxWinInit();
}

Printing::WindowHandle::~WindowHandle()
{
    if(m_pSiteObject)
    {
        m_pSiteObject->Release(); m_pSiteObject = NULL;
    }
}

HRESULT Printing::WindowHandle::PrivateCreateControlEx( LPCOLESTR  lpszName       ,
                                                        HWND       hWnd           ,
                                                        IStream*   pStream        ,
                                                        IUnknown* *ppUnkContainer ,
                                                        IUnknown* *ppUnkControl   ,
                                                        REFIID     iidSink        ,
                                                        IUnknown*  punkSink       )
{
    __HCP_FUNC_ENTRY( "Printing::WindowHandle::PrivateCreateControlEx" );

    HRESULT                   hr;
    CComPtr<IUnknown>         spUnkContainer;
    CComPtr<IUnknown>         spUnkControl;
    CComPtr<IAxWinHostWindow> pAxWindow;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pSiteObject->CreateInstance( &m_pSiteObject )); m_pSiteObject->AddRef();

    // set the print-specific data
    m_pSiteObject->SetMultiTopic   ( m_fMultiTopic             );
    m_pSiteObject->SetPrintFileName( m_szPrintFileName.c_str() );
    m_pSiteObject->SetAbortEvent   ( m_hEvent                  );


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_pSiteObject->QueryInterface( IID_IUnknown, (void**)&spUnkContainer ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, spUnkContainer.QueryInterface( &pAxWindow ));

    hr = pAxWindow->CreateControlEx( CComBSTR( lpszName ), hWnd, pStream, &spUnkControl, iidSink, punkSink );


    __HCP_FUNC_CLEANUP;

    if(ppUnkContainer != NULL) *ppUnkContainer = spUnkContainer.Detach();
    if(ppUnkControl   != NULL) *ppUnkControl   = spUnkControl  .Detach();

    __HCP_FUNC_EXIT(hr);
}

void Printing::WindowHandle::SetMultiTopic( /*[in]*/ bool fMulti )
{
    m_fMultiTopic = fMulti;

    if(m_pSiteObject) m_pSiteObject->SetMultiTopic( fMulti );
}

void Printing::WindowHandle::SetPrintFileName( /*[in]*/ LPCWSTR szPrintFileName )
{
    m_szPrintFileName = szPrintFileName;

    if(m_pSiteObject) m_pSiteObject->SetPrintFileName( szPrintFileName );
}

void Printing::WindowHandle::SetAbortEvent( /*[in]*/ HANDLE hEvent )
{
    m_hEvent = hEvent;

    if(m_pSiteObject) m_pSiteObject->SetAbortEvent( hEvent );
}

bool Printing::WindowHandle::GetAbortState()
{
    return m_pSiteObject ? m_pSiteObject->GetAbortState() : false;
}

BSTR Printing::WindowHandle::GetPrinterName()
{
    return m_pSiteObject ? m_pSiteObject->GetPrinterName() : NULL;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Printing::CDispatchSink::CDispatchSink()
{
	m_hEvent = NULL; // HANDLE m_hEvent;
	                 // CComBSTR m_URL;
}

void Printing::CDispatchSink::SetNotificationEvent( /*[in]*/ HANDLE hEvent )
{
	m_hEvent = hEvent;
}

BSTR Printing::CDispatchSink::GetCurrentURL()
{
	return m_URL;
}

////////////////////////////////////////

STDMETHODIMP Printing::CDispatchSink::GetTypeInfoCount(UINT* pctinfo)
{
    return  E_NOTIMPL;
}

STDMETHODIMP Printing::CDispatchSink::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return  E_NOTIMPL;
}

STDMETHODIMP Printing::CDispatchSink::GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
    return  E_NOTIMPL;
}

STDMETHODIMP Printing::CDispatchSink::Invoke( DISPID      dispidMember ,
                                              REFIID      riid         ,
                                              LCID        lcid         ,
                                              WORD        wFlags       ,
                                              DISPPARAMS* pdispparams  ,
                                              VARIANT*    pvarResult   ,
                                              EXCEPINFO*  pexcepinfo   ,
                                              UINT*       puArgErr     )
{
    HRESULT hr = S_OK;

    // check for NULL
    if(pdispparams)
    {
        switch(dispidMember)
        {
        case DISPID_DOCUMENTCOMPLETE:
			m_URL.Empty();
	
			if(pdispparams->rgvarg != NULL)
			{
				(void)MPC::PutBSTR( m_URL, &pdispparams->rgvarg[0] );
			}

            // signal our doc complete semaphore
            if(m_hEvent)
            {
                ::SetEvent( m_hEvent );
            }
            break;

        default:
            hr = DISP_E_MEMBERNOTFOUND;
            break;
        }
    }
    else
    {
        hr = DISP_E_PARAMNOTFOUND;
    }

    return  hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\printing\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_utils.h>
#include <MPC_xml.h>
#include <MPC_COM.h>

#include <HelpCenter.h>
#include <HelpViewerWrapper.h>
#include <HelpCenterExternal.h>
#include <Printing.h>

#include <winspool.h>

#include <resource.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\asyncdatabase.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    AsyncDatabase.cpp

Abstract:
    This file contains the implementation of the asynchronous database access.

Revision History:
    Davide Massarenti   (Dmassare)  08/13/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

AsynchronousTaxonomyDatabase::NotifyHandle::NotifyHandle()
{
    m_iType  = OfflineCache::ET_INVALID;       // int                        m_iType;
                                               // CComBSTR                   m_bstrID;
                                               //						   
    m_hEvent = NULL;                           // HANDLE                     m_hEvent;
                                               //						   
    m_hr     = HRESULT_FROM_WIN32(ERROR_BUSY); // HRESULT                    m_hr;
    m_pColl  = NULL;                           // CPCHQueryResultCollection* m_pColl;
}

AsynchronousTaxonomyDatabase::NotifyHandle::~NotifyHandle()
{
    Detach();

	MPC::Release( m_pColl );
 
    if(m_hEvent)
    {
        ::CloseHandle( m_hEvent );
    }
}

STDMETHODIMP_(ULONG) AsynchronousTaxonomyDatabase::NotifyHandle::AddRef()
{
    return InternalAddRef();
}

STDMETHODIMP_(ULONG) AsynchronousTaxonomyDatabase::NotifyHandle::Release()
{
    ULONG c = InternalRelease();

    if(c == 0) delete this;

    return c;
}

////////////////////////////////////////

HRESULT AsynchronousTaxonomyDatabase::NotifyHandle::Init()
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::NotifyHandle::Init" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    __MPC_EXIT_IF_CALL_RETURNS_NULL(hr, (m_hEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL )));
    m_fAttached = true;

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void AsynchronousTaxonomyDatabase::NotifyHandle::Bind( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_iType  = iType;
    m_bstrID = szID;

    m_hr = HRESULT_FROM_WIN32(ERROR_BUSY);

    MPC::Release( m_pColl );
}

void AsynchronousTaxonomyDatabase::NotifyHandle::Call( /*[in]*/ QueryStore* qs )
{
    MPC::SmartLock<_ThreadModel> lock( this );

	MPC::Release( m_pColl );

    m_hr = qs ? qs->GetData( &m_pColl ) : E_ABORT;

    //
    // Look ahead all the URLs, to Get all the Copy the items in the remote collection.
    //
	if(m_pColl)
    {
        long lCount;
        long lPos;

        if(SUCCEEDED(m_pColl->get_Count( &lCount )))
		{
			for(lPos=0; lPos<lCount; lPos++)
			{
				CComPtr<CPCHQueryResult> item;

				if(SUCCEEDED(m_pColl->GetItem( lPos, &item )))
				{
					CComBSTR bstrURL;

					if(SUCCEEDED(item->get_TopicURL( &bstrURL )))
					{
						if(STRINGISPRESENT(bstrURL)) (void)HyperLinks::Lookup::s_GLOBAL->Queue( bstrURL );
					}
				}
			}
        }
    }


    if(m_hEvent)
    {
        ::SetEvent( m_hEvent );
    }
}

void AsynchronousTaxonomyDatabase::NotifyHandle::Detach()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    m_fAttached = false;
}

bool AsynchronousTaxonomyDatabase::NotifyHandle::IsAttached()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    return m_fAttached;
}

////////////////////////////////////////

HRESULT AsynchronousTaxonomyDatabase::NotifyHandle::GetData( /*[out]*/ CPCHQueryResultCollection* *pColl )
{
    MPC::SmartLock<_ThreadModel> lock( this );

    if(pColl)
    {
        *pColl = NULL;

        if(SUCCEEDED(m_hr))
        {
            if(m_pColl) (*pColl = m_pColl)->AddRef();
        }
    }

    return m_hr;
}

HRESULT AsynchronousTaxonomyDatabase::NotifyHandle::Wait( /*[in]*/ DWORD dwTimeout )
{
    if(IsAttached())
    {
		for(int pass=0; pass<2; pass++)
		{
			DWORD dwRes;
			DWORD dwWait;

			//
			// On first pass, do a synchronous wait.
			//
			if(pass == 0)
			{
				dwRes = ::WaitForSingleObject( m_hEvent, min( dwTimeout, 200 ) );
			}
			else
			{
				dwRes = MPC::WaitForSingleObject( m_hEvent, dwTimeout );
			}

			if(dwRes == WAIT_OBJECT_0    ||
			   dwRes == WAIT_ABANDONED_0  )
			{
				break;
			}

			if(pass == 1)
			{
				return HRESULT_FROM_WIN32(ERROR_BUSY);
			}
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////

AsynchronousTaxonomyDatabase::Notifier::Notifier()
{
    // List m_lstCallback;
}

AsynchronousTaxonomyDatabase::Notifier::~Notifier()
{
    MPC::ReleaseAll( m_lstCallback );
}

////////////////////

void AsynchronousTaxonomyDatabase::Notifier::Notify( /*[in]*/ QueryStore* qs )
{
    List lst;
    Iter it;


    //
    // Phase 1: copy list, under lock.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        for(it = m_lstCallback.begin(); it != m_lstCallback.end(); it++)
        {
            NotifyHandle* nb = *it;

            if(qs)
            {
                if(qs->m_iType != nb->m_iType || MPC::StrCmp( qs->m_bstrID, nb->m_bstrID )) continue;
            }

            lst.push_back( nb ); nb->AddRef();
        }
    }


    //
    // Phase 2: send the notification.
    //
    for(it = lst.begin(); it != lst.end(); it++)
    {
        NotifyHandle* nb = *it;

        nb->Call  ( qs );
        nb->Detach(    );
    }
    MPC::ReleaseAll( lst );


    //
    // Phase 3: clean list, under lock.
    //
    {
        MPC::SmartLock<_ThreadModel> lock( this );

        for(it = m_lstCallback.begin(); it != m_lstCallback.end();)
        {
            NotifyHandle* nb = *it;

            if(nb->IsAttached() == false)
            {
                m_lstCallback.erase( it ); nb->Release();

                it = m_lstCallback.begin();
            }
            else
            {
                it++;
            }
        }
    }
}

////////////////////

HRESULT AsynchronousTaxonomyDatabase::Notifier::AddNotification( /*[in]*/ QueryStore* qs, /*[in]*/ NotifyHandle* nb )
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::Notifier::AddNotification" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );

    if(nb == NULL)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_OUTOFMEMORY);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, nb->Init());

    nb->Bind( qs->m_iType, qs->m_bstrID );

    m_lstCallback.push_back( nb ); nb->AddRef();
    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

AsynchronousTaxonomyDatabase::QueryStore::QueryStore( /*[in]*/ int iType, /*[in]*/ LPCWSTR szID, /*[in]*/ VARIANT* option )
{
    m_iType  = iType;        // int      		 m_iType;
    m_bstrID = szID;         // CComBSTR 		 m_bstrID;
	                         // CComVariant      m_vOption;
                             //	  	   
    m_fDone  = false;        // bool     		 m_fDone;
    m_hr     = E_INVALIDARG; // HRESULT  		 m_hr;
                             // MPC::CComHGLOBAL m_hgData;
                             // FILETIME 		 m_dLastUsed;

	if(option) m_vOption = *option;
}

AsynchronousTaxonomyDatabase::QueryStore::~QueryStore()
{
	Invalidate();
}

////////////////////

bool AsynchronousTaxonomyDatabase::QueryStore::LessThen( /*[in]*/ QueryStore const &qs ) const
{
    int iCmp = (m_iType - qs.m_iType);

    if(iCmp == 0)
    {
		iCmp = MPC::StrCmp( m_bstrID, qs.m_bstrID );
		if(iCmp == 0)
		{
			switch(m_iType)
			{
			case OfflineCache::ET_LOCATECONTEXT:
			case OfflineCache::ET_SEARCH       :
				{
					bool fHasLeft  = (	 m_vOption.vt == VT_BSTR);
					bool fHasRight = (qs.m_vOption.vt == VT_BSTR);

					if(fHasLeft)
					{
						iCmp = fHasRight ? MPC::StrCmp( m_vOption.bstrVal, qs.m_vOption.bstrVal ) : 1;
					}
					else
					{
						iCmp = fHasRight ? -1 : 0;
					}
  				}
			    break;
			}				
		}
    }
	
    return (iCmp < 0);
}

bool AsynchronousTaxonomyDatabase::QueryStore::NewerThen( /*[in]*/ QueryStore const &qs ) const
{
    return ::CompareFileTime( &m_dLastUsed, &qs.m_dLastUsed ) > 0;
}

////////////////////

HRESULT AsynchronousTaxonomyDatabase::QueryStore::Execute( /*[in]*/ OfflineCache::Handle*           handle ,
                                                           /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent ,
                                                           /*[in]*/ bool                            fForce )
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::QueryStore::Execute" );

    HRESULT                 hr;
    CComPtr<IPCHCollection> pColl;


	__MPC_TRY_BEGIN();

    if(fForce) m_fDone = false;

    if(m_fDone == false)
    {
        DebugLog( L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Start : %s\n", SAFEBSTR( m_bstrID ) );

		DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Start : %s", SAFEBSTR( m_bstrID ) );

        if(handle)
        {
            CComPtr<CPCHQueryResultCollection> coll;

            if(SUCCEEDED((*handle)->Retrieve( m_bstrID, m_iType, &coll )))
            {
				DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Cache Hit" );

                pColl = coll;
            }
        }

        if(!pColl && parent)
        {
            CComPtr<IPCHTaxonomyDatabase> db;

			DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Get DB" );
            __MPC_EXIT_IF_METHOD_FAILS(hr, parent->EnsureDirectConnection( db ));
			DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Got DB" );

            switch(m_iType)
            {
            case OfflineCache::ET_NODE             		: hr = db->LookupNode    	   ( m_bstrID,                &pColl ); break;
            case OfflineCache::ET_SUBNODES         		: hr = db->LookupSubNodes	   ( m_bstrID, VARIANT_FALSE, &pColl ); break;
            case OfflineCache::ET_SUBNODES_VISIBLE 		: hr = db->LookupSubNodes	   ( m_bstrID, VARIANT_TRUE , &pColl ); break;
            case OfflineCache::ET_NODESANDTOPICS        : hr = db->LookupNodesAndTopics( m_bstrID, VARIANT_FALSE, &pColl ); break;
            case OfflineCache::ET_NODESANDTOPICS_VISIBLE: hr = db->LookupNodesAndTopics( m_bstrID, VARIANT_TRUE , &pColl ); break;
            case OfflineCache::ET_TOPICS           		: hr = db->LookupTopics  	   ( m_bstrID, VARIANT_FALSE, &pColl ); break;
            case OfflineCache::ET_TOPICS_VISIBLE   		: hr = db->LookupTopics  	   ( m_bstrID, VARIANT_TRUE , &pColl ); break;
            case OfflineCache::ET_LOCATECONTEXT   		: hr = db->LocateContext 	   ( m_bstrID, m_vOption    , &pColl ); break;
            case OfflineCache::ET_SEARCH           		: hr = db->KeywordSearch 	   ( m_bstrID, m_vOption    , &pColl ); break;
            case OfflineCache::ET_NODES_RECURSIVE  		: hr = db->GatherNodes   	   ( m_bstrID, VARIANT_TRUE , &pColl ); break;
            case OfflineCache::ET_TOPICS_RECURSIVE 		: hr = db->GatherTopics  	   ( m_bstrID, VARIANT_TRUE , &pColl ); break;
            default                                		: hr = E_INVALIDARG;
            }
			DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Query Done" );
        }
    }

    if(pColl)
    {
        CComPtr<IPersistStream> persist;
        CComPtr<IStream>        stream;


		DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Local Copy Start" );

        __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->QueryInterface( IID_IPersistStream, (void**)&persist ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_hgData.NewStream( &stream        ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, persist->Save     (  stream, FALSE ));

		DEBUG_AppendPerf( DEBUG_PERF_QUERIES, L"AsynchronousTaxonomyDatabase::QueryStore::Execute - Local Copy Done" );
    }

    ::GetSystemTimeAsFileTime( &m_dLastUsed );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

    if(m_fDone == false)
    {
        m_hr    = hr;
        m_fDone = true;
    }

    __HCP_FUNC_EXIT(hr);
}

HRESULT AsynchronousTaxonomyDatabase::QueryStore::GetData( /*[out]*/ CPCHQueryResultCollection* *ppC )
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::QueryStore::GetData" );

    HRESULT                            hr;
    CComPtr<CPCHQueryResultCollection> pColl;
    CComPtr<IPersistStream>            persist;
    CComPtr<IStream>                   stream;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(ppC,NULL);
    __MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &pColl ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, pColl->QueryInterface( IID_IPersistStream, (void**)&persist  ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, m_hgData.GetAsStream( &stream, /*fClone*/false ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, persist->Load       (  stream                  ));

    *ppC = pColl.Detach();

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void AsynchronousTaxonomyDatabase::QueryStore::Invalidate()
{
    m_hgData.Release();

	m_fDone = false;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

bool AsynchronousTaxonomyDatabase::Engine::CompareQueryStores::operator()( /*[in]*/ const QueryStore *left, /*[in]*/ const QueryStore *right ) const
{
    if(left)
    {
        return right ? left->LessThen( *right ) : true;
    }

    return false;
}

AsynchronousTaxonomyDatabase::Engine::Engine( /*[in]*/ CPCHProxy_IPCHTaxonomyDatabase* parent )
{
    m_parent = parent; // CPCHProxy_IPCHTaxonomyDatabase* m_parent;
                       // Set                             m_setQueries;
                       // Notifier                        m_notifier;
}

AsynchronousTaxonomyDatabase::Engine::~Engine()
{
    Passivate();
}

////////////////////

void AsynchronousTaxonomyDatabase::Engine::Passivate()
{
    Thread_Wait();

    MPC::CallDestructorForAll( m_setQueries );
}

void AsynchronousTaxonomyDatabase::Engine::RefreshConnection()
{
    //
    // The connection to the database has changed, so we need to flush all the cached queries...
    //
    InvalidateQueries();

	Thread_Signal();
}

////////////////////////////////////////

bool AsynchronousTaxonomyDatabase::Engine::LookupCache( /*[out]*/ OfflineCache::Handle& handle )
{
    if(m_parent && m_parent->Parent())
    {
        CComPtr<CPCHProxy_IPCHUserSettings2> us;

        if(SUCCEEDED(m_parent->Parent()->GetUserSettings2( &us )))
        {
            if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Locate( us->THS(), handle )))
            {
                return true;
            }
        }
    }

    return false;
}

void AsynchronousTaxonomyDatabase::Engine::InvalidateQueries()
{
    MPC::SmartLock<_ThreadModel> lock( this );
    Iter                         it;

    for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
    {
        QueryStore* qs = *it;

		qs->Invalidate();
	}
}

HRESULT AsynchronousTaxonomyDatabase::Engine::Run()
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::Engine::Run" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    while(Thread_IsAborted() == false)
    {
        OfflineCache::Handle handle;
        bool                 fValidCache = false;
        bool                 fInit  	 = false;
        bool                 fSleep 	 = true;
        Iter                 it;


        //
        // Look for the first query store not ready and execute it.
        //
        for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
        {
            QueryStore* qs = *it;

            if(qs->m_fDone == false)
            {
                if(fInit == false)
                {
                    __MPC_PROTECT( fValidCache = LookupCache( handle ) );

                    fInit = true;
                }

				lock = NULL;
                qs->Execute( fValidCache ? &handle : NULL, m_parent );
				lock = this;

                fSleep = false;
                break;
            }
        }


        //
        // Notify all the query stores that are ready.
        //
        if(it == m_setQueries.end())
        {
            for(it = m_setQueries.begin(); it != m_setQueries.end(); it++)
            {
                QueryStore* qs = *it;

                if(qs->m_fDone)
                {
                    m_notifier.Notify( qs );
                }
            }
        }


        if(fSleep)
        {
            lock = NULL;
            Thread_WaitForEvents( NULL, INFINITE );
            lock = this;
        }
    }

    hr = S_OK;


    m_notifier.Notify( NULL );

    Thread_Abort();

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////

HRESULT AsynchronousTaxonomyDatabase::Engine::ExecuteQuery( /*[in]*/ int           iType  ,
															/*[in]*/ LPCWSTR       szID   ,
															/*[in]*/ VARIANT*      option ,
															/*[in]*/ NotifyHandle* nb     )
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::Engine::ExecuteQuery" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );
    QueryStore*                  qsNew = NULL;
    QueryStore*                  qs;
	Iter                         it;
	
    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(m_parent);
        __MPC_PARAMCHECK_NOTNULL(nb);
    __MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_ALLOC_FAILS(hr, qsNew, new QueryStore( iType, szID, option ));

	it = m_setQueries.find( qsNew );
	if(it == m_setQueries.end())
	{
		qs = qsNew;

		m_setQueries.insert( qsNew ); qsNew = NULL;
	}
	else
	{
		qs = *it;
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_notifier.AddNotification( qs, nb ));

    if(Thread_IsRunning() == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, Run, NULL ));
    }
    else
    {
        Thread_Signal();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	delete qsNew;

    __HCP_FUNC_EXIT(hr);
}

HRESULT AsynchronousTaxonomyDatabase::Engine::ExecuteQuery( /*[in]*/ 		  int                         iType  ,
															/*[in]*/ 		  LPCWSTR                     szID   ,
															/*[in]*/ 		  VARIANT*                    option ,
															/*[out, retval]*/ CPCHQueryResultCollection* *ppC    )
{
    __HCP_FUNC_ENTRY( "AsynchronousTaxonomyDatabase::Engine::ExecuteQuery" );

    HRESULT       hr;
    NotifyHandle* nb = new NotifyHandle(); if(nb) nb->AddRef();


    __MPC_EXIT_IF_METHOD_FAILS(hr, ExecuteQuery( iType, szID, option, nb ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, nb->Wait());

    __MPC_EXIT_IF_METHOD_FAILS(hr, nb->GetData( ppC ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(nb) nb->Release();

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\service.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Service.cpp

Abstract:
    This file contains the implementation of the client-side proxy for IPCHService.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////

CPCHProxy_IPCHService::CPCHProxy_IPCHService()
{
					 			   // CPCHSecurityHandle                     m_SecurityHandle;
    m_parent = NULL; 			   // CPCHHelpCenterExternal*                m_parent;
					 			   //
					 			   // MPC::CComSafeAutoCriticalSection       m_DirectLock;
					 			   // MPC::CComPtrThreadNeutral<IPCHService> m_Direct_Service;
	m_fContentStoreTested = false; // bool                                   m_fContentStoreTested;
					 			   //
	m_Utility = NULL;              // CPCHProxy_IPCHUtility* 		         m_Utility;
}

CPCHProxy_IPCHService::~CPCHProxy_IPCHService()
{
    Passivate();
}

////////////////////

HRESULT CPCHProxy_IPCHService::ConnectToParent( /*[in]*/ CPCHHelpCenterExternal* parent )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHService::ConnectToParent" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(parent);
    __MPC_PARAMCHECK_END();


    m_parent = parent;
    m_SecurityHandle.Initialize( parent, (IPCHService*)this );

	//
	// If the service is already running, it will respond to CLSID_PCHServiceReal, so let's try to connect through it, but ignore failure.
	//
	{
		CComPtr<IClassFactory> fact;
		CComQIPtr<IPCHService> svc;

		(void)::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact );

		if((svc = fact))
		{
			CComPtr<IPCHService> svcReal;

			__MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( svcReal, false ));
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHProxy_IPCHService::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

	if(m_Utility)
	{
        m_Utility->Passivate();

		MPC::Release2<IPCHUtility>( m_Utility );
	}

    m_Direct_Service.Release();

    m_SecurityHandle.Passivate();
    m_parent = NULL;
}

HRESULT CPCHProxy_IPCHService::EnsureDirectConnection( /*[out]*/ CComPtr<IPCHService>& svc, /*[in]*/ bool fRefresh )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHService::EnsureDirectConnection" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );


	if(fRefresh) m_Direct_Service.Release();

	svc.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, m_Direct_Service.Access( &svc ));
    if(!svc)
    {
		DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHService::EnsureDirectConnection - IN" );

        if(FAILED(hr = ::CoCreateInstance( CLSID_PCHService, NULL, CLSCTX_ALL, IID_IPCHService, (void**)&svc )))
		{
			MPC::RegKey rk;

			rk.SetRoot	( HKEY_CLASSES_ROOT, KEY_ALL_ACCESS                                );
			rk.Attach 	( L"CLSID\\{00020420-0000-0000-C000-000000000046}\\InprocServer32" );
			rk.del_Value( L"InprocServer32"                                                );

			__MPC_EXIT_IF_METHOD_FAILS(hr, ::CoCreateInstance( CLSID_PCHService, NULL, CLSCTX_ALL, IID_IPCHService, (void**)&svc ));
		}
		m_Direct_Service = svc;

		DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHService::EnsureDirectConnection - OUT" );

		if(!svc)
		{
			__MPC_SET_ERROR_AND_EXIT(hr, E_HANDLE);
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHService::EnsureContentStore()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHService::EnsureContentStore" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );


	if(m_fContentStoreTested == false)
	{
		CComPtr<IPCHService> svc;
		VARIANT_BOOL         fTrusted;

		lock = NULL;
		__MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( svc ));
		lock = &m_DirectLock;

		__MPC_EXIT_IF_METHOD_FAILS(hr, svc->IsTrusted( CComBSTR( L"hcp://system" ), &fTrusted ));

		m_fContentStoreTested = true;
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHService::GetUtility( /*[out]*/ CPCHProxy_IPCHUtility* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHService::GetUtility" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_Utility == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_Utility ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_Utility->ConnectToParent( this, m_SecurityHandle ));
	}

    hr = S_OK;


	__HCP_FUNC_CLEANUP;

	if(FAILED(hr)) MPC::Release2<IPCHUtility>( m_Utility );

	(void)MPC::CopyTo2<IPCHUtility>( m_Utility, pVal );

	__HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHService::CreateScriptWrapper( /*[in]*/  REFCLSID   rclsid   ,
														 /*[in]*/  BSTR 	  bstrCode ,
														 /*[in]*/  BSTR 	  bstrURL  ,
														 /*[out]*/ IUnknown* *ppObj    )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHService::CreateScriptWrapper",hr,ppObj);

	CComPtr<IPCHService> svc;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( svc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, svc->CreateScriptWrapper( rclsid, bstrCode, bstrURL, ppObj ));

    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_)
#define AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED_

#include <module.h>

//
// From HelpServiceTypeLib.idl
//
#include <HelpServiceTypeLib.h>

//
// From HelpCenterTypeLib.idl
//
#include <HelpCenterTypeLib.h>

//
// For debug trace
//
#include <HCP_trace.h>
#include <MPC_COM.h>
#include <MPC_security.h>
#include <MPC_utils.h>
#include <MPC_html.h>
#include <MPC_xml.h>

#include <HelpCenter.h>
#include <HelpCenterExternal.h>
#include <NameSpace_Impl.h>
#include <Favorites.h>
#include <ServiceProxy.h>

#include <resource.h>

////////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__412B7974_2F00_11D3_9A30_00C04F72D6C5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\common.inc ===
#
# Build unicode
#
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE

#
# Enable debug OM 
#
C_DEFINES = $(C_DEFINES) -DDEBUG_OM_ENABLED

#
# Get strict windows type checking.
#
C_DEFINES = $(C_DEFINES) -DSTRICT

#
# Make sure we include only W95 and NT4 windows header file info.
#
#WIN32_WINNT_VERSION=0x0400
#WIN32_WIN95_VERSION=0x0400

!ifdef PROJECT_ROOT
! INCLUDE $(PROJECT_ROOT)\pchealth\build\paths.all
!endif

#
# Define common paths for use in sources files
#

# Allow MARS_DIR to be set from the environment so we can override the default
!if !defined(MARS_DIR)
MARS_DIR        = $(INETROOT)\pchmars
!endif
MARS_INC        = $(MARS_DIR)\inc
MARS_GEN        = $(MARS_INC)\$(O)
MARS_ATL        = $(SDK_INC_PATH)\atl$(ATL_VER)
MARS_UUID       = $(MARS_DIR)\uuid\$(O)

#
# Common includes path
#
INCLUDES = .;$(SHELL_INC_PATH);$(MARS_INC);$(MARS_GEN);$(MARS_ATL);$(INCLUDES)

#
# Build voodoo so makefile.inc can be used
#

NTTARGETFILE1   = $(NTTARGETFILE1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\idl\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\setofhelptopics.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UserSettings.cpp

Abstract:
    This file contains the implementation of the client-side proxy for
    IPCHUserSettings2 and IPCHUserSettings.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <TaxonomyDatabase.h>

#define PROXY_METHOD(func,meth)                                             \
    __HCP_FUNC_ENTRY( func );                                               \
                                                                            \
    HRESULT                      hr;                                        \
    CComPtr<IPCHSetOfHelpTopics> sht;                                       \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));          \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, sht->##meth());                          \
                                                                            \
	hr = S_OK;                                                              \
																			\
	__HCP_FUNC_CLEANUP;                                                     \
																			\
	__HCP_FUNC_EXIT(hr)

#define PROXY_PROPERTY_PUT(func,meth,newVal)                                \
    __HCP_BEGIN_PROPERTY_PUT__NOLOCK(func,hr);                              \
                                                                            \
    CComPtr<IPCHSetOfHelpTopics> sht;                                       \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));          \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, sht->##meth( newVal ));                  \
                                                                            \
    __HCP_END_PROPERTY(hr)

#define PROXY_PROPERTY_GET(func,meth,pVal)                                  \
    __HCP_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal);                         \
                                                                            \
    CComPtr<IPCHSetOfHelpTopics> sht;                                       \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));          \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, sht->##meth( pVal ));                    \
                                                                            \
    __HCP_END_PROPERTY(hr)

#define PROXY_PROPERTY_GET2(func,meth,pVal,value)                           \
    __HCP_BEGIN_PROPERTY_GET2__NOLOCK(func,hr,pVal,value);                  \
                                                                            \
    CComPtr<IPCHSetOfHelpTopics> sht;                                       \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));          \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, sht->##meth( pVal ));                    \
                                                                            \
    __HCP_END_PROPERTY(hr)

////////////////////////////////////////////////////////////////////////////////

CPCHProxy_IPCHSetOfHelpTopics::CPCHProxy_IPCHSetOfHelpTopics()
{
    m_parent   = NULL;  // CPCHProxy_IPCHUserSettings2*                   m_parent;
	                    // 
                        // MPC::CComPtrThreadNeutral<IPCHSetOfHelpTopics> m_Direct_SKU;
	m_fMachine = false; // bool                                           m_fMachine;
}

CPCHProxy_IPCHSetOfHelpTopics::~CPCHProxy_IPCHSetOfHelpTopics()
{
    Passivate();
}

////////////////////

HRESULT CPCHProxy_IPCHSetOfHelpTopics::ConnectToParent( /*[in]*/ CPCHProxy_IPCHUserSettings2* parent, /*[in]*/ bool fMachine )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHSetOfHelpTopics::ConnectToParent" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(parent);
    __MPC_PARAMCHECK_END();


    m_parent   = parent;
	m_fMachine = fMachine;

    //
    // If the parent is connected directly, let's do the same.
    //
    if(parent->IsConnected())
    {
		CComPtr<IPCHSetOfHelpTopics> sht;

		__MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHProxy_IPCHSetOfHelpTopics::Passivate()
{
    m_Direct_SKU.Release();

    m_parent = NULL;
}

HRESULT CPCHProxy_IPCHSetOfHelpTopics::EnsureDirectConnection( /*[out]*/ CComPtr<IPCHSetOfHelpTopics>& sht, /*[in]*/ bool fRefresh )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHSetOfHelpTopics::EnsureDirectConnection" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );


    if(fRefresh) m_Direct_SKU.Release();

    sht.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, m_Direct_SKU.Access( &sht ));
    if(!sht)
    {
        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHSetOfHelpTopics::EnsureDirectConnection - IN" );

        if(m_parent)
        {
            CComPtr<IPCHUserSettings> us;

			lock = NULL;
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsureDirectConnection( us ));
			lock = &m_DirectLock;

			if(m_fMachine)
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, us->get_MachineSKU( &sht ));
			}
			else
			{
				__MPC_EXIT_IF_METHOD_FAILS(hr, us->get_CurrentSKU( &sht ));
			}

            m_Direct_SKU = sht;
        }

        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHSetOfHelpTopics::EnsureDirectConnection - OUT" );

        if(!sht)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_HANDLE);
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_SKU( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHSetOfHelpTopics::get_SKU",hr,pVal);

	if(IsConnected())
	{
        CComPtr<IPCHSetOfHelpTopics> sht;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));

		__MPC_EXIT_IF_METHOD_FAILS(hr, sht->get_SKU( pVal ));
	}
	else if(m_parent)
	{
		Taxonomy::HelpSet& ths = m_parent->THS();

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( (m_fMachine ? ths.m_strSKU_Machine : ths.m_strSKU).c_str(), pVal ));
	}

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_Language( /*[out, retval]*/ long *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHSetOfHelpTopics::get_SKU",hr,pVal);

	if(IsConnected())
	{
        CComPtr<IPCHSetOfHelpTopics> sht;

		lock = NULL;
        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));
		lock = this;

		__MPC_EXIT_IF_METHOD_FAILS(hr, sht->get_Language( pVal ));
	}
	else if(m_parent)
	{
		Taxonomy::HelpSet& ths = m_parent->THS();

		*pVal = (m_fMachine ? ths.m_lLCID_Machine : ths.m_lLCID);
	}

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_DisplayName( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHSetOfHelpTopics::get_DisplayName",hr,pVal);

	if(IsConnected())
	{
        CComPtr<IPCHSetOfHelpTopics> sht;

		lock = NULL;
        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( sht ));
		lock = this;

		__MPC_EXIT_IF_METHOD_FAILS(hr, sht->get_DisplayName( pVal ));
	}
	else if(m_parent)
	{
		Taxonomy::Instance& inst = (m_fMachine ? m_parent->MachineInstance() : m_parent->CurrentInstance());

		__MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsureInSync());

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( inst.m_strDisplayName.c_str(), pVal ));
	}

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_ProductID( /*[out, retval]*/ BSTR *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_ProductID", get_ProductID, pVal );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_Version( /*[out, retval]*/ BSTR *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_Location", get_Location, pVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_Location( /*[out, retval]*/ BSTR *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_Location", get_Location, pVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_Exported( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_Exported", get_Exported, pVal );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::put_Exported( /*[in]*/ VARIANT_BOOL newVal )
{
    PROXY_PROPERTY_PUT( "CPCHProxy_IPCHSetOfHelpTopics::put_Exported", put_Exported, newVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::put_onStatusChange( /*[in]*/ IDispatch* function )
{
    PROXY_PROPERTY_PUT( "CPCHProxy_IPCHSetOfHelpTopics::put_onStatusChange", put_onStatusChange, function );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_Status( /*[out, retval]*/ SHT_STATUS *pVal )
{
    PROXY_PROPERTY_GET2( "CPCHProxy_IPCHSetOfHelpTopics::get_Status", get_Status, pVal, SHT_NOTACTIVE );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_ErrorCode( /*[out, retval]*/ long *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_ErrorCode", get_ErrorCode, pVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_IsMachineHelp( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_IsMachineHelp", get_IsMachineHelp, pVal );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_IsInstalled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_IsInstalled", get_IsInstalled, pVal );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_CanInstall( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_CanInstall", get_CanInstall, pVal );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::get_CanUninstall( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    PROXY_PROPERTY_GET( "CPCHProxy_IPCHSetOfHelpTopics::get_CanUninstall", get_CanUninstall, pVal );
}

////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::Install()
{
	PROXY_METHOD( "CPCHProxy_IPCHSetOfHelpTopics::Install", Install );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::Uninstall()
{
	PROXY_METHOD( "CPCHProxy_IPCHSetOfHelpTopics::Uninstall", Uninstall );
}

STDMETHODIMP CPCHProxy_IPCHSetOfHelpTopics::Abort()
{
	PROXY_METHOD( "CPCHProxy_IPCHSetOfHelpTopics::Abort", Abort );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\utility.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Utility.cpp

Abstract:
    This file contains the implementation of the client-side proxy for IPCHUtility.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

    Kalyani Narlanka    (KalyaniN)  03/15/01
        Moved Incident and Encryption Objects from HelpService to HelpCtr to improve Perf.

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

#define PROXY_PROPERTY_GET(func,meth,pVal)                                  \
    __HCP_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal);                         \
                                                                            \
    CComPtr<IPCHUtility> util;                                              \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( util ));         \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, util->##meth( pVal ));                   \
                                                                            \
    __HCP_END_PROPERTY(hr)

#define PROXY_PROPERTY_GET1(func,meth,a,pVal)                               \
    __HCP_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal);                         \
                                                                            \
    CComPtr<IPCHUtility> util;                                              \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( util ));         \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, util->##meth( a, pVal ));                \
                                                                            \
    __HCP_END_PROPERTY(hr)

#define PROXY_PROPERTY_GET2(func,meth,a,b,pVal)                             \
    __HCP_BEGIN_PROPERTY_GET__NOLOCK(func,hr,pVal);                         \
                                                                            \
    CComPtr<IPCHUtility> util;                                              \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( util ));         \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, util->##meth( a, b, pVal ));             \
                                                                            \
    __HCP_END_PROPERTY(hr)

#define PROXY_PROPERTY_GET3(func,meth,a,b,c,d,pVal)                         \
    __HCP_BEGIN_PROPERTY_GET(func,hr,pVal);                                 \
                                                                            \
    CComPtr<IPCHUtility> util;                                              \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( util ));         \
                                                                            \
    __MPC_EXIT_IF_METHOD_FAILS(hr, util->##meth( a, b, c, d, pVal ));       \
                                                                            \
    __HCP_END_PROPERTY(hr)

////////////////////////////////////////////////////////////////////////////////

CPCHProxy_IPCHUtility::CPCHProxy_IPCHUtility()
{
                               // CPCHSecurityHandle                      m_SecurityHandle;
    m_parent           = NULL; // CPCHProxy_IPCHService*                  m_parent;
                               //
                               // MPC::CComPtrThreadNeutral<IPCHUtility>  m_Direct_Utility;
                               //
    m_UserSettings2    = NULL; // CPCHProxy_IPCHUserSettings2*            m_UserSettings2;
    m_TaxonomyDatabase = NULL; // CPCHProxy_IPCHTaxonomyDatabase*         m_TaxonomyDatabase;
}

CPCHProxy_IPCHUtility::~CPCHProxy_IPCHUtility()
{
    Passivate();
}

////////////////////

HRESULT CPCHProxy_IPCHUtility::ConnectToParent( /*[in]*/ CPCHProxy_IPCHService* parent, /*[in]*/ CPCHHelpCenterExternal* ext )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::ConnectToParent" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(parent);
    __MPC_PARAMCHECK_END();


    m_parent = parent;
    m_SecurityHandle.Initialize( ext, (IPCHUtility*)this );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHProxy_IPCHUtility::Passivate()
{
    MPC::SmartLock<_ThreadModel> lock( this );

    if(m_UserSettings2)
    {
        m_UserSettings2->Passivate();

        MPC::Release2<IPCHUserSettings2>( m_UserSettings2 );
    }

    if(m_TaxonomyDatabase)
    {
        m_TaxonomyDatabase->Passivate();

        MPC::Release2<IPCHTaxonomyDatabase>( m_TaxonomyDatabase );
    }

    m_Direct_Utility.Release();

    m_SecurityHandle.Passivate();
    m_parent = NULL;
}

HRESULT CPCHProxy_IPCHUtility::EnsureDirectConnection( /*[out]*/ CComPtr<IPCHUtility>& util, /*[in]*/ bool fRefresh )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::EnsureDirectConnection" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );


    if(fRefresh) m_Direct_Utility.Release();

    util.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, m_Direct_Utility.Access( &util ));
    if(!util)
    {
        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHUtility::EnsureDirectConnection - IN" );

        if(m_parent)
        {
            CComPtr<IPCHService> svc;

            lock = NULL;
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsureDirectConnection( svc ));
            lock = &m_DirectLock;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetUserSettings2());

            //
            // First try with the last user settings, then fall back to machine default.
            //
            if(FAILED(hr = svc->Utility( CComBSTR( m_UserSettings2->THS().GetSKU() ), m_UserSettings2->THS().GetLanguage(), &util )) || !util)
            {
                __MPC_EXIT_IF_METHOD_FAILS(hr, svc->Utility( NULL, 0, &util ));
            }

            m_Direct_Utility = util;

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings2->EnsureInSync());
        }

        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHUtility::EnsureDirectConnection - OUT" );

        if(!util)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_HANDLE);
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUtility::GetUserSettings2( /*[out]*/ CPCHProxy_IPCHUserSettings2* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::GetUserSettings2" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_UserSettings2 == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_UserSettings2 ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings2->ConnectToParent( this, m_SecurityHandle ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) MPC::Release2<IPCHUserSettings2>( m_UserSettings2 );

    (void)MPC::CopyTo2<IPCHUserSettings2>( m_UserSettings2, pVal );

    __HCP_FUNC_EXIT(hr);
}


HRESULT CPCHProxy_IPCHUtility::GetDatabase( /*[out]*/ CPCHProxy_IPCHTaxonomyDatabase* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::GetDatabase" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_TaxonomyDatabase == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_TaxonomyDatabase ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_TaxonomyDatabase->ConnectToParent( this, m_SecurityHandle ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) MPC::Release2<IPCHTaxonomyDatabase>( m_TaxonomyDatabase );

    (void)MPC::CopyTo2<IPCHTaxonomyDatabase>( m_TaxonomyDatabase, pVal );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHUtility::get_UserSettings( /*[out, retval]*/ IPCHUserSettings* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUtility::get_UserSettings",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetUserSettings2());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_UserSettings2->QueryInterface( IID_IPCHUserSettings, (void**)pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUtility::get_Channels( /*[out, retval]*/ ISAFReg* *pVal )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::get_Channels",get_Channels,pVal);
}

STDMETHODIMP CPCHProxy_IPCHUtility::get_Security( /*[out, retval]*/ IPCHSecurity* *pVal )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::get_Security",get_Security,pVal);
}

STDMETHODIMP CPCHProxy_IPCHUtility::get_Database( /*[out, retval]*/ IPCHTaxonomyDatabase* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUtility::get_UserSettings",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetDatabase());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_TaxonomyDatabase->QueryInterface( IID_IPCHTaxonomyDatabase, (void**)pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUtility::FormatError( /*[in         ]*/ VARIANT  vError ,
                                                 /*[out, retval]*/ BSTR    *pVal   )
{
    PROXY_PROPERTY_GET1("CPCHProxy_IPCHUtility::FormatError",FormatError,vError,pVal);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_SearchEngineMgr( /*[out, retval]*/ IPCHSEManager* *ppSE )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::CreateObject_SearchEngineMgr",CreateObject_SearchEngineMgr,ppSE);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_DataCollection( /*[out, retval]*/ ISAFDataCollection* *ppDC )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::CreateObject_DataCollection",CreateObject_DataCollection,ppDC);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_Cabinet( /*[out, retval]*/ ISAFCabinet* *ppCB )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::CreateObject_Cabinet",CreateObject_Cabinet,ppCB);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_Encryption( /*[out, retval]*/ ISAFEncrypt* *ppEn )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::CreateObject_Encryption",CreateObject_Encryption,ppEn);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_Channel( /*[in]*/          BSTR          bstrVendorID  ,
                                                          /*[in]*/          BSTR          bstrProductID ,
                                                          /*[out, retval]*/ ISAFChannel* *ppCh          )
{
    PROXY_PROPERTY_GET2("CPCHProxy_IPCHUtility::CreateObject_Channel",CreateObject_Channel,bstrVendorID,bstrProductID,ppCh);
}



STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_RemoteDesktopConnection( /*[out, retval]*/ ISAFRemoteDesktopConnection* *ppRDC )
{
    PROXY_PROPERTY_GET("CPCHProxy_IPCHUtility::CreateObject_RemoteDesktopConnection",CreateObject_RemoteDesktopConnection,ppRDC);
}

STDMETHODIMP CPCHProxy_IPCHUtility::CreateObject_RemoteDesktopSession( /*[in]*/          REMOTE_DESKTOP_SHARING_CLASS  sharingClass        ,
                                                                       /*[in]*/          long                          lTimeout            ,
                                                                       /*[in]*/          BSTR                          bstrConnectionParms ,
                                                                       /*[in]*/          BSTR                          bstrUserHelpBlob    ,
                                                                       /*[out, retval]*/ ISAFRemoteDesktopSession*    *ppRCS               )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::CreateObject_RemoteDesktopSession" );

    HRESULT                hr;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;

    //
    // This is handled in a special way.
    //
    // Instead of using the implementation inside HelpSvc, we QI the PCHSVC broker and then forward the call to it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact ));

    if((disp = fact))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, disp->CreateObject_RemoteDesktopSession( sharingClass, lTimeout, bstrConnectionParms, bstrUserHelpBlob, ppRCS ));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUtility::ConnectToExpert( /*[in]         */ BSTR  bstrExpertConnectParm ,
                                                     /*[in]         */ LONG  lTimeout              ,
                                                     /*[out, retval]*/ LONG *lSafErrorCode         )

{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::ConnectToExpert" );

    HRESULT                hr;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;

    //
    // This is handled in a special way.
    //
    // Instead of using the implementation inside HelpSvc, we QI the PCHSVC broker and then forward the call to it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact ));

    if((disp = fact))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, disp->ConnectToExpert( bstrExpertConnectParm, lTimeout, lSafErrorCode));
    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUtility::SwitchDesktopMode( /*[in]*/ int nMode   ,
                                                       /*[in]*/ int nRAType )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUtility::ConnectToExpert" );

    HRESULT                hr;
    CComPtr<IClassFactory> fact;
    CComQIPtr<IPCHUtility> disp;

    //
    // This is handled in a special way.
    //
    // Instead of using the implementation inside HelpSvc, we QI the PCHSVC broker and then forward the call to it.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::CoGetClassObject( CLSID_PCHService, CLSCTX_ALL, NULL, IID_IClassFactory, (void**)&fact ));

    if((disp = fact))
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, disp->SwitchDesktopMode (nMode, nRAType));

    }
    else
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_NOINTERFACE);
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\usersettings.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UserSettings.cpp

Abstract:
    This file contains the implementation of the client-side proxy for
    IPCHUserSettings2 and IPCHUserSettings.

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

#include <TaxonomyDatabase.h>

#include <shlobj.h>
#include <shlobjp.h>
#include <shldisp.h>

/////////////////////////////////////////////////////////////////////////////

static HRESULT local_GetInstance( /*[in]*/ CComPtr<IPCHSetOfHelpTopics>& sht  , 
								  /*[in]*/ Taxonomy::Instance&           inst )
{
    __HCP_FUNC_ENTRY( "local_GetInstance" );

    HRESULT                 hr;
	LARGE_INTEGER    		liFilePos = { 0, 0 };
	CComPtr<IStream> 		stream;
	CComPtr<IPersistStream> persist;


	__MPC_EXIT_IF_METHOD_FAILS(hr, sht.QueryInterface( &persist ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, ::CreateStreamOnHGlobal( NULL, TRUE, &stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, persist->Save( stream, FALSE ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream->Seek( liFilePos, STREAM_SEEK_SET, NULL ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, inst.LoadFromStream( stream ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

CPCHProxy_IPCHUserSettings2::CPCHProxy_IPCHUserSettings2()
{
                             // CPCHSecurityHandle                          m_SecurityHandle;
    m_parent        = NULL;  // CPCHProxy_IPCHUtility*                      m_parent;
                             //
                             // MPC::CComPtrThreadNeutral<IPCHUserSettings> m_Direct_UserSettings;
                             //
    m_MachineSKU    = NULL;  // CPCHProxy_IPCHSetOfHelpTopics*              m_MachineSKU;
    m_CurrentSKU    = NULL;  // CPCHProxy_IPCHSetOfHelpTopics*              m_CurrentSKU;
                             //	Taxonomy::HelpSet                           m_ths;
                             // CComBSTR                                    m_bstrScope;
                             //
    m_fReady        = false; // bool                                        m_fReady;
                             //	Taxonomy::Instance                          m_instMachine;
                             //	Taxonomy::Instance                          m_instCurrent;
                             //
    m_News_fDone    = false; // bool                                        m_News_fDone;
    m_News_fEnabled = false; // bool                                        m_News_fEnabled;
                             // MPC::CComPtrThreadNeutral<IUnknown>         m_News_xmlData;
}

CPCHProxy_IPCHUserSettings2::~CPCHProxy_IPCHUserSettings2()
{
    Thread_Wait();

    Passivate();
}

////////////////////

HRESULT CPCHProxy_IPCHUserSettings2::ConnectToParent( /*[in]*/ CPCHProxy_IPCHUtility* parent, /*[in]*/ CPCHHelpCenterExternal* ext )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::ConnectToParent" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(parent);
    __MPC_PARAMCHECK_END();


    m_parent = parent;
    m_SecurityHandle.Initialize( ext, (IPCHUserSettings2*)this );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHProxy_IPCHUserSettings2::Passivate()
{
    m_Direct_UserSettings.Release();

    MPC::Release( m_CurrentSKU );
    MPC::Release( m_MachineSKU );

    m_SecurityHandle.Passivate();
    m_parent = NULL;
}

HRESULT CPCHProxy_IPCHUserSettings2::EnsureDirectConnection( /*[out]*/ CComPtr<IPCHUserSettings>& us, /*[in]*/ bool fRefresh )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::EnsureDirectConnection" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );


    if(fRefresh) m_Direct_UserSettings.Release();

    us.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, m_Direct_UserSettings.Access( &us ));
    if(!us)
    {
        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHUserSettings2::EnsureDirectConnection - IN" );

        if(m_parent)
        {
            CComPtr<IPCHUtility>         util;
			CComPtr<IPCHSetOfHelpTopics> sht;

			MPC::Release( m_MachineSKU );

			lock = NULL;
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsureDirectConnection( util ));
			lock = &m_DirectLock;

            __MPC_EXIT_IF_METHOD_FAILS(hr, util->get_UserSettings( &us ));

            m_Direct_UserSettings = us;


            //
            // Initialize Machine data.
            //
			__MPC_EXIT_IF_METHOD_FAILS(hr, us->get_MachineSKU( &sht                ));
			__MPC_EXIT_IF_METHOD_FAILS(hr, local_GetInstance (  sht, m_instMachine ));

			__MPC_EXIT_IF_METHOD_FAILS(hr, Taxonomy::HelpSet::SetMachineInfo( m_instMachine ));
        }

        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHUserSettings2::EnsureDirectConnection - OUT" );

        if(!us)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_HANDLE);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::EnsureInSync()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::EnsureInSync" );

    HRESULT hr;


    if(m_fReady == false)
    {
        CComPtr<IPCHUserSettings>    us;
        CComPtr<IPCHSetOfHelpTopics> sht;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));

        MPC::Release( m_CurrentSKU );

        __MPC_EXIT_IF_METHOD_FAILS(hr, us->get_CurrentSKU( &sht                ));
		__MPC_EXIT_IF_METHOD_FAILS(hr, local_GetInstance (  sht, m_instCurrent ));

        CHCPProtocolEnvironment::s_GLOBAL->SetHelpLocation( m_instCurrent );

        m_fReady = true;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::GetCurrentSKU( /*[out]*/ CPCHProxy_IPCHSetOfHelpTopics* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::GetUserSettings2" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_CurrentSKU == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_CurrentSKU ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_CurrentSKU->ConnectToParent( this, /*fMachine*/false ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) MPC::Release( m_CurrentSKU );

    (void)MPC::CopyTo( m_CurrentSKU, pVal );

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::GetMachineSKU( /*[out]*/ CPCHProxy_IPCHSetOfHelpTopics* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::GetUserSettings2" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


    if(m_MachineSKU == NULL)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &m_MachineSKU ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_MachineSKU->ConnectToParent( this, /*fMachine*/true ));
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    if(FAILED(hr)) MPC::Release( m_MachineSKU );

    (void)MPC::CopyTo( m_MachineSKU, pVal );

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

bool CPCHProxy_IPCHUserSettings2::CanUseUserSettings()
{
	CPCHHelpCenterExternal* parent3;
	CPCHProxy_IPCHService*  parent2;
	CPCHProxy_IPCHUtility*  parent1;

	//
	// Only if we are from Start->Help we consider user settings.
	//
	if((parent1 =          Parent()) &&
	   (parent2 = parent1->Parent()) &&
	   (parent3 = parent2->Parent())  )
	{
		if(parent3->IsFromStartHelp() && parent3->DoesPersistSettings()) return true;
	}

	return false;
}

HRESULT CPCHProxy_IPCHUserSettings2::LoadUserSettings()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::LoadUserSettings" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


	//
	// Reload machine SKU.
	//
	(void)m_ths.Initialize( NULL, (long)0 );

	if(CanUseUserSettings())
	{
		//
		// If we are on a terminal server session, look for global default settings...
		//
		{
			Taxonomy::HelpSet& ths = CPCHOptions::s_GLOBAL->TerminalServerHelpSet();

			(void)m_ths.Initialize( ths.m_strSKU.size() ? ths.GetSKU() : NULL, ths.GetLanguage() );
		}

		//
		// ... then try anyway the user settings.
		//
		{
			Taxonomy::HelpSet& ths = CPCHOptions::s_GLOBAL->CurrentHelpSet();

			(void)m_ths.Initialize( ths.m_strSKU.size() ? ths.GetSKU() : NULL, ths.GetLanguage() );
		}
	}

    hr = S_OK;


	__HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::SaveUserSettings()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::SaveUserSettings" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( this );


	if(CanUseUserSettings())
	{
		if(CPCHOptions::s_GLOBAL)
		{
			(void)CPCHOptions::s_GLOBAL->put_CurrentHelpSet( m_ths );
		}
	}

    hr = S_OK;


	__HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::Initialize()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::Initialize" );

    HRESULT hr;

    //
    // Read user configuration.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, LoadUserSettings());

    //
    // If the parent is connected directly or the cache is not ready, connect directly
    //
    if(Parent() && Parent()->IsConnected() || OfflineCache::Root::s_GLOBAL->IsReady() == false)
    {
        CComPtr<IPCHUserSettings> us;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));
    }

	//
	// Wait a little for the cache to become ready.
	//
	{
		const int iMaxWait = 1000; // 1 second.
		int       iCount   = 0;

		while(OfflineCache::Root::s_GLOBAL->IsReady() == false && iCount < iMaxWait)
		{
			::Sleep( 10 ); iCount += 10;
		}
	}

	//
	// Do we have a valid cache for this SKU?
	//
	if(OfflineCache::Root::s_GLOBAL->IsReady())
	{
		{
			OfflineCache::Handle handle;

			m_instMachine = OfflineCache::Root::s_GLOBAL->MachineInstance();

			if(FAILED(OfflineCache::Root::s_GLOBAL->Locate( m_ths, handle )))
			{
				m_ths = m_instMachine.m_ths;
			}

			if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Locate( m_ths, handle )))
			{
				//
				// Yes, then populate from it...
				//
				m_fReady      = true;
				m_instCurrent = handle->Instance();
			}
		}

		if(m_fReady)
		{
			//
			// System Help, let's see if we have a version matching the user Default UI Language.
			//
			if(m_instCurrent.m_fSystem || m_instCurrent.m_fMUI)
			{
				long lUser = Taxonomy::HelpSet::GetUserLCID();
			
				if(lUser != m_ths.GetLanguage())
				{
					OfflineCache::Handle handle;
					Taxonomy::HelpSet    ths; ths.Initialize( m_ths.GetSKU(), lUser );

					if(SUCCEEDED(OfflineCache::Root::s_GLOBAL->Locate( ths, handle )))
					{
						m_ths         = ths;
						m_instCurrent = handle->Instance();
					}
				}
			}

			CHCPProtocolEnvironment::s_GLOBAL->SetHelpLocation( m_instCurrent );
		}
	}

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_CurrentSKU( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_CurrentSKU",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetCurrentSKU());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_CurrentSKU->QueryInterface( IID_IPCHSetOfHelpTopics, (void**)pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_MachineSKU( /*[out, retval]*/ IPCHSetOfHelpTopics* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_MachineSKU",hr,pVal);

    __MPC_EXIT_IF_METHOD_FAILS(hr, GetMachineSKU());

    __MPC_EXIT_IF_METHOD_FAILS(hr, m_MachineSKU->QueryInterface( IID_IPCHSetOfHelpTopics, (void**)pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_HelpLocation( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_HelpLocation",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_instCurrent.m_strHelpFiles.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_DatabaseDir( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_DatabaseDir",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_instCurrent.m_strDatabaseDir.c_str(), pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_DatabaseFile( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_DatabaseFile",hr,pVal);

	__MPC_EXIT_IF_METHOD_FAILS(hr, GetInstanceValue( &m_instCurrent.m_strDatabaseFile, pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IndexFile( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_IndexFile",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    if(vScope.vt == VT_BSTR)
    {
        CComPtr<IPCHUserSettings> us;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, us->get_IndexFile( vScope, pVal ));
    }
    else
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, GetInstanceValue( &m_instCurrent.m_strIndexFile, pVal ));
    }


    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IndexDisplayName( /*[in,optional]*/ VARIANT vScope, /*[out, retval]*/ BSTR *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_IndexDisplayName",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();


    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    if(vScope.vt == VT_BSTR)
    {
        CComPtr<IPCHUserSettings> us;

        __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, us->get_IndexDisplayName( vScope, pVal ));
    }
    else
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, GetInstanceValue( &m_instCurrent.m_strIndexDisplayName, pVal ));
    }


    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_LastUpdated( /*[out, retval]*/ DATE *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_LastUpdated",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    *pVal = m_instCurrent.m_dLastUpdated;

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

HRESULT CPCHProxy_IPCHUserSettings2::PollNews()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::PollNews" );

    HRESULT                      hr;
    MPC::SmartLock<_ThreadModel> lock( NULL );
    CComPtr<IPCHUserSettings>    us;
    CComPtr<IUnknown>            unk;
    VARIANT_BOOL                 fRes = VARIANT_FALSE;


    ::SetThreadPriority( ::GetCurrentThread(), THREAD_PRIORITY_LOWEST ); ::Sleep( 0 ); // Yield processor...

	__MPC_TRY_BEGIN();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));

    lock = this;

    (void)us->get_AreHeadlinesEnabled( &fRes );
    if(fRes == VARIANT_TRUE)
    {
        m_News_fEnabled = true;

        lock = NULL;
        (void)us->get_News( &unk );
        lock = this;

        m_News_xmlData = unk;
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

	__MPC_TRY_CATCHALL(hr);

    m_News_fDone = true;

    Thread_Abort  (); // To tell the MPC:Thread object to close the worker thread...
    Thread_Release(); // To tell the MPC:Thread object to clean up...

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::PrepareNews()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::PrepareNews" );

    HRESULT hr;


    if(m_News_fDone == false)
    {
        if(Thread_IsRunning() == false)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, Thread_Start( this, PollNews, NULL ));
        }
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_AreHeadlinesEnabled( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_AreHeadlinesEnabled",hr,pVal,VARIANT_FALSE);

    DWORD dwValue;
    bool  fFound;

    INTERNETSECURITY__CHECK_TRUST();


    // Get the RegKey Value
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::RegKey_Value_Read( dwValue, fFound, HC_REGISTRY_HELPSVC, L"Headlines" ));

    // If the Key was found and is disabled
    if(fFound && !dwValue)
    {
        m_News_fEnabled = false;
    }
    else
    {
        m_News_fEnabled = true;
    }

//    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareNews());
//
//    if(m_News_fDone == false)
//    {
//        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);
//    }

    if(m_News_fEnabled)
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_News( /*[out, retval]*/ IUnknown* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET("CPCHProxy_IPCHUserSettings2::get_News",hr,pVal);

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, PrepareNews());

    if(m_News_fDone == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_BUSY);
    }

    if(m_News_fEnabled)
    {
        CComPtr<IUnknown> unk = m_News_xmlData; m_News_xmlData.Release(); m_News_fDone = false;

        *pVal = unk.Detach();
    }

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////

HRESULT CPCHProxy_IPCHUserSettings2::GetInstanceValue( /*[in]*/ const MPC::wstring* str, /*[out, retval]*/ BSTR *pVal )
{
	__HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::GetInstanceValue" );

	HRESULT hr;

    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

	{
		MPC::wstring strTmp( *str ); MPC::SubstituteEnvVariables( strTmp );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( strTmp.c_str(), pVal ));
	}

	hr = S_OK;


	__HCP_FUNC_CLEANUP;

	__HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::Select( /*[in]*/ BSTR bstrSKU, /*[in]*/ long lLCID )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::Select" );

    HRESULT                   hr;
    CComBSTR                  bstr;
    CComPtr<IPCHUserSettings> us;


    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( us ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, us->Select( bstrSKU, lLCID ));
	(void)m_ths.Initialize( bstrSKU, lLCID );

    //
    // Refresh the cached info.
    //
    m_fReady = false;
    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureInSync());

    //
    // Get a new taxonomy database object.
    //
    {
        CComPtr<CPCHProxy_IPCHTaxonomyDatabase> db;
        CComPtr<IPCHTaxonomyDatabase>           db2;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->GetDatabase( &db ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, db->EnsureDirectConnection( db2, true ));
    }

    //
    // Refresh the favorites.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHFavorites::s_GLOBAL->Synchronize( true ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, CPCHHelpCenterExternal::s_GLOBAL->Events().FireEvent_SwitchedHelpFiles());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_Favorites( /*[out, retval]*/ IPCHFavorites* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::get_Favorites" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    INTERNETSECURITY__CHECK_TRUST();

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHFavorites::s_GLOBAL->Synchronize( false ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHFavorites::s_GLOBAL->QueryInterface( IID_IPCHFavorites, (void**)pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_Options( /*[out, retval]*/ IPCHOptions* *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::get_Options" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    INTERNETSECURITY__CHECK_TRUST();

    if(!CPCHOptions::s_GLOBAL) __MPC_SET_ERROR_AND_EXIT(hr, E_ACCESSDENIED);

    __MPC_EXIT_IF_METHOD_FAILS(hr, CPCHOptions::s_GLOBAL->QueryInterface( IID_IPCHOptions, (void**)pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_Scope( /*[out, retval]*/ BSTR *pVal )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHUserSettings2::get_Scope" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_POINTER_AND_SET(pVal,NULL);
    __MPC_PARAMCHECK_END();


    INTERNETSECURITY__CHECK_TRUST();

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetBSTR( m_bstrScope, pVal ));

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

HRESULT CPCHProxy_IPCHUserSettings2::put_Scope( /*[in]*/ BSTR newVal )
{
	return MPC::PutBSTR( m_bstrScope, newVal );
}



STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsRemoteSession( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2__NOLOCK("CPCHProxy_IPCHUserSettings2::get_IsRemoteSession",hr,pVal,VARIANT_FALSE);

    if(::GetSystemMetrics( SM_REMOTESESSION ))
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsTerminalServer( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2__NOLOCK("CPCHProxy_IPCHUserSettings2::get_IsTerminalServer",hr,pVal,VARIANT_FALSE);

    OSVERSIONINFOEXW ex; ex.dwOSVersionInfoSize = sizeof(ex);

    if(::GetVersionExW( (LPOSVERSIONINFOW)&ex ) && (ex.wSuiteMask & VER_SUITE_TERMINAL))
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsDesktopVersion( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_IsDesktopVersion",hr,pVal,VARIANT_FALSE);

    if(IsDesktopSKU())
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}


STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsAdmin( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_IsAdmin",hr,pVal,VARIANT_FALSE);

    if(SUCCEEDED(MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/false, NULL, MPC::IDENTITY_ADMIN | MPC::IDENTITY_ADMINS )))
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsPowerUser( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_IsPowerUser",hr,pVal,VARIANT_FALSE);

    if(SUCCEEDED(MPC::CheckCallerAgainstPrincipal( /*fImpersonate*/false, NULL, MPC::IDENTITY_ADMIN | MPC::IDENTITY_ADMINS | MPC::IDENTITY_POWERUSERS )))
    {
        *pVal = VARIANT_TRUE;
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsStartPanelOn( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_IsStartPanelOn",hr,pVal,VARIANT_FALSE);

    //    var shell = new ActiveXObject("Shell.Application");
    //    var bOn = shell.GetSetting( SSF_STARTPANELON );
    CComPtr<IShellDispatch4> sd4;
    if(SUCCEEDED(sd4.CoCreateInstance( CLSID_Shell )))
    {
        (void)sd4->GetSetting( SSF_STARTPANELON, pVal );
    }

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHUserSettings2::get_IsWebViewBarricadeOn( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2("CPCHProxy_IPCHUserSettings2::get_IsWebViewBarricadeOn",hr,pVal,VARIANT_FALSE);

    //    var shell = new ActiveXObject("Shell.Application");
    //    var CSIDL_CONTROL = 3;
    //    var control = shell.Namespace(CSIDL_CONTROL );
    //    var bOn = control.ShowWebViewBarricade;
    CComPtr<IShellDispatch> sd;
    if(SUCCEEDED(sd.CoCreateInstance( CLSID_Shell )))
    {
        CComVariant     v1( CSIDL_CONTROLS );
        CComPtr<Folder> fld;

        if(SUCCEEDED(sd->NameSpace( v1, &fld )))
        {
            CComQIPtr<Folder3> fld3 = fld;

            if(fld3)
            {
                (void)fld3->get_ShowWebViewBarricade( pVal );
            }
        }
    }

    __HCP_END_PROPERTY(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\helpctr\shell\proxies\taxonomydatabase.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    TaxonomyDatabase.cpp

Abstract:
    This file contains the implementation of the client-side proxy for IPCHTaxonomyDatabase

Revision History:
    Davide Massarenti   (Dmassare)  07/17/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

CPCHProxy_IPCHTaxonomyDatabase::CPCHProxy_IPCHTaxonomyDatabase() : m_AsyncCachingEngine(this)
{
	 			     // CPCHSecurityHandle                              m_SecurityHandle;
    m_parent = NULL; // CPCHProxy_IPCHUtility*                          m_parent;
                     //
                     // MPC::CComPtrThreadNeutral<IPCHTaxonomyDatabase> m_Direct_TaxonomyDatabase;
                     // AsynchronousTaxonomyDatabase::Engine            m_AsyncCachingEngine;
}

CPCHProxy_IPCHTaxonomyDatabase::~CPCHProxy_IPCHTaxonomyDatabase()
{
    Passivate();
}

////////////////////

HRESULT CPCHProxy_IPCHTaxonomyDatabase::ConnectToParent( /*[in]*/ CPCHProxy_IPCHUtility* parent, /*[in]*/ CPCHHelpCenterExternal* ext )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHTaxonomyDatabase::ConnectToParent" );

    HRESULT hr;

    __MPC_PARAMCHECK_BEGIN(hr)
        __MPC_PARAMCHECK_NOTNULL(parent);
    __MPC_PARAMCHECK_END();


    m_parent = parent;
    m_SecurityHandle.Initialize( ext, (IPCHTaxonomyDatabase*)this );

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

void CPCHProxy_IPCHTaxonomyDatabase::Passivate()
{
    m_AsyncCachingEngine.Passivate();

    m_Direct_TaxonomyDatabase.Release();

    m_SecurityHandle.Passivate();
    m_parent = NULL;
}

HRESULT CPCHProxy_IPCHTaxonomyDatabase::EnsureDirectConnection( /*[out]*/ CComPtr<IPCHTaxonomyDatabase>& db, /*[in]*/ bool fRefresh )
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHTaxonomyDatabase::EnsureDirectConnection" );

    HRESULT        hr;
    ProxySmartLock lock( &m_DirectLock );
    bool           fNotifyEngine = false;


    if(fRefresh) m_Direct_TaxonomyDatabase.Release();


    db.Release(); __MPC_EXIT_IF_METHOD_FAILS(hr, m_Direct_TaxonomyDatabase.Access( &db ));
    if(!db)
    {
        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHTaxonomyDatabase::EnsureDirectConnection - IN" );

        if(m_parent)
        {
            CComPtr<IPCHUtility> util;

			lock = NULL;
            __MPC_EXIT_IF_METHOD_FAILS(hr, m_parent->EnsureDirectConnection( util ));
			lock = &m_DirectLock;

            __MPC_EXIT_IF_METHOD_FAILS(hr, util->get_Database( &db ));

            m_Direct_TaxonomyDatabase = db;
        }

        DEBUG_AppendPerf( DEBUG_PERF_PROXIES, "CPCHProxy_IPCHTaxonomyDatabase::EnsureDirectConnection - OUT" );

        if(!db)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_HANDLE);
        }

        fNotifyEngine = true;
    }


    if(fNotifyEngine)
    {
        lock = NULL; // Unlock before calling into the engine.

        m_AsyncCachingEngine.RefreshConnection();
    }

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::get_InstalledSKUs( /*[out, retval]*/ IPCHCollection* *pVal )
{
    __HCP_BEGIN_PROPERTY_GET__NOLOCK("CPCHProxy_IPCHTaxonomyDatabase::get_InstalledSKUs",hr,pVal);

    CComPtr<IPCHTaxonomyDatabase> db;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->get_InstalledSKUs( pVal ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::get_HasWritePermissions( /*[out, retval]*/ VARIANT_BOOL *pVal )
{
    __HCP_BEGIN_PROPERTY_GET2__NOLOCK("CPCHProxy_IPCHTaxonomyDatabase::get_InstalledSKUs",hr,pVal,VARIANT_FALSE);

    CComPtr<IPCHTaxonomyDatabase> db;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->get_HasWritePermissions( pVal ));

    __HCP_END_PROPERTY(hr);
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CPCHProxy_IPCHTaxonomyDatabase::ExecuteQuery( /*[in]*/          int                         iType  ,
                                                      /*[in]*/          LPCWSTR                     szID   ,
                                                      /*[out, retval]*/ CPCHQueryResultCollection* *ppC    ,
                                                      /*[in]*/          VARIANT*                    option )
{
    return m_AsyncCachingEngine.ExecuteQuery( iType, szID, option, ppC );
}

HRESULT CPCHProxy_IPCHTaxonomyDatabase::ExecuteQuery( /*[in]*/          int              iType  ,
                                                      /*[in]*/          LPCWSTR          szID   ,
                                                      /*[out, retval]*/ IPCHCollection* *ppC    ,
                                                      /*[in]*/          VARIANT*         option )
{
    HRESULT hr;

    if(ppC == NULL)
    {
        hr = E_POINTER;
    }
    else
    {
        CPCHQueryResultCollection* pColl = NULL;

        hr = ExecuteQuery( iType, szID, &pColl, option ); *ppC = pColl;
    }

    return hr;
}

////////////////////

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::LookupNode( /*[in]*/          BSTR             bstrNode ,
                                                         /*[out, retval]*/ IPCHCollection* *ppC      )
{
    int iType = OfflineCache::ET_NODE;

    return ExecuteQuery( iType, bstrNode, ppC );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::LookupSubNodes( /*[in]*/          BSTR             bstrNode     ,
                                                             /*[in]*/          VARIANT_BOOL     fVisibleOnly ,
                                                             /*[out, retval]*/ IPCHCollection* *ppC          )
{
    int iType = (fVisibleOnly == VARIANT_TRUE) ? OfflineCache::ET_SUBNODES_VISIBLE : OfflineCache::ET_SUBNODES;

    return ExecuteQuery( iType, bstrNode, ppC );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::LookupNodesAndTopics( /*[in]*/          BSTR             bstrNode     ,
                                                                   /*[in]*/          VARIANT_BOOL     fVisibleOnly ,
                                                                   /*[out, retval]*/ IPCHCollection* *ppC          )
{
    int iType = (fVisibleOnly == VARIANT_TRUE) ? OfflineCache::ET_NODESANDTOPICS_VISIBLE : OfflineCache::ET_NODESANDTOPICS;

    return ExecuteQuery( iType, bstrNode, ppC );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::LookupTopics( /*[in]*/          BSTR             bstrNode     ,
                                                           /*[in]*/          VARIANT_BOOL     fVisibleOnly ,
                                                           /*[out, retval]*/ IPCHCollection* *ppC          )
{
    int iType = (fVisibleOnly == VARIANT_TRUE) ? OfflineCache::ET_TOPICS_VISIBLE : OfflineCache::ET_TOPICS;

    return ExecuteQuery( iType, bstrNode, ppC );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::LocateContext( /*[in]*/          BSTR             bstrURL  ,
                                                            /*[in,optional]*/ VARIANT          vSubSite ,
                                                            /*[out, retval]*/ IPCHCollection* *ppC      )
{
    int iType = OfflineCache::ET_LOCATECONTEXT;

    return ExecuteQuery( iType, bstrURL, ppC, &vSubSite );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::KeywordSearch( /*[in]*/          BSTR             bstrQuery ,
                                                            /*[in,optional]*/ VARIANT          vSubSite  ,
                                                            /*[out, retval]*/ IPCHCollection* *ppC       )
{
    int iType = OfflineCache::ET_SEARCH;

    return ExecuteQuery( iType, bstrQuery, ppC, &vSubSite );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::GatherNodes( /*[in]*/          BSTR             bstrNode     ,
                                                          /*[in]*/          VARIANT_BOOL     fVisibleOnly ,
                                                          /*[out, retval]*/ IPCHCollection* *ppC          )
{
    int iType = (fVisibleOnly == VARIANT_TRUE) ? OfflineCache::ET_NODES_RECURSIVE : OfflineCache::ET_NODES_RECURSIVE;

    return ExecuteQuery( iType, bstrNode, ppC );
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::GatherTopics( /*[in]*/          BSTR             bstrNode     ,
                                                           /*[in]*/          VARIANT_BOOL     fVisibleOnly ,
                                                           /*[out, retval]*/ IPCHCollection* *ppC          )
{
    int iType = (fVisibleOnly == VARIANT_TRUE) ? OfflineCache::ET_TOPICS_RECURSIVE : OfflineCache::ET_TOPICS_RECURSIVE;

    return ExecuteQuery( iType, bstrNode, ppC );
}

////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::ConnectToDisk( /*[in]*/          BSTR             bstrDirectory ,
                                                            /*[in]*/          IDispatch*       notify        ,
                                                            /*[out, retval]*/ IPCHCollection* *ppC           )
{
    __HCP_BEGIN_PROPERTY_GET__NOLOCK("CPCHProxy_IPCHTaxonomyDatabase::ConnectToDisk",hr,ppC);

    CComPtr<IPCHTaxonomyDatabase> db;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->ConnectToDisk( bstrDirectory, notify, ppC ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::ConnectToServer( /*[in]*/          BSTR             bstrServerName ,
                                                              /*[in]*/          IDispatch*       notify         ,
                                                              /*[out, retval]*/ IPCHCollection* *ppC            )
{
    __HCP_BEGIN_PROPERTY_GET__NOLOCK("CPCHProxy_IPCHTaxonomyDatabase::ConnectToServer",hr,ppC);

    CComPtr<IPCHTaxonomyDatabase> db;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->ConnectToServer( bstrServerName, notify, ppC ));

    __HCP_END_PROPERTY(hr);
}

STDMETHODIMP CPCHProxy_IPCHTaxonomyDatabase::Abort()
{
    __HCP_FUNC_ENTRY( "CPCHProxy_IPCHTaxonomyDatabase::Abort" );

    HRESULT                       hr;
    CComPtr<IPCHTaxonomyDatabase> db;

    __MPC_EXIT_IF_METHOD_FAILS(hr, EnsureDirectConnection( db ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, db->Abort());

    hr = S_OK;


    __HCP_FUNC_CLEANUP;

    __HCP_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\dllload.h ===
//***************************************************************************
// delay load macros ripped from shell\lib\dllload.c
//***************************************************************************

extern HINSTANCE g_hinstShell32;

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc);

#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define     DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
   DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_LRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LRESULT, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)
#define DELAY_LOAD_LPVOID(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LPVOID, _fn, _args, _nargs, 0)

#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)
#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)
#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)
#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_SHELL_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0, _realfn)
#define DELAY_LOAD_SHELL_HRESULT_FN(_hinst, _dll, _fn, _ord, _args, _nargs, realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL, _realfn)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\atlext.h ===
#pragma once

// Extensions to ATL to enable things it doesn't natively support

template <const CLSID* pcoclsid, const IID* psrcid, class tihclass = CMarsTypeInfoHolder>
    class MarsIProvideClassInfo2Impl : public IProvideClassInfo2Impl<pcoclsid, psrcid, NULL, 0, 0, tihclass>
    {
    
    };

template <class T, const IID* piid, class tihclass = CMarsTypeInfoHolder>
    class MarsIDispatchImpl : public IDispatchImpl<T, piid, NULL, 0, 0, tihclass>
    {
    public:
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
                          DISPPARAMS *pdispparams, VARIANT *pvarResult, 
                          EXCEPINFO *pexcepinfo, UINT *puArgErr)
        {
            HRESULT hr = IDispatchImpl<T, piid, NULL, 0, 0, tihclass>::Invoke(dispidMember, 
                                                                              riid, 
                                                                              lcid, 
                                                                              wFlags,
                                                                              pdispparams,
                                                                              pvarResult,
                                                                              pexcepinfo,
                                                                              puArgErr);
            hr = SanitizeResult(hr);

            if (DISP_E_EXCEPTION == hr)
            {
                // We're getting DISP_E_EXCEPTION returns which are not generated by Mars
                //  whenever invalid parameter types are passed. They're probably coming
                //  from oleaut itself.
                //          ASSERT(NULL != m_pwszException);

                if ((NULL != m_pwszException) && (NULL != pexcepinfo))
                {        
                    memset(pexcepinfo, 0, sizeof(EXCEPINFO));
                    pexcepinfo->wCode = (WORD)dispidMember;
                    pexcepinfo->bstrSource = SysAllocString(L"OM Exception");
                    pexcepinfo->bstrDescription = SysAllocString(m_pwszException);
                }
            }
        
            return hr;
        }

    protected:
        LPWSTR m_pwszException;
    };

//  each module implements this themselves
HRESULT GetMarsTypeLib(ITypeLib **ppTypeLib);

//==================================================================
// Begin CComTypeInfoHolder override
//
//  By providing our own CComTypeInfoHolder, we can load the type
//   library ourselves, rather than requiring it to be loaded from
//   the registry as ATL does. Only "GetTI" is changed from
//   ATL source. Since GetTI isn't virtual we need to duplicate
//   the entire class.
//  CMarsTypeInfoHolder accepts an ITypeLib * (with reference)
//   instead of a LIBID in m_plibid
//
//==================================================================

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CMarsTypeInfoHolder
{
    // Should be 'protected' but can cause compiler to generate fat code.
public:
    const GUID* m_pguid;
    const GUID* m_plibid;
    WORD m_wMajor;
    WORD m_wMinor;

    ITypeInfo* m_pInfo;
    long m_dwRef;
    struct stringdispid
    {
        CComBSTR bstr;
        int nLen;
        DISPID id;
    };
    stringdispid* m_pMap;
    int m_nCount;
public:
    HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
    {
        HRESULT hr = S_OK;
        if (m_pInfo == NULL)
            hr = GetTI(lcid);
        *ppInfo = m_pInfo;
        if (m_pInfo != NULL)
        {
            m_pInfo->AddRef();
            hr = S_OK;
        }
        return hr;
    }
    HRESULT GetTI(LCID lcid);
    HRESULT EnsureTI(LCID lcid)
    {
        HRESULT hr = S_OK;
        if (m_pInfo == NULL)
            hr = GetTI(lcid);
        return hr;
    }

    // This function is called by the module on exit
    // It is registered through _Module.AddTermFunc()
    static void __stdcall Cleanup2(DWORD_PTR dw)
    {
        CMarsTypeInfoHolder* p = (CMarsTypeInfoHolder*) dw;
        if (p->m_pInfo != NULL)
            p->m_pInfo->Release();
        p->m_pInfo = NULL;
        delete [] p->m_pMap;
        p->m_pMap = NULL;
    }

    HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
    {
        HRESULT hRes = E_POINTER;
        if (pptinfo != NULL)
            hRes = GetTI(lcid, pptinfo);
        return hRes;
    }
    HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
                          LCID lcid, DISPID* rgdispid)
    {
        HRESULT hRes = EnsureTI(lcid);
        if (m_pInfo != NULL)
        {
            for (int i=0; i<(int)cNames; i++)
            {
                int n = ocslen(rgszNames[i]);
                for (int j=m_nCount-1; j>=0; j--)
                {
                    if ((n == m_pMap[j].nLen) &&
                        (memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
                    {
                        rgdispid[i] = m_pMap[j].id;
                        break;
                    }

                    // Give debug warning if we differ only in case
                    //DEBUG_ONLY(StrEql(m_pMap[j].bstr, rgszNames[i]));
                }
                if (j < 0)
                {
                    // Not a warning. Common for behaviors as Trident passes all calls to
                    //  our IDispatch for the first shot. We should possibly just return
                    //  failure in this case instead of delegating to oleaut.
                    hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
                    if (FAILED(hRes))
                        break;
                }
            }
        }
        return hRes;
    }

    HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
                   LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                   EXCEPINFO* pexcepinfo, UINT* puArgErr)
    {
        HRESULT hRes = EnsureTI(lcid);
        if (m_pInfo != NULL)
            hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
        return hRes;
    }
    HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
    {
        TYPEATTR* pta;
        HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
        if (SUCCEEDED(hr))
        {
            m_nCount = pta->cFuncs;
            m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
            for (int i=0; i<m_nCount; i++)
            {
                FUNCDESC* pfd;
                if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
                {
                    CComBSTR bstrName;
                    if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
                    {
                        m_pMap[i].bstr.Attach(bstrName.Detach());
                        m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
                        m_pMap[i].id = pfd->memid;
                    }
                    pTypeInfo->ReleaseFuncDesc(pfd);
                }
            }
            pTypeInfo->ReleaseTypeAttr(pta);
        }
        return S_OK;
    }
};

inline HRESULT CMarsTypeInfoHolder::GetTI(LCID lcid)
{
    UNREFERENCED_PARAMETER(lcid);

    // Change: removed asserts
    if (m_pInfo != NULL)
        return S_OK;
    HRESULT hRes = E_FAIL;
    EnterCriticalSection(&_Module.m_csTypeInfoHolder);
    if (m_pInfo == NULL)
    {
        ITypeLib* pTypeLib;
        // Here's a change
        //      hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);

        hRes = GetMarsTypeLib(&pTypeLib);
        // End change
        
        if (SUCCEEDED(hRes))
        {
            CComPtr<ITypeInfo> spTypeInfo;
            hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
            if (SUCCEEDED(hRes))
            {
                CComPtr<ITypeInfo> spInfo(spTypeInfo);
                CComPtr<ITypeInfo2> spTypeInfo2;
                if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
                    spInfo = spTypeInfo2;

                LoadNameCache(spInfo);
                m_pInfo = spInfo.Detach();
            }
            pTypeLib->Release();
        }
    }
    LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
    _Module.AddTermFunc(Cleanup2, (DWORD_PTR)this);
    return hRes;
}

//==================================================================
// End CComTypeInfoHolder override
//==================================================================

// CComClassPtr is like CComPtr but it works with C++ classes, by not
//  assuming that we can cast to IUnknown unambiguously.

// Use caution when initializing within your constructor. You can't
//  AddRef an object which hasn't finished constructing yet, so you can
//  only initialize smart pointers to object which don't contain you.
template <class T>
    class _NoAddRefReleaseOnCComClassPtr : public T
    {
    public:
        // If you get a compile error here, make sure that the destructors
        //  for any CComClassPtr<> classes are protected instead of private
        ~_NoAddRefReleaseOnCComClassPtr() {}
    
    private:
        STDMETHOD_(ULONG, AddRef)()=0;
        STDMETHOD_(ULONG, Release)()=0;
    };


template <class T>
    class CComClassPtr
    {
    public:
        typedef T _PtrClass;
        CComClassPtr()
        {
            p=NULL;
        }
        CComClassPtr(T* lp)
        {
            if ((p = lp) != NULL)
                p->AddRef();
        }
        CComClassPtr(const CComClassPtr<T>& lp)
        {
            if ((p = lp.p) != NULL)
                p->AddRef();
        }
        ~CComClassPtr()
        {
            if (p)
                p->Release();
        }
        void Release()
        {
            T* pTemp = p;
            if (pTemp)
            {
                p = NULL;
                pTemp->Release();
            }
        }
        operator T*() const
        {
            return p;
        }
        T& operator*() const
        {
            ATLASSERT(p!=NULL);
            return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
            ATLASSERT(p==NULL);
            return &p;
        }

        HRESULT PassivateAndRelease()
        {
            if (p)
            {
                HRESULT hr = p->Passivate();
                Release();
                return hr;
            }
        
            return S_FALSE;
        }

        _NoAddRefReleaseOnCComClassPtr<T>* operator->() const
        {
            ATLASSERT(p!=NULL);
            return (_NoAddRefReleaseOnCComClassPtr<T>*)p;
        }

        T* AtlComClassPtrAssign(T** pp, T* lp)
        {
            if (lp != NULL)
                lp->AddRef();
            if (*pp)
                (*pp)->Release();
            *pp = lp;
            return lp;
        }

        T* operator=(T* lp)
        {
            return AtlComClassPtrAssign(&p, lp);
        }
        T* operator=(const CComClassPtr<T>& lp)
        {
            return AtlComClassPtrAssign(&p, lp.p);
        }
        bool operator!() const
        {
            return (p == NULL);
        }
        bool operator<(T* pT) const
        {
            return p < pT;
        }
        bool operator==(T* pT) const
        {
            return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(T* pOther)
        {
            return (p == pOther);
        }
        void Attach(T* p2)
        {
            if (p)
                p->Release();
            p = p2;
        }
        T* Detach()
        {
            T* pt = p;
            p = NULL;
            return pt;
        }
        HRESULT CopyTo(T** ppT)
        {
            ATLASSERT(ppT != NULL);
            if (ppT == NULL)
                return E_POINTER;
            *ppT = p;
            if (p)
                p->AddRef();
            return S_OK;
        }
        template <class Q>
            HRESULT QueryInterface(Q** pp) const
        {
            ATLASSERT(pp != NULL && *pp == NULL);
            return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
        T* p;
    };

//////////////////////////////////////////////////////////////////////////////
// CMarsComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
//
//  This is better than CComDispatchDriver for these reasons:
//      - CComDispatchDriver in atl30 doesn't define an assignment/copy constructor
//      - CcomDispatchDriver doesn't use _NoAddRefReleaseOnCComPtr
//      - Added "const" to methods which are const
//
class CMarsComDispatchDriver
{
public:
    CMarsComDispatchDriver()
    {
        p = NULL;
    }
    CMarsComDispatchDriver(IDispatch* lp)
    {
        if ((p = lp) != NULL)
            p->AddRef();
    }
    CMarsComDispatchDriver(IUnknown* lp)
    {
        p=NULL;
        if (lp != NULL)
            lp->QueryInterface(IID_IDispatch, (void **)&p);
    }
    CMarsComDispatchDriver(const CMarsComDispatchDriver& lp)
    {
        if ((p = lp.p) != NULL)
            p->AddRef();
    }
    
    ~CMarsComDispatchDriver() { if (p) p->Release(); }
    void Release() {if (p) p->Release(); p=NULL;}
    operator IDispatch*()   const {return p;}
    IDispatch& operator*()  const {ATLASSERT(p!=NULL); return *p; }
    IDispatch** operator&() {ATLASSERT(p==NULL); return &p; }

    _NoAddRefReleaseOnCComPtr<IDispatch>* operator->() const
    {
        ATLASSERT(p!=NULL);
        return (_NoAddRefReleaseOnCComPtr<IDispatch>*)p;
    }
    //IDispatch* operator->() {ATLASSERT(p!=NULL); return p; }
    IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
    IDispatch* operator=(IUnknown* lp)
    {
        return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
    }
    IDispatch* operator=(const CMarsComDispatchDriver& lp)
    {
        return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp.p);
    }
    BOOL operator!() const {return (p == NULL) ? TRUE : FALSE;}

    HRESULT GetPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
    {
        ATLASSERT(p);
        ATLASSERT(pVar);
        DISPID dwDispID;
        HRESULT hr = GetIDOfName(lpsz, &dwDispID);
        if (SUCCEEDED(hr))
            hr = GetProperty(p, dwDispID, pVar);
        return hr;
    }
    HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
    {
        ATLASSERT(p);
        return GetProperty(p, dwDispID, pVar);
    }
    HRESULT PutPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
    {
        ATLASSERT(p);
        ATLASSERT(pVar);
        DISPID dwDispID;
        HRESULT hr = GetIDOfName(lpsz, &dwDispID);
        if (SUCCEEDED(hr))
            hr = PutProperty(p, dwDispID, pVar);
        return hr;
    }
    HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
    {
        ATLASSERT(p);
        return PutProperty(p, dwDispID, pVar);
    }
    HRESULT GetIDOfName(LPCOLESTR lpsz, DISPID* pdispid)
    {
        return p->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpsz, 1, LOCALE_USER_DEFAULT, pdispid);
    }
    // Invoke a method by DISPID with no parameters
    HRESULT Invoke0(DISPID dispid, VARIANT* pvarRet = NULL)
    {
        DISPPARAMS dispparams = { NULL, NULL, 0, 0};
        return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
    }
    // Invoke a method by name with no parameters
    HRESULT Invoke0(LPCOLESTR lpszName, VARIANT* pvarRet = NULL)
    {
        HRESULT hr;
        DISPID dispid;
        hr = GetIDOfName(lpszName, &dispid);
        if (SUCCEEDED(hr))
            hr = Invoke0(dispid, pvarRet);
        return hr;
    }
    // Invoke a method by DISPID with a single parameter
    HRESULT Invoke1(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
    {
        DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
        return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
    }
    // Invoke a method by name with a single parameter
    HRESULT Invoke1(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
    {
        HRESULT hr;
        DISPID dispid;
        hr = GetIDOfName(lpszName, &dispid);
        if (SUCCEEDED(hr))
            hr = Invoke1(dispid, pvarParam1, pvarRet);
        return hr;
    }
    // Invoke a method by DISPID with two parameters
    HRESULT Invoke2(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
    {
        CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
        DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
        return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
    }
    // Invoke a method by name with two parameters
    HRESULT Invoke2(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
    {
        HRESULT hr;
        DISPID dispid;
        hr = GetIDOfName(lpszName, &dispid);
        if (SUCCEEDED(hr))
            hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
        return hr;
    }
    // Invoke a method by DISPID with N parameters
    HRESULT InvokeN(DISPID dispid, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
    {
        DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
        return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
    }
    // Invoke a method by name with Nparameters
    HRESULT InvokeN(LPCOLESTR lpszName, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
    {
        HRESULT hr;
        DISPID dispid;
        hr = GetIDOfName(lpszName, &dispid);
        if (SUCCEEDED(hr))
            hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
        return hr;
    }
    static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID,
                               VARIANT* pVar)
    {
        ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::GetProperty\n"));
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        return pDisp->Invoke(dwDispID, IID_NULL,
                             LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                             &dispparamsNoArgs, pVar, NULL, NULL);
    }

    static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID,
                               VARIANT* pVar)
    {
        ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::PutProperty\n"));
        DISPPARAMS dispparams = {NULL, NULL, 1, 1};
        dispparams.rgvarg = pVar;
        DISPID dispidPut = DISPID_PROPERTYPUT;
        dispparams.rgdispidNamedArgs = &dispidPut;

        if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
            (pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
        {
            HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
                                       LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
                                       &dispparams, NULL, NULL, NULL);
            if (SUCCEEDED(hr))
                return hr;
        }

        return pDisp->Invoke(dwDispID, IID_NULL,
                             LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
                             &dispparams, NULL, NULL, NULL);
    }

    IDispatch* p;
};

#define CComDispatchDriver _DONT_USE_CComDispatchDriver_USE_CMarsComDispatchDriver

//////////////////////////////////////////////////////////////////////////////
// CMarsSimpleArray / Specialization of CSimpleArray
//
//  This is better than CSimpleArray for these reasons:
//      overloaded the operator=() and defined a copy constructor.
//      Fixed various pointer math to use + instead of & because the operator&()
//      on contained smart types (like CComPtr) gets called accidentally if you
//      do this: &m_aT[i] instead of (m_aT + i).
//
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CMarsSimpleArray
#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif


template <class T>
class CMarsSimpleArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

// Construction/destruction
    CMarsSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CMarsSimpleArray()
    {
        RemoveAll();
    }

    CMarsSimpleArray(const CMarsSimpleArray<T> &current) : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    {
        *this = current;
    }

    CMarsSimpleArray &operator=(const CMarsSimpleArray<T> &right)
    {
        if (&right != this)
        {
            // BUGBUG (tnoonan) -- this code is going to potentially leak
            // if the new size is smaller than the old.
            
            T *aT = NULL;
            aT = (T *)realloc(m_aT, right.m_nAllocSize * sizeof(T));

            // Did the realloc succeed?
            if (aT)
            {
                m_aT = aT;
                m_nSize = right.m_nSize;
                m_nAllocSize = right.m_nAllocSize;

                // WARNING: This is not a simple mempcy() for a very specific reason!
                //      Each element must be copied with = in case the T class has an
                //      overloaded operator=(). (i.e. in the case of smart ptrs).
                //
                for (int idx = 0; idx < m_nSize; ++idx)
                {
                    m_aT[idx] = right.m_aT[idx];
                }
            }

        }

        return *this;
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            T* aT;
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
            if(aT == NULL)
                return FALSE;
            m_nAllocSize = nNewAllocSize;
            m_aT = aT;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {
        ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

        m_aT[nIndex].~T();

        if(nIndex != (m_nSize - 1))
        {
            //
            // BUGFIX: Use m_aT + nIndex instead of &m_aT[nIndex] to avoid calling type's operator &()
            //
            memmove((void*)(m_aT + nIndex), (void*)(m_aT + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(T));

            ZeroMemory((void*)(m_aT + (m_nSize-1)), sizeof(m_aT[0]));
        }
        m_nSize--;
        return TRUE;
    }
    BOOL InsertAt(int nIndex, T& t)
    {
        // Index equal to size means to insert at the end
        ATLASSERT(nIndex >= 0 && nIndex <= m_nSize);

        // First check if we have room...
        if(m_nSize == m_nAllocSize)
        {
            T* aT;
            int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
            aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
            if(aT == NULL)
                return FALSE;
            m_nAllocSize = nNewAllocSize;
            m_aT = aT;
        }

        // If we're not adding to the end, then we need to shift elements past the insertion point
        // down one.
        if (nIndex < m_nSize)
        {
            memmove( (void*)(m_aT + (nIndex + 1)), (void*)(m_aT + (nIndex)), sizeof(T) * (m_nSize - nIndex));

            // TRICKY: This memmove is a HACK -- it doesn't call the ctors and dtors of the elements.
            //      However below, we're going to make an assignment, and that assignment is going to
            //      cause the operator=() to fire on user types, which might mess up any
            //      internal pointers.  Ouch.  We need to avoid that by wiping out the memory
            //      destructively first.
            //
            //      The reason this is bad is because the memmove has caused the nIndex and nIndex + 1
            //      entries to both share the same data, including pointers, so we have danglers. :-(
            //
            ZeroMemory((void*)(m_aT + nIndex), sizeof(T));
        }

        m_nSize++;
        SetAtIndex(nIndex, t);
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++)
                m_aT[i].~T();
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
        void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
        //
        // BUGFIX: Use m_aT + nIndex instead of &m_aT[nIndex] to avoid calling type's operator &()
        //
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
}; // CMarsSimpleArray


// for arrays of simple types
template <class T>
class CMarsSimpleValArray : public CMarsSimpleArray< T >
{
public:
    BOOL Add(T t)
    {
        return CMarsSimpleArray< T >::Add(t);
    }
    BOOL Remove(T t)
    {
        return CMarsSimpleArray< T >::Remove(t);
    }
    T operator[] (int nIndex) const
    {
        return CMarsSimpleArray< T >::operator[](nIndex);
    }

    CMarsSimpleValArray &operator=(const CMarsSimpleValArray<T> &right)
    {
        if (&right != this)
        {
            T *aT = NULL;
            aT = (T *)realloc(m_aT, right.m_nAllocSize * sizeof(T));

            // Did the realloc succeed?
            if (aT)
            {
                m_aT = aT;
                m_nSize = right.m_nSize;
                m_nAllocSize = right.m_nAllocSize;

                CopyMemory(m_aT, right.m_aT, sizeof(T) * m_nSize);
            }

        }

        return *this;
    }
};


#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// class CComTableMarshalPtr
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=
template <class I>
class CComTableMarshalPtr : public CComPtr<I>
{
public:
    CComTableMarshalPtr(DWORD dwGITKey);
    virtual ~CComTableMarshalPtr();

    static HRESULT RegisterInterface(IUnknown *pUnk, DWORD *pdwKey);
    static HRESULT RevokeInterface(DWORD dwKey);

private:
    CComTableMarshalPtr();              // Protect access to default ctor
}; // CComTableMarshalPtr


//============================================================================
//  class CComTableMarshalPtr
//============================================================================
template <class I>
CComTableMarshalPtr<I>::CComTableMarshalPtr(DWORD dwKey)
{
    CComPtr<IGlobalInterfaceTable>  spGIT(CMarsGlobalsManager::GIT());

    if (spGIT)
    {
        I   *pInt = NULL;

        HRESULT hr = spGIT->GetInterfaceFromGlobal(dwKey, __uuidof(I), (void **)&pInt);

        if (SUCCEEDED(hr))
            Attach(pInt);
    }
} // CComTableMarshalPtr

template <class I>
CComTableMarshalPtr<I>::~CComTableMarshalPtr()
{
} // ~CComTableMarshalPtr

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
template <class I>
HRESULT CComTableMarshalPtr<I>::RegisterInterface(IUnknown *pInt, DWORD *pdwKey)
{
    HRESULT hr = E_INVALIDARG;

    if (IsValidInterfacePtr(pInt) && IsValidWritePtr(pdwKey))
    {
        CComPtr<IGlobalInterfaceTable>  spGIT(CMarsGlobalsManager::GIT());

        ATLASSERT(spGIT);

        if (spGIT)
        {
            hr = spGIT->RegisterInterfaceInGlobal(pInt, __uuidof(I), pdwKey);
        }
    }

    return hr;
} // RegisterInterface

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// CComTableMarshalPtr::RevokeInterface()
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
template <class I>
HRESULT CComTableMarshalPtr<I>::RevokeInterface(DWORD dwKey)
{
    HRESULT hr = E_FAIL;

    CComPtr<IGlobalInterfaceTable>  spGIT(CMarsGlobalsManager::GIT());

    ATLASSERT(spGIT);

    if (spGIT)
    {
        hr = spGIT->RevokeInterfaceFromGlobal(dwKey);
    }

    return hr;
} // RevokeInterface


typedef CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > CComVariantEnum;


//////////////////////////////////////////////////////////////////////////////
// CMarsComEnumVariant - Simple derivation for convenience. This is the standard
//      type of a CComEnum for use in a collection that returns IEnumVARIANT.
//
//      Our helper class has some luxury features that completely handle the common
//      case of take a CMarsSimpleArray full of "stuff," stuffing those things into
//      an array of CComVariant's (so we can be type-agnostic about what the
//      "things" are), and then creates a CComEnum and puts it in an out-param.
//
template <class I>
class CMarsComEnumVariant :
    public CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> >
{
public:
    static HRESULT CreateFromMarsSimpleArray(CMarsSimpleArray<CComClassPtr< I > > &arr, IUnknown **ppUnk)
    {
        // Internal API, so rip if the out param is bad
        ATLASSERT(NULL != ppUnk);

        HRESULT hr = E_FAIL;

        // Create one of ourselves...        
        CComObject<CMarsComEnumVariant<CMarsSimpleArray< CComClassPtr< I > > > >   *pEnum = NULL;

        hr = CComObject<CMarsComEnumVariant<CMarsSimpleArray< CComClassPtr< I > > > >::CreateInstance(&pEnum);

        if (SUCCEEDED(hr))
        {
            // Allocation must have succeeded if no error HRESULT
            ATLASSERT(pEnum);
            pEnum->AddRef();

            VARIANT *rgVar = new VARIANT[arr.GetSize()];
            LONG    idxEntry;

            if (rgVar)
            {
                HRESULT hrTestForDispatch = E_FAIL;

                for (idxEntry = 0; idxEntry < arr.GetSize(); idxEntry++)
                {
                    CComClassPtr<I> spElt;

                    spElt = arr.operator[](idxEntry);

                    hrTestForDispatch = spElt->QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(&rgVar[idxEntry]));

                    //
                    // This had better succeed: the type I must be a dispatch interface, because otherwise,
                    // you can't pass this object to script anyway, so what's the point of the collection???
                    // If you really want an IEnumXXXX for your non-automation interfaces, use ATL's CComEnum
                    // directly with appropriate template parameters.
                    //
                    ATLASSERT(SUCCEEDED(hrTestForDispatch));

                    V_VT(&rgVar[idxEntry]) = VT_DISPATCH;
                }

                // If this succeeds, then ATL will have taken care of freeing our array for
                // us.  How nice of it.
                //
                hr = pEnum->Init(&rgVar[0], &rgVar[arr.GetSize()], NULL, AtlFlagTakeOwnership);

                if (SUCCEEDED(hr))
                {
                    hr = pEnum->QueryInterface(IID_IUnknown, (void **)ppUnk);
                }
                else
                {
                    for(idxEntry = 0; idxEntry < arr.GetSize(); idxEntry++)
                    {
                        VariantClear(&rgVar[idxEntry]);
                    }
                    delete[] rgVar;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            pEnum->Release();
        } // If CreateInstance SUCCEEDED

        return hr;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\exports.h ===
#pragma once
// ---------------------------------------------------------------------------
// EXPORTS.H
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Ordinals and prototypes for NONAME exports
//
// ---------------------------------------------------------------------------

// Exported from mail dlls for object registration
#define DLLEXPORT_REGCLASSOBJS   3
#define DLLEXPORT_UNREGCLASSOBJS 4

typedef HRESULT (STDMETHODCALLTYPE *PFNREGCLASSOBJS)(void);
typedef HRESULT (STDMETHODCALLTYPE *PFNUNREGCLASSOBJS)(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\lib\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\evilguid.h ===
// evilguid.h
// Declarations of external guids which we can not easily include.
// Those which need to be defined are defined in evilguid.cpp

// From shdguid:
// #include "..\..\shell\inc\shdguid.h" // IID_ITravelLog, IID_ITravelEntry, IID_IBrowserService
EXTERN_C const IID IID_ITravelLog;
EXTERN_C const IID IID_ITravelEntry;
EXTERN_C const IID IID_IBrowserService;

// #include "..\..\shell\inc\shguidp.h" // SID_STopFrameBrowser
EXTERN_C const GUID SID_STopFrameBrowser;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\marscom.h ===
#pragma once

//
// Macro to delegate IDispatch to base class. Needed so that CMarsBehaviorSite vtbl works -
//    the only other way to do this is make CMarsBehaviorSite and CMarsBehaviorFor templated classes
//
#define IMPLEMENT_IDISPATCH_DELEGATE_TO_BASE(BaseClass)                                         \
    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)                                                  \
                { return BaseClass::GetTypeInfoCount(pctinfo); }                                \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)                         \
                { return BaseClass::GetTypeInfo(itinfo, lcid, pptinfo); }                       \
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,                     \
        LCID lcid, DISPID* rgdispid)                                                            \
            { return BaseClass::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }       \
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,                                         \
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,                   \
        EXCEPINFO* pexcepinfo, UINT* puArgErr)                                                  \
            { return BaseClass::Invoke(dispidMember, riid, lcid, wFlags,                        \
                        pdispparams, pvarResult, pexcepinfo, puArgErr); }

//---------------------------------------------------------------------------------
// CMarsComObject provides some functionality used by all or most Mars com objects
// including addref/release and passivation

// Exposed methods should be protected to ensure that they're not called while the
//  object is passive. There are three types of passivation protection:
// if (VerifyNotPassive())     - this function should not be called while passive,
//                                  but we still want to protect against it
// if (IsPassive())            - this function may be called while passive,
//                                  but we want to protect against it
// ASSERT(!IsPassive());       - we're pretty sure this won't be called while passive,
//                                  but we want to detect it if it starts happening

// Use:
//  derive from CMarsComObject
//  IMPLEMENT_ADDREF_RELEASE in source file
//  Implement DoPassivate()
//  Use IsPassive() and VerifyNotPassive() where appropriate
//  Don't call "delete" directly
//  CYourClass->Passivate() should be called before CYourClass->Release()

// TODO: FENTER on Passivate() causes debug link warnings due to dupe functions

class CMarsComObject
{
protected:
    LONG    m_cRef;
    BOOL    m_fPassive;
    
protected:
    virtual ~CMarsComObject() { ATLASSERT(IsPassive()); ATLASSERT(m_cRef==0); }

    CMarsComObject() { m_cRef = 1; }

    ULONG InternalAddRef()
    {
        return ++m_cRef;
    }

    ULONG InternalRelease()
    {
        if (--m_cRef)
        {
            return m_cRef;
        }

        delete this;

        return 0;
    }

    inline BOOL VerifyNotPassive(HRESULT *phr=NULL)
    {
        if (IsPassive())
        {
            if (phr)
            {
                *phr = SCRIPT_ERROR;
            }

            return FALSE;
        }

        return TRUE;
    }
    
    inline HRESULT GetBSTROut(const BSTR &bstrParam, BSTR *pbstrOut)
    {
        HRESULT hr = E_UNEXPECTED;

        ATLASSERT(API_IsValidBstr(bstrParam));
        
        if (API_IsValidWritePtr(pbstrOut))
        {
            if (VerifyNotPassive(&hr))
            {
                *pbstrOut =  ::SysAllocStringLen(bstrParam,
                                                 ::SysStringLen(bstrParam));

                hr = (*pbstrOut) ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                *pbstrOut = NULL;
            }
        }

        return hr;
    }
    
    virtual HRESULT DoPassivate() = 0;

public:
    BOOL    IsPassive() { return m_fPassive; }

    virtual HRESULT Passivate()
    {
        if (!IsPassive())
        {
            m_fPassive=TRUE;
            return DoPassivate();
        }
        else
        {
            return S_FALSE;
        }
    }
};

#define IMPLEMENT_ADDREF_RELEASE(cls)           \
STDMETHODIMP_(ULONG) cls::AddRef()              \
{                                               \
    return InternalAddRef();                    \
}                                               \
                                                \
STDMETHODIMP_(ULONG) cls::Release()             \
{                                               \
    return InternalRelease();                   \
}

#define FAIL_AFTER_PASSIVATE() if(IsPassive()) { ATLASSERT(0); return E_FAIL; }

//---------------------------------------------------------------------------------
// CMarsComObjectDelegate is used by objects which are completely contained within
//  another object. They delegate their lifetime to the other object and are
//  passivated when the parent is passivated.

// Use:
//  derive from CMarsComObjectDelegate<ParentClass>
//  IMPLEMENT_ADDREF_RELEASE in source file
//  Implement DoPassivate()
//  Use IsPassive() and VerifyNotPassive() where appropriate
//  Use Parent() to access the parent object

template <class clsDelegateTo> class CMarsComObjectDelegate
{
    clsDelegateTo *m_pParent;

//    DEBUG_ONLY(BOOL m_fPassivateCalled);
    
protected:
    virtual ~CMarsComObjectDelegate() { ATLASSERT(m_fPassivateCalled); }

    CMarsComObjectDelegate(clsDelegateTo *pParent)
    {
        ATLASSERT(pParent);
        m_pParent = pParent;
    }
    
    ULONG InternalAddRef()     { return m_pParent->AddRef(); }
    ULONG InternalRelease()    { return m_pParent->Release(); }

    clsDelegateTo *Parent() { ATLASSERT(!IsPassive()); return m_pParent; }
    
    inline BOOL VerifyNotPassive(HRESULT *phr=NULL)
    {
        ATLASSERT(m_fPassivateCalled == IsPassive());
        
        if (m_pParent->IsPassive())
        {
            if (phr)
            {
                *phr = SCRIPT_ERROR;
            }

            return FALSE;
        }
        
        return TRUE;
    }

    virtual HRESULT DoPassivate() = 0;
    
public:
    BOOL    IsPassive() { return m_pParent->IsPassive(); }

private:    
    friend clsDelegateTo;
    HRESULT Passivate()
    {
        // TODO: assert that we are being called by our parent's DoPassivate
        ATLASSERT(m_fPassivateCalled==FALSE);
        //DEBUG_ONLY(m_fPassivateCalled=TRUE);

        return DoPassivate();
    }
};

// This typedef's some CxxxSubObject types to make syntax easier
#define TYPEDEF_SUB_OBJECT(cls) typedef CMarsComObjectDelegate<class cls> cls##SubObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\lib\evilguid.cpp ===
#include "precomp.h"

// BUGBUG define/declare these guids somewhere else!
EXTERN_C const IID IID_ITravelLog        = {0x66a9cb08, 0x4802, 0x11d2, {0xa5, 0x61, 0x00, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8}};
EXTERN_C const IID IID_ITravelEntry      = {0xf46edb3b, 0xbc2f, 0x11d0, {0x94, 0x12, 0x00, 0xaa, 0x00, 0xa3, 0xeb, 0xd3}};
EXTERN_C const IID IID_IBrowserService   = {0x02ba3b52, 0x0547, 0x11d1, {0xb8, 0x33, 0x00, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f}};
EXTERN_C const GUID SID_STopFrameBrowser = {0xa9227c3c, 0x7f8e, 0x11d0, {0x8c, 0xb0, 0x00, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    } 	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    } 	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    } 	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    } 	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    } 	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    } 	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    } 	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory **ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLNodeSource * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLNodeSource * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLNodeSource * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLNodeSource * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource * This,
    /* [in] */ IXMLNodeFactory *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ IXMLNodeFactory **ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ const WCHAR **ppwcBuf,
    /* [out] */ ULONG *pulLen,
    /* [out] */ ULONG *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ BSTR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource * This,
    /* [out] */ const WCHAR **ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLParser * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLParser * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLParser * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLParser * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IXMLParser * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXMLParser * This,
            /* [in] */ IUnknown *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *PushData )( 
            IXMLParser * This,
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDTD )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ParseEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IXMLParser * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetParserState )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IXMLParser * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecureBaseURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecureBaseURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser * This,
    /* [in] */ IUnknown *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser * This,
    /* [in] */ const char *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl,
    /* [in] */ const WCHAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser * This,
    /* [in] */ PVOID *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser * This,
    /* [in] */ const WCHAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser * This,
    /* [out] */ const WCHAR **ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE *BeginChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EndChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNode )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ XML_NODE_INFO *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO **apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory * This,
    /* [in] */ IXMLNodeSource *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO **apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\inc\marsdev.h ===
//
// Common defines used in the mars project.
//

#ifndef __MARSDEV_H
#define __MARSDEV_H


// Number of elements in array
#define ARRAYSIZE(a)   (sizeof(a)/sizeof(a[0]))

// Size of struct up to but not including specified member
#define STRUCT_SIZE_TO_MEMBER(s,m)  ((DWORD_PTR)(&(((s *)0)->m)))

// Size of a single member of a structure
#define SIZEOF_MEMBER(s,m)   sizeof(((s *)0)->m)

// Size of struct up to and including specified member
#define STRUCT_SIZE_INCLUDING_MEMBER(s,m) (STRUCT_SIZE_TO_MEMBER(s,m) + SIZEOF_MEMBER(s,m))

#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else;

//  For destructor use -- doesn't NULL pointer
#define SAFERELEASE2(p) if ((p) != NULL) { (p)->Release();} else;

// Do strong typechecking
#ifdef SAFECAST
#undef SAFECAST
#endif
#define SAFECAST(_src, _type) (static_cast<_type>(_src))

//
// Validation functions.
//

#define IsValidReadPtr(ptr) \
    ((ptr) && !IsBadReadPtr((ptr), sizeof(*(ptr))))

#define IsValidWritePtr(ptr) \
    ((ptr) && !IsBadWritePtr((ptr), sizeof(*(ptr))))

#define IsValidStringW(pstr) \
    ((pstr) && !IsBadStringPtrW((pstr), (UINT)-1))

#define IsValidReadBuffer(ptr, n) \
    ((ptr) && !IsBadReadPtr((ptr), sizeof(*(ptr)) * (n)))

#define IsValidWriteBuffer(ptr, n) \
    ((ptr) && !IsBadWritePtr((ptr), sizeof(*(ptr)) * (n)))

#define IsValidInterfacePtr(punk) \
    ((punk) && IsValidReadPtr(punk) && \
     !IsBadCodePtr(*((FARPROC*)punk)))

#define IsValidFunctionPtr(pfunc) \
    ((NULL != pfunc) && \
     !IsBadCodePtr((FARPROC)pfunc))

#define IsValidBstr(bstr) \
    ((bstr) && IsValidWriteBuffer((BYTE*)(bstr), SysStringByteLen(bstr)))

#define IsValidOptionalBstr(bstr) \
    ((!bstr) || IsValidBstr(bstr))

#define IsValidVariantBoolVal(vb) \
    (VARIANT_FALSE == vb || VARIANT_TRUE == vb)

#define IsValidVariantI4(var) \
    (VT_I4 == (var).vt)

#define IsValidVariantBstr(var) \
    (VT_BSTR == (var).vt && IsValidBstr((var).bstrVal))

#define IsValidVariantMissingOptional(var) \
    (VT_ERROR == (var).vt && DISP_E_PARAMNOTFOUND == (var).scode)

#define IsValidFlag(f, fAll) \
    (!((f) & ~(fAll)))

BOOL IsValidVariant(VARIANT var);
BOOL IsValidStringPtrBufferW(LPOLESTR* ppstr, UINT n);


#define IsValidString             IsValidStringW
#define IsValidStringPtrBuffer    IsValidStringPtrBufferW

//
// API parameter validation helpers.  Use these on public APIs.  If a parameter
// is bad on debug build a RIP message will be generated.
//

#ifdef DEBUG

BOOL API_IsValidReadPtr(void* ptr, UINT cbSize);
BOOL API_IsValidWritePtr(void* ptr, UINT cbSize);
BOOL API_IsValidStringW(LPCWSTR psz);
BOOL API_IsValidReadBuffer(void* ptr, UINT cbSize, UINT n);
BOOL API_IsValidWriteBuffer(void* ptr, UINT cbSize, UINT n);
BOOL API_IsValidInterfacePtr(IUnknown* punk);
BOOL API_IsValidFunctionPtr(void *pfunc);
BOOL API_IsValidVariant(VARIANT var);
BOOL API_IsValidVariantI4(VARIANT var);
BOOL API_IsValidVariantBstr(VARIANT var);
BOOL API_IsValidBstr(BSTR bstr);
BOOL API_IsValidOptionalBstr(BSTR bstr);
BOOL API_IsValidFlag(DWORD dwFlag, DWORD dwAllFlags);
BOOL API_IsValidStringPtrBufferW(LPOLESTR* ppStr, UINT n);

#define API_IsValidString            API_IsValidStringW
#define API_IsValidStringPtrBuffer   API_IsValidStringPtrBufferW

#endif  //Debug

#ifdef DEBUG

#define API_IsValidReadPtr(ptr) \
    API_IsValidReadPtr((ptr), sizeof(*(ptr)))

#define API_IsValidWritePtr(ptr) \
    API_IsValidWritePtr((ptr), sizeof(*(ptr)))

#define API_IsValidReadBuffer(ptr, n) \
    API_IsValidReadBuffer((ptr), sizeof(*(ptr)), (n))

#define API_IsValidWriteBuffer(ptr, n) \
    API_IsValidWriteBuffer((ptr), sizeof(*(ptr)), (n))

#else  // DEBUG

#define API_IsValidReadPtr         IsValidReadPtr
#define API_IsValidWritePtr        IsValidWritePtr
#define API_IsValidString          IsValidString
#define API_IsValidStringW         IsValidStringW
#define API_IsValidReadBuffer      IsValidReadBuffer
#define API_IsValidWriteBuffer     IsValidWriteBuffer
#define API_IsValidInterfacePtr    IsValidInterfacePtr
#define API_IsValidFunctionPtr     IsValidFunctionPtr
#define API_IsValidVariant         IsValidVariant
#define API_IsValidVariantI4       IsValidVariantI4
#define API_IsValidVariantBstr     IsValidVariantBstr
#define API_IsValidBstr            IsValidBstr
#define API_IsValidOptionalBstr    IsValidOptionalBstr
#define API_IsValidFlag            IsValidFlag
#define API_IsValidStringPtrBuffer IsValidStringPtrBufferW

#endif  // DEBUG



//
//  Function prototypes.
//

BOOL StrEqlW(LPCWSTR psz1, LPCWSTR psz2);
BOOL StrEqlA(LPCSTR psz1, LPCSTR psz2);
#define StrEql     StrEqlW

UINT64 HexStringToUINT64W(LPCWSTR lpwstr);

//
//  Macro magic to help define away functions.
//
//  TO USE:
//
//  If you don't want a function to be used in the code do the following:
//      #undef funcA
//      #define funcA   DON_USE(funcA, funcB)
//
//  This will result in funcA being redefined to Don_not_use_funcA_use_funcB.
//  A compilation error complaining that Don_not_use_funcA_use_funcB is undefined
//  will be generated whenever anyone tries to use funcA.
//

#define MACRO_CAT(a,b) \
    a##b

#define DONT_USE(a,b) \
    MACRO_CAT(Do_not_use_##a,_use_##b)


// return SCRIPT_ERROR upon serious error that shouldn't occur; will break in debug builds
#ifdef DEBUG
#define SCRIPT_ERROR E_FAIL
#else
#define SCRIPT_ERROR S_FALSE
#endif

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)


HRESULT SanitizeResult(HRESULT hr);


// BITBOOL macros just make using single-bit bools a little safer. You can't nonchalantly assign
//  any "int" value to a bit bool and expect it to always work. "BOOLIFY" it first.
//
#define BOOLIFY(expr)           (!!(expr))

// BUGBUG (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.
typedef DWORD   BITBOOL;
//

#define VARIANT_BOOLIFY(expr)   ((expr) ? VARIANT_TRUE : VARIANT_FALSE)


/*
    TraceResult Macros

    The idea behind these macros is to have one entry and exit point per
    function to reduce errors (primarily bad state / leaks).  They generally
    require an HRESULT hr, and an 'exit' label that returns hr and performs
    any cleanup that might be needed.

    In addition to encouraging a unified exit point, these macros also debug
    spew if something fails (try to only use these macros on things that
    should never fail).  This can be extremely useful when something is
    failing many layers deep in the code.  To see the spew, you need to set
    TF_TRACERESULT.  To break on such failures, set BF_TRACERESULT.

    Common mistake: you must set hr when you use IF_FAILEXIT as it is not
                    automatically set to _hresult (for flexibility).
*/

#define IF_FAILEXIT(_hresult) \
    if (FAILED(_hresult)) { \
        TraceResult(hr); \
        goto exit; \
    } else

#define IF_NULLEXIT(_palloc) \
    if (NULL == (_palloc)) { \
        hr = TraceResult(E_OUTOFMEMORY); \
        goto exit; \
    } else

#define IF_TRUEEXIT(_expression, _hresult) \
    if (_expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else

#define IF_FALSEEXIT(_expression, _hresult) \
    if (FALSE == _expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else


#define TraceResult(_hresult) _hresult

#endif  // __MARSDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\lib\dllload.cpp ===
//***************************************************************************
// delay load code ripped from shell\lib\dllload.c
//***************************************************************************

#include "precomp.h"

HINSTANCE g_hinstShell32 = NULL;

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL) {
        *phmod = LoadLibraryA(pszDLL);
        if (*phmod == NULL) {
            return;
        }
    }

    *ppfn = GetProcAddress(*phmod, pszProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\lib\precomp.h ===
//
// Precompiled header for mars lib.
//

#pragma warning(disable: 4100)  // unreferenced formal parameter

#include <windows.h>

#include <shlwapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\lib\libutils.cpp ===
#include "precomp.h"
#include <marsdev.h>

//
// Compare if two strings are equal.
//

BOOL StrEqlW(LPCWSTR psz1, LPCWSTR psz2)
{
    while (*psz1 && *psz2 && *psz1 == *psz2)
    {
        psz1++;
        psz2++;
    }
    return (L'\0' == *psz1 && L'\0' == *psz2);
}

BOOL StrEqlA(LPCSTR psz1, LPCSTR psz2)
{
    // bobn : I chose not to thunk to the wide version
    // for efficiency's sake.

    while (*psz1 && *psz2 && *psz1 == *psz2)
    {
        psz1++;
        psz2++;
    }
    return ('\0' == *psz1 && '\0' == *psz2);
}

int MapWCHARToInt(WCHAR c)
{
    int nReturn;

    if ((L'0' <= c) && (L'9' >= c))
        nReturn = c - L'0';
    else if ((L'a' <= c) && (L'f' >= c))
        nReturn = c - L'a' + 10;
    else if ((L'A' <= c) && (L'F' >= c))
        nReturn = c - L'A' + 10;
    else
    {
        nReturn = 0;
    }

    return nReturn;
}

UINT64 HexStringToUINT64W(LPCWSTR lpwstr)
{
    int     start = 0;
    UINT64  iReturn = 0;
    
    // Read away leading 0's and x prefix
    while ((lpwstr[start]) && 
           ((lpwstr[start] == L'0') || (lpwstr[start] == L'x') || (lpwstr[start] == L'X')))
    {
        start++;
    }

    // Only proceed if we have something to work with
    while (lpwstr[start])
    {        
        // Shift the current value
        iReturn <<= 4;
        
        // Place next digit
        iReturn |= MapWCHARToInt(lpwstr[start++]);
    }

    return iReturn;
}

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T]   [S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_RECORD           [V]   [P][S]  user defined type
 *  VT_I1               [V][T][P][s]  signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2              [V][T][P][S]  unsigned short
 *  VT_UI4              [V][T][P][S]  unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT              [V][T][P][S]  signed machine int
 *  VT_UINT             [V][T]   [S]  unsigned machine int
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_VERSIONED_STREAM       [P]     Stream with a GUID version
 *  VT_BLOB_OBJECT            [P]     Blob contains an object
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 *  VT_BSTR_BLOB                      Reserved for system use
 */

BOOL IsValidVariant(VARIANT var)
{
    BOOL fRet;

    if(!(var.vt & VT_BYREF))
    {
        switch(var.vt)
        {
            //
            // Types that can have any value.
            //

            case VT_EMPTY:
            case VT_NULL:
            case VT_I2:
            case VT_I4:
            case VT_R4:
            case VT_R8:
            case VT_CY:
            case VT_DATE:
            case VT_ERROR:
            case VT_DECIMAL:
            case VT_RECORD:
            case VT_I1:
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_INT:
            case VT_UINT:
                fRet = TRUE;
                break;

            case VT_BOOL:
                fRet = IsValidVariantBoolVal(var.boolVal);
                break;

            case VT_BSTR:
                fRet = (NULL == var.bstrVal) || IsValidBstr(var.bstrVal);
                break;

            case VT_DISPATCH:
                fRet = IsValidInterfacePtr(var.pdispVal);    
                break;

            case VT_UNKNOWN:
                fRet = IsValidInterfacePtr(var.punkVal);
                break;

            case VT_ARRAY:
                fRet = IsValidReadPtr(var.parray);
                break;

            default:
                fRet = FALSE; 
                break;
        }
    }
    else
    {
        // VT_BYREF

        switch(var.vt & ~VT_BYREF)
        {
            case 0: // void*
                fRet = var.byref != NULL;
                break;

            case VT_I2:
                fRet = IsValidReadPtr(var.piVal);
                break;

            case VT_I4:
                fRet = IsValidReadPtr(var.plVal);
                break;

            case VT_R4:
                fRet = IsValidReadPtr(var.pfltVal);
                break;

            case VT_R8:
                fRet = IsValidReadPtr(var.pdblVal);
                break;

            case VT_CY:
                fRet = IsValidReadPtr(var.pcyVal);
                break;

            case VT_DATE:
                fRet = IsValidReadPtr(var.pdate);
                break;

            case VT_ERROR:
                fRet = IsValidReadPtr(var.pscode);
                break;

            case VT_DECIMAL:
                fRet = IsValidReadPtr(var.pdecVal);
                break;

            case VT_I1:
                fRet = IsValidReadPtr(var.pbVal);
                break;

            case VT_UI1:
                fRet = IsValidReadPtr(var.pcVal);
                break;

            case VT_UI2:
                fRet = IsValidReadPtr(var.puiVal);
                break;

            case VT_UI4:
                fRet = IsValidReadPtr(var.pulVal);
                break;

            case VT_INT:
                fRet = IsValidReadPtr(var.pintVal);
                break;

            case VT_UINT:
                fRet = IsValidReadPtr(var.puintVal);
                break;

            case VT_BOOL:
                fRet = IsValidReadPtr(var.pboolVal);
                break;

            case VT_BSTR:
                fRet = IsValidReadPtr(var.pbstrVal);
                break;

            case VT_DISPATCH:
                fRet = IsValidReadPtr(var.ppdispVal);
                break;

            case VT_VARIANT:
                fRet = IsValidReadPtr(var.pvarVal);
                break;

            case VT_UNKNOWN:
                fRet = IsValidReadPtr(var.ppunkVal);
                break;

            case VT_ARRAY:
                fRet = IsValidReadPtr(var.pparray);
                break;

            default:
                fRet = FALSE; 
                break;
        }
   }

    return fRet;
}

BOOL IsValidStringPtrBuffer(LPOLESTR* ppStr, UINT n)
{
    BOOL fRet;

    fRet = IsValidReadBuffer(ppStr, n);

    if (fRet)
    {
        for (UINT i = 0; i < n && fRet; i++)
        {
            fRet = IsValidStringW(ppStr[i]);
        }
    }

    return fRet;
}

//
// API parameter validation helpers.  Use these on public APIs.  If a parameter
// is bad on debug build a RIP message will be generated.
//

#ifdef DEBUG
#undef API_IsValidReadPtr
BOOL API_IsValidReadPtr(void* ptr, UINT cbSize)
{
    BOOL fRet;

    if (!IsBadReadPtr(ptr, cbSize))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

#undef API_IsValidWritePtr
BOOL API_IsValidWritePtr(void* ptr, UINT cbSize)
{
    BOOL fRet;

    if (!IsBadWritePtr(ptr, cbSize))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad write pointer 0x%08lx", szFunc, ptr);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidStringW(LPCWSTR psz)
{
    BOOL fRet;

    if (IsValidString(psz))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad string pointer 0x%08lx", szFunc, psz);
        fRet = FALSE;
    }

    return fRet;
}

#undef API_IsValidReadBuffer
BOOL API_IsValidReadBuffer(void* ptr, UINT cbSize, UINT n)
{
    BOOL fRet;

    if (!IsBadWritePtr(ptr, cbSize * n))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad read buffer 0x%08lx size %d",
        //		 szFunc, ptr, n);
        fRet = FALSE;
    }

    return fRet;
}

#undef API_IsValidWriteBuffer
BOOL API_IsValidWriteBuffer(void* ptr, UINT cbSize, UINT n)
{
    BOOL fRet;

    if (!IsBadWritePtr(ptr, cbSize * n))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad write buffer 0x%08lx size %d",
        //		 szFunc, ptr, n);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidInterfacePtr(IUnknown* punk)
{
    BOOL fRet;

    if (IsValidInterfacePtr(punk))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad interface pointer 0x%08lx", szFunc, punk);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidFunctionPtr(void *pfunc)
{
    BOOL fRet;

    if (IsValidFunctionPtr(pfunc))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad function pointer 0x%08lx", szFunc, pfunc);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidVariant(VARIANT var)
{
    BOOL fRet;

    if (IsValidVariant(var))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad variant ", szFunc);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidVariantI4(VARIANT var)
{
    BOOL fRet;

    if (IsValidVariantI4(var))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad variant (should be of type I4)", szFunc);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidVariantBstr(VARIANT var)
{
    BOOL fRet;

    if (IsValidVariantBstr(var))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad variant (should be of type VT_BSTR)", szFunc);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidBstr(BSTR bstr)
{
    BOOL fRet;

    if (IsValidBstr(bstr))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad BSTR", szFunc);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidOptionalBstr(BSTR bstr)
{
    return (!bstr || API_IsValidBstr(bstr));
}

BOOL API_IsValidFlag(DWORD f, DWORD fAll)
{
    BOOL fRet;

    if (IsValidFlag(f, fAll))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed bad flags %d (valid flags = %d)", szFunc, f, fAll);
        fRet = FALSE;
    }

    return fRet;
}

BOOL API_IsValidStringPtrBufferW(LPOLESTR* ppStr, UINT n)
{
    BOOL fRet;

    if (IsValidStringPtrBuffer(ppStr, n))
    {
        fRet = TRUE;
    }
    else
    {
        //WCHAR szFunc[MAX_PATH];
        //GetFunctionName(1, szFunc, ARRAYSIZE(szFunc));
		//
        //RipMsg(L"(%s) Passed a bad array of string pointers", szFunc);
        fRet = FALSE;
    }

    return fRet;
}

#endif

//------------------------------------------------------------------------------
// SanitizeResult
//
//   OM methods called from script get sanitized results (ie S_FALSE rather than
//   E_FAIL), which suppresses script errors while allowing C-code calling OM
//   methods to get "normal" (unsanitized) HRESULTs.
//
HRESULT SanitizeResult(HRESULT hr)
{
    
    //
    // HACK:
    //  Let DISP_E_MEMBERNOTFOUND go through -- this is because
    //   behaviors use this IDispatchImpl and trident depends on this
    //    HRESULT not being S_FALSE
    //
    
    if (FAILED(hr) && (hr != DISP_E_MEMBERNOTFOUND))
    {
        hr = S_FALSE;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

//
// Retail version of new and delete.  New zero inits memory.
//

void*  __cdecl operator new(size_t cbSize)
{
    return (void*)LocalAlloc(LPTR, cbSize);
}

void  __cdecl operator delete(void *pv)
{
    if (pv) 
        LocalFree((HLOCAL)pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\axhost.cpp ===
#include "precomp.h"
#include "mcinc.h"
#include "panel.h"
#include "marswin.h"
#include "axhost.h"
//#include "befact.h"


CMarsAxHostWindow::~CMarsAxHostWindow()
{
}

STDMETHODIMP CMarsAxHostWindow::SetSite(IUnknown* pUnkSite)
{
    m_spMarsPanel.Release();
    CMarsPanel::GetFromUnknown(pUnkSite, &m_spMarsPanel);

    return CAxHostWindow::SetSite(pUnkSite);
}

STDMETHODIMP CMarsAxHostWindow::OnUIActivate()
{
    if (m_spMarsPanel)
    {
        m_spMarsPanel->OnUIActivate();
    }

    return S_OK;
}


STDMETHODIMP CMarsAxHostWindow::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    HRESULT hr;

    if (m_spMarsPanel)
    {
        hr = m_spMarsPanel->TranslateAccelerator(lpMsg, grfModifiers);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

LRESULT CMarsAxHostWindow::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_bHaveFocus = TRUE;
    if (!m_bReleaseAll)
    {
        if (m_spOleObject != NULL)
        {
            CComPtr<IOleClientSite> spClientSite;
            GetControllingUnknown()->QueryInterface(IID_IOleClientSite, (void**)&spClientSite);
            if (spClientSite != NULL)
                m_spOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, spClientSite, 0, m_hWnd, &m_rcPos);
        }
        if(!m_bWindowless && !IsChild(::GetFocus()))
            ::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
    }
    bHandled = FALSE;
    return 0;
}

LRESULT CMarsAxHostWindow::OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_spMarsPanel)
    {
        m_spMarsPanel->OnWindowPosChanging((WINDOWPOS *)lParam);
    }
    bHandled = FALSE;
    return 0;
}

LRESULT CMarsAxHostWindow::OnWindowPosChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_spMarsPanel)
    {
        m_spMarsPanel->OnWindowPosChanged((WINDOWPOS *)lParam);
    }
    bHandled = FALSE;
    return 0;
}

LRESULT CMarsAxHostWindow::OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(m_spMarsPanel)
    {
		MINMAXINFO* pInfo = (MINMAXINFO*)lParam;
		POINT       ptMin;
		POINT       ptMax;

        m_spMarsPanel->GetMinMaxInfo( ptMin, ptMax );

		if(ptMin.x >= 0) pInfo->ptMinTrackSize.x = ptMin.x;
		if(ptMin.y >= 0) pInfo->ptMinTrackSize.y = ptMin.y;
														  
		if(ptMax.x >= 0) pInfo->ptMaxTrackSize.x = ptMax.x;
		if(ptMax.y >= 0) pInfo->ptMaxTrackSize.y = ptMax.y;
    }

    return 0;
}

STDMETHODIMP CMarsAxHostWindow::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, 
                                       DISPPARAMS *pdispparams, VARIANT *pvarResult, 
                                       EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = CAxHostWindow::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, 
                                       pvarResult, pexcepinfo, puArgErr);

    if (FAILED(hr))
    {
        if ((DISPID_AMBIENT_USERAGENT == dispidMember) &&
            (DISPATCH_PROPERTYGET == wFlags) &&
            (NULL != pvarResult))
        {
            //  BUGBUG: Once "real" C++ panel interface is defined, this should be
            //  set by the host
            
            CHAR szUA[MAX_PATH];
            DWORD dwSize = ARRAYSIZE(szUA);
            if (SUCCEEDED(ObtainUserAgentString(0, szUA, &dwSize)))
            {
                LPSTR pszAppend = szUA + dwSize - 2;    // skip back to the ')'
                
                if (*pszAppend != ')')
                {
                    pszAppend = StrRChrA(szUA, pszAppend, ')');
                }
                if (pszAppend)
                {                       
                    const CHAR c_szUserAgentAppend[] = "; PCHSHELL 2.0)";

                    *pszAppend = '\0';

                    StrCatBuffA(szUA, c_szUserAgentAppend, ARRAYSIZE(szUA));

                    CComBSTR bstrUA(szUA);

                    if (bstrUA)
                    {
                        pvarResult->vt = VT_BSTR;
                        pvarResult->bstrVal = bstrUA.Detach();
                        hr = S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT CMarsAxHostWindow::AskHostForDocHostUIHandler( CComPtr<IDocHostUIHandler>& spHost )
{
	return QueryService( IID_IDocHostUIHandler, IID_IDocHostUIHandler, (void**)&spHost );
}

//  IOleInPlaceSite overrides
STDMETHODIMP CMarsAxHostWindow::GetWindowContext(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo)
{
    HRESULT hr;
    
    if (ppFrame && ppDoc && lprcPosRect && lprcClipRect)
    {
        hr = S_OK;

        if (m_spMarsPanel)
        {
            m_spMarsPanel->QueryInterface(IID_IOleInPlaceUIWindow, (void **)ppDoc);
            m_spMarsPanel->Document()->MarsWindow()->QueryInterface(IID_IOleInPlaceFrame, (void **)ppFrame);

            GetClientRect(lprcPosRect);
            GetClientRect(lprcClipRect);

            pFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
            pFrameInfo->fMDIApp = m_bMDIApp;
            pFrameInfo->hwndFrame = GetParent();

            m_spMarsPanel->Document()->MarsWindow()->GetAccelerators(&pFrameInfo->haccel, &pFrameInfo->cAccelEntries);

            hr = S_OK;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP CMarsAxHostWindow::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext) 
{
    // We let IE enable SBCMDID_ADDTOFAVORITES for us along with the other context menus
    return OLECMDERR_E_NOTSUPPORTED;
}

HRESULT CMarsAxHostWindow::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
    VARIANT *pvarargIn, VARIANT *pvarargOut)
{
    // HACK: Shdocvw sometimes tests specifically for a value like
    // OLECMDERR_E_NOTSUPPORTED and will not perform an essential action 
    // if we return something more generic like E_FAIL

    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if (pguidCmdGroup != NULL)
    {
        if (*pguidCmdGroup == CGID_DocHostCommandHandler)
        {
            // Trident calls us with this command group as an extension
            // to IDocHostUIHandler

            if (m_spMarsPanel)
            {
                hr = m_spMarsPanel->OnDocHostUIExec(pguidCmdGroup, nCmdID, 
                    nCmdexecopt, pvarargIn, pvarargOut);
            }
        }
    }
    return hr;
}



HRESULT GetDoc2FromAxWindow(CMarsAxWindow *pAxWin, IHTMLDocument2 **ppDoc2)
{
    ATLASSERT((NULL != ppDoc2) && (NULL != pAxWin));

    *ppDoc2 = NULL;

    pAxWin->QueryControl(IID_IHTMLDocument2, (void **)ppDoc2);

    if (!*ppDoc2)
    {
        CComPtr<IWebBrowser2> spWebBrowser2;
        
        pAxWin->QueryControl(IID_IWebBrowser2, (void **)&spWebBrowser2);

        if (spWebBrowser2)
        {
            CComPtr<IDispatch> spdisp;

            spWebBrowser2->get_Document(&spdisp);

            if (spdisp)
            {
                spdisp->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc2);
            }
        }
    }
    
    return (*ppDoc2) ? S_OK : E_NOINTERFACE;
}

HRESULT GetWin2FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow2 **ppWin2)
{
    ATLASSERT(NULL != ppWin2);

    *ppWin2 = NULL;
    
    if (pDoc2)
    {
        pDoc2->get_parentWindow(ppWin2);
    }

    return (NULL != *ppWin2) ? S_OK : E_FAIL;
}

HRESULT GetWin2FromAxWindow(CMarsAxWindow *pAxWin, IHTMLWindow2 **ppWin2)
{
    CComPtr<IHTMLDocument2> spDoc2;
    
    GetDoc2FromAxWindow(pAxWin, &spDoc2);
    
    return GetWin2FromDoc2(spDoc2, ppWin2);
}

HRESULT GetControlWindow(CMarsAxWindow *pAxWin, HWND *phwnd)
{
    CComPtr<IOleWindow> spOleWindow;

    if (SUCCEEDED(pAxWin->QueryControl(&spOleWindow)) &&
        SUCCEEDED(spOleWindow->GetWindow(phwnd)))
    {
        ATLASSERT((*phwnd != (HWND)-1) && (*phwnd != NULL));

        return S_OK;
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\axhost.h ===
#ifndef __AXHOST_H
#define __AXHOST_H

////////////////////////////////////////////////////////////////////////////////

#define FORWARD_IDOCHOSTUIHANDLER_INIT                                                         \
    HRESULT                    hr;                                                             \
    CComPtr<IDocHostUIHandler> spHost;                                                         \
                                                                                               \
    hr = AskHostForDocHostUIHandler( spHost );


#define FORWARD_IDOCHOSTUIHANDLER( method )                                                    \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method(); if(hr != E_NOTIMPL) return hr;                                  \
    }                                                                                          \
    return CAxHostWindow::method();


#define FORWARD_IDOCHOSTUIHANDLER_1( method, arg1 )                                            \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method( arg1 ); if(hr != E_NOTIMPL) return hr;                            \
    }                                                                                          \
    return CAxHostWindow::method( arg1 );


#define FORWARD_IDOCHOSTUIHANDLER_2( method, arg1, arg2 )                                      \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method( arg1, arg2 ); if(hr != E_NOTIMPL) return hr;                      \
    }                                                                                          \
    return CAxHostWindow::method( arg1, arg2 );


#define FORWARD_IDOCHOSTUIHANDLER_3( method, arg1, arg2, arg3 )                                \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method( arg1, arg2, arg3 ); if(hr != E_NOTIMPL) return hr;                \
    }                                                                                          \
    return CAxHostWindow::method( arg1, arg2, arg3 );


#define FORWARD_IDOCHOSTUIHANDLER_4( method, arg1, arg2, arg3, arg4 )                          \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method( arg1, arg2, arg3, arg4 ); if(hr != E_NOTIMPL) return hr;          \
    }                                                                                          \
    return CAxHostWindow::method( arg1, arg2, arg3, arg4 );


#define FORWARD_IDOCHOSTUIHANDLER_5( method, arg1, arg2, arg3, arg4, arg5 )                    \
    FORWARD_IDOCHOSTUIHANDLER_INIT;                                                            \
    if(SUCCEEDED(hr))                                                                          \
    {                                                                                          \
        hr = spHost->method( arg1, arg2, arg3, arg4, arg5 ); if(hr != E_NOTIMPL) return hr;    \
    }                                                                                          \
    return CAxHostWindow::method( arg1, arg2, arg3, arg4, arg5 );

////////////////////////////////////////////////////////////////////////////////

ATLAPI MarsAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream,
                             IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink);
ATLAPI MarsAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer);

class CMarsPanel;

class CMarsAxHostWindow :
    public CAxHostWindow,
    public IOleCommandTarget
{
public:
    ~CMarsAxHostWindow();

    BEGIN_COM_MAP(CMarsAxHostWindow)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
        COM_INTERFACE_ENTRY_CHAIN(CAxHostWindow)
    END_COM_MAP()

    DECLARE_POLY_AGGREGATABLE(CMarsAxHostWindow)
    BEGIN_MSG_MAP(CMarsAxHostWindow)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
        MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
        MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
        CHAIN_MSG_MAP(CAxHostWindow);
    END_MSG_MAP()

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWindowPosChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // IObjectWithSite overrides
    STDMETHOD(SetSite)(IUnknown* pUnkSite);

    //  IOleInPlaceSite overrides
    STDMETHOD(OnUIActivate)();

    //  IOleControlSite overrides
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);

    //  IDispatch overrides
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                      DISPPARAMS *pdispparams, VARIANT *pvarResult,
                      EXCEPINFO *pexcepinfo, UINT *puArgErr);

    //  IDocHostUIHandler overrides
    HRESULT AskHostForDocHostUIHandler( CComPtr<IDocHostUIHandler>& spHost );

    STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget, IDispatch* pDispatchObjectHit)
    {
        FORWARD_IDOCHOSTUIHANDLER_4( ShowContextMenu, dwID, pptPosition, pCommandTarget, pDispatchObjectHit );
    }

    STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo)
    {
        FORWARD_IDOCHOSTUIHANDLER_1( GetHostInfo, pInfo );
    }

    STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject, IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame, IOleInPlaceUIWindow* pDoc)
    {
        FORWARD_IDOCHOSTUIHANDLER_5( ShowUI, dwID, pActiveObject, pCommandTarget, pFrame, pDoc );
    }

    STDMETHOD(HideUI)()
    {
        FORWARD_IDOCHOSTUIHANDLER( HideUI );
    }

    STDMETHOD(UpdateUI)()
    {
        FORWARD_IDOCHOSTUIHANDLER( UpdateUI );
    }

    STDMETHOD(EnableModeless)(BOOL fEnable)
    {
        FORWARD_IDOCHOSTUIHANDLER_1( EnableModeless, fEnable );
    }

    STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
    {
        FORWARD_IDOCHOSTUIHANDLER_1( OnDocWindowActivate, fActivate );
    }

    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate)
    {
        FORWARD_IDOCHOSTUIHANDLER_1( OnFrameWindowActivate, fActivate );
    }

    STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
    {
        FORWARD_IDOCHOSTUIHANDLER_3( ResizeBorder, prcBorder, pUIWindow, fFrameWindow );
    }

    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID* pguidCmdGroup, DWORD nCmdID)
    {
        FORWARD_IDOCHOSTUIHANDLER_3( TranslateAccelerator, lpMsg, pguidCmdGroup, nCmdID );
    }

    STDMETHOD(GetOptionKeyPath)(BSTR* pbstrKey, DWORD dwReserved)
    {
        FORWARD_IDOCHOSTUIHANDLER_2( GetOptionKeyPath, pbstrKey, dwReserved );
    }

    STDMETHOD(GetDropTarget)(IDropTarget* pDropTarget, IDropTarget** ppDropTarget)
    {
        FORWARD_IDOCHOSTUIHANDLER_2( GetDropTarget, pDropTarget, ppDropTarget );
    }

    STDMETHOD(GetExternal)(IDispatch** ppDispatch)
    {
        FORWARD_IDOCHOSTUIHANDLER_1( GetExternal, ppDispatch );
    }

    STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR* pchURLIn, OLECHAR** ppchURLOut)
    {
        FORWARD_IDOCHOSTUIHANDLER_3( TranslateUrl, dwTranslate, pchURLIn, ppchURLOut );
    }

    STDMETHOD(FilterDataObject)(IDataObject* pDO, IDataObject** ppDORet)
    {
        FORWARD_IDOCHOSTUIHANDLER_2( FilterDataObject, pDO, ppDORet );
    }

	////////////////////

    //  IOleInPlaceSite overrides
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame** ppFrame, IOleInPlaceUIWindow** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO pFrameInfo);

    // IOleCommandTarget methods
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

private:
    CComClassPtr<CMarsPanel> m_spMarsPanel;
};

template <class TBase = CWindow>
    class CMarsAxWindowT : public TBase
    {
    public:
        // Constructors
        CMarsAxWindowT(HWND hWnd = NULL) : TBase(hWnd)
        { }

        CMarsAxWindowT< TBase >& operator=(HWND hWnd)
        {
            m_hWnd = hWnd;
            return *this;
        }

        // Attributes
        static LPCTSTR GetWndClassName()
        {
            return _T("PCHAxWin");
        }

        // Operations
        HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
                    DWORD dwStyle = 0, DWORD dwExStyle = 0,
                    UINT nID = 0, LPVOID lpCreateParam = NULL)
        {
            return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
        }
        HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
                    DWORD dwStyle = 0, DWORD dwExStyle = 0,
                    HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
        {
            return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
        }

        HRESULT QueryHost(REFIID iid, void** ppUnk)
        {
            ATLASSERT(ppUnk != NULL);
            HRESULT hr;
            *ppUnk = NULL;
            CComPtr<IUnknown> spUnk;
            hr = AtlAxGetHost(m_hWnd, &spUnk);
            if (SUCCEEDED(hr))
            hr = spUnk->QueryInterface(iid, ppUnk);
            return hr;
        }
        template <class Q>
            HRESULT QueryHost(Q** ppUnk)
        {
            return QueryHost(__uuidof(Q), (void**)ppUnk);
        }
        HRESULT QueryControl(REFIID iid, void** ppUnk)
        {
            ATLASSERT(ppUnk != NULL);
            HRESULT hr;
            *ppUnk = NULL;
            CComPtr<IUnknown> spUnk;
            hr = AtlAxGetControl(m_hWnd, &spUnk);
            if (SUCCEEDED(hr))
            hr = spUnk->QueryInterface(iid, ppUnk);
            return hr;
        }
        template <class Q>
            HRESULT QueryControl(Q** ppUnk)
        {
            return QueryControl(__uuidof(Q), (void**)ppUnk);
        }
        HRESULT SetExternalDispatch(IDispatch* pDisp)
        {
            HRESULT hr;
            CComPtr<IAxWinHostWindow> spHost;
            hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
            if (SUCCEEDED(hr))
            hr = spHost->SetExternalDispatch(pDisp);
            return hr;
        }
        HRESULT SetExternalUIHandler(IDocHostUIHandlerDispatch* pUIHandler)
        {
            HRESULT hr;
            CComPtr<IAxWinHostWindow> spHost;
            hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
            if (SUCCEEDED(hr))
            hr = spHost->SetExternalUIHandler(pUIHandler);
            return hr;
        }

    };

typedef CMarsAxWindowT<CWindow> CMarsAxWindow;

static LRESULT CALLBACK MarsAxWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_CREATE:
    {
        // create control from a PROGID in the title
        // This is to make sure drag drop works
        ::OleInitialize(NULL);

        CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
        int nLen = ::GetWindowTextLength(hWnd);
        LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
        ::GetWindowText(hWnd, lpstrName, nLen + 1);
        ::SetWindowText(hWnd, _T(""));
        IAxWinHostWindow* pAxWindow = NULL;
        int nCreateSize = 0;
        if (lpCreate && lpCreate->lpCreateParams)
            nCreateSize = *((WORD*)lpCreate->lpCreateParams);
        CComPtr<IStream> spStream;
        if (nCreateSize)
        {
            HGLOBAL h = GlobalAlloc(GHND, nCreateSize);
            if (h)
            {
                BYTE* pBytes = (BYTE*) GlobalLock(h);
                BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD);
                //Align to DWORD
                //pSource += (((~((DWORD)pSource)) + 1) & 3);
                memcpy(pBytes, pSource, nCreateSize);
                GlobalUnlock(h);
                CreateStreamOnHGlobal(h, TRUE, &spStream);
            }
        }
        USES_CONVERSION;
        CComPtr<IUnknown> spUnk;
        HRESULT hRet = MarsAxCreateControl(T2COLE(lpstrName), hWnd, spStream, &spUnk);
        if(FAILED(hRet))
            return -1;    // abort window creation
        hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        if(FAILED(hRet))
            return -1;    // abort window creation
        ::SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)pAxWindow );
        // check for control parent style if control has a window
        HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
        if(hWndChild != NULL)
        {
            if(::GetWindowLong(hWndChild, GWL_EXSTYLE) & WS_EX_CONTROLPARENT)
            {
                DWORD dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
                dwExStyle |= WS_EX_CONTROLPARENT;
                ::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
            }
        }
        // continue with DefWindowProc
    }
    break;
    case WM_NCDESTROY:
    {
        IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr( hWnd, GWLP_USERDATA );
        if(pAxWindow != NULL)
            pAxWindow->Release();
        OleUninitialize();
    }
    break;
    default:
        break;
    }

    return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

ATLINLINE ATLAPI_(BOOL) MarsAxWinInit()
{
    EnterCriticalSection(&_Module.m_csWindowCreate);
    WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
    WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));

    WNDCLASSEX wc;
    // first check if the class is already registered
    wc.cbSize = sizeof(WNDCLASSEX);
    BOOL bRet = ::GetClassInfoEx(_Module.GetModuleInstance(), CMarsAxWindow::GetWndClassName(), &wc);

    // register class if not

    if(!bRet)
    {
        wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
        wc.style = CS_GLOBALCLASS;
#else
        wc.style = 0;
#endif
        wc.lpfnWndProc = MarsAxWindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = CMarsAxWindow::GetWndClassName();
        wc.hIconSm = NULL;

        bRet = (BOOL)::RegisterClassEx(&wc);
    }
    LeaveCriticalSection(&_Module.m_csWindowCreate);
    return bRet;
}

ATLINLINE ATLAPI MarsAxCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer)
{
    return MarsAxCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

ATLINLINE ATLAPI MarsAxCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream * pStream,
                                       IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    MarsAxWinInit();
    HRESULT hr;
    CComPtr<IUnknown> spUnkContainer;
    CComPtr<IUnknown> spUnkControl;

    hr = CMarsAxHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
    if (SUCCEEDED(hr))
    {
        CComPtr<IAxWinHostWindow> pAxWindow;
        spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
        CComBSTR bstrName(lpszName);
        hr = pAxWindow->CreateControlEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink);
    }
    if (ppUnkContainer != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkContainer = spUnkContainer.p;
            spUnkContainer.p = NULL;
        }
        else
            *ppUnkContainer = NULL;
    }
    if (ppUnkControl != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
            spUnkControl.p = NULL;
        }
        else
            *ppUnkControl = NULL;
    }
    return hr;
}

HRESULT GetDoc2FromAxWindow(CMarsAxWindow *pAxWin, IHTMLDocument2 **ppDoc2);
HRESULT GetWin2FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow2 **ppWin2);
HRESULT GetWin2FromAxWindow(CMarsAxWindow *pAxWin, IHTMLWindow2 **ppWin2);
HRESULT GetControlWindow(CMarsAxWindow *pAxWin, HWND *phwnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\external.cpp ===
// External.cpp : Implementation of CMarsExternal
#include "precomp.h"
#include "mcinc.h"
#include "marswin.h"
#include "external.h"

#include "panel.h"
#include "place.h"

/////////////////////////////////////////////////////////////////////////////
// CMarsExternal
/////////////////////////////////////////////////////////////////////////////

CMarsExternal::CMarsExternal(CMarsPanel *pParent, CMarsWindow *pMarsWindow) :
        CMarsPanelSubObject(pParent)
{
    m_spMarsWindow = pMarsWindow;
}

HRESULT CMarsExternal::DoPassivate()
{
    m_spMarsWindow.Release();

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CMarsExternal);

//------------------------------------------------------------------------------
//  IUnknown::QueryInterface
STDMETHODIMP CMarsExternal::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(ppvObject))
    {
        if ((iid == IID_IUnknown) ||
            (iid == IID_IDispatch) ||
            (iid == IID_IMarsExternal))
        {
            AddRef();
            *ppvObject = SAFECAST(this, IMarsExternal *);
            hr = S_OK;
        }
        else
        {
            *ppvObject = NULL;
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsExternal::put_singleButtonMouse(VARIANT_BOOL bVal)
{
    ATLASSERT(IsValidVariantBoolVal(bVal));

    if (VerifyNotPassive())
    {
        m_spMarsWindow->put_SingleButtonMouse(bVal);
    }
    
    return S_OK;
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsExternal::get_singleButtonMouse(VARIANT_BOOL *pbVal)
{
    HRESULT hr = E_INVALIDARG;
    
    if (API_IsValidWritePtr(pbVal))
    {
        if (VerifyNotPassive(&hr))
        {
            *pbVal = m_spMarsWindow->get_SingleButtonMouse();
            hr = S_OK;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsExternal::get_panels(IMarsPanelCollection **ppPanels)
{
	return m_spMarsWindow->get_panels( ppPanels );
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsExternal::get_places(IMarsPlaceCollection **ppPlaces)
{
	return m_spMarsWindow->get_places( ppPlaces );
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsExternal::get_window(IMarsWindowOM **ppWindow)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(ppWindow))
    {
        *ppWindow = NULL;
        
        if (VerifyNotPassive(&hr))
        {
            hr = m_spMarsWindow->QueryInterface(IID_IMarsWindowOM, (void **)ppWindow);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\external.h ===
// External.h : Declaration of the CMarsExternal

#ifndef __MARSEXTERNAL_H_
#define __MARSEXTERNAL_H_

/////////////////////////////////////////////////////////////////////////////
// CMarsExternal

class CMarsExternal :
    public CMarsPanelSubObject,
    public MarsIDispatchImpl<IMarsExternal, &IID_IMarsExternal>
{
    friend CMarsPanel;
    CMarsExternal(CMarsPanel *pParent, CMarsWindow *pMarsWindow);
    
    virtual ~CMarsExternal() {}

    HRESULT DoPassivate();

public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IMarsExternal

    STDMETHOD(put_singleButtonMouse)(VARIANT_BOOL bVal);
    STDMETHOD(get_singleButtonMouse)(VARIANT_BOOL *pbVal);
    STDMETHOD(get_panels)(IMarsPanelCollection **ppPanels);
    STDMETHOD(get_places)(IMarsPlaceCollection **ppPlaces);
    STDMETHOD(get_window)(IMarsWindowOM **ppWindow);
    
protected:
    CComClassPtr<CMarsWindow> m_spMarsWindow;
};

#endif //__MARSEXTERNAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\globals.h ===
#ifndef __GLOBALS_H
#define __GLOBALS_H

#include "marsthrd.h"
#include <atlext.h>


typedef CMarsSimpleValArray<DWORD> CDwordArray;

extern DWORD             g_dwPerfFlags;

/////////////////////////////////////////////////
//
// This object manages all global data which must
// be protected by the Mars Critical Section. Examples
// are per-process Singleton objects like the
// Notify Spooler.
//
class CMarsGlobalsManager
{
// This class only has static methods and members -- you can't construct one of these.
private:
    CMarsGlobalsManager();
    ~CMarsGlobalsManager();

public:
    static HRESULT Passivate();
    
    static void Initialize(void);
    static void Teardown(void);

    /////////////////////////////////////////////
    // Global Storage Accessor Methods
    //
    // These methods follow the semi-standard
    // convention that a ref-counted pointer
    // return as the return value is NOT AddRef()'d
    // for the caller, and one that's returned
    // as an out-param IS.  So...
    //
    //    DO NOT RELEASE A POINTER RETURNED FROM THESE ACCESSOR METHODS!!!
    //

    static IGlobalInterfaceTable    *GIT(void);

private:
    // NOTE: We can't use CComClassPtr<>'s here because these members are static,
    //      and that means we'd need to use the CRT to get the ctors to run
    //      at startup.  we could use pointers to CComClassPtr<>'s but that would
    //      be really awkward.
    //
    static IGlobalInterfaceTable   *ms_pGIT;
    static CMarsGlobalCritSect     *m_pCS;
};


EXTERN_C HINSTANCE g_hinst;
EXTERN_C HINSTANCE g_hinstBorg;

extern HPALETTE g_hpalHalftone;

extern HANDLE   g_hScriptEvents; // see CMarsDebugOM::logScriptEvent

// Use ProcessAddRef to keep InternetActivityCenter in a GetMessage loop
// until all references are removed by ProcessRelease

LONG ProcessAddRef();
LONG ProcessRelease();

LONG GetProcessRefCount();
void SetParkingThreadId(DWORD dwThreadId);

#endif  // __GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\globals.cpp ===
#include "precomp.h"
#include "mcinc.h"
#include "globals.h"

DWORD g_dwPerfFlags;

CRITICAL_SECTION CMarsGlobalCritSect::m_CS;

IGlobalInterfaceTable   *CMarsGlobalsManager::ms_pGIT = NULL;
CMarsGlobalCritSect     *CMarsGlobalsManager::m_pCS;

EXTERN_C HINSTANCE g_hinst = NULL;
EXTERN_C HINSTANCE g_hinstBorg = NULL;
HPALETTE g_hpalHalftone = NULL;

HANDLE g_hScriptEvents = INVALID_HANDLE_VALUE;

static LONG  s_cProcessRef = 0;
static DWORD s_dwParkingThreadId = 0;

LONG ProcessAddRef()
{
    InterlockedIncrement(&s_cProcessRef);
    return s_cProcessRef;
}

LONG ProcessRelease()
{
    ATLASSERT(s_cProcessRef > 0);
    InterlockedDecrement(&s_cProcessRef);

    if (s_cProcessRef == 0)
    {
        PostThreadMessage(s_dwParkingThreadId, WM_NULL, 0, 0);
    }
    return s_cProcessRef;
}

LONG GetProcessRefCount()
{
    return s_cProcessRef;
}

void SetParkingThreadId(DWORD dwThreadId)
{
    s_dwParkingThreadId = dwThreadId;
}


void CMarsGlobalsManager::Initialize(void)
{
    //  We have to use a pointer because we need
    //  the constructor to get called (the thing has a vtable) and that
    //  won't happen for global static objects since we're CRT-less.
    m_pCS = new CMarsGlobalCritSect;

    // We're REALLY in trouble if we can't get this thing created...
    ATLASSERT(m_pCS);
}

void CMarsGlobalsManager::Teardown(void)
{
    ATLASSERT(m_pCS);
    if (m_pCS)
    {
        m_pCS->Enter();
    }

    if (NULL != ms_pGIT)
    {
        ms_pGIT->Release();
        ms_pGIT = NULL;
    }

    // Leave before we delete the Critical Section object.
    if (m_pCS)
    {
        m_pCS->Leave();
    }

    delete m_pCS;
}

//----------------------------------------------------------------------------
//  Inform everyone who registered that it is time to clean up their globals
//----------------------------------------------------------------------------
HRESULT CMarsGlobalsManager::Passivate()
{
    HRESULT hr = S_OK;
    ATLASSERT(m_pCS);
    CMarsAutoCSGrabber  csGrabber(m_pCS);

    return hr;
}

//----------------------------------------------------------------------------
//  Return the Global Interface Table object
//----------------------------------------------------------------------------
IGlobalInterfaceTable *CMarsGlobalsManager::GIT(void)
{
    ATLASSERT(m_pCS);
    CMarsAutoCSGrabber  csGrabber(m_pCS);

    if (NULL == ms_pGIT)
    {
        HRESULT hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IGlobalInterfaceTable, (void **)&ms_pGIT);
        if (FAILED(hr))
        {
            ATLASSERT(false);
        }
    }

    // NULL if there was a failure, non-NULL otherwise.

    // NOTE: We are NOT returning an AddRef()'d pointer here!!!  Caller cannot release.
    return ms_pGIT;
} // GIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\marscore.cpp ===
// marscore.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for marscore.idl by adding the following 
//      files to the Outputs.
//          marscore_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f marscoreps.mk in the project directory.

#include "precomp.h"
#include "mcinc.h"
#include "marswin.h"
#include "external.h"
#include "marsthrd.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

// for the Rating Helper Class Factory
extern GUID CLSID_MarsCustomRatingHelper;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL bResult = TRUE;
    
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hInstance;
        
		// We don't pass in the LIBID since we don't register it. Instead,
		//  "GetMarsTypeLib()" loads and caches it.
		_Module.Init(ObjectMap, hInstance, NULL);
		DisableThreadLibraryCalls(hInstance);

		// Cache a palette handle for use throughout mars
		g_hpalHalftone = SHCreateShellPalette( NULL );

		// Initialize the global CS object 
		CMarsGlobalCritSect::InitializeCritSect();

		CMarsGlobalsManager::Initialize();

		bResult = CThreadData::TlsAlloc();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();

        CThreadData::TlsFree();

        CMarsGlobalsManager::Teardown();

        // Destroy the global CS object
        CMarsGlobalCritSect::TerminateCritSect();

        if (g_hpalHalftone)
            DeleteObject(g_hpalHalftone);

        bResult = TRUE;
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

#if 0

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\marsthrd.h ===
#pragma once

//
// Marsthrd.h
//
// Classes and mechanisms for thread safety in Mars.
//

#include "marscom.h"

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  CRITICAL SECTION HELPER CLASSES
// 
//  There are several classes here, each with a specific purpose as follows:
//
//  CMarsCSBase             Abstract base class for a "smart crit sect" that inits itself.
//
//  CMarsLocalCritSect      A derivation of CMarsCSBase that has it's own CS -- an object
//                          that wants to have one CritSect per instance or per class
//                          would own one of these. NOTE: Must call _InitCS() and _TermCS()
//                          from the owner's ctor...  Use with CMarsAutoCSGrabber.
//
//  CMarsGlobalCritSect     A derivation of CMarsCSBase that has a single crit sect for
//                          the entire application.  This is a static accessor class, so
//                          one instance of the class should be created by each client wanting
//                          access to the global crit sect.  Use with CMarsAutoCSGrabber.
//
//  CMarsAutoCSGrabber      Smart object that "grabs" the crit sect and holds it for its
//                          scoped lifetime.  Drop this at the begining of a scope block
//                          (constructed with a reference to the correct CMarsCSBase) and
//                          you're protected. Default parameter fAutoEnter on the ctor
//                          allows you to not enter the CS by default. This object tracks
//                          the status of its paired calls to Enter/Leave so you can call
//                          Leave and then Re-enter and the correct thing will happen.
//
//  CMarsGlobalCSGrabber    A derivation of CMarsAutoCSGrabber that makes grabbing the
//                          global CS even easier by rolling the CMarsAutoCSGrabber together
//                          with an instance of CMarsGlobalCritSect.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  class CMarsCSBase
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
class CMarsCSBase
{
public:
    CMarsCSBase()                   {}

    virtual ~CMarsCSBase()          {}

    virtual void _CSInit()
    { 
        InitializeCriticalSection(GetCS());
    }
    virtual void _CSTerm()          { DeleteCriticalSection(GetCS()); }

    void Enter(void)
    { 
        EnterCriticalSection(GetCS());
    }
    void Leave(void)
    { 
        LeaveCriticalSection(GetCS());
    }

protected:
    virtual CRITICAL_SECTION *GetCS(void) = 0;

}; // CMarsCSBase


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  class CMarsGlobalCritSect
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
class CMarsGlobalCritSect : public CMarsCSBase
{
public:
    CMarsGlobalCritSect()               {}
    virtual ~CMarsGlobalCritSect()      {}

    static void InitializeCritSect(void)    { InitializeCriticalSection(&m_CS); }
    static void TerminateCritSect(void)     { DeleteCriticalSection(&m_CS); }

private:
    // Make these private and re-expose public static methods that initialize and terminate only
    // once per process
    virtual void _CSInit()     { return; }
    virtual void _CSTerm()     { return; }
    
    virtual CRITICAL_SECTION *GetCS(void)   { return &m_CS; }

    static CRITICAL_SECTION     m_CS;
}; // CMarsGlobalCritSect


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  class CMarsAutoCSGrabber
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
class CMarsAutoCSGrabber
{
public:
    CMarsAutoCSGrabber(CMarsCSBase *pCS, bool fAutoEnter = true)
      : m_fIsIn(false),
        m_pCS(pCS)
    {
        if (fAutoEnter)
            Enter();
    }

    ~CMarsAutoCSGrabber()
    {
        Leave();
    }

    void Enter(void)
    {
        ATLASSERT((NULL != m_pCS));

        if (!m_fIsIn && (NULL != m_pCS))
        {
            m_pCS->Enter();
            m_fIsIn = true;
        }
    }

    void Leave(void)
    {
        ATLASSERT(NULL != m_pCS);

        if (m_fIsIn && (NULL != m_pCS))
        {
            m_fIsIn = false;
            m_pCS->Leave();
        }
    }

protected:
    // Hide this and delcare with defining so if anybody uses it, the compiler barfs.
    CMarsAutoCSGrabber();

protected:
    bool            m_fIsIn;
    CMarsCSBase    *m_pCS;
}; // CMarsAutoCSGrabber


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  class CMarsGlobalCSGrabber
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
class CMarsGlobalCSGrabber
{
public:
    // Need to not allow the base ctor to do AutoEnter because it'll fail since the
    // m_CS object's ctor hasn't run yet when the CMarsAutoCSGrabber ctor is called.
    CMarsGlobalCSGrabber(bool fAutoEnter = true) : m_grabber(&m_CS, false)
    {
        if (fAutoEnter)
            Enter();
    }

    ~CMarsGlobalCSGrabber()
    {
        Leave();
    }

    void Enter(void)    { m_grabber.Enter(); }
    void Leave(void)    { m_grabber.Leave(); }

private:
    CMarsGlobalCritSect m_CS;
    CMarsAutoCSGrabber  m_grabber;
}; // CMarsGlobalCSGrabber



//---------------------------------------------------------------------------------
// CMarsComObjectThreadSafe provides some functionality used by a few Mars COM objects
// that need to be thread-safe including addref/release and passivation

// Exposed methods should be protected to ensure that they're not called while the
//  object is passive. There are three types of passivation protection:
// if (VerifyNotPassive())     - this function should not be called while passive,
//                                  but we still want to protect against it
// if (IsPassive())            - this function may be called while passive,
//                                  but we want to protect against it
// ASSERT(!IsPassive());       - we're pretty sure this won't be called while passive,
//                                  but we want to detect it if it starts happening

// Use:
//  derive from CMarsComObjectThreadSafe
//  IMPLEMENT_ADDREF_RELEASE in source file
//  Implement DoPassivate()
//  Implement GetCS() to return a CMarsCSBase * (your own or the global one, as appropriate)
//  Use IsPassive() and VerifyNotPassive() where appropriate
//  Don't call "delete" directly
//  CYourClass->Passivate() should be called before CYourClass->Release()
//
class CMarsComObjectThreadSafe : protected CMarsComObject
{
public:
    BOOL    IsPassive()
    {
        CMarsAutoCSGrabber  cs(GetCS());

        return CMarsComObject::IsPassive();
    }

    virtual HRESULT Passivate()
    {
        CMarsAutoCSGrabber  cs(GetCS());

        return CMarsComObject::Passivate();
    }

protected:
    CMarsComObjectThreadSafe()
    {
    }

    virtual ~CMarsComObjectThreadSafe() { }

    ULONG InternalAddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    ULONG InternalRelease()
    {
        if (InterlockedDecrement(&m_cRef))
        {
            return m_cRef;
        }

        delete this;

        return 0;
    }

    inline BOOL VerifyNotPassive(HRESULT *phr=NULL)
    {
        CMarsAutoCSGrabber  cs(GetCS());

        return CMarsComObject::VerifyNotPassive(phr);
    }

    virtual HRESULT DoPassivate() = 0;

    virtual CMarsCSBase *GetCS() = 0;
}; // CMarsComObjectThreadSafe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\marsevt.h ===
// MarsEvt.h contains list of all events that script can sink
//
// Any new events must be added here and documented appropriately
//-------------------------------------------------------------------

//-------------------------------------------------------------------
// PANEL events
//-------------------------------------------------------------------

// OnNCHitTest(long x, long y) - return HTCLIENT (1) or HTCAPTION (2)
const WCHAR c_wszEvt_Window_NCHitTest[] =           L"Window.NCHitTest";
const WCHAR c_wszBeEvt_Window_NCHitTest[] =         L"onNCHitTest";

// OnActivate(bool bActive)
const WCHAR c_wszEvt_Window_Activate[] =            L"Window.Activate";
const WCHAR c_wszBeEvt_Window_Activate[] =          L"onActivate";

// OnActivate(panel Panel, bool bActive)
const WCHAR c_wszEvt_Panel_Activate[] =             L"Panel.Activate";
const WCHAR c_wszBeEvt_Panel_Activate[] =           L"onActivate";

// OnShow(panel Panel, bool bVisible)
const WCHAR c_wszEvt_Panel_Show[] =                 L"Panel.Show";
const WCHAR c_wszBeEvt_Panel_Show[] =               L"onShow";

// OnAllowBlur(long lReason)
const LONG ALLOWBLUR_MOUSECLICK   = 1;
const LONG ALLOWBLUR_TABKEYPRESS  = 2;
const LONG ALLOWBLUR_POPUPWINDOW  = 4;
const LONG ALLOWBLUR_SHUTTINGDOWN = 8;
const WCHAR c_wszEvt_Window_AllowBlur[] =           L"Window.AllowBlur";
const WCHAR c_wszBeEvt_Window_AllowBlur[] =         L"onAllowBlur";

const WCHAR c_wszBeEvt_Window_SysCommand[] =        L"onSysCommand";

// OnTrustedFind(panel, strPlaceName)
const WCHAR c_wszBeEvt_Panel_TrustedFind[] =        L"onTrustedFind";

// OnTrustedPrint(panel, strPlaceName)
const WCHAR c_wszBeEvt_Panel_TrustedPrint[] =       L"onTrustedPrint";

// OnTrustedRefresh(panel, strPlaceName, bool FullRefresh)
const WCHAR c_wszBeEvt_Panel_TrustedRefresh[] =     L"onTrustedRefresh";


//-------------------------------------------------------------------
// PLACE events
//-------------------------------------------------------------------

// OnBeginTransition(strPlaceFrom, strPlaceTo)
const WCHAR c_wszEvt_Place_BeginTransition[] =      L"Place.BeginTransition";
const WCHAR c_wszBeEvt_Place_BeginTransition[] =    L"onBeginTransition";

// OnTransitionComplete(strPlaceFrom, strPlaceTo)
const WCHAR c_wszEvt_Place_TransitionComplete[] =   L"Place.TransitionComplete";
const WCHAR c_wszBeEvt_Place_TransitionComplete[] = L"onTransitionComplete";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\mcinc.h ===
//
//  MarsCore non-precompiled header file.
//

#pragma once 

#include <atlext.h>
#include <marscore.h>
#include "util.h"
//#include "cstrw.h"
#include "globals.h"
#include <marscom.h>


#ifdef __MARS_INLINE_FAST_IS_EQUAL_GUID

__forceinline int operator==(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

#else

__forceinline int operator==(REFGUID guidOne, REFGUID guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}

#endif

__forceinline int operator!=(REFGUID guidOne, REFGUID guidOther)
{
    return !(guidOne == guidOther);
}



TYPEDEF_SUB_OBJECT(CMarsWindow);        // CMarsWindowSubObject
TYPEDEF_SUB_OBJECT(CMarsPanel);         // CMarsPanelSubObject
TYPEDEF_SUB_OBJECT(CPanelCollection);   // CPanelCollectionSubObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\pandef.cpp ===
//********************************************************************************
// MAKE NOTE:
// =========
//   This file is included by parser\comptree
//   If you modify this file, please make sure that parser\comptree still builds.
//
//   You have been warned.
//********************************************************************************
// String map used when script sets a panel's position
const struct tagPositionMap s_PositionMap[] =
{
    { L"Left",   PANEL_LEFT     },
    { L"Right",  PANEL_RIGHT    },
    { L"Top",    PANEL_TOP      },
    { L"Bottom", PANEL_BOTTOM   },
    { L"Window", PANEL_WINDOW   },
    { L"Popup",  PANEL_POPUP    },
    { L"Client", PANEL_WINDOW   },
    { L"Overlapped",PANEL_POPUP }
};
const int c_iPositionMapSize = sizeof(s_PositionMap)/sizeof(s_PositionMap[0]);


HRESULT StringToPanelPosition(LPCWSTR pwszPosition, PANEL_POSITION *pPosition)
{
    HRESULT hr = E_FAIL;

    ATLASSERT(pPosition);

    *pPosition = PANEL_INVALID;

    if (pwszPosition)
    {
        for (int i = 0; i < c_iPositionMapSize; i++)
        {
            if (0 == StrCmpI(pwszPosition, s_PositionMap[i].pwszName))
            {
                *pPosition = s_PositionMap[i].Position;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

void StringToPanelFlags(LPCWSTR pwsz, DWORD &dwFlags, long lLen /* =-1 */)
{
    if (pwsz)
    {
        if(lLen == -1) lLen = lstrlenW( pwsz );

        if(!StrCmpNIW( pwsz, L"OnStart", lLen ))
        {
            dwFlags &= ~PANEL_FLAG_ONDEMAND;
        }
		else if(!StrCmpNIW( pwsz, L"WebBrowser", lLen ))
        {
            dwFlags |= PANEL_FLAG_WEBBROWSER;
        }
        else if(!StrCmpNIW( pwsz, L"CustomControl", lLen ))
        {
            dwFlags |= PANEL_FLAG_CUSTOMCONTROL;
        }
    }
}



void StringToPersistVisibility(LPCWSTR pwsz, PANEL_PERSIST_VISIBLE &persistVis)
{
    if (pwsz)
    {
        if (0 == StrCmpIW(pwsz, L"Never"))
        {
            persistVis = PANEL_PERSIST_VISIBLE_NEVER;
        }
        else if (0 == StrCmpIW(pwsz, L"Always"))
        {
            persistVis = PANEL_PERSIST_VISIBLE_ALWAYS;
        }
        else if (0 == StrCmpIW(pwsz, L"DontTouch"))
        {
            persistVis = PANEL_PERSIST_VISIBLE_DONTTOUCH;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\marswin.h ===
#ifndef __MARSWIN_H
#define __MARSWIN_H

#include "marsevt.h"
#include "profsvc.h"

//
// The compiler doesn't like this perfectly correct code:
//
//    MESSAGE_RANGE_HANDLER(0, 0xFFFF, ForwardToMarsHost);
//
#pragma warning(disable:4296)  // expression is always true/false


EXTERN_C const GUID CLASS_CMarsWindow;
EXTERN_C const GUID CLASS_CMarsDocument;
const LONG FLASH_TIMER_ID = 42;

class CMarsPanel;

struct CMarsEventSink
{
    CComPtr<IDispatch>  m_spDispatchSink;
    CComPtr<IUnknown>   m_spUnknownOwner;
    CMarsEventSink      *m_pNext;

    BOOL                m_fPendingDelete : 1;   //  Needs to be deleted ASAP

    CMarsEventSink(IDispatch *pDispatchSink, IUnknown *pUnknownOwner, CMarsEventSink *pNext)
    {
        m_spDispatchSink = pDispatchSink;
        m_spUnknownOwner = pUnknownOwner;
        m_pNext = pNext;
    }
};

struct CEventSinkList
{
    CMarsEventSink  *m_pEventSinks;

    int             m_cBusyLock;            //  Not safe to delete items in the list
    BOOL            m_fPendingDeletes : 1;  //  Have items to delete

    void DoPendingDeletes()
    {
        if (m_fPendingDeletes)
        {
            CMarsEventSink **ppNextEventSink = &m_pEventSinks;
            CMarsEventSink *pEventSink;

            while (*ppNextEventSink)
            {
                pEventSink = *ppNextEventSink;

                if (pEventSink->m_fPendingDelete)
                {
                    *ppNextEventSink = pEventSink->m_pNext;

                    if (pEventSink->m_pNext)
                    {
                        ppNextEventSink = &pEventSink->m_pNext->m_pNext;
                    }
                    delete pEventSink;
                }
                else
                {
                    ppNextEventSink = &pEventSink->m_pNext;
                }
            }
            m_fPendingDeletes = FALSE;
        }
    }

    ~CEventSinkList()
    {
        CMarsEventSink *pEventSink = m_pEventSinks;

        while (NULL != pEventSink)
        {
            CMarsEventSink *pNextSink = pEventSink->m_pNext;

            delete pEventSink;

            pEventSink = pNextSink;
        }
    }
};

struct CMarsPanelProp
{
    CComPtr<IUnknown>   m_spUnknownOwner;
    CComVariant         m_var;

    CMarsPanelProp(VARIANT& var, IUnknown *pUnknownOwner)
    {
        m_var = var;
        m_spUnknownOwner = pUnknownOwner;
    }
};

class CMarsDocument :   public CMarsComObject,
                        public IServiceProvider
{
protected:
    virtual ~CMarsDocument();
    CMarsDocument();

    HRESULT     DoPassivate();
    HRESULT     Init(CMarsWindow *pMarsWindow, CMarsPanel *pHostPanel);

public:
    //  IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    static HRESULT  CreateInstance(CMarsWindow *pMarsWindow, CMarsPanel *pHostPanel, CMarsDocument **ppObj);

    // Panel/Place methods
    HRESULT         ReadPanelDefinition(LPCWSTR pwszUrl);
    class CPanelCollection *GetPanels() { ATLASSERT(m_spPanels); return m_spPanels; }
    class CPlaceCollection *GetPlaces() { ATLASSERT(m_spPlaces); return m_spPlaces; }

    HRESULT         GetPlaces(IMarsPlaceCollection **ppPlaces);

    // Window that the document is in.
    CWindow        *Window() { return &m_cwndDocument; }

    // Window that the application is in.
    CMarsWindow    *MarsWindow() { ATLASSERT(m_spMarsWindow); return m_spMarsWindow; }

    void            ForwardMessageToChildren(UINT uMsg, WPARAM wParam, LPARAM lParam);

    static HRESULT GetFromUnknown(IUnknown *punk, CMarsDocument **ppMarsDocument)
    {
        return IUnknown_QueryService(punk, SID_SMarsDocument, CLASS_CMarsDocument, (void **)ppMarsDocument);
    }

private:
    // Topmost application window + app services
    CComClassPtr<CMarsWindow>           m_spMarsWindow;

    // Panels and places within this document
    CComClassPtr<class CPanelCollection>    m_spPanels;
    CComClassPtr<class CPlaceCollection>    m_spPlaces;

    // Window for this document (either CMarsWindow or CPanel)
    CWindow                             m_cwndDocument;

    // Panel that this doc is hosted in (if any)
    CComClassPtr<class CMarsPanel>      m_spHostPanel;
};

typedef MarsIDispatchImpl<IMarsWindowOM, &IID_IMarsWindowOM> IMarsWindowOMImpl;

class CMarsWindow :
                public CMarsDocument,
                public CWindowImpl<CMarsWindow>,
                public IMarsWindowOMImpl,
                public IProfferServiceImpl,
                public IOleInPlaceFrame
{
protected:
    virtual ~CMarsWindow();
    CMarsWindow();

    HRESULT     DoPassivate();
    HRESULT     Init(IMarsHost *pMarsHost, MARSTHREADPARAM *pThreadParam);
    HRESULT     Startup();
    void        DoShowWindow(int nCmdShow);

public:
    static HRESULT  CreateInstance(IMarsHost *pMarsHost, MARSTHREADPARAM *pThreadParam, CMarsWindow **ppObj);

    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IDispatch
    IMPLEMENT_IDISPATCH_DELEGATE_TO_BASE(IMarsWindowOMImpl);

    // IMarsWindowOM
    STDMETHOD(get_active)(VARIANT_BOOL *pbActive);
    STDMETHOD(get_minimized)(VARIANT_BOOL *pbMinimized);
    STDMETHOD(put_minimized)(VARIANT_BOOL bMinimized);
    STDMETHOD(get_maximized)(VARIANT_BOOL *pbMaximized);
    STDMETHOD(put_maximized)(VARIANT_BOOL bMaximized);
    STDMETHOD(get_title)(BSTR *pbstrTitle);
    STDMETHOD(put_title)(BSTR bstrTitle);
    STDMETHOD(get_height)(long *plHeight);
    STDMETHOD(put_height)(long lHeight);
    STDMETHOD(get_width)(long *plWidth);
    STDMETHOD(put_width)(long lWidth);
    STDMETHOD(get_x)(long *plX);
    STDMETHOD(put_x)(long lX);
    STDMETHOD(get_y)(long *plY);
    STDMETHOD(put_y)(long lY);
    STDMETHOD(get_visible)(VARIANT_BOOL *pbVisible);
    STDMETHOD(put_visible)(VARIANT_BOOL bVisible);

    STDMETHOD(get_panels)(IMarsPanelCollection **ppPanels);
    STDMETHOD(get_places)(IMarsPlaceCollection **ppPlaces);

    STDMETHOD(setWindowDimensions)( /*[in]*/ long lX, /*[in]*/ long lY, /*[in]*/ long lW, /*[in]*/ long lH );
    STDMETHOD(close)();
    STDMETHOD(refreshLayout)();

    // IServiceProvider methods
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceUIWindow
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleInPlaceFrame
    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus(HMENU hmenuShared);
    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // CWindowImpl
    static CWndClassInfo& GetWndClassInfo()
    {
        static CWndClassInfo wc =
        {
            { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc,
              0, 0, NULL, NULL, NULL,
              (HBRUSH)(COLOR_WINDOW + 1), NULL, _T("PCHShell Window"), NULL },
            NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
        };

        return wc;
    }

    BEGIN_MSG_MAP(CMarsWindow)
        MESSAGE_RANGE_HANDLER(0, 0xFFFF         , ForwardToMarsHost);
        MESSAGE_HANDLER      (WM_CREATE         , OnCreate         );
        MESSAGE_HANDLER      (WM_SIZE           , OnSize           );
        MESSAGE_HANDLER      (WM_CLOSE          , OnClose          );
        MESSAGE_HANDLER      (WM_NCCALCSIZE     , OnNCCalcSize     );
        MESSAGE_HANDLER      (WM_NCACTIVATE     , OnNCActivate     );
        MESSAGE_HANDLER      (WM_ACTIVATE       , OnActivate       );
        MESSAGE_HANDLER      (WM_ERASEBKGND     , OnEraseBkgnd     );
        MESSAGE_HANDLER      (WM_PAINT          , OnPaint          );
        MESSAGE_HANDLER      (WM_NCPAINT        , OnNCPaint        );
        MESSAGE_HANDLER      (WM_PALETTECHANGED , OnPaletteChanged );
        MESSAGE_HANDLER      (WM_QUERYNEWPALETTE, OnQueryNewPalette);
        MESSAGE_HANDLER      (WM_SYSCOLORCHANGE , OnSysColorChange );
        MESSAGE_HANDLER      (WM_DISPLAYCHANGE  , OnDisplayChange  );
        MESSAGE_HANDLER      (WM_SYSCOMMAND     , OnSysCommand     );
        MESSAGE_HANDLER      (WM_SETFOCUS       , OnSetFocus       );
        MESSAGE_HANDLER      (WM_SETTEXT        , OnSetText        );
        MESSAGE_HANDLER      (WM_GETMINMAXINFO  , OnGetMinMaxInfo  );
    END_MSG_MAP()

    // Window message handlers
    BOOL    PreTranslateMessage (MSG &msg);
    BOOL    TranslateAccelerator(MSG &msg);

    LRESULT ForwardToMarsHost(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate         (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize           (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose          (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNCCalcSize     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNCActivate     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnActivate       (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint          (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNCPaint        (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaletteChanged (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysColorChange (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDisplayChange  (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand     (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus       (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetText        (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGetMinMaxInfo  (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    ////////////////////////////////////////

    void GetMinMaxInfo( CPanelCollection *spPanels, int pos, POINT& ptMin, POINT& ptMax );
    void FixLayout    ( CPanelCollection *spPanels, int index, RECT rcClient, POINT& ptDiff );

    bool CanLayout( /*[in]*/ RECT rcClient );
    void FixLayout( /*[in]*/ RECT rcClient );

    ////////////////////////////////////////

    void OnFinalMessage (HWND hWnd);

    // Eventing Methods
    STDMETHODIMP    ReleaseOwnedObjects(IUnknown *pUnknownOwner);

    void            CancelEvent(VARIANT_BOOL bCancel) { m_bEventCancelled = bCancel; }
    VARIANT_BOOL    IsEventCancelled() { return m_bEventCancelled; }

    void            OnTransitionComplete();
    void            SetFirstPlace( LPCWSTR szPlace );

    // Other methods
    HRESULT         Passivate();
    BOOL            IsWindowActive() { return m_fActiveWindow; }
    void            ShowTitleBar(BOOL fShowTitleBar);

    STDMETHODIMP    GetSetting(BSTR bstrSubPath, BSTR bstrName, VARIANT *pvarVal);
    STDMETHODIMP    PutSetting(BSTR bstrSubPath, BSTR bstrName, VARIANT varVal);
    STDMETHODIMP    PutProperty(BSTR bstrName, VARIANT varVal, IUnknown *punkOwner);
    STDMETHODIMP    GetProperty(BSTR bstrName, VARIANT *pvarVal);

    VARIANT_BOOL    get_SingleButtonMouse() { return m_bSingleButtonMouse; }
    void            put_SingleButtonMouse(VARIANT_BOOL bVal) { m_bSingleButtonMouse = bVal; }

    void SpinMessageLoop( BOOL fWait );

    HRESULT NotifyHost(MARSHOSTEVENT event, IUnknown *punk, LPARAM lParam)
    {
        HRESULT hr;

        if(m_spMarsHost)
        {
            hr = m_spMarsHost->OnHostNotify(event, punk, lParam);

            if(hr == E_NOTIMPL)
            {
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;
        }

        return hr;
    }

    void GetAccelerators(HACCEL *phAccel, UINT *pcAccel)
    {
        if (!m_hAccel)
        {
            ACCEL ac = { 0,0,0 };
            m_hAccel = CreateAcceleratorTable(&ac, 1);
        }

        *phAccel = m_hAccel;
        *pcAccel = m_hAccel ? 1 : 0;
    }

    MARSTHREADPARAM *GetThreadParam()
    {
        ATLASSERT(m_pThreadParam);
        return m_pThreadParam;
    };

    static HRESULT GetFromUnknown(IUnknown *punk, CMarsWindow **ppMarsWindow)
    {
        return IUnknown_QueryService(punk, SID_SMarsWindow, CLASS_CMarsWindow, (void **) ppMarsWindow);
    }

    bool InitWindowPosition( CGlobalSettingsRegKey& regkey, BOOL fWrite                                                 );
    void SaveWindowPosition( CGlobalSettingsRegKey& regkey                                                              );
    void LoadWindowPosition( CGlobalSettingsRegKey& regkey, BOOL fAllowMaximized, WINDOWPLACEMENT& wp, BOOL& fMaximized );

protected:

    HWND               m_hwndFocus;

    BOOL               m_fActiveWindow     : 1;  // Are we the active window?
    BOOL               m_fShowTitleBar     : 1;
    BOOL               m_fStartMaximized   : 1;  // Will we start off maximized?
    BOOL               m_fUIPanelsReady    : 1;  // Have all our UI panels finished loading yet?
    BOOL               m_fDeferMakeVisible : 1;  // Did someone put_visible(TRUE) before the UI was ready?
    BOOL               m_fEnableModeless   : 1;  // Should modeless dlgs and stuff be enabled?
    BOOL               m_fLayoutLocked     : 1;  // When minimized, layout is locked.

    HACCEL             m_hAccel;

    VARIANT_BOOL       m_bEventCancelled;
    VARIANT_BOOL       m_bSingleButtonMouse;

    CComPtr<IMarsHost> m_spMarsHost;
    MARSTHREADPARAM*   m_pThreadParam;
    CComBSTR           m_bstrFirstPlace;
};

#endif // __MARSWIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\panel.cpp ===
#include "precomp.h"

#define __MARS_INLINE_FAST_IS_EQUAL_GUID
#define LIGHTWEIGHT_AUTOPERSIST
#define BLOCK_PANEL_RENAVIGATES
#include "mcinc.h"
#include <evilguid.h>
#include "marswin.h"

#include "pandef.h"
#include "panel.h"
#include "place.h"
#include "htiface.h"
#include "mimeinfo.h"
#include <exdispid.h>
#include "dllload.h"
#include <perhist.h>
#include <mshtmcid.h>

// We include this cpp file because the stuff
//   in pandef needs to be included in another project
//   namely, parser\comptree
#include "pandef.cpp"

// CLSID strings passed to ATL to create control
static WCHAR wszCLSID_HTMLDocument[]        = L"{25336920-03F9-11CF-8FD0-00AA00686F13}";
static WCHAR wszCLSID_WebBrowser[]          = L"{8856F961-340A-11D0-A96B-00C04FD705A2}";
static WCHAR wszCLSID_HTADocument[]         = L"{3050f5c8-98b5-11cf-bb82-00aa00bdce0b}";
const GUID CLSID_HTADoc = { 0x3050f5c8, 0x98b5, 0x11cf, { 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b } };

// CLASS_CMarsPanel = {EE0462C2-5CD3-11d3-97FA-00C04F45D0B3}
const GUID CLASS_CMarsPanel = { 0xee0462c2, 0x5cd3, 0x11d3, { 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0x45, 0xd0, 0xb3 } };

CMarsPanel::CMarsPanel(CPanelCollection *pParent, CMarsWindow *pMarsWindow) :
    m_MarsExternal(this, pMarsWindow),
    m_BrowserEvents(this)
{
    m_spPanelCollection = pParent;
    m_spMarsDocument = m_spPanelCollection->Document();

    m_lReadyState = READYSTATE_COMPLETE;
}

CMarsPanel::~CMarsPanel()
{
}

HRESULT CMarsPanel::Passivate()
{
    return CMarsComObject::Passivate();
}

HRESULT CMarsPanel::DoPassivate()
{
    m_spMarsDocument->MarsWindow()->NotifyHost(MARSHOST_ON_PANEL_PASSIVATE, SAFECAST(this, IMarsPanel *), 0);

    m_spPanelCollection->SetActivePanel(this, FALSE);

    // First we unload the document so that script can do work in its "onunload"
    // handler, before we become passive
    if(IsWebBrowser())
    {
        CComPtr<IUnknown> spUnk;

        if (SUCCEEDED(m_Content.QueryControl(IID_IUnknown, (void **)&spUnk)))
        {
            m_BrowserEvents.Connect(spUnk, FALSE);
        }
    }
    else if(IsCustomControl())
    {
    }
    else
    {
        DisconnectCompletionAdviser();
    }

    m_Content.DestroyWindow();

    ////////////////////////////////////////

    m_spMarsDocument->MarsWindow()->ReleaseOwnedObjects(SAFECAST(this, IDispatch *));


    m_BrowserEvents.Passivate();
    m_MarsExternal.Passivate();

    m_spBrowserService.Release();

    m_spPanelCollection.Release();
    m_spMarsDocument.Release();

    return S_OK;
}

// IUnknown
IMPLEMENT_ADDREF_RELEASE(CMarsPanel);

STDMETHODIMP CMarsPanel::QueryInterface(REFIID iid, void ** ppvObject)
{
    ATLASSERT(ppvObject);

    if ((iid == IID_IUnknown) ||
        (iid == IID_IDispatch) ||
        (iid == IID_IMarsPanel))
    {
        *ppvObject = SAFECAST(this, IMarsPanel *);
    }
    else if (iid == IID_IHlinkFrame)
    {
        *ppvObject = SAFECAST(this, IHlinkFrame *);
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppvObject = SAFECAST(this, IServiceProvider *);
    }
    else if (iid == IID_IInternetSecurityManager)
    {
        *ppvObject = SAFECAST(this, IInternetSecurityManager *);
    }
    else if ((iid == IID_IOleInPlaceSite) || (iid == IID_IOleWindow))
    {
        *ppvObject = SAFECAST(this, IOleInPlaceSite *);
    }
    else if (iid == IID_IOleControlSite)
    {
        *ppvObject = SAFECAST(this, IOleControlSite *);
    }
    else if (iid == IID_IPropertyNotifySink)
    {
        *ppvObject = SAFECAST(this, IPropertyNotifySink *);
    }
    else if (iid == IID_IProfferService)
    {
        *ppvObject = SAFECAST(this, IProfferService *);
    }
    else if (iid == IID_IOleInPlaceUIWindow)
    {
        *ppvObject = SAFECAST(this, IOleInPlaceUIWindow *);
    }
    else if (iid == CLASS_CMarsPanel)
    {
        *ppvObject = SAFECAST(this, CMarsPanel *);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT CMarsPanel::DoEnableModeless(BOOL fEnable)
{
    CComPtr<IOleInPlaceActiveObject> spOleInPlaceActiveObject;

    HRESULT hr = m_Content.QueryControl(&spOleInPlaceActiveObject);

    if (SUCCEEDED(hr))
    {
        spOleInPlaceActiveObject->EnableModeless(fEnable);
    }

    return hr;
}

//==================================================================
// Automation Object Model
//==================================================================

//------------------------------------------------------------------------------
// IMarsPanel::get_name
//
HRESULT CMarsPanel::get_name( BSTR *pbstrName )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbstrName ))
    {
        *pbstrName = SysAllocString( GetName() );

        hr = (NULL != *pbstrName) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_content
//
HRESULT CMarsPanel::get_content( IDispatch* *ppVal )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( ppVal ))
    {
        *ppVal = NULL;

        if(VerifyNotPassive( &hr ))
        {
            CreateControl();

            hr = m_Content.QueryControl( ppVal );
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_visible
//
HRESULT CMarsPanel::get_visible( VARIANT_BOOL *pbVisible )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbVisible ))
    {
        if(VerifyNotPassive( &hr ))
        {
            *pbVisible = VARIANT_BOOLIFY( m_fVisible );
            hr = S_OK;
        }
        else
        {
            *pbVisible = VARIANT_FALSE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_visible
//
HRESULT CMarsPanel::put_visible( VARIANT_BOOL bVisible )
{
    ATLASSERT(IsValidVariantBoolVal( bVisible ));

    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(!!m_fVisible != !!bVisible)
        {
            m_fVisible = (bVisible != VARIANT_FALSE);

			if(!m_fVisible)
			{
				m_spPanelCollection->SetActivePanel( this, FALSE );
			}

            // If the theme has changed while the panel was invisible,
            // now is a good time to automatically update it
            if(m_fVisible && IsContentInvalid())
            {
                refresh();
            }

            OnLayoutChange();
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_startUrl
//
HRESULT CMarsPanel::get_startUrl( BSTR *pVal )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pVal ))
    {
        *pVal = m_bstrStartUrl.Copy();

        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_startUrl
//
HRESULT CMarsPanel::put_startUrl( BSTR newVal )
{
    HRESULT hr = S_OK;

    m_bstrStartUrl = newVal;

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_height
//
HRESULT CMarsPanel::get_height( long *plHeight )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( plHeight ))
    {
        if(VerifyNotPassive( &hr ))
        {
            hr = S_OK;

            if(m_Content.IsWindowVisible())
            {
                // Use actual position
                RECT rc;

                m_Content.GetWindowRect( &rc );

                *plHeight = rc.bottom - rc.top;
            }
            else
            {
                // Panel's hidden. Return requested position.
                *plHeight = m_lHeight;
            }
        }
        else
        {
            *plHeight = 0;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_height
//
HRESULT CMarsPanel::put_height( long lHeight )
{
    ATLASSERT(lHeight >= 0);

    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(lHeight >= 0)
        {
            if(m_lMinHeight >= 0 && lHeight < m_lMinHeight) lHeight = m_lMinHeight;
            if(m_lMaxHeight >= 0 && lHeight > m_lMaxHeight) lHeight = m_lMaxHeight;

            if(m_lHeight != lHeight)
            {
                m_lHeight = lHeight;

                OnLayoutChange();
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_width
//
HRESULT CMarsPanel::get_width( long *plWidth )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( plWidth ))
    {
        if(VerifyNotPassive( &hr ))
        {
            if(m_Content.IsWindowVisible())
            {
                // Use actual position
                RECT rc;

                m_Content.GetWindowRect( &rc );

                *plWidth = rc.right - rc.left;
            }
            else
            {
                // Panel's hidden. Return requested position.
                *plWidth = m_lWidth;
            }

            hr = S_OK;
        }
        else
        {
            *plWidth = 0;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_width
//
HRESULT CMarsPanel::put_width( long lWidth )
{
    ATLASSERT(lWidth >= 0);

    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(lWidth >= 0)
        {
            if(m_lMinWidth >= 0 && lWidth < m_lMinWidth) lWidth = m_lMinWidth;
            if(m_lMaxWidth >= 0 && lWidth > m_lMaxWidth) lWidth = m_lMaxWidth;

            if(m_lWidth != lWidth)
            {
                m_lWidth = lWidth;

                OnLayoutChange();
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_x
//
HRESULT CMarsPanel::get_x( long *plX )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( plX ))
    {
        if(VerifyNotPassive( &hr ))
        {
            hr = S_OK;

            if(m_Content.IsWindowVisible())
            {
                // Use actual position
                RECT rc;

                GetMyClientRectInParentCoords( &rc );

                *plX = rc.left;
            }
            else
            {
                // Panel's hidden. Return requested position.
                *plX = m_lX;
            }
        }
        else
        {
            *plX = 0;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_x
//
HRESULT CMarsPanel::put_x( long lX )
{
    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(m_lX != lX)
        {
            m_lX = lX;

            if(IsPopup())
            {
                OnLayoutChange();
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_y
//
HRESULT CMarsPanel::get_y( long *plY )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( plY ))
    {
        if(VerifyNotPassive( &hr ))
        {
            hr = S_OK;

            if(m_Content.IsWindowVisible())
            {
                // Use actual position
                RECT rc;

                GetMyClientRectInParentCoords( &rc );

                *plY = rc.top;
            }
            else
            {
                *plY = m_lY;
            }
        }
        else
        {
            *plY = 0;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_y
//
HRESULT CMarsPanel::put_y( long lY )
{
    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(m_lY != lY)
        {
            m_lY = lY;

            if(IsPopup())
            {
                OnLayoutChange();
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_position
//
HRESULT CMarsPanel::get_position( VARIANT *pvarPosition )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pvarPosition ))
    {
        if(VerifyNotPassive( &hr ))
        {
            VariantClear( pvarPosition );

            hr = S_FALSE;

            if(m_Position <= c_iPositionMapSize)
            {
                pvarPosition->bstrVal = SysAllocString( s_PositionMap[m_Position].pwszName );

                if(pvarPosition->bstrVal)
                {
                    pvarPosition->vt = VT_BSTR;
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_position
//
HRESULT CMarsPanel::put_position( VARIANT varPosition )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidVariantBstr( varPosition ))
    {
        if(VerifyNotPassive( &hr ))
        {
            hr = SCRIPT_ERROR;

            PANEL_POSITION position;

            if(SUCCEEDED(StringToPanelPosition( varPosition.bstrVal, &position )))
            {
                hr = S_OK;

                if(m_Position != position)
                {
                    m_Position = s_PositionMap[position].Position;

                    if(m_Position == PANEL_POPUP)
                    {
                        m_Content.SetWindowPos( HWND_TOP, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE );
                    }

                    OnLayoutChange();
                }
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_autoSize
//
HRESULT CMarsPanel::get_autoSize( VARIANT_BOOL *pbAutoSize )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbAutoSize ))
    {
        *pbAutoSize = VARIANT_BOOLIFY(IsAutoSizing());

        if(VerifyNotPassive( &hr ))
        {
            hr = S_OK;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_autoSize
//
HRESULT CMarsPanel::put_autoSize( VARIANT_BOOL bAutoSize )
{
    HRESULT hr = S_OK;

    ATLASSERT(IsValidVariantBoolVal( bAutoSize ));

    if(VerifyNotPassive( &hr ))
    {
        if(bAutoSize)
        {
            if(!IsAutoSizing())
            {
                m_dwFlags |= PANEL_FLAG_AUTOSIZE;

                OnLayoutChange();
            }
        }
        else
        {
            if(IsAutoSizing())
            {
                m_dwFlags &= ~PANEL_FLAG_AUTOSIZE;

                OnLayoutChange();
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_contentInvalid
//
HRESULT CMarsPanel::get_contentInvalid( VARIANT_BOOL *pbInvalid )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbInvalid ))
    {
        *pbInvalid = VARIANT_BOOLIFY(m_fContentInvalid);

        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::put_contentInvalid
//
HRESULT CMarsPanel::put_contentInvalid( VARIANT_BOOL bInvalid )
{
    ATLASSERT(IsValidVariantBoolVal( bInvalid ));
    ATLASSERT(!IsPassive());

    m_fContentInvalid = BOOLIFY( bInvalid );

    return S_OK;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_layoutIndex
//
HRESULT CMarsPanel::get_layoutIndex( long *plIndex )
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( plIndex ))
    {
        if(VerifyNotPassive( &hr ))
        {
            hr = m_spPanelCollection->FindPanelIndex( this, plIndex );
        }
    }

    return hr;
}


//------------------------------------------------------------------------------
// IMarsPanel::moveto
//
HRESULT CMarsPanel::moveto( VARIANT vlX, VARIANT vlY, VARIANT vlWidth, VARIANT vlHeight )
{
    HRESULT hr = S_OK;

    ATLASSERT(vlX.vt      == VT_NULL || vlX.vt      == VT_I4);
    ATLASSERT(vlY.vt      == VT_NULL || vlY.vt      == VT_I4);
    ATLASSERT(vlWidth.vt  == VT_NULL || vlWidth.vt  == VT_I4);
    ATLASSERT(vlHeight.vt == VT_NULL || vlHeight.vt == VT_I4);

    if(VerifyNotPassive( &hr ))
    {
        long lX      = VariantToI4( vlX      );
        long lY      = VariantToI4( vlY      );
        long lWidth  = VariantToI4( vlWidth  );
        long lHeight = VariantToI4( vlHeight );

        if((                 lX     != m_lX     ) ||
           (                 lY     != m_lY     ) ||
           (lWidth  >= 0 && lWidth  != m_lWidth ) ||
           (lHeight >= 0 && lHeight != m_lHeight)  )
        {
            m_lX = lX;
            m_lY = lY;

            if(lWidth  >= 0) m_lWidth  = lWidth;
            if(lHeight >= 0) m_lHeight = lHeight;

            OnLayoutChange();
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::restrictWidth
//
HRESULT CMarsPanel::restrictWidth( VARIANT vlMin, VARIANT vlMax, VARIANT vbstrMarker )
{
    HRESULT hr = S_OK;

    ATLASSERT(vlMin.vt == VT_EMPTY || vlMin.vt == VT_NULL || vlMin.vt == VT_BSTR || vlMin.vt == VT_I4);
    ATLASSERT(vlMax.vt == VT_EMPTY || vlMax.vt == VT_NULL || vlMax.vt == VT_BSTR || vlMin.vt == VT_I4);
    ATLASSERT((vbstrMarker.vt==VT_NULL) || (vbstrMarker.vt == VT_EMPTY));

    if(VerifyNotPassive( &hr ))
    {
        m_lMaxWidth = m_lMinWidth = -1;

        if(vlMin.vt != VT_NULL  &&
           vlMin.vt != VT_EMPTY  )
        {
            CComVariant vlMin2; vlMin2.ChangeType( VT_I4, &vlMin );

            m_lMinWidth = VariantToI4( vlMin2 );
        }

        if(vlMax.vt != VT_NULL  &&
           vlMax.vt != VT_EMPTY  )
        {
            CComVariant vlMax2; vlMax2.ChangeType( VT_I4, &vlMax );

            m_lMaxWidth = VariantToI4( vlMax2 );
        }

        if(m_lMaxWidth >= 0 && m_lMaxWidth < m_lMinWidth)
        {
            m_lMaxWidth = m_lMinWidth;
        }

        OnLayoutChange();
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::restrictHeight
//
HRESULT CMarsPanel::restrictHeight( VARIANT vlMin, VARIANT vlMax, VARIANT vbstrMarker )
{
    HRESULT hr = S_OK;

    ATLASSERT(vlMin.vt == VT_EMPTY || vlMin.vt == VT_NULL || vlMin.vt == VT_BSTR || vlMin.vt == VT_I4);
    ATLASSERT(vlMax.vt == VT_EMPTY || vlMax.vt == VT_NULL || vlMax.vt == VT_BSTR || vlMin.vt == VT_I4);
    ATLASSERT((vbstrMarker.vt==VT_NULL) || (vbstrMarker.vt == VT_EMPTY));

    if(VerifyNotPassive( &hr ))
    {
        m_lMaxHeight = m_lMinHeight = -1;

        if(vlMin.vt != VT_NULL  &&
           vlMin.vt != VT_EMPTY  )
        {
            CComVariant vlMin2; vlMin2.ChangeType( VT_I4, &vlMin );

            m_lMinHeight = VariantToI4( vlMin2 );
        }

        if(vlMax.vt != VT_NULL  &&
           vlMax.vt != VT_EMPTY  )
        {
            CComVariant vlMax2; vlMax2.ChangeType( VT_I4, &vlMax );

            m_lMaxHeight = VariantToI4( vlMax2 );
        }

        if(m_lMaxHeight >= 0 && m_lMaxHeight < m_lMinHeight) m_lMaxHeight = m_lMinHeight;

        OnLayoutChange();
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::canResize
//
HRESULT CMarsPanel::canResize( long lDX, long lDY, VARIANT_BOOL *pVal )
{
    long lWidthOld  = m_lWidth;
    long lHeightOld = m_lHeight;
    RECT rcClient;

    m_lWidth  += lDX;
    m_lHeight += lDY;

    (void)m_spMarsDocument->Window()->GetClientRect( &rcClient );

    if(m_spMarsDocument->MarsWindow()->CanLayout( rcClient ))
    {
        if(pVal) *pVal = VARIANT_TRUE;
    }
    else
    {
        if(pVal) *pVal = VARIANT_FALSE;
    }

    m_lWidth  = lWidthOld;
    m_lHeight = lHeightOld;

    return S_OK;
}

//------------------------------------------------------------------------------
// IMarsPanel::activate
//
HRESULT CMarsPanel::activate()
{
    m_Content.SendMessage(WM_SETFOCUS, 0, 0);

    return S_OK;
}

//------------------------------------------------------------------------------
// IMarsPanel::insertBefore
//
HRESULT CMarsPanel::insertBefore(VARIANT varInsertBefore)
{
    ATLASSERT(varInsertBefore.vt == VT_I4   ||     // index to insert before
        varInsertBefore.vt == VT_BSTR ||     // panel name to insert before
        varInsertBefore.vt == VT_DISPATCH);  // panel object to insert before

    HRESULT hr = E_INVALIDARG;

    if (API_IsValidVariant(varInsertBefore))
    {
        if (VerifyNotPassive(&hr))
        {
            hr = E_FAIL;

            long lIndex = -668;

            switch(varInsertBefore.vt)
            {
            case VT_I4:
                lIndex = varInsertBefore.lVal;
                hr = S_OK;
                break;

            case VT_DISPATCH:
            {
                CComClassPtr<CMarsPanel> spPanel;

                varInsertBefore.pdispVal->QueryInterface(CLASS_CMarsPanel, (void **)&spPanel);

                if (spPanel)
                {
                    hr = m_spPanelCollection->FindPanelIndex(spPanel, &lIndex);
                }
                break;
            }
            case VT_BSTR:
                hr = m_spPanelCollection->FindPanelIndex(
                            m_spPanelCollection->FindPanel(varInsertBefore.bstrVal),
                            &lIndex);
                break;

            default:
                ATLASSERT(0);
            }


            if (SUCCEEDED(hr))
            {
                // Successfully got an index to insert before
                ATLASSERT(lIndex != -668);

                // Get our current index
                long lCurrentIndex;

                if (SUCCEEDED(m_spPanelCollection->FindPanelIndex(this, &lCurrentIndex)))
                {
                    ATLASSERT(lCurrentIndex != -1);

                    if (lIndex != lCurrentIndex)
                    {
                        m_spPanelCollection->InsertPanelFromTo(lCurrentIndex, lIndex);
                        OnLayoutChange();
                    }
                }
                else
                {
                    ATLASSERT(!"FindPanelIndex failed!");
                }
            }
        }
    }

    return hr;
}



//------------------------------------------------------------------------------
// IMarsPanel::execMshtml
//
//  execMshtml allows script to send a command directly to Trident.  This is different from
//  IWebBrowser2::ExecWB because ExecWB passes a NULL command group, which prevents Trident
//  from responding to commands like IDM_FIND.  Usually, we could accomplish this by calling
//  the OM method execCommand, but Trident doesn't respond to execCommand("Find")
//
HRESULT CMarsPanel::execMshtml(DWORD nCmdID, DWORD nCmdExecOpt,
                               VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr = E_INVALIDARG;

    if (VerifyNotPassive(&hr))
    {
        CComPtr<IOleCommandTarget> spCmdTarget;

        hr = m_Content.QueryControl(IID_IOleCommandTarget, (void **) &spCmdTarget);

        if (SUCCEEDED(hr))
        {
            hr = spCmdTarget->Exec(&CGID_MSHTML, nCmdID, nCmdExecOpt, pvaIn, pvaOut);
        }

        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::get_isCurrentlyVisible
//
HRESULT CMarsPanel::get_isCurrentlyVisible(VARIANT_BOOL *pbIsVisible)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(pbIsVisible))
    {
        if (VerifyNotPassive(&hr))
        {
            *pbIsVisible = VARIANT_BOOLIFY(m_Content.IsWindowVisible());

            hr = S_OK;
        }
    }

    return hr;
}


//------------------------------------------------------------------------------
// IServiceProvider::QueryService
//
//   First, we try to handle guidService, then we go to IProfferServiceImpl,
//    then we go to the parent window.
//
HRESULT CMarsPanel::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    if (!IsPassive())
    {
        if (guidService == IID_IInternetProtocol)
        {
            // Yeah, we don't support this service.  Stop asking us for it!
        }
        else if ((guidService == SID_SHlinkFrame) ||
                 (guidService == SID_SProfferService) ||
                 (guidService == SID_SMarsPanel))
        {
            hr = QueryInterface(riid, ppv);
        }
        else if (guidService == SID_SInternetSecurityManager)
        {
             if (IsTrusted())
             {
                 hr = QueryInterface(riid, ppv);
             }
        }

        if (FAILED(hr))
        {
            hr = IProfferServiceImpl::QueryService(guidService, riid, ppv);
        }
    }

    if (FAILED(hr))
    {
        hr = m_spMarsDocument->MarsWindow()->QueryService(guidService, riid, ppv);
    }

    return hr;
}

//------------------------------------------------------------------------------
// IHlinkFrame::Navigate
//
HRESULT CMarsPanel::Navigate(DWORD grfHLNF, LPBC pbc,
                             IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    // BUGBUG: Call ReleasedOwnedObjects for this panel

    HRESULT hr = E_FAIL;
    CComPtr<IMoniker> spMk;

    if (VerifyNotPassive())
    {
        pihlNavigate->GetMonikerReference(grfHLNF, &spMk, NULL);

        if (spMk)
        {
            hr = NavigateMk(spMk);
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT CMarsPanel::Create( MarsAppDef_Panel* pLayout)
{
    ATLASSERT(!IsPassive());

    m_bstrName   = pLayout->szName;
    m_Position   = pLayout->Position;
    m_lWidth     = pLayout->lWidth;
    m_lHeight    = pLayout->lHeight;
    m_lX         = pLayout->lX;
    m_lY         = pLayout->lY;
    m_dwFlags    = pLayout->dwFlags;
    m_lMinWidth  = pLayout->lWidthMin;
    m_lMinHeight = pLayout->lHeightMin;
    m_lMaxWidth  = pLayout->lWidthMax;
    m_lMaxHeight = pLayout->lHeightMax;
    m_fVisible   = BOOLIFY(m_dwFlags & PANEL_FLAG_VISIBLE);
    m_dwCookie   = 0;

    if(!IsAutoSizing())
    {
        switch(m_Position)
        {
        case PANEL_BOTTOM:
        case PANEL_TOP:
            if(m_lMinHeight < 0 && m_lMaxHeight < 0)
            {
                m_lMinHeight = m_lHeight;
                m_lMaxHeight = m_lHeight;
            }
            break;

        case PANEL_LEFT:
        case PANEL_RIGHT:
            if(m_lMinWidth < 0 && m_lMaxWidth < 0)
            {
                m_lMinWidth = m_lWidth;
                m_lMaxWidth = m_lWidth;
            }
            break;
        }
    }

    {
        DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS;

        RECT rcCreate = { 0, 0, 0, 0 };

        m_Content.Create( m_spMarsDocument->Window()->m_hWnd, &rcCreate, _T(""), dwStyle, 0 );
    }

    {
        CComPtr<IObjectWithSite> spObj;

        m_Content.QueryHost(IID_IObjectWithSite, (void **)&spObj);

        if (spObj)
        {
            spObj->SetSite(SAFECAST(this, IMarsPanel *));        // To connect our QueryService
        }
    }

    m_spMarsDocument->MarsWindow()->NotifyHost(MARSHOST_ON_PANEL_INIT, SAFECAST(this, IMarsPanel *), 0);

    if(pLayout->szUrl[0])
    {
        m_bstrStartUrl = pLayout->szUrl;
    }

    if(!(m_dwFlags & PANEL_FLAG_ONDEMAND))
    {
        CreateControl();
    }

    if(m_dwFlags & PANEL_FLAG_VISIBLE)
    {
        OnLayoutChange();
    }

    return S_OK;
}

//------------------------------------------------------------------------------

DELAY_LOAD_NAME_HRESULT(g_hinstBorg, mshtml, BorgDllGetClassObject, DllGetClassObject,
                        (REFCLSID rclsid, REFIID riid, LPVOID* ppv),
                        (rclsid, riid, ppv));

HRESULT CMarsPanel::CreateControlObject()
{
    ATLASSERT(!m_fControlCreated);

    CComPtr<IAxWinHostWindow> spHost;
    HRESULT hr = m_Content.QueryHost(&spHost);

    if (SUCCEEDED(hr))
    {
        if(IsWebBrowser())
        {
            hr = spHost->CreateControl(wszCLSID_WebBrowser, m_Content, 0);
        }
        else if(IsCustomControl())
        {
            hr = spHost->CreateControl(m_bstrStartUrl, m_Content, 0);
        }
        else
        {
            if (IsTrusted())
            {
                CComPtr<IClassFactory> spCf;

                hr = BorgDllGetClassObject(CLSID_HTADoc, IID_IClassFactory, (void **)&spCf);

                if (SUCCEEDED(hr))
                {
                    CComPtr<IUnknown> spUnk;

                    hr = spCf->CreateInstance(NULL, IID_IUnknown, (void **)&spUnk);

                    if (SUCCEEDED(hr))
                    {
                        hr = spHost->AttachControl(spUnk, m_Content);
                    }
                }
            }
            else
            {
                hr = spHost->CreateControl(wszCLSID_HTMLDocument, m_Content, 0);
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// Internal function called when panel is first made visible
HRESULT CMarsPanel::CreateControl()
{
    HRESULT hr = S_FALSE;

    if(!m_fControlCreated)
    {
        // Create WebBrowser or Trident and navigate to default url
        if (SUCCEEDED(CreateControlObject()))
        {
            m_fControlCreated = TRUE;

            if(IsWebBrowser())
            {
                CComPtr<IUnknown> spUnk;

                if (SUCCEEDED(m_Content.QueryControl(IID_IUnknown, (void **)&spUnk)))
                {
                    m_BrowserEvents.Connect(spUnk, TRUE);

                    // get the browserservice that we will intercept to update the travel log
                    // only if this is a WebBrowser and not a Popup
                    if (!m_spBrowserService)
                    {
                         HRESULT hrQS = IUnknown_QueryService(spUnk, SID_STopFrameBrowser,
                                                              IID_IBrowserService,
                                                              (void **)&m_spBrowserService);
                         if (FAILED(hrQS))
                         {
                             ATLASSERT(!m_spBrowserService);
                         }
                    }
                }
            }
            else if(IsCustomControl())
            {
            }
            else
            {
                ConnectCompletionAdviser();
            }

            if(IsTrusted())
            {
                m_Content.SetExternalDispatch(&m_MarsExternal);
            }

            if (m_bstrStartUrl)
            {
                ATLASSERT(m_bstrStartUrl[0]);

                NavigateURL(m_bstrStartUrl, FALSE);
                m_bstrStartUrl.Empty();
            }

            m_spMarsDocument->MarsWindow()->NotifyHost(MARSHOST_ON_PANEL_CONTROL_CREATE, SAFECAST(this, IMarsPanel *), 0);

            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// This returns void because it calls a script method that might return
// S_FALSE with no URL, so we should force callers to check the BSTR
//
//  rbstrUrl = document.location.href
//
void CMarsPanel::GetUrl(CComBSTR& rbstrUrl)
{
    CComPtr<IHTMLDocument2> spDoc2;

    GetDoc2FromAxWindow(&m_Content, &spDoc2);

    if (spDoc2)
    {
        CComPtr<IHTMLLocation> spLoc;

        spDoc2->get_location(&spLoc);

        if (spLoc)
        {
            spLoc->get_href(&rbstrUrl);
        }
    }
}

//------------------------------------------------------------------------------
HRESULT CMarsPanel::NavigateMk(IMoniker *pmk)
{
    HRESULT hr = E_FAIL;

    if (VerifyNotPassive())
    {
        CComPtr<IPersistMoniker> spPersistMk;

        if (SUCCEEDED(m_Content.QueryControl(IID_IPersistMoniker, (void **)&spPersistMk)))
        {
            m_spMarsDocument->MarsWindow()->ReleaseOwnedObjects((IDispatch *)this);
            hr = spPersistMk->Load(FALSE, pmk, NULL, 0);
        }
        else
        {
            // NavigateMk: QueryControl failed -- the most likely reason for this is that
            // you don't have CLSID_HTADocument registered -- upgrade your IE bits
            ATLASSERT(FALSE);

            // Don't just hang the UI
            m_lReadyState = READYSTATE_COMPLETE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT CMarsPanel::NavigateURL(LPCWSTR lpszURL, BOOL fForceLoad)
{
    HRESULT hr = E_FAIL;

    if (VerifyNotPassive())
    {
        CreateControl();

        BOOL fIgnoreNavigate = FALSE;

#ifdef BLOCK_PANEL_RENAVIGATES
        if (!fForceLoad && IsTrusted() && !IsContentInvalid())
        {
            CComBSTR sbstrCurrentUrl;
            GetUrl(sbstrCurrentUrl);

            if (sbstrCurrentUrl && (0 == StrCmpIW(sbstrCurrentUrl, lpszURL)))
            {
                fIgnoreNavigate = TRUE;
                hr = S_FALSE;
            }
        }
#endif
        if(!fIgnoreNavigate)
        {
            if(IsWebBrowser())
            {
                CComPtr<IWebBrowser2> spWebBrowser2;

                if (SUCCEEDED(m_Content.QueryControl(IID_IWebBrowser2, (void **)&spWebBrowser2)))
                {
                    CComVariant varEmpty;
                    CComVariant varURL(lpszURL);

                    m_spMarsDocument->MarsWindow()->ReleaseOwnedObjects((IDispatch *)this);
                    hr = spWebBrowser2->Navigate2(&varURL, &varEmpty, &varEmpty, &varEmpty, &varEmpty);
                }
            }
            else if(IsCustomControl())
            {
            }
            else
            {
                CComPtr<IMoniker> spMkUrl;

                if (SUCCEEDED(CreateURLMoniker(NULL, lpszURL, &spMkUrl)) && spMkUrl)
                {
                    hr = NavigateMk(spMkUrl);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_fContentInvalid = FALSE;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanel::navigate
//
HRESULT CMarsPanel::navigate(VARIANT varTarget, VARIANT varForceLoad)
{
    HRESULT hr = S_FALSE;

    if (API_IsValidVariant(varTarget) && VerifyNotPassive(&hr))
    {
        CComBSTR strPath;

        if (SUCCEEDED(MarsVariantToPath(varTarget, strPath)))
        {
            if (!PathIsURLW(strPath) && PathIsURLFileW(strPath))
            {
                // handle navigate to .url shortcut
                CComPtr<IDispatch> spDisp;

                CreateControl();
                if (SUCCEEDED(m_Content.QueryControl(&spDisp)))
                {
                    if (SUCCEEDED(MarsNavigateShortcut(spDisp, strPath)))
                    {
                        m_spMarsDocument->MarsWindow()->ReleaseOwnedObjects((IDispatch *)this);
                        hr = S_OK;
                    }
                }
            }
            else
            {
                // handle navigate to URL
                BOOL fForceLoad;

                if (varForceLoad.vt == VT_BOOL)
                {
                    // the optional param was specified
                    fForceLoad = varForceLoad.boolVal;
                }
                else
                {
                    fForceLoad = FALSE;
                }

                if (SUCCEEDED(NavigateURL(strPath, fForceLoad)))
                {
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}


//------------------------------------------------------------------------------
// IMarsPanel::refresh
//
HRESULT CMarsPanel::refresh(void)
{
    m_fInRefresh = TRUE;
    execMshtml(IDM_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    m_fInRefresh = FALSE;

    m_fContentInvalid = FALSE;
    return S_OK;
}

//------------------------------------------------------------------------------
void CMarsPanel::OnLayoutChange()
{
    ATLASSERT(!IsPassive());

    if (!m_fVisible && !m_Content.IsWindowVisible())
    {
        // We're not even visible. Nothing to do.
        return;
    }

    // Create content if it's not already created
    CreateControl();

    // Redraw entire Mars window
    m_spPanelCollection->Layout();
}

//------------------------------------------------------------------------------
void CMarsPanel::MakeVisible(VARIANT_BOOL bVisible, VARIANT_BOOL bForce)
{
    ATLASSERT(!IsPassive());

    BOOL fVisible = m_Content.IsWindowVisible();

    if (bForce || (!!fVisible != !!bVisible))
    {
        m_Content.ShowWindow((bVisible) ? SW_SHOW : SW_HIDE);
    }
}

//------------------------------------------------------------------------------
void CMarsPanel::OnWindowPosChanging(WINDOWPOS *pWindowPos)
{
    if (!IsPassive() && !m_spPanelCollection->IsLayoutLocked())
    {
        if (pWindowPos->x < 0)
        {
            pWindowPos->x = 0;
        }

        if (pWindowPos->y < 0)
        {
            pWindowPos->y = 0;
        }
    }
}

//------------------------------------------------------------------------------
inline void DimChange(long& lMember, int iVal, BOOL& bChanged)
{
    if (lMember != iVal)
    {
        lMember = iVal;
        bChanged = TRUE;
    }
}

//------------------------------------------------------------------------------
void CMarsPanel::OnWindowPosChanged(WINDOWPOS *pWindowPos)
{
    if(!IsPassive() && !m_spPanelCollection->IsLayoutLocked())
    {
        BOOL bChanged = FALSE;

        switch(m_Position)
        {
        case PANEL_POPUP:
            if(!(pWindowPos->flags & SWP_NOMOVE)) DimChange(m_lX     , pWindowPos->x , bChanged);
            if(!(pWindowPos->flags & SWP_NOMOVE)) DimChange(m_lY     , pWindowPos->y , bChanged);
            if(!(pWindowPos->flags & SWP_NOSIZE)) DimChange(m_lWidth , pWindowPos->cx, bChanged);
            if(!(pWindowPos->flags & SWP_NOSIZE)) DimChange(m_lHeight, pWindowPos->cy, bChanged);
            break;

        case PANEL_BOTTOM:
        case PANEL_TOP:
            if(!(pWindowPos->flags & SWP_NOSIZE)) DimChange(m_lHeight, pWindowPos->cy, bChanged);
            break;

        case PANEL_LEFT:
        case PANEL_RIGHT:
            if(!(pWindowPos->flags & SWP_NOSIZE)) DimChange(m_lWidth, pWindowPos->cx, bChanged);
            break;
        }

        if(bChanged)
        {
            OnLayoutChange();
        }
    }
}

//------------------------------------------------------------------------------
void CMarsPanel::GetMinMaxInfo( POINT& ptMin, POINT& ptMax )
{
    long lWidth  = m_lWidth;
    long lHeight = m_lHeight;
    long lMinWidth;
    long lMinHeight;
    long lMaxWidth;
    long lMaxHeight;

    if(!IsAutoSizing())
    {
        lMinWidth  = m_lMinWidth;
        lMinHeight = m_lMinHeight;
        lMaxWidth  = m_lMaxWidth;
        lMaxHeight = m_lMaxHeight;
    }
    else
    {
        ComputeDimensionsOfContent( &lMinWidth, &lMinHeight );
        if(m_lMinWidth  != -1 && lMinWidth  < m_lMinWidth ) lMinWidth  = m_lMinWidth;
        if(m_lMinHeight != -1 && lMinHeight < m_lMinHeight) lMinHeight = m_lMinHeight;
        lMaxWidth  = m_lMaxWidth;
        lMaxHeight = m_lMaxHeight;

        if(lMinWidth  > lWidth ) lWidth  = lMinWidth;
        if(lMinHeight > lHeight) lHeight = lMinHeight;
    }

    switch(m_Position)
    {
    case PANEL_BOTTOM:
    case PANEL_TOP   :
        if(lMinHeight < 0) lMinHeight = lHeight;
        if(lMaxHeight < 0) lMaxHeight = lHeight;
        break;

    case PANEL_LEFT :
    case PANEL_RIGHT:
        if(lMinWidth < 0) lMinWidth = lWidth;
        if(lMaxWidth < 0) lMaxWidth = lWidth;
        break;
    }

    ptMin.x = lMinWidth;
    ptMin.y = lMinHeight;
    ptMax.x = lMaxWidth;
    ptMax.y = lMaxHeight;
}

bool CMarsPanel::CanLayout( RECT& rcClient, POINT& ptDiff )
{
    ptDiff.x = 0;
    ptDiff.y = 0;

    if(IsVisible())
    {
        RECT  rcClient2;
        POINT ptMin;
        POINT ptMax;
        long  lWidth;
        long  lHeight;

        GetRect      ( &rcClient, &rcClient2 );
        GetMinMaxInfo(  ptMin   ,  ptMax     );

        lWidth  = rcClient2.right  - rcClient2.left;
        lHeight = rcClient2.bottom - rcClient2.top;

        if(ptMin.x >= 0 && lWidth  < ptMin.x) ptDiff.x -= (lWidth  - ptMin.x);
        if(ptMax.x >= 0 && lWidth  > ptMax.x) ptDiff.x -= (lWidth  - ptMax.x);
        if(ptMin.y >= 0 && lHeight < ptMin.y) ptDiff.y -= (lHeight - ptMin.y);
        if(ptMax.y >= 0 && lHeight > ptMax.y) ptDiff.y -= (lHeight - ptMax.y);
    }

    return ptDiff.x == 0 && ptDiff.y == 0;
}

//------------------------------------------------------------------------------
// S_FALSE      : We used up all remaining client area
// E_INVALIDARG : *prcClient was empty, so we are hidden
HRESULT CMarsPanel::Layout( RECT *prcClient )
{
    ATLASSERT(prcClient);
    ATLASSERT(!IsPassive());

    RECT rcMyClient;
    HRESULT hr = S_OK;

    if (m_fVisible && !IsRectEmpty(prcClient))
    {
        hr = GetRect(prcClient, &rcMyClient);

        // Optimize out the case that the rect is the same as we already have. This
        //  is pretty common, and Windows doesn't optimize it out.
        RECT rcCurrent;

        GetMyClientRectInParentCoords(&rcCurrent);

        if(memcmp( &rcCurrent, &rcMyClient, sizeof(RECT) ))
        {
            m_Content.MoveWindow( &rcMyClient, TRUE );
        }

        if (IsPopup())
        {
            // Bring popup windows to top
            m_Content.SetWindowPos(HWND_TOP, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
        }

        MakeVisible(VARIANT_TRUE, VARIANT_FALSE);
    }
    else
    {
        if (m_fVisible)
        {
            // We wanted to be visible but had no remaining client area
            hr = E_INVALIDARG;
        }

        MakeVisible(VARIANT_FALSE, VARIANT_FALSE);
    }

    return hr;
}

//------------------------------------------------------------------------------
// IPropertyNotifySink::OnChanged
//
STDMETHODIMP CMarsPanel::OnChanged(DISPID dispID)
{
    if (DISPID_READYSTATE == dispID)
    {
        VARIANT vResult = {0};
        EXCEPINFO excepInfo;
        UINT uArgErr;

        DISPPARAMS dp = {NULL, NULL, 0, 0};

        CComPtr<IHTMLDocument2> spDocument;

        if (SUCCEEDED(m_Content.QueryControl(IID_IHTMLDocument2, (void **)&spDocument))
            && SUCCEEDED(spDocument->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                            DISPATCH_PROPERTYGET, &dp, &vResult, &excepInfo,
                                            &uArgErr)))
        {
            m_lReadyState = (READYSTATE)V_I4(&vResult);
            switch (m_lReadyState)
            {
            case READYSTATE_UNINITIALIZED:    //= 0,
                break;
            case READYSTATE_LOADING:          //= 1,
                break;
            case READYSTATE_LOADED:           //= 2,
                break;
            case READYSTATE_INTERACTIVE:      //= 3,
                break;
            case READYSTATE_COMPLETE:         //= 4
                if (IsAutoSizing())
                {
                    OnLayoutChange();
                }
                m_spMarsDocument->GetPlaces()->OnPanelReady();
                break;
            }
        }
    }
    return NOERROR;
}

//------------------------------------------------------------------------------
void CMarsPanel::ConnectCompletionAdviser()
{
    if (!m_dwCookie)
    {
        CComPtr<IConnectionPointContainer> spICPC;
        if (SUCCEEDED(m_Content.QueryControl(IID_IConnectionPointContainer, (void **)&spICPC)))
        {
            CComPtr<IConnectionPoint> spCP;
            if (spICPC && SUCCEEDED(spICPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP)))
            {
                spCP->Advise((LPUNKNOWN)(IPropertyNotifySink*)this, &m_dwCookie);
                ATLASSERT(m_dwCookie);
            }
        }
    }
}

//------------------------------------------------------------------------------
void CMarsPanel::DisconnectCompletionAdviser()
{
    if (m_dwCookie)
    {
        CComPtr<IConnectionPointContainer> spICPC;
        if (SUCCEEDED(m_Content.QueryControl(IID_IConnectionPointContainer, (void **)&spICPC)))
        {
            CComPtr<IConnectionPoint> spCP;
            if (spICPC && SUCCEEDED(spICPC->FindConnectionPoint(IID_IPropertyNotifySink, &spCP)))
            {
                spCP->Unadvise(m_dwCookie);
                m_dwCookie = 0;
            }
        }
    }
}

//------------------------------------------------------------------------------
// Given some content, we're going to compute its dimensions and use those.
//
void CMarsPanel::ComputeDimensionsOfContent(long *plWidth, long *plHeight)
{
    ATLASSERT(plWidth && plHeight);
    ATLASSERT(!IsPassive());

    *plWidth  = -1;
    *plHeight = -1;

    if(!IsWebBrowser() && IsAutoSizing())
    {
       CComPtr<IHTMLDocument2> spDocument;

        if(SUCCEEDED(m_Content.QueryControl(IID_IHTMLDocument2, (void **)&spDocument)))
        {
            CComPtr<IHTMLElement> spBody;

            if(spDocument)
            {
                spDocument->get_body( &spBody );
            }

            BOOL fScrollBar = FALSE;

            BOOL fHeight = (m_Position == PANEL_BOTTOM) ||
                           (m_Position == PANEL_TOP   ) ||
                           (m_Position == PANEL_POPUP );

            BOOL fWidth  = (m_Position == PANEL_LEFT ) ||
                           (m_Position == PANEL_RIGHT) ||
                           (m_Position == PANEL_POPUP);

            CComQIPtr<IHTMLElement2> spBody2(spBody);

            if(spBody2 && fHeight)
            {
                LONG lScrollHeight = 0; spBody2->get_scrollHeight( &lScrollHeight );

                if(m_lMaxHeight >= 0 && lScrollHeight > m_lMaxHeight)
                {
                    *plHeight = m_lMaxHeight;

                    fScrollBar = TRUE;
                }
                else
                {
                    *plHeight = lScrollHeight;
                }
            }

            if(spBody2 && fWidth)
            {
                LONG lScrollWidth = 0; spBody2->get_scrollWidth( &lScrollWidth );

                if(m_lMaxWidth >= 0 && lScrollWidth > m_lMaxWidth)
                {
                    *plWidth = m_lMaxWidth;

                    fScrollBar = TRUE;
                }
                else
                {
                    *plWidth = lScrollWidth;
                }
            }

            CComQIPtr<IHTMLBodyElement> spBody3(spBody);

            if(spBody3)
            {
                spBody3->put_scroll( CComBSTR( fScrollBar ? L"yes" : L"no" ) );
            }
        }
    }

}

//------------------------------------------------------------------------------
// Given the remaining client rect that we are allowed to use, calculate our
//  own position in client coordinates, and return the remaining empty client
//  rectangle
//
// S_OK : Remaining client area
// S_FALSE : No client area remaining
HRESULT CMarsPanel::GetRect(RECT *prcClient, RECT *prcMyClient)
{
    ATLASSERT(!IsPassive());

    HRESULT hr = S_OK;

    if (!m_fVisible)
    {
        memset(prcMyClient, 0, sizeof(*prcMyClient));
        return S_OK;
    }

    *prcMyClient = *prcClient;

    long lWidth = m_lWidth;
    long lHeight = m_lHeight;

    if (IsAutoSizing())
    {
        long lMinWidth;
        long lMinHeight;

        ComputeDimensionsOfContent(&lMinWidth, &lMinHeight);

        if(lMinWidth  > lWidth ) lWidth  = lMinWidth;
        if(lMinHeight > lHeight) lHeight = lMinHeight;
    }

    if(m_lMinWidth  >= 0 && lWidth  < m_lMinWidth ) lWidth  = m_lMinWidth;
    if(m_lMinHeight >= 0 && lHeight < m_lMinHeight) lHeight = m_lMinHeight;

    switch (m_Position)
    {
    case PANEL_POPUP:
        // Special case: we exist on top of the other panels.
        if (m_lX < 0)
        {
            prcMyClient->right = prcClient->right + 1 + m_lX;
            prcMyClient->left = prcMyClient->right - lWidth;
        }
        else
        {
            prcMyClient->left = prcClient->left + m_lX;
            prcMyClient->right = prcMyClient->left + lWidth;
        }

        if (m_lY < 0)
        {
            prcMyClient->bottom = prcClient->bottom + 1 + m_lY;
            prcMyClient->top = prcMyClient->bottom - lHeight;
        }
        else
        {
            prcMyClient->top = prcClient->top + m_lY;
            prcMyClient->bottom = prcMyClient->top + lHeight;
        }

        break;

    case PANEL_LEFT:
        prcClient->left = prcMyClient->right = prcClient->left + lWidth;

        if (prcClient->left > prcClient->right)
        {
            prcClient->left = prcMyClient->right = prcClient->right;
            hr = S_FALSE;
        }
        break;

    case PANEL_RIGHT:
        prcClient->right = prcMyClient->left = prcClient->right - lWidth;

        if (prcClient->right < prcClient->left)
        {
            prcClient->right = prcMyClient->left = prcClient->left;
            hr = S_FALSE;
        }
        break;

    case PANEL_TOP:
        prcClient->top = prcMyClient->bottom = prcClient->top + lHeight;

        if (prcClient->top > prcClient->bottom)
        {
            prcClient->top = prcMyClient->bottom = prcClient->bottom;
            hr = S_FALSE;
        }
        break;

    case PANEL_BOTTOM:
        prcClient->bottom = prcMyClient->top = prcClient->bottom - lHeight;

        if (prcClient->bottom < prcClient->top)
        {
            prcClient->bottom = prcMyClient->top = prcClient->top;
            hr = S_FALSE;
        }
        break;

    case PANEL_WINDOW:
        hr = S_FALSE;
        break;

    default:
        ATLASSERT(FALSE); // Invalid panel position.
        break;
    }
    return hr;
}

// =========================================================
// CBrowserEvents
// =========================================================

CMarsPanel::CBrowserEvents::CBrowserEvents(CMarsPanel *pParent) :
            CMarsPanelSubObject(pParent)
{
    ATLASSERT(m_dwCookie == 0);
    ATLASSERT(m_dwCookie2 == 0);
}

IMPLEMENT_ADDREF_RELEASE(CMarsPanel::CBrowserEvents);

//------------------------------------------------------------------------------
void CMarsPanel::CBrowserEvents::Connect(IUnknown *punk, BOOL bConnect)
{
    CComPtr<IConnectionPointContainer> spCpc;

    if (SUCCEEDED(punk->QueryInterface(IID_IConnectionPointContainer, (void **)&spCpc)))
    {
        CComPtr<IConnectionPoint> spCp;

        if (SUCCEEDED(spCpc->FindConnectionPoint(DIID_DWebBrowserEvents, &spCp)))
        {
            if (bConnect)
            {
                spCp->Advise(this, &m_dwCookie);
            }
            else if (m_dwCookie)
            {
                spCp->Unadvise(m_dwCookie);
                m_dwCookie = 0;
            }
        }

        spCp.Release();

        if (SUCCEEDED(spCpc->FindConnectionPoint(DIID_DWebBrowserEvents2, &spCp)))
        {
            if (bConnect)
            {
                spCp->Advise(this, &m_dwCookie2);
            }
            else if (m_dwCookie2)
            {
                spCp->Unadvise(m_dwCookie2);
                m_dwCookie2 = 0;
            }
        }
    }
}

//------------------------------------------------------------------------------
// IUnknown::QueryInterface
//
HRESULT CMarsPanel::CBrowserEvents::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    if ((iid == IID_IUnknown) ||
        (iid == IID_IDispatch))
    {
        AddRef();
        *ppvObject = SAFECAST(this, IDispatch *);
        hr = S_OK;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

//------------------------------------------------------------------------------
// IDispatch::Invoke
//
HRESULT CMarsPanel::CBrowserEvents::Invoke(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    HRESULT hr = S_OK;

    if (VerifyNotPassive(&hr))
    {
        switch (dispidMember)
        {
            case DISPID_BEFORENAVIGATE:
            case DISPID_FRAMEBEFORENAVIGATE:
            case DISPID_BEFORENAVIGATE2:
            {
                VARIANT *pVarCancel = &pdispparams->rgvarg[0];

                if (pVarCancel->vt == (VT_BOOL | VT_BYREF))
                {
                    if (VARIANT_TRUE == *pVarCancel->pboolVal)
                    {
                        CComPtr<IHTMLDocument2> spDoc2;

                        GetDoc2FromAxWindow(&Parent()->m_Content, &spDoc2);

                        if (spDoc2)
                        {
                            VARIANT vResult = {0};
                            EXCEPINFO excepInfo;
                            UINT uArgErr;

                            DISPPARAMS dp = {NULL, NULL, 0, 0};

                            if (SUCCEEDED(spDoc2->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                DISPATCH_PROPERTYGET, &dp, &vResult, &excepInfo, &uArgErr)))
                            {
                                Parent()->m_lReadyState = (READYSTATE)V_I4(&vResult);
                            }
                        }
                    }
                    else
                    {
                        Parent()->m_lReadyState = READYSTATE_LOADING;
                    }

                    if (READYSTATE_COMPLETE == Parent()->m_lReadyState)
                    {
                        Parent()->m_spMarsDocument->GetPlaces()->OnPanelReady();
                    }
                }
                break;
            }

            case DISPID_DOCUMENTCOMPLETE:
            {
                Parent()->m_lReadyState = READYSTATE_COMPLETE;
                Parent()->m_spMarsDocument->GetPlaces()->OnPanelReady();

                break;
            }
        } // switch(dispidMember)
    }

    return hr;
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsPanel::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)
{
    HRESULT hr;

    ATLASSERT(!m_fTabCycle);

    if (IsVK_TABCycler(pMsg))
    {
        m_fTabCycle = TRUE;
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

//------------------------------------------------------------------------------
STDMETHODIMP CMarsPanel::OnUIActivate()
{
    ATLASSERT(!IsPassive());

    m_spPanelCollection->SetActivePanel(this, TRUE);

    return S_OK;
}

//------------------------------------------------------------------------------
HRESULT CMarsPanel::UIDeactivate()
{
    HRESULT hr;
    CComPtr<IOleInPlaceObject> spOleInPlaceObject;

    if (SUCCEEDED(m_Content.QueryControl(&spOleInPlaceObject)))
    {
        hr = spOleInPlaceObject->UIDeactivate();
    }
    else
    {
        //  What the heck else can we do?
        hr = S_FALSE;
    }

    return hr;
}

//------------------------------------------------------------------------------
// Forwards the message to the hosted control.
void CMarsPanel::ForwardMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd;
    CComPtr<IOleWindow> spOleWindow;

    // Note that we send the message directly to the window rather than use
    // WM_FORWARDMSG which calls TranslateAccelerator
    if (SUCCEEDED(m_Content.QueryControl(&spOleWindow)) &&
        SUCCEEDED(spOleWindow->GetWindow(&hwnd)))
    {
        SendMessage(hwnd, uMsg, wParam, lParam);
    }
}

//------------------------------------------------------------------------------
HRESULT CMarsPanel::TranslateAccelerator(MSG *pMsg)
{
    ATLASSERT(!IsPassive());

    HRESULT hr      = S_FALSE;
    BOOL    fGlobal = IsGlobalKeyMessage( pMsg );

    if((S_OK == SHIsChildOrSelf(m_Content.m_hWnd, pMsg->hwnd)) || fGlobal)
    {
        if(m_spActiveObject && (this == m_spPanelCollection->ActivePanel()))
        {
            hr = m_spActiveObject->TranslateAccelerator(pMsg);
        }
        else
        {
            CComPtr<IOleInPlaceActiveObject> obj;

            if(SUCCEEDED(m_Content.QueryControl( IID_IOleInPlaceActiveObject, (void **)&obj )))
            {
                hr = obj->TranslateAccelerator(pMsg);
            }

            //
            // If it's a WebBrowser, forward the accelerator directly to the Document object, otherwise accesskeys won't be resolved.
            //
            if(hr == S_FALSE && fGlobal)
            {
                CComPtr<IWebBrowser2> obj2;

                if(SUCCEEDED(m_Content.QueryControl( IID_IWebBrowser2, (void **)&obj2 )))
                {
                    CComPtr<IDispatch> disp;

                    if(SUCCEEDED(obj2->get_Document( &disp )) && disp)
                    {
                        CComPtr<IOleInPlaceActiveObject> obj3;

                        if(SUCCEEDED(disp.QueryInterface( &obj3 )))
                        {
                            hr = obj3->TranslateAccelerator(pMsg);
                        }
                    }
                }
            }
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//  Returns the Screen coordinates of this panel
//----------------------------------------------------------------------------
void CMarsPanel::GetMyClientRectInParentCoords(RECT *prc)
{
    ATLASSERT(!IsPassive());

    POINT ptParent = {0, 0}, ptMe = {0, 0}, ptOffset;

    m_Content.ClientToScreen(&ptMe);
    m_spMarsDocument->Window()->ClientToScreen(&ptParent);

    ptOffset.x = ptMe.x - ptParent.x;
    ptOffset.y = ptMe.y - ptParent.y;

    m_Content.GetClientRect(prc);
    OffsetRect(prc, ptOffset.x, ptOffset.y);

}

// IInternetSecurityManager
// This interface is used to override default security settings for our panels.
// These panels are trusted.

//------------------------------------------------------------------------------
// IInternetSecurityManager::SetSecuritySite
//
HRESULT CMarsPanel::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::GetSecuritySite
//
HRESULT CMarsPanel::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::MapUrlToZone
//
HRESULT CMarsPanel::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::GetSecurityId
//
HRESULT CMarsPanel::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::ProcessUrlAction
//
// Be as permissive as we can
//
HRESULT CMarsPanel::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction,
                                     BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext,
                                     DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    ATLASSERT(IsTrusted());

    if (cbPolicy >= sizeof(DWORD))
    {
        *((DWORD *)pPolicy) = URLPOLICY_ALLOW;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::QueryCustomPolicy
//
// Be as permissive as we can
//
HRESULT CMarsPanel::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy,
                                      DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    ATLASSERT(IsTrusted());
    ATLASSERT(ppPolicy && !*ppPolicy);
    ATLASSERT(pcbPolicy);

    if (ppPolicy && pcbPolicy)
    {
        *ppPolicy = (BYTE *)CoTaskMemAlloc(sizeof(DWORD));

        if (*ppPolicy)
        {
            *pcbPolicy = sizeof(DWORD);
            *(DWORD *)*ppPolicy = URLPOLICY_ALLOW;

            return S_OK;
        }
    }

    return INET_E_DEFAULT_ACTION;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::SetZoneMapping
//
HRESULT CMarsPanel::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//------------------------------------------------------------------------------
// IInternetSecurityManager::GetZoneMappings
//
HRESULT CMarsPanel::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

//------------------------------------------------------------------------------
// OnDocHostUIExec
//
//  When we get an Exec from Trident on CGID_DocHostCommandHandler, we can return S_OK
//  to indicate that we handled the command and Trident should take no further action
//  We'll delegate the processing to script by firing events
//
//  TODO: once Mars accelerators are implemented, we should just block Trident from
//  taking action, and not fire any events.
//
HRESULT CMarsPanel::OnDocHostUIExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                                    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    // HACK: Shdocvw/Trident sometimes tests specifically for a value like
    // OLECMDERR_E_NOTSUPPORTED and will not perform an essential action
    // if we return something more generic like E_FAIL.

    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;

    if(!IsPassive() && pguidCmdGroup && (*pguidCmdGroup == CGID_DocHostCommandHandler))
    {
		switch (nCmdID)
		{
		case OLECMDID_SHOWFIND:
			hr = S_OK;
			break;

		case IDM_NEW_TOPLEVELWINDOW:
			// Shdocvw gives us this command when Ctrl+N or the localized equivalent
			// is translated.  We return S_OK to stop it from opening an IE window.
			hr = S_OK;
			break;

		case IDM_REFRESH:
		case IDM_REFRESH_TOP:
		case IDM_REFRESH_TOP_FULL:
		case IDM_REFRESH_THIS:
		case IDM_REFRESH_THIS_FULL:
			if(!m_fInRefresh)
			{
				hr = S_OK;
			}
			break;

		case OLECMDID_SHOWSCRIPTERROR:
			if(SUCCEEDED(m_spMarsDocument->MarsWindow()->NotifyHost( MARSHOST_ON_SCRIPT_ERROR, V_VT(pvarargIn) == VT_UNKNOWN ? V_UNKNOWN(pvarargIn) : NULL, 0 )))
			{
				V_VT  (pvarargOut) = VT_BOOL;
				V_BOOL(pvarargOut) = VARIANT_FALSE;
				hr = S_OK;
			}
			break;
		}
    }

    return hr;
}

//
// CPanelCollection implementation
//

//------------------------------------------------------------------------------
CPanelCollection::CPanelCollection(CMarsDocument *pMarsDocument)
{
    m_spMarsDocument = pMarsDocument;
}

//------------------------------------------------------------------------------
CPanelCollection::~CPanelCollection()
{
    ATLASSERT(GetSize() == 0);
    FreePanels();
}

//------------------------------------------------------------------------------
void CPanelCollection::FreePanels()
{
    for (int i=0; i<GetSize(); i++)
    {
        (*this)[i].PassivateAndRelease();
    }

    RemoveAll();
}

//------------------------------------------------------------------------------
HRESULT CPanelCollection::DoPassivate()
{
    FreePanels();

    m_spMarsDocument.Release();

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CPanelCollection);

//------------------------------------------------------------------------------
// IUnknown::QueryInterface
//
STDMETHODIMP CPanelCollection::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    if (API_IsValidWritePtr(ppvObject))
    {
        if ((iid == IID_IUnknown) ||
            (iid == IID_IDispatch) ||
            (iid == IID_IMarsPanelCollection))
        {
            AddRef();
            *ppvObject = SAFECAST(this, IMarsPanelCollection *);
            hr = S_OK;
        }
        else
        {
            *ppvObject = NULL;
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT CPanelCollection::DoEnableModeless(BOOL fEnable)
{
    for (int i=0; i<GetSize(); i++)
    {
        (*this)[i]->DoEnableModeless(fEnable);
    }

    return S_OK;
}

//////////////////////////////
// IMarsPanelCollection


//------------------------------------------------------------------------------
// IMarsPanelCollection::get_panel
//
// TODO: (PaulNash, 9/19/99) This method is outdated.
//      Remove once content is switched over.
//
STDMETHODIMP CPanelCollection::get_panel(LPWSTR pwszName, IMarsPanel **ppPanel)
{
    CComVariant var(pwszName);

    return get_item(var, ppPanel);
}


//------------------------------------------------------------------------------
// IMarsPanelCollection::addPanel
//
STDMETHODIMP CPanelCollection::addPanel(
                BSTR    bstrName,
                VARIANT varType,
                BSTR    bstrStartUrl,
                VARIANT varCreate,
                long    lFlags,
                IMarsPanel **ppPanel)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidString(bstrName)                                    &&
        (VT_NULL == varType.vt || API_IsValidVariantBstr(varType))     &&
        (NULL == bstrStartUrl || API_IsValidString(bstrStartUrl))      &&
        (VT_NULL == varCreate.vt || API_IsValidVariantBstr(varCreate)) &&
        API_IsValidFlag(lFlags, PANEL_FLAG_ALL)                        &&
        API_IsValidWritePtr(ppPanel)                                     )
    {
        *ppPanel = NULL;

        if (VerifyNotPassive(&hr))
        {
            MarsAppDef_Panel Layout;
            BSTR             bstrType   = VariantToBSTR( varType   );
            BSTR             bstrCreate = VariantToBSTR( varCreate );
            DWORD            dwFlags = DEFAULT_PANEL_FLAGS | (DWORD)lFlags;

            StringToPanelFlags( bstrType  , dwFlags );
            StringToPanelFlags( bstrCreate, dwFlags );

            wcsncpy                  ( Layout.szName, bstrName    , ARRAYSIZE(Layout.szName) );
            ExpandEnvironmentStringsW( bstrStartUrl , Layout.szUrl, ARRAYSIZE(Layout.szUrl ) );

            Layout.dwFlags = dwFlags;

            AddPanel(&Layout, NULL);

            hr = get_item( CComVariant( bstrName ), ppPanel );
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::removePanel
//
STDMETHODIMP CPanelCollection::removePanel(LPWSTR pwszName)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidString(pwszName))
    {
        if(VerifyNotPassive(&hr))
        {
            hr = S_FALSE;

            for(int i=0; i<GetSize(); i++)
            {
                if(!StrCmpI(pwszName, (*this)[i]->GetName()))
                {
                    BOOL fVisible = (*this)[i]->IsVisible();

                    (*this)[i].PassivateAndRelease();
                    RemoveAt(i);

                    if(fVisible)
                    {
                        Layout();
                    }

                    hr = S_OK;
                    break;
                }
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::lockLayout
//
STDMETHODIMP CPanelCollection::lockLayout()
{
    HRESULT hr = S_OK;

    if (VerifyNotPassive(&hr))
    {
        m_iLockLayout++;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::unlockLayout
//
STDMETHODIMP CPanelCollection::unlockLayout()
{
    HRESULT hr = S_OK;

    if (VerifyNotPassive(&hr))
    {
        if (IsLayoutLocked())
        {
            if (0 == --m_iLockLayout)
            {
                // TODO: clear lock timeout

                if (m_fPendingLayout)
                {
                    m_fPendingLayout = FALSE;
                    Layout();
                }
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
void CPanelCollection::Layout()
{
    if(!IsPassive())
    {
        if(!IsLayoutLocked())
        {
            RECT rcClient;

            lockLayout();

            m_spMarsDocument->Window()->GetClientRect( &rcClient );

            if(m_spMarsDocument->MarsWindow()->CanLayout( rcClient ) == false)
            {
                m_spMarsDocument->MarsWindow()->FixLayout( rcClient );
            }

            m_fPendingLayout = FALSE;

            for (int i=0; i<GetSize(); i++)
            {
                if (S_OK != (*this)[i]->Layout( &rcClient ))
                {
                    // We're out of client area; won't be able to show all panels.
                    // Keep calling Layout for remaining panels so they can hide themselves.
                }
            }

            ATLASSERT(!m_fPendingLayout);

            unlockLayout();
        }
        else
        {
            // We'll do the layout once we get unlocked
            m_fPendingLayout = TRUE;
        }
    }
}

//------------------------------------------------------------------------------
void CPanelCollection::SetActivePanel(CMarsPanel *pPanel, BOOL bActive)
{
    if (bActive)
    {
        if (m_spActivePanel != pPanel)
        {
            if (m_spActivePanel)
            {
                m_spActivePanel->UIDeactivate();
                m_spActivePanel.Release();
            }

            m_spActivePanel = pPanel;
        }
    }
    else
    {
        //  A panel is telling us it doesn't want to be the active
        //  panel anymore.
        if (pPanel == m_spActivePanel)
        {
            m_spActivePanel->UIDeactivate();
            m_spActivePanel.Release();
        }
    }
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::get_activePanel
//
STDMETHODIMP CPanelCollection::get_activePanel(IMarsPanel **ppPanel)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(ppPanel))
    {
        *ppPanel = NULL;

        if (VerifyNotPassive(&hr))
        {
            hr = S_OK;

            *ppPanel = ActivePanel();

            if (*ppPanel)
            {
                (*ppPanel)->AddRef();
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT CPanelCollection::AddPanel( MarsAppDef_Panel* pLayout, /*optional*/ IMarsPanel **ppPanel)
{
    ATLASSERT(pLayout);
    ATLASSERT(!IsPassive());

    HRESULT hr = E_FAIL;

    if (ppPanel)
    {
        *ppPanel = NULL;
    }

    // If it's a duplicate panel name, just fail.
    if (!FindPanel(pLayout->szName))
    {
        CComClassPtr<CMarsPanel>    spPanel;

        spPanel.Attach(new CMarsPanel(this, m_spMarsDocument->MarsWindow()));

        if (spPanel)
        {
            if (Add(spPanel))
            {
                spPanel->Create(pLayout);

                if (ppPanel)
                {
                    hr = spPanel->QueryInterface(IID_IMarsPanel, (void **)ppPanel);
                }

                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
CMarsPanel *CPanelCollection::FindPanel(LPCWSTR pwszName)
{
    ATLASSERT(!IsPassive());

    CMarsPanel *pPanel = NULL;

    int iLen = GetSize();

    for (int i = 0; i < iLen; ++i)
    {
        if (!StrCmpIW(pwszName, (*this)[i]->GetName()))
        {
            pPanel = (*this)[i];
            break;
        }
    }

    return pPanel;
}

//------------------------------------------------------------------------------
HRESULT CPanelCollection::FindPanelIndex(CMarsPanel *pPanel, long *plIndex)
{
    ATLASSERT(plIndex);
    ATLASSERT(!IsPassive());

    HRESULT hr = E_FAIL;
    *plIndex = -1;

    if (pPanel)
    {
        long lSize = GetSize();

        for (long i = 0; i < lSize; ++i)
        {
            if (pPanel == (*this)[i])
            {
                *plIndex = i;
                hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
HRESULT CPanelCollection::InsertPanelFromTo(long lOldIndex, long lNewIndex)
{
    ATLASSERT((lOldIndex >= 0) && (lOldIndex < GetSize()));
    ATLASSERT(!IsPassive());

    HRESULT hr = S_FALSE;

    if (lNewIndex < 0)
    {
        lNewIndex = 0;
    }

    if (lNewIndex > GetSize() - 1)
    {
        lNewIndex = GetSize() - 1;
    }

    // If this is something that is done very often, we should optimize this better
    //  and probably not use an array
    if (lOldIndex != lNewIndex)
    {
        CComClassPtr<CMarsPanel>    spPanel = (*this)[lOldIndex];

        RemoveAt(lOldIndex);
        InsertAt(lNewIndex, spPanel);

        hr = S_OK;
    }

    return hr;
}


//------------------------------------------------------------------------------
// Sets the dirty bit on all panels after a theme switch
//
void CPanelCollection::InvalidatePanels()
{
   for (int i=0; i < GetSize(); i++)
   {
       (*this)[i]->put_contentInvalid(VARIANT_TRUE);
   }
}


//------------------------------------------------------------------------------
// Called after the theme switch event has fired, to refresh any panels
// that are visible but still haven't been updated with the new theme
//
void CPanelCollection::RefreshInvalidVisiblePanels()
{
   for (int i=0; i < GetSize(); i++)
   {
       CMarsPanel *pPanel = (*this)[i];

       if (pPanel->IsVisible() && pPanel->IsContentInvalid())
       {
           pPanel->refresh();
       }
   }
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::get_length
//
//       standard collection method (gets instantaneous length of coll)
//
STDMETHODIMP CPanelCollection::get_length(LONG *plNumPanels)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(plNumPanels))
    {
        (*plNumPanels) = GetSize();
        hr = S_OK;
    }

    return hr;
}

//------------------------------------------------------------------------------
// IMarsPanelCollection::get_item
//
//         standard collection method (gets an theme given index or name)
//
STDMETHODIMP CPanelCollection::get_item(/*[in]*/ VARIANT varIndexOrName,
                                        /*[out, retval]*/ IMarsPanel **ppPanel)
{
    ATLASSERT(VT_BSTR == varIndexOrName.vt || VT_I4 == varIndexOrName.vt);

    HRESULT hr = E_INVALIDARG;

    //
    // We can't use the API_IsValid varieties because they rip, and we actually don't want that.
    // It's only valid to RIP on IsValidFailure if only a single type is allowed, but here we
    // allow two types in the Variant, so we would only want to RIP if both are false (already
    // handled by above RIP).
    //
    if ((IsValidVariantI4(varIndexOrName) || IsValidVariantBstr(varIndexOrName)) &&
        API_IsValidWritePtr(ppPanel))
    {
        *ppPanel= NULL;

        if (VerifyNotPassive(&hr))
        {
            CMarsPanel *pPanel = NULL;

            if (VT_BSTR == varIndexOrName.vt)
            {
                pPanel = FindPanel(V_BSTR(&varIndexOrName));

                if (pPanel)
                {
                    hr = pPanel->QueryInterface(IID_IMarsPanel, (void **)ppPanel);
                }
                else
                {
                    hr = S_FALSE;
                }
            }
            else if (VT_I4 == varIndexOrName.vt)
            {
                long    idxPanel = V_I4(&varIndexOrName);

                if (idxPanel >= 0 && idxPanel < GetSize())
                {
                    pPanel = (*this)[idxPanel];

                    if (pPanel)
                    {
                        hr = pPanel->QueryInterface(IID_IMarsPanel, (void **)ppPanel);
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
            else
            {
                // We only accept VT_BSTR and VT_I4 and we should have already
                // detected any other invalid params higher up in the function.
                ATLASSERT(false);
            }
        }
    }

    return hr;
} // get_item


//------------------------------------------------------------------------------
// IMarsPanelCollection::get__newEnum
//          standard collection method (gets a new IEnumVARIANT)
//
STDMETHODIMP CPanelCollection::get__newEnum(/*[out, retval]*/ IUnknown **ppEnumPanels)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidWritePtr(ppEnumPanels))
    {
        *ppEnumPanels = NULL;

        if (VerifyNotPassive(&hr))
        {
            // This helper takes a CMarsSimpleArray and does all
            // the work of creating a CComEnum for us. Neat!

            hr = CMarsComEnumVariant< CMarsPanel >::CreateFromMarsSimpleArray(*this, ppEnumPanels);
        }
    }

    return hr;
} // get__newEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\marswin.cpp ===
#include "precomp.h"
#define __MARS_INLINE_FAST_IS_EQUAL_GUID
#include "mcinc.h"
#include "marswin.h"
#include <exdispid.h>
#include "parser\marsload.h"
#include "panel.h"
#include "place.h"

// CLASS_CMarsWindow = {172AF160-5CD4-11d3-97FA-00C04F45D0B3}
const GUID CLASS_CMarsWindow = { 0x172af160, 0x5cd4, 0x11d3, { 0x97, 0xfa, 0x0, 0xc0, 0x4f, 0x45, 0xd0, 0xb3 } };

// CLASS_CMarsDocument = {E0C4E3A8-20D6-47d6-87FB-0A43452117BA}
const GUID CLASS_CMarsDocument = { 0xe0c4e3a8, 0x20d6, 0x47d6, { 0x87, 0xfb, 0xa, 0x43, 0x45, 0x21, 0x17, 0xba } };


#define WZ_WINDOWPLACEMENT  L"WindowPlacement\\%d_%d_%s"
#define WZ_POSITIONMAX      L"Maximized"
#define WZ_POSITIONRECT     L"Rect"

static void combineMin( long& out, long in1, long in2 )
{
    if(in1 > 0)
    {
        out = (in2 > 0) ? in2 + in1 : in1;
    }
    else
    {
        out = in2;
    }
}

static void combineMax( long& out, long in1, long in2 )
{
    if(in1 < 0 || in2 < 0)
    {
        out = -1; // Don't care...
    }
    else
    {
        out = in2 + in1;
    }
}

static void selectMin( long& out, long in1, long in2 )
{
    if(in1 < 0)
    {
        out = in2;
    }
    else if(in2 < 0)
    {
        out = in1;
    }
    else
    {
        out = max( in1, in2 );
    }
}

static void selectMax( long& out, long in1, long in2 )
{
    if(in1 < 0)
    {
        out = in2;
    }
    else if(in2 < 0)
    {
        out = in1;
    }
    else
    {
        out = min( in1, in2 );
    }
}

static BOOL WriteWindowPosition(CRegistryKey &regkey, RECT *prc, BOOL fMaximized)
{
    return ERROR_SUCCESS == regkey.SetBoolValue(fMaximized, WZ_POSITIONMAX)
        && ERROR_SUCCESS == regkey.SetBinaryValue(prc, sizeof(*prc), WZ_POSITIONRECT);
}



//==================================================================
//
// CMarsDocument implementation
//
//==================================================================

CMarsDocument::CMarsDocument()
{
}

CMarsDocument::~CMarsDocument()
{
}

HRESULT CMarsWindow::Passivate()
{
    return CMarsComObject::Passivate();
}

HRESULT CMarsDocument::DoPassivate()
{
    m_spPanels.PassivateAndRelease();
    m_spPlaces.PassivateAndRelease();

    m_spMarsWindow.Release();
    m_spHostPanel.Release();
    m_cwndDocument.Detach();

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CMarsDocument);

STDMETHODIMP CMarsDocument::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    ATLASSERT(ppvObject);

    if(iid == IID_IUnknown         ||
       iid == IID_IServiceProvider  )
    {
        *ppvObject = SAFECAST(this, IServiceProvider *);
    }
    else if(iid == CLASS_CMarsDocument)
    {
        *ppvObject = SAFECAST(this, CMarsDocument *);
    }
    else
    {
        *ppvObject = NULL;
    }

    if(*ppvObject)
    {
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

HRESULT CMarsDocument::Init(CMarsWindow *pMarsWindow, CMarsPanel *pHostPanel)
{
    ATLASSERT(pMarsWindow);

    m_spMarsWindow = pMarsWindow;

    m_spHostPanel = pHostPanel;

    if(pHostPanel)
    {
        m_cwndDocument.Attach(m_spHostPanel->Window()->m_hWnd);
    }
    else
    {
        m_cwndDocument.Attach(m_spMarsWindow->m_hWnd);
    }

    m_spPlaces.Attach(new CPlaceCollection(this));
    m_spPanels.Attach(new CPanelCollection(this));

    return (m_spMarsWindow && m_spPanels && m_spPlaces) ? S_OK : E_FAIL;
}

// static
HRESULT CMarsDocument::CreateInstance(CMarsWindow *pMarsWindow, CMarsPanel *pHostPanel, CMarsDocument **ppObj)
{
    ATLASSERT(pMarsWindow && ppObj && (*ppObj==NULL));

    *ppObj=NULL;

    if(pMarsWindow)
    {
        CMarsDocument *pDoc;

        pDoc = new CMarsDocument();

        if(pDoc)
        {
            if(SUCCEEDED(pDoc->Init(pMarsWindow, pHostPanel)))
            {
                *ppObj = pDoc;
            }
            else
            {
                pDoc->Passivate();
                pDoc->Release();
            }
        }
    }

    return (*ppObj) ? S_OK : E_FAIL;
}

// IServiceProvider
HRESULT CMarsDocument::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    if(!IsPassive())
    {
        if(guidService == SID_SMarsDocument)
        {
            hr = QueryInterface(riid, ppv);
        }
    }

    return hr;
}

HRESULT CMarsDocument::GetPlaces(IMarsPlaceCollection **ppPlaces)
{
    ATLASSERT(ppPlaces);
    ATLASSERT(!IsPassive());

    if(m_spPlaces)
    {
        return m_spPlaces.QueryInterface(ppPlaces);
    }

    *ppPlaces = NULL;
    return E_FAIL;
}

HRESULT CMarsDocument::ReadPanelDefinition(LPCWSTR pwszUrl)
{
    FAIL_AFTER_PASSIVATE();

    HRESULT hr;

    GetPanels()->lockLayout();

    if(pwszUrl)
    {
        hr = CMMFParser::MMFToMars(pwszUrl, this);
    }
    else
    {
        hr = E_FAIL;
    }

    GetPanels()->unlockLayout();

    return hr;
}

void CMarsDocument::ForwardMessageToChildren(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPanelCollection* panels = GetPanels();

    if(panels)
    {
        for(int i=0; i < panels->GetSize(); i++)
        {
            CMarsPanel* pPanel = (*panels)[i];

            if(pPanel) pPanel->ForwardMessage(uMsg, wParam, lParam);
        }
    }
}

//==================================================================
//
// CMarsWindow implementation
//
//==================================================================

CMarsWindow::CMarsWindow()
{
    m_fShowTitleBar   = TRUE;
    m_fEnableModeless = TRUE;
    m_fLayoutLocked   = FALSE;
}

CMarsWindow::~CMarsWindow()
{
    if(m_hAccel)
    {
        DestroyAcceleratorTable(m_hAccel);
    }
}

HRESULT CMarsWindow::DoPassivate()
{
    (void)NotifyHost(MARSHOST_ON_WIN_PASSIVATE, SAFECAST(this, IMarsWindowOM *), 0);

    CMarsDocument::DoPassivate();

    if(IsWindow())
    {
        DestroyWindow();
    }

    m_spMarsHost.Release();

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CMarsWindow);

STDMETHODIMP CMarsWindow::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    ATLASSERT(ppvObject);

    if(iid == IID_IMarsWindowOM ||
       iid == IID_IDispatch     ||
       iid == IID_IUnknown       )
    {
        *ppvObject = SAFECAST(this, IMarsWindowOM *);
    }
    else if(iid == IID_IOleWindow          ||
            iid == IID_IOleInPlaceUIWindow ||
            iid == IID_IOleInPlaceFrame     )
    {
        *ppvObject = SAFECAST(this, IOleInPlaceFrame *);
    }
    else if(iid == IID_IServiceProvider)
    {
        *ppvObject = SAFECAST(this, IServiceProvider *);
    }
    else if(iid == IID_IProfferService)
    {
        *ppvObject = SAFECAST(this, IProfferService *);
    }
    else if(iid == CLASS_CMarsWindow)
    {
        *ppvObject = SAFECAST(this, CMarsWindow *);
    }
    else
    {
        *ppvObject = NULL;
    }

    if(*ppvObject)
    {
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = CMarsDocument::QueryInterface(iid, ppvObject);
    }

    return hr;
}

//
// Static creation function
//
HRESULT CMarsWindow::CreateInstance(IMarsHost *pMarsHost, MARSTHREADPARAM *pThreadParam, CMarsWindow **ppObj)
{
    ATLASSERT(pThreadParam && ppObj && (*ppObj==NULL));

    *ppObj=NULL;

    if(pThreadParam)
    {
        CComClassPtr<CMarsWindow> spWin;

        spWin.Attach(new CMarsWindow());

        if(spWin)
        {
            if(pThreadParam->pwszFirstPlace)
            {
                spWin->m_bstrFirstPlace = pThreadParam->pwszFirstPlace;
            }

            if(SUCCEEDED(spWin->Init(pMarsHost, pThreadParam)) &&
               SUCCEEDED(spWin->Startup()                    )  )
            {
                *ppObj = spWin.Detach();
            }
            else
            {
                spWin.PassivateAndRelease();
            }
        }
    }

    return (*ppObj) ? S_OK : E_FAIL;
}

HRESULT CMarsWindow::Init(IMarsHost *pMarsHost, MARSTHREADPARAM *pThreadParam)
{
    HRESULT hr;

    m_pThreadParam = pThreadParam;
    m_spMarsHost = pMarsHost;

    Create(NULL,
           rcDefault,
           GetThreadParam()->pwszTitle,
           WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN
           );

    hr = CMarsDocument::Init(this, NULL);

    if(SUCCEEDED(hr))
    {
        CGlobalSettingsRegKey regkey;
        WINDOWPLACEMENT       wp; wp.length = sizeof(wp);
        BOOL                  fMaximized;

        GetWindowPlacement( &wp );

        if(GetThreadParam()->dwFlags & MTF_MANAGE_WINDOW_SIZE)
        {
			if(InitWindowPosition( regkey, FALSE ))
			{
                LoadWindowPosition( regkey, TRUE, wp, fMaximized );
            }
        }

        if(SUCCEEDED(NotifyHost( MARSHOST_ON_WIN_SETPOS, SAFECAST(this, IMarsWindowOM *), (LPARAM)&wp )))
        {
            // Always make sure the window is fully on-screen
            BoundWindowRectToMonitor( m_hWnd, &wp.rcNormalPosition );
        }

		if(wp.showCmd == SW_MAXIMIZE)
		{
			m_fStartMaximized = true;
		}
		wp.showCmd = SW_HIDE;

////		if(GetThreadParam()->dwFlags & MTF_DONT_SHOW_WINDOW)
////		{
////			wp.showCmd = SW_HIDE;
////		}

        if(GetThreadParam()->dwFlags & MTF_MANAGE_WINDOW_SIZE)
        {
            // Make the next Mars window try and appear at the current location.
            WriteWindowPosition( regkey, &wp.rcNormalPosition, fMaximized );
        }

        SetWindowPlacement( &wp );
    }

    if(SUCCEEDED(hr))
    {
        hr = NotifyHost( MARSHOST_ON_WIN_INIT, SAFECAST(this, IMarsWindowOM *), (LPARAM)m_hWnd );
    }

    if(SUCCEEDED(hr))
    {
        hr = ReadPanelDefinition(GetThreadParam()->pwszPanelURL);
    }

    return hr;
}

HRESULT CMarsWindow::Startup()
{
    HRESULT hr;

    if(SUCCEEDED(hr = NotifyHost( MARSHOST_ON_WIN_READY, SAFECAST(this, IMarsWindowOM *), 0 )))
    {
        if(hr == S_FALSE)
        {
            ; // Host has taken care of the startup.
        }
        else
        {
            CComClassPtr<CMarsPlace> spPlace;

            if(SUCCEEDED(hr = GetPlaces()->GetPlace( m_bstrFirstPlace, &spPlace )))
            {
                hr = spPlace->transitionTo();
            }
        }
    }

    return hr;
}


// IServiceProvider
HRESULT CMarsWindow::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    if(!IsPassive())
    {
        if(guidService == SID_SProfferService ||
           guidService == SID_SMarsWindow     ||
           guidService == SID_STopWindow       )
        {
            hr = QueryInterface(riid, ppv);
        }
        else
        {
            hr = IProfferServiceImpl::QueryService(guidService, riid, ppv);

            if(FAILED(hr))
            {
                hr = CMarsDocument::QueryService(guidService, riid, ppv);

                if(FAILED(hr))
                {
                    hr = IUnknown_QueryService(m_spMarsHost, guidService, riid, ppv);
                }
            }
        }
    }

    return hr;
}

// IMarsWindowOM
STDMETHODIMP CMarsWindow::get_active(VARIANT_BOOL *pbActive)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbActive ))
    {
        if(VerifyNotPassive( &hr ))
        {
            *pbActive = VARIANT_BOOLIFY(IsWindowActive());
            hr = S_OK;
        }
        else
        {
            *pbActive = VARIANT_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::get_minimized(VARIANT_BOOL *pbMinimized)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbMinimized ))
    {
        if(VerifyNotPassive( &hr ))
        {
            *pbMinimized = IsIconic() ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            *pbMinimized = VARIANT_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::put_minimized(VARIANT_BOOL bMinimized)
{
    ATLASSERT(IsValidVariantBoolVal(bMinimized));

    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        if(!!IsIconic() != !!bMinimized)
        {
            SendMessage(WM_SYSCOMMAND, (bMinimized ? SC_MINIMIZE : SC_RESTORE), 0);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::get_maximized(VARIANT_BOOL *pbMaximized)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr( pbMaximized ))
    {
        if(VerifyNotPassive( &hr ))
        {
            *pbMaximized = IsZoomed() ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
        else
        {
            *pbMaximized = VARIANT_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::put_maximized(VARIANT_BOOL bMaximized)
{
    ATLASSERT(IsValidVariantBoolVal(bMaximized));

    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        DWORD dwStyle = ::GetWindowLong( m_hWnd, GWL_STYLE );
        DWORD dwNewStyle = dwStyle | (WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_SIZEBOX);

        if(dwStyle != dwNewStyle)
        {
            ::SetWindowLong( m_hWnd, GWL_STYLE, dwNewStyle );
        }

        if(!!IsZoomed() != !!bMaximized)
        {
            SendMessage(WM_SYSCOMMAND, (bMaximized ? SC_MAXIMIZE : SC_RESTORE), 0);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::get_title(BSTR *pbstrTitle)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(pbstrTitle))
    {
        if(VerifyNotPassive(&hr))
        {
            int nLen = (int)SendMessage(WM_GETTEXTLENGTH, 0, 0);

            //  SysAllocStringLen adds 1 for the NULL terminator
            *pbstrTitle = SysAllocStringLen(NULL, nLen);

            if(*pbstrTitle)
            {
                GetWindowText(*pbstrTitle, nLen + 1);
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            *pbstrTitle = NULL;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::put_title(BSTR bstrTitle)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidBstr(bstrTitle))
    {
        if(VerifyNotPassive(&hr))
        {
            //  TODO: If the text is not displayable with the current system font
            //  we need to come up with something legible.
            SetWindowText(bstrTitle);
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::get_height(long *plHeight)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(plHeight))
    {
        if(VerifyNotPassive(&hr))
        {
            hr = SCRIPT_ERROR;
            RECT rc;

            if(GetWindowRect(&rc))
            {
                *plHeight = RECTHEIGHT(rc);
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::put_height(long lHeight)
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive(&hr))
    {
        RECT rc;

        if(GetWindowRect( &rc ) && SetWindowPos( NULL, 0, 0, RECTWIDTH(rc), lHeight, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE ))
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::get_width(long *plWidth)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(plWidth))
    {
        if(VerifyNotPassive(&hr))
        {
            hr = SCRIPT_ERROR;
            RECT rc;

            if(GetWindowRect(&rc))
            {
                *plWidth = RECTWIDTH(rc);
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::put_width(long lWidth)
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive(&hr))
    {
        RECT rc;

        if(GetWindowRect( &rc ) && SetWindowPos( NULL, 0, 0, lWidth, RECTHEIGHT(rc), SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE ))
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::get_x(long *plX)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(plX))
    {
        if(VerifyNotPassive(&hr))
        {
            hr = SCRIPT_ERROR;
            RECT rc;

            if(GetWindowRect(&rc))
            {
                *plX = rc.left;
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::put_x(long lX)
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive( &hr ))
    {
        RECT rc;

        if(GetWindowRect( &rc ) && SetWindowPos( NULL, lX, rc.top, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::get_y(long *plY)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(plY))
    {
        if(VerifyNotPassive(&hr))
        {
            hr = SCRIPT_ERROR;
            RECT rc;

            if(GetWindowRect(&rc))
            {
                *plY = rc.top;
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::put_y(long lY)
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive( &hr ))
    {
        RECT rc;

        if(GetWindowRect( &rc ) && SetWindowPos( NULL, rc.left, lY, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE ))
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::get_visible(VARIANT_BOOL *pbVisible)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(pbVisible))
    {
        if(VerifyNotPassive(&hr))
        {
            *pbVisible = IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
             hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CMarsWindow::put_visible(VARIANT_BOOL bVisible)
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive(&hr))
    {
        if(bVisible)
        {
            if(m_fUIPanelsReady)
            {
                DoShowWindow(SW_SHOW);
            }
            else
            {
                // Our UI hasn't finished loading yet so showing the window
                // now is ugly.  We'll remember this put_visible was done, and
                // show the window when the UI panels have fully loaded.

                m_fDeferMakeVisible = TRUE;
            }
        }
        else
        {
            DoShowWindow(SW_HIDE);
        }

        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CMarsWindow::get_panels(IMarsPanelCollection **ppPanels)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(ppPanels))
    {
        *ppPanels = NULL;

        if(VerifyNotPassive(&hr))
        {
            hr = GetPanels()->QueryInterface(IID_IMarsPanelCollection, (void **)ppPanels);
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::get_places(IMarsPlaceCollection **ppPlaces)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(ppPlaces))
    {
        *ppPlaces = NULL;

        if(VerifyNotPassive(&hr))
        {
            hr = GetPlaces()->QueryInterface(IID_IMarsPlaceCollection, (void **)ppPlaces);
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::setWindowDimensions( /*[in]*/ long lX, /*[in]*/ long lY, /*[in]*/ long lW, /*[in]*/ long lH )
{
    HRESULT hr = SCRIPT_ERROR;

    if(VerifyNotPassive( &hr ))
    {
        if(SetWindowPos(NULL, lX, lY, lW, lH, SWP_NOACTIVATE | SWP_NOZORDER))
        {
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::close()
{
    HRESULT hr = S_OK;

    if(VerifyNotPassive(&hr))
    {
        PostMessage(WM_CLOSE, 0, 0);
    }

    return hr;
}

STDMETHODIMP CMarsWindow::refreshLayout()
{
    HRESULT hr = S_OK;

    if(VerifyNotPassive( &hr ))
    {
        CPanelCollection *panels = GetPanels();

        if(panels) panels->Layout();
    }

    return hr;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

// IOleWindow
STDMETHODIMP CMarsWindow::GetWindow(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(phwnd))
    {
        if(IsWindow())
        {
            *phwnd = m_hWnd;
            hr = S_OK;
        }
        else
        {
            *phwnd = NULL;
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CMarsWindow::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// IOleInPlaceUIWindow
STDMETHODIMP CMarsWindow::GetBorder(LPRECT lprectBorder)
{
    ATLASSERT(lprectBorder);

    // We don't negotiate any toolbar space -- if they want screen real estate
    // they won't get it from us willingly.
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CMarsWindow::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    ATLASSERT(pborderwidths);

    // Look buddy, we told you before -- we ain't giving you any of our pixels.
    return INPLACE_E_NOTOOLSPACE;
}

STDMETHODIMP CMarsWindow::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    ATLASSERT(pborderwidths);

    // Pushy OLE object wouldn't ya say?
    return E_UNEXPECTED;    //  return E_BITEME;
}

STDMETHODIMP CMarsWindow::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName)
{
    // REVIEW: Maybe this is how a panel should let us know it's active.  We currently track that in
    // the CPanelCollection via SetActivePanel().

    return S_OK;
}

// IOleInPlaceFrame
STDMETHODIMP CMarsWindow::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    // Menus?  We don't need no steenkin' menus.
    ATLASSERT(hmenuShared &&
           API_IsValidWritePtr(lpMenuWidths) &&
           (0 == lpMenuWidths->width[0]) &&
           (0 == lpMenuWidths->width[2]) &&
           (0 == lpMenuWidths->width[4]));

    return E_NOTIMPL;
}

STDMETHODIMP CMarsWindow::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMarsWindow::RemoveMenus(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMarsWindow::SetStatusText(LPCOLESTR pszStatusText)
{
    ATLASSERT((NULL == pszStatusText) || (API_IsValidString(pszStatusText)));

    return S_OK;
}

STDMETHODIMP CMarsWindow::EnableModeless(BOOL fEnable)
{
    FAIL_AFTER_PASSIVATE();

    m_fEnableModeless = BOOLIFY(fEnable);
    return GetPanels()->DoEnableModeless(fEnable);
}

STDMETHODIMP CMarsWindow::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // REVIEW: Should we make keyboard routing go through here?

    return S_FALSE;
}

//==================================================================
// Window message handlers
//==================================================================
LRESULT CMarsWindow::ForwardToMarsHost(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;

    if(m_spMarsHost)
    {
        MSG msg;

        msg.hwnd    = m_hWnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        if(SUCCEEDED(m_spMarsHost->PreTranslateMessage( &msg )))
        {
            bHandled = TRUE;
        }
    }

    return 0;
}

LRESULT CMarsWindow::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetIcon(GetThreadParam()->hIcon);

    return TRUE;
}

LRESULT CMarsWindow::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CPanelCollection *panels = GetPanels(); if(!panels) return 0;

    switch(wParam)
    {
    case SIZE_MINIMIZED:
        if(!m_fLayoutLocked)
        {
            panels->lockLayout();
            m_fLayoutLocked = TRUE;
        }
        break;

    case SIZE_MAXIMIZED:
    case SIZE_RESTORED :
        if(m_fLayoutLocked)
        {
            panels->unlockLayout();

            m_fLayoutLocked = FALSE;
        }
        // Fall through...

    default:
        panels->Layout();
        break;
    }

    return 0;
}

LRESULT CMarsWindow::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(GetThreadParam()->dwFlags & MTF_MANAGE_WINDOW_SIZE)
    {
        CGlobalSettingsRegKey regkey;

		if(InitWindowPosition( regkey, TRUE ))
		{
            SaveWindowPosition( regkey );
        }
    }

    Passivate();

    return FALSE;
}

LRESULT CMarsWindow::OnNCActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lResult;

    if(!m_fShowTitleBar && !IsIconic())
    {
        lResult = TRUE;
    }
    else
    {
        lResult = DefWindowProc(uMsg, wParam, lParam);
    }

    return lResult;
}

LRESULT CMarsWindow::OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    WORD wActive = LOWORD(wParam);

    if(wActive == WA_INACTIVE)
    {
        //
        // If we are the active window, remember the focus location, to restore it later.
        //
        if(m_fActiveWindow)
        {
            if(!IsPassive()) m_hwndFocus = GetFocus();

            m_fActiveWindow = FALSE;
        }
    }
    else
    {
        m_fActiveWindow = TRUE;
    }

    bHandled = FALSE;
    return 0;
}

LRESULT CMarsWindow::OnGetMinMaxInfo(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    MINMAXINFO       *pInfo    = (MINMAXINFO *)lParam;
    CPanelCollection *spPanels = GetPanels();

    if(spPanels)
    {
        long  lAdjustWidth;
        long  lAdjustHeight;
        POINT ptMin;
        POINT ptMax;
        RECT  rcClient;
        RECT  rcWindow;


        GetMinMaxInfo( spPanels, 0, ptMin, ptMax );


        GetClientRect( &rcClient );
        GetWindowRect( &rcWindow );

        lAdjustWidth  = (rcWindow.right  - rcWindow.left) - (rcClient.right  - rcClient.left);
        lAdjustHeight = (rcWindow.bottom - rcWindow.top ) - (rcClient.bottom - rcClient.top );

        if(ptMin.x >= 0) pInfo->ptMinTrackSize.x = ptMin.x + lAdjustWidth ;
        if(ptMin.y >= 0) pInfo->ptMinTrackSize.y = ptMin.y + lAdjustHeight;

        if(ptMax.x >= 0) pInfo->ptMaxTrackSize.x = ptMax.x + lAdjustWidth ;
        if(ptMax.y >= 0) pInfo->ptMaxTrackSize.y = ptMax.y + lAdjustHeight;
    }

    return 0;
}

void CMarsWindow::GetMinMaxInfo( CPanelCollection *spPanels, int index, POINT& ptMin, POINT& ptMax )
{
    ptMin.x = -1;
    ptMin.y = -1;
    ptMax.x = -1;
    ptMax.y = -1;

    if(spPanels && index < spPanels->GetSize())
    {
        CMarsPanel* pPanel = (*spPanels)[index++];

        if(pPanel)
        {
            PANEL_POSITION pos = pPanel->GetPosition();
            if(pos != PANEL_POPUP)
            {
                if(pPanel->IsVisible())
                {
                    POINT ptOurMin;
                    POINT ptOurMax;
                    POINT ptSubMin;
                    POINT ptSubMax;

                    pPanel->GetMinMaxInfo( ptOurMin, ptOurMax );
                    GetMinMaxInfo( spPanels, index, ptSubMin, ptSubMax );


                    if(pos == PANEL_BOTTOM || pos == PANEL_TOP)
                    {
                        selectMin( ptMin.x, ptOurMin.x, ptSubMin.x );
                        selectMax( ptMax.x, ptOurMax.x, ptSubMax.x );
                    }
                    else
                    {
                        combineMin( ptMin.x, ptOurMin.x, ptSubMin.x );
                        combineMax( ptMax.x, ptOurMax.x, ptSubMax.x );
                    }

                    if(pos == PANEL_LEFT || pos == PANEL_RIGHT)
                    {
                        selectMin( ptMin.y, ptOurMin.y, ptSubMin.y );
                        selectMax( ptMax.y, ptOurMax.y, ptSubMax.y );
                    }
                    else
                    {
                        combineMin( ptMin.y, ptOurMin.y, ptSubMin.y );
                        combineMax( ptMax.y, ptOurMax.y, ptSubMax.y );
                    }
                }
                else
                {
                    GetMinMaxInfo( spPanels, index, ptMin, ptMax );
                }
            }
        }
    }
}

bool CMarsWindow::CanLayout( /*[in/out]*/ RECT rcClient )
{
    CPanelCollection *spPanels = GetPanels();

    if(spPanels)
    {
        for(int i=0; i<spPanels->GetSize(); i++)
        {
            CMarsPanel* pPanel = (*spPanels)[i];
            POINT       ptDiff;

            if(pPanel->CanLayout( rcClient, ptDiff ) == false)
            {
                return false;
            }
        }
    }

    return true;
}

void CMarsWindow::FixLayout( /*[in/out]*/ RECT rcClient )
{
    CPanelCollection *spPanels = GetPanels();

    if(spPanels)
    {
        POINT ptDiff;

        FixLayout( spPanels, 0, rcClient, ptDiff );
    }
}

void CMarsWindow::FixLayout( CPanelCollection *spPanels, int index, RECT rcClient, POINT& ptDiff )
{
    ptDiff.x = 0;
    ptDiff.y = 0;

    if(index < spPanels->GetSize())
    {
        CMarsPanel*    pPanel    = (*spPanels)[index++];
        PANEL_POSITION pos       = pPanel->GetPosition();
        RECT           rcClient2 = rcClient;
        POINT          ptSubDiff;

        //
        // First round, try to fix first ourselves and then lets the other fix themselves.
        //
        if(pPanel->CanLayout( rcClient2, ptDiff ) == false)
        {
            if(pos == PANEL_BOTTOM || pos == PANEL_TOP)
            {
                if(ptDiff.y)
                {
                    pPanel->put_height( pPanel->GetHeight() - ptDiff.y );
                }
            }

            if(pos == PANEL_LEFT || pos == PANEL_RIGHT)
            {
                if(ptDiff.x)
                {
                    pPanel->put_width ( pPanel->GetWidth () - ptDiff.x );
                }
            }

            rcClient2 = rcClient;
            pPanel->CanLayout( rcClient2, ptDiff );
        }

        FixLayout( spPanels, index, rcClient2, ptSubDiff );

        //
        // Second round, based on what the other panels need, we adjust.
        //
        if(pos == PANEL_BOTTOM || pos == PANEL_TOP)
        {
            if(ptSubDiff.y)
            {
                pPanel->put_height( pPanel->GetHeight() - ptSubDiff.y );
            }
        }

        if(pos == PANEL_LEFT || pos == PANEL_RIGHT)
        {
            if(ptSubDiff.x)
            {
                pPanel->put_width ( pPanel->GetWidth () - ptSubDiff.x );
            }
        }


        pPanel->CanLayout( rcClient, ptDiff );
        FixLayout( spPanels, index, rcClient2, ptSubDiff );

        ptDiff.x += ptSubDiff.x;
        ptDiff.y += ptSubDiff.y;
    }
}


void DrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
    HBRUSH hbr;
    int cx, cy;
    RECT rcT;

    ATLASSERT(NULL != prc);

    int cyBorder = GetSystemMetrics(SM_CYBORDER);
    int cxBorder = GetSystemMetrics(SM_CXBORDER);

    rcT = *prc;
    cx = cl * cxBorder;
    cy = cl * cyBorder;

    hbr = (HBRUSH)SelectObject(hdc, hbrColor);

    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
    rcT.left += cx;

    PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
    rcT.top += cy;

    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

    SelectObject(hdc, hbr);

    *prc = rcT;
}

//  For now it looks like we can let windows handle this since we are adjusting
//  the client rect ourselves in OnNCCalcSize.

LRESULT CMarsWindow::OnNCPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lResult;

    if(!m_fShowTitleBar)
    {
        HDC hdc = GetDCEx(wParam != 1 ? (HRGN)wParam : NULL, DCX_WINDOW | DCX_INTERSECTRGN);
        if(NULL == hdc)
        {
            hdc = GetWindowDC();
        }

        RECT rcWindow;
        GetWindowRect(&rcWindow);
        OffsetRect(&rcWindow, -rcWindow.left, -rcWindow.top);

        HBRUSH hbrBorder = CreateSolidBrush(GetSysColor(COLOR_ACTIVEBORDER));
        HBRUSH hbrFrame = CreateSolidBrush(GetSysColor(COLOR_3DFACE));

        DrawEdge(hdc, &rcWindow, EDGE_RAISED, (BF_RECT | BF_ADJUST));

        NONCLIENTMETRICSA ncm;
        ncm.cbSize = sizeof(ncm);

        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), (void *)(LPNONCLIENTMETRICS)&ncm, 0);

        DrawFrame(hdc, &rcWindow, hbrBorder, ncm.iBorderWidth);
        DrawFrame(hdc, &rcWindow, hbrFrame, 1);

        DeleteObject(hbrBorder);
        DeleteObject(hbrFrame);

        ReleaseDC(hdc);
        lResult = 0;
    }
    else
    {
        lResult = DefWindowProc(uMsg, wParam, lParam);
    }

    return lResult;
}

LRESULT CMarsWindow::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PAINTSTRUCT ps;

    BeginPaint(&ps);
    EndPaint(&ps);
    return 0;
}

LRESULT CMarsWindow::OnPaletteChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hwndPaletteChange = (HWND)wParam;

    // Ignore if we changed the palette
    if(hwndPaletteChange == m_hWnd)
       return 0;

    // If we are the active window and one of our children set the forground palette
    // we want to avoid realizing our palette in the foreground or we get in a tug-of-war
    // with lots of flashing.
    if(IsChild(hwndPaletteChange) && (m_hWnd == GetForegroundWindow()))
    {
        // Our child caused a palette change so force a redraw to use the
        // new system palette. Children shouldn't do this, bad child!
        RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    }
    else
    {
        // Select our foreground palette
        OnQueryNewPalette(uMsg, wParam, lParam, bHandled);
    }

    return 0;
}

LRESULT CMarsWindow::OnQueryNewPalette(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lResult = FALSE;

    // Realize our palette
    if(g_hpalHalftone)
    {
        HDC hDC = GetDC();
        if(hDC)
        {
            if(GetDeviceCaps(hDC, RASTERCAPS) & RC_PALETTE)
            {
                HPALETTE hOldPal = SelectPalette(hDC, g_hpalHalftone, FALSE);
                UINT i = RealizePalette(hDC);

                // Did the realization change?  (We need to always invalidate background windows
                // because when we have multiple windows up only the first top-level
                // window will actually realize any colors.  Windows lower in the
                // z-order always get 0 returned from RealizePalette, but they
                // may need repainting!  We could further optimize by having the top
                // html window invalidate all the rest when i is non-zero. -- StevePro)
                if(i || (m_hWnd != GetForegroundWindow()))
                {
                    // Yes, so force a repaint.
                    RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
                }

                SelectPalette(hDC, hOldPal, TRUE);
                RealizePalette(hDC);
//                lResult = i;
                lResult = TRUE;
            }
            ReleaseDC(hDC);
        }
    }

    return lResult;
}

LRESULT CMarsWindow::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // We need to update our palette because some of the "reserved" colors may have changed
    HPALETTE hpal = SHCreateShellPalette(NULL);
    hpal = (HPALETTE)InterlockedExchangePointer( (LPVOID*)&g_hpalHalftone, hpal);
    if(hpal)
    {
        DeleteObject(hpal);
    }

    PostMessage(WM_QUERYNEWPALETTE, 0, (LPARAM) -1);

    // Trident likes to know about these changes
    ForwardMessageToChildren(uMsg, wParam, lParam);

    bHandled = FALSE;
    return 0;
}

LRESULT CMarsWindow::OnDisplayChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return OnSysColorChange(uMsg, wParam, lParam, bHandled);
}

LRESULT CMarsWindow::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if(wParam == SC_MINIMIZE)
    {
        //
        // If we are the active window, remember the focus location, to restore it later.
        //
        if(m_fActiveWindow)
        {
            if(!IsPassive()) m_hwndFocus = GetFocus();

            m_fActiveWindow = FALSE;
        }
    }

    bHandled = FALSE;
    return 0;
}

LRESULT CMarsWindow::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //
    // If we have a saved focus location, restore it.
    //
    if(m_hwndFocus && m_hwndFocus != m_hWnd)
    {
        ::SetFocus( m_hwndFocus );
    }

    return 0;
}

LRESULT CMarsWindow::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return TRUE;
}

LRESULT CMarsWindow::OnNCCalcSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lResult;

    if(!m_fShowTitleBar && !IsIconic())
    {
        RECT *prc = (RECT *)lParam;
        NONCLIENTMETRICSA ncm;

        ncm.cbSize = sizeof(ncm);

        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE);
        int xDelta = GetSystemMetrics(SM_CXEDGE) + ncm.iBorderWidth + 1;
        int yDelta = GetSystemMetrics(SM_CYEDGE) + ncm.iBorderWidth + 1;

        InflateRect(prc, -xDelta, -yDelta);

        lResult = 0;
    }
    else
    {
        lResult = DefWindowProc(uMsg, wParam, lParam);
    }

    return lResult;
}

LRESULT CMarsWindow::OnSetText(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    //  HACK 'O RAMA:  Turn off one of the WS_CAPTION style bits (WS_CAPTION == WS_BORDER | WS_DLGFRAME)
    //                 so that USER32 doesn't try and draw the title bar for us.

    DWORD dwStyle = GetWindowLong(GWL_STYLE);
    SetWindowLong(GWL_STYLE, dwStyle & ~WS_DLGFRAME);

    LRESULT lResult = DefWindowProc();

    SetWindowLong(GWL_STYLE, dwStyle);

    return lResult;
}

void CMarsWindow::OnFinalMessage(HWND hWnd)
{
    PostQuitMessage(0);
}

//==================================================================
// Panel/Place methods
//==================================================================

void CMarsWindow::DoShowWindow(int nCmdShow)
{
    if(GetThreadParam()->dwFlags & MTF_DONT_SHOW_WINDOW) return;

    ShowWindow( nCmdShow );

    // Win95 doesn't let the window from another thread appear in front of an
    // existing window, so we must grab the foreground

    if(IsWindowVisible())
    {
        SetForegroundWindow(m_hWnd);
    }
}

void CMarsWindow::OnTransitionComplete()
{
    if(!m_fUIPanelsReady && !IsWindowVisible())
    {
        m_fUIPanelsReady = TRUE;

        // start with the Mars window host's requested show mode
        int nCmdShow = GetThreadParam()->nCmdShow;

        if((nCmdShow == SW_HIDE) && m_fDeferMakeVisible)
        {
            // nCmdShow is SW_HIDE to indicate that the window should be shown
            // via put_visible.  In this case, someone did a pub_visible(TRUE) before
            // our UI panels were finished loading, so we'll honor the request now.

            nCmdShow = SW_SHOW;
        }

        // only promote to maximized state if we are going to become visible
        if((nCmdShow != SW_HIDE) && m_fStartMaximized)
        {
            nCmdShow = SW_MAXIMIZE;
        }

        DoShowWindow(nCmdShow);
    }
}

HRESULT CMarsWindow::ReleaseOwnedObjects(IUnknown *pUnknownOwner)
{
    return S_OK;
}

void CMarsWindow::SetFirstPlace( LPCWSTR szPlace )
{
    if(!m_bstrFirstPlace)
    {
        m_bstrFirstPlace = szPlace;
    }
}

void CMarsWindow::ShowTitleBar(BOOL fShowTitleBar)
{
    if(!!m_fShowTitleBar != !!fShowTitleBar)
    {
        m_fShowTitleBar = fShowTitleBar ? TRUE : FALSE;
        SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_FRAMECHANGED);
    }
}

BOOL CMarsWindow::TranslateAccelerator(MSG &msg)
{
    BOOL bProcessed = FALSE;

//    if(msg.message ==  WM_SYSKEYDOWN)
//    {
//        switch (msg.wParam)
//        {
//            case VK_LEFT:
//            case VK_RIGHT:
//                GetTravelLog()->travel((msg.wParam == VK_LEFT) ? -1 : 1);
//                bProcessed = TRUE;
//                break;
//        }
//    }

    return bProcessed;
}

BOOL CMarsWindow::PreTranslateMessage(MSG &msg)
{
    //  Set to TRUE if you don't want this message dispatched normally
    BOOL bProcessed = FALSE;

    switch (msg.message)
    {
        case WM_SETFOCUS:
            break;

        default:
            if((msg.message >= WM_KEYFIRST) && (msg.message <= WM_KEYLAST))
            {
                //  First we take a crack
                bProcessed = TranslateAccelerator(msg);

                //  Now let the active place try
                if(!bProcessed)
                {
                    CMarsPlace *pPlace = GetPlaces()->GetCurrentPlace();
                    if(NULL != pPlace)
                    {
                        bProcessed = (pPlace->TranslateAccelerator(&msg) == S_OK);
                    }
                }
            }
            else if((msg.message >= WM_MOUSEFIRST) && (msg.message <= WM_MOUSELAST))
            {
                if(m_bSingleButtonMouse)
                {
                    switch (msg.message)
                    {
                        case WM_RBUTTONDOWN:
                        case WM_MBUTTONDOWN:
                            msg.message = WM_LBUTTONDOWN;
                            break;

                        case WM_RBUTTONUP:
                        case WM_MBUTTONUP:
                            msg.message = WM_LBUTTONUP;
                            break;

                        case WM_RBUTTONDBLCLK:
                        case WM_MBUTTONDBLCLK:
                            msg.message = WM_LBUTTONDBLCLK;
                            break;
                    }
                }
            }
    }
    return bProcessed;
}


bool CMarsWindow::InitWindowPosition( CGlobalSettingsRegKey& regkey, BOOL fWrite )
{
	WCHAR rgPath[MAX_PATH];
	RECT  rc;

	if(::GetClientRect( ::GetDesktopWindow(), &rc ))
	{
		LPCWSTR szTitle       = GetThreadParam()->pwszTitle; if(!szTitle) szTitle = L"<DEFAULT>";
		LONG 	Screen_width  = rc.right  - rc.left;
		LONG 	Screen_height = rc.bottom - rc.top;

		_snwprintf( rgPath, sizeof(rgPath)/sizeof(rgPath[0]) - 1, WZ_WINDOWPLACEMENT, (int)Screen_width, (int)Screen_height, szTitle );

		if(fWrite)
		{
			if(regkey.CreateGlobalSubkey( rgPath ) == ERROR_SUCCESS) return true;
		}
		else
		{
			if(regkey.OpenGlobalSubkey( rgPath ) == ERROR_SUCCESS) return true;
		}
	}

	return false;
}

void CMarsWindow::SaveWindowPosition( CGlobalSettingsRegKey& regkey )
{
    WINDOWPLACEMENT wp; wp.length = sizeof(wp);

    GetWindowPlacement( &wp );

    WriteWindowPosition(regkey, &wp.rcNormalPosition, IsZoomed());
}


void CMarsWindow::LoadWindowPosition( CGlobalSettingsRegKey& regkey, BOOL fAllowMaximized, WINDOWPLACEMENT& wp, BOOL& fMaximized )
{
    RECT rc;


    // Use default values if there is no valid registry data
    if(ERROR_SUCCESS != regkey.QueryBoolValue(fMaximized, WZ_POSITIONMAX))
    {
        fMaximized = fAllowMaximized;
    }

    if(ERROR_SUCCESS != regkey.QueryBinaryValue(&rc, sizeof(rc), WZ_POSITIONRECT))
    {
        rc = wp.rcNormalPosition;

        GetThreadParam()->dwFlags &= ~MTF_RESTORING_FROM_REGISTRY;
    }
    else
    {
        GetThreadParam()->dwFlags |= MTF_RESTORING_FROM_REGISTRY;
    }

    // If the window is about to open with the same top-left corner as another
    // Mars window, cascade it.

    if(IsWindowOverlayed( m_hWnd, rc.left, rc.top ))
    {
        CascadeWindowRectOnMonitor( m_hWnd, &rc );
    }

    // Always make sure the window is fully on-screen
    BoundWindowRectToMonitor( m_hWnd, &rc );

    // Don't use maximized setting if we're opened by script
    m_fStartMaximized = fMaximized && fAllowMaximized;

    // Now set the size of the window -- we should be hidden at this point
    wp.rcNormalPosition = rc;
    wp.showCmd          = IsWindowVisible() ? (fMaximized ? SW_MAXIMIZE : SW_NORMAL) : SW_HIDE;
}

void CMarsWindow::SpinMessageLoop( BOOL fWait )
{
    MSG msg;

    while(fWait ? GetMessage( &msg, NULL, 0, 0 ) : PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
    {
        if(m_spMarsHost && SUCCEEDED(m_spMarsHost->PreTranslateMessage( &msg ))) continue;

        if(!PreTranslateMessage( msg ))
        {
            TranslateMessage( &msg );
            DispatchMessage ( &msg );
        }

        if(IsPassive()) break;
    }
}

//==================================================================
// Mars App
//==================================================================

HRESULT STDMETHODCALLTYPE MarsThreadProc(IMarsHost *pMarsHost, MARSTHREADPARAM *pThreadParam)
{
    HRESULT hr;

    if (!CThreadData::HaveData() && (NULL != pThreadParam) &&
        (pThreadParam->cbSize == sizeof(*pThreadParam)))
    {
        hr = E_OUTOFMEMORY;

        CThreadData *pThreadData = new CThreadData;

        if (pThreadData && CThreadData::TlsSetValue(pThreadData))
        {
            hr = CoInitialize(NULL);

            if(SUCCEEDED(hr))
            {
                MarsAxWinInit();

                CComClassPtr<CMarsWindow> spMarsWindow;

                CMarsWindow::CreateInstance(pMarsHost, pThreadParam, &spMarsWindow);


                if(spMarsWindow)
                {
                    spMarsWindow->SpinMessageLoop( TRUE );

                    // Ensure that no matter what the window is passivated & then release it
                    if (!spMarsWindow->IsPassive())
                    {
                        spMarsWindow->Passivate();
                    }
                }

                CoUninitialize();
            }

            CThreadData::TlsSetValue(NULL); //  paranoia
        }

        delete pThreadData;
    }
    else
    {
        if(pThreadParam)
        {
            ATLASSERT(pThreadParam->cbSize == sizeof(*pThreadParam));
        }

        //  If we already have TLS data then we are being reentered -- this is not a good thing!
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\panel.h ===
#ifndef __PANEL_H
#define __PANEL_H

// A "panel" is basically a tiled window inside the outer Mars window

class CMarsDocument;
class CMarsWindow;

interface IBrowserService;

#include "axhost.h"
#include "external.h"
#include "profsvc.h"
#include "pandef.h"

class CPanelCollection;

EXTERN_C const GUID CLASS_CMarsPanel;

class CMarsPanel :
    public CMarsComObject,
    public MarsIDispatchImpl<IMarsPanel, &IID_IMarsPanel>,
    public IHlinkFrame,
    public IInternetSecurityManager,
    public IServiceProvider,
    public IProfferServiceImpl,
    public IOleInPlaceSite,
    public IOleControlSite,
    public IPropertyNotifySink,
    public IOleInPlaceUIWindow
{
    friend CPanelCollection;
    CMarsPanel(CPanelCollection *pParent, CMarsWindow *pMarsWindow);

protected:
    virtual ~CMarsPanel();

    HRESULT DoPassivate();

public:
    virtual HRESULT Passivate();

    HRESULT Create( MarsAppDef_Panel* pLayout);
    HRESULT NavigateMk(IMoniker *pmk);
    HRESULT NavigateURL(LPCWSTR lpszURL, BOOL fForceLoad);

    HRESULT Layout( RECT *prcClient );

    void    OnWindowPosChanging( WINDOWPOS *pWindowPos );
    void    OnWindowPosChanged ( WINDOWPOS *pWindowPos );

    void    GetMinMaxInfo( POINT& ptMin, POINT& ptMax );
    bool    CanLayout( RECT& rcClient, POINT& ptDiff );

    void              GetUrl   ( CComBSTR& rbstrUrl );
    BSTR              GetName  () { return  m_bstrName;          }
    CMarsAxWindow    *Window   () { return &m_Content;           }
    CPanelCollection *Panels   () { return  m_spPanelCollection; }
    long              GetWidth () { return  m_lWidth; }
    long              GetHeight() { return  m_lHeight; }

    HRESULT UIDeactivate();
    HRESULT TranslateAccelerator(MSG *pMsg);
    void    ForwardMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMarsDocument *Document() { return m_spMarsDocument; }

    bool           IsWebBrowser      () { return (m_dwFlags & PANEL_FLAG_WEBBROWSER   ) != 0; }
    bool           IsCustomControl   () { return (m_dwFlags & PANEL_FLAG_CUSTOMCONTROL) != 0; }
    bool           IsPopup           () { return (m_Position == PANEL_POPUP);       		  }
    bool           IsVisible         () { return !!m_fVisible;                      		  }
    bool           WasInPreviousPlace() { return !!m_fPresentInPlace;               		  }
    bool           IsTrusted         () { return (m_dwFlags & PANEL_FLAG_TRUSTED      ) != 0; }
    bool           AutoPersists      () { return (m_dwFlags & PANEL_FLAG_AUTOPERSIST  ) != 0; }
    bool           IsAutoSizing      () { return (m_dwFlags & PANEL_FLAG_AUTOSIZE     ) != 0; }
    LONG           GetReadyState     () { return  m_lReadyState;                    		  }
    PANEL_POSITION GetPosition       () { return  m_Position;                       		  }


    BOOL    GetTabCycle()   { return m_fTabCycle; }
    void    ResetTabCycle() { ATLASSERT(m_fTabCycle); m_fTabCycle = FALSE; }
	void    SetPresenceInPlace( BOOL fPresent ) { m_fPresentInPlace = fPresent; }

    BOOL    IsContentInvalid()   { return m_fContentInvalid; }

    HRESULT DoEnableModeless(BOOL fEnable);

    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IMarsPanel
    STDMETHOD(get_name              )( /*[out, retval]*/ BSTR         *pVal   );
    STDMETHOD(get_content           )( /*[out, retval]*/ IDispatch*   *pVal   );
    STDMETHOD(get_visible           )( /*[out, retval]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_visible           )( /*[in         ]*/ VARIANT_BOOL  newVal );
    STDMETHOD(get_startUrl          )( /*[out, retval]*/ BSTR         *pVal   );
    STDMETHOD(put_startUrl          )( /*[in         ]*/ BSTR          newVal );
    STDMETHOD(get_height            )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(put_height            )( /*[in         ]*/ long          newVal );
    STDMETHOD(get_width             )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(put_width             )( /*[in         ]*/ long          newVal );
    STDMETHOD(get_x                 )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(put_x                 )( /*[in         ]*/ long          newVal );
    STDMETHOD(get_y                 )( /*[out, retval]*/ long         *pVal   );
    STDMETHOD(put_y                 )( /*[in         ]*/ long          newVal );
    STDMETHOD(get_position          )( /*[out, retval]*/ VARIANT      *pVal   );
    STDMETHOD(put_position          )( /*[in         ]*/ VARIANT       newVal );
    STDMETHOD(get_autoSize          )( /*[out, retval]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_autoSize          )( /*[in         ]*/ VARIANT_BOOL  newVal );
    STDMETHOD(get_contentInvalid    )( /*[out, retval]*/ VARIANT_BOOL *pVal   );
    STDMETHOD(put_contentInvalid    )( /*[in         ]*/ VARIANT_BOOL  newVal );
    STDMETHOD(get_layoutIndex       )( /*[out, retval]*/ long         *pVal   );

    STDMETHOD(get_isCurrentlyVisible)( /*[out, retval]*/ VARIANT_BOOL *pVal   );


    STDMETHOD(moveto)( VARIANT lX, VARIANT lY, VARIANT lWidth, VARIANT lHeight );

    STDMETHOD(restrictHeight)( VARIANT lMin, VARIANT lMax, VARIANT varMarker );
    STDMETHOD(restrictWidth )( VARIANT lMin, VARIANT lMax, VARIANT varMarker );

    STDMETHOD(canResize)( long lDX, long lDY, VARIANT_BOOL *pVal );

    STDMETHOD(navigate)( VARIANT varTarget, VARIANT varForceLoad );
    STDMETHOD(refresh )();

    STDMETHOD(activate)();
    STDMETHOD(insertBefore)( VARIANT varInsertBefore );

    STDMETHOD(execMshtml)( DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut );

    ////////////////////////////////////////////////////////////////////////////////

    // IServiceProvider methods
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IHlinkFrame
    STDMETHODIMP GetBrowseContext(IHlinkBrowseContext **ppihlbc)
        { return E_NOTIMPL; }
    STDMETHODIMP OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved)
        { return E_NOTIMPL; }
    STDMETHODIMP UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName)
        { return E_NOTIMPL; }
    STDMETHODIMP SetBrowseContext(IHlinkBrowseContext *pihlbc)
        { return E_NOTIMPL; }
    STDMETHODIMP Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate);

    // IInternetSecurityManager
    STDMETHODIMP        SetSecuritySite(IInternetSecurityMgrSite *pSite);
    STDMETHODIMP        GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    STDMETHODIMP        MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    STDMETHODIMP        GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId,
                                      DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    STDMETHODIMP        ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy,
                                         DWORD cbPolicy, BYTE *pContext, DWORD cbContext,
                                         DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP        QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy,
                                          DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext,
                                          DWORD dwReserved);
    STDMETHODIMP        SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    STDMETHODIMP        GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

    //  IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd)
        { return E_NOTIMPL; }
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    //  IOleInPlaceSite
    STDMETHODIMP CanInPlaceActivate()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP OnInPlaceActivate()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP OnUIActivate();

    STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame,
                                  IOleInPlaceUIWindow **ppDoc,
                                  LPRECT lprcPosRect,
                                  LPRECT lprcClipRect,
                                  LPOLEINPLACEFRAMEINFO lpFrameInfo)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP Scroll(SIZE scrollExtant)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP OnUIDeactivate(BOOL fUndoable)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP OnInPlaceDeactivate()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP DiscardUndoState()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP DeactivateAndUndo()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP OnPosRectChange(LPCRECT lprcPosRect)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    // IOleControlSite
    STDMETHODIMP OnControlInfoChanged()
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP LockInPlaceActive(BOOL fLock)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP TranslateAccelerator(MSG *pMsg,DWORD grfModifiers);

    STDMETHODIMP OnFocus(BOOL fGotFocus)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    STDMETHODIMP ShowPropertyFrame(void)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    // IPropertyNotifySink methods
    STDMETHODIMP OnChanged(DISPID dispID);
    STDMETHODIMP OnRequestEdit(DISPID dispID)
        { ATLASSERT(FALSE); return E_NOTIMPL; }

    // IOleInPlaceUIWindow
    STDMETHOD(GetBorder)(LPRECT /*lprectBorder*/)
    {
        return S_OK;
    }

    STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
    {
        return INPLACE_E_NOTOOLSPACE;
    }

    STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS /*pborderwidths*/)
    {
        return S_OK;
    }

    STDMETHOD(SetActiveObject)(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR /*pszObjName*/)
    {
        m_spActiveObject = pActiveObject;
        return S_OK;
    }

    static HRESULT GetFromUnknown(IUnknown *punk, CMarsPanel **ppMarsPanel)
    {
        return IUnknown_QueryService(punk, SID_SMarsPanel, CLASS_CMarsPanel, (void **)ppMarsPanel);
    }

    HRESULT OnDocHostUIExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                            VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

protected:
    HRESULT CreateControl();
    HRESULT CreateControlObject();
    HRESULT GetRect(RECT *prcClient, RECT *prcMyClient);
    VOID  ConnectCompletionAdviser();
    VOID  DisconnectCompletionAdviser();
    VOID  ComputeDimensionsOfContent(long *plWidth, long *plHeight);
    void  MakeVisible(VARIANT_BOOL bVisible, VARIANT_BOOL bForce);
    void  OnLayoutChange();
    void  GetMyClientRectInParentCoords(RECT *prc);

    class CBrowserEvents :  public CMarsPanelSubObject,
                            public IDispatch
    {
        friend CMarsPanel;
        CBrowserEvents(CMarsPanel *pParent);
        ~CBrowserEvents() {}

        HRESULT DoPassivate() { return S_OK; }

        DWORD m_dwCookie;
        DWORD m_dwCookie2;

    public:
        void Connect(IUnknown *punk, BOOL bConnect);

        // IUnknown
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
        {
            *pctinfo = 0;
            return E_NOTIMPL;
        }

        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
        {
            *pptinfo = NULL;
            return E_NOTIMPL;
        }

        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
        {
            return E_NOTIMPL;
        }

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr);
    };

protected:
    friend class CBrowserEvents;

    CMarsAxWindow                    m_Content;      // Content in this panel
    CBrowserEvents                   m_BrowserEvents;
    CMarsExternal                    m_MarsExternal;
    CComBSTR                         m_bstrName;

    // Active object within this doc
    CComPtr<IOleInPlaceActiveObject> m_spActiveObject;

    CComClassPtr<CPanelCollection>   m_spPanelCollection;    // Parent collection
    CComClassPtr<CMarsDocument>      m_spMarsDocument;       // Parent document

    CComBSTR                         m_bstrStartUrl;    // Used until control is created

    PANEL_POSITION                   m_Position;
    long                             m_lWidth;      // Used for "left", "right", or "popup"
    long                             m_lHeight;     // Used for "top", "bottom", or "popup"
    long                             m_lX;          // Used for "popup"
    long                             m_lY;          // Used for "popup"
    DWORD                            m_dwFlags;     // PANEL_FLAG_*
    long                             m_lMinWidth;   // size constraints
    long                             m_lMaxWidth;   // ""
    long                             m_lMinHeight;  // ""
    long                             m_lMaxHeight;  // ""
    DWORD                            m_dwCookie;    // Cookie for mshtml sink for resize events

    long                             m_lReadyState; // READYSTATE_*

    BOOL                             m_fControlCreated : 1; // Has control been created?

    BOOL                             m_fVisible        : 1; // Should we be visible?
    BOOL                             m_fPresentInPlace : 1; // Were we in the previous place?
    BOOL                             m_fTabCycle       : 1;
    BOOL                             m_fInRefresh      : 1; // Are we the one calling Trident to refresh?
    BOOL                             m_fContentInvalid : 1; // Does this panel need updating after a theme switch?

    CComPtr<IBrowserService>         m_spBrowserService;
};

typedef CMarsSimpleArray<CComClassPtr<CMarsPanel> > CPanelArray;
typedef MarsIDispatchImpl<IMarsPanelCollection, &IID_IMarsPanelCollection> IMarsPanelCollectionImpl;

class CPanelCollection :
            public CPanelArray,
            public CMarsComObject,
            public IMarsPanelCollectionImpl
{
    friend CMarsDocument;
    CPanelCollection(CMarsDocument *pMarsDocument);

    HRESULT DoPassivate();

protected:
    virtual ~CPanelCollection();

public:
    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IDispatch
    IMPLEMENT_IDISPATCH_DELEGATE_TO_BASE(IMarsPanelCollectionImpl);

    // IMarsPanelCollection
    STDMETHOD(get_panel)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ IMarsPanel **ppPanel);
    STDMETHOD(addPanel)(/*[in]*/ BSTR bstrName, /*[in]*/ VARIANT varType, /*[in]*/ BSTR bstrStartUrl, /*[in]*/ VARIANT varCreate, /*[in]*/ long lFlags, /*[out, retval]*/ IMarsPanel **ppPanel);
    STDMETHOD(removePanel)(/*[in]*/ BSTR bstrName);
    STDMETHOD(lockLayout)();
    STDMETHOD(unlockLayout)();
    STDMETHOD(get_activePanel)(/*out, retval*/ IMarsPanel **ppPanel);

    // IMarsPanelCollection standard collection methods
    STDMETHOD(get_length)(/*[out, retval]*/ LONG *plNumPanels);
    STDMETHOD(get_item)(/*[in]*/ VARIANT varIndexOrName, /*[out, retval]*/ IMarsPanel **ppPanel);
    STDMETHOD(get__newEnum)(/*[out, retval]*/ IUnknown **ppEnumPanels);

    HRESULT DoEnableModeless(BOOL fEnable);

    void        Layout();
    BOOL        IsLayoutLocked() { return (m_iLockLayout != 0); }

    void        SetActivePanel(CMarsPanel *pPanel, BOOL bActive);
    CMarsPanel *ActivePanel() { return m_spActivePanel; }

    CMarsDocument *Document() { return m_spMarsDocument; }

    HRESULT         AddPanel( MarsAppDef_Panel* pLayout, /*optional*/ IMarsPanel **ppPanel);
    void            FreePanels();

    CMarsPanel     *FindPanel(LPCWSTR pwszName);
    HRESULT         FindPanelIndex(CMarsPanel *pPanel, long *plIndex);
    HRESULT         InsertPanelFromTo(long lOldIndex, long lNewIndex);

    void InvalidatePanels();
    void RefreshInvalidVisiblePanels();
protected:
    CComClassPtr<CMarsDocument>     m_spMarsDocument;

    CComClassPtr<CMarsPanel>        m_spActivePanel;

    int     m_iLockLayout;              // Is our panel layout temporarily locked (refcount)?
    BOOL    m_fPendingLayout : 1;       // Do we have pending layouts because of lock?
};

#endif // __PANEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\pandef.h ===
#pragma once

//********************************************************************************
// MAKE NOTE:
// =========
//   This file is included by parser\comptree
//   If you modify this file, please make sure that parser\comptree still builds.
//
//   You have been warned.
//********************************************************************************

#define XML_FILE_FORMAT_CURRENT_VERSION 0x3

const CHAR g_szMMFCookie[] = "PCH_MMF";
#define MMF_FILE_COOKIELEN ARRAYSIZE(g_szMMFCookie)

typedef enum
{
    PANEL_LEFT,
    PANEL_RIGHT,
    PANEL_TOP,
    PANEL_BOTTOM,
    PANEL_WINDOW,
    PANEL_POPUP,
    PANEL_INVALID = -1
}
PANEL_POSITION;

const int PANEL_FLAG_VISIBLE       = 0x00000001; // Do we start out visible?
const int PANEL_FLAG_WEBBROWSER    = 0x00000002; // Do we host shdocvw?
const int PANEL_FLAG_ONDEMAND      = 0x00000004; // We wait for first vis to show?
const int PANEL_FLAG_TRUSTED       = 0x00000008; // Is this a trusted panel?
const int PANEL_FLAG_AUTOPERSIST   = 0x00000010; // Does this panel persist in the travel log?
const int PANEL_FLAG_AUTOSIZE      = 0x00000020; // Should this panel autosize?

const int PANEL_FLAG_CUSTOMCONTROL = 0x00001000; // Are we a "marsdoc" panel?

const int PANEL_FLAG_ALL           = 0x0000103f; // All the above flags.  Used for validation.

const int DEFAULT_PANEL_FLAGS      = PANEL_FLAG_ONDEMAND;    // default flags

const int PANEL_NAME_MAXLEN  = 63;
const int PANEL_NAME_MAXSIZE = PANEL_NAME_MAXLEN + 1;

typedef enum
{
    PANEL_PERSIST_VISIBLE_NEVER    , // When transitioning to a place, always show the place panel.
    PANEL_PERSIST_VISIBLE_DONTTOUCH, // If the place was in the previous place, don't touch its state.
    PANEL_PERSIST_VISIBLE_ALWAYS   , // Restore the persisted state every time the place is reached.
} PANEL_PERSIST_VISIBLE;

////////////////////////////////////////////////////////////////////////////////

struct MarsAppDef_PlacePanel
{
    WCHAR  				  szName[PANEL_NAME_MAXSIZE];
    BOOL   				  fDefaultFocusPanel;
    BOOL   				  fStartVisible; // only used when persistence is not "NEVER"
    PANEL_PERSIST_VISIBLE persistVisible;

    MarsAppDef_PlacePanel()
	{
		::ZeroMemory( szName, sizeof( szName ) );

		fDefaultFocusPanel = FALSE;
		fStartVisible      = TRUE;
		persistVisible     = PANEL_PERSIST_VISIBLE_NEVER;
	}
};


struct MarsAppDef_Place
{
    WCHAR  szName[PANEL_NAME_MAXSIZE];
    DWORD  dwPlacePanelCount;

    MarsAppDef_Place()
	{
		::ZeroMemory( szName, sizeof( szName ) );

		dwPlacePanelCount = 0;
	}
};

struct MarsAppDef_Places
{
    DWORD dwPlacesCount;

    MarsAppDef_Places()
	{
		dwPlacesCount = 0;
	}
};


struct MarsAppDef_Panel
{
    WCHAR           szName[PANEL_NAME_MAXSIZE];
    WCHAR           szUrl [MAX_PATH          ];
    PANEL_POSITION  Position;
    long            lWidth;    // Used for "left", "right", or "popup"
    long            lWidthMax;
    long            lWidthMin;
    long            lHeight;   // Used for "top", "bottom", or "popup"
    long            lHeightMax;
    long            lHeightMin;
    long            lX;         // Used for "popup"
    long            lY;         // Used for "popup"
    DWORD           dwFlags;    // PANEL_FLAG_*

	MarsAppDef_Panel()
	{
		::ZeroMemory( szName, sizeof( szName ) );
		::ZeroMemory( szUrl , sizeof( szUrl  ) );

		Position  	=  PANEL_TOP;
		lWidth      =  0;
		lWidthMax   = -1;
		lWidthMin   = -1;
		lHeight     =  0;
		lHeightMax  = -1;
		lHeightMin  = -1;
		lX          =  0;
		lY          =  0;
		dwFlags     =  DEFAULT_PANEL_FLAGS;
	}
};


struct MarsAppDef_Panels
{
    DWORD dwPanelsCount;

    MarsAppDef_Panels()
	{
		dwPanelsCount = 0;
	}
};

struct MarsAppDef
{
    DWORD dwVersion;
    BOOL  fTitleBar;

    MarsAppDef()
	{
		dwVersion     = XML_FILE_FORMAT_CURRENT_VERSION;
		fTitleBar     = TRUE;
	}
};

////////////////////////////////////////////////////////////////////////////////

struct tagPositionMap
{
    LPCWSTR         pwszName;
    PANEL_POSITION  Position;
};

extern const struct tagPositionMap s_PositionMap[];

extern const int c_iPositionMapSize;

HRESULT StringToPanelPosition(LPCWSTR pwszPosition, PANEL_POSITION *pPosition);
void StringToPanelFlags(LPCWSTR pwsz, DWORD &dwFlags, long lLen =-1);
void StringToPersistVisibility(LPCWSTR pwsz, PANEL_PERSIST_VISIBLE &persistVis);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\place.h ===
#ifndef __PLACE_H
#define __PLACE_H

class CPlaceCollection;
class CMarsWindow;
class CMarsDocument;
class CMarsPanel;

#include "pandef.h"


class CPlacePanel
{
protected:
    CComBSTR              m_bstrName;
    PANEL_PERSIST_VISIBLE m_PersistVisible;
    BOOL                  m_fWasVisible;

public:
    CPlacePanel( MarsAppDef_PlacePanel* pp );

    VARIANT_BOOL ShowOnTransition( CMarsPanel *pPanel );

    void SaveLayout( class CMarsPanel* pPanel );

    CComBSTR &GetName() { return m_bstrName; }
};

typedef CSimpleArray<CPlacePanel *> CPlacePanelArray;

class CPlacePanelCollection : public CPlacePanelArray
{
public:
    ~CPlacePanelCollection();
};



class CMarsPlace :
    public CMarsComObject,
    public MarsIDispatchImpl<IMarsPlace, &IID_IMarsPlace>
{
    friend CPlaceCollection;
    CMarsPlace(CPlaceCollection *pParent, CMarsDocument *pMarsDocument);

    HRESULT     DoPassivate();

protected:
    virtual ~CMarsPlace() {}

public:
    HRESULT Init(LPCWSTR pwszName);

    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IMarsPlace
    STDMETHODIMP get_name(/* out, retval */ BSTR *pbstrName);
    STDMETHODIMP transitionTo();
    
    HRESULT     TranslateAccelerator(MSG *pMsg);

    BSTR        GetName() { return m_bstrName; }
    HRESULT     DoTransition();

    HRESULT AddPanel(CPlacePanel *pPlacePanel);
    void SaveLayout(void);

protected:
    CComClassPtr<CPlaceCollection>  m_spPlaceCollection;
    CComClassPtr<CMarsDocument>     m_spMarsDocument;
    CComBSTR                        m_bstrName;

    // Each place has a set of panels that it would like to be visible
    CPlacePanelCollection           m_PlacePanels;
};

typedef CSimpleArray<CMarsPlace *> CMarsPlaceArray;
typedef MarsIDispatchImpl<IMarsPlaceCollection, &IID_IMarsPlaceCollection> IMarsPlaceCollectionImpl;

class CPlaceCollection :
        public    CMarsComObject,
        public    IMarsPlaceCollectionImpl,
        protected CMarsPlaceArray
{
    friend CMarsDocument;

    CPlaceCollection( CMarsDocument *pMarsDocument );
    
    HRESULT     DoPassivate();

protected:
    virtual ~CPlaceCollection() { ATLASSERT(GetSize() == 0); }

public:
    // IUnknown
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    // IDispatch
    IMPLEMENT_IDISPATCH_DELEGATE_TO_BASE(IMarsPlaceCollectionImpl);
    
    // IMarsPlaceCollection
    STDMETHODIMP place(/* in */ BSTR bstrName, /* out, retval */ IMarsPlace **ppMarsPlace);
    STDMETHODIMP get_currentPlace(/* out, retval */ IMarsPlace **ppMarsPlace);
    STDMETHODIMP transitionTo(/* in */ BSTR bstrName);

    CMarsDocument   *Document() { ATLASSERT(m_spMarsDocument); return m_spMarsDocument; }
    
    HRESULT AddPlace(LPCWSTR pwszName, CMarsPlace **ppPlace);
    void    FreePlaces();

    HRESULT GetPlace(LPCWSTR pwszName, /*optional*/ CMarsPlace **ppPlace);
    HRESULT FindPlaceIndex(LPCWSTR pwszName, long *plIndex);

    void OnPanelReady();

    CMarsPlace *GetCurrentPlace() { return (m_lCurrentPlaceIndex != -1) ? (*this)[m_lCurrentPlaceIndex] : NULL; }

protected:
    CComClassPtr<CMarsDocument> m_spMarsDocument;

    long        				m_lCurrentPlaceIndex;
    long        				m_lOldPlaceIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\precomp.h ===
//
// Mars precompiled header file.
//
//     Only include files that don't change often or are include by most
//     project files.
//

#pragma warning(disable: 4100)  // unreferenced formal parameter


#define _ATL_APARTMENT_THREADED
#define _NO_SYS_GUID_OPERATOR_EQ_

#include <windows.h> 

//#include <marsleak.h>

// Set some debug wrappers before we load atlbase.h to allow use of atl trace flags
#ifdef _DEBUG

extern DWORD g_dwAtlTraceFlags;
#define ATL_TRACE_CATEGORY g_dwAtlTraceFlags

// In _DEBUG mode atlbase.h uses _vsn?printf which we remap to wvnsprintf?
// Atlbase.h will also pull in stdio.h.  We must remap these functions
// after stdio.h has been loaded.
//
// Why? You ask?  Cuz we're not too inclined to pull in the C runtime library.
// It's good enough for everyone but us.
//
//  - The Faroukmaster (1999)
//

#include <stdio.h>
#define _vsnprintf wvnsprintfA
#define _vsnwprintf wvnsprintfW

#endif //_DEBUG

#define wcscmp StrCmpW          //  For CComBSTR

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>
#include <atlctl.h>
#include <marsdev.h>


#include <shlguid.h>
#include <shlwapip.h>

#include <mshtml.h>
#include <mshtmdid.h>
#include <hlink.h>
#include <wininet.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <htiframe.h> // IID_ITargetFrame2
#include <msident.h>

//
//  Taken from windowsx.h -- can't include windowsx.h since ATL won't compile
//
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))


// Flavors of refresh taken from mshtml\src\core\include\privcid.h

#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\place.cpp ===
#include "precomp.h"
#include "mcinc.h"
#include "marswin.h"
#include "panel.h"
#include "place.h"

////static void DebugLog( LPCWSTR szMessageFmt ,
////							  ...          )
////{
////	const int BUFFER_LINE_LENGTH = 512;
////	WCHAR   rgLine[BUFFER_LINE_LENGTH+1];
////	va_list arglist;
////	int     iLen;
////	BOOL    bRetVal = TRUE;
////
////
////	//
////	// Format the log line.
////	//
////	va_start( arglist, szMessageFmt );
////	iLen = _vsnwprintf( rgLine, BUFFER_LINE_LENGTH, szMessageFmt, arglist );
////	va_end( arglist );
////
////	//
////	// Is the arglist too big for us?
////	//
////	if(iLen < 0)
////	{
////		iLen = BUFFER_LINE_LENGTH;
////	}
////	rgLine[iLen] = 0;
////
////	::OutputDebugStringW( rgLine );
////}


//==================================================================
// CPlacePanelCollection 
//==================================================================

CPlacePanelCollection::~CPlacePanelCollection()
{
    for (int i=0; i<GetSize(); i++)
    {
        delete (*this)[i];
    }
}

//==================================================================
// CPlacePanel
//==================================================================

CPlacePanel::CPlacePanel( MarsAppDef_PlacePanel* pp) :
  m_bstrName(pp->szName), 
  m_fWasVisible(pp->fStartVisible),
  m_PersistVisible(pp->persistVisible) 
{ 
}

VARIANT_BOOL CPlacePanel::ShowOnTransition(CMarsPanel *pPanel)
{
    VARIANT_BOOL bResult;

	switch(m_PersistVisible)
	{
	case PANEL_PERSIST_VISIBLE_DONTTOUCH:
		if(pPanel->WasInPreviousPlace())
		{
			bResult = pPanel->IsVisible();
			break;
		}

	case PANEL_PERSIST_VISIBLE_ALWAYS:
        bResult = m_fWasVisible ? VARIANT_TRUE : VARIANT_FALSE; 
		break;

	default:
        bResult = VARIANT_TRUE;
		break;
    }

    return bResult;
}

void CPlacePanel::SaveLayout(CMarsPanel *pPanel)
{
    m_fWasVisible = pPanel->IsVisible();
}


//==================================================================
// CMarsPlace 
//==================================================================

CMarsPlace::CMarsPlace(CPlaceCollection *pParent, CMarsDocument *pMarsDocument)
{
    m_spPlaceCollection = pParent;
    m_spMarsDocument = pMarsDocument;
}

HRESULT CMarsPlace::DoPassivate()
{
    m_spPlaceCollection.Release();
    m_spMarsDocument.Release();

    return S_OK;
}

HRESULT CMarsPlace::Init(LPCWSTR pwszName)
{
    m_bstrName = pwszName;

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CMarsPlace);

STDMETHODIMP CMarsPlace::QueryInterface(REFIID iid, void ** ppvObject)
{
    HRESULT hr;

    if(API_IsValidWritePtr(ppvObject))
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;

        if((iid == IID_IMarsPlace) ||
		   (iid == IID_IDispatch ) ||
		   (iid == IID_IUnknown  )  )
        {
            *ppvObject = SAFECAST(this, IMarsPlace *);
        }

        if(*ppvObject)
        {
            hr = S_OK;
            AddRef();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

// IMarsPlace
STDMETHODIMP CMarsPlace::get_name(BSTR *pbstrName)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(pbstrName) && VerifyNotPassive(&hr))
    {
        hr = SUCCEEDED(m_bstrName.CopyTo(pbstrName)) ? S_OK : S_FALSE;
    }

    return hr;
}

STDMETHODIMP CMarsPlace::transitionTo()
{
	FAIL_AFTER_PASSIVATE();

    return m_spPlaceCollection->transitionTo(m_bstrName);
}

HRESULT CMarsPlace::DoTransition()
{
	FAIL_AFTER_PASSIVATE();
    
    CPanelCollection *pPanels = m_spMarsDocument->GetPanels();

	if(pPanels)
	{
		pPanels->lockLayout();

		//
		// For each panel in our window, show or hide it depending on if it is visible within our place.
		//
		for(int i=0; i<pPanels->GetSize(); i++)
		{
			CMarsPanel* pPanel = (*pPanels)[i];

			if(pPanel)
			{
				LPCWSTR      pwszName     = pPanel->GetName();
				VARIANT_BOOL bMakeVisible = VARIANT_FALSE;

				for(int j=0; j<m_PlacePanels.GetSize(); j++)
				{
					CPlacePanel* pPlacePanel = m_PlacePanels[j];
				
					if(pPlacePanel && StrEqlW(pwszName, pPlacePanel->GetName()))
					{
						// Let the place panel decide whether it should be shown
						bMakeVisible = pPlacePanel->ShowOnTransition( pPanel );
						break;
					}
				}

				pPanel->put_visible( bMakeVisible );
			}
		}

		pPanels->unlockLayout();
	}

    return S_OK;
}

HRESULT CMarsPlace::AddPanel(CPlacePanel *pPlacePanel)
{
    ATLASSERT(!IsPassive());

    m_PlacePanels.Add(pPlacePanel);

    return S_OK;
}

static HRESULT local_TranslateFocusAccelerator(MSG *pMsg, CComPtr<IOleInPlaceActiveObject> pObj)
{
    // identify Ctrl-Tab and F6 keystrokes
    BOOL isKeydown = (pMsg && (pMsg->message == WM_KEYDOWN));
    BOOL isCtrlTab = (isKeydown && (pMsg->wParam == VK_TAB) && 
                        (::GetKeyState( VK_CONTROL ) & 0x8000));
    BOOL isF6 = (isKeydown && (pMsg->wParam == VK_F6));

    // map F6 and Ctrl-TAB to TAB for the Control in panel can set
    // focus to the first item
    HRESULT hr = S_FALSE;
    
    if (isF6 || isCtrlTab) 
    {
        BYTE bState[256];
        if (isCtrlTab) 
        {
            ::GetKeyboardState(bState);
            bState[VK_CONTROL] &= 0x7F;
            ::SetKeyboardState(bState);
        }
        
        pMsg->wParam = VK_TAB;
        hr = pObj->TranslateAccelerator(pMsg);

        if (isCtrlTab) 
        {
            bState[VK_CONTROL] |= 0x80;
            ::SetKeyboardState(bState);
        }
    }

    return hr;
}


HRESULT CMarsPlace::TranslateAccelerator(MSG *pMsg)
{
	FAIL_AFTER_PASSIVATE();

    HRESULT     hr           = S_FALSE;
    CMarsPanel *pActivePanel = m_spPlaceCollection->Document()->GetPanels()->ActivePanel();
    
    //  First give the active panel a shot.
    if(pActivePanel)
    {   
        pActivePanel->ResetTabCycle();
        
        hr = pActivePanel->TranslateAccelerator(pMsg);

        //  Trident will return S_OK but we may have decided
        //  we want it.  This happens when you tab past the last 
        //  focusable item on the page.
        if(pActivePanel->GetTabCycle())
        {
            pActivePanel->ResetTabCycle();

            hr = S_FALSE;
        }
    }

    if(S_OK != hr)
    {
        int i;
        int nCurrent = -1;
        int nPanels = m_PlacePanels.GetSize();

        ATLASSERT(nPanels > 0);

        if(pActivePanel)
        {
            for (i = 0; i < nPanels; i++)
            {
                if(StrEql(pActivePanel->GetName(), m_PlacePanels[i]->GetName()))
                {
                    nCurrent = i;
                    break;
                }
            }
        }
        else
        {
            //  This will force us to start at 0 in the for loop below
            nCurrent = nPanels;
        }

        CMarsPanel *pPanel;

        if(IsGlobalKeyMessage(pMsg))
        {
            //  Now give the rest of the panels a crack at it            
            for (i = 0; (i < nPanels) && (S_OK != hr); i++)
            {
                nCurrent++;
                
                if(nCurrent >= nPanels)
                {
                    nCurrent = 0;
                }
                
                pPanel = m_spMarsDocument->GetPanels()->FindPanel(m_PlacePanels[nCurrent]->GetName());

                if(pPanel != pActivePanel)
                {
                    hr = pPanel->TranslateAccelerator(pMsg);
                }
                else
                {
                    //  We're right back where we started
                    break;
                }
            }
        }
        else
        {
            int nTab = IsVK_TABCycler(pMsg);

            if(nTab)
            {
				int nCount = nPanels;
				
				if(pActivePanel)
				{
					nCurrent += nTab;
					if(nCurrent < 0)
					{
						nCurrent = nPanels - 1;
					}
					else if(nCurrent >= nPanels)
					{
						nCurrent = 0;
					}
				}
				else
				{
					//  If there is no active panel then let's tab to the first one
					nCurrent = 0;
				}

				while(nCount-- > 0)
				{
					pPanel = m_spMarsDocument->GetPanels()->FindPanel(m_PlacePanels[nCurrent]->GetName());
					if(pPanel && pPanel->IsVisible())
					{
						CComPtr<IOleInPlaceActiveObject> pObj;

						if(SUCCEEDED(pPanel->Window()->QueryControl( IID_IOleInPlaceActiveObject, (LPVOID*)&pObj )))
						{
							pPanel->ResetTabCycle();
							
							hr = pObj->TranslateAccelerator( pMsg );

							if(hr == S_FALSE)
							{
								//  The WebOC behaves a little differently -- go figure :)
								//  It seems to rely on getting the TranslateAccelerator call to do the 
								//  right UI activation the very first time.
								if(pPanel->IsWebBrowser())
								{
									pPanel->activate();
								
								    //  Fix up the hwnd so the panel will think it was intended for it.
									pMsg->hwnd = pPanel->Window()->m_hWnd;
									hr = pPanel->TranslateAccelerator(pMsg);
									if(hr == S_OK) 
									{
                                        local_TranslateFocusAccelerator(pMsg, pObj);
									    break;
									}

									//  REVIEW -- this happens when we tab into a panel with no place to
									//  tab to.  IOW, it has nothing which can take the focus so we might
									//  want to loop until we find someone who does.
									if(pPanel->GetTabCycle())
									{
										pPanel->ResetTabCycle();
									}
								}
							}
							else
							{
								if(pPanel->IsWebBrowser   () ||
								   pPanel->IsCustomControl()  )
								{
									break;
								}

								if(pPanel->GetTabCycle() == false)
								{
									break;
								}

                                pPanel->ResetTabCycle();
                                
								hr = local_TranslateFocusAccelerator(pMsg, pObj);
								
								if (hr == S_OK && pPanel->GetTabCycle() == false)
								{
								    break;
								}
							}
						}
					}

					nCurrent += nTab;
					if(nCurrent < 0)
					{
						nCurrent = nPanels - 1;
					}
					else if(nCurrent >= nPanels)
					{
						nCurrent = 0;
					}
				}

                if(pPanel && pPanel != pActivePanel)
                {
					m_spMarsDocument->GetPanels()->SetActivePanel( pPanel, TRUE );
                }

                hr = S_OK;
            }
        }
    }

    return hr;
}


void CMarsPlace::SaveLayout()
{
	if(IsPassive()) return;


	//
	// For each panel in our window, save the layout and flag if it's present in the current place.
	//
    CPanelCollection *pPanels = m_spMarsDocument->GetPanels();
	for(int i=0; i<pPanels->GetSize(); i++)
	{
		CMarsPanel* pPanel = (*pPanels)[i];

		if(pPanel)
		{
			LPCWSTR pwszName = pPanel->GetName();
			BOOL    fPresent = FALSE;

			for(int j=0; j<m_PlacePanels.GetSize(); j++)
			{
				CPlacePanel* pPlacePanel = m_PlacePanels[j];
				if(pPlacePanel && StrEqlW(pwszName, pPlacePanel->GetName()))
				{
					pPlacePanel->SaveLayout(pPanel);
					fPresent = TRUE;
					break;
				}
			}

			pPanel->SetPresenceInPlace( fPresent );
		}
	}
}

//==================================================================
//
// CPlaceCollection implementation
//
//==================================================================

CPlaceCollection::CPlaceCollection(CMarsDocument *pMarsDocument)
{
    m_spMarsDocument = pMarsDocument;
    m_lCurrentPlaceIndex = -1;
    m_lOldPlaceIndex = -1;
}

void CPlaceCollection::FreePlaces()
{
    for (int i=0; i<GetSize(); i++)
    {
        (*this)[i]->Passivate();
        (*this)[i]->Release();
    }

    RemoveAll();
}

HRESULT CPlaceCollection::DoPassivate()
{
    FreePlaces();

    m_spMarsDocument.Release();

    return S_OK;
}

IMPLEMENT_ADDREF_RELEASE(CPlaceCollection);

STDMETHODIMP CPlaceCollection::QueryInterface(REFIID iid, void ** ppvObject)
{
    HRESULT hr;

    if(API_IsValidWritePtr(ppvObject))
    {
        if((iid == IID_IUnknown            ) ||
           (iid == IID_IDispatch           ) ||
           (iid == IID_IMarsPlaceCollection)  )
        {
            AddRef();
            *ppvObject = SAFECAST(this, IMarsPlaceCollection *);
            hr = S_OK;
        }
        else
        {
            *ppvObject = NULL;
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

// IMarsPlaceCollection
STDMETHODIMP CPlaceCollection::place(LPWSTR pwszName, IMarsPlace **ppMarsPlace)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidString(pwszName) && API_IsValidWritePtr(ppMarsPlace))
    {
        *ppMarsPlace = NULL;

        if(VerifyNotPassive(&hr))
        {
            CMarsPlace *pPlace;

            if(SUCCEEDED(GetPlace(pwszName, &pPlace)))
            {
                (*ppMarsPlace) = SAFECAST(pPlace, IMarsPlace *);
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    return hr;
}

STDMETHODIMP CPlaceCollection::get_currentPlace(/* out, retval */ IMarsPlace **ppMarsPlace)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidWritePtr(ppMarsPlace))
    {
        *ppMarsPlace = NULL;
    
        if(VerifyNotPassive(&hr))
        {
            if(m_lCurrentPlaceIndex != -1)
            {
                CMarsPlace *pPlace = (*this)[m_lCurrentPlaceIndex];

                *ppMarsPlace = SAFECAST(pPlace, IMarsPlace *);
                pPlace->AddRef();
            }

            hr = (*ppMarsPlace) ? S_OK : S_FALSE;
        }
    }

    return hr;
}

void CPlaceCollection::OnPanelReady()
{
    //  First see if we need to bother with this
    if(m_lCurrentPlaceIndex != m_lOldPlaceIndex)
    {
        CPlacePanelCollection& PlacePanels = GetCurrentPlace()->m_PlacePanels;
        CPanelCollection*      pPanels     = m_spMarsDocument->GetPanels();

        int nPanels      = PlacePanels.GetSize();
        int nPanelsReady = 0;

        for(int i = 0; i < nPanels; i++)
        {
            CMarsPanel *pPanel = pPanels->FindPanel(PlacePanels[i]->GetName());
            
            if(pPanel && (!pPanel->IsTrusted() || (pPanel->GetReadyState()==READYSTATE_COMPLETE)))
            {
                nPanelsReady++;
            }
        }

        if(nPanelsReady >= nPanels)
        {
            if(m_lCurrentPlaceIndex != m_lOldPlaceIndex)
            {
                m_spMarsDocument->MarsWindow()->OnTransitionComplete();
                m_lOldPlaceIndex = m_lCurrentPlaceIndex;
            }
        }
    }
}

STDMETHODIMP CPlaceCollection::transitionTo(/* in */ BSTR bstrName)
{
    HRESULT hr = E_INVALIDARG;

    if(API_IsValidString(bstrName))
    {
        if(VerifyNotPassive())
        {
            hr = S_FALSE;

            long lNewPlaceIndex;

            if(SUCCEEDED(FindPlaceIndex(bstrName, &lNewPlaceIndex)))
            {
                if(m_lCurrentPlaceIndex != lNewPlaceIndex)
                {
                    if(m_lCurrentPlaceIndex >= 0)
                    {
                        GetCurrentPlace()->SaveLayout();
                    }

                    if(m_spMarsDocument->MarsWindow()->IsEventCancelled() == VARIANT_FALSE)
                    {
                        // Layout panels for new place
                        m_lCurrentPlaceIndex = lNewPlaceIndex;
                        (*this)[m_lCurrentPlaceIndex]->DoTransition();
                        OnPanelReady();                        
                    }
            
                    hr = S_OK;
                }

                m_spMarsDocument->MarsWindow()->NotifyHost( MARSHOST_ON_PLACE_TRANSITION_DONE, SAFECAST(GetCurrentPlace(), IMarsPlace *), 0 );
            }
        }
    }

    return hr;
}

HRESULT CPlaceCollection::FindPlaceIndex(LPCWSTR pwszName, long *plIndex)
{
    ATLASSERT(!IsPassive());
    
    int i;

    *plIndex = -1;

    for (i=0; i<GetSize(); i++)
    {
        if(pwszName == NULL || StrEqlW(pwszName, (*this)[i]->GetName()))
        {
            *plIndex = (long)i;

            return S_OK;
        }
    }

    return E_FAIL;
}

HRESULT CPlaceCollection::GetPlace(LPCWSTR pwszName, /*optional*/ CMarsPlace **ppPlace)
{
    ATLASSERT(!IsPassive());
    
    long lIndex;
    HRESULT hrRet;

    if(ppPlace)
    {
        *ppPlace = NULL;
    }
    
    if(SUCCEEDED(hrRet = FindPlaceIndex(pwszName, &lIndex)))
    {
        if(ppPlace)
        {
            *ppPlace = (*this)[lIndex];
            (*ppPlace)->AddRef();
        }
    }

    return hrRet;
}

// Called by our XML parser only
HRESULT CPlaceCollection::AddPlace(LPCWSTR pwszName, CMarsPlace **ppPlace)
{
    *ppPlace = NULL;

    HRESULT hr = S_OK;

    if(VerifyNotPassive(&hr))
    {
        if(SUCCEEDED(GetPlace(pwszName, NULL)))
        {
            // Place of this name already exists
            return E_FAIL;
        }

        CMarsPlace *pPlace = new CMarsPlace(this, m_spMarsDocument);

        if(pPlace)
        {
            if(Add(pPlace))
            {
                pPlace->Init(pwszName);
                pPlace->AddRef();
                *ppPlace = pPlace;
            }
            else
            {
                pPlace->Release();
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\profsvc.cpp ===
#include "precomp.h"
#include "mcinc.h"

#include <profsvc.h>

typedef struct
{
    IServiceProvider *psp;
    GUID guidService;
    DWORD dwCookie;
} SERVICE_ITEM;

#define _Item(i)    (_hdsa ? (SERVICE_ITEM *)DSA_GetItemPtr(_hdsa, i) : NULL)
#define _Count()    (_hdsa ? DSA_GetItemCount(_hdsa) : 0)

IProfferServiceImpl::~IProfferServiceImpl()
{
    for(int i = 0; i<_Count(); i++)
    {
		SERVICE_ITEM *psi = _Item( i );
		if(psi)
		{
			IUnknown_Set((IUnknown **)&psi->psp, NULL);
		}
    }

    DSA_Destroy(_hdsa);
}

HRESULT IProfferServiceImpl::ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie)
{
    HRESULT hr;

    if (!_hdsa)
        _hdsa = DSA_Create(sizeof(SERVICE_ITEM), 4);

    SERVICE_ITEM si;
    
    si.psp = psp;
    si.guidService = rguidService;
    si.dwCookie = ++_dwNextCookie;  // start at 1

    if (_hdsa && (-1 != DSA_AppendItem(_hdsa, &si)))
    {
        psp->AddRef();
        *pdwCookie = si.dwCookie;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT IProfferServiceImpl::RevokeService(DWORD dwCookie)
{
    HRESULT hr = E_INVALIDARG;  // not found

    for(int i = 0; i<_Count(); i++)
    {
		SERVICE_ITEM *psi = _Item( i );
		if(psi)
		{
			if(psi->dwCookie == dwCookie)
			{
				IUnknown_Set((IUnknown **)&psi->psp, NULL);
				DSA_DeleteItem(_hdsa, i);
				hr = S_OK;  // successful revoke
				break;
			}
		}
    }

    return hr;
}

HRESULT IProfferServiceImpl::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;    // did not find the service object

    *ppv = NULL;

    for(int i = 0; i<_Count(); i++)
    {
		SERVICE_ITEM *psi = _Item( i );
		if(psi)
		{
			if(IsEqualGUID(psi->guidService, guidService))
			{
				hr = psi->psp->QueryService(guidService, riid, ppv);
				break;
			}
		}
    }
    return hr;
}

#if 0
// trident implementation
 
HRESULT CProfferService::ProfferService(REFGUID rguidService, IServiceProvider * pSP, DWORD * pdwCookie)
{
    HRESULT hr;
    CProfferServiceItem *pItem = new CProfferServiceItem(rguidService, pSP);
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(_aryItems.Append(pItem));
    if (hr)
        goto Cleanup;

    if (!pdwCookie)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pdwCookie = _aryItems.Size() - 1;

Cleanup:
    RRETURN (hr);
}

HRESULT CProfferService::RevokeService(DWORD dwCookie)
{
    if ((DWORD)_aryItems.Size() <= dwCookie)
    {
        RRETURN (E_INVALIDARG);
    }

    delete _aryItems[dwCookie];
    _aryItems[dwCookie] = NULL;

    RRETURN (S_OK);
}

HRESULT CProfferService::QueryService(REFGUID rguidService, REFIID riid, void ** ppv)
{
    for (int i = 0, int c = _aryItems.Size(); i < c; i++)
    {
        CProfferServiceItem *pItem = _aryItems[i];
        if (pItem && IsEqualGUID(pItem->_guidService, rguidService))
        {
            RRETURN (pItem->_pSP->QueryService(rguidService, riid, ppv));
        }
    }

    RRETURN (E_NOTIMPL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\profsvc.h ===
#ifndef _PROFSVC_H_
#define _PROFSVC_H_

class IProfferServiceImpl : public IProfferService
{
public:
    // IProfferService
    STDMETHODIMP ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie);
    STDMETHODIMP RevokeService(DWORD dwCookie);

    // delegate unrecognized QS's here
    HRESULT QueryService(REFGUID guidService, REFIID riid, void **ppv);

protected:
    ~IProfferServiceImpl();

    HDSA _hdsa;             // list of services held
    DWORD _dwNextCookie;    // unique cookie index
};

#endif  // _PROFSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\makefile.inc ===
# this looks like a -*-Makefile-*-

# welcome, sports fans
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by marscore.rc
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\util.cpp ===
#include "precomp.h"
#include "mcinc.h"
#include "util.h"
#include "intshcut.h"
#include "optary.h"

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
#undef COMPILE_MULTIMON_STUBS

BOOL IsSysKeyMessage(MSG *pMsg)
{
    switch(pMsg->message)
    {
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP  :
	case WM_SYSCHAR   :
		if(pMsg->wParam == VK_MENU) break; // Alt key alone.

		if(pMsg->wParam >= L'0'       && pMsg->wParam <= L'9'      ) break; // ALT+<digit> should pass through.
		if(pMsg->wParam >= VK_NUMPAD0 && pMsg->wParam <= VK_NUMPAD9) break; // ALT+<numpad> should pass through.


	case WM_SYSDEADCHAR:
		return TRUE;
	}

    return FALSE;
}

BOOL IsGlobalKeyMessage(MSG *pMsg)
{
    BOOL fRet = IsSysKeyMessage( pMsg );

    if(!fRet)
    {
        switch(pMsg->message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
            // Allow ESC and CTRL-E as well...
            fRet = ((pMsg->wParam == VK_ESCAPE                                 ) ||
                    (pMsg->wParam == L'E' && GetAsyncKeyState( VK_CONTROL ) < 0)  );
        }
    }

    return fRet;
}

int IsVK_TABCycler(MSG *pMsg)
{  
    int result;
    
    if (pMsg && 
        (pMsg->message == WM_KEYDOWN) &&
        ((pMsg->wParam == VK_TAB) || (pMsg->wParam == VK_F6)))
    {
        result = (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;
    }
    else
    {
        result = 0;
    }

    return result;
}

DWORD CThreadData::s_dwTlsIndex = 0xffffffff;

CThreadData::CThreadData()
{
}

CThreadData::~CThreadData()
{
}


BOOL CThreadData::TlsSetValue(CThreadData *ptd)
{
    ATLASSERT(s_dwTlsIndex != 0xffffffff);

    //  Don't call set twice except to clear
    ATLASSERT((NULL == ptd) || (NULL == ::TlsGetValue(s_dwTlsIndex))); 

    return ::TlsSetValue(s_dwTlsIndex, ptd);
}

BOOL CThreadData::HaveData()
{
    ATLASSERT(s_dwTlsIndex != 0xffffffff);

    return NULL != ::TlsGetValue(s_dwTlsIndex);
}

CThreadData *CThreadData::TlsGetValue()
{
    ATLASSERT(s_dwTlsIndex != 0xffffffff);

    CThreadData *ptd = (CThreadData *)::TlsGetValue(s_dwTlsIndex);

    ATLASSERT(NULL != ptd);
    
    return ptd;
}

BOOL CThreadData::TlsAlloc()
{
    ATLASSERT(s_dwTlsIndex == 0xffffffff);   //  Don't call this twice

    s_dwTlsIndex = ::TlsAlloc();

    return (s_dwTlsIndex != 0xffffffff) ? TRUE : FALSE;
}

BOOL CThreadData::TlsFree()
{
    BOOL bResult;
    
    if (s_dwTlsIndex != 0xffffffff)
    {
        bResult = ::TlsFree(s_dwTlsIndex);
        s_dwTlsIndex = 0xffffffff;
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

HRESULT GetMarsTypeLib(ITypeLib **ppTypeLib)
{
    ATLASSERT(NULL != ppTypeLib);
    
    CThreadData *pThreadData = CThreadData::TlsGetValue();

    if (!pThreadData->m_spTypeLib)
    {
        // Load our typelib, to be used for our automation interfaces
        WCHAR wszModule[_MAX_PATH+10];
        GetModuleFileNameW(_Module.GetModuleInstance(), wszModule, _MAX_PATH);
        LoadTypeLib(wszModule, &pThreadData->m_spTypeLib);
    }

    pThreadData->m_spTypeLib.CopyTo(ppTypeLib);

    return ((NULL != ppTypeLib) && (NULL != *ppTypeLib)) ? S_OK : E_FAIL;
}


UINT HashKey(LPCWSTR pwszName)
{
    int hash = 0;

    while (*pwszName)
    {
        hash += (hash << 5) + *pwszName++;
    }
    return hash;
}


void AsciiToLower(LPWSTR pwsz)
{
    while (*pwsz)
    {
        if ((*pwsz >= L'A') && (*pwsz <= L'Z'))
        {
            *pwsz += L'a' - L'A';
        }
        pwsz++;
    }
}

HRESULT PIDLToVariant(LPCITEMIDLIST pidl, CComVariant& v)
{
    // the variant must be empty since we don't clear or initialize it

    HRESULT hr = S_OK;

    // NULL pidls are valid, so we just leave the variant empty and return S_OK
    if (pidl)
    {
        v.bstrVal = SysAllocStringLen(NULL, MAX_PATH);
        if (v.bstrVal)
        {
            // make this an official BSTR since the alloc succeeded
            v.vt = VT_BSTR;

            if (!SHGetPathFromIDListW(pidl, v.bstrVal))
            {
                // CComVariant will handle cleanup
                hr = E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//   Checks if global state is offline
BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    HANDLE  hModuleHandle = LoadLibraryA("wininet.dll");

    if (!hModuleHandle)
    {
        return FALSE;
    }

    if (InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if (fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    }
    else
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

HRESULT
_WriteDIBToFile(HBITMAP hDib, HANDLE hFile)
{
    if (!hDib)
    {
        return E_INVALIDARG;
    }

    // Make sure this is a valid DIB and get this useful info.
    DIBSECTION ds;
    if (!GetObject( hDib, sizeof(DIBSECTION), &ds ))
    {
        return E_INVALIDARG;
    }

    // We only deal with DIBs
    if (ds.dsBm.bmPlanes != 1)
    {
        return E_INVALIDARG;
    }

    // Calculate some color table sizes
    int nColors = ds.dsBmih.biBitCount <= 8 ? 1 << ds.dsBmih.biBitCount : 0;
    int nBitfields = ds.dsBmih.biCompression == BI_BITFIELDS ? 3 : 0;

    // Calculate the data size
    int nImageDataSize = ds.dsBmih.biSizeImage ? ds.dsBmih.biSizeImage : ds.dsBm.bmWidthBytes * ds.dsBm.bmHeight;

    // Get the color table (if needed)
    RGBQUAD rgbqaColorTable[256] = {0};
    if (nColors)
    {
        HDC hDC = CreateCompatibleDC(NULL);
        if (hDC)
        {
            HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hDC,hDib));
            GetDIBColorTable( hDC, 0, nColors, rgbqaColorTable );
            SelectObject(hDC,hOldBitmap);
            DeleteDC( hDC );
        }
    }

    // Create the file header
    BITMAPFILEHEADER bmfh;
    bmfh.bfType = 'MB';
    bmfh.bfSize = 0;
    bmfh.bfReserved1 = 0;
    bmfh.bfReserved2 = 0;
    bmfh.bfOffBits = sizeof(bmfh) + sizeof(ds.dsBmih) + nBitfields*sizeof(DWORD) + nColors*sizeof(RGBQUAD);

    // Start writing!  Note that we write out the bitfields and the color table.  Only one,
    // at most, will actually result in data being written
    DWORD dwBytesWritten;
    if (!WriteFile( hFile, &bmfh, sizeof(bmfh), &dwBytesWritten, NULL ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (!WriteFile( hFile, &ds.dsBmih, sizeof(ds.dsBmih), &dwBytesWritten, NULL ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (!WriteFile( hFile, &ds.dsBitfields, nBitfields*sizeof(DWORD), &dwBytesWritten, NULL ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (!WriteFile( hFile, rgbqaColorTable, nColors*sizeof(RGBQUAD), &dwBytesWritten, NULL ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (!WriteFile( hFile, ds.dsBm.bmBits, nImageDataSize, &dwBytesWritten, NULL ))
        return HRESULT_FROM_WIN32(GetLastError());
    return S_OK;
}

HRESULT SaveDIBToFile(HBITMAP hbm, WCHAR *pszPath)
{
    HRESULT hr = E_INVALIDARG;

    if (hbm != NULL &&
        hbm != INVALID_HANDLE_VALUE)
    {
        HANDLE hFile;

        hr = E_FAIL;

        hFile = CreateFileWrapW(pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        
        if (hFile != INVALID_HANDLE_VALUE)
        {
            hr = _WriteDIBToFile(hbm, hFile);

            CloseHandle(hFile);
        }
    }

    return hr;
}


// BoundWindowRect will nudge a rectangle so that it stays fully on its current monitor. 
// pRect must be in workspace coordinates

void BoundWindowRectToMonitor(HWND hwnd, RECT *pRect)
{
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);

    OffsetRect(&mi.rcWork, 
        mi.rcMonitor.left - mi.rcWork.left,
        mi.rcMonitor.top - mi.rcWork.top);

    LONG lDeltaX = 0, lDeltaY = 0;

    if (pRect->left < mi.rcWork.left)
        lDeltaX = mi.rcWork.left - pRect->left;

    if (pRect->top < mi.rcWork.top)
        lDeltaY = mi.rcWork.top - pRect->top;

    if (pRect->right > mi.rcWork.right)
        lDeltaX = mi.rcWork.right - pRect->right;

    if (pRect->bottom > mi.rcWork.bottom)
        lDeltaY = mi.rcWork.bottom - pRect->bottom;

    RECT rc = *pRect; 
    OffsetRect(&rc, lDeltaX, lDeltaY);
    IntersectRect(pRect, &rc, &mi.rcWork);
}



// Moves a rectangle down and to the right, by the same amount Windows would use 
// to cascade.  If the new position is partially off-screen, then the rect is either 
// moved up to the top, or back to the origin.

void CascadeWindowRectOnMonitor(HWND hwnd, RECT *pRect)
{
    int delta = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYSIZEFRAME) - 1;
    OffsetRect(pRect, delta, delta);
    
    // test if the new rect will end up getting moved later on
    RECT rc = *pRect;
    BoundWindowRectToMonitor(hwnd, &rc);

    if (!EqualRect(pRect, &rc))
    {
        // rc had to be moved, so we'll restart the cascade using the best monitor
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);

        if (rc.bottom < pRect->bottom && rc.left == pRect->left)
        {
            // Too tall to cascade further down, but we can keep the X and just
            // reset the Y.  This fixes the bug of having a tall windows piling up
            // on the top left corner -- instead they will be offset to the right
            OffsetRect(pRect, 0, mi.rcMonitor.top - pRect->top);   
        }
        else
        {
            // we've really run out of room, so restart cascade at top left
            OffsetRect(pRect, 
                mi.rcMonitor.left - pRect->left,
                mi.rcMonitor.top - pRect->top);
        }
    }
}

struct WINDOWSEARCHSTRUCT
{
    LONG x;
    LONG y;
    ATOM atomClass;
    BOOL fFoundWindow;
};

BOOL CALLBACK EnumWindowSearchProc(HWND hwnd, LPARAM lParam)
{
    WINDOWSEARCHSTRUCT *pSearch = (WINDOWSEARCHSTRUCT *) lParam;
    
    if ((ATOM) GetClassLong(hwnd, GCW_ATOM) == pSearch->atomClass)
    {
        // Only check the rest if we find a window that matches our class

        WINDOWPLACEMENT wp;
        wp.length = sizeof(wp);
        GetWindowPlacement(hwnd, &wp);

        pSearch->fFoundWindow = 
            pSearch->x == wp.rcNormalPosition.left &&
            pSearch->y == wp.rcNormalPosition.top &&
            IsWindowVisible(hwnd);
    }
 
    // return TRUE if we want to continue the enumeration
    return !pSearch->fFoundWindow;
}


// Checks whether there is a window of the same class at some location on screen.  
// x and y are in workspace coords because we need to use GetWindowPlacement to
// retrieve the rect of the restored window. 


BOOL IsWindowOverlayed(HWND hwndMatch, LONG x, LONG y)
{
    WINDOWSEARCHSTRUCT search = { x, y, (ATOM) GetClassLong(hwndMatch, GCW_ATOM), FALSE };
    EnumWindows(EnumWindowSearchProc, (LPARAM) &search);
    return search.fFoundWindow;
}



BOOL CInterfaceMarshal::Init()
{
    m_hresMarshal = E_FAIL;
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    return m_hEvent != NULL;
}


CInterfaceMarshal::~CInterfaceMarshal()
{
    if (m_hEvent)
        CloseHandle(m_hEvent);

    SAFERELEASE2(m_pStream);
}   


HRESULT CInterfaceMarshal::Marshal(REFIID riid, IUnknown *pUnk)
{
    ATLASSERT(pUnk);

    m_hresMarshal = CoMarshalInterThreadInterfaceInStream(riid, pUnk, &m_pStream);

    // We must signal the other thread regardless of whether the marshal was 
    // successful, otherwise it will be blocked for a very long time.

    Signal();
    
    return m_hresMarshal;
}


HRESULT CInterfaceMarshal::UnMarshal(REFIID riid, void ** ppv)
{
    HRESULT hr;
    ATLASSERT(ppv);

    if (S_OK == m_hresMarshal)
    {
        hr = CoGetInterfaceAndReleaseStream(m_pStream, riid, ppv);
        m_pStream = NULL;
    }
    else
    {
        hr = m_hresMarshal;
    }

    return hr;
}

void CInterfaceMarshal::Signal()
{
    ATLASSERT(m_hEvent);
    SetEvent(m_hEvent);
}


// This waiting code was copied from Shdocvw iedisp.cpp
//
// hSignallingThread is the handle of the thread that will be setting the m_hEvent.
// If that thread terminates before marshalling an interface, we can detect this 
// condition and not hang around pointlessly.

HRESULT CInterfaceMarshal::WaitForSignal(HANDLE hSignallingThread, DWORD dwSecondsTimeout)
{
    ATLASSERT(m_hEvent);

    HANDLE ah[]     = { m_hEvent, hSignallingThread };
    DWORD dwStart   = GetTickCount();
    DWORD dwMaxWait = 1000 * dwSecondsTimeout;
    DWORD dwWait    = dwMaxWait;
    DWORD dwWaitResult;

    do {
        // dwWait is the number of millseconds we still need to wait for

        dwWaitResult = MsgWaitForMultipleObjects(
            ARRAYSIZE(ah), ah, FALSE, dwWait, QS_SENDMESSAGE);

        if (dwWaitResult == WAIT_OBJECT_0 + ARRAYSIZE(ah)) 
        {
            // Msg input.  We allow the pending SendMessage() to go through
            MSG msg;
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
        }
        else
        {
            // signaled or timed out, so we exit the loop
            break;  
        }
        
        // Update dwWait. It will become larger than dwMaxWait if we 
        // wait more than that

        dwWait = dwStart + dwMaxWait - GetTickCount();

    } while (dwWait <= dwMaxWait);


    HRESULT hr = E_FAIL;

    switch (dwWaitResult)
    {
        case WAIT_OBJECT_0: 
            // Event signaled -- this is what should happen every time
            hr = m_hresMarshal;
            break;

        case WAIT_OBJECT_0 + 1:
            // Thread terminated before signalling
            break;

        case WAIT_OBJECT_0 + ARRAYSIZE(ah): // msg input -- fall through
        case WAIT_TIMEOUT:
            // Timed out while waiting for signal
            break;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////



HRESULT MarsNavigateShortcut(IUnknown *pBrowser, IUniformResourceLocator* pUrl, LPCWSTR pszPath)
{
    HRESULT hr;

    if (pBrowser )
    {
        CComPtr<IMoniker> spMkUrl;
        CComPtr<IBindCtx> spBindCtx;

        // Create moniker
        LPWSTR pszURL = NULL;
        hr = pUrl->GetURL(&pszURL);

        if (pszURL)
        {
            hr = CreateURLMoniker(NULL, pszURL, &spMkUrl);
            SHFree(pszURL);
        }

        if (SUCCEEDED(hr) && spMkUrl)
        {
            // create bind context and register load options
            // NOTE: errors here are not fatal, as the bind context is optional, so hr is not set
            CreateBindCtx(0, &spBindCtx);
            if (spBindCtx)
            {
                CComPtr<IHtmlLoadOptions> spLoadOpt;
                if (SUCCEEDED(CoCreateInstance(CLSID_HTMLLoadOptions, NULL, CLSCTX_INPROC_SERVER,
                    IID_IHtmlLoadOptions, (void**)&spLoadOpt)))
                {
                    if (pszPath)
                    {
                        spLoadOpt->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH, (void*)pszPath, 
                            (lstrlen(pszPath) + 1) * sizeof(WCHAR));
                    }

                    spBindCtx->RegisterObjectParam(L"__HTMLLOADOPTIONS", spLoadOpt);
                }
            }

            // create hyperlink using URL moniker
            CComPtr<IHlink> spHlink;
            hr = HlinkCreateFromMoniker(spMkUrl, NULL, NULL, NULL, 0, NULL, IID_IHlink, (void **)&spHlink);
            if (spHlink)
            {
                // navigate frame using hyperlink and bind context
                CComQIPtr<IHlinkFrame> spFrame(pBrowser);
                if (spFrame)
                {
                    hr = spFrame->Navigate(0, spBindCtx, NULL, spHlink);
                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
    }
    else
    {
        // L"MarsNavigateShortcut: target or path is NULL";
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT MarsNavigateShortcut(IUnknown *pBrowser, LPCWSTR lpszPath)
{
    HRESULT hr;

    if (pBrowser && lpszPath)
    {
        // create internet shortcut object
        CComPtr<IPersistFile> spPersistFile;
        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
            IID_IPersistFile, (void **)&spPersistFile);
        if (SUCCEEDED(hr))
        {
            // persist from file
            hr = spPersistFile->Load(lpszPath, STGM_READ);
            if (SUCCEEDED(hr))
            {
                CComQIPtr<IUniformResourceLocator, &IID_IUniformResourceLocator> spURL(spPersistFile);
                if (spURL)
                {
                    hr = MarsNavigateShortcut(pBrowser, spURL, lpszPath);

                }
                else
                {
                    hr = E_NOINTERFACE;
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT MarsVariantToPath(VARIANT &varItem, CComBSTR &strPath)
{
    HRESULT hr = E_INVALIDARG;

    if (API_IsValidVariant(varItem))
    {
        switch (varItem.vt)
        {
        case VT_EMPTY:
        case VT_NULL:
        case VT_ERROR:
            // return path empty when undefined, null, or omitted
            strPath.Empty();
            hr = S_OK;
            break;

        case VT_BSTR:
            // make a copy of the supplied path
            strPath = varItem.bstrVal;
            hr = S_OK;
            break;

        case VT_DISPATCH:
            {
                // query for FolderItem interface
                CComQIPtr<FolderItem> spFolderItem(varItem.pdispVal);

                // if we don't have a FolderItem, try to get one
                if (!spFolderItem)
                {
                    // if we got a Folder2 object instead of a FolderItem object
                    CComQIPtr<Folder2> spFolder2(varItem.pdispVal);
                    if (spFolder2)
                    {
                        // get FolderItem object from Folder2 interface
                        spFolder2->get_Self(&spFolderItem);
                    }
                }

                // if we managed to get a folder item
                if (spFolderItem)
                {
                    // get the path from it
                    CComBSTR bstr;
                    hr = spFolderItem->get_Path(&bstr);
                    strPath = bstr;
                }
            }
            break;
        }
    }

    return hr;
}

BOOL PathIsURLFileW(LPCWSTR lpszPath)
{
    BOOL fDoesMatch = FALSE;

    if (lpszPath)
    {
        LPCWSTR lpszExt = PathFindExtensionW(lpszPath);
        if (lpszExt && (StrCmpIW(lpszExt, L".url") == 0))
        {
            fDoesMatch = TRUE;
        }
    }

    return fDoesMatch;
}

////////////////////////////////////////////////////////////////////////////////

#define GLOBAL_SETTINGS_PATH L"Software\\Microsoft\\PCHealth\\Global"

//==================================================================
// Registry helpers
//==================================================================

LONG CRegistryKey::QueryLongValue(LONG& lValue, LPCWSTR pwszValueName)
{
    DWORD dwValue;
    LONG lResult = QueryValue(dwValue, pwszValueName);

    if (lResult == ERROR_SUCCESS)
    {
        lValue = (LONG) dwValue;
    }
    return lResult;
}

LONG CRegistryKey::SetLongValue(LONG lValue, LPCWSTR pwszValueName)
{
    return SetValue((DWORD) lValue, pwszValueName);
}

LONG CRegistryKey::QueryBoolValue(BOOL& bValue, LPCWSTR pwszValueName)
{
    DWORD dwValue;
    LONG lResult = QueryValue(dwValue, pwszValueName);

    if (lResult == ERROR_SUCCESS)
    {
        bValue = (BOOL) dwValue;
    }
    return lResult;
}

LONG CRegistryKey::SetBoolValue(BOOL bValue, LPCWSTR pwszValueName)
{
    return SetValue((DWORD) bValue, pwszValueName);
}

LONG CRegistryKey::QueryBinaryValue(LPVOID pData, DWORD cbData, LPCWSTR pwszValueName)
{
    DWORD dwType;
    DWORD lResult = RegQueryValueEx(m_hKey, pwszValueName, NULL, &dwType, (BYTE *) pData, &cbData);
    
    return (lResult == ERROR_SUCCESS) && (dwType != REG_BINARY) ? ERROR_INVALID_DATA : lResult;
}

LONG CRegistryKey::SetBinaryValue(LPVOID pData, DWORD cbData, LPCWSTR pwszValueName)
{
    return RegSetValueEx(m_hKey, pwszValueName, NULL, REG_BINARY, (BYTE *) pData, cbData);
}



LONG CGlobalSettingsRegKey::CreateGlobalSubkey(LPCWSTR pwszSubkey)
{
    CComBSTR strPath = GLOBAL_SETTINGS_PATH;
    
    if (pwszSubkey)
    {
        strPath += L"\\";
        strPath += pwszSubkey;
    }

    return Create(HKEY_CURRENT_USER, strPath);    
}


LONG CGlobalSettingsRegKey::OpenGlobalSubkey(LPCWSTR pwszSubkey)
{
    CComBSTR strPath = GLOBAL_SETTINGS_PATH;
    
    if (pwszSubkey)
    {
        strPath += L"\\";
        strPath += pwszSubkey;
    }

    return Open(HKEY_CURRENT_USER, strPath);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\util.h ===
#ifndef __UTIL_H
#define __UTIL_H

#define FT2LL(x) (((LONGLONG)((x).dwLowDateTime)) | (((LONGLONG)((x).dwHighDateTime))<<32))

UINT HashKey(LPCWSTR pwszName);

BOOL IsSysKeyMessage   (MSG *pMsg); // Is this message an ALT key?
BOOL IsGlobalKeyMessage(MSG *pMsg); // Is this message a key message that we want to handle globally?
int  IsVK_TABCycler    (MSG *pMsg);

inline BSTR VariantToBSTR(VARIANT &v) { return (v.vt == VT_BSTR) ? v.bstrVal : NULL; }
inline long VariantToI4(VARIANT &v) { return (v.vt == VT_I4) ? v.lVal : 0; }

void SetExceptionInfo(EXCEPINFO *pexcepinfo, WORD wCode);

void AsciiToLower(LPWSTR pwsz);

#define MAX_URL_STRING INTERNET_MAX_URL_LENGTH

#define DEFINE_BEHAVIOR_CREATE_INSTANCE(cls) \
static HRESULT CreateInstance(IElementBehavior **ppBehavior) \
{ \
    HRESULT hr = E_OUTOFMEMORY; \
    \
    cls * pB = new cls(); \
    if(pB) \
    { \
        hr = pB->QueryInterface( \
            IID_IElementBehavior, (void **) ppBehavior); \
        pB->Release(); \
    } \
    return hr; \
}

typedef struct _SA_BSTR
{
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

typedef HRESULT (STDMETHODCALLTYPE *PFNCREATEFACTORY)(IClassFactory **ppClassFactory);

struct CThreadData
{
    CThreadData();
    ~CThreadData();

    CComPtr<ITypeLib> m_spTypeLib;
    DWORD             m_dwProxyFactory;

    static DWORD        s_dwTlsIndex;
    static BOOL         TlsSetValue(CThreadData *ptd);
    static CThreadData *TlsGetValue();
    static BOOL 		HaveData();
    static BOOL 		TlsAlloc();
    static BOOL 		TlsFree();
};

HRESULT PIDLToVariant(LPCITEMIDLIST pidl, CComVariant& v);

BOOL IsGlobalOffline(void);
void SetGlobalOffline(BOOL fOffline);

HRESULT SaveDIBToFile(HBITMAP hbm, WCHAR * pszPath);

void BoundWindowRectToMonitor(HWND hwnd, RECT *pRect);
void CascadeWindowRectOnMonitor(HWND hwnd, RECT *pRect);
BOOL IsWindowOverlayed(HWND hwndMatch, LONG x, LONG y);


class CInterfaceMarshal
{
public:
    ~CInterfaceMarshal();   
    
    BOOL Init(void);
    HRESULT Marshal(REFIID riid, IUnknown *pUnk);
    HRESULT UnMarshal(REFIID riid, void ** ppv);
    HRESULT WaitForSignal(HANDLE hSignallingThread, DWORD dwSecondsTimeout);

protected:
    HANDLE m_hEvent;     
    IStream *m_pStream;
    HRESULT m_hresMarshal;

    void Signal(void);
};

////////////////////////////////////////////////////////////////////////////////

interface IUniformResourceLocatorW;

HRESULT MarsNavigateShortcut(IUnknown *pBrowser, IUniformResourceLocatorW* pUrl, LPCWSTR pszPath);
HRESULT MarsNavigateShortcut(IUnknown *pTarget, LPCWSTR lpszPath);
HRESULT MarsVariantToPath(VARIANT &varItem, CComBSTR &strPath);

BOOL PathIsURLFileW(LPCWSTR lpszPath);

////////////////////////////////////////////////////////////////////////////////

class CRegistryKey : public CRegKey
{
public:
    LONG SetLongValue(LONG lValue, LPCWSTR pwszValueName);
    LONG QueryLongValue(LONG& lValue, LPCWSTR pwszValueName);

    LONG SetBoolValue(BOOL bValue, LPCWSTR pwszValueName);
    LONG QueryBoolValue(BOOL& bValue, LPCWSTR pwszValueName);

    LONG SetBinaryValue(LPVOID pData, DWORD cbData, LPCWSTR pwszValueName);
    LONG QueryBinaryValue(LPVOID pData, DWORD cbData, LPCWSTR pwszValueName);
};


// GlobalSettingsRegKey lets you get a key to store miscellaneous data. 
// For example, CreateGlobalSubkey("MyOptions") might create the key 
// HKCU\Software\Microsoft\PCHealth\Global\MyOptions

class CGlobalSettingsRegKey : public CRegistryKey
{
public:
    LONG CreateGlobalSubkey(LPCWSTR pwszSubkey);
    LONG OpenGlobalSubkey(LPCWSTR pwszSubkey);
};

////////////////////////////////////////////////////////////////////////////////

#endif //__UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\panel_common.cpp ===
#include "pch.h"
#include "comptree.h"

#include "panel_common.h"

// all of the implementation is here:
#include "..\pandef.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\panel_common.h ===
#pragma once

#include "..\pandef.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\comptree.cpp ===
#include "pch.h"
#include "comptree.h"
#include "tagtab.h"

////////////////////////////////////////////////////////////////////////////////

HRESULT TraverseXMLDoc( const CComPtr<IXMLElement>& spxmlElt  ,
                        TagInformation*             pTagTable ,
                        const CTagHandler*          pthParent ,
                        CTagData&                   tdRoot    );

////////////////////////////////////////////////////////////////////////////////

// ((!pszTagName) || pszTagName == spxmlElt.parent.tagName) ? S_OK : S_FALSE
HRESULT TagNameMatchesParent( LPCWSTR                     pszTagName ,
                              const CComPtr<IXMLElement>& spxmlElt   )
{
    HRESULT hr = S_OK;

    if(pszTagName != NULL)
    {
        CComPtr<IXMLElement> spParent;

        hr = spxmlElt->get_parent( &spParent ); // S_FALSE if no parent

        ASSERT((hr != S_FALSE) || (!spParent));

        if(hr == S_OK)
        {
            CComBSTR bstrParentName;

            if(SUCCEEDED(hr = spParent->get_tagName( &bstrParentName )))
            {
                hr = (_wcsicmp( bstrParentName, pszTagName )) ? S_FALSE : S_OK;
            }
        }

    }

    return hr;
}

// looks up the tagName in pTagTable and calls the appropriate
//   CreateInstance function to create pTagHndlr
HRESULT VisitElement( const CComPtr<IXMLElement>& spxmlElt    ,
                      TagInformation *            pTagTable   ,
                      CTagHandler*&               pTagHandler )
{
    HRESULT  hr;
    CComBSTR bstrTagName;

    pTagHandler = NULL;

    if(SUCCEEDED(hr = spxmlElt->get_tagName( &bstrTagName )))
    {
        TagInformation* ptiElt;

        for(ptiElt = pTagTable; ptiElt->pszTagName; ++ptiElt)
        {
            if(!_wcsicmp( ptiElt->pszTagName, bstrTagName ))
            {
                if(SUCCEEDED(hr = TagNameMatchesParent( ptiElt->pszParent, spxmlElt )))
                {
                    if(hr == S_OK)
                    {
                        // call the CreateInstance function for the tag
                        pTagHandler = ptiElt->pfnTag();
                        break;
                    }
                    else
                    {
                        // these are not the droids you're looking for
                    }
                }
                else
                {
                    break;
                }
            }
        }
    }
    else if(hr == E_NOTIMPL) // this is a node without tag information (comment)
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT GetChild( const CComVariant&                    varChild ,
                  const CComPtr<IXMLElementCollection>& spcol    ,
                  CComPtr<IXMLElement>&                 spEltOut )
{
    HRESULT            hr;
    CComPtr<IDispatch> spDisp;
    CComVariant        varEmpty;


    hr = spcol->item( varChild, varEmpty, &spDisp );
    if(hr == S_OK)
    {
        hr = spDisp.QueryInterface( &spEltOut );
    }

    return hr;
}


//     return (spcol.item(lChildID));
// gets an IXMLElement from an IXMLElementCollection
HRESULT GetChild( LONG                                  lChildID ,
                  const CComPtr<IXMLElementCollection>& spcol    ,
                  CComPtr<IXMLElement>&                 spEltOut )
{
    CComVariant varItem( lChildID );

    return GetChild( varItem, spcol, spEltOut );
}

// for (obj in spxmlElt.children)
// {
//    phs = TraverseXMLDoc(obj);
//    pthVisitor->AddChild(obj, phs);
// }
HRESULT VisitChildren( const CComPtr<IXMLElement>& spxmlElt   ,
                       TagInformation*             pTagTable  ,
                       const CTagHandler*          pthParent  ,
                       CTagHandler*                pthVisitor )
{
    HRESULT                        hr;
    CComPtr<IXMLElementCollection> spcolChildren;

    if(SUCCEEDED(hr = spxmlElt->get_children( &spcolChildren )) && spcolChildren)
    {
        long lChildren;

        if(SUCCEEDED(hr = spcolChildren->get_length( &lChildren )))
        {
            for(long l = 0; l < lChildren; ++l)
            {
                CComPtr<IXMLElement> spxmlChild;

                if(SUCCEEDED(hr = GetChild( l, spcolChildren, spxmlChild )))
                {
                    CTagData td;

                    hr = TraverseXMLDoc( spxmlChild, pTagTable, pthVisitor, td );
                    if(hr == S_OK)
                    {
                        hr = pthVisitor->AddChild( spxmlChild, td );
                    }
                }

                if(FAILED(hr)) break;
            }

            // convert return value from TraverseXMLDoc
            if(hr == S_FALSE) hr = S_OK;
        }
    }

    return hr;
}


// return S_FALSE when no element found
HRESULT TraverseXMLDoc( const CComPtr<IXMLElement>& spxmlElt  ,
                        TagInformation*             pTagTable ,
                        const CTagHandler*          pthParent , //TODO: Get rid of this parameter
                        CTagData&                   tdRoot    )
{
    HRESULT      hr;
    CTagHandler *pTagHandler;

    if(SUCCEEDED(hr = VisitElement( spxmlElt, pTagTable, pTagHandler )))
    {
        // skip children we have no TagHandler for
        if(pTagHandler)
        {
            if(SUCCEEDED(hr = pTagHandler->BeginChildren( spxmlElt )))
            {
                if(SUCCEEDED(hr = VisitChildren( spxmlElt, pTagTable, pthParent, pTagHandler )))
                {
                    hr = pTagHandler->EndChildren( tdRoot );

                    if(SUCCEEDED(hr)) hr = S_OK;
                }
            }
        }
        else
		{
            hr = S_FALSE;
		}
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

unsigned int WriteBlobToFileHandle( LPCWSTR pszFileName, int fh, const void *pvBlob, DWORD dwSize )
{
    unsigned int bytesWritten;

    if ((bytesWritten = _write(fh, pvBlob, dwSize)) != -1)
    {
        if (bytesWritten == dwSize)
        {
            // S_OK!!!
        }
        else
        {
            wprintf(L"%s File %s wasn't totally written: "
                    L"Are you out of disk space?\n", g_szErrorPrefix,
                    pszFileName);
            bytesWritten = (unsigned int)-1;
        }
    }
    else
    {
        ERRMSG(L"%s Cannot write to %s\n", pszFileName);
        bytesWritten = (unsigned int)-1;
    }

    return bytesWritten;
}


HRESULT WriteBlobToFile( LPCWSTR pszFileName, const char *pszCookie, void *pvBlob, DWORD dwSize, unsigned int &cbWritten )
{
    HRESULT hr = E_FAIL;

    cbWritten = 0;

    int          fh;
    unsigned int _cbWritten = 0;

    USES_CONVERSION;

    if ( (fh = _open(W2A(pszFileName), _O_RDWR | _O_CREAT | _O_TRUNC | _O_BINARY,
                     _S_IREAD | _S_IWRITE)) > 0)
    {

        if (pszCookie)
        {
            hr = ((_cbWritten =
                   WriteBlobToFileHandle(pszFileName, fh, pszCookie,
                                         lstrlenA(pszCookie) + 1)) == -1)
                    ? E_FAIL : S_OK;
        }

        unsigned int _cbWritten2;

        if (SUCCEEDED(hr))
        {
            hr = ((_cbWritten2 =
                   WriteBlobToFileHandle(pszFileName, fh, pvBlob, dwSize)) == -1)
                    ? E_FAIL : S_OK;

            cbWritten = _cbWritten + _cbWritten2;

        }
    }

    return hr;
}


HRESULT DoTraverse( const CComPtr<IXMLDocument>& spxmlDoc          ,
                    TagInformation*              pTagTable         ,
                    LPCWSTR                      pszOutputFileName )
{
    HRESULT              hr;
    CComPtr<IXMLElement> spxmlRoot;

    if(SUCCEEDED(hr = spxmlDoc->get_root( &spxmlRoot )))
    {
        CTagData tdRoot;

        hr = TraverseXMLDoc( spxmlRoot, pTagTable, NULL, tdRoot );

        ASSERT(tdRoot.pData && "No Root Data!!!");

        if(SUCCEEDED(hr))
        {
            if(hr == S_OK)
            {
                unsigned int cbWritten;

                hr = WriteBlobToFile( pszOutputFileName, g_szMMFCookie, tdRoot.pData, tdRoot.dwSize, cbWritten );

                if(SUCCEEDED(hr))
				{
                    STATUSMSG( L"Wrote %d bytes to %s.\n", cbWritten, pszOutputFileName );
				}
            }
        }
    }

    return hr;
}

HRESULT GetXMLDoc( const CComBSTR&        bstrUrl  ,
				   CComPtr<IXMLDocument>& spxmlDoc )
{
    HRESULT hr;

    if(SUCCEEDED(hr = spxmlDoc.CoCreateInstance( CLSID_XMLDocument )))
    {
        hr = spxmlDoc->put_URL( bstrUrl );
    }

    return hr;
}

HRESULT GetXMLDocFromFile( const CComBSTR&        bstrFileName ,
                           CComPtr<IXMLDocument>& spxmlDoc     )
{
    HRESULT hr;

    if(SUCCEEDED(hr = spxmlDoc.CoCreateInstance( CLSID_XMLDocument )))
    {
        CComPtr<IStream> spstm;

        if(SUCCEEDED(hr = SHCreateStreamOnFileW( bstrFileName, 0, &spstm )))
        {
            CComPtr<IPersistStream> sppsPersist;

            if(SUCCEEDED(hr = spxmlDoc.QueryInterface( &sppsPersist )))
            {
                hr = sppsPersist->Load( spstm );
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////

int usage(char *progName)
{
    printf("Usage: %s inputFileName outputFileName\n", progName);
    return 1;
}

int __cdecl main(int argc, char *argv[])
{
    int retCode = 0;

    CoInitialize(NULL);

    {
        CComPtr<IXMLDocument> spxmlDoc;

        USES_CONVERSION;

        if (argc == 3)
        {
            //if (SUCCEEDED(GetXMLDoc(A2W(argv[1]), spxmlDoc)))
            if (SUCCEEDED(GetXMLDocFromFile(A2W(argv[1]), spxmlDoc)))
            {
                if (FAILED(DoTraverse(spxmlDoc, g_rgMasterTagTable, A2W(argv[2]))))
                    retCode = 1;
            }
            else
            {
                ERRMSG(L"Failed to load FILE: %s\n", A2W(argv[1]));
            }
        }
        else
            retCode = usage(argv[0]);

        // this scope calls Release on spxmlDoc *before* CoUnitialize()
    }

    CoUninitialize();

    return retCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\comptree.h ===
#pragma once

#define STATUS
#ifdef STATUS
#define STATUSMSG wprintf
#else
#define STATUSMSG 1 ? (void)0 : (void)
#endif

#define ERRMSG wprintf(L"%s ", g_szErrorPrefix); wprintf

// always leave asserts on for internal tool
#define ASSERT(x) assert(x)


HRESULT GetChild(const CComVariant &varChild,
                 const CComPtr<IXMLElementCollection> &spcol,
                 CComPtr<IXMLElement> &spEltOut);

// this is so build.exe will filter and print our errors to the console
const WCHAR g_szErrorPrefix[] = L"comptree : fatal error -: ";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\pch.h ===
#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <msxml.h>
#include <string.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <malloc.h>
#include <assert.h>

#ifdef DEBUG
#ifdef  __cplusplus
extern "C" {
#endif

_CRTIMP void __cdecl _assert(void *, void *, unsigned);

#ifdef  __cplusplus
}
#endif
#ifdef assert
#undef assert
#endif
#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )
#endif

//extern CComModule _Module;

//#include <atlcom.h>
//#include <atlwin.h>
//#include <atlhost.h>
//#include <atlctl.h>


#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\dll\makefile.inc ===
..\marscore.rc : $(MARS_GEN)\marscore.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\dll\dload.c ===
#include <windows.h>
#include <delayimp.h>

////////////////////////////////////////////////////////////////////////////////

static VOID* WINAPI hook_NULL()
{
	SetLastError( ERROR_PROC_NOT_FOUND );

	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

FARPROC WINAPI PCHSHELL_DelayLoadFailureHook( UINT unReason, PDelayLoadInfo pDelayInfo )
{
	// HLINK.dll
	// SHELL32.dll
	// WININET.dll

	return (FARPROC)hook_NULL; // Also covers hook_ZERO and hook_FALSE.
}

// we assume DELAYLOAD_VERSION >= 0x0200
PfnDliHook __pfnDliFailureHook2 = PCHSHELL_DelayLoadFailureHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\tagtab.cpp ===
#include "pch.h"
#include "panel_common.h"
#include "comptree.h"
#include "tagtab.h"

#define ARRAYSIZE(x) (sizeof(x)/sizeof(*x))

BOOL TagNameEql(const WCHAR *pszTagName, const CComPtr<IXMLElement> &spElt)
{
    CComBSTR bstrTagName;

    spElt->get_tagName( &bstrTagName );

    return (!_wcsicmp( bstrTagName, pszTagName ));
}


////////////////////////////////////////////////////////////////////////////////
class CMars_App : public CTagHandler
{
protected:
    MarsAppDef m_MarsApp;
    CTagData   m_tdPanels;
    CTagData   m_tdPlaces;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::AddChild( spEltChild, tdChild ))) return hr;


        if(TagNameEql( L"PANELS", spEltChild ))
        {
            if(FAILED(hr = m_tdPanels.AppendData( tdChild ))) return hr;
        }
        else if(TagNameEql( L"PLACES", spEltChild ))
        {
            if(FAILED(hr = m_tdPlaces.AppendData( tdChild ))) return hr;
        }
        else
        {
            ERRMSG(L"Unrecognized TagName for Child of PANELS\n");

            return E_FAIL;
        }


        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

        // Title bar
        {
            CComVariant varTitleBar;

            if(FAILED(hr = GetAttribute( m_spElt, L"TitleBar", varTitleBar, VT_BOOL )))
            {
                ERRMSG(L"Bad TitleBar attribute\n");
                return hr;
            }
            if(hr == S_OK)
            {
                m_MarsApp.fTitleBar = (varTitleBar.boolVal == VARIANT_TRUE);
            }
        }

        if(FAILED(hr = td.AppendData( m_MarsApp  ))) return hr;
        if(FAILED(hr = td.AppendData( m_tdPanels ))) return hr;
        if(FAILED(hr = td.AppendData( m_tdPlaces ))) return hr;


        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CMars_App; }
};

class CPanels : public CTagHandler
{
protected:
    MarsAppDef_Panels m_Panels;
    CTagData          m_tdPanels;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        HRESULT hr = CTagHandler::BeginChildren(spElt);

        return hr;
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::AddChild( spEltChild, tdChild ))) return hr;

        if(!tdChild.pData) ASSERT(0 && "Bad Child for PANEL");

        if(TagNameEql( L"PANEL", spEltChild ))
        {
            m_Panels.dwPanelsCount++;

            if(FAILED(hr = m_tdPanels.AppendData( tdChild ))) return hr;
        }
        else
        {
            ERRMSG(L"Unrecognized child for PANEL\n"); ASSERT(0);
            return E_FAIL;
        }

        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

        if(FAILED(hr = td.AppendData( m_Panels   ))) return hr;
        if(FAILED(hr = td.AppendData( m_tdPanels ))) return hr;

        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CPanels; }
};

class CPanel : public CTagHandler
{
protected:
    MarsAppDef_Panel m_Layout;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::AddChild( spEltChild, tdChild ))) return hr;

        if(TagNameEql( L"LAYOUT", spEltChild ))
        {
            m_Layout = *(MarsAppDef_Panel*)tdChild.pData;
        }
        else
        {
            ERRMSG(L"Unrecognized Child\n");
            return E_FAIL;
        }

        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

		// Trusted
        {
            CComVariant varTrusted;

            if(FAILED(hr = GetAttribute( m_spElt, L"Trusted", varTrusted, VT_BOOL )))
            {
                ERRMSG(L"Bad Trusted attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                if(varTrusted.boolVal != VARIANT_FALSE) m_Layout.dwFlags |= PANEL_FLAG_TRUSTED;
            }
        }

		// AutoSize
        {
            CComVariant varAutoSize;

            if(FAILED(hr = GetAttribute( m_spElt, L"AutoSize", varAutoSize, VT_BOOL )))
            {
                ERRMSG(L"Bad AutoSize attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                if(varAutoSize.boolVal != VARIANT_FALSE) m_Layout.dwFlags |= PANEL_FLAG_AUTOSIZE;
            }
        }

		// AutoPersist
        {
            CComVariant varAutoPersist;

            if(FAILED(hr = GetAttribute( m_spElt, L"AutoPersist", varAutoPersist, VT_BOOL )))
            {
                ERRMSG(L"Bad AutoPersist attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                if(varAutoPersist.boolVal != VARIANT_FALSE) m_Layout.dwFlags |= PANEL_FLAG_AUTOPERSIST;
            }
        }

		// Create
        {
            CComBSTR bstrCreate;

            if(FAILED(hr = GetAttribute(m_spElt, L"Create", bstrCreate)))
            {
                return hr;
            }
            if(hr == S_OK)
            {
                StringToPanelFlags( bstrCreate, m_Layout.dwFlags );
            }
        }

		// PanelType
        {
            CComBSTR bstrPanelType;

            if(FAILED(hr = GetAttribute( m_spElt, L"PanelType", bstrPanelType )))
            {
                ERRMSG(L"Bad PanelType Attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                StringToPanelFlags( bstrPanelType, m_Layout.dwFlags );
            }
        }

		// Name
        {
            CComBSTR bstrName;

            if(FAILED(hr = GetChildData( m_spElt, L"NAME", bstrName )) || hr != S_OK)
            {
                ERRMSG(L"Panel without NAME");
                return E_FAIL;
            }
			wcsncpy( m_Layout.szName, bstrName, ARRAYSIZE(m_Layout.szName) );
        }

		// URL
        {
            CComBSTR bstrStartUrl;

            if(FAILED(hr = GetChildData( m_spElt, L"STARTURL", bstrStartUrl )) || hr != S_OK)
            {
                ERRMSG(L"StartUrl not specified");
                return E_FAIL;
            }
			wcsncpy( m_Layout.szUrl, bstrStartUrl, ARRAYSIZE(m_Layout.szUrl) );
        }


        if(FAILED(hr = td.AppendData( m_Layout ))) return hr;


        return hr;
    }

    static CTagHandler *CreateInstance() { return new CPanel; }
};

////////////////////////////////////////////////////////////////////////////////
////  <Layout>
////////////////////////////////////////////////////////////////////////////////
class CLayout : public CTagHandler
{
protected:
    MarsAppDef_Panel m_Layout;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        ASSERT(0 && "No legal children for LAYOUT tag");
        return S_OK;
    }

    HRESULT GetMinAndMax(const CComPtr<IXMLElement> &spElt, long &min, long &max)
    {
        CComVariant varMin;
        CComVariant varMax;
        HRESULT     hr;

		if(FAILED(hr = GetAttribute( spElt, L"MAX", varMax, VT_I4 ))) return hr;
		if(hr == S_OK) max = varMax.lVal;

		if(FAILED(hr = GetAttribute( spElt, L"MIN", varMin, VT_I4 ))) return hr;
		if(hr == S_OK) min = varMin.lVal;

        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

        if(FAILED(hr = GetLongChildData( m_spElt, L"HEIGHT", m_Layout.lHeight ))) return hr;
        if(FAILED(hr = GetLongChildData( m_spElt, L"WIDTH" , m_Layout.lWidth  ))) return hr;
        if(FAILED(hr = GetLongChildData( m_spElt, L"LEFT"  , m_Layout.lX      ))) return hr;
        if(FAILED(hr = GetLongChildData( m_spElt, L"TOP"   , m_Layout.lY      ))) return hr;

		m_Layout.lWidthMin = -1;
		m_Layout.lWidthMax = -1;

		m_Layout.lHeightMin = -1;
		m_Layout.lHeightMax = -1;

		// Height
        {
            CComPtr<IXMLElement> spHeight;

            if(FAILED(hr = GetChild( m_spElt, L"HEIGHT", spHeight ))) return hr;

			if(hr == S_OK)
			{
				if(FAILED(hr = GetMinAndMax( spHeight, m_Layout.lHeightMin, m_Layout.lHeightMax ))) return hr;
			}
		}

		// Width
		{
			CComPtr<IXMLElement> spWidth;

			if(FAILED(hr = GetChild( m_spElt, L"WIDTH", spWidth ))) return hr;

			if(hr == S_OK)
			{
				if(FAILED(hr = GetMinAndMax( spWidth, m_Layout.lWidthMin, m_Layout.lWidthMax ))) return hr;
			}
		}

		// Position
		{
			CComBSTR bstrPosition;

			if(FAILED(hr = GetChildData( m_spElt, L"POSITION", bstrPosition ))) return hr;

			if(hr == S_OK)
			{
				if(FAILED(hr = StringToPanelPosition(bstrPosition, &m_Layout.Position ))) return hr;
			}
		}


        if(FAILED(hr = td.AppendData( m_Layout ))) return hr;


        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CLayout; }
};

////////////////////////////////////////////////////////////////////////////////
class CPlaces : public CTagHandler
{
protected:
    MarsAppDef_Places m_Places;
    CTagData          m_tdPlaces;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::AddChild( spEltChild, tdChild ))) return hr;


		ASSERT(tdChild.pData && "NULL Child Not Acceptable");

		if(TagNameEql( L"PLACE", spEltChild ))
		{
			m_Places.dwPlacesCount++;

            if(FAILED(hr = m_tdPlaces.AppendData( tdChild ))) return hr;
		}
		else
		{
			ERRMSG(L"Unknown child for PLACES\n");
			return E_FAIL;
        }

        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;


        if(FAILED(hr = td.AppendData( m_Places   ))) return hr;
        if(FAILED(hr = td.AppendData( m_tdPlaces ))) return hr;


        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CPlaces; }
};

////////////////////////////////////////////////////////////////////////////////

class CPlace : public CTagHandler
{
protected:
    MarsAppDef_Place m_Place;
	CTagData         m_tdPlacePanel;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::AddChild( spEltChild, tdChild ))) return hr;

		ASSERT(tdChild.pData && "NULL Child Not Acceptable");

		if(TagNameEql( L"PLACEPANEL", spEltChild ))
		{
			m_Place.dwPlacePanelCount++;

            if(FAILED(hr = m_tdPlacePanel.AppendData( tdChild ))) return hr;
		}
		else
		{
			ERRMSG(L"Unrecognized child for PLACE\n");
			return E_FAIL;
        }

        return S_OK;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

        // Name
        {
            CComBSTR bstrPlaceName;

            if(GetChildData( m_spElt, L"NAME", bstrPlaceName ) != S_OK)
			{
                ERRMSG(L"'NAME' Child is not present -- place must have name.");
                return E_FAIL;
			}
			wcsncpy( m_Place.szName, bstrPlaceName, ARRAYSIZE(m_Place.szName) );
        }


        if(FAILED(hr = td.AppendData( m_Place        ))) return hr;
        if(FAILED(hr = td.AppendData( m_tdPlacePanel ))) return hr;


        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CPlace; }
};

////////////////////////////////////////////////////////////////////////////////

class CPlacePanel : public CTagHandler
{
protected:
    MarsAppDef_PlacePanel m_PlacePanel;

public:
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        return CTagHandler::BeginChildren( spElt );
    }

    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        ERRMSG(L"There are no legal children for <PlacePanel>");

        return E_FAIL;
    }

    virtual HRESULT EndChildren( CTagData& td )
    {
        HRESULT hr; if(FAILED(hr = CTagHandler::EndChildren( td ))) return hr;

        // Name
        {
            CComBSTR bstrName;

            if(GetChildData( m_spElt, L"NAME", bstrName ) != S_OK)
            {
                ERRMSG(L"'NAME' Child is not present -- placepanel must have name.");
                return E_FAIL;
            }
            wcsncpy( m_PlacePanel.szName, bstrName, ARRAYSIZE(m_PlacePanel.szName) );
        }

        // DefaultFocusPanel
        {
            CComVariant varDefaultFocusPanel;

            if(FAILED(hr = GetAttribute( m_spElt, L"DefaultFocusPanel", varDefaultFocusPanel, VT_BOOL )))
            {
                ERRMSG(L"Bad DefaultFocusPanel Attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                m_PlacePanel.fDefaultFocusPanel = (varDefaultFocusPanel.boolVal != VARIANT_FALSE);
            }
        }

        // StartVisible
        {
            CComVariant varStartVisible;

            if(FAILED(hr = GetAttribute( m_spElt, L"StartVisible", varStartVisible, VT_BOOL )))
            {
                ERRMSG(L"Bad StartVisible Attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                m_PlacePanel.fStartVisible = (varStartVisible.boolVal != VARIANT_FALSE);
            }
        }

        // PersistVisibility
        {
            CComBSTR bstrPersistVis;

            if(FAILED(hr = GetAttribute( m_spElt, L"PersistVisibility", bstrPersistVis )))
            {
                ERRMSG(L"Bad PersistVisibility Attribute");
                return hr;
            }
            if(hr == S_OK)
            {
                StringToPersistVisibility( bstrPersistVis, m_PlacePanel.persistVisible );
            }
        }


        if(FAILED(hr = td.AppendData( m_PlacePanel ))) return hr;


        return S_OK;
    }

    static CTagHandler *CreateInstance() { return new CPlacePanel; }
};


TagInformation g_rgMasterTagTable[] =
{//   Tag Name       Creator Function             Valid Parent Name (null means "any parent")
    { L"Mars_App",   CMars_App::CreateInstance,   NULL        },
    { L"Panels",     CPanels::CreateInstance,     L"Mars_App" },
    { L"Places",     CPlaces::CreateInstance,     L"Mars_App" },
    { L"Panel",      CPanel::CreateInstance,      L"Panels"   },
    { L"Place",      CPlace::CreateInstance,      L"Places"   },
    { L"PlacePanel", CPlacePanel::CreateInstance, L"Place"    },
    { L"Layout",     CLayout::CreateInstance,     L"Panel"    },
    { 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\comptree\tagtab.h ===
#pragma once

#include "panel_common.h"

#pragma warning( disable : 4100 34 )  

struct CTagData
{
    DWORD dwSize;
	BYTE* pData;

    CTagData()
	{
		dwSize = 0;
		pData  = NULL;
	}

	~CTagData()
	{
		if(pData) free( pData );
	}

	HRESULT AppendData( const LPVOID pvData, DWORD dwDataSize )
	{
		DWORD dwOldSize = dwSize;
		DWORD dwNewSize = dwOldSize + dwDataSize;
		BYTE* pDataNew  = (BYTE*)malloc( dwNewSize );

		if(pDataNew == NULL) return E_FAIL;

		if(pData)
		{
			memcpy( pDataNew, pData, dwOldSize ); free( pData );
		}
		
		memcpy( &pDataNew[dwOldSize], pvData, dwDataSize );

		dwSize = dwNewSize;
		pData  = pDataNew;

		return S_OK;
	}

	template <class T> HRESULT AppendData( T& data )
	{
		return AppendData( &data, sizeof(T) );
	}

	template <> HRESULT AppendData( CTagData& td )
	{
		return AppendData( td.pData, td.dwSize );
	}
};

class CTagHandler
{
protected:
    CComBSTR             m_spTagName;
    CComPtr<IXMLElement> m_spElt;

    static HRESULT GetChild( const CComPtr<IXMLElement>& spElt         ,
                             const CComBSTR&             bstrChildName ,
                             CComPtr<IXMLElement>&       spEltOut      )
    {
        HRESULT                        hr;
        CComPtr<IXMLElementCollection> spcolChildren;

        if(SUCCEEDED(hr = spElt->get_children( &spcolChildren )) && spcolChildren)
        {
            CComVariant varChild( bstrChildName );

            hr = ::GetChild( varChild, spcolChildren, spEltOut );
        }
        return hr;
    }

    static HRESULT GetChildData( const CComPtr<IXMLElement>& spElt         ,
                                 const CComBSTR&             bstrChildName ,
                                 CComBSTR&                   bstrChildData )
    {
        HRESULT              hr;
        CComPtr<IXMLElement> spChild;

        if(SUCCEEDED(hr = GetChild( spElt, bstrChildName, spChild )))
        {
            if(spChild)
            {
                hr = spChild->get_text( &bstrChildData );
            }
            else
            {
                bstrChildData.Empty();
                hr = S_FALSE;
            }
        }

        return hr;
    }

    static HRESULT GetChildData( const CComPtr<IXMLElement>& spElt         ,
                                 const CComBSTR& 			 bstrChildName ,
                                 CComVariant& 				 varChildData  ,
								 VARTYPE                     vt            )
    {
        HRESULT  hr;
        CComBSTR bstrData;

		hr = GetChildData( spElt, bstrChildName, bstrData );
        if(hr == S_OK)
        {
            varChildData = bstrData;

            hr = varChildData.ChangeType( vt );
        }

        return hr;
    }
    
    static HRESULT GetLongChildData( const CComPtr<IXMLElement>& spElt         ,
                                     const CComBSTR&             bstrChildName ,
									 long&                       l             )
    {
        HRESULT     hr;
        CComVariant varChild;

		hr = GetChildData( spElt, bstrChildName, varChild, VT_I4 );
        if(hr == S_OK)
        {
            l = varChild.lVal;
        }

        return hr;
    }

    static HRESULT GetAttribute( const CComPtr<IXMLElement>& spElt          ,
                                 const CComBSTR& 			 bstrAttribName ,
                                 CComVariant&    			 varVal         ,
								 VARTYPE                     vt = VT_BSTR   )
    {
        HRESULT hr;

		hr = spElt->getAttribute( bstrAttribName, &varVal );
        if(hr == S_OK)
        {
            hr = varVal.ChangeType( vt );
        }

        return hr;
    }

    static HRESULT GetAttribute( const CComPtr<IXMLElement>& spElt          ,
                                 const CComBSTR&             bstrAttribName ,
                                 CComBSTR&                   bstrVal        )
    {
        HRESULT     hr;
        CComVariant varVal;

		hr = GetAttribute( spElt, bstrAttribName, varVal, VT_BSTR );
        if(hr == S_OK)
        {
            bstrVal = varVal.bstrVal;
        }

        return hr;
    }
    
    
public:
    
    virtual HRESULT BeginChildren( const CComPtr<IXMLElement>& spElt )
    {
        HRESULT hr;

        m_spElt = spElt;
        
        hr = spElt->get_tagName( &m_spTagName );
        if(SUCCEEDED(hr))
        {
            //wprintf(L"BEGINCHILDREN: %s\n", m_spTagName);
        }

        return hr;
    }
    
    virtual HRESULT AddChild( const CComPtr<IXMLElement>& spEltChild, CTagData& tdChild )
    {
        HRESULT hr = S_OK;

        if(SUCCEEDED(hr))
        {
            // wprintf(L"ADDCHILD (to %s): %s\n", m_spTagName, spTagName);
        }        

        return hr;
    }
    
    virtual HRESULT EndChildren( CTagData& td )
    {
        //wprintf(L"ENDCHILDREN %s\n", m_spTagName);
        return S_OK;
    }
};

typedef CTagHandler *(*PfnCreatesATagHandler)();

struct TagInformation
{
    LPCWSTR               pszTagName;
    PfnCreatesATagHandler pfnTag;
    LPCWSTR               pszParent;

    /*
    TagInformation(const WCHAR           *pwszTagName,
                   PfnCreatesATagHandler  pfnTag,
                   TagInformation        *ptiChildren)
    {
        this->pwszTagName = pwszTagName;
        this->pfnTag      = pfnTag;
        this->ptiChildren = ptiChildren;
    }
    */
};

extern TagInformation g_rgMasterTagTable[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\marsload.cpp ===
// parser.cpp : Defines the entry point for the DLL application.

#include "precomp.h"
#include "..\mcinc.h"
#include "marsload.h"
#include "xmlparser.h"
#include "..\marswin.h"
#include "..\panel.h"
#include "..\place.h"

HRESULT CMMFParser::DoPlace( BYTE*& rgBuffer )
{
	MarsAppDef_Place  pPlace; Extract( rgBuffer, pPlace );
    CComBSTR          bstrName( pPlace.szName );
    HRESULT           hr;

	m_pMarsDocument->MarsWindow()->SetFirstPlace( bstrName );
    
    if(bstrName)
    {
        CPlaceCollection*        pPlaceCollection = m_pMarsDocument->GetPlaces(); ATLASSERT(pPlaceCollection);
        CComClassPtr<CMarsPlace> spPlace;
               
        if(SUCCEEDED(hr = pPlaceCollection->AddPlace( bstrName, &spPlace )))
        {
            ATLASSERT(spPlace);

            for(DWORD u = 0; u < pPlace.dwPlacePanelCount; ++u)
            {
				MarsAppDef_PlacePanel pPPanel; Extract( rgBuffer, pPPanel );
                CComBSTR              bstrPanel( pPPanel.szName );
                
                if(bstrPanel)
                {
                    CPlacePanel *pPlacePanel = new CPlacePanel( &pPPanel );
                    
                    if(pPlacePanel)
                    {
                        hr = spPlace->AddPanel( pPlacePanel );
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if(FAILED(hr)) break;
            }
        }
    }
    else
	{
        hr = E_OUTOFMEMORY;
	}
   
    return hr;
}

HRESULT CMMFParser::DoPlaces( BYTE*& rgBuffer )
{
    HRESULT           hr;
	MarsAppDef_Places pPlaces; Extract( rgBuffer, pPlaces );

    for(DWORD i = 0; i < pPlaces.dwPlacesCount; i++)
    {
        if(FAILED(hr = DoPlace( rgBuffer ))) return hr;
    }

    return S_OK;
}

HRESULT CMMFParser::DoPanel( BYTE*& rgBuffer )
{
	MarsAppDef_Panel    pLayout; Extract( rgBuffer, pLayout );
    CPanelCollection*   pPanelCollection = m_pMarsDocument->GetPanels();
    CComPtr<IMarsPanel> spPanel;
    WCHAR               wszStartUrl[MAX_PATH];
	HRESULT             hr;

    ExpandEnvironmentStringsW( pLayout.szUrl, wszStartUrl, ARRAYSIZE(wszStartUrl  ) );
	wcsncpy                  ( pLayout.szUrl, wszStartUrl, ARRAYSIZE(pLayout.szUrl) );

    hr = pPanelCollection->AddPanel( &pLayout, &spPanel );

    return hr;
}

HRESULT CMMFParser::DoPanels( BYTE*& rgBuffer )
{
    HRESULT           hr;
	MarsAppDef_Panels pPanels; Extract( rgBuffer, pPanels );

    for(DWORD i = 0; i < pPanels.dwPanelsCount; i++)
    {
        if(FAILED(hr = DoPanel( rgBuffer ))) return hr;
    }

    return S_OK;
}

HRESULT CMMFParser::DoMarsApp( BYTE* rgBuffer )
{
    HRESULT    hr;
    MarsAppDef pMarsApp; Extract( rgBuffer, pMarsApp );

    if(pMarsApp.dwVersion == XML_FILE_FORMAT_CURRENT_VERSION)
    {
        if(SUCCEEDED(hr = DoPanels( rgBuffer )) &&
		   SUCCEEDED(hr = DoPlaces( rgBuffer ))  )
		{
            if(pMarsApp.fTitleBar == FALSE)
            {
                m_pMarsDocument->MarsWindow()->ShowTitleBar( FALSE );
            }            
        }
    }
    else
    {
        hr = E_FAIL;
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////////////////////

HRESULT CMMFParser::ReadFile( const CComPtr<IStream>& spStream )
{
    HRESULT hr;

    if(SUCCEEDED(hr = ReadMMFStreamCookie( spStream )))
    {
        STATSTG stat;

        if(SUCCEEDED(hr = spStream->Stat( &stat, STATFLAG_NONAME )))
        {
            m_dwDocSize = stat.cbSize.LowPart - MMF_FILE_COOKIELEN;
            m_rgDocBuff = (BYTE*)LocalAlloc( LPTR, m_dwDocSize );

            if(m_rgDocBuff)
            {
                ULONG cbRead = 0;

                hr = spStream->Read( m_rgDocBuff, m_dwDocSize, &cbRead );

                if(cbRead != m_dwDocSize)
                {
                    hr = E_FAIL;
                }

                if(SUCCEEDED(hr))
                {
                    hr = DoMarsApp( m_rgDocBuff );
                }            
            }
            else
			{
                hr = E_OUTOFMEMORY;
			}
        }
    }

    return hr;
}

HRESULT CMMFParser::ReadMMFStreamCookie( const CComPtr<IStream>& spStream )
{
    HRESULT hr;
    char  	szFileCookie[MMF_FILE_COOKIELEN];
    ULONG 	cbRead = 0;

    if(SUCCEEDED(hr = spStream->Read( szFileCookie, MMF_FILE_COOKIELEN, &cbRead )))
    {
        if((cbRead == (MMF_FILE_COOKIELEN)) && (!memcmp( szFileCookie, g_szMMFCookie, MMF_FILE_COOKIELEN )))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    
    return hr;
}

CMMFParser::CMMFParser( CMarsDocument *pMarsDocument )
{
    m_pMarsDocument = pMarsDocument; //	  class CMarsDocument* m_pMarsDocument;
	m_dwDocSize     = 0;			 //	  DWORD                m_dwDocSize;
	m_rgDocBuff     = NULL;			 //	  BYTE*                m_rgDocBuff;
									 //	  CComBSTR             m_bstrFirstPlace;
}


HRESULT CMMFParser::MMFToMars( LPCWSTR pwszMMFUrl, CMarsDocument* pMarsDocument )
{
    HRESULT          hr;
	CComPtr<IStream> spStream;

    if(SUCCEEDED(hr = URLOpenBlockingStream( NULL, pwszMMFUrl, &spStream, 0, NULL )))
    {
        CMMFParser mmfParser( pMarsDocument );

        hr = mmfParser.ReadFile( spStream );
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\marsload.h ===
#pragma once
#include "parser.h"

class CMMFParser
{
protected:
    class CMarsDocument* m_pMarsDocument;
    DWORD                m_dwDocSize;
    BYTE*                m_rgDocBuff;
    CComBSTR             m_bstrFirstPlace;
    
    CMMFParser( CMarsDocument *pMarsDocument );
    
    ~CMMFParser()
    {
        if(m_rgDocBuff) LocalFree( m_rgDocBuff );
    }

    HRESULT DoPlace  ( BYTE*& rgBuffer );
    HRESULT DoPanel  ( BYTE*& rgBuffer );
    HRESULT DoPlaces ( BYTE*& rgBuffer );
    HRESULT DoPanels ( BYTE*& rgBuffer );
    HRESULT DoMarsApp( BYTE*  rgBuffer );    

	template <class T> void Extract( BYTE*& rgBuffer, T& pRet )
	{
		::CopyMemory( &pRet, rgBuffer, sizeof(T) );

		rgBuffer += sizeof(T);
	}
    
public:
    HRESULT ReadFile( const CComPtr<IStream>& spis );

    static HRESULT ReadMMFStreamCookie( const CComPtr<IStream>& spis );

    static HRESULT MMFToMars( LPCWSTR pszMMFUrl, class CMarsDocument* pMarsDocument );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\precomp.h ===
#ifndef _PRECOMP_H_INCLUDE
#define _PRECOMP_H_INCLUDE

#include "..\precomp.h"

#endif // _PRECOMP_H_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\uuid\acguids.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       acguids.c
//
//----------------------------------------------------------------------------

#define INITGUID
#include <initguid.h>
#include <windows.h>
#include <ole2.h>

#include <shobjidl.h>
#include <marscore.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\stack.h ===
#pragma once

// simple array-based stack class
// Entries and exits are copies; this class is only suitable for small types,
// like basic types(int, char, etc) and pointers
// If you store dynamically allocated pointers, you are responsible for their deletion
// This class DOES NOT TAKE OWNERSHIP of the objects if you use pointers.

// Methods:
// CStack(int iSizeHint=10)
//          Makes an empty stack with initial capacity of iSizeHint
// ~CStack()
//          Deletes ONLY the internal data allocated by CStack (ie, the array).
// Type Top()
//          Returns a copy of the last object pushed on the stack
//          Using this method when the stack is empty produces undefined behavior.
// void Pop()
//          Removes the last entry from the stack (loses the refrence to it.)
//          Using this method when the stack is empty produces undefined behavior.
// HRESULT Push(Type tobj)
//          Pushes a copy of tobj onto the stack.  This method will return S_OK unless
//          it needs to resize the stack and does not have enough memory, in which case it
//          returns E_OUTOFMEMORY
// BOOL IsEmpty()
//          Returns TRUE if the stack is empty, else FALSE.

template<class Type>
class CStack
{
protected:
    CSimpleArray<Type> m_srgArray;

public:
    CStack(int iSizeHint = 10)
    {
        ATLASSERT(iSizeHint > 0);
        // note: iSizeHint is no longer used
    }

    ~CStack()
    {
#ifdef DEBUG
        int nSize = m_srgArray.GetSize();
        ATLASSERT(nSize >= 0);
#endif
        m_srgArray.RemoveAll();
    }

    Type Top()
    {
        int nSize = m_srgArray.GetSize();
        ATLASSERT(nSize > 0);
        return m_srgArray[nSize - 1];
    }

    void Pop()
    {
        int nSize = m_srgArray.GetSize();
        ATLASSERT(nSize > 0);
        m_srgArray.RemoveAt(nSize - 1);
    }

    HRESULT Push(Type tobj)
    {
        return m_srgArray.Add(tobj);
    }

    BOOL IsEmpty()
    {
        return (m_srgArray.GetSize() <= 0);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\uuid\makefile.inc ===
!IF 0

Copyright (c) 1999 Microsoft Corporation

File:       makefile.inc

Abstract:   Added for guid header files that need to be propegated to the SDK
            directory.

History:    09/08/99    TNoonan     Borrowed from another location

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\parser.cpp ===
#include "precomp.h"
#include "..\mcinc.h"
#include "parser.h"

////////////////////////////////////////////
// CMarsXMLFactory
////////////////////////////////////////////

CMarsXMLFactory::CMarsXMLFactory()
    : m_elemStack(10)
{
    ATLASSERT(! m_ptiaTags);
}

CMarsXMLFactory::~CMarsXMLFactory()
{
    if (!m_elemStack.IsEmpty())
    {
        do
        {
            m_elemStack.Top()->Release_Ref();
            m_elemStack.Pop();
        }
        while (! m_elemStack.IsEmpty());
    }
}


// IUnknown
IMPLEMENT_ADDREF_RELEASE(CMarsXMLFactory);

STDMETHODIMP CMarsXMLFactory::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr;

    if (iid == IID_IXMLNodeFactory  || 
        iid == IID_IUnknown )
    {
        AddRef();
        *ppvObject = (IXMLNodeFactory *) this;
        hr = S_OK;
    }
    else
    {
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}

// IXMLNodeFactory
HRESULT CMarsXMLFactory::NotifyEvent(IXMLNodeSource *pSource,
                                     XML_NODEFACTORY_EVENT iEvt)
{
    return S_OK;
}

HRESULT CMarsXMLFactory::BeginChildren(IXMLNodeSource *pSource,
                                       XML_NODE_INFO *pNodeInfo)
{
    return S_OK;
}

HRESULT CMarsXMLFactory::EndChildren(IXMLNodeSource *pSource,
                                     BOOL fEmpty,
                                     XML_NODE_INFO *pNodeInfo)
{
    // This call means that the node is completed; all the children and innertext
    // have been processed, and the </tag> has been reached.  This is the time to
    // close up the element.
    // Note: any return value other than S_OK indicates failure
    HRESULT hr = S_OK;
    // It is assumed that the top of the stack is the node whose children are
    // ending

    if (! m_elemStack.IsEmpty())
    {
        HRESULT hrTemp;
        CXMLElement *pxElem = m_elemStack.Top();
        m_elemStack.Pop();

        // OnNodeComplete should return S_OK for need to be added to parent,
        // S_FALSE for do not need to be added to parent, and
        // any failure codes for critical problems
        hrTemp = pxElem->OnNodeComplete();

        if ((hrTemp == S_OK) && !m_elemStack.IsEmpty())
        {
            // Addchild takes ownership of the element on S_OK.
            // Otherwise, we delete the element here.
            // we must delete the element here.

            // NOTE: Parent should Add_Ref the child
            hrTemp = m_elemStack.Top()->AddChild(pxElem);
        }
        else 
        {
            if(FAILED(hrTemp))
			{
                hr = hrTemp;
			}
        }

        pxElem->Release_Ref();
    }
        

    return hr;
}


HRESULT CMarsXMLFactory::Error(IXMLNodeSource *pSource,
                               HRESULT hrErrorCode, USHORT cNumRecs,
                               XML_NODE_INFO **apNodeInfo)
{
    // break out of the xmlparser->Run(-1) with error message E_INVALIDARG
    // on any xml syntax erros
    return E_INVALIDARG;
}

HRESULT CMarsXMLFactory::CreateNode(IXMLNodeSource *pSource,
                                    PVOID pNodeParent, USHORT cNumRecs,
                                    XML_NODE_INFO  **apNodeInfo)
{
    // This call is made when a opening tag is encoutered, ie
    // <data>... or <data/> (an empty tag) apNodeInfo is an array of
    // node infos; the first is the name of the tag, the rest are a
    // series of attributes and other such things which were bundled
    // in the tag, ie <data size="100">
    // We only recognize attributes;
    //   SetElementAttributes handles those

    HRESULT hr = S_OK;
    ATLASSERT(cNumRecs > 0);

    switch (apNodeInfo[0]->dwType)
    {
    case XML_ELEMENT:
    {
        CXMLElement *pxElem;
        hr = CreateElement(apNodeInfo[0]->pwcText, apNodeInfo[0]->ulLen, &pxElem);

        if (hr == S_OK)
        {
            hr = SetElementAttributes(pxElem, apNodeInfo + 1, cNumRecs - 1);
            if (SUCCEEDED(hr))
            {
                m_elemStack.Push(pxElem); // the stack holds our Ref
            }
            else
            {
                pxElem->Release_Ref();
            }
        }

        break;
    }
    case XML_PCDATA:
    case XML_CDATA:
    {
        // since this is the first node in the node-info, this must be the
        // inner text in a tag (<name>Johhny</name> - we're talking about the
        // string "Johhny" for example).

        if (! m_elemStack.IsEmpty())
        {
            hr = m_elemStack.Top()->SetInnerXMLText(apNodeInfo[0]->pwcText,
                                                    apNodeInfo[0]->ulLen);
        }
        break;
    }
    default:
    {
        // ignore all other types of nodes (whitespace, comment, and unknown)
        break;
    }
    }

    return hr;
}



HRESULT CMarsXMLFactory::SetElementAttributes(CXMLElement *pxElem,  
                                              XML_NODE_INFO **apNodeInfo,
                                              ULONG cInfoLen)
// apNodeInfo is the beginning of XML_NODE_INFO attributes: the first node is an
// XML_ATTRIBUTE with the name of an attribute, the second node is an XML_PCDATA with
// the value, and then the 3rd and 4th are similar, if they exist, and so on.
// pElement's SetAttribute method is called for all the attribute name/value pairs,
// the return result is S_OK, E_OUTOFMEMORY, or S_FALSE (xml symantic err)
{
    ULONG i;
    HRESULT hr = S_OK;

    i = 0;
    while (SUCCEEDED(hr) && (i < cInfoLen))
    {
        if (apNodeInfo[i]->dwType == XML_ATTRIBUTE)
        {
            // move to the next ap node to get the value of the attribute
            i++;
            if ((i < cInfoLen) && (apNodeInfo[i]->dwType == XML_PCDATA))
            {
                // Set attribute should return S_OK for success, S_FALSE for
                // unexpected attribute, and may return critical errors such as
                // E_OUTOFMEMORY
                hr = pxElem->SetAttribute(apNodeInfo[i-1]->pwcText, 
                                          apNodeInfo[i-1]->ulLen,
                                          apNodeInfo[i]->pwcText, 
                                          apNodeInfo[i]->ulLen);
            }
            else
            {
                continue;
            }
        }

        i++;
    }

    return hr;
}

HRESULT CMarsXMLFactory::Run(IStream *pisDoc)
{
    if (!m_ptiaTags)
        return E_UNEXPECTED; // EPC
    if (!pisDoc)
        return E_INVALIDARG; // EPC

    HRESULT hr;

    CComPtr<IXMLParser> spParser;

    hr = spParser.CoCreateInstance(CLSID_XMLParser);

    if (SUCCEEDED(hr))
    {
        CComPtr<IUnknown> spUnk;

        hr = pisDoc->QueryInterface(IID_IUnknown, (void **)&spUnk);
        if (SUCCEEDED(hr))
        {
            hr = spParser->SetInput(spUnk);

            if (SUCCEEDED(hr))
            {
                hr = spParser->SetFactory(this);

                if (SUCCEEDED(hr))
                {
                    hr = spParser->Run(-1);

                    ATLASSERT(hr != E_PENDING);
                    if (FAILED(hr))
                        hr = spParser->GetLastError();
                }
            }
        }
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}


void CMarsXMLFactory::SetTagInformation(TagInformation **ptiaTags)
{
    m_ptiaTags = ptiaTags;
}

void CMarsXMLFactory::SetLParam(LONG lParamNew)
{
    m_lParamArgument = lParamNew;
}

HRESULT CMarsXMLFactory::CreateElement(LPCWSTR wzTagName, ULONG cLen, CXMLElement **ppxElem)
{
    // Look in m_ptiaTags for a name that matches wzTagName, and call upon the corresponding
    // creation function once found
    // REturns S_FALSE if the tag is not found
    ATLASSERT(ppxElem);
    HRESULT hr = S_FALSE;
    int i;
    *ppxElem = NULL;

    if (m_ptiaTags)
    {
        for (i = 0; m_ptiaTags[i]; i++)
        {
            // if m_ptiaTags[i]->wzTagName is ever NULL, we will consider this
            //   the "default" action and call "Create"
#ifdef DEBUG
            // TODO: for now, we assert that the generic element is VT_BSTR, but
            //  it would be cool to have a "Generic number" element, "Generic Time", etc...
            if (m_ptiaTags[i]->wzTagName == NULL)
                ATLASSERT(m_ptiaTags[i]->vt == VT_BSTR);
#endif
            
            if ((m_ptiaTags[i]->wzTagName == NULL)
                || (StrEqlNToSZ(wzTagName, cLen, m_ptiaTags[i]->wzTagName)))
            {
                *ppxElem = m_ptiaTags[i]->funcCreate(m_ptiaTags[i]->wzTagName, m_ptiaTags[i]->vt, 
                                                     m_ptiaTags[i]->ptiaChildren,
                                                     m_ptiaTags[i]->paiaAttributes,
                                                     m_lParamArgument);
                hr = *ppxElem ? S_OK : E_OUTOFMEMORY;
                break;
            }
        }
    }

    if (hr == S_FALSE)
    {
        SpewUnrecognizedString(wzTagName, cLen, L"Tag name not recognized and being ignored, ");
    }

    return hr;
}


/////////////////////////////////////////////
// CXMLElement
/////////////////////////////////////////////
HRESULT CXMLElement::OnNodeComplete()
{
    return S_FALSE; 
}

HRESULT CXMLElement::AddChild(CXMLElement *pxeChild)
{ 
    ATLASSERT(pxeChild);
    return S_FALSE; 
}

HRESULT CXMLElement::SetAttribute(LPCWSTR wzName, ULONG cLenName, LPCWSTR pwzValue, ULONG cLenValue)
{
    SpewUnrecognizedString(wzName, cLenName, L"Base class SetAttribute called, attribute name ");
    return S_FALSE;
}

HRESULT CXMLElement::SetInnerXMLText(LPCWSTR pwzText, ULONG cLen)
{
    return S_FALSE; 
}

HRESULT CXMLElement::GetAttribute(LPCWSTR wzName, VARIANT *pvarOut)
{
    if (pvarOut)
    {
        VariantInit(pvarOut);
    }

    return E_INVALIDARG;
}

HRESULT CXMLElement::GetContent(VARIANT *pvarOut)
{
    if (pvarOut)
    {
        VariantInit(pvarOut);
    }

    return E_INVALIDARG;
}

void CXMLElement::FirstChild()
{
}
void CXMLElement::NextChild()
{
}
CXMLElement *CXMLElement::CurrentChild()
{
    return NULL;
}
CXMLElement *CXMLElement::DetachCurrentChild()
{
    return NULL;
}
BOOL CXMLElement::IsDoneChild()
{
    return TRUE;
}
LPCWSTR CXMLElement::GetName()
{
    return NULL;
}


struct CAttributeStruct
{
    int         m_iArrayIndex;
    CComVariant m_Variant;

    // NOTE: This is only set when m_iArrayIndex is "-1"
    CComBSTR    m_bstrAttribName;
    
    CAttributeStruct(int iArrayIndex, VARTYPE vt, LPCWSTR wzVal, ULONG cLen,
                     LPCWSTR pszAttribName = NULL)
    {

        // must set iArrayIndex to -1 in order to pass in bstrAttribName
        ATLASSERT( ((iArrayIndex >= 0) && !pszAttribName)
                || pszAttribName);
        
        m_iArrayIndex = iArrayIndex;

        if (pszAttribName)
            // copy
            m_bstrAttribName = pszAttribName;
        
        HRESULT hr;

        // We don't call VariantChangeType 'cause wzVal is not null-terminated
        switch (vt)
        {
        case VT_I4:
            hr = StrToLongNW(wzVal, cLen, &m_Variant.lVal);
            if (SUCCEEDED(hr))
                m_Variant.vt = VT_I4;
            else
                m_Variant.vt = VT_NULL;

            break;
        case VT_BSTR:
            m_Variant = SysAllocStringLen(wzVal, cLen);
            break;
        case VT_BOOL:
            m_Variant = StrToIsTrueNW(wzVal, cLen);
            ATLASSERT(m_Variant.vt == VT_BOOL);
            break;
        default:
            ATLASSERT(FALSE);
            m_Variant.vt = VT_NULL;
            break;
        }
    }
};

/////////////////////////////////////////////
// CXMLGenericElement
/////////////////////////////////////////////

CXMLGenericElement::CXMLGenericElement(LPCWSTR wzName, 
                                       VARTYPE vt, 
                                       TagInformation **ptiaChildren, 
                                       AttributeInformation **paiaAttributes)
{
    m_paiaAttributes = paiaAttributes;
    m_ptiaChildren   = ptiaChildren;
    m_vtData         = vt;
    m_varData.vt     = VT_EMPTY;
    m_bstrName       = wzName;

    ATLASSERT(! m_psnodeAttributes);
    // The header node is a member variable.
    m_psnodeChildrenFirst = &m_snodeChildrenFirst;
    m_psnodeChildrenFirst->m_pvData = NULL;
    m_psnodeChildrenFirst->m_psnodeNext = NULL;
    m_psnodeChildrenEnd = m_psnodeChildrenFirst;
    ATLASSERT(! m_psnodeChildrenIter);
}

CXMLGenericElement::~CXMLGenericElement()
{
    CAttributeStruct *pattStruct;
    CXMLElement      *pxElem;
    CSimpleNode      *psnodeTemp;

    while (m_psnodeAttributes)
    {
        pattStruct = (CAttributeStruct *) m_psnodeAttributes->m_pvData;
        psnodeTemp = m_psnodeAttributes;
        m_psnodeAttributes = m_psnodeAttributes->m_psnodeNext;
        delete pattStruct;
        delete psnodeTemp;
    }

    // Don't delete the header - a statically allocated member
    m_psnodeChildrenFirst = m_psnodeChildrenFirst->m_psnodeNext;
    while (m_psnodeChildrenFirst)
    {
        pxElem = (CXMLElement *) m_psnodeChildrenFirst->m_pvData;
        psnodeTemp = m_psnodeChildrenFirst;
        m_psnodeChildrenFirst = m_psnodeChildrenFirst->m_psnodeNext;
        pxElem->Release_Ref();
        delete psnodeTemp;
    }
}

HRESULT CXMLGenericElement::SetInnerXMLText(LPCWSTR pwzText, ULONG cLen)
{
    HRESULT      hr = S_OK;
    BOOL    fAppend = FALSE;
    
    if ((m_varData.vt != VT_EMPTY) &&
        (m_varData.vt != VT_NULL))
    {
        fAppend = TRUE;
    }
    
    m_varData.vt = m_vtData;
    
    switch (m_vtData)
    {
    case VT_I4:
    {
        ATLASSERT(!fAppend);
        LONG lVal;
        hr = StrToLongNW(pwzText, cLen, &lVal);
        if (SUCCEEDED(hr))
        {
            m_varData    = lVal;
            // this assignment should never fail; any possible errors are unexpected
            ATLASSERT(m_varData.vt != VT_ERROR);
        }
        else
        {
            SpewUnrecognizedString(pwzText, cLen, L"StrToLongNW failed in SetInnerXMLText, ");
            hr = S_FALSE;
        }

        break;
    }
    case VT_BSTR:
    {
        if (fAppend)
        {
            BSTR bstrOld    = m_varData.bstrVal;
            UINT cb_bstrOld = SysStringLen(m_varData.bstrVal);
            
            m_varData.bstrVal = SysAllocStringLen(bstrOld, cb_bstrOld + cLen);

            if (m_varData.bstrVal)
            {
                StrCpyN(m_varData.bstrVal + cb_bstrOld, pwzText, cLen + 1);
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
            SysFreeString(bstrOld);
        }
        else
        {
            m_varData.bstrVal = SysAllocStringLen(pwzText, cLen);

            if (!m_varData.bstrVal)
                hr = E_OUTOFMEMORY;
        }
        break;
    }
    case VT_NULL:
    case VT_EMPTY:
        break;
    default:
        m_varData = VT_EMPTY;
        hr = S_FALSE;
        break;
    }

    return hr;
}

HRESULT CXMLGenericElement::SetAttribute(const WCHAR *pwzName, ULONG cNameLen,
                                         const WCHAR *pwzText, ULONG cTextLen)
{
    // It is expected that the number of attributes is small
    // Hence we use a simple linked list with O(1) insertions and O(n)queries
    // No syntax checking (ie, dups) is done

    HRESULT hr = S_FALSE;
    int i;
    LPCWSTR pszAttribName = NULL;
    
    if (m_paiaAttributes)
    {
        for (i = 0; m_paiaAttributes[i]; i++)
        {
            // wzAttName NULL is the "default" attribute
            if (m_paiaAttributes[i]->wzAttName == NULL)
            {
                pszAttribName = pwzName;
                break;
            }
            else if (StrEqlNToSZ(pwzName, cNameLen, m_paiaAttributes[i]->wzAttName))
            {
                break;
            }
        }

        if (m_paiaAttributes[i])
        {
            CAttributeStruct *pattStruct;
            
            if (pszAttribName)
            {
                pattStruct = new CAttributeStruct(-1, m_paiaAttributes[i]->vt,
                                                  pwzText, cTextLen, pszAttribName);
            }
            else
            {
                pattStruct = new CAttributeStruct(i, m_paiaAttributes[i]->vt,
                                                  pwzText, cTextLen, pszAttribName);
            }

            if (pattStruct)
            {
                CSimpleNode *psnode = new CSimpleNode();
                if (psnode)
                {
                    // add to front of list
                    psnode->m_psnodeNext = m_psnodeAttributes;
                    psnode->m_pvData = pattStruct;
                    m_psnodeAttributes = psnode;
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    delete pattStruct;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (hr == S_FALSE)
    {
        SpewUnrecognizedString(pwzName, cNameLen,
                               L"Trying to set unrecognized attribute in SetAttribute, ");
    }

    return hr;
}


HRESULT CXMLGenericElement::GetContent(VARIANT *pvarOut)
{
    // Returns S_OK on attribute found, E_INVALIDARG on not.
    // ppvarOut can be NULL; if it is not, then it is a pointer to the content VARIANT
    HRESULT hr = E_INVALIDARG;
    if ((m_varData.vt != VT_EMPTY) && (m_varData.vt != VT_NULL))
    {
        if (pvarOut)
        {
            VariantInit(pvarOut);
            hr = VariantCopy(pvarOut, &m_varData);
        }
    }
    else
    {
        if (pvarOut)
        {
            VariantInit(pvarOut);
        }
    }

    return hr;
}

HRESULT CXMLGenericElement::GetAttribute(LPCWSTR wzName, VARIANT *pvarOut)
{
    // Returns S_OK on attribute found, E_INVALIDARG if not.
    // ppvarOut can be NULL; if it is not, then it is a pointer to the attribute value VARIANT
    // It is expected that the number of attributes is small
    // Hence we use a simple linked list with O(1) insertions and O(n)queries
    // No syntax checking (ie, dups) is done

    HRESULT           hr     = E_INVALIDARG;
    CSimpleNode      *psnode = m_psnodeAttributes;
    CAttributeStruct *pattStruct;
    while (psnode)
    {
        pattStruct = (CAttributeStruct *) psnode->m_pvData;

        if (((pattStruct->m_iArrayIndex < 0) &&
             StrEql(wzName, pattStruct->m_bstrAttribName))
            || (StrEql(m_paiaAttributes[pattStruct->m_iArrayIndex]->wzAttName, wzName)))
        {
            hr = S_OK;
            if (pvarOut)
            {
                VariantInit(pvarOut);
                VariantCopy(pvarOut, &(pattStruct->m_Variant));
            }
            break;
        }
        psnode = psnode->m_psnodeNext;
    }

    if (!psnode)
    {
        // don't fire a trace message if our caller is just pinging us
        // to see if we have the attribute
        if (pvarOut)
        {
            VariantInit(pvarOut);
        }
    }

    return hr;
}

void CXMLGenericElement::FirstChild()
{
    m_psnodeChildrenIter = m_psnodeChildrenFirst->m_psnodeNext;
}

void CXMLGenericElement::NextChild()
{
    if (m_psnodeChildrenIter)
    {
        m_psnodeChildrenIter = m_psnodeChildrenIter->m_psnodeNext;
    }
    else
    {
        ATLASSERT(FALSE);
    }
}

CXMLElement *CXMLGenericElement::CurrentChild()
{
    CXMLElement *pxeReturn;

    if (m_psnodeChildrenIter && (m_psnodeChildrenIter != m_psnodeChildrenFirst))
    {
        pxeReturn = (CXMLElement *) m_psnodeChildrenIter->m_pvData;
    }
    else
    {
        ATLASSERT(FALSE);
        pxeReturn = NULL;
    }

    return pxeReturn;
}

// caller gets our ref to the CXMLElement
CXMLElement *CXMLGenericElement::DetachCurrentChild()
{
    CXMLElement *pxeReturn;

    if (m_psnodeChildrenIter)
    {
        pxeReturn = (CXMLElement *) m_psnodeChildrenIter->m_pvData;

        CSimpleNode *psnodeHack = m_psnodeChildrenFirst;
        while (psnodeHack->m_psnodeNext != m_psnodeChildrenIter)
        {
            psnodeHack = psnodeHack->m_psnodeNext;
            // If this assertion is broken, then m_psnodeChildrenIter is not
            // in the list
            ATLASSERT(psnodeHack);
        }

        // here psnodeHack=>m_psnodeChildrenIter=>...=>m_psnodeChildrenEnd
        
        // update the end of the list
        if (psnodeHack->m_psnodeNext == m_psnodeChildrenEnd)
        {
            m_psnodeChildrenEnd = psnodeHack;
        }

        // delete the current NODE (but not the data in the node) and set the iterator
        // to the previous node (psnodeHack)
        psnodeHack->m_psnodeNext = psnodeHack->m_psnodeNext->m_psnodeNext;
        delete m_psnodeChildrenIter;
        m_psnodeChildrenIter = psnodeHack;
    }
    else
    {
        ATLASSERT(FALSE);
        pxeReturn = NULL;
    }

    return pxeReturn;
}
HRESULT CXMLGenericElement::AddChild(CXMLElement *pxeChild)
{
    HRESULT hr = S_FALSE;

    LPCWSTR pwzName = pxeChild->GetName();
    int i;
    if (m_ptiaChildren)
    {
        for (i = 0; m_ptiaChildren[i]; i++)
        {
            if (StrEql(m_ptiaChildren[i]->wzTagName, pwzName))
            {
                break;
            }
        }

        if (m_ptiaChildren[i])
        {
            CSimpleNode *psnode;

            psnode = new CSimpleNode;
            if (psnode)
            {
                pxeChild->Add_Ref();
                psnode->m_pvData = (void *) pxeChild;
                psnode->m_psnodeNext = NULL;
                m_psnodeChildrenEnd->m_psnodeNext = psnode;
                m_psnodeChildrenEnd = psnode;
                // S_OK to indicate we're taking ownership of the child
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

BOOL CXMLGenericElement::IsDoneChild()
{
    return !(m_psnodeChildrenIter && (m_psnodeChildrenIter != m_psnodeChildrenFirst));
}

CXMLElement *CXMLGenericElement::CreateInstance(LPCWSTR wzName, 
                                                VARTYPE vt, 
                                                TagInformation **ptiaChildren, 
                                                AttributeInformation **paiaAttributes,
                                                LONG)
{
    return new CXMLGenericElement(wzName, vt, ptiaChildren, paiaAttributes);
}

LPCWSTR CXMLGenericElement::GetName()
{
    return m_bstrName;
}

HRESULT CXMLGenericElement::OnNodeComplete()
{
    return S_OK;
}



/////////////////////////////////////////////
// Global Helper functions
/////////////////////////////////////////////

BOOL StrEqlNToSZ(const WCHAR *wzN, int n, const WCHAR *wzSZ)
{
    int i;
    for (i = 0; i < n; i++)
    {
        if (wzN[i] != wzSZ[i])
        {
            return FALSE;
        }
    }

    // make sure the zero terminated string is ending here
    return (wzSZ[n] == L'\0');
}

bool StrToIsTrueNW(const WCHAR *wz, ULONG cLen)
{
    if (cLen == 4 &&
        (StrEqlNToSZ(wz, cLen, L"true") ||
         StrEqlNToSZ(wz, cLen, L"TRUE")))
    {
        return true;
    }
    else
    {
        return false;
    }
}

#ifndef IS_DIGITW
#ifndef InRange
#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#endif
#define IS_DIGITW(ch)    InRange(ch, L'0', L'9')
#endif

// convert a wide string to a long, assuming the string has a max of cLen characters.
// L'\0' is recognized to stop earlier, but any other non-digit will cause a return
// of E_INVALIDARG
HRESULT StrToLongNW(const WCHAR *wzString, ULONG cLen, LONG *plong)
{
    HRESULT hr = S_OK;
    ATLASSERT(plong);
    *plong = 0;
    UINT i = 0;
    BOOL bNeg = FALSE;

    if ((i < cLen) && wzString[i] == L'-') 
    {
        bNeg = TRUE;
        i++;
    }

    while ((i < cLen) && IS_DIGITW(wzString[i])) 
    {
        *plong *= 10;
        *plong += wzString[i] - L'0';
        i++;
    }

    if ((i < cLen) && (wzString[i] != L'\0'))
    {
        *plong = 0;
        hr = E_INVALIDARG;
    }
    else
    {
        if (bNeg)
            *plong = -(*plong);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\pchmars\marscore\parser\parser.h ===
// marsfact.h
// header file for class CMarsXMLFactory,
// a callback class for the XML Push model parser
// CMarsXMLFactory is used to construct a MARS its file from the xml
#pragma once

#include "stack.h"
#include <xmlparser.h>

// forward declarations of data structures
class CXMLElement;
struct TagInformation;

class CMarsXMLFactory : public CMarsComObject,
                        public IXMLNodeFactory
{
public:
    CMarsXMLFactory();
    virtual ~CMarsXMLFactory();

    // IUnknown
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject);

    // CMarsComObject
    // This class has no back references so the passivate stuff is a noop
    virtual HRESULT DoPassivate() { return S_OK; }

    // IXMLNodeFactory - used to communicate with the IXMLParser
    virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
                    IXMLNodeSource *pSource, XML_NODEFACTORY_EVENT iEvt);
    
    virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
                    IXMLNodeSource *pSource, XML_NODE_INFO *pNodeInfo);
    
    virtual HRESULT STDMETHODCALLTYPE EndChildren( 
                    IXMLNodeSource *pSource, BOOL fEmpty, 
                    XML_NODE_INFO *pNodeInfo);
    
    virtual HRESULT STDMETHODCALLTYPE Error( 
                    IXMLNodeSource *pSource, HRESULT hrErrorCode,
                    USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);
    
    virtual HRESULT STDMETHODCALLTYPE CreateNode( 
                    IXMLNodeSource *pSource, PVOID pNodeParent,
                    USHORT cNumRecs, XML_NODE_INFO **apNodeInfo);

    
    // CMarsXMLFactory

    // Call "Run" when you want to start parsing...
    //  Note: pisDoc must be a synchronous stream (not E_PENDING) -- so there!
    HRESULT Run(IStream *pisDoc);
    
    // Set the TagInformation* array used to create nodes.  These
    // arrays should be const and live past the lifetime of the
    // parsing; they are not copied
    void SetTagInformation(TagInformation **ptiaTags);

    // Sets the LONG parameter passed as the last argument to all of
    // the nodes created in CreateNode.  (See the definition of
    // CreationFunction below) This parameter is the way to provide
    // your run-time pointer/reference or whatever to the objects that
    // the xml is supposed to be initializing
    void SetLParam(LONG lParamNew);


protected:
    HRESULT SetElementAttributes(CXMLElement *pxElem,  
                                 XML_NODE_INFO **apNodeInfo, ULONG cInfoLen);
    HRESULT CreateElement(LPCWSTR wzTagName, ULONG cLen, CXMLElement **ppxElem);
    

    CStack<CXMLElement *> m_elemStack;
    TagInformation **m_ptiaTags;
    LONG m_lParamArgument;
};




// The AttributeInformation and TagInformation structs, which are used to determine syntax: what 
// element creation function is called for what tag name
struct AttributeInformation
{
    LPWSTR wzAttName;
    VARTYPE vt;
};

typedef CXMLElement * (*CreationFunction)(LPCWSTR, VARTYPE, TagInformation **, AttributeInformation **, LONG lParam);

struct TagInformation
{
    LPWSTR wzTagName;
    CreationFunction funcCreate;
    VARTYPE vt;
    TagInformation **ptiaChildren;
    AttributeInformation **paiaAttributes;
};

// The CXMLElement class, from which all the elements used by the
// CMarsXMLFactory must be derived.  The methods can be pick and chose
// implemented; the base class implementations spew a TraceMsg error
// and return S_FALSE or E_NOTIMPL as appropriate
class CXMLElement
{
private:
    ULONG m_cRef;
    
public:

    // CXMLElement is NOT a COM object, so these methods are
    //  given wierd names to prevent confusion...

    ULONG Add_Ref()     { return ++m_cRef; }

    ULONG Release_Ref()
    {
        if (--m_cRef == 0)
        {
            delete this;
            return 0;
        }
        else return m_cRef;
    }
    
    // these methods are used by the CMarsXMLFactory and should return S_FALSE on not impl 
    // (to indicate an unexpected operation due to unexpected xml)
    virtual HRESULT OnNodeComplete();
    // Addchild takes ownership of the element on S_OK; otherwise CMarsXMLFactory deletes pxeChild
    virtual HRESULT AddChild(CXMLElement *pxeChild);

    virtual HRESULT SetAttribute(LPCWSTR wzName, ULONG cLenName,
                                 LPCWSTR pwzValue, ULONG cLenValue);

    //
    // HACKHACK paddywack:
    //       The implementer of this function should be aware of the strange
    //       semantics here:  SetInnerXMLText is sometimes called multiple times
    //       due to issues with the Push-model parser.  If SetInnerXMLText is called
    //       more than once, the subsequent called mean "AppendInnerXMLText". :)
    //
    virtual HRESULT SetInnerXMLText(LPCWSTR pwzText, ULONG cLen);

    // GetName can return NULL
    virtual LPCWSTR GetName();

    // The rest of these methods are generalized methods to access CXMLElements.
    // They should generally return E_whatever on failure or not impl.
    // This interface can be changed, as long as whoever changes it also makes sure
    // to serve up the changes in CXMLGenericElement
    // These methods are not used by any of the code in marsfact.cpp

    // The GetContent and GetAttribute methods return pointers to existing variants;
    // these variants should be considered const

    // TODO: No procedure should take VARIANT**: we need to make all of these
    //       VARIANT*
    virtual HRESULT GetContent(VARIANT *pvarOut);
    virtual HRESULT GetAttribute(LPCWSTR wzName, VARIANT *pvarOut);
    virtual void FirstChild();
    virtual void NextChild();
    virtual CXMLElement *CurrentChild();
    virtual CXMLElement *DetachCurrentChild();
    virtual BOOL IsDoneChild();

protected:
    CXMLElement() { m_cRef = 1; }
    virtual ~CXMLElement() { ATLASSERT(0 == m_cRef); }
};


struct CSimpleNode
{
    CSimpleNode *m_psnodeNext;
    void *m_pvData;
};

// Generic implementation of the CXMLElement class.
class CXMLGenericElement : public CXMLElement
{
public:
    virtual ~CXMLGenericElement();

    virtual HRESULT OnNodeComplete();

    virtual HRESULT AddChild(CXMLElement *pxeChild);

    virtual HRESULT SetAttribute(LPCWSTR wzName, ULONG cLenName,
                                 LPCWSTR pwzValue, ULONG cLenValue);

    virtual HRESULT SetInnerXMLText(LPCWSTR pwzText, ULONG cLen);
    virtual LPCWSTR GetName();

    virtual HRESULT GetContent(VARIANT *pvarOut);
    virtual HRESULT GetAttribute(LPCWSTR wzName, VARIANT *pvarOut);


    virtual void FirstChild();
    virtual void NextChild();

    // These methods return NULL if invalid
    // DetachCurrentChild does the same as CurrentChild, but also removes the child from the
    // list
    virtual CXMLElement *CurrentChild();
    virtual CXMLElement *DetachCurrentChild();

    virtual BOOL IsDoneChild();

    static CXMLElement *CreateInstance(LPCWSTR wzName, 
                                       VARTYPE vt, 
                                       TagInformation **ptiaChildren, 
                                       AttributeInformation **paiaAttributes,
                                       LONG lParam);
protected:
    CXMLGenericElement(LPCWSTR wzName, VARTYPE vt,
                       TagInformation **ptiaChildren, AttributeInformation **paiaAttributes);
    CXMLGenericElement() {}

    VARTYPE      m_vtData;
    CComVariant  m_varData;
    CSimpleNode *m_psnodeAttributes;
    // The header node is a member variable.
    CSimpleNode  m_snodeChildrenFirst;
    CSimpleNode *m_psnodeChildrenFirst;
    CSimpleNode *m_psnodeChildrenEnd;
    CSimpleNode *m_psnodeChildrenIter;
    
    TagInformation **m_ptiaChildren;
    AttributeInformation **m_paiaAttributes;
    
    CComBSTR m_bstrName;
};


// Some helpful functions for handling explicit length strings

// Returns true if the strings are the same up to the nth char,
// and the zero terminated string (third param) has a null character after that
// position
BOOL StrEqlNToSZ(const WCHAR *wzN, int n, const WCHAR *wzSZ);

// Retunrs true if wz is L"true" or L"TRUE" and cLen is 4
// Must be "bool" for CComVariant to become VT_BOOL
bool StrToIsTrueNW(const WCHAR *wz, ULONG cLen);

// Converts the first cLen chars to a long, returning a E_FAIL if there is a non-digit
// If L'\0' is encountered, the conversion stops at that point
HRESULT StrToLongNW(const WCHAR *wzString, ULONG cLen, LONG *plong);

// SpewTraceMessage copies the cLen wchars to a bstr and then 
// calls TraceMsg(TF_XMLPARSING | TF_WARNING, L"%sstring=%s", wzDesc, wzBstr)
#ifdef DEBUG
void SpewUnrecognizedString(const WCHAR *wzString, ULONG cLen, const WCHAR *wzDesc);
#else
#define SpewUnrecognizedString(strByLength, len, strDesc)
#endif

// I used TraceMst(..., L"...%s...", string) all over the place without checking string;
// As everyone knows (except me!) printf faults on NULL for a %s arg, hence this macro
#define NULL_STRING_PROTECT(str) str ? str : L""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_bla\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_bla.log -dblog createdb_bla.log COMPILE $(_NTTREE) Blade_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_b3.cab $(O)\pchdt_b3.cab
!elseif $(WIN64)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\common\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS0"
	-del/q/f $(_NTPOSTBLD)\build_logs\hss*.log
	-del/q/f $(_NTPOSTBLD)\build_logs\createdb*.log
!endif
!if "$(BUILD_PASS)" == "PASS1"
	hsssetuptool -maxelements 50 -root $(_NTPOSTBLD)\build_logs BINPLACE $(INETROOT)\redist\SKUlist.txt $(INETROOT)\redist\setupimage.lst $(_NTTREE) $(O)
	hsssetuptool 				 -root $(_NTPOSTBLD)\build_logs COMPILE                                                                   $(_NTTREE) none
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_per\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_per.log -dblog createdb_per.log COMPILE $(_NTTREE) Personal_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_p3.cab $(O)\pchdt_p3.cab
!elseif $(WIN64)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_ent\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_ent.log -dblog createdb_ent.log COMPILE $(_NTTREE) AdvancedServer_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_e3.cab $(O)\pchdt_e3.cab
!elseif $(WIN64)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_ent.log -dblog createdb_ent.log COMPILE $(_NTTREE) AdvancedServer_64
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_e6.cab $(O)\pchdt_e6.cab
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_dtc\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_dtc.log -dblog createdb_dtc.log COMPILE $(_NTTREE) DataCenter_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_d3.cab $(O)\pchdt_d3.cab
!elseif $(WIN64)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_dtc.log -dblog createdb_dtc.log COMPILE $(_NTTREE) DataCenter_64
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_d6.cab $(O)\pchdt_d6.cab
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_srv\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_srv.log -dblog createdb_srv.log COMPILE $(_NTTREE) Server_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_s3.cab $(O)\pchdt_s3.cab
!elseif $(WIN64)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_sbs\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_sbs.log -dblog createdb_sbs.log COMPILE $(_NTTREE) SmallBusinessServer_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_l3.cab $(O)\pchdt_l3.cab
!elseif $(WIN64)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\sku_wks\makefile.inc ===
gosetup:
!if "$(BUILD_PASS)" == "PASS1"
!if $(386)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_wks.log -dblog createdb_wks.log COMPILE $(_NTTREE) Professional_32
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_w3.cab $(O)\pchdt_w3.cab
!elseif $(WIN64)
	HssSetupTool.exe -root $(_NTPOSTBLD)\build_logs -log hss_wks.log -dblog createdb_wks.log COMPILE $(_NTTREE) Professional_64
	copy/y $(_NTTREE)\HelpAndSupportServices\pchdt_w6.cab $(O)\pchdt_w6.cab
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\api\internal.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    internal.c

Abstract:

    User-mode interface to SR.SYS.

Author:

    Keith Moore (keithmo)           15-Dec-1998 (ul.sys)
    Paul McDaniel (paulmcd)         07-Mar-2000

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//

#define EA_BUFFER_LENGTH                                                    \
    ( sizeof(FILE_FULL_EA_INFORMATION) +                                    \
      SR_OPEN_PACKET_NAME_LENGTH +                                          \
      sizeof(SR_OPEN_PACKET) )


//
// Private prototypes.
//

NTSTATUS
SrpAcquireCachedEvent(
    OUT PHANDLE pEvent
    );

VOID
SrpReleaseCachedEvent(
    IN HANDLE Event
    );


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Synchronous wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpSynchronousDeviceControl(
    IN HANDLE FileHandle,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE event;
    LARGE_INTEGER timeout;

    //
    // Try to snag an event object.
    //

    status = SrpAcquireCachedEvent( &event );

    if (NT_SUCCESS(status))
    {
        //
        // Make the call.
        //

        status = NtDeviceIoControlFile(
                        FileHandle,                     // FileHandle
                        event,                          // Event
                        NULL,                           // ApcRoutine
                        NULL,                           // ApcContext
                        &ioStatusBlock,                 // IoStatusBlock
                        IoControlCode,                  // IoControlCode
                        pInputBuffer,                   // InputBuffer
                        InputBufferLength,              // InputBufferLength
                        pOutputBuffer,                  // OutputBuffer
                        OutputBufferLength              // OutputBufferLength
                        );

        if (status == STATUS_PENDING)
        {
            //
            // Wait for it to complete.
            //

            timeout.LowPart = 0xFFFFFFFF;
            timeout.HighPart = 0x7FFFFFFF;

            status = NtWaitForSingleObject( event, FALSE, &timeout );
            ASSERT( status == STATUS_SUCCESS );

            status = ioStatusBlock.Status;
        }

        //
        // If the call didn't fail and the caller wants the number
        // of bytes transferred, grab the value from the I/O status
        // block & return it.
        //

        if (!NT_ERROR(status) && pBytesTransferred != NULL)
        {
            *pBytesTransferred = (ULONG)ioStatusBlock.Information;
        }

        //
        // Release the cached event object we acquired above.
        //

        SrpReleaseCachedEvent( event );
    }

    return status;

}   // SrpSynchronousDeviceControl


/***************************************************************************++

Routine Description:

    Overlapped wrapper around NtDeviceIoControlFile().

Arguments:

    FileHandle - Supplies a handle to the file on which the service is
        being performed.

    pOverlapped - Supplies an OVERLAPPED structure.

    IoControlCode - Subfunction code to determine exactly what operation
        is being performed.

    pInputBuffer - Optionally supplies an input buffer to be passed to the
        device driver. Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the pInputBuffer in bytes.

    pOutputBuffer - Optionally supplies an output buffer to receive
        information from the device driver. Whether or not the buffer is
        actually optional is dependent on the IoControlCode.

    OutputBufferLength - Length of the pOutputBuffer in bytes.

    pBytesTransferred - Optionally receives the number of bytes transferred.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    )
{
    NTSTATUS status;

    //
    // Overlapped I/O gets a little more interesting. We'll strive to be
    // compatible with NT's KERNEL32 implementation. See DeviceIoControl()
    // in \\rastaman\ntwin\src\base\client\filehops.c for the gory details.
    //

    OVERLAPPED_TO_IO_STATUS(pOverlapped)->Status = STATUS_PENDING;

    status = NtDeviceIoControlFile(
                    FileHandle,                         // FileHandle
                    pOverlapped->hEvent,                // Event
                    NULL,                               // ApcRoutine
                    (ULONG_PTR)pOverlapped->hEvent & 1  // ApcContext
                        ? NULL : pOverlapped,
                    OVERLAPPED_TO_IO_STATUS(pOverlapped), // IoStatusBlock
                    IoControlCode,                      // IoControlCode
                    pInputBuffer,                       // InputBuffer
                    InputBufferLength,                  // InputBufferLength
                    pOutputBuffer,                      // OutputBuffer
                    OutputBufferLength                  // OutputBufferLength
                    );

    //
    // If the call didn't fail or pend and the caller wants the number of
    // bytes transferred, grab the value from the I/O status block &
    // return it.
    //

    if (!NT_ERROR(status) &&
            status != STATUS_PENDING &&
            pBytesTransferred != NULL)
    {
        *pBytesTransferred =
            (ULONG)OVERLAPPED_TO_IO_STATUS(pOverlapped)->Information;
    }

    return status;

}   // SrpOverlappedDeviceControl


/***************************************************************************++

Routine Description:

    Initializes the event object cache.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
SrpInitializeEventCache(
    VOID
    )
{
    //
    // CODEWORK: MAKE THIS CACHED!
    //

    return NO_ERROR;

}   // SrpInitializeEventCache


/***************************************************************************++

Routine Description:

    Terminates the event object cache.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
SrpTerminateEventCache(
    VOID
    )
{
    //
    // CODEWORK: MAKE THIS CACHED!
    //

    return NO_ERROR;

}   // SrpTerminateEventCache


/***************************************************************************++

Routine Description:

    This routine attempts to start UL.SYS.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--***************************************************************************/
BOOLEAN
SrpTryToStartDriver(
    VOID
    )
{
    BOOLEAN result;
    SC_HANDLE scHandle;
    SC_HANDLE svcHandle;

    result = FALSE; // until proven otherwise...

    //
    // Open the service controller.
    //

    scHandle = OpenSCManagerW(
                   NULL,                        // lpMachineName
                   NULL,                        // lpDatabaseName
                   SC_MANAGER_ALL_ACCESS        // dwDesiredAccess
                   );

    if (scHandle != NULL)
    {
        //
        // Try to open the UL service.
        //

        svcHandle = OpenServiceW(
                        scHandle,               // hSCManager
                        SR_SERVICE_NAME,        // lpServiceName
                        SERVICE_ALL_ACCESS      // dwDesiredAccess
                        );

        if (svcHandle != NULL)
        {
            //
            // Try to start it.
            //

            if (StartService( svcHandle, 0, NULL))
            {
                result = TRUE;
            }

            CloseServiceHandle( svcHandle );
        }

        CloseServiceHandle( scHandle );
    }

    return result;

}   // SrpTryToStartDriver


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Helper routine for opening a UL.SYS handle.

Arguments:

    pHandle - Receives a handle if successful.

    DesiredAccess - Supplies the types of access requested to the file.

    AppPool - Supplies TRUE to open/create an application pool, FALSE
        to open a control channel.

    pAppPoolName - Optionally supplies the name of the application pool
        to create/open.

    Options - Supplies zero or more UL_OPTION_* flags.

    CreateDisposition - Supplies the creation disposition for the new
        object.

    pSecurityAttributes - Optionally supplies security attributes for
        the newly created application pool. Ignored if opening a
        control channel.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpOpenDriverHelper(
    OUT PHANDLE pHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    IN ULONG CreateDisposition,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG shareAccess;
    ULONG createOptions;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    PSR_OPEN_PACKET pOpenPacket;
    WCHAR deviceNameBuffer[MAX_PATH];
    UCHAR rawEaBuffer[EA_BUFFER_LENGTH];

    //
    // Validate the parameters.
    //

    if ((pHandle == NULL) ||
        (Options & ~SR_OPTION_VALID))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Build the open packet.
    //

    pEaBuffer = (PFILE_FULL_EA_INFORMATION)rawEaBuffer;

    pEaBuffer->NextEntryOffset = 0;
    pEaBuffer->Flags = 0;
    pEaBuffer->EaNameLength = SR_OPEN_PACKET_NAME_LENGTH;
    pEaBuffer->EaValueLength = sizeof(*pOpenPacket);

    RtlCopyMemory(
        pEaBuffer->EaName,
        SR_OPEN_PACKET_NAME,
        SR_OPEN_PACKET_NAME_LENGTH + 1
        );

    pOpenPacket =
        (PSR_OPEN_PACKET)( pEaBuffer->EaName + pEaBuffer->EaNameLength + 1 );

    pOpenPacket->MajorVersion = SR_INTERFACE_VERSION_MAJOR;
    pOpenPacket->MinorVersion = SR_INTERFACE_VERSION_MINOR;

    //
    // Build the device name.
    //

    //
    // It's a control channel, so just use the appropriate device name.
    //

    wcscpy( deviceNameBuffer, SR_CONTROL_DEVICE_NAME );

    //
    // Determine the share access and create options based on the
    // Flags parameter.
    //

    shareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
    createOptions = 0;

    if ((Options & SR_OPTION_OVERLAPPED) == 0)
    {
        createOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
    }

    //
    // Build the object attributes.
    //

    RtlInitUnicodeString( &deviceName, deviceNameBuffer );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        NULL,                                   // RootDirectory
        NULL,                                   // SecurityDescriptor
        );

    if (pSecurityAttributes != NULL)
    {
        objectAttributes.SecurityDescriptor =
            pSecurityAttributes->lpSecurityDescriptor;

        if (pSecurityAttributes->bInheritHandle)
        {
            objectAttributes.Attributes |= OBJ_INHERIT;
        }
    }

    //
    // Open the SR device.
    //

    status = NtCreateFile(
                pHandle,                        // FileHandle
                DesiredAccess,                  // DesiredAccess
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                shareAccess,                    // ShareAccess
                CreateDisposition,              // CreateDisposition
                createOptions,                  // CreateOptions
                pEaBuffer,                      // EaBuffer
                EA_BUFFER_LENGTH                // EaLength
                );

    if (!NT_SUCCESS(status))
    {
        *pHandle = NULL;
    }

    return status;

}   // SrpOpenDriverHelper


/***************************************************************************++

Routine Description:

    Acquires a short-term event from the global event cache. This event
    object may only be used for pseudo-synchronous I/O.

Arguments:

    pEvent - Receives the event handle.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrpAcquireCachedEvent(
    OUT PHANDLE pEvent
    )
{
    NTSTATUS status;

    //
    // CODEWORK: MAKE THIS CACHED!
    //

    status = NtCreateEvent(
                 pEvent,                            // EventHandle
                 EVENT_ALL_ACCESS,                  // DesiredAccess
                 NULL,                              // ObjectAttributes
                 SynchronizationEvent,              // EventType
                 FALSE                              // InitialState
                 );

    return status;

}   // SrpAcquireCachedEvent


/***************************************************************************++

Routine Description:

    Releases a cached event acquired via SrpAcquireCachedEvent().

Arguments:

    Event - Supplies the event to release.

--***************************************************************************/
VOID
SrpReleaseCachedEvent(
    IN HANDLE Event
    )
{
    NTSTATUS status;

    //
    // CODEWORK: MAKE THIS CACHED!
    //

    status = NtClose( Event );
    ASSERT( NT_SUCCESS(status) );

}   // SrpReleaseCachedEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\api\notify.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    notify.c

Abstract:

    User-mode interface to UL.SYS.

Author:

    Paul McDaniel (paulmcd)     07-Mar-2000

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:


    SrWaitForNotificaiton is used to receive volume activity notifications 
    from the driver.  This includes new volume, delete volume, and out of disk
    space for a volume.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

    pNotification - the buffer to hold the NOTIFICATION_RECORD.

    NotificationLength - the length in bytes of pNotification

    pOverlapped - an OVERLAPPED structure if async io is enabled on the 
        HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrWaitForNotification(
    IN HANDLE ControlHandle,
    OUT PSR_NOTIFICATION_RECORD pNotification,
    IN ULONG NotificationLength,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    NTSTATUS Status;

#if DBG
    RtlFillMemory( pNotification, NotificationLength, '\xcc' );
#endif

    //
    // Make the request.
    //

    if (pOverlapped == NULL)
    {
        Status = SrpSynchronousDeviceControl(
                        ControlHandle,                  // FileHandle
                        IOCTL_SR_WAIT_FOR_NOTIFICATION, // IoControlCode
                        NULL,                           // pInputBuffer
                        0,                              // InputBufferLength
                        pNotification,                  // pOutputBuffer
                        NotificationLength,             // OutputBufferLength
                        NULL                            // pBytesTransferred
                        );
    }
    else
    {
        Status = SrpOverlappedDeviceControl(
                        ControlHandle,                  // FileHandle
                        pOverlapped,                    // pOverlapped
                        IOCTL_SR_WAIT_FOR_NOTIFICATION, // IoControlCode
                        NULL,                           // pInputBuffer
                        0,                              // InputBufferLength
                        pNotification,                  // pOutputBuffer
                        NotificationLength,             // OutputBufferLength
                        NULL                            // pBytesTransferred
                        );
    }

    return SrpNtStatusToWin32Status( Status );

}   // SrWaitForNotification


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\api\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for ULAPI.LIB user-mode interface to UL.SYS.

Author:

    Keith Moore (keithmo)        15-Dec-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <srapi.h>


//
// Private macros.
//

#define ALLOC_MEM(cb) RtlAllocateHeap( RtlProcessHeap(), 0, (cb) )
#define FREE_MEM(ptr) RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )

#define ALIGN_DOWN(length, type)                                            \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type)                                              \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define OVERLAPPED_TO_IO_STATUS( pOverlapped )                              \
    ((PIO_STATUS_BLOCK)&(pOverlapped)->Internal)

#define DIMENSION( array )                                                  \
    ( sizeof(array) / sizeof((array)[0]) )


//
// Private prototypes.
//

#define SrpNtStatusToWin32Status( Status )                                  \
    ( ( (Status) == STATUS_SUCCESS )                                        \
          ? NO_ERROR                                                        \
          : RtlNtStatusToDosError( Status ) )

NTSTATUS
SrpOpenDriverHelper(
    OUT PHANDLE pHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    IN ULONG CreateDisposition,
    IN PSECURITY_ATTRIBUTES pSecurityAttributes OPTIONAL
    );

NTSTATUS
SrpSynchronousDeviceControl(
    IN HANDLE FileHandle,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

NTSTATUS
SrpOverlappedDeviceControl(
    IN HANDLE FileHandle,
    IN OUT LPOVERLAPPED pOverlapped,
    IN ULONG IoControlCode,
    IN PVOID pInputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID pOutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG pBytesTransferred OPTIONAL
    );

ULONG
SrpInitializeEventCache(
    VOID
    );

ULONG
SrpTerminateEventCache(
    VOID
    );

BOOLEAN
SrpTryToStartDriver(
    VOID
    );


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\api\control.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    control.c

Abstract:

    User-mode interface to SR.SYS.

Author:

    Keith Moore (keithmo)       15-Dec-1998
    Paul McDaniel (paulmcd)     07-Mar-2000 (sr)

Revision History:

--*/


#include "precomp.h"


//
// Private macros.
//


//
// Private prototypes.
//


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Opens a control channel to SR.SYS.

Arguments:

    Options - Supplies zero or more SR_OPTION_* flags.
    
    pControlHandle - Receives a handle to the control channel if successful.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrCreateControlHandle(
    IN  ULONG Options,
    OUT PHANDLE pControlHandle
    )
{
    NTSTATUS status;

    //
    // First, just try to open the driver.
    //

    status = SrpOpenDriverHelper(
                    pControlHandle,             // pHandle
                    GENERIC_READ |              // DesiredAccess
                        GENERIC_WRITE |
                        SYNCHRONIZE,
                    Options,                    // Options
                    FILE_OPEN,                  // CreateDisposition
                    NULL                        // pSecurityAttributes
                    );

    //
    // If we couldn't open the driver because it's not running, then try
    // to start the driver & retry the open.
    //

    if (status == STATUS_OBJECT_NAME_NOT_FOUND ||
        status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        if (SrpTryToStartDriver())
        {
            status = SrpOpenDriverHelper(
                            pControlHandle,     // pHandle
                            GENERIC_READ |      // DesiredAccess
                                GENERIC_WRITE |
                                SYNCHRONIZE,
                            Options,            // Options
                            FILE_OPEN,          // CreateDisposition
                            NULL                // pSecurityAttributes
                            );
        }
    }

    return SrpNtStatusToWin32Status( status );

}   // SrCreateControlHandle


/***************************************************************************++

Routine Description:

    SrCreateRestorePoint is called by the controlling application to declare
    a new restore point.  The driver will create a local restore directory
    and then return a unique sequence number to the controlling app.

Arguments:

    ControlHandle - the control HANDLE.

    pNewSequenceNumber - holds the new sequnce number on return.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrCreateRestorePoint(
    IN HANDLE ControlHandle,
    OUT PULONG pNewRestoreNumber
    )
{
    NTSTATUS Status;
    
    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_CREATE_RESTORE_POINT, // IoControlCode
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     pNewRestoreNumber, // pOutputBuffer
                                     sizeof(ULONG),     // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );

}   // SrCreateRestorePoint

/***************************************************************************++

Routine Description:

    SrGetNextSequenceNum is called by the application to get the next
    available sequence number from the driver.

Arguments:

    ControlHandle - the control HANDLE.

    pNewSequenceNumber - holds the new sequnce number on return.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrGetNextSequenceNum(
    IN HANDLE ControlHandle,
    OUT PINT64 pNextSequenceNum
    )
{
    NTSTATUS Status;
    
    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_GET_NEXT_SEQUENCE_NUM, 
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     pNextSequenceNum, // pOutputBuffer
                                     sizeof(INT64),     // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );

}   // SrCreateRestorePoint



/***************************************************************************++

Routine Description:

    SrReloadConfiguration causes the driver to reload it's configuration 
    from it's configuration file that resides in a preassigned location.
    A controlling service can update this file, then alert the driver to 
    reload it.

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrReloadConfiguration(
    IN HANDLE ControlHandle
    )
{
    NTSTATUS Status;
    
    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_RELOAD_CONFIG, // IoControlCode
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     NULL,      // pOutputBuffer
                                     0,         // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );

}   // SrReloadConfiguration


/***************************************************************************++

Routine Description:

    SrStopMonitoring will cause the driver to stop monitoring file changes.
    The default state of the driver on startup is to monitor file changes.

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrStopMonitoring(
    IN HANDLE ControlHandle
    )
{
    NTSTATUS Status;
    
    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_STOP_MONITORING, // IoControlCode
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     NULL,      // pOutputBuffer
                                     0,         // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );

}   // SrStopMonitoring

/***************************************************************************++

Routine Description:

    SrStartMonitoring will cause the driver to start monitoring file changes.
    The default state of the driver on startup is to monitor file changes.
    This api is only needed in the case that the controlling application has 
    called SrStopMonitoring and wishes to restart it.

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrStartMonitoring(
    IN HANDLE ControlHandle
    )
{
    NTSTATUS Status;
    
    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_START_MONITORING, // IoControlCode
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     NULL,      // pOutputBuffer
                                     0,         // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );

}   // SrStartMonitoring

/***************************************************************************++

Routine Description:

    SrDisableVolume is used to temporarily disable monitoring on the 
    specified volume.  this is reset by a call to SrReloadConfiguration.
    There is no EnableVolume.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

    pVolumeName - the name of the volume to disable, in the nt format of 
        \Device\HarddiskDmVolumes\PhysicalDmVolumes\BlockVolume3.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrDisableVolume(
    IN HANDLE ControlHandle,
    IN PWSTR pVolumeName
    )
{
    NTSTATUS Status;

    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_DISABLE_VOLUME, // IoControlCode
                                     pVolumeName,// pInputBuffer
                                     (lstrlenW(pVolumeName)+1)*sizeof(WCHAR),// InputBufferLength
                                     NULL,      // pOutputBuffer
                                     0,         // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );
    
}   // SrDisableVolume

/***************************************************************************++

Routine Description:

    SrSwitchAllLogs is used to cause the filter to close all of the open
    log files on all volumes, and use new log files.  this is used so that
    another process can parse these files without worrying about the filter
    writing to them.  use this to get a consistent view of the restore point.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrSwitchAllLogs(
    IN HANDLE ControlHandle
    )
{
    NTSTATUS Status;

    //
    // Make the request.
    //

    Status = 
        SrpSynchronousDeviceControl( ControlHandle,       // FileHandle
                                     IOCTL_SR_SWITCH_LOG, // IoControlCode
                                     NULL,      // pInputBuffer
                                     0,         // InputBufferLength
                                     NULL,      // pOutputBuffer
                                     0,         // OutputBufferLength
                                     NULL );    // pBytesTransferred

    return SrpNtStatusToWin32Status( Status );
    
}   // SrSwitchAllLogs


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\datastor.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    datastor.cpp
 *
 *  Abstract:
 *    CDataStore class functions
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#include "datastor.h"
#include "datastormgr.h"
#include "enumlogs.h"
#include "srconfig.h"
#include "srapi.h"
#include "evthandler.h"
#include "..\snapshot\snappatch.h"
#include "NTServMsg.h"    // generated from the MC message compiler
#include "Accctrl.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

//
// The format for each line of the drive table
//
static WCHAR gs_wcsPrintFormat[] = L"%s/%s %x %i %i %s\r\n";

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::CDataStore
//
//  Synopsis:   Initialize an empty datastore object
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

CDataStore::CDataStore (CDriveTable *pdt)
{
    _pwszDrive[0] = L'\0';
    _pwszGuid[0] = L'\0';
    _pwszLabel[0] = L'\0';
    _dwFlags = 0;

    _llDataStoreUsageBytes = -1;
    _llCurrentRpUsageBytes = 0;
    _llDataStoreSizeBytes = 0;
    _llDiskFreeBytes = 0;
    
    _prp = NULL;
    _prpe = NULL;
    _iChangeLogs = -1;
    _pdt = pdt;
}

CDataStore::~CDataStore()
{
    if (_prp != NULL)
        delete _prp;

    if (_prpe != NULL)
        delete _prpe;

    // we leave _pdt as a dangling reference,
    // since deleting _pdt will delete all child datastores
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::LoadDataStore
//
//  Synopsis:   Initialize a datastore object from a file
//
//  Arguments:  [pwszDrive] -- optional drive letter
//              [pwszGuid] -- mount manager GUID
//              [pwszLabel] -- optional volume label
//              [dwFlags] -- SR volume flags
//              [iChangeLogs] -- number of change logs
//              [llSizeLimit] -- datastore size limit
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::LoadDataStore (WCHAR *pwszDrive,
                WCHAR *pwszGuid,
                WCHAR *pwszLabel,
                DWORD dwFlags,
                int   iChangeLogs,
                INT64 llSizeLimit)
{
    if (pwszDrive != NULL)
    {
        if (lstrlen(pwszDrive) >= MAX_PATH)
            return ERROR_INVALID_PARAMETER;
        else
            lstrcpy (_pwszDrive, pwszDrive);
    }

    if (pwszGuid != NULL)
    {
        if (lstrlen(pwszGuid) >= GUID_STRLEN)
            return ERROR_INVALID_PARAMETER;
        else
            lstrcpy (_pwszGuid, pwszGuid);
    }

    if (pwszLabel != NULL)
    {
        if (lstrlen(pwszLabel) >= LABEL_STRLEN)
            return ERROR_INVALID_PARAMETER;
        else
            lstrcpy (_pwszLabel, pwszLabel);
    }

    _dwFlags = dwFlags;
    _prpe = NULL;
    _prp = NULL;
    _iChangeLogs = iChangeLogs;
    _llDataStoreSizeBytes = llSizeLimit;

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::GetVolumeInfo
//
//  Synopsis:   retrieves volume information
//
//  Arguments:
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::GetVolumeInfo ()
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsLabel [LABEL_STRLEN];
    DWORD dwSerial;
    DWORD dwFsFlags;

    TENTER ("CDataStore::GetVolumeInfo");

    // Get the volume label and flags
    if (TRUE == GetVolumeInformationW (_pwszGuid,
            wcsLabel, LABEL_STRLEN,
            &dwSerial, NULL, &dwFsFlags, NULL, 0))
    {
        lstrcpy (_pwszLabel, wcsLabel);

        if (dwFsFlags & FS_VOL_IS_COMPRESSED)
            _dwFlags |= SR_DRIVE_COMPRESSED;

        if (dwFsFlags & FS_PERSISTENT_ACLS)
            _dwFlags |= SR_DRIVE_NTFS;

        if (dwFsFlags & FILE_READ_ONLY_VOLUME)
            _dwFlags |= SR_DRIVE_READONLY;
    }
    else
    {
        dwErr = GetLastError();
        TRACE(0, "! CDataStore::GetVolumeInfo : %ld", dwErr);
    }

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::Initialize
//
//  Synopsis:   Initialize a datastore object
//
//  Arguments:  [pwszDrive] -- drive letter or mount point
//              [pwszGuid] -- volume GUID
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::Initialize(WCHAR *pwszDrive, WCHAR *pwszGuid)
{
    TENTER("CDataStore::Initialize");

    ULARGE_INTEGER ulTotalFreeBytes;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS nts;
    HANDLE h = INVALID_HANDLE_VALUE;
    WCHAR wcsBuffer[MAX_PATH]; 
    
    if (pwszDrive == NULL)
        return ERROR_INVALID_PARAMETER;

    if (pwszGuid == NULL)
    {
        if (!GetVolumeNameForVolumeMountPoint (pwszDrive, wcsBuffer, MAX_PATH))
        {
            dwErr = GetLastError();
            TRACE(0, "! CDataStore::Initialize GetVolumeNameForVolumeMountPoint"
                     " : %ld", dwErr);
            return dwErr;
        }
        pwszGuid = wcsBuffer;
    }

    if (lstrlen (pwszDrive) >= MAX_PATH ||
        lstrlen (pwszGuid)  >= GUID_STRLEN)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Err;
    }

    if (DRIVE_FIXED != GetDriveType (pwszDrive))
        return ERROR_BAD_DEV_TYPE;

    lstrcpy (_pwszDrive, pwszDrive);
    lstrcpy (_pwszGuid, pwszGuid);

    // Open a handle to the volume
    h = CreateFileW ( pwszGuid,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL );

    if (h == INVALID_HANDLE_VALUE) // The volume could be unformatted or locked
    {
        dwErr = GetLastError();
        TRACE(0, "! CDataStore::Initialize CreateFileW : %ld", dwErr);
        dwErr = ERROR_UNRECOGNIZED_VOLUME;
        goto Err;
    }

    dwErr = GetVolumeInfo ();
    if (dwErr != ERROR_SUCCESS)
        goto Err;

    if (IsSystemDrive (_pwszDrive))
    {
        _dwFlags |= SR_DRIVE_SYSTEM;
    }

    _dwFlags |= SR_DRIVE_ACTIVE;
    _dwFlags |= SR_DRIVE_MONITORED;

Err:
    if (h != INVALID_HANDLE_VALUE)
        CloseHandle (h);

    TLEAVE();

    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStore::UpdateDiskFree
//
//  Synopsis:   calculates disk free and sets initial datastore size
//
//  Arguments:  
//              
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------
DWORD
CDataStore::UpdateDiskFree(LONG_PTR lReserved)
{
    ULARGE_INTEGER ulTotalFreeBytes, ulTotalBytes;
    DWORD          dwErr = ERROR_SUCCESS;
    const BOOL     fSystem = _dwFlags & SR_DRIVE_SYSTEM;
    
    if (FALSE == GetDiskFreeSpaceEx (_pwszGuid, NULL, &ulTotalBytes, &ulTotalFreeBytes))
    {
        dwErr = GetLastError();
        goto Err;
    }
    
    if (g_pSRConfig != NULL)        
    {
        if (_llDataStoreSizeBytes == 0)
        {      
            // datastore size calculation
            // minimum = 50mb (non-system) or 200mb (system)
            // maximum = min (disksize, max(12%, 400mb))
            // actual ds size = calculated maximum
            
            INT64 llDSQuota = g_pSRConfig->m_dwDiskPercent * ulTotalBytes.QuadPart / 100;
            INT64 llDSMin   = (INT64) (g_pSRConfig->GetDSMin(fSystem));
            INT64 llDSMax   = min( ulTotalBytes.QuadPart, 
                                   max( llDSQuota, (INT64) g_pSRConfig->m_dwDSMax * MEGABYTE ) );
        
            if (llDSMax < llDSMin)
                llDSMax = llDSMin;

            //
            // take floor of this value
            //

            _llDataStoreSizeBytes = ((INT64) (llDSMax / (INT64) MEGABYTE)) * (INT64) MEGABYTE;
        }                                             
    }        
    else
    {
        _llDataStoreSizeBytes = SR_DEFAULT_DSMAX * MEGABYTE;
    }
    
    _llDiskFreeBytes = (INT64) ulTotalFreeBytes.QuadPart;
    
Err:
    return dwErr;        
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::UpdateParticipate
//
//  Synopsis:   updates participate bit
//
//  Arguments:
//
//  Returns:    boolean
//
//  History:    27-Apr-2000  brijeshk    Created
//
//----------------------------------------------------------------------------

DWORD
CDataStore::UpdateParticipate(LONG_PTR pwszDir)
{
    DWORD dwRc = ERROR_SUCCESS;
    
    if (! (_dwFlags & SR_DRIVE_PARTICIPATE))
    {
        WCHAR szPath[MAX_PATH];
        
        MakeRestorePath(szPath, _pwszDrive, (LPWSTR) pwszDir);
        if (-1 != GetFileAttributes(szPath))
        {
           dwRc = SetParticipate(TRUE);
        }
    }

    return dwRc;
}



//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::GetUsagePercent
//
//  Synopsis:   returns datastore usage in percentage
//
//  Arguments:
//
//  Returns:    error code
//
//  History:    27-Apr-2000  brijeshk    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::GetUsagePercent(int * pnPercent)
{
    TENTER("CDataStore::GetUsagePercent");
    
    DWORD   dwErr = ERROR_SUCCESS;
    INT64   llAdjustedSize;

    if (_llDataStoreUsageBytes == -1)  // not initialized yet
    {
        dwErr = CalculateDataStoreUsage (NULL);
        if (dwErr != ERROR_SUCCESS)
            goto done;
    }

    if (_llDiskFreeBytes + _llDataStoreUsageBytes + _llCurrentRpUsageBytes < _llDataStoreSizeBytes)
    {
        llAdjustedSize = _llDiskFreeBytes + _llDataStoreUsageBytes + _llCurrentRpUsageBytes;
    }
    else
    {
        llAdjustedSize = _llDataStoreSizeBytes;
    }

    
    if (llAdjustedSize)
    {
        *pnPercent = (int) ((_llDataStoreUsageBytes + _llCurrentRpUsageBytes) * 100/ llAdjustedSize);
    }
    else
    {
        *pnPercent = 0;
    }

    TRACE(0, "Datastore %S: Usage=%I64d, Size=%I64d, AdjustedSize=%I64d, Percentage=%d",
          _pwszDrive,
          _llDataStoreUsageBytes + _llCurrentRpUsageBytes,
          _llDataStoreSizeBytes,
          llAdjustedSize,
          *pnPercent);

done:
    TLEAVE();

    return dwErr;
}

DWORD CompressDir_Recurse (WCHAR *pwszPath, 
                           INT64 *pllDiff, 
                           INT64 llAllocatedTime,
                           ULARGE_INTEGER ulft1,
                           ULARGE_INTEGER& ulft2)
{
    TENTER ("CompressDir_Recurse");

    DWORD dwErr = ERROR_SUCCESS;
    WIN32_FIND_DATAW wfd;
    WCHAR wcsPath [MAX_PATH];
    WCHAR wcsSrch [MAX_PATH];

    if (lstrlenW(pwszPath) + 4 >= MAX_PATH)  // ignore paths too long
    {
        return ERROR_SUCCESS;
    }

    lstrcpy(wcsSrch, pwszPath);
    lstrcat(wcsSrch, L"\\*.*");
    
    HANDLE hFind = FindFirstFile (wcsSrch, &wfd);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        do
        {
            BOOL fDir = wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;
            if (!lstrcmp(wfd.cFileName, L".") ||
                !lstrcmp(wfd.cFileName, L"..") ||
                (wfd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ||
                (wfd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED))
            {
                continue;
            }

            if (lstrlenW(pwszPath) + lstrlenW(wfd.cFileName) + 1 >= MAX_PATH)
                continue;   // skip files that are too long

            lstrcpyW (wcsPath, pwszPath);
            lstrcatW (wcsPath, L"\\");
            lstrcatW (wcsPath, wfd.cFileName);

            if (fDir)
            {
                dwErr = CompressDir_Recurse (wcsPath, pllDiff, llAllocatedTime, ulft1, ulft2);
                if (dwErr != ERROR_SUCCESS)
                    break;
            }

            dwErr = CompressFile (wcsPath, TRUE, fDir);
            if (ERROR_SUCCESS != dwErr)
                break;

            if (!fDir)
            {
                LARGE_INTEGER ulBefore;
                ULARGE_INTEGER ulAfter;

                ulBefore.HighPart = wfd.nFileSizeHigh;
                ulBefore.LowPart = wfd.nFileSizeLow;

                ulAfter.LowPart = GetCompressedFileSize (wcsPath,
                                  &ulAfter.HighPart);
                if (ulAfter.LowPart == 0xFFFFFFFF)
                {
                    dwErr = GetLastError();
                    TRACE(0, "! GetCompressedFileSize : %ld", dwErr);
                    break;
                }

                *pllDiff += ulAfter.QuadPart - ulBefore.QuadPart;
            }

            FILETIME ft2;

            GetSystemTimeAsFileTime (&ft2);
            ulft2.LowPart = ft2.dwLowDateTime;
            ulft2.HighPart = ft2.dwHighDateTime;

            // check to see if we need to exit
            if (llAllocatedTime < ulft2.QuadPart - ulft1.QuadPart)
            {
                TRACE(0, "Timed out - aborting compression");
                dwErr = ERROR_OPERATION_ABORTED;
                break;
            }

            ASSERT(g_pSRConfig);
            if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
            {
                TRACE(0, "Stop signalled - aborting compression");
                dwErr = ERROR_OPERATION_ABORTED;
                break;
            }
        }
        while (FindNextFile (hFind, &wfd));
        FindClose (hFind);
    }

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::Compress
//
//  Synopsis:   compress a file in this datastore
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::Compress (INT64 llAllocatedTime, INT64 *pllUsed)
{
    TENTER ("CDataStore::Compress");

    if (g_pSRConfig != NULL &&
        TRUE == g_pSRConfig->GetSafeMode())  // do not compress in SafeMode
    {
        return ERROR_BAD_ENVIRONMENT;
    }

    if (_dwFlags & SR_DRIVE_READONLY)   // cannot compress read-only volumes
        return ERROR_SUCCESS;

    ULARGE_INTEGER ulft1, ulft2;
    FILETIME ft1, ft2;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsPath[MAX_PATH];

    GetSystemTimeAsFileTime (&ft1);
    ulft1.LowPart = ft1.dwLowDateTime;
    ulft1.HighPart = ft1.dwHighDateTime;

    ulft2.LowPart = ft1.dwLowDateTime;
    ulft2.HighPart = ft1.dwHighDateTime;
    
    if (_prp == NULL)
    {
        _prp = new CRestorePoint;
        if (_prp == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        _prpe = new CRestorePointEnum (_pwszDrive, TRUE, TRUE);
        if (_prpe == NULL)
        {
            delete _prp;
            _prp = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = _prpe->FindFirstRestorePoint( * _prp );
        if (dwErr != ERROR_SUCCESS)
        {
            dwErr = ERROR_SUCCESS;  // no restore points to compress
            goto Err;
        }
    }

	if (g_pSRConfig->m_dwTestBroadcast)
	    PostTestMessage(g_pSRConfig->m_uiTMCompressStart, (WPARAM) _pwszDrive[0], NULL);
        
    do
    {        
        MakeRestorePath(wcsPath, _pwszDrive, _prp->GetDir());        
        
        //
        // patch the snapshot directory on system drive
        //

        // BUGBUG - add a time restriction to this
        // and factor this into the compression time allocated
        
        if (_dwFlags & SR_DRIVE_SYSTEM)
        {
            WCHAR wcsSnapshot[MAX_PATH];
            
            lstrcpy(wcsSnapshot, wcsPath);
            lstrcat(wcsSnapshot, L"\\snapshot");            
            
            dwErr = PatchComputePatch(wcsSnapshot);
            if (dwErr != ERROR_SUCCESS)
            {
                trace(0, "! PatchComputePatch : %ld", dwErr);
                goto Err;
            }
        }
            
                
        if (_dwFlags & SR_DRIVE_NTFS)  // use NTFS compression
        {


            INT64 llDiff = 0;
            DWORD dwAttrs = GetFileAttributes(wcsPath);

            if (-1 == dwAttrs || !(FILE_ATTRIBUTE_COMPRESSED & dwAttrs))
                dwErr = CompressDir_Recurse (wcsPath, &llDiff, llAllocatedTime, ulft1, ulft2);

            if (llDiff != 0)
            {
                INT64 llSize = 0;
                if (ERROR_SUCCESS == _prp->ReadSize (_pwszDrive, &llSize ))
                    _prp->WriteSize (_pwszDrive, llSize + llDiff);

                if (_llDataStoreUsageBytes != -1)     // counter initialized
                    _llDataStoreUsageBytes += llDiff;
            }

            if (ERROR_SUCCESS == dwErr) // mark restore point as compressed
            {
                dwErr = CompressFile (wcsPath, TRUE, TRUE);
            }

            // check to see if we need to exit
            if (ERROR_SUCCESS != dwErr && ERROR_OPERATION_ABORTED != dwErr)
                break;
        }
    }
    while (dwErr != ERROR_OPERATION_ABORTED && ERROR_SUCCESS == _prpe->FindNextRestorePoint ( * _prp ));

    *pllUsed = ulft2.QuadPart - ulft1.QuadPart;
    trace(0, "Compression on drive %S used up %I64d", _pwszDrive, *pllUsed);

	if (g_pSRConfig->m_dwTestBroadcast)
	    PostTestMessage(g_pSRConfig->m_uiTMCompressStop, (WPARAM) _pwszDrive[0], NULL);

Err:
    if (ERROR_SUCCESS == dwErr)  // if we finished everything
    {
        delete _prpe;
        _prpe = NULL;

        delete _prp;
        _prp = NULL;
    }
    
    TLEAVE();

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::UpdateDataStoreUsage
//
//  Synopsis:   incremental update of usage byte count
//
//  Arguments:  [llDelta] -- add this amount to the total
//              [fCurrent] -- update current restore point's size
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::UpdateDataStoreUsage(INT64 llDelta, BOOL fCurrent)
{
    TENTER ("CDataStore::UpdateDataStoreUsage");
    DWORD dwErr = ERROR_SUCCESS;

    if (_llDataStoreUsageBytes != -1)  // counter is initialized
    {
        if (fCurrent)
        { 
            CRestorePoint   rpCur;

            _llCurrentRpUsageBytes += llDelta;
            if (_llCurrentRpUsageBytes < 0)
                _llCurrentRpUsageBytes = 0;

            CHECKERR(GetCurrentRestorePoint(rpCur),
             "GetCurrentRestorePoint");

            CHECKERR(rpCur.WriteSize(_pwszDrive, _llCurrentRpUsageBytes),
             "WriteSize");
        }
        else
        {
            _llDataStoreUsageBytes += llDelta;
            if (_llDataStoreUsageBytes < 0)
                _llDataStoreUsageBytes = 0;
        }
    }
    
Err:
    TLEAVE();
    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::CalculateRpUsage
//
//  Synopsis:   get disk space used by restore point on this volume
//
//  Arguments:  prp - pointer to restore point object
//              pllTemp - pointer to variable that stores calculated size
//              fForce - ignore existing restorepointsize file
//              fSnapshotOnly - calculate size of snapshot only
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------
DWORD CDataStore::CalculateRpUsage(
    CRestorePoint *prp, 
    INT64* pllTemp, 
    BOOL fForce, 
    BOOL fSnapshotOnly)
{
    TENTER("CDataStore::CalculateRpUsage");

    WCHAR wcsPath[MAX_PATH];
    DWORD dwErr = ERROR_SUCCESS;

    if (! fForce)
    {
        dwErr = prp->ReadSize(_pwszDrive, pllTemp);
    }
    
    if (fForce || dwErr != ERROR_SUCCESS)
    {
        //
        // recalculate size 
        // when a new restore point is created, only calculate
        // the snapshot size
        // filter will notify us at 25mb intervals
        // and we will accurately calculate the size when the restore
        // point is closed
        //
        
        MakeRestorePath(wcsPath, _pwszDrive, prp->GetDir());
        if (fSnapshotOnly)
        {
            lstrcat(wcsPath, L"\\snapshot");
        }
    
        *pllTemp = 0;
        dwErr = GetFileSize_Recurse (wcsPath, pllTemp,
                                     g_pDataStoreMgr->GetStopFlag());                                     

        if (dwErr == ERROR_PATH_NOT_FOUND)
        {
            dwErr = ERROR_SUCCESS;         
        }
        else
        {
            dwErr = prp->WriteSize(_pwszDrive, *pllTemp);
        }    
            
   }     

   return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::CalculateDataStoreUsage
//
//  Synopsis:   get disk space used by data store and volume
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::CalculateDataStoreUsage(LONG_PTR lReserved)
{
    TENTER ("CDataStore::CalculateDataStoreUsage");

    DWORD dwErr = ERROR_SUCCESS;

    CRestorePointEnum rpe (_pwszDrive, TRUE, TRUE);  // enum forward, skipping current
    CRestorePoint rp;

    _llDataStoreUsageBytes = 0;
    
    dwErr = rpe.FindFirstRestorePoint(rp);

    while (ERROR_SUCCESS == dwErr || dwErr == ERROR_FILE_NOT_FOUND)
    {
        INT64 llTemp = 0;    
        
        CHECKERR(
            CalculateRpUsage(
                &rp, 
                &llTemp, 
                FALSE,      // don't force
                FALSE),     // everything
            "CalculateRpUsage");
        
        _llDataStoreUsageBytes += llTemp;
        
        dwErr = rpe.FindNextRestorePoint (rp);
    }

    rpe.FindClose ();    

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = ERROR_SUCCESS;

    // 
    // get the size of the current restore point 
    // 
    
    CHECKERR(GetCurrentRestorePoint(rp),
             "GetCurrentRestorePoint");

    CHECKERR(CalculateRpUsage(&rp,
                              &_llCurrentRpUsageBytes,
                              FALSE,
                              FALSE),
             "CalculateRpUsage");
        
Err:
    TLEAVE();

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::CreateDataStore
//
//  Synopsis:   create the _restore directory and pertinent files
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::CreateDataStore (LONG_PTR lReserved)
{
    TENTER("CDataStore::CreateDataStore");

    ULARGE_INTEGER ulTotalFreeBytes;
    SECURITY_ATTRIBUTES *psa = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwAttrs = 0;
    WCHAR wcsPath[MAX_PATH];

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    SID *pSid = NULL;

    if (_dwFlags & SR_DRIVE_NTFS)
    {
        struct
        {
            ACL acl;                          // the ACL header
            BYTE rgb[ 128 - sizeof(ACL) ];     // buffer to hold 2 ACEs
        } DaclBuffer;

        SID_IDENTIFIER_AUTHORITY SaNT = SECURITY_NT_AUTHORITY;

        if (!InitializeAcl(&DaclBuffer.acl, sizeof(DaclBuffer), ACL_REVISION))
        {
            dwErr = GetLastError();
            goto Err;
        }

        // Create the SID.  We'll give the local system full access

        if( !AllocateAndInitializeSid( &SaNT,  // Top-level authority
                                   1, SECURITY_LOCAL_SYSTEM_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   (void **) &pSid ))
        {
            dwErr = GetLastError();
            TRACE(0, "! AllocateAndInitializeSid : %ld", dwErr);
            goto Err;
        }


        if (!AddAccessAllowedAce( &DaclBuffer.acl,
                              ACL_REVISION,
                              STANDARD_RIGHTS_ALL | GENERIC_ALL,
                              pSid ))
        {
            dwErr = GetLastError();
            TRACE(0, "! AddAccessAllowedAce : %ld", dwErr);
            goto Err;
        }


        // Set up the security descriptor with that DACL in it.

        if (!InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION ))
        {
            dwErr = GetLastError();
            TRACE(0, "! InitializeSecurityDescriptor : %ld", dwErr);
            goto Err;
        }

        if( !SetSecurityDescriptorDacl( &sd, TRUE, &DaclBuffer.acl, FALSE ))
        {
            dwErr = GetLastError();
            TRACE(0, "! SetSecurityDescriptorDacl : %ld", dwErr);
            goto Err;
        }


        // Put the security descriptor into the security attributes.

        ZeroMemory (&sa, sizeof(sa));
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = TRUE;

        psa = &sa;

    }
    

    // create "System Volume Information" if it does not exist
    // set "system only" dacl on this directory
    // make this S+H+non-CI
    
    wsprintf(wcsPath, L"%s%s", _pwszDrive, s_cszSysVolInfo);    
    if (-1 == GetFileAttributes(wcsPath))
    {
        if (FALSE == CreateDirectoryW(wcsPath, psa))
        {
            dwErr = GetLastError();
            TRACE(0, "! CreateDirectoryW for %s : %ld", wcsPath, dwErr);
            goto Err;
        }

        if (FALSE == SetFileAttributesW (wcsPath,
                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM))  
        {
            dwErr = GetLastError();
            TRACE(0, "! SetFileAttributes for %s : %ld", wcsPath, dwErr);
            goto Err;
        }         
    }

    // now create our _Restore directory
    // don't put any dacl on it
    
    MakeRestorePath (wcsPath, _pwszDrive, L"");    

    dwAttrs = GetFileAttributes(wcsPath);
    if (-1 != dwAttrs && !(FILE_ATTRIBUTE_DIRECTORY & dwAttrs))
    {
        DeleteFileW (wcsPath);  // try deleting the file
    }

    if (FALSE == CreateDirectoryW (wcsPath, NULL))
    {
        dwErr = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            TRACE(0, "! CreateDataStore CreateDirectoryW : %ld", dwErr);
            goto Err;
        }
    }

    if (_dwFlags & SR_DRIVE_NTFS)
    {
        dwErr = SetCorrectACLOnDSRoot(wcsPath);
        if (dwErr != ERROR_SUCCESS)
        {
            TRACE(0, "! SetAclInNamedObject : %ld", dwErr);
            goto Err;            
        }
    }
    
    // 
    // let's keep the datastore uncompressed
    // so that filter can make quicker unbuffered copies
    // 

#if 0
    // If the datastore is marked uncompressed, mark it compressed
    //
    if (_dwFlags & SR_DRIVE_NTFS)
    {
        dwAttrs = GetFileAttributesW (wcsPath);
        if (dwAttrs != INVALID_FILE_SIZE && 
            0 == (FILE_ATTRIBUTE_COMPRESSED & dwAttrs))
        {
            dwErr = CompressFile ( wcsPath, TRUE, TRUE );
        
            if (dwErr != ERROR_SUCCESS)
            {
                TRACE(0, "! CreateDataStore CompressFile : %ld", dwErr);
                goto Err;
            }
        }
    }
#endif 
    
    if (FALSE == SetFileAttributesW (wcsPath,
                FILE_ATTRIBUTE_NOT_CONTENT_INDEXED |
                FILE_ATTRIBUTE_HIDDEN |
                FILE_ATTRIBUTE_SYSTEM))
    {
        dwErr = GetLastError();
        TRACE(0, "! CreateDataStore SetFileAttributesW : %ld", dwErr);
    }

Err:
    if (pSid != NULL)
        FreeSid (pSid);

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::DestroyDataStore
//
//  Synopsis:   remove the _restore directory and pertinent files
//
//  Arguments:  [fDeleteDir] -- TRUE if deleting parent directory
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::DestroyDataStore (LONG_PTR fDeleteDir)
{
    TENTER("CDataStore::DestroyDataStore");

    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsPath[MAX_PATH];

    MakeRestorePath (wcsPath, _pwszDrive, L"");

    // delete the restore directory
    dwErr = Delnode_Recurse (wcsPath, (BOOL) fDeleteDir,
                             g_pDataStoreMgr->GetStopFlag());

    if (_dwFlags & SR_DRIVE_SYSTEM)
    {
        g_pDataStoreMgr->DeleteMachineGuidFile();
    }

    if (ERROR_SUCCESS == dwErr)
    {
        _llDataStoreUsageBytes = 0;
        _llCurrentRpUsageBytes = 0;
    }

    TLEAVE();

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::MonitorDrive
//
//  Synopsis:   tell the filter to start/stop monitoring this drive
//
//  Arguments:  [fStart] -- TRUE start monitoring, FALSE stop monitoring
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::MonitorDrive (LONG_PTR fSet)
{
    DWORD dwRc = ERROR_SUCCESS;
    HANDLE hEventSource = NULL;
    
    TENTER("CDataStore::MonitorDrive");
    
    if (!fSet)
    {
        // if the drive is already disabled, then no op
        
        if (! (_dwFlags & SR_DRIVE_MONITORED))
            goto done;
        
        dwRc = SrDisableVolume(g_pSRConfig->GetFilter(), GetNTName());
        if (dwRc != ERROR_SUCCESS)
            goto done;

        _dwFlags &= ~SR_DRIVE_MONITORED;

        // reset any per-rp flags as well
        ResetFlags(NULL);
        
        dwRc = DestroyDataStore(TRUE);
    }
    else
    {
        // if the drive is already enabled, then no op
        
        if (_dwFlags & SR_DRIVE_MONITORED)
        {
            dwRc = ERROR_SERVICE_ALREADY_RUNNING;
            goto done;
        }
        
        _dwFlags |= SR_DRIVE_MONITORED;    

        // reset any per-rp flags as well
        ResetFlags(NULL);        
    }

    DirtyDriveTable();

    trace(0, "****%S drive %S****", fSet ? L"Enabled" : L"Disabled", _pwszDrive);
    
    hEventSource = RegisterEventSource(NULL, s_cszServiceName);
    if (hEventSource != NULL)
    {
        SRLogEvent (hEventSource, EVENTLOG_INFORMATION_TYPE, fSet ? EVMSG_DRIVE_ENABLED : EVMSG_DRIVE_DISABLED,
           NULL, 0, _pwszDrive, NULL, NULL);
        DeregisterEventSource(hEventSource);
    }
    

    if (g_pSRConfig->m_dwTestBroadcast)
        PostTestMessage( fSet ? g_pSRConfig->m_uiTMEnable : g_pSRConfig->m_uiTMDisable,
                         (WPARAM) _pwszDrive[0], 
                         NULL);
    
done:
    TLEAVE();
    return dwRc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::FreezeDrive
//
//  Synopsis:   tell the filter to freeze this drive
//
//  Arguments:  
//
//  Returns:    Win32 error code
//
//  History:    04-Jun-2000  brijeshk    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::FreezeDrive (LONG_PTR lReserved)
{
    DWORD dwErr = ERROR_SUCCESS;

    TENTER("CDataStore::FreezeDrive");

    _dwFlags |= SR_DRIVE_FROZEN;  // freeze in spite of open file handles
    
    // if the drive is disabled, no op

    if (! (_dwFlags & SR_DRIVE_MONITORED))
        goto Err;

    //
    // check if the drive exists before calling the driver
    //

    if (0xFFFFFFFF == GetFileAttributes(_pwszGuid))
    {
        trace(0, "Drive %s does not exist", _pwszDrive);
        goto Err;
    }
                                           
    CHECKERR(SrDisableVolume(g_pSRConfig->GetFilter(), GetNTName()),
             "SrDisableVolume");            

    DestroyDataStore(FALSE);
             
    DirtyDriveTable();

    trace(0, "****Froze drive %S****", _pwszDrive);
        
Err:
    TLEAVE();
    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CDataStore::ThawDrive
//
//  Synopsis:   check and thaw this drive
//
//  Arguments:  
//
//  Returns:    Win32 error code
//
//  History:    04-Jun-2000  brijeshk    Created
//
//----------------------------------------------------------------------------
DWORD CDataStore::ThawDrive(LONG_PTR fCheckOnly)
{   
    DWORD           dwRc = ERROR_SUCCESS;

    TENTER("CDataStore::ThawDrive");    

    if (_dwFlags & SR_DRIVE_FROZEN) 
    {
        //Actually we want to clean up everything except for the
        //current restore point
        //dwRc = DestroyDataStore(FALSE);
        if (ERROR_SUCCESS == dwRc)
        {
            _dwFlags &= ~SR_DRIVE_FROZEN;    
            DirtyDriveTable();
            trace(0, "****Thawed drive %S****", _pwszDrive);                
        }
        else trace(0, "Cannot thaw %S error %d", _pwszDrive, dwRc);
    }
    
    TLEAVE();
    return dwRc;
}

//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::FifoRestorePoint
//
//  Synopsis:   fifo one restore point in this datastore
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  BrijeshK    Created
//
//----------------------------------------------------------------------------

DWORD
CDataStore::FifoRestorePoint(
    CRestorePoint& rp)
{
    TENTER("CDataStore::FifoRestorePoint");

    WCHAR szRpPath[MAX_PATH], szFifoedPath[MAX_PATH];
    INT64 llSize = 0;        
    DWORD dwRc;
    
    //
    // if patching is on, and this is a reference directory
    // for later snapshots, then don't fifo the snapshot folder
    // rename it to RefRPx, and keep it around
    // BUGBUG - how do we update size correctly ?
    //

    if (PatchGetPatchWindow() != 0)
    {
        // if Reference(RPx) == x, then x is a reference rp
        
        if (PatchGetReferenceRpNum(rp.GetNum()) == rp.GetNum())
        {
            WCHAR szRp[MAX_RP_PATH];

            MakeRestorePath(szRpPath, _pwszDrive, rp.GetDir());            
            lstrcat(szRpPath, SNAPSHOT_DIR_NAME);
            
            wsprintf(szRp, L"%s%ld", s_cszReferenceDir, rp.GetNum());            
            MakeRestorePath(szFifoedPath, _pwszDrive, szRp);                    
            CreateDirectory(szFifoedPath, NULL);
            
            lstrcat(szFifoedPath, SNAPSHOT_DIR_NAME);
            MoveFile(szRpPath, szFifoedPath);            
        }
    }
    
    // read the size of this restore point
    // but don't update the datastore size yet
    
    dwRc = rp.ReadSize(_pwszDrive, &llSize);


    // move the rp dir to a temp dir "Fifoed"
    // this is to make the fifo of a single rp atomic
    // to take care of unclean shutdowns

    MakeRestorePath(szRpPath, _pwszDrive, rp.GetDir());    
    MakeRestorePath(szFifoedPath, _pwszDrive, s_cszFifoedRpDir);

    if (! MoveFile(szRpPath, szFifoedPath))
    {
        dwRc = GetLastError();
        TRACE(0, "! MoveFile from %S to %S : %ld", szRpPath, szFifoedPath, dwRc);
        goto done;
    }


    // now examine the result of rp.ReadSize
    // and update the datastore usage variable
    
    if (ERROR_SUCCESS == dwRc)
    {        
        UpdateDataStoreUsage (-llSize, FALSE);
    }
    else
    {
        // ignore this error and continue

        TRACE(0, "! rp.ReadSize : %ld", dwRc);
    }


    // blow away the temp fifoed directory again
    
    dwRc = Delnode_Recurse(szFifoedPath, TRUE, 
                           g_pDataStoreMgr->GetStopFlag()); 
    if (ERROR_SUCCESS != dwRc)
    {
        TRACE(0, "! Delnode_Recurse : %ld", dwRc);
        goto done;
    }    
    
done:
    TLEAVE();
    return dwRc;
}


DWORD
CDataStore::Print(LONG_PTR lptr)
{	
	TENTER("CDataStore::Print");
	DWORD dwErr = ERROR_SUCCESS;
	DWORD cbWritten;
	HANDLE h = (HANDLE) lptr;
	
	WCHAR w[1024];
	
	wsprintf(w, L"Drive: %s,  Guid: %s\r\n", _pwszDrive, _pwszGuid);    	
    WriteFile (h, (BYTE *) w, lstrlen(w) * sizeof(WCHAR), &cbWritten, NULL);

	trace(0, "Drive: %S, Guid: %S", _pwszDrive, _pwszGuid);    	
	
	wsprintf(w, L"\t%s %s %s %s %s %s %s %s\r\n", 
			 _dwFlags & SR_DRIVE_ACTIVE ? L"Active, " : L"",
			 _dwFlags & SR_DRIVE_COMPRESSED ? L"Compressed, " : L"",
			 _dwFlags & SR_DRIVE_MONITORED ? L"Monitored, " : L"", 
			 _dwFlags & SR_DRIVE_NTFS ? L"NTFS, " : L"",
			 _dwFlags & SR_DRIVE_PARTICIPATE ? L"Participate, " : L"",
			 _dwFlags & SR_DRIVE_FROZEN ? L"Frozen, " : L"",
			 _dwFlags & SR_DRIVE_READONLY ? L"ReadOnly, " : L"",
			 _dwFlags & SR_DRIVE_ERROR ? L"Error" : L"");
    WriteFile (h, (BYTE *) w, lstrlen(w) * sizeof(WCHAR), &cbWritten, NULL);			 

	trace(0, "%S %S %S %S", _dwFlags & SR_DRIVE_ACTIVE ? L"Active, " : L"",
			 _dwFlags & SR_DRIVE_COMPRESSED ? L"Compressed, " : L"",
			 _dwFlags & SR_DRIVE_MONITORED ? L"Monitored, " : L"",
 			 _dwFlags & SR_DRIVE_NTFS ? L"NTFS, " : L"");

	trace(0, "%S %S	%S %S",	_dwFlags & SR_DRIVE_PARTICIPATE ? L"Participate, " : L"",
			 _dwFlags & SR_DRIVE_FROZEN ? L"Frozen, " : L"",
			 _dwFlags & SR_DRIVE_READONLY ? L"ReadOnly, " : L"",
			 _dwFlags & SR_DRIVE_ERROR ? L"Error" : L"");

	wsprintf(w, L"\tSize: %I64d,  Usage: %I64d,  Diskfree: %I64d\r\n\r\n", 
			 _llDataStoreSizeBytes,
			 _llDataStoreUsageBytes + _llCurrentRpUsageBytes,
			 _llDiskFreeBytes);			 
    WriteFile (h, (BYTE *) w, lstrlen(w) * sizeof(WCHAR), &cbWritten, NULL);	

    trace(0, "Size: %I64d,  Usage: %I64d,  Diskfree: %I64d",
  			 _llDataStoreSizeBytes,
			 _llDataStoreUsageBytes + _llCurrentRpUsageBytes,
			 _llDiskFreeBytes);	

	TLEAVE();
	return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::SaveDataStore
//
//  Synopsis:   save datastore info as a line in the drive table
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::SaveDataStore (LONG_PTR hFile)
{
    HANDLE h = (HANDLE) hFile;
    DWORD  dwErr = ERROR_SUCCESS;
    WCHAR  wcsBuffer[MAX_PATH * 2];
    DWORD  cbWritten = 0;

    wsprintf (wcsBuffer, gs_wcsPrintFormat,
                    GetDrive(), GetGuid(), _dwFlags, 
                    GetNumChangeLogs(), (DWORD) (GetSizeLimit() / (INT64) MEGABYTE),
                    GetLabel());

    if (FALSE == WriteFile (h, (BYTE *) wcsBuffer,
                    lstrlen(wcsBuffer) * sizeof(WCHAR), &cbWritten, NULL))
    {
        dwErr = GetLastError();
    }
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::DirtyDriveTable
//
//  Synopsis:   set the dirty bit in the drive table
//
//  Arguments:  
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::DirtyDriveTable ()
{
    if (_pdt != NULL)
        _pdt->SetDirty ();

    return ERROR_SUCCESS;
}



//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::SwitchRestorePoint
//
//  Synopsis:   change the drive table when switching restore points
//
//  Arguments:  pointer to restore point object
//
//  Returns:    Win32 error code
//
//  History:    14-Jun-2000  BrijeshK    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::SwitchRestorePoint(LONG_PTR pRestorePoint)
{
    TENTER("CDataStore::SwitchRestorePoint");
    
    CRestorePoint *prp = (CRestorePoint *) pRestorePoint;
    DWORD         dwErr = ERROR_SUCCESS;
    INT64         llTemp;
    
    if (prp)
    {
        // 
        // get the last restore point size - accurate
        //
        
        if (_llDataStoreUsageBytes != -1)  // initialized
        {
            CHECKERR(CalculateRpUsage(prp, 
                                  &_llCurrentRpUsageBytes, 
                                  TRUE,         // force calculation
                                  FALSE),       // everything
                 "CalculateRpUsage");                    


            _llDataStoreUsageBytes += _llCurrentRpUsageBytes;
            _llCurrentRpUsageBytes = 0;
        }
    }

    // 
    // get the size of the current snapshot 
    //

    if (_dwFlags & SR_DRIVE_SYSTEM)
    {
        CRestorePoint rpCur;
        
        CHECKERR(GetCurrentRestorePoint(rpCur),
                 "GetCurrentRestorePoint");

        CHECKERR(CalculateRpUsage(&rpCur,
                                  &_llCurrentRpUsageBytes,
                                  TRUE,
                                  TRUE),
                 "CalculateRpUsage");
    }    

Err:
    TLEAVE();
    return dwErr;
}




//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::CountChangeLogs
//
//  Synopsis:   counts the number of change logs & saves the drive table
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD CDataStore::CountChangeLogs (LONG_PTR pRestorePoint)
{
    CRestorePoint *prp = (CRestorePoint *) pRestorePoint;
    CFindFile ff;
    WIN32_FIND_DATA *pwfd = new WIN32_FIND_DATA;
    DWORD dwErr = ERROR_SUCCESS;
    int iCount = -1;
    CRestorePoint *pCurRp = NULL;

    if (! pwfd)
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto Err;
    }
    
    if (prp == NULL)
    {
        pCurRp = new CRestorePoint;
        if (! pCurRp)
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto Err;
        }
        
        dwErr = GetCurrentRestorePoint (*pCurRp);
        if (dwErr != ERROR_SUCCESS)
        {
            if (_dwFlags & SR_DRIVE_SYSTEM)
                goto Err;

            // This drive has no current restore point
            // It could have been re-formatted or placed in read-only mode
            // So assume no change logs are available 
            dwErr = ERROR_SUCCESS;
        }
        else prp = pCurRp;
    }

    if (prp != NULL)
    {
        LPWSTR pwcsPath = new WCHAR[MAX_PATH];
        if (! pwcsPath)
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto Err;
        }
        
        iCount = 0;        
        
        MakeRestorePath (pwcsPath, _pwszDrive, prp->GetDir());
        lstrcatW (pwcsPath, L"\\");
        lstrcatW (pwcsPath, s_cszChangeLogPrefix);

        if (TRUE == ff._FindFirstFile (pwcsPath, s_cszChangeLogSuffix, pwfd,
                                   FALSE, FALSE))                        
        do
        {
            iCount++;
        }
        while (ff._FindNextFile (pwcsPath, s_cszChangeLogSuffix, pwfd));

        delete [] pwcsPath;
    }

    dwErr = SetNumChangeLogs (iCount);

Err:
    if (pCurRp)
        delete pCurRp;

    if (pwfd)
        delete pwfd;
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::IsVolumeDeleted
//
//  Synopsis:   determines if this volume is no longer accessible
//
//  Arguments:
//
//  Returns:    TRUE if can be removed
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL CDataStore::IsVolumeDeleted ()
{
    WCHAR wszMount[MAX_PATH];
    DWORD dwChars = 0;
    DWORD dwFsFlags = 0;

    tenter("CDataStore::IsVolumeDeleted");
    
    // don't open the volume, since it could be locked for chkdsk

    if (FALSE == GetVolumePathNamesForVolumeNameW (_pwszGuid,
                                                   wszMount,
                                                   MAX_PATH,
                                                   &dwChars ))
    {
        if (GetLastError() != ERROR_MORE_DATA)
        {
            _dwFlags &= ~SR_DRIVE_ACTIVE;
            trace(0, "! GetVolumePathNamesForVolumeNameW : %ld", GetLastError());            
            return TRUE;
        }
    }

    if (L'\0' == wszMount[0])             // empty string, no mount point
    {
        _dwFlags &= ~SR_DRIVE_ACTIVE;
        trace(0, "! Empty mountpoint");
        return TRUE;
    }

    wszMount[MAX_PATH-1] = L'\0';
    
    if (lstrlenW (wszMount) > MAX_MOUNTPOINT_PATH)   // mountpoint too long
    {
        _dwFlags &= ~SR_DRIVE_ACTIVE;
        trace(0, "! Mountpoint too long");
        return TRUE;
    }

    // update the drive letter
    lstrcpyW (_pwszDrive, wszMount);  // copy the first string

    GetVolumeInfo ();  // get the latest volume flags if possible

    trace(0, "volume %S is active", wszMount);

    tleave();
    return FALSE;  // volume is still active
}

//+---------------------------------------------------------------------------
//
//  Functiion   CDataStore::GetNTName
//
//  Synopsis:   constructs the NT object name into a static buffer
//
//  Arguments:  (none) caller must take the datastore lock 
//
//  Returns:    pointer to string
//
//  History:    12-Apr-2000  HenryLee    Created
//
//----------------------------------------------------------------------------

WCHAR * CDataStore::GetNTName ()
{
    NTSTATUS nts;
    static WCHAR wcsBuffer [MAX_PATH];

    wcsBuffer[0] = L'\0';
    // Open a handle to the volume
    HANDLE h = CreateFileW ( _pwszGuid,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        NULL );

    if (h != INVALID_HANDLE_VALUE)
    {
        OBJECT_NAME_INFORMATION * poni;
        poni = (OBJECT_NAME_INFORMATION *) wcsBuffer;

        // Get name from NT namespace
        nts = NtQueryObject (h, ObjectNameInformation, poni, MAX_PATH, NULL);

        if (NT_SUCCESS(nts))
        {
            if (poni->Name.Length < MAX_PATH * sizeof(WCHAR))
                poni->Name.Buffer [poni->Name.Length / sizeof(WCHAR) - 1] = TEXT('\0');
        }

        CloseHandle (h);
        return poni->Name.Buffer;        
    }
    else
    {
        return wcsBuffer;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\datastor.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    datastor.h
 *
 *  Abstract:
 *    CDataStore class definition
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _DATASTOR_H_
#define _DATASTOR_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgtrace.h>
#include "srdefs.h"
#include "utils.h"
#include "enumlogs.h"

//
// Note: NTFS does not support volume compression, 
//       but only compression on individual files and directories
//       So SR_DRIVE_COMPRESSED is not supported for FAT or NTFS
//
#define SR_DRIVE_ACTIVE      0x01
#define SR_DRIVE_SYSTEM      0x02
#define SR_DRIVE_COMPRESSED  0x04
#define SR_DRIVE_MONITORED   0x08
#define SR_DRIVE_NTFS        0x10
#define SR_DRIVE_PARTICIPATE 0x20
#define SR_DRIVE_FROZEN      0x40
#define SR_DRIVE_READONLY    0x80
#define SR_DRIVE_ERROR		 0x100

class CDriveTable;

//+-------------------------------------------------------------------------
//
//  Class:      CDataStore    
//
//  Synopsis:   maintains and operates on a drive's _restore directory
//
//  History:    13-Apr-2000     BrijeshK    Created
//
//--------------------------------------------------------------------------

class CDataStore : public CSRAlloc
{
public:
    // constants
    enum { LABEL_STRLEN = 256 };   // On NTFS, you can have long volume labels

    CDataStore(CDriveTable *pdt);
    ~CDataStore();

    DWORD LoadDataStore (WCHAR *pwszDrive,
                WCHAR *pwszGuid,
                WCHAR *pwszLabel,
                DWORD dwFlags,
                int   iChangeLogs,
                INT64 llSizeLimit);

    WCHAR * GetDrive()           // return the drive letter or mount point
    {
        return _pwszDrive;
    }

    WCHAR * GetNTName();         // return the NT object name

    WCHAR * GetLabel()           // return the volume label
    {
        return _pwszLabel;
    }

    WCHAR * GetGuid ()           // return the mount mananger GUID
    {
        return _pwszGuid;
    }
    
    DWORD GetFlags ()            // return the status bits
    {
        return _dwFlags;
    }

    int GetNumChangeLogs ()      // number of change logs
    {
        return _iChangeLogs;
    }

    DWORD SetNumChangeLogs (LONG_PTR iChangeLogs)   // number of change logs
    {
        _iChangeLogs = (int) iChangeLogs;

        return DirtyDriveTable();
    }

    void SetDrive (WCHAR *pwszDrive)  // for drive renames
    {
        lstrcpyW (_pwszDrive, pwszDrive);
    }

    INT64 GetSizeLimit ()
    {
        return _llDataStoreSizeBytes;
    }

    void SetSizeLimit (INT64 llSizeLimit)
    {
        _llDataStoreSizeBytes = llSizeLimit;
    }

    INT64 GetDiskFree()
    {
        return _llDiskFreeBytes;
    }    
    
    DWORD   DirtyDriveTable ();
    DWORD   Initialize(WCHAR *pwszDrive, WCHAR *pwszGuid);
    DWORD   UpdateDataStoreUsage(INT64 llDelta, BOOL fCurrent);
    DWORD   GetUsagePercent(int * nPercent);

    DWORD   UpdateDiskFree(LONG_PTR lReserved);
    DWORD   UpdateParticipate(LONG_PTR pwszDir);
    
    //
    // The methods can be callbacks in CDriveTable::ForAllDrives
    //

    DWORD SetActive (LONG_PTR fActive)   // BOOL fActive
    {
        if (FALSE == fActive)
            _dwFlags &= ~SR_DRIVE_ACTIVE;
        else
            _dwFlags |= SR_DRIVE_ACTIVE;

        return DirtyDriveTable();
    }

    DWORD SetParticipate (LONG_PTR fParticipate) // BOOL fParticipate
    {
        if (FALSE == fParticipate)
            _dwFlags &= ~SR_DRIVE_PARTICIPATE;
        else
            _dwFlags |= SR_DRIVE_PARTICIPATE;

        return DirtyDriveTable();
    }

    DWORD SetError (LONG_PTR lReserved) // BOOL fParticipate
    {
        _dwFlags |= SR_DRIVE_ERROR;

        return DirtyDriveTable();
    }

    DWORD ResetFlags (LONG_PTR lReserved)  // reset flags for new restore point
    {
        _iChangeLogs = 0;
        _dwFlags &= ~SR_DRIVE_PARTICIPATE;
        _dwFlags &= ~SR_DRIVE_ERROR;

        return DirtyDriveTable();
    }

    DWORD   SaveDataStore (LONG_PTR hFile);    // HANDLE hFile
    DWORD   MonitorDrive (LONG_PTR fSet);      // BOOL fSet
    DWORD   FreezeDrive (LONG_PTR lReserved);
    DWORD   ThawDrive (LONG_PTR fCheckOnly);   // BOOL fCheckOnly
    DWORD   CreateDataStore (LONG_PTR lReserved);
    DWORD   DestroyDataStore (LONG_PTR fDeleteDir);  // BOOL fDeleteDir
    DWORD   CalculateDataStoreUsage(LONG_PTR lReserved);   
    DWORD   CalculateRpUsage(CRestorePoint * prp,
    						 INT64 * pllSize, 
    						 BOOL fForce, 
    						 BOOL fSnapshotOnly);
    DWORD   Compress (INT64 llAllocatedTime, INT64 *pllUsed);
    DWORD   FifoRestorePoint(CRestorePoint &rp);
    DWORD   CountChangeLogs (LONG_PTR pRestorePoint);
    DWORD   SwitchRestorePoint(LONG_PTR pRestorePoint);
    DWORD   GetVolumeInfo ();
    BOOL    IsVolumeDeleted ();
	DWORD   Print(LONG_PTR lptr);

private:
    CDriveTable * _pdt;               // parent drive table
    int     _iChangeLogs;             // number of change logs

    // variables
    INT64 _llDataStoreSizeBytes;      // maximum data store size
    INT64 _llDiskFreeBytes;           // dynamic free space
    INT64 _llDataStoreUsageBytes;     // non-current restore point usage
    INT64 _llCurrentRpUsageBytes;     // current restore point usage
    
    CRestorePointEnum * _prpe;        // enum restore point to compress
    CRestorePoint * _prp;             // current restore point to compress

    WCHAR   _pwszDrive[MAX_PATH];     // logical DOS device name
    WCHAR   _pwszLabel[LABEL_STRLEN]; // volume label
    WCHAR   _pwszGuid[GUID_STRLEN];   // mount manager volume name
    WORD    _dwFlags;                 // volume flags
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\utest\stubs.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <srconfig.h>
#include <rwlock.h>
#include <respoint.h>
#include <srapi.h>
#include <utils.h>
#include <evthandler.h>
#include <enumlogs.h>

CEventHandler * g_pEventHandler = NULL;
CSRConfig * g_pSRConfig = NULL;

DWORD CEventHandler::SRUpdateMonitoredListS (LPWSTR pszXMLFile)
{
    return 0;
}

ULONG WINAPI SrDisableVolume ( IN HANDLE ControlHandle, IN PWSTR pVolumeName )
{
    return 0;
}

void CEventHandler::RefreshCurrentRp (BOOL fScanAllDrives)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\enumlogs.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    changelog.cpp
 *
 *  Abstract:
 *    CChangeLogEnum functions
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile



// CHANGELOG ENUMERATION METHODS

// constructors

CChangeLogEntryEnum::CChangeLogEntryEnum()
{
    m_fForward = TRUE;
    m_pRestorePointEnum = NULL;
    m_fHaveLock = FALSE;
    m_dwTargetRPNum = 0;
    m_fIncludeCurRP = FALSE;
    GetSystemDrive(m_szDrive);
}

CChangeLogEntryEnum::CChangeLogEntryEnum(
    LPWSTR  pszDrive,
    BOOL    fForward, 
    DWORD   dwRPNum,
    BOOL    fIncludeCurRP)
{
    m_fForward = fForward;
    m_pRestorePointEnum = NULL;
    m_dwTargetRPNum = dwRPNum;
    m_fHaveLock = FALSE;
    m_fIncludeCurRP = fIncludeCurRP;
    lstrcpy(m_szDrive, pszDrive);
}


// destructor

CChangeLogEntryEnum::~CChangeLogEntryEnum()
{
    FindClose();
}


// return first/last change log entry across all restore points

extern "C" DWORD WINAPI
CChangeLogEntryEnum::FindFirstChangeLogEntry(
    CChangeLogEntry& cle)
{
    DWORD   dwRc = ERROR_INTERNAL_ERROR;
    BOOL    fSkipLastLog;

    TENTER("CChangeLogEntryEnum::FindFirstChangeLogEntry");
    
    // initialize the lock object
    
    dwRc = m_DSLock.Init();    // don't create mutex
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! m_DSLock.Init : %ld", dwRc);
        goto done;
    }
        
    // get mutually exclusive access to the datastore

    LOCKORLEAVE(m_fHaveLock);
    
    // get the first/last restore point
    
    m_pRestorePointEnum = new CRestorePointEnum(m_szDrive, m_fForward, ! m_fIncludeCurRP);
    if (! m_pRestorePointEnum)
    {
        TRACE(0, "Out of memory");
        goto done;
    }
    
    dwRc = m_pRestorePointEnum->FindFirstRestorePoint(m_RPTemp);    
    if (ERROR_SUCCESS != dwRc && ERROR_FILE_NOT_FOUND != dwRc) 
    {
        TRACE(0, "! FindFirstRestorePoint : %ld", dwRc);
        goto done;
    }  

    // gone past target restore point?
    
    if (m_dwTargetRPNum)
    {
        if (m_fForward)
        {
            if (m_dwTargetRPNum < m_RPTemp.GetNum())
            {
                dwRc = ERROR_NO_MORE_ITEMS;
                goto done;
            }
        }
        else
        {
            if (m_dwTargetRPNum > m_RPTemp.GetNum())
            {
                dwRc = ERROR_NO_MORE_ITEMS;
                goto done;
            }               
        }
    }

    // get the first/last change log entry in this restore point
    
    dwRc = m_RPTemp.FindFirstChangeLogEntry(m_szDrive,
                                            m_fForward,  
                                            cle);    
    if (ERROR_NO_MORE_ITEMS == dwRc) 
    {
        dwRc = FindNextChangeLogEntry(cle);
    }


done:
    if (ERROR_SUCCESS != dwRc)
    {
        UNLOCK(m_fHaveLock);
    }

    TLEAVE();
    return dwRc;
}



// return next/prev change log entry across all restore points

extern "C" DWORD WINAPI
CChangeLogEntryEnum::FindNextChangeLogEntry(
    CChangeLogEntry& cle)
{
    DWORD dwRc = ERROR_INTERNAL_ERROR;
    BOOL  fSkipLastLog;

    TENTER("CChangeLogEntryEnum::FindNextChangeLogEntry");
   
    // get the next change log entry in the current restore point
    
    if (! m_pRestorePointEnum)
    {
        TRACE(0, "m_pRestorePointEnum=NULL");
        goto done;
    }
    
    dwRc = m_RPTemp.FindNextChangeLogEntry(cle);
                   
    while (ERROR_NO_MORE_ITEMS == dwRc)    // all entries done
    {
        // get the next restore point
        
        m_RPTemp.FindClose();
        
        dwRc = m_pRestorePointEnum->FindNextRestorePoint(m_RPTemp);
        
        if (ERROR_SUCCESS != dwRc && dwRc != ERROR_FILE_NOT_FOUND)      // all restore points done
        {
            TRACE(0, "! FindFirstRestorePoint : %ld", dwRc);
            goto done;
        }

        // gone past target restore point?
    
        if (m_dwTargetRPNum)
        {
            if (m_fForward)
            {
                if (m_dwTargetRPNum < m_RPTemp.GetNum())
                {
                    dwRc = ERROR_NO_MORE_ITEMS;
                    goto done;
                }
            }
            else
            {
                if (m_dwTargetRPNum > m_RPTemp.GetNum())
                {
                    dwRc = ERROR_NO_MORE_ITEMS;
                    goto done;
                }               
            }
        }

        // get the first change log entry in this restore point

        dwRc = m_RPTemp.FindFirstChangeLogEntry(m_szDrive,
                                                m_fForward,
                                                cle);
    }    

    // return this entry    
done:
    TLEAVE();
    return dwRc;    
}


// release memory, lock and close handles

DWORD WINAPI
CChangeLogEntryEnum::FindClose()
{
    TENTER("CChangeLogEntryEnum::FindClose");
    
    m_RPTemp.FindClose();  
    
    if (m_pRestorePointEnum)
    {
        m_pRestorePointEnum->FindClose(); 
        delete m_pRestorePointEnum;
        m_pRestorePointEnum = NULL;
    }

    UNLOCK(m_fHaveLock);

    TLEAVE();

    return ERROR_SUCCESS;
}


// RESTORE POINT ENUMERATION METHODS

// constructors

CRestorePointEnum::CRestorePointEnum()
{
    // defaults
    m_fForward = TRUE;
    GetSystemDrive(m_szDrive);  
    m_fSkipLast = FALSE;
    m_pCurrentRp = NULL;
}

CRestorePointEnum::CRestorePointEnum(LPWSTR pszDrive, BOOL fForward, BOOL fSkipLast)
{
    m_fForward = fForward;
    lstrcpy(m_szDrive, pszDrive);
    m_fSkipLast = fSkipLast;
    m_pCurrentRp = NULL;    
}

// destructor

CRestorePointEnum::~CRestorePointEnum()
{
    FindClose();
}


// to find the first restore point on a given drive - forward or backward

DWORD
CRestorePointEnum::FindFirstRestorePoint(CRestorePoint& RestorePoint)
{
    WIN32_FIND_DATA     *pFindData = new WIN32_FIND_DATA;
    DWORD               dwRc = ERROR_SUCCESS;
    
    TENTER("CRestorePointEnum::FindFirstRestorePoint");    

    if (! pFindData)
    {
        trace(0, "Cannot allocate pFindData");
        dwRc = ERROR_OUTOFMEMORY;
        goto done;
    }
    
    // construct drive:\_restore\RP directory
    {
        WCHAR szCurPath[MAX_PATH];
        MakeRestorePath(szCurPath, m_szDrive, s_cszRPDir);

        if (FALSE == FindFile._FindFirstFile(szCurPath, L"", pFindData, m_fForward, FALSE))
        {
            dwRc = ERROR_NO_MORE_ITEMS;
            goto done;
        }
    }
    
    // get the current restore point

    if (m_fSkipLast)
    {
        m_pCurrentRp = new CRestorePoint();
        if (! m_pCurrentRp)
        {
            trace(0, "Cannot allocate memory for m_pCurrentRp");
            dwRc = ERROR_OUTOFMEMORY;
            goto done;
        }
           
        dwRc = GetCurrentRestorePoint(*m_pCurrentRp);
        if (dwRc != ERROR_SUCCESS && dwRc != ERROR_FILE_NOT_FOUND)
        {
            TRACE(0, "! GetCurrentRestorePoint : %ld", dwRc);
            goto done;
        }
        
        // check if this is the current restore point
        // and if client wants it

        if (0 == lstrcmpi(pFindData->cFileName, m_pCurrentRp->GetDir()))
        {
            if (m_fForward)
            {
                // we are done
                dwRc = ERROR_NO_MORE_ITEMS;
                goto done;
            }
            else
            {
                // skip this
                dwRc = FindNextRestorePoint(RestorePoint);
                goto done;
            }
        }
    }
    
       
    // read restore point data from log
    // if the enumeration is happening on the system drive
    
    RestorePoint.SetDir(pFindData->cFileName);
    
    if (IsSystemDrive(m_szDrive))
        dwRc = RestorePoint.ReadLog();  
    

done:  
    if (pFindData)
        delete pFindData;
    TLEAVE();    
    return dwRc;
}


// to find the next/previous restore point on a given drive

DWORD
CRestorePointEnum::FindNextRestorePoint(CRestorePoint& RestorePoint)
{
    DWORD   dwRc = ERROR_SUCCESS;
    WIN32_FIND_DATA FindData;

    TENTER("CRestorePointEnum::FindNextRestorePoint");

    {
        WCHAR szCurPath[MAX_PATH];  
        MakeRestorePath(szCurPath, m_szDrive, s_cszRPDir);        
        if (FALSE == FindFile._FindNextFile(szCurPath, L"", &FindData))
        {
            dwRc = ERROR_NO_MORE_ITEMS;
            goto done;
        }
    }
    
    if (m_fSkipLast)
    {        
        // check if this is the current restore point
        // and if client wants it

        if (! m_pCurrentRp)
        {
            trace(0, "m_pCurrentRp = NULL");            
            dwRc = ERROR_INTERNAL_ERROR;
            goto done;
        }
        
        if (0 == lstrcmpi(FindData.cFileName, m_pCurrentRp->GetDir()))
        {
            if (m_fForward)
            {
                // we are done
                dwRc = ERROR_NO_MORE_ITEMS;
                goto done;
            }
        }
    }


    // read restore point data from log
    // if the enumeration is happening on the system drive
    
    RestorePoint.SetDir(FindData.cFileName);
    
    if (IsSystemDrive(m_szDrive))
        dwRc = RestorePoint.ReadLog();        
        
done:
    TLEAVE();
    return dwRc;
}


// nothing here

DWORD
CRestorePointEnum::FindClose()
{
    TENTER("CRestorePointEnum::FindClose");

    if (m_pCurrentRp)
    {
        delete m_pCurrentRp;
        m_pCurrentRp = NULL;
    }
    
    TLEAVE();
    return ERROR_SUCCESS;    
}


DWORD WINAPI
GetCurrentRestorePoint(CRestorePoint& rp)
{
    DWORD dwErr;
    WCHAR szSystemDrive[MAX_SYS_DRIVE]=L"";
    CRestorePointEnum *prpe = NULL;
    
    GetSystemDrive(szSystemDrive);

    prpe = new CRestorePointEnum(szSystemDrive, FALSE, FALSE);  // enum backward, don't skip last    
    if (! prpe)
    {
        dwErr = ERROR_OUTOFMEMORY;
        return dwErr;
    }
    
    dwErr = prpe->FindFirstRestorePoint(rp);
    prpe->FindClose ();
    delete prpe;
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\datastormgr.cpp ===
/*****************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    datastormgr.cpp
 *
 *  Abstract:
 *    CDataStoreMgr class functions
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/28/2000
 *        created
 *
 *****************************************************************************/

#include "datastormgr.h" 
#include "srapi.h"
#include "srconfig.h"
#include "evthandler.h"
#include "ntservice.h"
#include "ntservmsg.h"

#include <coguid.h>
#include <rpc.h>
#include <stdio.h>
#include <shlwapi.h>

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

CDataStoreMgr * g_pDataStoreMgr = NULL;  // the global instance

//
// we can't use %s for the volume label because it can contain spaces
// so we look for all characters until the end-of-line
//
static WCHAR gs_wcsScanFormat[] = L"%[^/]/%s %x %i %i %[^\r]\n";

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::CDriveTable ()
//
//  Synopsis:   
//
//  Arguments:  
//
//  Returns:    
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDriveTable::CDriveTable ()
{
    _pdtNext = NULL;
    _nLastDrive = 0;
    _fDirty = FALSE;
    _fLockInit = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::~CDriveTable
//
//  Synopsis:   delete all drive table entries
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDriveTable::~CDriveTable ()
{
    for (int i = 0; i < _nLastDrive; i++)
    {
        if (_rgDriveTable[i] != NULL)
        {
            delete _rgDriveTable[i];
            _rgDriveTable[i] = NULL;
        }
    }
    _nLastDrive = 0;

    if (_pdtNext != NULL)
    {
        delete _pdtNext;
        _pdtNext = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::CreateNewEntry
//
//  Synopsis:   populate the table with this datastore object
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::CreateNewEntry (CDataStore *pds)
{
    if (_nLastDrive < DRIVE_TABLE_SIZE)
    {
        _rgDriveTable[_nLastDrive] = pds;
        _nLastDrive++;
        return ERROR_SUCCESS;
    }
    else
    {
        // this table is full, allocate a new one if needed
        if (_pdtNext == NULL)
        {
            _pdtNext = new CDriveTable();
            if (_pdtNext == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        // Now add the entry to the new table
        return _pdtNext->CreateNewEntry (pds);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::FindDriveInTable
//
//  Synopsis:   return datastore object matching this drive
//
//  Arguments:  can pass in dos drive letter, mount point path, or volume guid
//
//  Returns:    pointer to corresponding datastore object
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStore * CDriveTable::FindDriveInTable (WCHAR *pwszDrive) const
{    
    if (NULL == pwszDrive)   // not a valid drive
        return NULL;

    if (0 == wcsncmp(pwszDrive, L"\\\\?\\Volume", 10))
        return FindGuidInTable(pwszDrive);
        
    for (const CDriveTable *pdt = this; pdt != NULL; pdt = pdt->_pdtNext)
    {
        for (int i = 0; i < pdt->_nLastDrive; i++)
        {
            if ((pdt->_rgDriveTable[i] != NULL) && 
                lstrcmpi (pwszDrive, pdt->_rgDriveTable[i]->GetDrive()) == 0)
            {
                return pdt->_rgDriveTable[i];
            }
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::RemoveDrivesFromTable
//
//  Synopsis:   remove inactive drive table entries
//
//  Arguments:  
//
//  Returns:    Win32 error code
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::RemoveDrivesFromTable ()
{
    DWORD dwErr = ERROR_SUCCESS;

    tenter("removedrivesfromtable");
    
    for (CDriveTable *pdt = this; pdt != NULL; pdt = pdt->_pdtNext)
    {
        for (int i = 0; i < pdt->_nLastDrive; i++)
        {
            if (pdt->_rgDriveTable[i] != NULL &&
                pdt->_rgDriveTable[i]->IsVolumeDeleted())
            {
                 trace(0, "removing %S from drivetable", pdt->_rgDriveTable[i]->GetDrive());
                 
                 delete pdt->_rgDriveTable[i];
                 pdt->_rgDriveTable[i] = NULL;

                 if (i == pdt->_nLastDrive - 1)
                     --(pdt->_nLastDrive);

                 _fDirty = TRUE;
            }
        }
    }

    tleave();
    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::FindGuidInTable
//
//  Synopsis:   get the drive table entry matching the volume GUID
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStore * CDriveTable::FindGuidInTable (WCHAR *pwszGuid) const
{
    if (NULL == pwszGuid)   // not a valid string
        return NULL;

    for (const CDriveTable *pdt = this; pdt != NULL; pdt = pdt->_pdtNext)
    {
        for (int i = 0; i < pdt->_nLastDrive; i++)
        {
            if (pdt->_rgDriveTable[i] != NULL &&
                lstrcmp (pwszGuid, pdt->_rgDriveTable[i]->GetGuid()) == 0)
            {
                return pdt->_rgDriveTable[i];
            }
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::FindSystemDrive
//
//  Synopsis:   get the drive table entry for the system drive
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStore * CDriveTable::FindSystemDrive () const
{
    for (const CDriveTable *pdt = this; pdt != NULL; pdt = pdt->_pdtNext)
    {
        for (int i = 0; i < pdt->_nLastDrive; i++)
        {
            if (pdt->_rgDriveTable[i] != NULL &&
                pdt->_rgDriveTable[i]->GetFlags() & SR_DRIVE_SYSTEM)
            {
                return pdt->_rgDriveTable[i];
            }
        }
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::ForAllDrives
//
//  Synopsis:   Execute this CDataStore method for all drives
//
//  Arguments:  [pMethod] -- CDataStore method to call
//              [lParam] -- parameter to that method
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::ForAllDrives (PDATASTOREMETHOD pMethod, LONG_PTR lParam)
{
    TENTER ("ForAllDrives");

    DWORD dwErr = ERROR_SUCCESS;

    for (CDriveTable *pdt = this; pdt != NULL; pdt = pdt->_pdtNext)
    {
        for (int i = 0; i < pdt->_nLastDrive; i++)
        {
            if (pdt->_rgDriveTable[i] != NULL)
            {
                dwErr = (pdt->_rgDriveTable[i]->*pMethod) (lParam);
                if (dwErr != ERROR_SUCCESS)
                {
                    TRACE(0, "%S ForAllDrives failed %x", pdt->_rgDriveTable[i]->GetDrive(), dwErr);
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }

    if (dwErr == ERROR_SUCCESS && _fDirty)
        dwErr = SaveDriveTable ((CRestorePoint *) NULL);

    TLEAVE();

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::ForOneOrAllDrives
//
//  Synopsis:   Execute this CDataStore method for one or all drives
//
//  Arguments:  [pwszDrive] -- drive to execute method
//              [pMethod] -- CDataStore method to call
//              [lParam] -- parameter to that method
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::ForOneOrAllDrives (WCHAR *pwszDrive,
                                      PDATASTOREMETHOD pMethod,
                                      LONG_PTR lParam)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (pwszDrive == NULL)
    {
        dwErr = ForAllDrives (pMethod, lParam);
    }
    else
    {
        CDataStore *pds = FindDriveInTable (pwszDrive);
        dwErr = (pds != NULL) ? (pds->*pMethod)(lParam) : ERROR_INVALID_DRIVE;

        if (dwErr == ERROR_SUCCESS && _fDirty)
            dwErr = SaveDriveTable ((CRestorePoint *) NULL);
    }

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::FindMountPoint
//
//  Synopsis:   Given a volume GUID, find a mount point that points to it
//
//  Arguments:  [pwszGuid] -- input volume GUID
//              [pwszPath] -- output path to mount point
//
//  Returns:    Win32 error
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::FindMountPoint (WCHAR *pwszGuid, WCHAR *pwszPath) const
{
    TENTER ("CDriveTable::FindMountPoint");

    DWORD dwErr = ERROR_MORE_DATA;      // initialize for loop
    WCHAR * pwszMount = NULL;           // MultiSz string
    DWORD dwMountLen = MAX_PATH;        // initial buffer size
    DWORD dwChars = 0;       

    pwszPath[0] = L'\0';

    while (dwErr == ERROR_MORE_DATA)
    {
        dwErr = ERROR_SUCCESS;

        pwszMount = new WCHAR [dwMountLen];
        if (pwszMount == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Err;
        }

        if (FALSE == GetVolumePathNamesForVolumeNameW (pwszGuid,
                                                   pwszMount,
                                                   dwMountLen,
                                                   &dwChars ))
        {
            dwErr = GetLastError();
            delete [] pwszMount;      // free the existing buffer
            pwszMount = NULL;
            dwMountLen *= 2;          // double the length
        }
    }

    if (ERROR_SUCCESS == dwErr && pwszMount != NULL)
    {
        if (L'\0' == pwszMount[0])           // empty string
        {
            dwErr = ERROR_NOT_DOS_DISK;      // no drive letter or mount point
        }
        else if (lstrlenW (pwszMount) < MAX_MOUNTPOINT_PATH)
        {
            lstrcpyW (pwszPath, pwszMount);  // copy the first string
        }
        else
        {
            dwErr = ERROR_BAD_PATHNAME;      // 1st path too long
        }
    }

Err:
    if (pwszMount != NULL)
        delete [] pwszMount;
        
    TLEAVE();

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::AddDriveToTable
//
//  Synopsis:   add the volume to the drive table
//
//  Arguments:  [pwszGuid] -- the volume GUID
//
//  Returns:    Win32 error code
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::AddDriveToTable(WCHAR *pwszDrive, WCHAR *pwszGuid)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (NULL == pwszDrive)
        return ERROR_INVALID_DRIVE;

    // Eventually, this routine will require pwszGuid to be non-NULL
    CDataStore *pds = pwszGuid != NULL ? FindGuidInTable (pwszGuid) :
                                         FindDriveInTable (pwszDrive);

    if (pds != NULL)   // found the drive already
    {
        if (lstrcmpiW (pwszDrive, pds->GetDrive()) != 0)  // drive rename
            pds->SetDrive (pwszDrive);

        return dwErr;
    }

    pds = new CDataStore(this);
    if (pds == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        return dwErr;
    }

    dwErr = pds->Initialize (pwszDrive, pwszGuid);

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = CreateNewEntry (pds);
        _fDirty = TRUE;
    }

    if (dwErr != ERROR_SUCCESS)  // clean up on error
    {
        delete pds;
    }

    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::FindFirstDrive
//              CDriveTable::FindNextDrive
//
//  Synopsis:   loop through drive table entries
//
//  Arguments:  [dtec] -- enumeration context
//
//  Returns:    CDataStore object pointer
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStore * CDriveTable::FindFirstDrive (SDriveTableEnumContext & dtec) const
{
    for (dtec._pdt = this; dtec._pdt != NULL; dtec._pdt = dtec._pdt->_pdtNext)
    {
        for (dtec._iIndex = 0; dtec._iIndex < dtec._pdt->_nLastDrive; dtec._iIndex++)
        {
            CDataStore *pds = dtec._pdt->_rgDriveTable[dtec._iIndex];
            if (pds != NULL)
            {
                return pds;
            }
        }
    }
    return NULL;
}

CDataStore * CDriveTable::FindNextDrive (SDriveTableEnumContext & dtec) const
{
    for (; dtec._pdt != NULL; dtec._pdt = dtec._pdt->_pdtNext)
    {
        dtec._iIndex++;
        for (; dtec._iIndex < dtec._pdt->_nLastDrive; dtec._iIndex++)
        {
            CDataStore *pds = dtec._pdt->_rgDriveTable[dtec._iIndex];

            if (pds != NULL)
            {
                return pds;
            }
        }
        dtec._iIndex = 0;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::Merge
//
//  Synopsis:   loop through drive table entries and merge
//
//  Arguments:  [dt] -- drive table read from disk
//
//  Returns:    Win32 error
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::Merge (CDriveTable &dt)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fApplyDefaults = FALSE;
    SDriveTableEnumContext  dtec = {NULL, 0};
    HKEY hKeyGP = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                         s_cszGroupPolicy,
                         0,
                         KEY_READ,
                         &hKeyGP))
    {
        DWORD dwRet = 0;
        if (ERROR_SUCCESS == RegReadDWORD(hKeyGP, s_cszDisableConfig, &dwRet))
        {
            if (dwRet == 0)
                fApplyDefaults = TRUE;
        }
        RegCloseKey (hKeyGP);
    }

    CDataStore *pds = dt.FindFirstDrive (dtec);
    while (pds != NULL)
    {
        CDataStore *pdsFound = FindGuidInTable (pds->GetGuid());
        if (pdsFound != NULL)
        {
            pds->GetVolumeInfo();   // refresh the volume flags

            if (fApplyDefaults)
            {
                pds->MonitorDrive(TRUE);   // make sure drive is monitored
                pds->SetSizeLimit(0);      // set max datastore size to default
            }

            // don't overwrite the newer drive letter and label
            dwErr = pdsFound->LoadDataStore (NULL, pds->GetGuid(), NULL,
                pds->GetFlags() | SR_DRIVE_ACTIVE, pds->GetNumChangeLogs(), pds->GetSizeLimit());
        }
        else
        {
            CDataStore *pdsNew = new CDataStore ( this);
            if (pdsNew == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                return dwErr;
            }

            dwErr = pdsNew->LoadDataStore (pds->GetDrive(), pds->GetGuid(),
                         pds->GetLabel(), 
                         pds->GetFlags() & ~SR_DRIVE_ACTIVE,
                         pds->GetNumChangeLogs(), pds->GetSizeLimit());

            if (dwErr != ERROR_SUCCESS)
            {
                delete pdsNew;
                pdsNew = NULL;
                goto Err;
            }

            dwErr = CreateNewEntry (pdsNew);
        }
        if (dwErr != ERROR_SUCCESS)
            goto Err;


        pds = dt.FindNextDrive (dtec);
    }

    if (fApplyDefaults && g_pEventHandler != NULL)
    {
        dwErr = g_pEventHandler->SRUpdateMonitoredListS(NULL);
    }
Err:
    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::IsAdvancedRp()
//
//  Synopsis:   method to determine if a given restore point is an
//              advanced restore point
//
//  Arguments:  restore point, pointer to flags 
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD
CDriveTable::IsAdvancedRp(CRestorePoint *prp, PDWORD pdwFlags)
{
    TraceFunctEnter("CDriveTable::IsAdvancedRp");

    WCHAR                   szPath[MAX_PATH];
    WCHAR                   szSysDrive[MAX_PATH];
    SDriveTableEnumContext  dtec = {NULL, 0};
    DWORD                   dwErr = ERROR_SUCCESS;
    CDataStore              *pds = NULL;
    CRestorePoint           rp;
    CDriveTable             dt;
    
    // 
    // read the drivetable file for this restore point
    // 

    if (FALSE == GetSystemDrive(szSysDrive))
    {
        dwErr = ERROR_INVALID_DRIVE;
        trace(0, "! GetSystemDrive : %ld", dwErr);
        goto Err;
    }

    dwErr = GetCurrentRestorePoint(rp);
    if ( dwErr != ERROR_SUCCESS )
        goto Err;

    //
    // if no restore point specified, assume current 
    //

    if (! prp)
        prp = &rp;
    if (prp->GetNum() == rp.GetNum())
    {
        MakeRestorePath(szPath, szSysDrive, s_cszDriveTable);
    }
    else
    {
        MakeRestorePath(szPath, szSysDrive, prp->GetDir());
        PathAppend(szPath, s_cszDriveTable);
    }

    dwErr = dt.LoadDriveTable(szPath);
    if (dwErr != ERROR_SUCCESS)
        goto Err;

    // 
    // check if the rp directory exists on all drives
    // if it does not, then it is an advanced restore point
    //
    
    *pdwFlags = RP_NORMAL;
    pds = dt.FindFirstDrive(dtec);
    while (pds)
    {
        // 
        // is the rp dir supposed to exist?
        //
        
        if ((pds->GetFlags() & SR_DRIVE_ACTIVE) &&
            (pds->GetFlags() & SR_DRIVE_MONITORED) &&
            (pds->GetFlags() & SR_DRIVE_PARTICIPATE) &&
            !(pds->GetFlags() & SR_DRIVE_FROZEN))
        {
            MakeRestorePath(szPath, pds->GetDrive(), rp.GetDir());
            if (0xFFFFFFFF == GetFileAttributes(szPath))
            {
                *pdwFlags = RP_ADVANCED;
                break;
            }
        }
        pds = dt.FindNextDrive(dtec);
    }

Err:
    TraceFunctLeave();
    return dwErr;
}



//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::AnyMountedDrives()
//
//  Synopsis:   check if there are any mounted drives
//
//  Arguments:  
//
//  Returns:
//
//  History:    25-Oct-2000     Brijeshk    Created
//
//--------------------------------------------------------------------------
BOOL CDriveTable::AnyMountedDrives()
{
    SDriveTableEnumContext  dtec = {NULL, 0};
    CDataStore *pds = FindFirstDrive(dtec);
    while (pds)
    {
        //
        // get the first '\' in the drive path
        // if this is not the last character in the path
        // then this is a mount point
        //
        
        LPWSTR pszfirst = wcschr(pds->GetDrive(), L'\\');
        if (pszfirst &&
            pszfirst != pds->GetDrive() + (lstrlen(pds->GetDrive()) - 1))
        {
            return TRUE;
        }
        pds = FindNextDrive(dtec);
    }   

    return FALSE;    
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::CDataStoreMgr()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStoreMgr::CDataStoreMgr()
{
    _fStop = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::~CDataStoreMgr()
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

CDataStoreMgr::~CDataStoreMgr()
{
}


// helper functions for Fifo

BOOL
IsCurrentRp(CRestorePoint& rp, CRestorePoint& rpCur)
{
    return rp.GetNum() == rpCur.GetNum();
}

BOOL
IsTargetPercentMet(int nUsagePercent, int nTargetPercent)
{   
    return  nUsagePercent <= nTargetPercent;
}

BOOL
IsTargetRpMet(DWORD dwRPNum, DWORD dwTargetRPNum)
{
    return dwRPNum > dwTargetRPNum;
}



//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::Fifo
//
//  Synopsis:   fifo restore points upto a given percentage
//
//  Arguments:  drive to fifo, target RP dir, target percentage to stop fifo
//              specify only one of both (dwTargetRPNum or nTargetPercent)
//              fIncludeCurrentRp = TRUE : fifo current rp if necessary (i.e. freeze)
//              fIncludeCurrentRp = FALSE : don't fifo current rp
//
//  Returns:    Win32 error code
//
//  History:    27-Apr-2000     brijeshk    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::Fifo(
    WCHAR   *pwszDrive, 
    DWORD   dwTargetRPNum,
    int     nTargetPercent,
    BOOL    fIncludeCurrentRp,
    BOOL    fFifoAtLeastOneRp
    )
{
    TENTER("CDataStoreMgr::Fifo");

    DWORD       dwErr = ERROR_SUCCESS;
    CDataStore  *pds = _dt.FindDriveInTable(pwszDrive);
    BOOL        fFifoed = FALSE;
    DWORD       dwLastFifoedRp;
    CDataStore  *pdsLead = NULL;
    BOOL        fFirstIteration;
    SDriveTableEnumContext dtec = {NULL, 0};
    CRestorePointEnum   *prpe = NULL;
    CRestorePoint       *prp = new CRestorePoint;
    
    // can't specify many target criteria
    
    if (dwTargetRPNum != 0 && nTargetPercent != 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Err;
    }

    // can't specify no target criteria
    
    if (fIncludeCurrentRp == TRUE && dwTargetRPNum == 0 && nTargetPercent == 0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Err;
    }


    // can't specify bad target criteria

    if (dwTargetRPNum > g_pEventHandler->m_CurRp.GetNum()  ||
        nTargetPercent < 0 ||
        nTargetPercent > 100)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Err;
    }

    if (!prp)
    {
        trace(0, "cannot allocate memory for restore point");
        dwErr = ERROR_OUTOFMEMORY;
        goto Err;
    }
    
    if (! pds)
    {
        TRACE(0, "! Drive %S not in drivetable", pwszDrive);
        dwErr = ERROR_INVALID_DRIVE;
        goto Err;
    }    
    
    if (! (pds->GetFlags() & SR_DRIVE_MONITORED) ||
          (pds->GetFlags() & SR_DRIVE_FROZEN) )
    {
        trace(0, "Drive %S already frozen/disabled", pwszDrive);
        goto Err;
    }

    if (g_pSRConfig->m_dwTestBroadcast)
        PostTestMessage(g_pSRConfig->m_uiTMFifoStart, (WPARAM) NULL, (LPARAM) NULL);        

    
    pdsLead = NULL;
    fFirstIteration = TRUE;
    while (pds)            
    {
        fFifoed = FALSE;
        
        //
        // skip the drive we fifoed first
        //
        
        if (pds != pdsLead)
        {        
            //
            // enum forward, don't skip last
            //
            
            prpe = new CRestorePointEnum( pds->GetDrive(), TRUE, FALSE );   

            if (!prpe)
            {
                trace(0, "cannot allocate memory for restore point enum");
                dwErr = ERROR_OUTOFMEMORY;
                goto Err;
            }
            

            {
                WCHAR       szFifoedRpPath[MAX_PATH];
                
                //
                // blow away any obsolete "Fifoed" directories
                //
                
                MakeRestorePath(szFifoedRpPath, pwszDrive, s_cszFifoedRpDir);              

                CHECKERR(Delnode_Recurse(szFifoedRpPath, TRUE, &_fStop),
                         "Denode_Recurse Fifoed");
                
                //
                // blow away any obsolete "RP0" directories
                //
                
                MakeRestorePath(szFifoedRpPath, pwszDrive, L"RP0");              
                dwErr = Delnode_Recurse(szFifoedRpPath, TRUE, &_fStop);

                if (ERROR_SUCCESS != dwErr)
                {
                    trace (0, "Cannot FIFO RP0 error %d, ignoring", dwErr);
                    dwErr = ERROR_SUCCESS;
                }
            }
            
            //
            // loop through restore points on this drive
            //
            
            dwErr = prpe->FindFirstRestorePoint (*prp);

            //
            // enumeration can return ERROR_FILE_NOT_FOUND for restorepoints
            // that are missing rp.log
            // we will just continue in this case
            //
            
            while (dwErr == ERROR_SUCCESS || dwErr == ERROR_FILE_NOT_FOUND)
            {
                //
                // check for the stop event             
                //
                
                ASSERT(g_pSRConfig);
                if (IsStopSignalled(g_pSRConfig->m_hSRStopEvent))
                {
                    TRACE(0, "Stop signalled - aborting fifo");
                    dwErr = ERROR_OPERATION_ABORTED;
                    goto Err;
                }

                //
                // check if fifo is disabled from this restore point
                //
                
                if (g_pSRConfig->GetFifoDisabledNum() != 0 && 
                    prp->GetNum() >= g_pSRConfig->GetFifoDisabledNum())
                {
                    TRACE(0, "Fifo disabled from %S", prp->GetDir());
                    break;
                }

                //
                // check if we've reached target restore point or percentage
                //
                
                if (dwTargetRPNum)
                {
                    if (IsTargetRpMet(prp->GetNum(), dwTargetRPNum))
                    {
                        TRACE(0, "Target restore point reached");
                        break;
                    }
                }
                else if (nTargetPercent && FALSE == fFifoAtLeastOneRp)
                {
                    int nUsagePercent = 0;

                    if (ERROR_SUCCESS == pds->GetUsagePercent(&nUsagePercent) &&
                        IsTargetPercentMet(nUsagePercent, nTargetPercent))
                    {
                        TRACE(0, "Target percentage reached");                
                        break;                
                    }
                }

                //
                // check if we've reached the current rp
                //
                
                if (IsCurrentRp(*prp, g_pEventHandler->m_CurRp))
                {                
                    if (fIncludeCurrentRp)
                    {
                        //
                        // need to fifo this one too
                        // this is same as freezing the drive
                        // so freeze
                        //
                        
                        dwErr = FreezeDrive(pwszDrive);
                        goto Err;
                    }
                    else                    
                    {   
                        //
                        // don't fifo current rp
                        // (usually called from Disk Cleanup)
                        //
                        
                        trace(0, "No more rps to fifo");
                        break;
                    }
                }            

                                                                    
                //
                // throw away this restore point on this drive       
                //
                
                dwErr = pds->FifoRestorePoint (*prp);
                if ( ERROR_SUCCESS != dwErr )
                {
                    TRACE(0, "! FifoRestorePoint on %S on drive %S : %ld",
                             prp->GetDir(), pwszDrive, dwErr);
                    goto Err;
                }

                //
                // record in the fifo log
                //
                
                WriteFifoLog (prp->GetDir(), pds->GetDrive());
                dwLastFifoedRp = prp->GetNum();
                fFifoed = TRUE;
                fFifoAtLeastOneRp = FALSE;
                
                dwErr = prpe->FindNextRestorePoint(*prp);          
            }            

            if (prpe)
            {
                delete prpe;
                prpe = NULL;
            }
        }

        //
        // go to next drive
        //
        
        if (fFirstIteration)
        {
            if (! fFifoed)  // we did not fifo anything
            {
                break;
            }
        
            pdsLead = pds;
            pds = _dt.FindFirstDrive(dtec);
            fFirstIteration = FALSE;
            dwTargetRPNum = dwLastFifoedRp; // fifo till what we fifoed just now
            nTargetPercent = 0;
            fIncludeCurrentRp = TRUE;
            fFifoAtLeastOneRp = FALSE;           
        }
        else
        {
            pds = _dt.FindNextDrive(dtec);
        }
    }


    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = ERROR_SUCCESS;
  
    if (g_pSRConfig->m_dwTestBroadcast)
        PostTestMessage(g_pSRConfig->m_uiTMFifoStop, (WPARAM) dwLastFifoedRp, (LPARAM) NULL);  
        
Err:
    if (prpe)
        delete prpe;
    if (prp)
        delete prp;
        
    TLEAVE();
    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::WriteFifoLog
//
//  Synopsis:   appends to the fifo log
//
//  Arguments:  dir name of restore point fifoed, drive
//
//  Returns:
//
//  History:    27-Apr-2000     brijeshk    Created
//
//--------------------------------------------------------------------------

DWORD
CDataStoreMgr::WriteFifoLog(LPWSTR pwszDir, LPWSTR pwszDrive)
{
    FILE        *f = NULL;
    WCHAR       szLog[MAX_PATH];
    DWORD       dwRc = ERROR_INTERNAL_ERROR;
    WCHAR       wszTime[MAX_PATH] = L"";
    WCHAR       wszDate[MAX_PATH] = L"";
    CDataStore  *pds = NULL;
    
    TENTER("CDataStoreMgr::WriteFifoLog");

    TRACE(0, "Fifoed %S on drive %S",  pwszDir, pwszDrive);            

    if (pds = _dt.FindSystemDrive())
    {
        MakeRestorePath(szLog, pds->GetDrive(), s_cszFifoLog);
        
        f = (FILE *) _wfopen(szLog, L"a");
        if (f)
        {
            _wstrdate(wszDate);
            _wstrtime(wszTime);
            fwprintf(f, L"%s-%s : Fifoed %s on drive %s\n", wszDate, wszTime, pwszDir, pwszDrive);
            fclose(f);
            dwRc = ERROR_SUCCESS;
        }
        else
        {
            TRACE(0, "_wfopen failed on %s", szLog);
        }
    }
    
    TLEAVE();
    return dwRc;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::EnumAllVolumes
//
//  Synopsis:   enumerates all local volumes and updates the drive table
//
//  Arguments:
//
//  Returns:    Win32 error code
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::EnumAllVolumes ()
{
    TENTER("CDriveTable::EnumAllVolumes");

    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsVolumeName[MAX_PATH];
    WCHAR wcsDosName[MAX_PATH];

    //
    // Let's first get all the local volumes
    //
    HANDLE hVolume = FindFirstVolume (wcsVolumeName, MAX_PATH);

    // If we can't even find one volume, return an error
    if (hVolume == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        return dwErr;
    }

    do
    {
        //
        // We have to find a mount point that points to this volume
        // If there is no such mount point, then the volume is not
        //     accessible, and we ignore it
        //
        dwErr = FindMountPoint (wcsVolumeName, wcsDosName);

        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = AddDriveToTable (wcsDosName, wcsVolumeName);

            if (dwErr == ERROR_BAD_DEV_TYPE ||  //add only fixed drives
                dwErr == ERROR_UNRECOGNIZED_VOLUME) //unformatted
                dwErr = ERROR_SUCCESS;

            if (dwErr != ERROR_SUCCESS)
            {
                goto Err;
            }
        }
    }
    while (FindNextVolume (hVolume, wcsVolumeName, MAX_PATH));

    dwErr = ERROR_SUCCESS;
    
Err:
    FindVolumeClose (hVolume);

    TLEAVE();

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::LoadDriveTable
//
//  Synopsis:   loads a drive table from a restore point directory
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::LoadDriveTable (WCHAR *pwszPath)
{
    TENTER ("CDriveTable::LoadDriveTable");

    DWORD dwErr = ERROR_SUCCESS;

    if (FALSE == _fLockInit)
    {
        dwErr = _lock.Init();

        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        _fLockInit = TRUE;
    }
    BOOL fLocked = _lock.Lock(CLock::TIMEOUT);
    if (!fLocked)
    {
        return WAIT_TIMEOUT;
    }

    CDataStore  *pds = NULL;
    WCHAR *pwcBuffer = NULL;
    WCHAR *pwszLine = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwFlags = 0;
    DWORD dwFileSize = 0;
    DWORD cbRead = 0;
    int   iChangeLogs = 0;
    WCHAR wcsDrive[MAX_PATH] = L"";
    WCHAR wcsGuid[GUID_STRLEN] = L"";
    WCHAR wcsLabel[CDataStore::LABEL_STRLEN];
    DWORD dwSizeLimit = 0;

    hFile = CreateFileW ( pwszPath,   // file name
                         GENERIC_READ, // file access
                         FILE_SHARE_READ, // share mode
                         NULL,          // SD
                         OPEN_EXISTING, // how to create
                         0,             // file attributes
                         NULL);         // handle to template file

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
        goto Err;
    }

    dwFileSize = GetFileSize (hFile, NULL);
    if (dwFileSize > SR_DEFAULT_DSMAX * MEGABYTE)
    {
        dwErr = ERROR_FILE_CORRUPT;
        goto Err;
    }

    pwcBuffer = (WCHAR *) SRMemAlloc (dwFileSize);
    if (pwcBuffer == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto Err;
    }

    if (FALSE == ReadFile (hFile, (BYTE*)pwcBuffer, dwFileSize, &cbRead, NULL))
    {
        dwErr = GetLastError();
        goto Err;
    }

    pwszLine = pwcBuffer;
    for (UINT i = 0; i < dwFileSize / sizeof(WCHAR); i++)
    {
        if (pwcBuffer[i] == L'\n')
        {
            pwcBuffer[i] = L'\0';  // convert all newlines to terminators
            wcsLabel[0] = L'\0';   // initialize in case scanf terminates early

            if (EOF != swscanf(pwszLine, gs_wcsScanFormat, wcsDrive,
                             wcsGuid, &dwFlags, &iChangeLogs, 
                             &dwSizeLimit, wcsLabel))
            {
                pds = new CDataStore ( this);
                if (pds == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    return dwErr;
                }

                dwErr = pds->LoadDataStore (wcsDrive, wcsGuid,
                                  wcsLabel, dwFlags, iChangeLogs,
                                  (INT64) dwSizeLimit * MEGABYTE);
                if (dwErr != ERROR_SUCCESS)
                    goto Err;

                dwErr = CreateNewEntry (pds);
                if (dwErr != ERROR_SUCCESS)
                    goto Err;
            }
            pwszLine = &pwcBuffer[i+1];  // skip to next line
        }
    }

Err:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    if (pwcBuffer != NULL)
        SRMemFree (pwcBuffer);

    if (fLocked)
        _lock.Unlock();

    TLEAVE();

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDriveTable::SaveDriveTable
//
//  Synopsis:   saves a drive table into a restore point directory
//
//  Arguments:  [prp] -- restore point to save into
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDriveTable::SaveDriveTable (CRestorePoint *prp)
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsPath[MAX_PATH];
    CDataStore *pds = FindSystemDrive();

    if (NULL == pds)
    {
        dwErr = ERROR_INVALID_DRIVE;
        goto Err;
    }

    if (prp == NULL)    // no restore point, so save to the datastore directory
    {
        MakeRestorePath(wcsPath, pds->GetDrive(), L"");
    }
    else
    {
        MakeRestorePath(wcsPath, pds->GetDrive(), prp->GetDir());
    }

    lstrcatW (wcsPath, L"\\");
    lstrcatW (wcsPath, s_cszDriveTable);

    dwErr = SaveDriveTable (wcsPath);

Err:
    return dwErr;
}

DWORD CDriveTable::SaveDriveTable (WCHAR *pwszPath)
{
    TENTER ("CDriveTable::SaveDriveTable");
    
    DWORD dwErr = ERROR_SUCCESS;

    if (FALSE == _fLockInit)
    {
        dwErr = _lock.Init();

        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        _fLockInit = TRUE;
    }
    BOOL fLocked = _lock.Lock(CLock::TIMEOUT);
    if (!fLocked)
    {
        return WAIT_TIMEOUT;
    }

    BOOL  fDirtySave = _fDirty;   // save the dirty bit

    HANDLE hFile = CreateFileW ( pwszPath,   // file name
                         GENERIC_WRITE, // file access
                         0,             // share mode
                         NULL,          // SD
                         CREATE_ALWAYS, // how to create
                         FILE_FLAG_WRITE_THROUGH,             // file attributes
                         NULL);         // handle to template file

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
        goto Err;
    }

    _fDirty = FALSE;  // avoid calling back into SaveDriveTable again

    dwErr = ForAllDrives (CDataStore::SaveDataStore, (LONG_PTR) hFile);
    if (dwErr != ERROR_SUCCESS)
        goto Err;

    if (lstrcmp (pwszPath, L"CONOUT$") != 0)
    {
        if (FALSE == FlushFileBuffers (hFile))    // make sure it's on disk
            dwErr = GetLastError();
    }

Err:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    if (ERROR_SUCCESS == dwErr)
        _fDirty = FALSE;
    else
        _fDirty = fDirtySave;

    if (fLocked)
        _lock.Unlock();

    TLEAVE();

    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::Initialize
//
//  Synopsis:
//
//  Arguments:  fFirstRun -- true if run on first boot
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::Initialize (BOOL fFirstRun)
{
    TENTER("CDataStoreMgr::Initialize");

    DWORD dwErr = ERROR_SUCCESS;

    dwErr = _dt.EnumAllVolumes();

    if (dwErr == ERROR_SUCCESS)
    {    
        CDataStore *pds = _dt.FindSystemDrive();

        // now create system datastore on firstrun
        
        if (pds != NULL) 
        {
            WCHAR wcsPath[MAX_PATH];

            if (fFirstRun)
            {
                // destroy datastores on all drives and 
                // create new on system drive

                SDriveTableEnumContext  dtec = {NULL, 0};

                CDataStore *pdsDel = _dt.FindFirstDrive (dtec);
                while (pdsDel != NULL)
                {
                    if (pdsDel->GetFlags() & (SR_DRIVE_ACTIVE))
                    {
                        dwErr = pdsDel->DestroyDataStore (TRUE);
                        if (dwErr != ERROR_SUCCESS)
                        {
                            trace(0, "! DestroyDataStore : %ld", dwErr);
                            goto Err;
                        }
                    }
                    pdsDel = _dt.FindNextDrive (dtec);
                }
                
                dwErr = pds->CreateDataStore (NULL);
                if (dwErr != ERROR_SUCCESS)
                {
                    trace(0, "! CreateDataStore : %ld", dwErr);
                    goto Err;
                }

                (void) WriteMachineGuid();
            }
            else  // verify that the system datastore exists
            {                
                CDriveTable dt;
                SDriveTableEnumContext  dtec = {NULL, 0};
                CDataStore *pdsACL=NULL;
                
                MakeRestorePath (wcsPath, pds->GetDrive(), L"");
            
                DWORD dwAttr = GetFileAttributes (wcsPath);
                if (0xFFFFFFFF==dwAttr || !(FILE_ATTRIBUTE_DIRECTORY & dwAttr))
                {
                    dwErr = pds->CreateDataStore( NULL );
                }

                 // set the correct ACLs on all the datastores
                pdsACL = _dt.FindFirstDrive (dtec);
                while (pdsACL != NULL)
                {
                    if ( (pdsACL->GetFlags() & (SR_DRIVE_ACTIVE)) &&
                         (pdsACL->GetFlags() & (SR_DRIVE_NTFS)) )
                    {
                        MakeRestorePath(wcsPath, pdsACL->GetDrive(), L"");
                        if (IsDirectoryWorldAccessible(wcsPath))
                        {
                            dwErr = SetCorrectACLOnDSRoot(wcsPath);
                            if (dwErr != ERROR_SUCCESS)
                            {
                                trace(0, "! SetCorrectACLOnDSRoot %ld %S",
                                      dwErr, wcsPath);
                                 //goto Err;
                            }
                        }
                    }
                    pdsACL = _dt.FindNextDrive (dtec);
                }

                MakeRestorePath(wcsPath, pds->GetDrive(), s_cszDriveTable);
                if (ERROR_SUCCESS == dt.LoadDriveTable (wcsPath))
                {
                    dwErr = _dt.Merge(dt);
                    if (dwErr != ERROR_SUCCESS)
                    {
                        trace(0, "! CDriveTable::Merge : %ld", dwErr);
                        goto Err;
                    }
                }
            }

            // update the disk free space variable and 
            // set datastore size for each datastore if not already done
            
            dwErr = UpdateDiskFree(NULL);
            if (dwErr != ERROR_SUCCESS)
            {
                trace(0, "! UpdateDiskFree : %ld", dwErr);
                goto Err;
            }

            // freeze system drive if this is firstrun and disk free is < 200MB

            if (fFirstRun && g_pSRConfig)
            {
                if (pds->GetDiskFree() < (g_pSRConfig->m_dwDSMin * MEGABYTE))  
                {
                    dwErr = FreezeDrive(pds->GetGuid());
                    if (dwErr != ERROR_SUCCESS)
                    {
                        trace(0, "! FreezeDrive : %ld", dwErr);
                        goto Err;
                    }
                }
            }

            MakeRestorePath(wcsPath, pds->GetDrive(), s_cszDriveTable);
            dwErr = _dt.SaveDriveTable (wcsPath);
            if (dwErr != ERROR_SUCCESS)
            {
                trace(0, "! SaveDriveTable : %ld", dwErr);
                goto Err;            
            }
        }
        else dwErr = ERROR_INVALID_DRIVE;
    }
Err:

    TLEAVE();
    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::TriggerFreezeOrFifo
//
//  Synopsis:   checks freedisk space & datastore size,
//              triggering freeze or fifo as required
//  Arguments:  
//
//  Returns:
//
//  History:    27-Apr-2000     brijeshk    Created
//
//--------------------------------------------------------------------------

DWORD
CDataStoreMgr::TriggerFreezeOrFifo()
{
    TENTER("CDataStoreMgr::TriggerFreezeOrFifo");
    
    SDriveTableEnumContext  dtec = {NULL, 0};
    DWORD                   dwRc = ERROR_SUCCESS;    
    CDataStore              *pds = _dt.FindFirstDrive (dtec);

    // update datastore capacities 
    // and get free space on each drive

    dwRc = UpdateDiskFree(NULL);
    if (dwRc != ERROR_SUCCESS)
    {
        trace(0, "! UpdateDiskFree : %ld", dwRc);
        goto done;
    }              
    
    // check the free space and datastore usage
    
    while (pds != NULL && dwRc == ERROR_SUCCESS)
    {
        // we care only if the drive is not already frozen
        // and if it is monitored
        
        if (!(pds->GetFlags() & SR_DRIVE_FROZEN) &&
            (pds->GetFlags() & SR_DRIVE_MONITORED))
        {
            //
            // if there is no rp on this drive,
            // then we don't really care
            //

            CRestorePointEnum rpe((LPWSTR) pds->GetDrive(), FALSE, FALSE);  // backward, include current
            CRestorePoint     rp;
            int nUsagePercent = 0;
    
            DWORD dwErr = rpe.FindFirstRestorePoint(rp) ;
            if (dwErr == ERROR_SUCCESS || dwErr == ERROR_FILE_NOT_FOUND)
            {                    
                if (pds->GetDiskFree() <= THRESHOLD_FREEZE_DISKSPACE * MEGABYTE)
                {
                    dwRc = FreezeDrive(pds->GetGuid());
                }
                else if (pds->GetDiskFree() <= THRESHOLD_FIFO_DISKSPACE * MEGABYTE)
                {
                    dwRc = Fifo(pds->GetGuid(), 0, TARGET_FIFO_PERCENT, TRUE, TRUE);
                }
                else if (ERROR_SUCCESS == pds->GetUsagePercent(&nUsagePercent) 
                         && nUsagePercent >= THRESHOLD_FIFO_PERCENT)
                {
                    dwRc = Fifo(pds->GetGuid(), 0, TARGET_FIFO_PERCENT, TRUE, FALSE);
                }
            }
            
            rpe.FindClose();
        }
        
        pds = _dt.FindNextDrive (dtec);
    }

done:
    TLEAVE();
    return dwRc;
}



//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::FindFrozenDrive
//
//  Synopsis:   returns ERROR_SUCCESS if any drives are frozen
//              ERROR_NO_MORE_ITEMS otherwise
//  Arguments:  
//
//  Returns:
//
//  History:    27-Apr-2000     brijeshk    Created
//
//--------------------------------------------------------------------------

DWORD
CDataStoreMgr::FindFrozenDrive()
{   
    CDataStore * pds = NULL;
    SDriveTableEnumContext dtec = {NULL, 0};
    
    pds = _dt.FindFirstDrive (dtec);

    while (pds != NULL)
    {
        if ((pds->GetFlags() & SR_DRIVE_MONITORED) &&
            (pds->GetFlags() & SR_DRIVE_FROZEN)) 
            return ERROR_SUCCESS;

        pds = _dt.FindNextDrive (dtec);
    }

    return ERROR_NO_MORE_ITEMS;
}



//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::FifoOldRps
//
//  Synopsis:   fifoes out restore points older than a given time period
//              
//  Arguments:  [llTimeInSeconds] -- FIFO interval time
//
//  Returns:
//
//  History:    14-Jul-2000     brijeshk    Created
//
//--------------------------------------------------------------------------
DWORD
CDataStoreMgr::FifoOldRps( 
    INT64 llTimeInSeconds)
{
    TENTER("CDataStoreMgr::FifoOldRps");
    
    CDataStore  *pds = _dt.FindSystemDrive();
    DWORD       dwRc = ERROR_SUCCESS;
    CRestorePointEnum   *prpe = NULL;
    CRestorePoint       *prp = NULL;
    
    if (pds)
    {
        DWORD               dwRpFifo = 0;
        LARGE_INTEGER       *pllRp = NULL, *pllNow = NULL;
        FILETIME            ftNow, *pftRp = NULL;
        
        // enumerate RPs forward on the system drive
        // skip the current one
        // even if the current rp is older than a month, we won't fifo it
        
        prpe = new CRestorePointEnum(pds->GetDrive(), TRUE, TRUE);
        prp = new CRestorePoint;

        if (!prpe || !prp)
        {
            trace(0, "Cannot allocate memory for restore point enum");
            dwRc = ERROR_OUTOFMEMORY;
            goto done;
        }
        
        // get the current time
        
        GetSystemTimeAsFileTime(&ftNow);
        pllNow = (LARGE_INTEGER *) &ftNow;

        dwRc = prpe->FindFirstRestorePoint(*prp);
        
        while (dwRc == ERROR_SUCCESS || dwRc == ERROR_FILE_NOT_FOUND)
        {
            // first check if this is not a cancelled restore point

            if (dwRc != ERROR_FILE_NOT_FOUND && ! prp->IsDefunct())
            {
                // get the restore point creation time
                
                pftRp = prp->GetTime();   
                pllRp = (LARGE_INTEGER *) pftRp;
                
                if (!pllRp || !pllNow)
                {
                    trace(0, "! pulRp or pulNow = NULL");
                    dwRc = ERROR_INTERNAL_ERROR;
                    goto done;
                }

                // check if it is newer than a month
                // if so, stop looking
                // else, try the next restore point
                
                if (pllNow->QuadPart - pllRp->QuadPart < llTimeInSeconds * 10 * 1000 * 1000)
                {
                    trace(0, "%S newer than a month", prp->GetDir());
                    break;            
                }
                else
                {
                    dwRpFifo = prp->GetNum();
                }
            }
            
            dwRc = prpe->FindNextRestorePoint(*prp);
        }    

        // at this point, if dwRpFifo != 0,
        // it contains the latest RP that's older than a month
        // call fifo on this to fifo out all previous RPs including this one

        if (dwRpFifo != 0)
            dwRc = Fifo(pds->GetGuid(), dwRpFifo, 0, FALSE, FALSE);
        else
            dwRc = ERROR_SUCCESS;
    }
    else
    {
        trace(0, "! FindSystemDrive");        
        dwRc = ERROR_INVALID_DRIVE;
    }

done:
    if (prpe)
        delete prpe;
    if (prp)
        delete prp;
        
    TLEAVE();
    return dwRc;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::UpdateDataStoreUsage
//
//  Synopsis:   update the size of a datastore 
//
//  Arguments:  
//
//  Returns:
//
//  History:    27-Apr-2000     brijeshk    Created
//
//--------------------------------------------------------------------------

DWORD    
CDataStoreMgr::UpdateDataStoreUsage(WCHAR *pwszDrive, INT64 llDelta)
{
    TENTER ("CDataStoreMgr::UpdateDataStoreUsage");

    DWORD dwErr = ERROR_SUCCESS;
    CDataStore *pds = _dt.FindDriveInTable(pwszDrive);
    
    if (pds)
    {
        if ((pds->GetFlags() & SR_DRIVE_FROZEN) ||
            ! (pds->GetFlags() & SR_DRIVE_MONITORED))
        {
            TRACE(0, "Size update on frozen/unmonitored drive!");
        }
        else dwErr = pds->UpdateDataStoreUsage(llDelta, TRUE);
    }
    else
        dwErr = ERROR_INVALID_DRIVE;

    TLEAVE();

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:    CDataStoreMgr::GetFlags
//
//  Synopsis:    get the participation bit from a drive
//
//  Arguments:   [pwszDrive] -- drive letter
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::GetFlags(WCHAR *pwszDrive, PDWORD pdwFlags)
{
    CDataStore *pds = _dt.FindDriveInTable (pwszDrive);
    DWORD      dwErr = ERROR_SUCCESS;

    if (NULL != pds)
    {
        *pdwFlags = pds->GetFlags(); 
    }
    else dwErr = ERROR_INVALID_DRIVE;

    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:    CDataStoreMgr::GetUsagePercent
//
//  Synopsis:    get the datastore usage for a drive
//
//  Arguments:   [pwszDrive] -- drive letter
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::GetUsagePercent(WCHAR *pwszDrive, int *pnPercent)
{
    CDataStore *pds = _dt.FindDriveInTable (pwszDrive);
    DWORD      dwErr = ERROR_SUCCESS;

    if (NULL != pds)
    {
        dwErr = pds->GetUsagePercent(pnPercent);
    }
    else dwErr = ERROR_INVALID_DRIVE;

    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:    CDataStoreMgr::SwitchRestorePoint
//
//  Synopsis:    change the drive table when switching restore points
//
//  Arguments:   [prp] -- old restore point
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::SwitchRestorePoint (CRestorePoint *prp)
{
    DWORD dwErr = ERROR_SUCCESS;
    
    dwErr = _dt.ForAllDrives (&CDataStore::CountChangeLogs, (LONG_PTR) prp);
    if (dwErr != ERROR_SUCCESS)
        goto Err;

    // persist old restore point dt

    if (prp)    
    {
        dwErr = _dt.SaveDriveTable (prp);
        if (dwErr != ERROR_SUCCESS)
            goto Err;
    }

    // remove old volumes

    dwErr = _dt.RemoveDrivesFromTable ();
    if (dwErr != ERROR_SUCCESS)
        goto Err;              

    // reset per-rp flags

    dwErr = _dt.ForAllDrives (&CDataStore::ResetFlags, NULL);
    if (dwErr != ERROR_SUCCESS)
        goto Err;

    // persist current restore point dt
    
    dwErr = _dt.SaveDriveTable((CRestorePoint *) NULL);

Err:
    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::FreezeDrive
//
//  Synopsis:   freeze a drive 
//
//  Arguments:  [pwszDrive] -- drive
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::FreezeDrive(WCHAR *pwszDrive)
{
    DWORD       dwErr = ERROR_SUCCESS;
	WCHAR szThawSize[GUID_STRLEN], szSystemDrive[MAX_SYS_DRIVE] = L" ";
    

	TENTER("CDataStoreMgr::FreezeDrive");

    if (pwszDrive != NULL)
    {
        CDataStore *pds = _dt.FindDriveInTable (pwszDrive);

        if (! pds)
        {
            dwErr = ERROR_INVALID_DRIVE;
			TRACE (0, "FindDriveInTable failed in CDataStoreMgr::FreezeDrive %ld\n", dwErr);
            goto Err;
        }

        //            
        // freeze all drives
        //
    }

    dwErr = _dt.ForAllDrives (CDataStore::FreezeDrive, NULL);

    if (dwErr == ERROR_SUCCESS)
    {
        //
        // rebuild _filelst.cfg and pass to filter
        //
        
        ASSERT(g_pEventHandler);
        dwErr = g_pEventHandler->SRUpdateMonitoredListS(NULL);

        if (g_pSRService != NULL)            
        {
            if (g_pSRConfig && g_pSRConfig->m_dwFreezeThawLogCount < MAX_FREEZETHAW_LOG_MESSAGES)             
            {
				TRACE (0, "Freezing the SR service due to low disk space.");
				wsprintf(szThawSize, L"%d",THRESHOLD_THAW_DISKSPACE);
				if (pwszDrive == NULL)
				{
					if(GetSystemDrive(szSystemDrive) == FALSE)
						TRACE (0, "GetSystemDrive failed in CDataStoreMgr::FreezeDrive.");			
					pwszDrive = szSystemDrive;
				}
                g_pSRService->LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_FROZEN, NULL, 0, szThawSize, pwszDrive);
                g_pSRConfig->m_dwFreezeThawLogCount++;
            }
        }
    }

    //
    // request for idle time 
    // so that we can thaw later
    //

    ASSERT(g_pSRConfig);
    SetEvent(g_pSRConfig->m_hIdleRequestEvent);
        
    if (g_pEventHandler)
        g_pEventHandler->RefreshCurrentRp(FALSE);   

    if (g_pSRConfig->m_dwTestBroadcast)
        PostTestMessage(g_pSRConfig->m_uiTMFreeze, NULL, NULL);

Err: 
	TLEAVE();
    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::IsDriveFrozen
//
//  Synopsis:   check if given drive is frozen
//              if NULL, check if any drive is frozen
//
//  Arguments:  
//
//  Returns:
//
//  History:    21-Jul-2000     Brijeshk    Created
//
//--------------------------------------------------------------------------

BOOL CDataStoreMgr::IsDriveFrozen(LPWSTR pszDrive)
{
    CDataStore              *pds = NULL;
    SDriveTableEnumContext  dtec = {NULL, 0};
    
    if (!pszDrive)
    {
        pds = _dt.FindFirstDrive(dtec);
        while (pds)
        {
            if (pds->GetFlags() & SR_DRIVE_FROZEN)
                return TRUE;
            pds = _dt.FindNextDrive(dtec);
        }
    }
    else
    {
        CDataStore *pds = _dt.FindDriveInTable(pszDrive);
        if (pds)
        {
            if (pds->GetFlags() & SR_DRIVE_FROZEN)
                return TRUE;
        }
    }

    return FALSE;
}



//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::ThawDrives
//
//  Synopsis:   thaw one or more drives
//
//  Arguments:  [fCheckOnly] -- if TRUE do not actually thaw
//
//  Returns:    if any drive is thawed, returns ERROR_SUCCESS
//              else returns ERROR_NO_MORE_ITEMS
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD
CDataStoreMgr::ThawDrives(BOOL fCheckOnly)
{
    TENTER("CDataStoreMgr::ThawDrives");
    
    CDataStore  *pds = NULL, *pdsSys = _dt.FindSystemDrive();
    DWORD       dwRc = ERROR_NO_MORE_ITEMS;
    SDriveTableEnumContext dtec;
    DWORD       dwTemp;
    
    if (! pdsSys)
    {
        dwRc = ERROR_INVALID_DRIVE;
        TRACE (0, "Cannot find system drive %ld\n", dwRc);
        goto done;
    }
    
    // if system drive is frozen, then check if 200mb is free 
    // if yes, then thaw all drives
    // if no, thaw none
    
    ASSERT(pdsSys->GetFlags() & SR_DRIVE_MONITORED);
    
    if ((pdsSys->GetFlags() & SR_DRIVE_FROZEN))
    {        
        dwRc = pdsSys->UpdateDiskFree(NULL);
        if (dwRc != ERROR_SUCCESS)
        {
            trace(0, "! UpdateDiskFree : %ld", dwRc);
            goto done;
        }
           
        if (pdsSys->GetDiskFree() >= THRESHOLD_THAW_DISKSPACE * MEGABYTE)
        {   
            if (fCheckOnly)
            {
                dwRc = ERROR_SUCCESS;
                goto done;
            }
            
            pds = _dt.FindFirstDrive (dtec);
            while (pds != NULL)
            {
                dwTemp = pds->ThawDrive(NULL);
                if (dwTemp != ERROR_SUCCESS)     // remember the error and
                {
                    dwRc = dwTemp;               // keep on going
                    TRACE (0, "ThawDrive failed with %ld\n", dwRc);
                }
                pds = _dt.FindNextDrive (dtec);
            }
        }
        else        // cannot thaw now
        {
            dwRc = ERROR_NO_MORE_ITEMS;
            TRACE (0, "No drives to thaw %ld\n", dwRc);
        }
    }
    else // make sure all the other drives are thawed too for consistency
    {
        pds = _dt.FindFirstDrive (dtec);
        while (pds != NULL)
        {
            if (pds->GetFlags() & SR_DRIVE_FROZEN)
                pds->ThawDrive(NULL);

            pds = _dt.FindNextDrive (dtec);
        }
        dwRc = ERROR_SUCCESS;
    }

    if (_dt.GetDirty())
    {
        dwRc = _dt.SaveDriveTable ((CRestorePoint *) NULL);
        if (dwRc != ERROR_SUCCESS)
            TRACE (0, "SaveDriveTable failed with %ld\n", dwRc);
    }                        

    if (g_pSRService != NULL && ERROR_SUCCESS == dwRc && FALSE == fCheckOnly) 
    {        
        if (g_pSRConfig && g_pSRConfig->m_dwFreezeThawLogCount <= MAX_FREEZETHAW_LOG_MESSAGES)             
        {
            g_pSRService->LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_THAWED);
            g_pSRConfig->m_dwFreezeThawLogCount++;
        }
    }

done:
    TLEAVE();
    return dwRc;
}




//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::MonitorDrive
//
//  Synopsis:   enable/disable a drive 
//
//  Arguments:  [pwszDrive] -- drive, [fSet] -- enable/disable
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------
DWORD CDataStoreMgr::MonitorDrive(WCHAR *pwszDrive, BOOL fSet)
{
    CDataStore *pds = pwszDrive ? _dt.FindDriveInTable(pwszDrive) : NULL;
    DWORD      dwErr = ERROR_SUCCESS;
    BOOL       fTellFilter = TRUE;

    if (! pwszDrive || ! pds || pds == _dt.FindSystemDrive())    // system drive
    {
        // something wrong
        // cannot enable/disable whole of SR this way

        dwErr = ERROR_INVALID_DRIVE;
    }
    else    
    {
        // enable/disable only this drive

        dwErr = pds->MonitorDrive(fSet);
        if (ERROR_SUCCESS == dwErr && (pds->GetFlags() & SR_DRIVE_FROZEN))
            fTellFilter = FALSE;
    }


    if (dwErr == ERROR_SUCCESS)
    {
        // update drivetable on disk

        if (_dt.GetDirty())
        {
            dwErr = _dt.SaveDriveTable ((CRestorePoint *) NULL);

            // rebuild _filelst.cfg and pass to filter
            if (fTellFilter)
            {
                ASSERT(g_pEventHandler);
                dwErr = g_pEventHandler->SRUpdateMonitoredListS(NULL);
            }
        }
    }

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::WriteMachineGuid
//
//  Synopsis:   write machine guid for disk cleanup utility
//
//  Arguments:  
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::WriteMachineGuid ()
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsPath [MAX_PATH];

    if (0 == GetSystemDirectoryW (wcsPath, MAX_PATH))
    {
        dwErr = GetLastError();
    }
    else
    {
        lstrcatW (wcsPath, L"\\Restore\\MachineGuid.txt");

        HANDLE hFile = CreateFileW ( wcsPath,   // file name
                          GENERIC_WRITE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_ALWAYS, // how to create
                          0,             // file attributes
                          NULL);         // handle to template file

        if (INVALID_HANDLE_VALUE == hFile)
        {
            dwErr = GetLastError();
        }
        else
        {
            WCHAR *pwszGuid = GetMachineGuid();
            ULONG cbWritten;

            if (FALSE == WriteFile (hFile, (BYTE *) pwszGuid,
                             (lstrlenW(pwszGuid)+1) * sizeof(WCHAR),
                             &cbWritten, NULL))
            {
                dwErr = GetLastError();
            }
            CloseHandle (hFile);
        }
    }

    return dwErr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::DeleteMachineGuidFile
//
//  Synopsis:   write machine guid for disk cleanup utility
//
//  Arguments:
//
//  Returns:
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::DeleteMachineGuidFile ()
{
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR wcsPath [MAX_PATH];

    if (0 == GetSystemDirectoryW (wcsPath, MAX_PATH))
    {
        dwErr = GetLastError();
    }
    else
    {
        lstrcatW (wcsPath, L"\\Restore\\MachineGuid.txt");
        if (FALSE == DeleteFileW (wcsPath))
            dwErr = GetLastError();
    }
    return dwErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   CDataStoreMgr::Compress
//
//  Synopsis:   compress files in each datastore
//
//  Arguments:  lDuration - duration to compress
//
//  Returns:
//
//  History:    26-Feb-01 Brijeshk Created
//
//--------------------------------------------------------------------------

DWORD CDataStoreMgr::Compress (
    LPWSTR pszDrive,
    LONG   lDuration)
{
    TENTER("CDataStoreMgr::Compress");

    DWORD   dwErr = ERROR_SUCCESS;
    CDataStore *pds = NULL, *pdsSys = NULL;
    INT64   llAllocated = 0, llUsed = 0; 
    SDriveTableEnumContext dtec = {NULL, 0}; 
    BOOL    fFirstTime;

    llAllocated = lDuration * 1000 * 1000 * 10; // 100's of nanoseconds
    
    //
    // if drive specified, compress only that
    // 

    if (pszDrive)
    {
        pds = _dt.FindDriveInTable(pszDrive);
        if (pds)
        {
            dwErr = pds->Compress(llAllocated, &llUsed);
        }
        else
        {
            dwErr = ERROR_INVALID_DRIVE;
        }
        goto Err;
    }

    
    // 
    // else, compress all drives if time permits
    // starting with system drive
    //

    pdsSys = _dt.FindSystemDrive();
    pds = pdsSys;
    fFirstTime = TRUE;
    while (pds)
    {
        if (fFirstTime || pds != pdsSys)
        {
            trace(0, "Allocated time for %S is %I64d", pds->GetDrive(), llAllocated);

            llUsed = 0;
            dwErr = pds->Compress(llAllocated, &llUsed);
            if (dwErr != ERROR_SUCCESS && dwErr != ERROR_OPERATION_ABORTED)
            {
                trace(0, "! Compress : %ld", dwErr);
                goto Err;
            }

            llAllocated -= llUsed;
            
            if (llAllocated <= 0)
            {
                //
                // used up all time
                //
                dwErr = ERROR_OPERATION_ABORTED;
                break;
            }
        }
        
        //
        // go to next drive
        //
        if (fFirstTime)
        {
            pds = _dt.FindFirstDrive(dtec);
        }
        else
        {
            pds = _dt.FindNextDrive(dtec);
        }
        fFirstTime = FALSE;
    }    
        
Err:
    TLEAVE();
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\redist\strings.inc ===
<% @LANGUAGE="VBScript" @CODEPAGE="1252" @EnableSessionState="False"  %>
<%
OPTION Explicit
Response.Buffer = True
Response.Expires = 0
Function getString(sStringName)

	'for main title
	Const L_SiteTitle_text = "Windows XP Help and Support Services"
	
	'for initial page
	Const L_mainheading_text = "Compatible Hardware and Software"
	Const L_maintext_text = "Type the product name: "
	Const L_protext_text = "Product"
	Const L_manuf_text = "Manufacturer Name"
	Const L_sw_text = "Software"
	Const L_hw_text = "Hardware"
	Const L_sub_text = "... or browse list of"
	
	'for quickfind main
	Const L_QFmain1_text = "Type the product name: "
	Const L_searchtips_text = "<nobr>Tips on searching...</nobr>"
	Const L_search_text = "<u>S</u>earch"
	Const L_sfproducts_text = "Searching"
	Const L_QfindHead_text = "Search for hardware and software by name"
	Const L_QfindSubHead_text = "Find which hardware and software is compatible with Windows XP"
	Const L_QfindPS_text = "Product Search"
	
	'for search tips
	Const L_searchtitle_text = "Tips on searching"
	Const L_searchthead_text = "Compatible Hardware and Software Search Tips"
	Const L_searchtip1_text = "If your search returns no results, make sure to check the spelling of the manufacturer or product name. "
	Const L_searchtip2_text = "Queries are not case-sensitive. You can type your search in uppercase or lowercase. "
	Const L_searchtip3_text = "Any words you enter in Search are initially treated as exact phrases. Search attempts to return results that contain at least one occurrence of the exact sequence of words you entered, in the same order. If it can't find the exact phrase, Search then systematically looks for results that contain any combination of all the words. If that fails, Search looks for occurrences of each individual word in the phrase. Finally, if no results are found, Search tries to guess what you might have meant to type.  "
	Const L_searchtip5_text = "Punctuation marks such as the period (.), colon (:), semicolon (;), and comma (,) are not recognized during a search.  "
	Const L_example1_text = "Type <B>Microsoft</B> to find all products made by the Microsoft Corporation that are compatible with Windows XP. "
	Const L_example2_text = "Type <B>games</B> to find game programs that are compatible with Windows XP. "
	Const L_example3_text = "Type <B>Office</B> to find all versions of Microsoft Office that are compatible with Windows XP."
	Const L_examplehead_text = "Examples:"
	 
	'for qfind results
	Const L_qfrheading_text = "Search results"
	Const L_dfnoresults1_text = "No matches were found for your search.  You may want to try again, consult the "
	Const L_dfnoresults2_text = "search tips"
	Const L_dfnoresults3_text = ", or contact the manufacturer."
	Const L_qfrtext1_text = "search results found for"
	Const L_qfrtext2_text = "Tell me more about compatibility status ratings"
	Const L_moreqresults_text = "More than 250" 
	Const L_moreresultstext_text = " First 250 shown. "
	Const L_sorthead_text = ""
	Const L_clkdetails_text = "Click <b>Details</b> to find out more about the product."
	
	'for leftnav
	Const L_lqf_text = "Product Search"
	Const L_llum_text = "Manufacturer Search"
	Const L_lbsc_text = "Software  Lists"
	Const L_lbhc_text = "Hardware Lists"
	Const L_lqftt_text = "Search for products compatible with Windows XP."
	Const L_llumtt_text = "Search by manufacturer for products compatible with Windows XP."
	Const L_lbsctt_text = "Browse for software compatible with Windows XP."
	Const L_lbhctt_text = "Browse for hardware compatible with Windows XP."	
	Const L_ltools_text = "See Also"
	Const L_aboutcom_text = "About Compatible Hardware and Software"
	Const L_lmci_text = "My Computer Information"
	Const L_lrelated_text = "Related Links"
	Const L_lmsf_text = "Microsoft Support Feedback"
	Const L_luc_text = "Windows Update"
	Const L_compatmode_text = "Program Compatibility Wizard"
	Const L_HWUpdate_text = "Hardware Upgrade Information"
	Const L_aboutcomtt_text = "Read general information about this Web site."
	Const L_luctt_text = "Keep your computer current with the latest downloads."
	Const L_lmcitt_text = "View information about your system hardware and software."
	Const L_compatmodett_text = "Resolve the most common compatibility problems between your programs and Windows XP that occur after an upgrade."
	
	'for look up manufacturer
	Const L_lumhead_text = "Search for products by manufacturer name"
	Const L_lummain1_text = "Type the first few letters of the manufacturer's name:"
	Const L_lummain3_text = "To view a list of products made by a manufacturer in the <B>Possible matches</B> list, click a manufacturer name, and then click <B>Search</B>."
	Const L_lummain2_text = "Possible matches:"
	Const L_manufacturer_text = "Manufacturer"
	Const L_product_text = "Product"
	Const L_status_text = "Status"
	Const L_details_text = "Details"
	Const L_mannomatcth_text = "No matches were found.  This manufacturer may not have submitted information about their products to Microsoft.  Please check that you spelled the manufacturer name correctly or for more compatibility information, contact the manufacturer."
	Const L_manSrch_text = "Manufacturer Search"
	
	'for browse Categories
	Const L_BSWHead_text = "Software Lists"
	Const L_BSWMain1_text = "To see a list of software programs, click a category link."
	Const L_BhWHead_text = "Hardware Lists"
	Const L_BhWMain1_text = "To see a list of hardware, click a category link."
	
	'brow cat result
	Const L_bcatr_text = "Click <B>Details</B> to find out more about the product. "
	Const L_bcatrat_text = "Tell me more about compatibility status ratings"
	
	'for about compatibility page
	Const L_ABheading_text = "About Compatible Hardware and Software"
	Const L_ABtext1_text = "Compatible Hardware and Software is an informational service that helps you decide which programs and hardware will work best with your computer. Use Compatible Hardware and Software to preview hardware and software before you buy it."
	Const L_ABtext2_text = "New software and hardware compatibility status information is added to the site regularly, so you can always get the most recent information to protect your computer and keep it running smoothly"
	Const L_ABsubheading_text = "How do I know if hardware and software will be compatible with Windows XP?"
	Const L_ABtext3_text = "You can search or browse by manufacturer or product to see which hardware and software is compatible and incompatible with Windows XP and if you need an update."
	Const L_ABtext4_text = "In many cases, Microsoft, Independent Software Vendors (ISV) or Independent Hardware Vendors (IHV) have tested a product and rated its compatibility. Or, the product's compatibility status is determined through practical use. Microsoft encourages ISV and IHV representatives to submit information about how well their product has worked with Windows XP." 	
	Const L_ABtext5_text = "<B>Note</B> This is not necessarily a complete list of products compatible with Windows XP. If you have a product that is compatible with Windows XP and it is not on this list, please notify the appropriate vendor and request that they register their products on the "
	Const L_ABtext6_text = "<A HREF='http://msdnisv.microsoft.com/msdnisv/win2000' target='compat'>software registration</A>"
	Const L_ABtext7_text = " or "
	Const L_ABtext8_text = "<A HREF='http://www.microsoft.com/hwtest/' target='compat'>hardware registration</A>"
	Const L_ABtext9_text = " Web sites."

	'for details page
	Const L_swdetails_text = "<i>Note this directory is not necessarily a complete list of applications compatible with Windows XP: It is a collection of products tested by Microsofts application compatibility team.</i>  If you have an application that is compatible with Windows XP and it is not on this list, please notify the appropriate vendor and request that they register their product at <a href=http://msdnisv.microsoft.com/msdnisv/win2000  target='compat'> http://msdnisv.microsoft.com/msdnisv/win2000</a>. "
	Const L_hwdetails_text = "<i>Note this directory is not necessarily a complete list of products compatible with Windows XP: It is a collection of products tested by Microsofts Hardware Quality Labs.</i> If you have hardware that is compatible with Windows XP and it is not on this list, please notify the appropriate vendor and request that they register their product at <a href=http://www.microsoft.com/hwtest/  target='compat'>http://www.microsoft.com/hwtest</a>."
	Const L_hwdclickhere_text = "Click here"
	Const L_hwddriver_text = "to download the driver"
	Const L_hwcman_text = "to go the manufacturer's site to get the latest BIOS"
	Const L_contact_text = "Contact Information"
	Const L_address_text = "Address"
	Const L_phone_text = "Phone"
	Const L_fax_text = "Fax"
	Const L_support_text = "Support Phone"
	Const L_company_text = "Company"
	Const L_swaditional_text = "If you have upgraded to Windows XP from another version of Windows, this product might not be compatible with Windows XP."
	Const L_detect_text = "It appears that you are running"
	Const L_SerCleanWhist_text = "Windows XP Advanced Server Clean Installation"
	Const L_SerCleanWhistDTC_text = "Windows XP DataCenter Clean Installation"
	Const L_whisperhomeclean_text = "Windows XP Personal Clean Installation"
	Const L_wprocorpclean_text = "Windows XP Professional Clean Installation"
	
	'Const L_whperwin98rtm_text = "Windows XP Personal: Upgrade from Windows 98 "  
	'Const L_whperwin98se_text = "Windows XP Personal:  Upgrade from Windows 98 Second Edition  "
	'Const L_whperclean_text = "Windows XP Personal: Clean Install "
	'Const L_whperme_text = "Windows XP Personal:  Upgrade From Windows Me"
	'Const L_whprowin98rtm_text = "Windows XP Professional: Upgrade from Windows 98    "
	'Const L_whprowin98se_text = "Windows XP Professional: Upgrade from Windows 98 Second Edition  "
	'Const L_whproclea_text = "Windows XP Professional:  Clean Install  "
	'Const L_whpront4_text = " Windows XP Professional:  Upgrade from Windows NT 4"
	'Const L_whprowin2000sp1_text = "Windows XP Professional:  Upgrade from Windows 2000 SP1  "
	'Const L_whprome_text = "Windows XP Professional:  Upgrade from Windows Me  "
	
	'for status text
	Const L_HWDcompatible_text = "Microsoft has certified that this product is compatible with Windows XP. The driver for this hardware device is included on the Windows XP CD-ROM."
	Const L_hwdcomatibleinf_text = "This device may require an updated driver to be compatible with Windows XP. To obtain the driver, contact the device manufacturer."
	Const L_hwdcompatibledown_text = "This product requires you download the manufacturer's driver. To obtain this driver,  click  and follow the instructions to download: <a href='javascript:ShowDTips(false)'>Tips for downloading</a>"
	Const L_HWccompatible_text = "Microsoft has certified that this product is compatible with Windows XP. The BIOS for this hardware device is included on the Windows XP CD-ROM."
	Const L_hwccompatiblebios_text = "This product requires you download the manufacturer's BIOS update. To obtain this manufacturer update, click and follow the instructions :"
	Const L_ScenFrom_text = "From"
	Const L_ScenStatus_text = "Status"
	
	'Const L_swcompatible_text = "Microsoft tested basic functionality and found this product compatible with Windows XP. However, results when using this product on your system may differ. For more specific compatibility information, you can also contact the product vendor."
	'Const L_swcautioninf_text = "Compatibility data is not available for this product. Microsoft cannot guarantee the performance of this product with Windows XP. For more information, contact the product manufacturer."
	'Const L_swcautionup_text = "Microsoft has tested this product and found it to be compatible with Windows XP but you may need a driver update from the hardware manufacturer."
	'Const L_swcautionki_text = "Microsoft has tested this product and found it to be incompatible with Windows XP."
	
	Const L_swcompatible_text = "Microsoft tested basic functionality and found this product compatible with Windows XP. However, results when using this product on your system may differ. For more specific compatibility information, you can also contact the product vendor."
	Const L_swcompatibleup_text = "Microsoft has tested this product and found it to be compatible with Windows XP only if you apply an update."
	Const L_swcompatiblecn_text = "Microsoft has tested this product and detected superficial problems that will not affect its functions or features."
	Const L_swnoinfavb_text = "Compatibility data is not available for this product. Microsoft cannot guarantee the performance of this product with Windows XP. For more information, contact the product manufacturer."
	Const L_swcautionki_text = "Microsoft has tested this product and found it to be incompatible with Windows XP."
	
	'status popup text
	'Const L_ststustitle_text = "Compatible Hardware and Software Status Ratings"
	'Const L_statuspophead_text = "Compatible Hardware and Software Status Ratings"
	'Const L_compatible_text = "<b>Compatible</b><br>Microsoft tested this product and found it to be compatible with Windows XP.<br> -or- <br>Microsoft has certified that this product is compatible with Windows XP."
	'Const L_cautionki_text = "<b>Caution (Known Incompatibility)</b><br>Microsoft has tested this product and found it to be incompatible with Windows XP. "
	'Const L_cautionin_text = "<b>Caution (Informational)</b><br>Compatibility data is not available for this product. Microsoft cannot guarantee the performance of this product with Windows XP. For more information, contact the product manufacturer.<br>-or-<br>Microsoft has tested this product and detected superficial problems that will not affect its functions or features."
	'Const L_cautionup_text = "<b>Caution (Update Required)</b><br>Microsoft has tested this product and found it to be compatible with Windows XP only if you apply an update."
	'Const L_close_text = "Close"
	
	'status popup text
	Const L_ststustitle_text = "Compatible Hardware and Software Status Ratings"
	Const L_statuspophead_text = "Compatible Hardware and Software Status Ratings"
	Const L_compatible_text = "<b>Compatible</b><br>Microsoft tested this product and found it to be compatible with Windows XP.<br> -or- <br>Microsoft has certified that this product is compatible with Windows XP."
	Const L_compatibleup_text = "<b>Compatible (Update Required)</b><br>Microsoft has tested this product and found it to be compatible with Windows XP only if you apply an update."
	Const L_compatiblecn_text = "<b>Compatible (Cautionary Note)</b><br>Microsoft has tested this product and detected superficial problems that will not affect its functions or features."
	Const L_noinfavb_text = "<b>No Information Available</b><br>Compatibility data is not available for this product. Microsoft cannot guarantee the performance of this product with Windows XP. For more information, contact the product manufacturer."
	Const L_cautionki_text = "<b>Caution (Known Incompatibility)</b><br>Microsoft has tested this product and found it to be incompatible with Windows XP. "
	Const L_close_text = "Close"
	
	'for download tips
	Const L_downloadtitle_text = "Compatible Hardware and Software - Download Tips"
	Const L_dwheading1_text = "Downloading and installation Instructions"
	Const L_dwheading2_text = "Basic Installation and Setup"
	Const L_dwheading3_text = "MS-DOS-based Installation"
	Const L_dwheading4_text = "Windows Installation"
	Const L_dwheading5_text = "Downloading and Extracting a File"
	Const L_dwheading6_text = "To create a downloads folder:"
	Const L_dwheading7_text = "To download files:"
	Const L_dwtext1_text = "Many drivers can be installed on your system automatically, but other downloads require that you manually install the driver in Windows. Actual installation programs vary from driver to driver, but there are three main types of download scenarios:"
	Const L_dwtext2_text = "Many downloads run on your system as a basic installation Setup program, using some type of File Transfer Protocol (FTP). The Setup program guides you through the process by using a series of dialog boxes. A dialog box will appear, asking where to save the file. When you install the download, the FTP copy of the files for the driver are transferred to your computer. These files may include the .exe file that installs the driver, the Setup program that guides you through the process, and any documentation or README text files provided by the device manufacturer. "
	Const L_dwtext3_text = "Some driver-download programs will open one or more MS-DOS windows and then run commands to download the driver to your system. You may be prompted to press ENTER or other keys to progress through the installation. "
	Const L_dwtext4_text = "Some driver downloads must be manually installed on Windows. To do this, follow the steps on the "
	Const L_dwtext41_text = "installing devices"
	Const L_dwtext42_text = " page."
	Const L_dwtext5_text = "Some driver downloads require you to download and extract files to a specific location on your computer. To download these driver files correctly, follow these steps. "
	Const L_dwtext6_text = "The download install program will ask you for a location to copy the download files. To do this:"
	Const L_dwtext7_text = "1.	On your desktop, double-click <b>My Computer</b>. "
	Const L_dwtext8_text = "2.	Double-click the C drive icon (it may have a label name before it). "
	Const L_dwtext9_text = "3.	Click the <B>File</B> menu, point to <b>New</b>, and click <b>Folder</b>. "
	Const L_dwtext10_text = "4.	Type <b>""drivers""</b> and press ENTER key. "
	Const L_dwtext11_text = "1.	On the Web page, click the link for the file you want to download. A dialog box will appear, asking where to save the file. "
	Const L_dwtext12_text = "2.	Find and click the <B>Save in</B> drop-down list and click the up arrow until <b>C:</b> is visible. Click <b>C:</b>. "
	Const L_dwtext13_text = "3.	Locate and click the drivers folder you created in the step above. "
	Const L_dwtext14_text = "4.	Click <b>Save</b>. "
	Const L_dwtext15_text = "5.	Double-click the file. The file will extract into a number of different files, which will be located either in a folder inside the Drivers folder you just created, with the same numerical name as the driver file, or in a file named by the type driver. For example, a video driver might be found in a folder called C:\Video. "
	Const L_dwtext16_text = "6.	One of the files installed with your driver will be called ""README.TXT"".  This file may contain further instructions on how to use the files you have downloaded. "
	
	'' mstoolbar.asp ''
	Const L_ToolbarSiteLabel_Text = "Microsoft Windows Update"
	Const L_ToolbarWindowsLabel_Text = "WINDOWS SITES"
	Const L_ToolbarOfficeUpdateLabel_Text = "OFFICE UPDATE"
	
	'doesn't need localization....HTML tag
	Const L_dir_text = ""
	Const L_lcidcode_text = "text/html;charset=windows-1252"
	Const L_lan_text = "en"
	
	getString = Eval(sStringName)
End Function

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\enumlogs.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    changelog.h
 *
 *  Abstract:
 *    CChangeLogEnum class definition
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _CHANGELOG_H_
#define _CHANGELOG_H_


#include "respoint.h"
#include "utils.h"

// restore point enumeration class

class CRestorePointEnum {

public:
    CRestorePointEnum();
    CRestorePointEnum(LPWSTR pszDrive, BOOL fForward, BOOL fSkipLast);
    ~CRestorePointEnum();
    
    DWORD FindFirstRestorePoint(CRestorePoint&);
    DWORD FindNextRestorePoint(CRestorePoint&);
    DWORD FindClose();
    
private:
    CFindFile       FindFile;
    WCHAR           m_szDrive[MAX_PATH];
    BOOL            m_fForward;
    BOOL            m_fSkipLast;
    CRestorePoint   *m_pCurrentRp;
};


// change log enumeration class

class CChangeLogEntryEnum {

private:
    BOOL                m_fForward;
    CRestorePointEnum * m_pRestorePointEnum;
    CRestorePoint       m_RPTemp;
    DWORD               m_dwTargetRPNum;
    CLock               m_DSLock;  
    BOOL                m_fHaveLock; 
    BOOL                m_fLockInit;
    BOOL                m_fIncludeCurRP;
    WCHAR               m_szDrive[MAX_PATH];

public:
    CChangeLogEntryEnum();
    CChangeLogEntryEnum(LPWSTR pszDrive, BOOL fForward, DWORD dwRPNum, BOOL fIncludeCurRP);
    ~CChangeLogEntryEnum();

    DWORD WINAPI FindFirstChangeLogEntry(CChangeLogEntry&);
    DWORD WINAPI FindNextChangeLogEntry(CChangeLogEntry&);
    DWORD WINAPI FindClose();
};


DWORD WINAPI GetCurrentRestorePoint(CRestorePoint& rp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\utest\dstortest.cpp ===
#include "..\datastormgr.h"
#include <stdio.h>

void __cdecl main ()
{
    DWORD dwErr = ERROR_SUCCESS;
    CDriveTable *pdt = NULL;

    g_pDataStoreMgr = new CDataStoreMgr();
    if (g_pDataStoreMgr == NULL)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr == ERROR_SUCCESS)
        dwErr = g_pDataStoreMgr->Initialize(TRUE);

    pdt = g_pDataStoreMgr->GetDriveTable ();
    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->SaveDriveTable (L"dstortest.txt");

    pdt = new CDriveTable();
    if (pdt == NULL)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->LoadDriveTable (L"dstortest.txt");

    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->SaveDriveTable (L"CONOUT$");

    if (dwErr == ERROR_SUCCESS)
        dwErr = g_pDataStoreMgr->Compress (NULL, 25);

    if (dwErr == ERROR_SUCCESS)
    {
        delete g_pDataStoreMgr;
        g_pDataStoreMgr = new CDataStoreMgr();
        if (g_pDataStoreMgr == NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        WCHAR wcsPath[MAX_PATH];
        MakeRestorePath (wcsPath, L"C:\\", L"RP1");
        CreateDirectory (wcsPath, NULL);

        MakeRestorePath (wcsPath, L"C:\\", L"RP2");
        CreateDirectory (wcsPath, NULL);

        lstrcat (wcsPath, L"\\A1.TXT");
        FILE *f = _wfopen(wcsPath, L"w");
        if (f)  fclose (f);

        MakeRestorePath (wcsPath, L"C:\\", L"RP2");
        lstrcat (wcsPath, L"\\change1.log");
        f = _wfopen(wcsPath, L"w");
        if (f)  fclose (f);
    }

    if (dwErr == ERROR_SUCCESS)
        dwErr = g_pDataStoreMgr->Initialize(FALSE);

    if (dwErr == ERROR_SUCCESS)
        dwErr = g_pDataStoreMgr->CountChangeLogs (NULL);

    pdt = g_pDataStoreMgr->GetDriveTable ();
    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->SaveDriveTable (L"dstortest.txt");

    pdt = new CDriveTable();
    if (pdt == NULL)
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->LoadDriveTable (L"dstortest.txt");

    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->SaveDriveTable (L"CONOUT$");

    if (dwErr == ERROR_SUCCESS)
        dwErr = g_pDataStoreMgr->Compress (NULL, 25);

    if (dwErr == ERROR_SUCCESS)
    {
        SDriveTableEnumContext dtec;
        CDataStore *pds = pdt->FindFirstDrive (dtec);
        while (pds != NULL)
        {
            printf ("Found drive %ws %ws\n", pds->GetDrive(), pds->GetGuid());
            pds = pdt->FindNextDrive (dtec);
        }
        printf ("Found drive DONE.\n");
    }

    if (dwErr == ERROR_SUCCESS)
        dwErr = pdt->AddDriveToTable (L"Z:\\", NULL);

    if (dwErr == ERROR_SUCCESS)
    {
        SDriveTableEnumContext dtec;
        CDataStore *pds = pdt->FindFirstDrive (dtec);    
        while (pds != NULL)
        {
            printf ("Found drive %ws %ws\n", pds->GetDrive(), pds->GetGuid());
            pds = pdt->FindNextDrive (dtec);
        }
        printf ("Found drive DONE.\n");
    }

    if (dwErr == ERROR_SUCCESS)
    {
        dwErr = GetDomainMembershipInfo (L"domain.txt");
    }

    if (dwErr != ERROR_SUCCESS)
        printf ("Failed with %d\n", dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\datastor\datastormgr.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    datastormgr.h
 *
 *  Abstract:
 *    CDataStoreMgr class definition
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/28/2000
 *        created
 *
 *****************************************************************************/

#ifndef _DATASTORMGR_H_
#define _DATASTORMGR_H_

#include "datastor.h"

class CDataStoreMgr;
class CDriveTable;
class CRestorePoint;

//
// DriveTable structure with pointers to CDataStore objects
//
// pointer to CDataStore method for looping through all drives
//
typedef DWORD (CDataStore::* PDATASTOREMETHOD) (LONG_PTR lParam);

//+-------------------------------------------------------------------------
//
//  Class:      CDriveTable
//
//  Synopsis:   maintains table of drives and CDataStore objects
//
//  History:    13-Apr-2000     HenryLee    Created
//
//--------------------------------------------------------------------------

struct SDriveTableEnumContext
{
    const CDriveTable * _pdt;
    int           _iIndex;

    void Reset ()
    {
        _pdt = NULL;
        _iIndex = 0;
    }
};

#define RP_NORMAL   0
#define RP_ADVANCED 1

class CDriveTable : public CSRAlloc
{
public:
    friend CDataStoreMgr;

    CDriveTable();
    ~CDriveTable();

    CDataStore * FindDriveInTable (WCHAR *pwszDrive) const;
    CDataStore * FindGuidInTable (WCHAR *pwszGuid) const;
    CDataStore * FindSystemDrive () const;

    DWORD AddDriveToTable(WCHAR *pwszDrive, WCHAR *pwszGuid);
    DWORD RemoveDrivesFromTable ();

    DWORD FindMountPoint (WCHAR *pwszGuid, WCHAR *pwszPath) const;
    DWORD SaveDriveTable (CRestorePoint *prp);
    DWORD SaveDriveTable (WCHAR *pwszPath);
    DWORD LoadDriveTable (WCHAR *pwszPath);
    DWORD IsAdvancedRp (CRestorePoint *prp, PDWORD pdwFlags);
	BOOL  AnyMountedDrives();    

    DWORD ForAllDrives (PDATASTOREMETHOD pMethod, LONG_PTR lParam);
    DWORD ForOneOrAllDrives (WCHAR *pwszDrive, 
                             PDATASTOREMETHOD pMethod, 
                             LONG_PTR lParam);

    CDataStore * FindFirstDrive (SDriveTableEnumContext & dtec) const;
    CDataStore * FindNextDrive (SDriveTableEnumContext & dtec) const;

    DWORD Merge (CDriveTable &dt);  // merge one table into another
    DWORD EnumAllVolumes ();        // fill in the drive table

    inline void  SetDirty ()
    {
        _fDirty = TRUE;
    }

    BOOL GetDirty()
    {
        return _fDirty;
    }

private:
    DWORD CreateNewEntry (CDataStore *pds);

    static const enum { DRIVE_TABLE_SIZE = 26 };

    CDataStore  * _rgDriveTable[DRIVE_TABLE_SIZE];
    CDriveTable * _pdtNext;
    int           _nLastDrive;
    BOOL          _fDirty;
    BOOL          _fLockInit;
    CLock         _lock;
};

//+-------------------------------------------------------------------------
//
//  Class:      CDataStoreMgr
//
//  Synopsis:   there will be one global instance of this class
//              this is the starting point for all of the datastore tasks
//              all the datastore objects will be accessible from here
//
//  History:    13-Apr-2000     BrijeshK    Created
//
//--------------------------------------------------------------------------

class CDataStoreMgr : public CSRAlloc
{
public: 
    CDataStoreMgr();
    ~CDataStoreMgr();

    CDriveTable * GetDriveTable ()
    {
        return &_dt;
    }

    // pass NULL for action on all datastores

    DWORD       Initialize (BOOL fFirstRun);
    DWORD       Fifo(WCHAR *pwszDrive, 
                     DWORD dwTargetRPNum, 
                     int nTargetPercent, 
                     BOOL fIncludeCurrentRp,
                     BOOL fFifoAtLeastOneRp);  
                     
    DWORD       FifoOldRps(INT64 llTimeInSeconds);    
    DWORD       FreezeDrive(WCHAR *pwszDrive);
    DWORD       ThawDrives(BOOL fCheckOnly);    
    DWORD       MonitorDrive(WCHAR *pwszDrive, BOOL fSet);

    DWORD       TriggerFreezeOrFifo();
    DWORD       FindFrozenDrive();
    BOOL        IsDriveFrozen(LPWSTR pszDrive);
    
    void        SignalStop ()
    {
        _fStop = TRUE;
        _dt.SaveDriveTable ((CRestorePoint*) NULL);
    }

    DWORD       UpdateDataStoreUsage(WCHAR *pwszDrive, INT64 llDelta); 

    DWORD       CreateDataStore (WCHAR *pwszDrive)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive,
                                      &CDataStore::CreateDataStore,
                                      NULL);
    }

    DWORD       DestroyDataStore (WCHAR *pwszDrive)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive,
                                      &CDataStore::DestroyDataStore,
                                      TRUE);
    }

    DWORD       SetDriveParticipation (WCHAR *pwszDrive, BOOL fParticipate)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive, 
                                      &CDataStore::SetParticipate, 
                                      fParticipate);
    }

    DWORD       UpdateDriveParticipation (WCHAR *pwszDrive, LPWSTR pwszDir)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive, 
                                      &CDataStore::UpdateParticipate, 
                                      (LONG_PTR) pwszDir);
    }    

    DWORD       UpdateDiskFree (WCHAR *pwszDrive)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive, 
                                       &CDataStore::UpdateDiskFree, 
                                       NULL);
    }

    DWORD       SetDriveError (WCHAR *pwszDrive)
    {
        return  _dt.ForOneOrAllDrives (pwszDrive, 
                                      &CDataStore::SetError, 
                                      NULL);
    }

	DWORD 		Compress (LPWSTR pszDrive, LONG lDuration);
    
    // Used to get the participation, monitor, freeze, and other flags
    DWORD       GetFlags (WCHAR *pwszDrive, DWORD *pdwFlags);
    DWORD       GetUsagePercent(WCHAR *pwszDrive, int * pnPercent);

    DWORD       CountChangeLogs (CRestorePoint *prp)
    {
        return  _dt.ForAllDrives (&CDataStore::CountChangeLogs, (LONG_PTR) prp);
    }

    DWORD       SwitchRestorePoint (CRestorePoint *prp);

    BOOL * GetStopFlag ()   // used for Delnode_Recurse
    {
        return &_fStop;
    }

    DWORD       DeleteMachineGuidFile ();

private:
    CDriveTable _dt;
    BOOL        _fStop;

    DWORD       WriteFifoLog(LPWSTR pwszDrive, LPWSTR pwszRPDir);
    DWORD       WriteMachineGuid ();
};

extern CDataStoreMgr * g_pDataStoreMgr;  // the global instance

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#include "srdefs.h"
#include <dbgtrace.h>
//#include "rwlock.h"

#include "logfmt.h"
#include "srrpcapi.h"

#include "enumlogs.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\findfile.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    findfile.h
 *
 *  Abstract:
 *    Defintion of CFindFile.
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _FINDFILE_H_
#define _FINDFILE_H_


class CFindFile {

public:
    ULONG    m_ulCurID, m_ulMinID, m_ulMaxID;
    BOOL     m_fForward;

    CFindFile();
    BOOL _FindFirstFile(LPCWSTR pszPrefix, LPCWSTR pszSuffix, PWIN32_FIND_DATA pData, BOOL fForward, BOOL fSkipLast = FALSE);
    BOOL _FindNextFile(LPCWSTR pszPrefix, LPCWSTR pszSuffix, PWIN32_FIND_DATA pData);  
    ULONG GetNextFileID(LPCWSTR pszPrefix, LPCWSTR pszSuffix);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\findfile.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    findfile.cpp
 *
 *  Abstract:
 *    CFindFile functions.
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


// constructor

CFindFile::CFindFile()
{
    m_ulCurID = 0;
    m_ulMaxID = 0;
    m_ulMinID = 0;
    m_fForward = FALSE;
}

// returns oldest/youngest file
// <prefix>n<suffix> is older than <prefix>n+1<suffix>

BOOL
CFindFile::_FindFirstFile(
    LPCWSTR           pszPrefix,
    LPCWSTR           pszSuffix,
    PWIN32_FIND_DATA  pData,      
    BOOL              fForward,
    BOOL              fSkipLast
)
{
    BOOL    fRc = FALSE;
    HANDLE  hdl = INVALID_HANDLE_VALUE;
    ULONG   ulCurID = 0;
    WCHAR   szSrch[MAX_PATH];

    TENTER("CFindFile::_FindFirstFile");

    m_fForward = fForward;

    m_ulCurID = 1;
    m_ulMaxID = 0;
    m_ulMinID = 0xFFFFFFF7;
    
    if(NULL == pData || NULL == pszPrefix || NULL == pszSuffix)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }


    // enumerate all files with wildcard search
    // record the first and last files in numerical order
    // then return in order requested

    wsprintf(szSrch, L"%s*%s", pszPrefix, pszSuffix);

    hdl = FindFirstFile(szSrch, pData);
    if(INVALID_HANDLE_VALUE == hdl)
    {
        goto done;
    }

    do
    {        
        ulCurID = GetID(pData->cFileName);
        if (0 == ulCurID)    // always skip 0
            continue;

        if (ulCurID < m_ulMinID)        
            m_ulMinID = ulCurID;

        if (ulCurID > m_ulMaxID)
            m_ulMaxID = ulCurID;

    } while (FindNextFile(hdl, pData));

    FindClose(hdl);    
    hdl = INVALID_HANDLE_VALUE;

    if (m_ulMaxID == 0)  // no file really
        goto done;
           
    if (fSkipLast)      // skip the last file if needed
        m_ulMaxID--;

    if (m_ulMaxID == 0)  // no file again
        goto done;

    // start at beginning or end
    
    m_ulCurID = m_fForward ? m_ulMinID : m_ulMaxID;   
    wsprintf(szSrch, L"%s%d%s", pszPrefix, m_ulCurID, pszSuffix);

    // get the first existing file
    
    while (m_ulCurID >= m_ulMinID && m_ulCurID <= m_ulMaxID && 
           INVALID_HANDLE_VALUE == (hdl = FindFirstFile(szSrch, pData)))        
    {
        // try again with leading zeros
        wsprintf(szSrch, L"%s%07d%s", pszPrefix, m_ulCurID, pszSuffix);

        if (INVALID_HANDLE_VALUE == (hdl = FindFirstFile (szSrch, pData)))
        {
            m_fForward ? m_ulCurID++ : m_ulCurID--;        
            wsprintf(szSrch, L"%s%d%s", pszPrefix, m_ulCurID, pszSuffix);
        }
        else
        {
            break;
        }
    }   

    
    if (INVALID_HANDLE_VALUE != hdl)
    {
        FindClose(hdl);
        fRc = TRUE;
    }

done:
    TLEAVE();
    return fRc;
}


// returns next/prev oldest file
// <prefix>n<suffix> is older than <prefix>n+1<suffix>

BOOL
CFindFile::_FindNextFile(
    LPCWSTR           pszPrefix,           
    LPCWSTR           pszSuffix,
    PWIN32_FIND_DATA  pData  // [out] Next file info
)
{
    BOOL    fRc = FALSE;
    WCHAR   szSrch[MAX_PATH];
    HANDLE  hdl = INVALID_HANDLE_VALUE;

    TENTER("CFindFile::_FindNextFile");
    
    if(NULL == pData || NULL == pszPrefix || NULL == pszSuffix)
    {
        SetLastError(ERROR_INVALID_PARAMETER);        
        goto done;
    }

    // get the next/prev oldest existing file
    
    do 
    {
        m_fForward ? m_ulCurID++ : m_ulCurID--;        
        wsprintf(szSrch, L"%s%d%s", pszPrefix, m_ulCurID, pszSuffix);                        

        if (m_ulCurID >= m_ulMinID && m_ulCurID <= m_ulMaxID &&
            INVALID_HANDLE_VALUE == (hdl = FindFirstFile(szSrch, pData)))
        {
            // try again with leading zeros
            wsprintf(szSrch, L"%s%07d%s", pszPrefix, m_ulCurID, pszSuffix);
        }
        else if (INVALID_HANDLE_VALUE != hdl)
            break;

    }   while (m_ulCurID >= m_ulMinID && m_ulCurID <= m_ulMaxID && 
               INVALID_HANDLE_VALUE == (hdl = FindFirstFile(szSrch, pData)));


    if (INVALID_HANDLE_VALUE != hdl)  // no more files?
    {
        fRc = TRUE;
        FindClose(hdl);
    }

done:
    TLEAVE();
    return fRc;
}


// returns n+1 for the max n for which file <Prefix>n<Suffix> exists

ULONG
CFindFile::GetNextFileID(
    LPCWSTR pszPrefix,
    LPCWSTR pszSuffix)
{
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    CFindFile FindFile; 
    WIN32_FIND_DATA FindData;

    TENTER("CFindFile::GetNextFileID");
    
    // step thru all files in order of increasing id
    
    if (FindFile._FindFirstFile(pszPrefix, pszSuffix, &FindData, TRUE))
    {
        while (FindFile._FindNextFile(pszPrefix, pszSuffix, &FindData));
    }

    TLEAVE();
    return FindFile.m_ulCurID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\respoint.cpp ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    respoint.cpp
 *
 *  Abstract:
 *    CRestorePoint, CRestorePointEnum class functions
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#include "precomp.h"
#include "srapi.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile


// constructors

// use this constructor to read in an existing rp
// then need to call Read() to initialize rp members

CRestorePoint::CRestorePoint()
{
    m_pRPInfo = NULL;
    lstrcpy(m_szRPDir, L"");
    m_itCurChgLogEntry = m_ChgLogList.end();
    m_fForward = TRUE;
    m_fDefunct = FALSE;
}

// initialize

BOOL
CRestorePoint::Load(RESTOREPOINTINFOW *prpinfo)
{
    if (prpinfo)
    {
        if (! m_pRPInfo)
        {
            m_pRPInfo = (RESTOREPOINTINFOW *) SRMemAlloc(sizeof(RESTOREPOINTINFOW));
            if (! m_pRPInfo)
                return FALSE;
        }            
        CopyMemory(m_pRPInfo, prpinfo, sizeof(RESTOREPOINTINFOW));
    }
    return TRUE;
}
               

// destructor
// call FindClose here
// if no enumeration was done, this is a no-op

CRestorePoint::~CRestorePoint()
{    
    if (m_pRPInfo)
        SRMemFree(m_pRPInfo);
        
    FindClose();    
}


// return first/last change log entry in this restore point
// assumes Read() has already been called

DWORD
CRestorePoint::FindFirstChangeLogEntry(
    LPWSTR           pszDrive,
    BOOL             fForward,
    CChangeLogEntry& cle)
{
    DWORD           dwRc = ERROR_SUCCESS;
    WCHAR           szChgLogPrefix[MAX_PATH];
    WIN32_FIND_DATA FindData;
    INT64           llSeqNum;
    WCHAR           szPath[MAX_PATH];

    TENTER("CRestorePoint::FindFirstChangeLogEntry");
    
    m_fForward = fForward;
    lstrcpy(m_szDrive, pszDrive);

    // read the first/last change log in this restore point
    // all entries inside a change log will always be read in forward order   
    
    MakeRestorePath(szPath, m_szDrive, m_szRPDir);
    wsprintf(szChgLogPrefix, L"%s\\%s", szPath, s_cszChangeLogPrefix);
    
    if (! m_FindFile._FindFirstFile(szChgLogPrefix,
                                    s_cszChangeLogSuffix, 
                                    &FindData, 
                                    m_fForward,
                                    FALSE))
    {
        TRACE(0, "No changelog in %S", szPath);
        dwRc = ERROR_NO_MORE_ITEMS;
        goto done;
    }

    lstrcat(szPath, L"\\");
    lstrcat(szPath, FindData.cFileName);

    // build list of entries in increasing order of sequence number

    dwRc = BuildList(szPath);
    if (ERROR_SUCCESS != dwRc)
    {
        TRACE(0, "! BuildList : %ld", dwRc);
        goto done;
    }

    TRACE(0, "Enumerating %S in %S", FindData.cFileName, m_szRPDir);

    // if there was no entry in this change log, go to the next

    if (m_ChgLogList.empty())
    {
        dwRc = FindNextChangeLogEntry(cle);
        goto done;
    }

    // get the first/last entry

    if (m_fForward)                
    {
        m_itCurChgLogEntry = m_ChgLogList.begin();
    }
    else                            
    {
        m_itCurChgLogEntry = m_ChgLogList.end();
        m_itCurChgLogEntry--;
    }

    // read in the change log entry into the object
    
    cle.Load(*m_itCurChgLogEntry, m_szRPDir);        

done:
    TLEAVE();
    return dwRc;
}



// return next/prev change log entry in this restore point
// assumes Read() has already been called

DWORD 
CRestorePoint::FindNextChangeLogEntry(
    CChangeLogEntry& cle)
{
    DWORD           dwRc = ERROR_SUCCESS;
    WCHAR           szPath[MAX_PATH];
    WCHAR           szChangeLogPath[MAX_PATH];
    WCHAR           szChgLogPrefix[MAX_PATH];
    WIN32_FIND_DATA FindData;
    INT64           llSeqNum;

    TENTER("CRestorePoint::FindNextChangeLogEntry");
    
    // go to the next entry in the list

    m_fForward ? m_itCurChgLogEntry++ : m_itCurChgLogEntry--;


    // check if we've reached the end of this change log
    // end is the same for both forward and reverse enumeration

    if (m_itCurChgLogEntry == m_ChgLogList.end())
    {
        // if so, read the next change log into memory

        // nuke the current list
        FindClose();        

        
        MakeRestorePath(szPath, m_szDrive, m_szRPDir);
        wsprintf(szChgLogPrefix, L"%s\\%s", szPath, s_cszChangeLogPrefix);

        while (m_ChgLogList.empty())
        {
            if (FALSE == m_FindFile._FindNextFile(szChgLogPrefix, 
                                                  s_cszChangeLogSuffix, 
                                                  &FindData))
            {
                dwRc = ERROR_NO_MORE_ITEMS;
                TRACE(0, "No more change logs");
                goto done;
            }

            lstrcpy(szChangeLogPath, szPath);
            lstrcat(szChangeLogPath, L"\\");
            lstrcat(szChangeLogPath, FindData.cFileName);

            dwRc = BuildList(szChangeLogPath);
            if (ERROR_SUCCESS != dwRc)
            {
                TRACE(0, "BuildList : error=%ld", dwRc);
                goto done;
            }
            
            TRACE(0, "Enumerating %S in %S", FindData.cFileName, m_szRPDir);
        }



        // get the first/last entry

        if (m_fForward)                
        {
            m_itCurChgLogEntry = m_ChgLogList.begin();
        }
        else                            
        {
            m_itCurChgLogEntry = m_ChgLogList.end();
            m_itCurChgLogEntry--;
        }
    }

    
    // read in the change log entry fields into the object

    cle.Load(*m_itCurChgLogEntry, m_szRPDir);
    
done:
    TLEAVE();
    return dwRc;    
}


DWORD
CRestorePoint::BuildList(
        LPWSTR pszChgLog)
{
    DWORD           dwRc = ERROR_INTERNAL_ERROR;
    HANDLE          hChgLog = INVALID_HANDLE_VALUE;
    DWORD           dwRead;
    DWORD           dwEntrySize;
    PVOID           pBlob = NULL;
    SR_LOG_ENTRY*    pEntry = NULL;
    PSR_LOG_HEADER   pLogHeader = NULL;
    DWORD           cbSize;

    TENTER("CChangeLogEntry::BuildList");

    if (FALSE==IsFileOwnedByAdminOrSystem(pszChgLog))
    {
         // this is not a valid log.
         // ignore this log and go to the next one
        TRACE(0, "Change log %S not owned by admin or system", pszChgLog);
        dwRc = ERROR_SUCCESS;
        goto done;
    }

    hChgLog = CreateFile(pszChgLog,                        // file name
                         GENERIC_READ,                     // access mode
                         FILE_SHARE_READ,                  // share mode
                         NULL,                             // SD
                         OPEN_EXISTING,                    // how to create
                         FILE_ATTRIBUTE_NORMAL,            // file attributes
                         NULL);
                 
    if (INVALID_HANDLE_VALUE == hChgLog)
    {
        dwRc = GetLastError();
        TRACE(0, "! CreateFile on %S : %ld", pszChgLog, dwRc);
        goto done;
    }

    // read header size

    if (FALSE == ReadFile(hChgLog,
                          &cbSize,
                          sizeof(DWORD),
                          &dwRead,
                          NULL) || dwRead == 0 || cbSize == 0)
    {
        // if the file could not be read,
        // assume that it is a 0-sized log, and go to the next log
        
        dwRc = GetLastError();
        TRACE(0, "Zero sized log : %ld", pszChgLog, dwRc);
        dwRc = ERROR_SUCCESS;
        goto done;
    }

    pLogHeader = (SR_LOG_HEADER *) SRMemAlloc(cbSize);
    if (! pLogHeader)
    {
        TRACE(0, "Out of memory");
        goto done;
    }

    // read header

    pLogHeader->Header.RecordSize = cbSize;
    if (FALSE == ReadFile(hChgLog, 
                          (PVOID) ( ((BYTE *) pLogHeader) + sizeof(DWORD)), 
                          cbSize - sizeof(DWORD), 
                          &dwRead, 
                          NULL))
    {
        dwRc = GetLastError();
        TRACE(0, "! ReadFile on %S : %ld", pszChgLog, dwRc);
        goto done;
    }

    // check log's integrity

    if( pLogHeader->LogVersion != SR_LOG_VERSION ||
        pLogHeader->MagicNum   != SR_LOG_MAGIC_NUMBER )
    {
        TRACE(0, "! LogHeader for %S : invalid or corrupt", pszChgLog);
        goto done;
    }

    // now read the entries

    do 
    {
        // get the size of the entry
        
        if (FALSE == ReadFile(hChgLog, &dwEntrySize, sizeof(DWORD), &dwRead, NULL))
        {
            TRACE(0, "ReadFile failed, error=%ld", GetLastError());
            break;
        }

        if (0 == dwRead)                // end of file
        {
            TRACE(0, "End of file");
            dwRc = ERROR_NO_MORE_ITEMS;
            break;
        }

        if (dwRead != sizeof(DWORD))    // error reading entry
        {
            TRACE(0, "Readfile could not read a DWORD");
            break;
        }

        if (0 == dwEntrySize)           // reached the last entry
        {    
            TRACE(0, "No more entries");
            dwRc = ERROR_NO_MORE_ITEMS;
            break;
        }


        // get the entry itself

        pEntry = (SR_LOG_ENTRY *) SRMemAlloc(dwEntrySize);
        if (! pEntry)
        {
            TRACE(0, "Out of memory");
            break;
        }

        pEntry->Header.RecordSize = dwEntrySize;

        // skip the size field

        pBlob = (PVOID) ((PBYTE) pEntry + sizeof(dwEntrySize));

        if (FALSE == ReadFile(hChgLog, pBlob, dwEntrySize - sizeof(dwEntrySize), &dwRead, NULL))
        {
            TRACE(0, "! ReadFile on %S : %ld", pszChgLog, GetLastError());
            break;
        }

        if (dwRead != dwEntrySize - sizeof(dwEntrySize))    // error reading entry
        {
            TRACE(0, "! Readfile: ToRead=%ld, Read=%ld bytes", 
                  dwEntrySize - sizeof(dwEntrySize), dwRead);
            break;
        }

        // insert entry into list 
        
        dwRc = InsertEntryIntoList(pEntry);

    }   while (ERROR_SUCCESS == dwRc);

    if (ERROR_NO_MORE_ITEMS == dwRc)
    {
        dwRc = ERROR_SUCCESS;
    }

done:
    if (INVALID_HANDLE_VALUE != hChgLog)
        CloseHandle(hChgLog);

    SRMemFree(pLogHeader);

    TLEAVE();
    return dwRc;
}   


// release memory and empty the list

DWORD CRestorePoint::FindClose()
{
    // nuke the list
    
    for (m_itCurChgLogEntry = m_ChgLogList.begin();
         m_itCurChgLogEntry != m_ChgLogList.end(); 
         m_itCurChgLogEntry++)
    {
        SRMemFree(*m_itCurChgLogEntry);
    }

    m_ChgLogList.clear(); 
    
    return ERROR_SUCCESS;
}


// insert change log entry into list

DWORD
CRestorePoint::InsertEntryIntoList(
    SR_LOG_ENTRY* pEntry)
{
    TENTER("CRestorePoint::InsertEntryIntoList");
    
    m_ChgLogList.push_back(pEntry);    

    TLEAVE();
    return ERROR_SUCCESS;    
}


// populate members

DWORD
CRestorePoint::ReadLog()
{
    DWORD   dwRc = ERROR_SUCCESS;
    WCHAR   szLog[MAX_PATH];
    WCHAR   szSystemDrive[MAX_PATH];
    DWORD   dwRead;

    TENTER("CRestorePoint::ReadLog");

    // construct path of rp.log
    
    GetSystemDrive(szSystemDrive);
    MakeRestorePath(szLog, szSystemDrive, m_szRPDir);
    lstrcat(szLog, L"\\");
    lstrcat(szLog, s_cszRestorePointLogName);

    HANDLE hFile = CreateFile (szLog,           // file name
                               GENERIC_READ,    // file access
                               FILE_SHARE_READ, // share mode
                               NULL,            // SD
                               OPEN_EXISTING,   // how to create
                               0,               // file attributes
                               NULL);           // handle to template file
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwRc = GetLastError();
        trace(0, "! CreateFile on %S : %ld", szLog, dwRc);
        goto done;
    }


    // read the restore point info
    
    if (! m_pRPInfo)
    {
        m_pRPInfo = (RESTOREPOINTINFOW *) SRMemAlloc(sizeof(RESTOREPOINTINFOW));
        if (! m_pRPInfo)
        {
            dwRc = ERROR_OUTOFMEMORY;
            trace(0, "SRMemAlloc failed");
            goto done;
        }
    }
    
    if (FALSE == ReadFile(hFile, m_pRPInfo, sizeof(RESTOREPOINTINFOW), &dwRead, NULL) ||
        dwRead != sizeof(RESTOREPOINTINFOW))
    {
        dwRc = GetLastError();
        trace(0, "! ReadFile on %S : %ld", szLog, dwRc);
        goto done;
    }

    m_fDefunct = (m_pRPInfo->dwRestorePtType == CANCELLED_OPERATION);
       
    // read the creation time
    if (FALSE == ReadFile(hFile, &m_Time, sizeof(m_Time), &dwRead, NULL) ||
        dwRead != sizeof(m_Time))
    {
        dwRc = GetLastError();
        trace(0, "! ReadFile on %S : %ld", szLog, dwRc);
        goto done;
    }

    
done:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    TLEAVE();
    return dwRc;
}



DWORD
CRestorePoint::WriteLog()
{
    DWORD   dwRc = ERROR_SUCCESS;
    WCHAR   szLog[MAX_PATH];
    WCHAR   szSystemDrive[MAX_PATH];
    DWORD   dwWritten;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    
    TENTER("CRestorePoint::WriteLog");

    if (! m_pRPInfo)
    {
        ASSERT(0);
        dwRc = ERROR_INTERNAL_ERROR;
        goto done;
    }
    
    // set the creation time to the current time
    
    GetSystemTimeAsFileTime(&m_Time);

    // construct path of rp.log
    
    GetSystemDrive(szSystemDrive);
    MakeRestorePath(szLog, szSystemDrive, m_szRPDir);
    lstrcat(szLog, L"\\");
    lstrcat(szLog, s_cszRestorePointLogName);

    hFile = CreateFile (szLog,           // file name
                        GENERIC_WRITE,   // file access
                        0,               // share mode
                        NULL,            // SD
                        CREATE_ALWAYS,   // how to create
                        FILE_FLAG_WRITE_THROUGH,               // file attributes
                        NULL);           // handle to template file
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwRc = GetLastError();
        trace(0, "! CreateFile on %S : %ld", szLog, dwRc);
        goto done;
    }

    // write the restore point info
    if (FALSE == WriteFile(hFile, m_pRPInfo, sizeof(RESTOREPOINTINFOW), &dwWritten, NULL))
    {
        dwRc = GetLastError();
        trace(0, "! WriteFile on %S : %ld", szLog, dwRc);
        goto done;
    }

    // write the creation time
    if (FALSE == WriteFile(hFile, &m_Time, sizeof(m_Time), &dwWritten, NULL))
    {
        dwRc = GetLastError();
        trace(0, "! WriteFile on %S : %ld", szLog, dwRc);
        goto done;
    }


done:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    TLEAVE();
    return dwRc;
}


BOOL
CRestorePoint::DeleteLog()
{
    WCHAR   szLog[MAX_PATH];
    WCHAR   szSystemDrive[MAX_PATH];

    GetSystemDrive(szSystemDrive);
    MakeRestorePath(szLog, szSystemDrive, m_szRPDir);
    lstrcat(szLog, L"\\");
    lstrcat(szLog, s_cszRestorePointLogName);

    return DeleteFile(szLog);
}


DWORD
CRestorePoint::Cancel()
{   
    if (m_pRPInfo)
    {
        m_pRPInfo->dwRestorePtType = CANCELLED_OPERATION;
        return WriteLog();
    }        
    else
    {
        ASSERT(0);
        return ERROR_INTERNAL_ERROR;   
    }        
}


DWORD 
CRestorePoint::GetNum() 
{
    return GetID(m_szRPDir);
}

// read the size of the restore point folder from file 

DWORD CRestorePoint::ReadSize (const WCHAR *pwszDrive, INT64 *pllSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbRead = 0;
    WCHAR wcsPath[MAX_PATH];

    MakeRestorePath(wcsPath, pwszDrive, m_szRPDir);
    lstrcat(wcsPath, L"\\");
    lstrcat (wcsPath, s_cszRestorePointSize);

    HANDLE hFile = CreateFileW ( wcsPath,   // file name
                         GENERIC_READ, // file access
                         FILE_SHARE_READ, // share mode
                         NULL,          // SD
                         OPEN_EXISTING, // how to create
                         0,             // file attributes
                         NULL);         // handle to template file

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
        return dwErr;
    }

    if (FALSE == ReadFile (hFile, (BYTE *) pllSize, sizeof(*pllSize), 
                           &cbRead, NULL))
    {
        dwErr = GetLastError();
    }

    CloseHandle (hFile);
    return dwErr;
}


// write the size of the restore point folder to file

DWORD CRestorePoint::WriteSize (const WCHAR *pwszDrive, INT64 llSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cbWritten = 0;
    WCHAR wcsPath[MAX_PATH];

    MakeRestorePath(wcsPath, pwszDrive, m_szRPDir);
    lstrcat(wcsPath, L"\\");
    lstrcat (wcsPath, s_cszRestorePointSize);

    HANDLE hFile = CreateFileW ( wcsPath,   // file name
                         GENERIC_WRITE, // file access
                         0,             // share mode
                         NULL,          // SD
                         CREATE_ALWAYS, // how to create
                         0,             // file attributes
                         NULL);         // handle to template file

    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwErr = GetLastError();
        return dwErr;
    }

    if (FALSE == WriteFile (hFile, (BYTE *) &llSize, sizeof(llSize),
                            &cbWritten, NULL))
    {
        dwErr = GetLastError();
    }

    CloseHandle (hFile);
    return dwErr;
}

    
// populate a changelogentry object

void
CChangeLogEntry::Load(SR_LOG_ENTRY *pentry, LPWSTR pszRPDir)
{
    PSR_LOG_DEBUG_INFO pDebugRec = NULL;
    
    _pentry = pentry;

    _pszPath1 = _pszPath2 = _pszTemp = _pszProcess = _pszShortName = NULL;
    _pbAcl = NULL;
    _cbAcl = 0;
    _fAclInline = FALSE;
    lstrcpy(_pszRPDir, pszRPDir);
    
    BYTE *pRec = (PBYTE) & _pentry->SubRecords;

    //
    // get source path
    //

    _pszPath1 = (LPWSTR) (pRec + sizeof(RECORD_HEADER));

    //
    // get temp path if exists
    //

    if (_pentry->EntryFlags & ENTRYFLAGS_TEMPPATH)
    {
        pRec += RECORD_SIZE(pRec);
        _pszTemp = (LPWSTR) (pRec + sizeof(RECORD_HEADER));
    }

    // 
    // get second path if exists
    //
    
    if (_pentry->EntryFlags & ENTRYFLAGS_SECONDPATH)
    {
        pRec += RECORD_SIZE(pRec);
        _pszPath2 = (LPWSTR) (pRec + sizeof(RECORD_HEADER));
    }

    //
    // get acl info if exists
    //

    if (_pentry->EntryFlags & ENTRYFLAGS_ACLINFO)
    {
        pRec += RECORD_SIZE(pRec);
        if (RECORD_TYPE(pRec) == RecordTypeAclInline)
        {
            _fAclInline = TRUE;
        }

        _pbAcl = (BYTE *) (pRec + sizeof(RECORD_HEADER));
        _cbAcl = RECORD_SIZE(pRec) - sizeof(RECORD_HEADER);
    }

    //
    // get debug info if exists
    //
    
    if (_pentry->EntryFlags & ENTRYFLAGS_DEBUGINFO)
    {
        pRec += RECORD_SIZE(pRec);
        pDebugRec = (PSR_LOG_DEBUG_INFO) pRec; 
        _pszProcess = (LPWSTR) (pDebugRec->ProcessName);
    }

    //
    // get shortname if exists
    //
    
    if (_pentry->EntryFlags & ENTRYFLAGS_SHORTNAME)
    {
        pRec += RECORD_SIZE(pRec);
        _pszShortName =  (LPWSTR) (pRec + sizeof(RECORD_HEADER));
    }

    return;
}


// this function will check if any filepath length exceeds
// the max length that restore supports
// if so, it will return FALSE
BOOL
CChangeLogEntry::CheckPathLengths()
{
    if (_pszPath1 && lstrlen(_pszPath1) > SR_MAX_FILENAME_PATH-1)
        return FALSE;
    if (_pszPath2 && lstrlen(_pszPath2) > SR_MAX_FILENAME_PATH-1)
        return FALSE;
    if (_pszTemp && lstrlen(_pszTemp) > SR_MAX_FILENAME_PATH-1)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flbuilder.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    flbuilder.cpp

Abstract:

    This class uses the CXMLFileListParser, CFLHashList and CFLPathTree 
    classses to take an a protected XML file and build a data file for the FL.


Author:

    Kanwaljit Marok (kmarok)     01-May-2000

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "srdefs.h"

//#include <windows.h>
//#include <windowsx.h>
//#include <stdlib.h>
//#include <stdio.h>

#include <io.h>
#include <tchar.h>

#ifdef _ASSERT
#undef _ASSERT
#endif

#include <commonlib.h>
#include <atlbase.h>
#include <msxml.h>
#include "xmlparser.h"
#include "flbuilder.h"
#include "flpathtree.h"
#include "flhashlist.h"
#include "commonlibh.h"

#include "datastormgr.h"

#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile


#define TRACE_FILEID  0
#define FILEID        0

#define SAFEDELETE(p)  if (p) { HeapFree( m_hHeapToUse, 0, p); p = NULL;} else ;

//
// redefine a new max buf 
//

#ifdef  MAX_BUFFER

#undef  MAX_BUFFER
#define MAX_BUFFER      1024

#endif

//
// Some Registry keys used to merge registry info into the blob.
//

static TCHAR s_cszUserHivePrefix[]        = TEXT("\\REGISTRY\\USER\\");
static TCHAR s_cszUserHiveClassesSuffix[] = TEXT("_CLASSES");
static TCHAR s_cszTempUserProfileKey[]    = TEXT("FILELIST0102");
static TCHAR s_cszProfileImagePath[]      = TEXT("ProfileImagePath");
static TCHAR s_cszUserHiveDefault[]       = TEXT(".DEFAULT");
static TCHAR s_cszUserProfileEnv []       = TEXT("USERPROFILE");
static TCHAR s_cszFilesNotToBackup[]      = TEXT("SYSTEM\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup");
static TCHAR s_cszProfileList[]           = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList");
static TCHAR s_cszUserShellFolderKey[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
static TCHAR s_cszWinLogonKey[]           = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon");
static TCHAR s_cszSnapshotKey[]           = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\FilesToSnapshot");

static INT  s_nSnapShotEntries = 0;
static BOOL s_bSnapShotInit    = FALSE;

//
// Some invalid patterns found in FilesNotToBackup Key.
//

TCHAR ArrInvalidPatterns[][64] = { TEXT("*."), 
                                   TEXT("%USERPROFILE%"), 
                                   TEXT("%TEMP%") 
                                 };
#define INVALID_PATTERNS 3


//
// CFLDatBuilder Implementation
//

CFLDatBuilder::CFLDatBuilder()
{
    m_lNodeCount = m_lFileListCount = m_lNumFiles = m_lNumChars  = 0;
    m_pRoot = NULL;
    m_chDefaultType = _TEXT('i');

    if( ( m_hHeapToUse = HeapCreate( 0, 1048576 /* 1 meg */, 0 ) ) == NULL )
    {
        m_hHeapToUse = GetProcessHeap();
    }
}

CFLDatBuilder::~CFLDatBuilder()
{
    if( m_hHeapToUse != GetProcessHeap() )
    {
        HeapDestroy( m_hHeapToUse );
    }
}

//
// CFLDatBuilder::DeleteList  - free'd up a a linked list of 
//    FL_FILELIST structures and the attached strings.
//

BOOL 
CFLDatBuilder::DeleteList(
    LPFL_FILELIST pList
    )
{
    LPFL_FILELIST pListNext;

    TraceFunctEnter("CFLDatBuilder::DeleteList");

    while( pList )
    {
        if( pList->szFileName )
        {
            HeapFree( m_hHeapToUse, 0,  pList->szFileName );
        }       

        pListNext = pList->pNext;
        HeapFree( m_hHeapToUse, 0, pList );
        pList = pListNext;
    }

    TraceFunctLeave();

    return TRUE;
}


//
// CFLDatBuilder::DeleteTree - Recurses  through a FLTREE_NODE, deletes 
//     all the nods, allocated strings for path and file lists attached 
//     to the nodes.
//

BOOL 
CFLDatBuilder::DeleteTree(
    LPFLTREE_NODE pTree
    )
{
    TraceFunctEnter("CFLDatBuilder::DeleteTree");

    if( pTree ) 
    {
        if( pTree->szPath )
        {
            HeapFree( m_hHeapToUse, 0,  pTree->szPath );
        }

        if( pTree->pFileList )
        {
            DeleteList( pTree->pFileList );
        }
    
        //
        // go depth first 
        //

        if( pTree->pChild )
        {
            DeleteTree( pTree->pChild );
        }

        if( pTree->pSibling )
        {
            DeleteTree( pTree->pSibling );
        }
    
        HeapFree( m_hHeapToUse, 0,  pTree );
    }

    TraceFunctLeave( );

    return TRUE;
}


//
// CFLDatBuilder::CreateNode -  Allocates space for a tree node and path 
//    string and copies szPath into the newly allocated path.  It also 
//    sets the internal node parent pointer.
//    ->Increments the global ( m_lNodeCount ) node count.
//    ->Increments the global characters allocated ( m_lNumChars ) count
//    (These counts are used to reserve space in the FLDAT file)
//

LPFLTREE_NODE 
CFLDatBuilder::CreateNode(
    LPTSTR szPath, 
    TCHAR  chType, 
    LPFLTREE_NODE pParent, 
    BOOL fDisable)
{
    LPFLTREE_NODE pNode=NULL;
    LONG lPathLen;

    TraceFunctEnter("CFLDatBuilder::CreateNode");

    pNode = (LPFLTREE_NODE) HeapAlloc( m_hHeapToUse, 0, sizeof(FLTREE_NODE) ); 

    if (pNode == NULL)
    {
        goto End;
    }

    memset( pNode, 0, sizeof( FLTREE_NODE ) );
   
    lPathLen = _tcslen( szPath );
    if ( (pNode->szPath = _MyStrDup( szPath ) ) == NULL)
    {
        HeapFree( m_hHeapToUse, 0, pNode);
        pNode = NULL;
        goto End;
    }

    pNode->chType = chType;

    //
    // give me a node number, used for indexing later.
    //

    pNode->lNodeNumber = m_lNodeCount++;
    m_lNumChars += lPathLen;

    //
    // set the parent
    //

    if( pParent )
    {
        pNode->pParent = pParent;
    }

    //
    // is this a protected directory
    //

    pNode->fDisableDirectory = fDisable;

End:
    TraceFunctLeave();
    return( pNode );
}


//
// CFLDatBuilder::CreateList - Allocates a file list entry. 
//

LPFL_FILELIST 
CFLDatBuilder::CreateList()
{
    LPFL_FILELIST pList=NULL;

    TraceFunctEnter("CFLDatBuilder::CreateList");

    pList = (LPFL_FILELIST) HeapAlloc( m_hHeapToUse, 0, sizeof( FL_FILELIST) );

    if ( pList )
    {
        memset( pList, 0, sizeof(LPFL_FILELIST) );
    }
  
    TraceFunctLeave();
    return( pList );
}


//
// CFLDatBuidler::AddfileToList
//    This method calls CreateList() and allocates a filelist node. 
//    It then allocates memoery for the file name and copies it over.  
//    It then links it into the pList file list.
//    
//    -> If *pList is null, it increments the number of file lists in system.
//       This is important as most nodes don't have file lists and we shouldn't
//       reserve space for them.
//    -> Like CreateNode(), this functions also adds to the number of   
//       global allocated characters ( m_lNumChars )
//    -> Increments the total number of files ( m_lFiles ), this number
//       is used by the HASHLIST in order to see how m any physical entries 
//       to allocate.
//    -> This functions also nodes to the nods own NumofCharacere and NumFiles
//       counters.  This is used to create it's own individual hash list.
//

BOOL 
CFLDatBuilder::AddFileToList(
    LPFLTREE_NODE pNode, 
    LPFL_FILELIST *pList, 
    LPTSTR szFile, 
    TCHAR chType)
{
    LPFL_FILELIST pNewList=NULL;
    LPTSTR        pNewString=NULL;
    LONG          lFileNameLength;

    TraceFunctEnter("CFLDatBuilder::AddFileToList");

    _ASSERT(pList);
    _ASSERT(szFile);

    if( (pNewList = CreateList() ) == NULL) 
    {
        ErrorTrace(FILEID, "Error allocating memory", 0);
        goto cleanup;
    }

    lFileNameLength = _tcslen( szFile );

    if( (pNewString = _MyStrDup( szFile ) ) == NULL )
    {   
        ErrorTrace(FILEID,"Error allocating memory",0);
        goto cleanup;
    }
    
    pNewList->szFileName = pNewString;
    pNewList->chType = chType;
    
    //
    // this is a whole new list
    //

    if( *pList == NULL ) 
    {
        m_lFileListCount++;
    }
    
    m_lNumFiles++;
    m_lNumChars += lFileNameLength;

    pNode->lNumFilesHashed++;
    pNode->lFileDataSize += lFileNameLength;

    pNewList->pNext = *pList;
    *pList = pNewList;

    TraceFunctLeave();
    return TRUE;

cleanup:

    SAFEDELETE( pNewString );
    SAFEDELETE( pNewList );
    TraceFunctLeave();
    return FALSE;
}



//
// CFLDatBuilder::AddTreeNode
//    This method is the core of the FL tree building process.  
//    It takes a full path of a filename (or directory) and recurses down 
//    the tree. If one of the intermediary nodes required by end node 
//    (i.e a directory on the way to our final directory), it adds 
//    it to the tree with the default type.  if another directory is added
//    which explicitly references that directory, its type is changed to 
//    the explicit type.
//
//    Files are a special case since they are linked lists off direcory nodes.
//

BOOL 
CFLDatBuilder::AddTreeNode(
    LPFLTREE_NODE *pParent, 
    LPTSTR szFullPath, 
    TCHAR chType, 
    LONG lNumElements, 
    LONG lLevel, 
    BOOL fFile, 
    BOOL fDisable)
{
    TCHAR           szBuf[MAX_PATH];
    LPFLTREE_NODE  pNodePointer, pTempNode, pNewNode;

    BOOL            fResult=FALSE;

    TraceFunctEnter("CFLDatBuilder::AddTreeNode");

    //
    // we've hit the end of the recursion.
    //

    if( lLevel == lNumElements )
    {
        return(TRUE);
    }

    //
    // make sure everything is null
    //

    pNodePointer = pTempNode = pNewNode = NULL;
    
    // 
    // Get this element of the path structure
    // 

    if( GetField( szFullPath, szBuf, lLevel, _TEXT('\\') ) == 0) 
    {
        ErrorTrace(FILEID, "Error extracting path element.", 0 );
        goto cleanup;
    }

    //
    // We are adding a file!
    //

    if( (lLevel == (lNumElements - 1) ) && fFile )
    {
        if( AddFileToList( *pParent, 
                           &(*pParent)->pFileList, 
                           szBuf, 
                           chType ) == FALSE )
        {
            ErrorTrace(FILEID, "Error adding a file to the filelist.", 0 );
            goto cleanup;
        }

        TraceFunctLeave();
        return(TRUE);
    }

    
    if( *pParent )
    {
        //
        // lets see if i exist as sibling any where along the line.
        //

        if( lLevel == 0 )
        {
            //
            // at level 0, we don't really have a parent->child relationship
            // manually set the pointer
            //

            pNodePointer = *pParent;
        }
        else
        {   
            //
            // start searching for siblings
            //

            pNodePointer = (*pParent)->pChild;
        }
        for( ; pNodePointer != NULL; pNodePointer = pNodePointer->pSibling)
        {
            //
            // okay, we've already hashed this entry !
            //

            if( _tcsicmp( pNodePointer->szPath, szBuf ) == 0 ) 
            {
                if( lLevel == (lNumElements-1) )
                {
                    //
                    // In this case, we at the leaf node on this addition 
                    // but it has been addded before implicitly
                    // as a default node. we need to change this type to 
                    // our explicity type;
                    //

                    pNodePointer->chType = chType;
                    
                    //
                    // brijeshk: we would have already created this 
                    // node ONLY if this node is a DIRECTORY
                    // need to change the default protected attribute 
                    // to specified value as well
                    //

                    pNodePointer->fDisableDirectory = fDisable;
                    fResult = TRUE;
                } 
                else 
                {
                    fResult = AddTreeNode( 
                                  &pNodePointer, 
                                  szFullPath, 
                                  chType, 
                                  lNumElements, 
                                  lLevel + 1, 
                                  fFile, 
                                  fDisable );
                }

                TraceFunctLeave();
                return( fResult );

            }

            pTempNode = pNodePointer;
        }
    }


    if( (pNewNode = CreateNode(szBuf, 
                        chType, 
                        *pParent, 
                        fDisable) ) == NULL) 
    {
        ErrorTrace(FILEID, "Error allocating memory", 0);
        goto cleanup;
    }

    //
    // We are a node implicitly created on the chain, set it to 
    // the unknown type instead of the end node type.
    //

    if( lLevel != (lNumElements-1) )
    {
        pNewNode->chType = NODE_TYPE_UNKNOWN;

        //
        // brijeshk: if we are an implicitly created node, then we need 
        // to set the disable attribute to default (FALSE)
        // otherwise, protecting the directory c:\A\B would also 
        // protect c:\ and A. 
        //

        pNewNode->fDisableDirectory = FALSE;
    }

    //
    // Are we the first root
    //

    if( *pParent == NULL )
    {
        *pParent = pNewNode;
    }
    else if( (*pParent)->pChild == NULL )
    {
        //
        // We are the child off the root
        //

        (*pParent)->pChild = pNewNode;
    }
    else if( pTempNode )
    {
        //
        // We are a sibling at this level, pTempNode is the last sibling 
        // in the list
        // just tack pNewNode onto the end/
        //

        pTempNode->pSibling = pNewNode;
        pNewNode->pSibling = NULL;
    } 
    else
    {
        ErrorTrace(
            FILEID,
            "Uxpected error condition in AddTreeNode: no link determined",0);
        goto cleanup;
    }

    //
    // Parse the new level.
    //

    fResult = AddTreeNode( 
                  &(pNewNode), 
                  szFullPath, 
                  chType, 
                  lNumElements, 
                  lLevel + 1, 
                  fFile,  
                  fDisable );

cleanup:
    TraceFunctLeave();
    return( fResult );

}

BOOL
CFLDatBuilder::AddRegistrySnapshotEntry( 
   LPTSTR pszPath)
{
    HKEY hKey;
    BOOL fRet = FALSE;

    if ( s_bSnapShotInit == FALSE )
    {
        //
        // Delete the snapshot key
        //
    
        RegDeleteKey( HKEY_LOCAL_MACHINE, s_cszSnapshotKey );

        s_nSnapShotEntries = 0;
    
        //
        // Add the snapshot key
        //
    
        if (RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
                            s_cszSnapshotKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKey,
                            NULL) == ERROR_SUCCESS)
        {
            s_bSnapShotInit = TRUE;

            RegCloseKey( hKey );
        }
    }

    //
    // Set the value in the key
    //

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       s_cszSnapshotKey,
                       0,
                       KEY_READ|KEY_WRITE,
                       &hKey ) == ERROR_SUCCESS )
    {
         TCHAR szSnapshotName[ MAX_PATH ];

         s_nSnapShotEntries++;

         _stprintf(szSnapshotName, TEXT("snap#%d"), s_nSnapShotEntries);

         RegSetValueEx( hKey, 
                        szSnapshotName,
                        0,
                        REG_SZ,
                        (const BYTE * )pszPath,
                        (_tcslen(pszPath) + 1)*sizeof(TCHAR) );
                        

         RegCloseKey( hKey );

         fRet = TRUE;
    }

    return fRet;
}

//
// CFLDatBuilder::AddMetaDriveFileDir - 
//

BOOL CFLDatBuilder::AddMetaDriveFileDir( 
    LPTSTR szInPath, 
    TCHAR chType,  
    BOOL fFile, 
    BOOL fDisable )
{
    BOOL    fRet = FALSE;
    TCHAR   szFile[MAX_BUFFER];
    TCHAR   szOutFile[MAX_BUFFER];
    LONG    lNumTokens=0;

    TraceFunctEnter("AddMetaDriveFileDir");
           
    if (szInPath && 
        szInPath[0]==TEXT('*'))
    {
        //
        // if type is 's' make it exclude and add to the registry
        // setting fro snapshotted files
        //

        if ( chType == TEXT('s') )
        {
            AddRegistrySnapshotEntry( szInPath );
            chType = TEXT('e');
        }
                
        _tcscpy( szFile, szInPath );

#ifdef USE_NTDEVICENAMES
        if(szFile[1] == TEXT(':') )
        {
            _stprintf(szOutFile, 
                      _TEXT("NTROOT\\%s\\%s"),
                      ALLVOLUMES_PATH_T, 
                      szFile+3);

            CharUpper( szOutFile );
        }
        else
#endif
        {
            _stprintf(szOutFile, 
                      _TEXT("NTROOT\\%s\\%s"),
                      ALLVOLUMES_PATH_T, 
                      szFile );
        }

        lNumTokens = CountTokens( szOutFile, _TEXT('\\') );

        if( AddTreeNode( 
                &m_pRoot, 
                szOutFile, 
                chType, 
                lNumTokens, 
                0, 
                fFile, 
                fDisable ) == FALSE ) 
        {
            ErrorTrace(FILEID, 
                       "Error adding tree node in metadrive fileadd.",0);

            goto cleanup;
        }

        fRet = TRUE;
    }

cleanup:
    TraceFunctLeave();
    return fRet;
}


//
// CFLDatBuilder::VerifyVxdDat
//

BOOL 
CFLDatBuilder::VerifyVxdDat(
    LPCTSTR pszFile)
{
    DWORD   dwSize = 0;
    HANDLE  hFile=NULL;

    TraceFunctEnter("VerifyVxdDat");

    if( (hFile = CreateFile( pszFile,
                             GENERIC_READ,
                             0, // exclusive file accces
                             NULL, //security attributes
                             OPEN_EXISTING, // don't make it if it don't exist
                             FILE_FLAG_RANDOM_ACCESS,
                             NULL ) ) == NULL )
    {
        ErrorTrace(FILEID, "Error opening %s to verify FLDAT", pszFile );
        goto cleanup;
    }
                    
                             
    dwSize = GetFileSize( hFile, NULL);

    if( (dwSize == 0xFFFFFFFF) || (dwSize == 0) )
    {
        ErrorTrace(FILEID, "%s: 0 size file, unable to verify.", pszFile );
        goto cleanup;
    }

    CloseHandle( hFile );    
 
    TraceFunctLeave();
    return TRUE;

cleanup:
    if( hFile )
    {
        CloseHandle( hFile );    
    }

    TraceFunctLeave();
    return FALSE;
}

//
// Merge FileNotToBackup information into the Dat File
//

BOOL 
CFLDatBuilder::MergeSfcDllCacheInfo( )
{
    BOOL fRet;

    //
    // Try to get the value from the key first
    //

    fRet = AddNodeForKeyValue( HKEY_LOCAL_MACHINE, 
                               s_cszWinLogonKey, 
                               TEXT("SfcDllCache") );

    if ( fRet == FALSE )
    {

        TCHAR SfcPath[MAX_PATH + 1];
        TCHAR SfcFullPath[MAX_PATH + 1];
        LONG  lNumTokens  = 0;

        _stprintf( SfcPath, TEXT("%%WINDIR%%\\system32\\dllcache")); 

        ExpandEnvironmentStrings( SfcPath,
                                  SfcFullPath,
                                  MAX_PATH );

        SfcFullPath[MAX_PATH] = 0;
    
        ConvertToInternalFormat( SfcFullPath, SfcPath );

        SfcPath[MAX_PATH] = 0;

        lNumTokens = CountTokens( SfcPath, _TEXT('\\') );
    
        fRet = AddTreeNode(&m_pRoot, 
                           SfcPath, 
                           TEXT('e'), 
                           lNumTokens, 
                           0, 
                           FALSE, 
                           FALSE );
    }

    return fRet;
}

//
// Merge FileNotToBackup information into the Dat File
//

BOOL 
CFLDatBuilder::MergeFilesNotToBackupInfo( )
{
    TCHAR ValueName[ MAX_PATH+1 ];
    TCHAR ValueData[ MAX_PATH+1 ];

    DWORD ValueType   = 0;
    DWORD cbValueName = 0;
    DWORD cbValueData = 0;
    DWORD cbValueType = 0;

    LONG  lNumTokens  = 0;

    BOOL  bExtension = FALSE, bRecursive = FALSE, bInvalidPattern = FALSE;

    HKEY hKey;

    PTCHAR ptr = NULL;
   
    TraceFunctEnter("CFLDatBuilder::MergeFilesNotToBackupInfo");

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       s_cszFilesNotToBackup,
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {

        DWORD dwIndex = 0;

        while ( TRUE )
        {
            bExtension      = FALSE;
            bRecursive      = FALSE;
            bInvalidPattern = FALSE;

            *ValueName      = 0;
            cbValueName     = sizeof(ValueName)/sizeof(TCHAR);

            *ValueData      = 0;
            cbValueData     = sizeof(ValueData);

            if ( RegEnumValue( hKey,
                               dwIndex,
                               ValueName,
                               &cbValueName,
                               0,
                               &ValueType,
                               (PBYTE)ValueData,
                               &cbValueData ) != ERROR_SUCCESS )
            {
                break;
            }

//            trace(0, "Opened Registry Key %S\n", ValueData);

            //
            // We are interested in only string types
            //
  
            if ( ValueType != REG_EXPAND_SZ &&
                 ValueType != REG_SZ        &&
                 ValueType != REG_MULTI_SZ )
            {
                dwIndex++;
                continue;
            }

            CharUpper( ValueData );

            //
            // Look for any invalid patterns in the value data
            //

            for (int i=0; i<INVALID_PATTERNS; i++)
            {
                if (_tcsstr( ValueData, ArrInvalidPatterns[i]) != NULL)
                {
                    bInvalidPattern = TRUE;
                }
            }

            if (bInvalidPattern)
            {
                dwIndex++;
                continue;
            }

            //
            // Check for recursive flag /s
            //

            if ( (ptr = _tcsstr( ValueData, TEXT("/S"))) != NULL )
            {
                *ptr = 0;
                bRecursive = TRUE;
            }

            //
            // trim any trailing spaces, tabs or "\\"
            //

            ptr = ValueData + _tcslen(ValueData) - 1;
            
            while ( ptr > ValueData )
            {
                if ( *ptr == TEXT(' ')  || 
                     *ptr == TEXT('\t') ||
                     *ptr == TEXT('\\') ||
                     *ptr == TEXT('*') )
                {
                    *ptr = 0;
                }
                else
                {
                    break;
                }

                ptr--;
            }

            //
            // Check if the path has extensions also
            //
#if 0
            if ( _tcsrchr( ValueData, TEXT('.') ) != NULL )
            {
                bExtension = TRUE;
            }
#else
            ptr = ValueData + _tcslen(ValueData) - 1;
            
            while ( ptr > ValueData )
            {
                if ( *ptr == TEXT('\\') )
                {
                    break;
                }
                else if ( *ptr == TEXT('.') )
                {
                    bExtension = TRUE;
                    break;
                }
            
                ptr--;
            }
#endif

            if ( ( bExtension && bRecursive  ) ||
                 ( !bExtension && !bRecursive) )
            {
                dwIndex++;
                continue;
            }

            //
            // Check if the path starts with a "\\"
            //

            if ( ValueData[0] == TEXT('\\') )
            {
                _stprintf( ValueName, TEXT("*:%s"), ValueData ); 

                ExpandEnvironmentStrings( ValueName,
                                          ValueData,
                                          MAX_PATH );
    
                if (_tcsstr( ValueData, TEXT("~")) != NULL )
                {
                    LPTSTR pFilePart = NULL;

                    //
                    // Convert into full path
                    //

                    if (ExpandShortNames(ValueData, 
                                         sizeof(ValueData), 
                                         ValueName,
                                         sizeof(ValueName)))
                    {
                        _tcscpy( ValueData, ValueName );
                    }
                }
              
//                trace(0, "Adding - %S\n\n", ValueData );

                AddMetaDriveFileDir( 
                       ValueData, 
                       TEXT('e'),
                       bExtension, 
                       FALSE);
            }
            else
            {
                TCHAR szDeviceName[ MAX_PATH ];

                *szDeviceName=0;

                _tcscpy( ValueName, ValueData );
    
                ExpandEnvironmentStrings( ValueName,
                                          ValueData,
                                          MAX_PATH );
    
                if (_tcsstr( ValueData, TEXT("~")) != NULL )
                {
                    LPTSTR pFilePart = NULL;

                    //
                    // Convert into full path
                    //

                    if (ExpandShortNames(ValueData, 
                                         sizeof(ValueData), 
                                         ValueName,
                                         sizeof(ValueName)))
                    {
                        _tcscpy( ValueData, ValueName );
                    }
                }
              
                ConvertToInternalFormat( ValueData, ValueName );

                lNumTokens = CountTokens( ValueName, _TEXT('\\') );
    
//                trace(0, "Adding - %S\n\n", ValueName );
    
                AddTreeNode( 
                    &m_pRoot, 
                    ValueName, 
                    TEXT('e'), 
                    lNumTokens, 
                    0, 
                    bExtension, 
                    FALSE );
            }

            dwIndex++;
        }
                    
        RegCloseKey( hKey );
    }

    TraceFunctLeave();
    return TRUE;
}

BOOL
CFLDatBuilder::AddNodeForKeyValue(
    HKEY    hKeyUser,
    LPCTSTR pszSubKey,
    LPCTSTR pszValue
    )
{
    BOOL fRet = FALSE;

    HKEY hKeyEnv;

    TCHAR szDeviceName[ MAX_PATH ];
    TCHAR szBuf       [ MAX_PATH ];
    TCHAR szBuf2      [ MAX_PATH ];
    DWORD cbBuf;
    DWORD cbBuf2;
    LONG  lNumTokens=0;
    DWORD Type, dwErr;

    TraceFunctEnter("CFLDatBuilder::AddNodeForKeyValue");

    dwErr = RegOpenKeyEx( hKeyUser,
                          pszSubKey,
                          0,
                          KEY_READ,
                          &hKeyEnv );

    if ( dwErr == ERROR_SUCCESS )
    {

        //
        // Read and add the value for TEMP from the user profile
        //
    
        cbBuf = sizeof( szBuf );
    
        dwErr = RegQueryValueEx( hKeyEnv,
                                 pszValue,
                                 NULL,
                                 &Type,
                                 (PBYTE)szBuf,
                                 &cbBuf );

        RegCloseKey( hKeyEnv );
    
        if ( dwErr != ERROR_SUCCESS )
        {
             trace( 0, "Cannot open :%S", pszValue );
             goto Exit;
        }
    
        ExpandEnvironmentStrings ( szBuf,
                                   szBuf2,
                                   sizeof( szBuf2 ) / sizeof( TCHAR ) );
        
        ConvertToInternalFormat ( szBuf2, szBuf );
    
        lNumTokens = CountTokens( szBuf, _TEXT('\\') );
    
//        trace(0, "Adding - %S\n\n", szBuf );
    
        fRet = AddTreeNode( &m_pRoot, 
                            szBuf, 
                            TEXT('e'), 
                            lNumTokens, 
                            0, 
                            FALSE, 
                            FALSE );
    
    }

Exit:

    TraceFunctLeave();
    return fRet;
}


BOOL
CFLDatBuilder::AddUserProfileInfo( 
    HKEY    hKeyUser,
    LPCTSTR pszUserProfile
    )
{
    HKEY  hKeyEnv;
    DWORD dwErr;

    TCHAR OldUserProfileEnv[ MAX_PATH ];

    LPTSTR pszOldUserProfileEnv = NULL;

    TraceFunctEnter("CFLDatBuilder::AddUserProfileInfo");

    //
    // Save the current value of %UserProfile% in the env
    //

    *OldUserProfileEnv = 0;
    if ( GetEnvironmentVariable( s_cszUserProfileEnv,
                                 OldUserProfileEnv,
                                 sizeof( OldUserProfileEnv )/sizeof(TCHAR))>0 )
    {
        pszOldUserProfileEnv = OldUserProfileEnv;
    }


    SetEnvironmentVariable( s_cszUserProfileEnv,
                            pszUserProfile );
 
    AddNodeForKeyValue( hKeyUser, 
                        TEXT("Environment"), 
                        TEXT("TEMP") );

    AddNodeForKeyValue( hKeyUser, 
                        TEXT("Environment"), 
                        TEXT("TMP") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("Favorites") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("Cache") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("Cookies") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("Personal") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("nethood") );

    AddNodeForKeyValue( hKeyUser, 
                        s_cszUserShellFolderKey,
                        TEXT("history") );

    //
    // Put back the user Profile Env variable
    //

    SetEnvironmentVariable ( s_cszUserProfileEnv,
                             pszOldUserProfileEnv );


    TraceFunctLeave();

    return TRUE;
}

//
// This funtion merges the drive table info into the Xml Blob
//

BOOL 
CFLDatBuilder::MergeDriveTableInfo(  )
{
    BOOL fRet = FALSE;

    TCHAR szSystemDrive[MAX_PATH];
    TCHAR *szBuf2 = NULL;
    LONG  lNumTokens = 0;

    TraceFunctEnter("CFLDatBuilder::MergeDriveTableInfo");

    szBuf2 = new TCHAR[MAX_BUFFER+7]; 
    if (! szBuf2)
    {
        ErrorTrace(0, "Cannot allocate memory for szBuf2");
        goto cleanup;
    }
        
    //
    // Enumerate the drive table information and merge it into
    // the filelist
    //

    if (GetSystemDrive(szSystemDrive)) 
    {
         TCHAR szPath[MAX_PATH];
         CDriveTable dt;

         SDriveTableEnumContext  dtec = {NULL, 0};
         
         MakeRestorePath(szPath, szSystemDrive, s_cszDriveTable);

         //
         // remove terminating slash
         //

         if (szPath[_tcslen( szPath ) - 1] == _TEXT('\\'))
             szPath[_tcslen( szPath ) - 1] = 0;
                      
         if (dt.LoadDriveTable(szPath) == ERROR_SUCCESS)
         {
             CDataStore *pds;
             pds = dt.FindFirstDrive (dtec);

             while (pds)
             {
                  BOOLEAN bDisable = FALSE;
                  
	              DWORD dwFlags = pds->GetFlags();

                  if ( !(dwFlags & SR_DRIVE_MONITORED) )
 	              {
		              bDisable = TRUE;
                  }
	              
                  if (dwFlags & SR_DRIVE_FROZEN)
 	              {
		              bDisable = TRUE;
	              }


                  if ( bDisable )
                  {
                      //
                      // Enter this information into the tree
                      //
                      
                      swprintf(szBuf2,_TEXT("NTROOT%s"), pds->GetNTName());
    
                      //
                      // remove terminating slash
                      //
    
                      if (szBuf2[_tcslen( szBuf2 ) - 1] == _TEXT('\\'))
                          szBuf2[_tcslen( szBuf2 ) - 1] = 0;

                      CharUpper (szBuf2);
    
                      lNumTokens = CountTokens( szBuf2, _TEXT('\\') );
    
                      if( AddTreeNode( 
                              &m_pRoot, 
                              szBuf2, 
                              NODE_TYPE_UNKNOWN, 
                              lNumTokens, 
                              0, 
                              FALSE, 
                              bDisable ) == FALSE ) 
                      {
                           ErrorTrace(FILEID, "Error adding node.",0);
                           goto cleanup;
                      }
                  }
                
	              pds = dt.FindNextDrive (dtec);
	          }
	     }

         fRet = TRUE;
    }

cleanup:

    if (szBuf2)
        delete [] szBuf2;
    
    TraceFunctLeave();

    return fRet;
}

//
// This function merges per user information either from HKEY_USER or from 
// the user hive on the disk
//

BOOL 
CFLDatBuilder::MergeUserRegistryInfo( 
    LPCTSTR pszUserProfilePath,
    LPCTSTR pszUserProfileHive,
    LPCTSTR pszUserSid
    )
{
    BOOL  fRet = TRUE;
    HKEY  hKeyUser;
    DWORD dwErr;

    TraceFunctEnter("CFLDatBuilder::MergeUserRegistryInfo");

//    trace(0, "UserProfilePath: %S", pszUserProfilePath );
//    trace(0, "UserProfileHive: %S", pszUserProfileHive );

    //
    // Try to open the user specific key from HKEY_USER
    //

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          pszUserSid,
                          0,
                          KEY_READ,
                          &hKeyUser);

    if ( dwErr == ERROR_SUCCESS )
    {
         //
         // Succeeded : copy the setting from this key
         //

         AddUserProfileInfo( hKeyUser, pszUserProfilePath );

         RegCloseKey( hKeyUser );
    }
    else
    {
         // 
         // Failed : Now load the hive for this user
         //

         dwErr = RegLoadKey( HKEY_LOCAL_MACHINE,
                             s_cszTempUserProfileKey,
                             pszUserProfileHive );

         if ( dwErr == ERROR_SUCCESS )
         {
//             trace(0, "Loaded Hive : %S",  pszUserProfileHive );

             //
             // Open temporary key where the hive was loaded
             //

             dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                  s_cszTempUserProfileKey,
                                  0,
                                  KEY_READ,
                                  &hKeyUser);

             if ( dwErr == ERROR_SUCCESS )
             {
                  AddUserProfileInfo( hKeyUser, pszUserProfilePath );

                  RegCloseKey( hKeyUser );
             }

             //
             // Unload the hive from the temp key
             //

             RegUnLoadKey( HKEY_LOCAL_MACHINE,
                           s_cszTempUserProfileKey );
        }
    }

    fRet = TRUE;

    TraceFunctLeave();

    return fRet;
}

//
// This function enumerats all the available user profiles and calls
// MergeUserRegistryInfo for each user.
//

BOOL 
CFLDatBuilder::MergeAllUserRegistryInfo( )
{
    BOOL  fRet = FALSE;
    TCHAR UserSid[ MAX_PATH ];
    DWORD ValueType   = 0;
    DWORD cbUserSid   = 0;
    DWORD cbValueType = 0;

    HKEY hKey;

    PTCHAR ptr = NULL;

    FILETIME ft;
   
    DWORD dwErr;

    TraceFunctEnter("CFLDatBuilder::MergeAllUserRegistryInfo");

    dwErr = SetPrivilegeInAccessToken(SE_RESTORE_NAME);

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       s_cszProfileList,
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DWORD dwIndex = 0;

        //
        // Enumerate and get the Sids for each user.
        //

        while ( TRUE )
        {
            *UserSid  = 0;
            cbUserSid = sizeof(UserSid)/sizeof(TCHAR);

            if ( RegEnumKeyEx( hKey,
                               dwIndex,
                               UserSid,
                               &cbUserSid,
                               0,
                               NULL,
                               0,
                               &ft ) != ERROR_SUCCESS )
            {
                break;
            }

            CharUpper( UserSid );

            //
            // Look for intersting values
            //

            if (cbUserSid > 0)
            {
                DWORD dwErr;
                HKEY  hKeyUser, hKeyEnv, hKeyProfileList;
                TCHAR UserProfilePath[MAX_PATH];
                TCHAR UserProfileHive[MAX_PATH];
                DWORD cbUserProfilePath = 0;

//                trace(0,"UserSid = %S", UserSid);

                dwErr = RegOpenKeyEx( hKey,
                                      UserSid,
                                      0,
                                      KEY_READ,
                                      &hKeyProfileList );
                
                if ( dwErr == ERROR_SUCCESS )
                {
                     DWORD Type;

                     cbUserProfilePath = sizeof( UserProfilePath );

                     dwErr = RegQueryValueEx( hKeyProfileList,
                                              s_cszProfileImagePath,
                                              NULL,
                                              &Type,
                                              (PBYTE)UserProfilePath,
                                              &cbUserProfilePath );

                     RegCloseKey( hKeyProfileList );

                     if ( dwErr != ERROR_SUCCESS )
                     {
                         trace(0, "Query ProfileImagePath failed: %d", dwErr );
                         dwIndex++;
                         continue; 
                     }
                }
                else
                {
                     trace(0, "Opening UserSid failed: %d", dwErr );
                     dwIndex++;
                     continue; 
                }
               
                //
                // Create NTUSER.Dat path from the user profile path
                //

                ExpandEnvironmentStrings( UserProfilePath, 
                                          UserProfileHive, 
                                          sizeof(UserProfileHive) /
                                               sizeof(TCHAR) );

                _tcscpy( UserProfilePath, UserProfileHive );

                _tcscat( UserProfileHive, TEXT("\\NTUSER.DAT") );
                
                MergeUserRegistryInfo( UserProfilePath,
                                              UserProfileHive,
                                              UserSid );
        
            }

            dwIndex++;
        }

        fRet = TRUE;
                    
        RegCloseKey( hKey );
    }
    else
    {
        trace( 0, "Failed to open %S", s_cszProfileList );
    }

    TraceFunctLeave();

    return fRet;
}

// 
// CFLDatBuilder::BuildTree
//    This methods takes an XML file (the PCHealth Protected file)
//    and outsputs a FLDAT file ( pszOutFile ). 
//    It basically just opens up the xml, iterates through
//    all the files and then adds them to the tree.  It then
//    creates blobs based on the data gathered and then sends the
//    tree to the CFLPathTree blob class which transforms the tree
//    into the contigious blob format. It then writes it out.
//
//    -> The method of actually passing the FLDAT file has not be defined,
//       this function just demonstrates the process.
//   
// 

BOOL 
CFLDatBuilder::BuildTree(
    LPCTSTR pszFile, 
    LPCTSTR pszOutFile)
{
    TCHAR  *szBuf = NULL;
    TCHAR  *szBuf2 = NULL;    
    TCHAR  chType;
    LONG   lLoop,lMax,lNumTokens;
    BOOL   fRet = FALSE;
    
    s_bSnapShotInit = FALSE;

    //
    // ext list blob
    //

    CFLHashList ExtListBlob( m_hHeapToUse );
    LONG        lNumChars, lNumExt, lNumExtTotal;

    //
    // config blob
    //

    BlobHeader  ConfigBlob;

    //
    // CFLPathTree blob
    //

    CFLPathTree PathTreeBlob( m_hHeapToUse );

    //
    // outfile
    //

    HANDLE hOutFile=NULL;
    DWORD  dwWritten;

    //
    // array opf all the file types, Include, Exclude, SNAPSHOT
    //

    TCHAR achType[3] = { _TEXT('i'), _TEXT('e'), _TEXT('s') };
    LONG  lTypeLoop;

    //
    // numeric counterpart of m_chDefaultType;
    //

    DWORD dwDefaultType;

    //
    // should we protect this directory
    //

    BOOL  fDisable = FALSE;

    TraceFunctEnter("CFLDatBuilder::BuildTree");
    
    if( m_pRoot )
    {
        DeleteTree( m_pRoot );
        m_pRoot = NULL;
    }

    if(m_XMLParser.Init(pszFile) == FALSE)
    {
        ErrorTrace(FILEID,
                   "There was an error parsing the protected XML file.",0);
        goto cleanup;
    }

    szBuf = new TCHAR[MAX_BUFFER];
    szBuf2 = new TCHAR[MAX_BUFFER+7];
    if (! szBuf || ! szBuf2)
    {
        ErrorTrace(0, "Cannot allocate memory");
        goto cleanup;
    }
    
    //
    //  Calculate the tree default type info
    //

    m_chDefaultType = m_XMLParser.GetDefaultType();

    if( m_chDefaultType == _TEXT('I') )
        dwDefaultType = NODE_TYPE_INCLUDE;
    else if( m_chDefaultType == _TEXT('E') )
        dwDefaultType = NODE_TYPE_EXCLUDE;
    else
        dwDefaultType = NODE_TYPE_UNKNOWN;


    //
    // Loop through the directory/files for each file type (include, exclude )
    //

    for(lTypeLoop = 0; lTypeLoop < 3;lTypeLoop++)
    {

        //
        // Find directories for the type
        //

        lMax = m_XMLParser.GetDirectoryCount( achType[lTypeLoop] );

        for(lLoop = 0;lLoop < lMax;lLoop++)
        {
            fDisable = FALSE;
            if( m_XMLParser.GetDirectory(
                                lLoop, 
                                szBuf, 
                                MAX_BUFFER, 
                                achType[lTypeLoop], 
                                &fDisable) != MAX_BUFFER ) 
            {
                ErrorTrace(FILEID, "Not enough buffer space.",0);
                goto cleanup;
            }

            if( szBuf[0] == _TEXT('*') )
            {
                if( AddMetaDriveFileDir( 
                       szBuf, 
                       achType[lTypeLoop], 
                       FALSE, 
                       fDisable) == FALSE )
                {
                    ErrorTrace(FILEID, "error adding meta drive directory.",0);
                    goto cleanup;
                }

            }
            else
            {
                TCHAR szDeviceName[ MAX_PATH ];

                *szDeviceName=0;
    
                // ankor all nods at Root.. so tree actually looks 
                // like Root\C:\Windows etc 

                ConvertToInternalFormat( szBuf, szBuf2 );

                lNumTokens = CountTokens( szBuf2, _TEXT('\\') );

                if( AddTreeNode( 
                        &m_pRoot, 
                        szBuf2, 
                        achType[lTypeLoop], 
                        lNumTokens, 
                        0, 
                        FALSE, 
                        fDisable ) == FALSE ) 
                {
                    ErrorTrace(FILEID, "Error adding node.",0);
                    goto cleanup;
                }
            }

        }

        //
        // Find files for the type
        //

        lMax = m_XMLParser.GetFileCount( achType[lTypeLoop] );

        for(lLoop = 0;lLoop < lMax;lLoop++)
        {
            if( m_XMLParser.GetFile(lLoop, 
                                    szBuf, 
                                    MAX_BUFFER, 
                                    achType[lTypeLoop] ) != MAX_BUFFER ) 
            {
                ErrorTrace(FILEID, "Not enough buffer space.",0);
                goto cleanup;
            }

            if( szBuf[0] == _TEXT('*') )
            {
                if( AddMetaDriveFileDir( szBuf, 
                                         achType[lTypeLoop],  
                                         TRUE, FALSE ) == FALSE )
                {
                    ErrorTrace(FILEID, "error adding meta drive file.",0);
                    goto cleanup;
                }

            }
            else
            {
                int iType = lTypeLoop;

                //
                // if type is 's' make it exclude and add to the registry
                // setting fro snapshotted files
                //

                if ( achType[lTypeLoop] == TEXT('s') )
                {
                    AddRegistrySnapshotEntry( szBuf );

                    iType = 1; // exclude
                }
                
                //
                // Ankor all nods at Root.. so tree actually looks like 
                // Root\C:\Windows etc 
                //

                ConvertToInternalFormat( szBuf, szBuf2 );

                lNumTokens = CountTokens( szBuf2, _TEXT('\\') );

                if( AddTreeNode( 
                        &m_pRoot, 
                        szBuf2, 
                        achType[iType], 
                        lNumTokens, 
                        0, 
                        TRUE, 
                        FALSE ) == FALSE ) 
                {
                    ErrorTrace(FILEID, "Error adding node.",0);
                    goto cleanup;
                }

            }
        }
    }

    //
    // Merge information from the drivetable in to the blob
    //

    if ( MergeDriveTableInfo() == FALSE )
    {
        ErrorTrace(FILEID, "Error merging drive table info.",0);
        goto cleanup;
    }

    //
    // Merge Information under FilesNotToBackup key in to the blob ...
    //

    if ( MergeFilesNotToBackupInfo() == FALSE )
    {
        ErrorTrace(FILEID, "Error merging FilesNotToBackup Info.",0);
        goto cleanup;
    }

    //
    // Merge Per user information from the registry / user hives
    //

    if ( MergeAllUserRegistryInfo() == FALSE )
    {
        ErrorTrace(FILEID, "Error merging user registry info.",0);
        goto cleanup;
    }

#if 0

    //
    // Commented out: We monitor sfc cache ...
    // Merge information for sfcdllcache
    //

    if ( MergeSfcDllCacheInfo() == FALSE )
    {
        ErrorTrace(FILEID, "Error merging SfcDllCache info.",0);
        goto cleanup;
    }

#endif

    //
    // Build the path tree based on our tree and the data we collected 
    // about it ( filecounts, nodecounts, # chars, etc)
    //
    
    if( PathTreeBlob.BuildTree( 
                         m_pRoot, 
                         m_lNodeCount, 
                         dwDefaultType,  
                         m_lFileListCount, 
                         m_lNumFiles, 
                         CalculateNumberOfHashBuckets( m_pRoot ),
                         m_lNumChars) == FALSE )
    {
        ErrorTrace(FILEID, "Error buildign pathtree blob.",0);
        goto cleanup;
    }
    
    // 
    //  Okay, now build a ext list hash blob
    // 

    lNumChars = 0;
    lNumExtTotal = 0;

    for(lTypeLoop = 0; lTypeLoop < 3;lTypeLoop++)
    {
        lNumExt = m_XMLParser.GetExtCount( achType[ lTypeLoop ] );
        lNumExtTotal += lNumExt;

        for(lLoop = 0;lLoop < lNumExt ;lLoop++)
        {
            if( m_XMLParser.GetExt(
                                lLoop, 
                                szBuf, 
                                MAX_BUFFER, 
                                achType[ lTypeLoop ] ) != MAX_BUFFER ) 
            {
                ErrorTrace(FILEID, "Not enough buffer space.",0);
                goto cleanup;
            }

            lNumChars += _tcslen( szBuf );
        }
    }

    ExtListBlob.Init( lNumExtTotal, lNumChars );

    for(lTypeLoop = 0; lTypeLoop < 3;lTypeLoop++)
    {
        lNumExt = m_XMLParser.GetExtCount( achType[ lTypeLoop ] );
        for(lLoop = 0;lLoop < lNumExt; lLoop++)
        {
            m_XMLParser.GetExt(lLoop, szBuf, MAX_BUFFER, achType[ lTypeLoop ] ); 
            ExtListBlob.AddFile( szBuf, achType[lTypeLoop]  );
        }

    }

    //
    // now we have both blobs, lets write to disk
    //

    if( (hOutFile = CreateFile(  pszOutFile,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE, 
                                 NULL, //  security attributes
                                 OPEN_ALWAYS,
                                 FILE_FLAG_RANDOM_ACCESS,
                                 NULL) // template file
                                 ) == INVALID_HANDLE_VALUE)
    {
        ErrorTrace( FILEID,  "CreateFile Failed 0x%x", GetLastError());
        goto cleanup;
    }

    //
    //  Prepare the header blob
    // 

    ConfigBlob.m_dwMaxSize  = sizeof(BlobHeader) + 
                              PathTreeBlob.GetSize() + 
                              ExtListBlob.GetSize();
    ConfigBlob.m_dwVersion  = BLOB_VERSION_NUM;
    ConfigBlob.m_dwMagicNum = BLOB_MAGIC_NUM  ;
    ConfigBlob.m_dwBlbType  = BLOB_TYPE_CONTAINER;
    ConfigBlob.m_dwEntries  = 2;
    
    if ( WriteFile(hOutFile, 
                   &ConfigBlob, 
                   sizeof(BlobHeader), 
                   &dwWritten, NULL) == 0) 
    {
        ErrorTrace( FILEID,  "WriteFile Failed 0x%x", GetLastError());
        goto cleanup;
    }

    if ( WriteFile(hOutFile, 
                   PathTreeBlob.GetBasePointer(), 
                   PathTreeBlob.GetSize(), 
                   &dwWritten, NULL) == 0) 
    {
        ErrorTrace( FILEID,  "WriteFile Failed 0x%x", GetLastError());
        goto cleanup;
    }

    if ( WriteFile(hOutFile, 
                   ExtListBlob.GetBasePointer(), 
                   ExtListBlob.GetSize(), 
                   &dwWritten, NULL) == 0) 
    {
        ErrorTrace( FILEID,  "WriteFile Failed 0x%x", GetLastError());
        goto cleanup;
    }
   
    fRet = TRUE;

cleanup:

    if (szBuf)
        delete [] szBuf;
    if (szBuf2)
        delete [] szBuf2;
    
    if( hOutFile )
    {
        CloseHandle( hOutFile );
    }

    ExtListBlob.CleanUpMemory();
    PathTreeBlob.CleanUpMemory();

    if( m_pRoot )
    {

        DeleteTree(m_pRoot);
        m_pRoot = NULL;
    }

    TraceFunctLeave();
    return(fRet);
}


//
// CFLDatBuilder::CountTokens
//     CountTokens(LPTSTR szStr, TCHAR chDelim)
//     Counts the number of tokens seperated by (chDelim) in a string.
//        

LONG 
CFLDatBuilder::CountTokens(
    LPTSTR szStr, 
    TCHAR chDelim)
{
    LONG lNumTokens=1;

    TraceFunctEnter("CFLDatBuilder::CountTokens");

    _ASSERT( szStr );

    if( *szStr == 0 )
    {
        TraceFunctLeave();
        return(0);
    }

    while( *szStr != 0 )
    {
        if( *szStr == chDelim )
        {
            lNumTokens++;
        }
        szStr = _tcsinc( szStr );

    }

    TraceFunctLeave();
    return(lNumTokens);
}

//
// CFLDatBuilder::_MyStrDup( LPTSTR szIn )
//     Same as _tcsdup or strdup but it does it our own local
//     heap space.
//

LPTSTR 
CFLDatBuilder::_MyStrDup( 
    LPTSTR szIn )
{
    LONG lLen;
    LPTSTR pszOut=NULL;

    if( szIn ) 
    {
        lLen = _tcslen( szIn );

        pszOut = (LPTSTR) HeapAlloc( m_hHeapToUse, 
                                     0, 
                                     (sizeof(TCHAR) * (lLen+1)) );

        if( pszOut )
        {
            _tcscpy( pszOut, szIn );
        }
    }

    return( pszOut );
}

//
// CFLDatBuilder::CalculateNumberOfHashBuckets
//    Calculates the number of hash buckets needed by the dynamic hashes
//    in the hashlist.
//

LONG 
CFLDatBuilder::CalculateNumberOfHashBuckets( 
    LPFLTREE_NODE pRoot )
{
    LONG lNumNeeded=0;

    if( pRoot )
    {
        if( pRoot->pChild ) 
        {
            lNumNeeded += CalculateNumberOfHashBuckets( pRoot->pChild );
        }
    
        if( pRoot->pSibling ) 
        {
            lNumNeeded += CalculateNumberOfHashBuckets( pRoot->pSibling );
        }
    
        if( pRoot->lNumFilesHashed > 0 )
        {
            lNumNeeded += GetNextHighestPrime( pRoot->lNumFilesHashed );
        }
    }

    return( lNumNeeded );
}

//
// Debugging Methods
//

//
// CFLDatBuilder::PrintList
//

void 
CFLDatBuilder::PrintList(
    LPFL_FILELIST pList, 
    LONG lLevel)
{
    LONG lCount;
    
    if( !pList )
    {
        return;
    }

    for(lCount = 0;lCount < lLevel;lCount++)
    {
        printf("    ");
    }

    printf("  f: %s\n", pList->szFileName );

    PrintList(pList->pNext, lLevel );
}

void 
CFLDatBuilder::PrintTree(
    LPFLTREE_NODE pTree, 
    LONG lLevel)
{
    LONG lCount;

    if( pTree )
    {
        for(lCount = 0;lCount < lLevel;lCount++)
        {
            printf("    ");
        }
    
        printf("%s", pTree->szPath);
        if( pTree->pFileList )
        {
            printf(" (%d) \n", pTree->lNumFilesHashed);
        }
        else
        {
            printf("\n");
        }
        PrintList( pTree->pFileList, lLevel );
        PrintTree( pTree->pChild, lLevel + 1 );
        PrintTree( pTree->pSibling, lLevel );
    }
    
    return;

}

//
// CFLDatBuilder::IsPrime
//

BOOL 
CFLDatBuilder::IsPrime(
    LONG lNumber)
{
    LONG cl;

    //
    // prevent divide by 0 problems
    //

    if( lNumber == 0 )
    {
        return FALSE;
    }

    if( lNumber == 1 )
    {
        return TRUE;
    }

    for(cl = 2;cl < lNumber;cl++)
    {
        if( (lNumber % cl ) == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
}

//
// CFLDatBuilder::GetNextHighestPrime
//

LONG 
CFLDatBuilder::GetNextHighestPrime( 
    LONG lNumber )
{
    LONG clLoop;

    if( lNumber >= LARGEST_HASH_SIZE )
    {
        return( LARGEST_HASH_SIZE );
    }
    
    for( clLoop = lNumber; clLoop < LARGEST_HASH_SIZE;clLoop++)
    {
        if( IsPrime( clLoop ) )
        {
            return( clLoop );
        }
    }

    // nothing found, return large hash size.

    return( LARGEST_HASH_SIZE );
}

//
// Some C helper API ( should be removed ?? )
//

DWORD 
HeapUsed( 
    HANDLE hHeap )
{
    PROCESS_HEAP_ENTRY HeapEntry;
    DWORD dwAllocSize=0;

    HeapEntry.lpData = NULL;
    
    while( HeapWalk( hHeap, &HeapEntry) != FALSE )
    {
        if( HeapEntry.wFlags & PROCESS_HEAP_ENTRY_BUSY )
            dwAllocSize += HeapEntry.cbData;

    }

    return( dwAllocSize );
}

//
// Convert to internal NT namespace format + additional formatiing for
// required to Add the tree node.
//

BOOL 
CFLDatBuilder::ConvertToInternalFormat(
    LPTSTR szFrom,
    LPTSTR szTo
    )
{
    BOOL fRet = FALSE;

#ifdef USE_NTDEVICENAMES
    if(szFrom[1] == TEXT(':') )
    {
        TCHAR szDeviceName[MAX_PATH];

        szFrom[2] = 0;

        QueryDosDevice( szFrom, szDeviceName, sizeof(szDeviceName) );

        _stprintf(szTo, 
                  _TEXT("NTROOT%s\\%s"), 
                  szDeviceName, 
                  szFrom+3 );

        //
        // remove terminating slash
        //

        if (szTo[_tcslen( szTo ) - 1] == _TEXT('\\'))
            szTo[_tcslen( szTo ) - 1] = 0;
          
        CharUpper( szTo );
    }
    else
#endif
    {
        _stprintf(szTo,_TEXT("NTROOT\\%s"), szFrom);
    }

    fRet = TRUE;

    return fRet;
}


//
// Adjust the process privileges so that we can load other user's hives.
//

DWORD 
CFLDatBuilder::SetPrivilegeInAccessToken(
    LPCTSTR pszPrivilegeName
    )
{
    TraceFunctEnter("CSnapshot::SetPrivilegeInAccessToken");
    
    HANDLE           hProcess;
    HANDLE           hAccessToken=NULL;
    LUID             luidPrivilegeLUID;
    TOKEN_PRIVILEGES tpTokenPrivilege;
    DWORD            dwReturn = ERROR_INTERNAL_ERROR, dwErr;

    hProcess = GetCurrentProcess();
    if (!hProcess)
    {
        dwReturn = GetLastError();
        trace(0, "GetCurrentProcess failed ec=%d", dwReturn);
        goto done;
    }

    if (!OpenProcessToken(hProcess,
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &hAccessToken))
    {
        dwErr=GetLastError();
        trace(0, "OpenProcessToken failed ec=%d", dwErr);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }
        goto done;
    }

    if (!LookupPrivilegeValue(NULL,
                              pszPrivilegeName,
                              &luidPrivilegeLUID))
    {
        dwErr=GetLastError();        
        trace(0, "LookupPrivilegeValue failed ec=%d",dwErr);
        if (ERROR_SUCCESS != dwErr)
        {
            dwReturn = dwErr;
        }        
        goto done;
    }

    tpTokenPrivilege.PrivilegeCount = 1;
    tpTokenPrivilege.Privileges[0].Luid = luidPrivilegeLUID;
    tpTokenPrivilege.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hAccessToken,
                               FALSE,  // Do not disable all
                               &tpTokenPrivilege,
                               sizeof(TOKEN_PRIVILEGES),
                               NULL,   // Ignore previous info
                               NULL))  // Ignore previous info
    {
        dwErr=GetLastError();
        trace(0, "AdjustTokenPrivileges");
        if (dwErr != NO_ERROR)
        {
            dwReturn = dwErr;
        }
        goto done;
    }
    
    dwReturn = ERROR_SUCCESS;

done:

    if (hAccessToken != NULL)
    {
        CloseHandle(hAccessToken);
    }
    
    TraceFunctLeave();
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\commonlibh.h ===
//+---------------------------------------------------------------------------
//
//  File:       parsecath.h
//
//  Contents:	The precompiled headers file.
//
//  History:    AshishS    Created     6/27/99
//
//----------------------------------------------------------------------------
#ifndef _COMMONLIB_HEADERS_H_
#define _COMMONLIB_HEADERS_H_


#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <tchar.h>
#include <locale.h>



 

// use the _ASSERT and _VERIFY in dbgtrace.h
#ifdef _ASSERT
#undef _ASSERT
#endif

#ifdef _VERIFY
#undef _VERIFY
#endif

#include <stdlib.h>
#include <dbgtrace.h>
// #include <sfp.h>
#include <traceids.h>
// #include <constants.h>
#include <commonlib.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\enumlogs\respoint.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    respoint.h
 *
 *  Abstract:
 *    Definition of CRestorePoint, CRestorePointEnum classes.
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _RESPOINT_H_
#define _RESPOINT_H_


#include "findfile.h"
#include "logfmt.h"
#include "srrestoreptapi.h"
#include <list>

#define MAX_RP_PATH							14


// class which will hold a single change log entry

class CChangeLogEntry {

private:    
    SR_LOG_ENTRY *_pentry;
    LPWSTR _pszDrive, _pszPath1, _pszPath2, _pszTemp, _pszProcess, _pszShortName;
    WCHAR  _pszRPDir[MAX_PATH];
    BYTE * _pbAcl;
    DWORD  _cbAcl;
    BOOL   _fAclInline;

public:
    CChangeLogEntry() {
        _pentry = NULL;
        _pszPath1 = _pszPath2 = _pszTemp = _pszDrive = _pszProcess = _pszShortName = NULL;
        _pbAcl = NULL;
        _cbAcl = 0;
        _fAclInline = FALSE;
    }

    void Load(SR_LOG_ENTRY *pentry, LPWSTR pszRPDir);

    BOOL CheckPathLengths();

    INT64 GetSequenceNum() {
        return _pentry->SequenceNum;
    }

    DWORD GetType() {
        return _pentry->EntryType;
    }

    DWORD GetFlags() {
        return _pentry->EntryFlags;
    }

    DWORD GetAttributes() {
        return _pentry->Attributes;
    }

    LPWSTR GetProcName() {
        return _pentry->ProcName;
    }
    
    LPWSTR GetRPDir() {
        return _pszRPDir;
    }
    
    LPWSTR GetDrive() {
        return _pszDrive;
    }

    LPWSTR GetPath1() {
        return _pszPath1;
    }

    LPWSTR GetPath2() {
        return _pszPath2;
    }

    LPWSTR GetTemp() {
        return _pszTemp;
    }    
    
    LPWSTR GetShortName() {
        return _pszShortName;
    }    

    BYTE * GetAcl() {
        return _pbAcl;
    }

    DWORD GetAclSize() {
        return _cbAcl;
    }

    LPWSTR GetProcess() {
        return _pszProcess;
    }
    
    DWORD GetAclInline() {
        return _fAclInline;
    }
};


// class which will hold a single restore point entry
// this will represent a restore point across all drives
// can use this to find the restore point size on a given drive
// enumeration will always happen on system drive (since this contains the change log)
// operations on all drives will be enumerated

class CRestorePoint {

private:
    RESTOREPOINTINFOW   *m_pRPInfo;
    WCHAR               m_szRPDir[MAX_RP_PATH];        // restore point dir, for eg. "RP1"    
    BOOL                m_fForward;                 // forward/reverse enumeration of change log
    CFindFile           m_FindFile;
    WCHAR               m_szDrive[MAX_PATH];        // drive for enumeration 
    FILETIME            m_Time;                     // creation time 
    BOOL                m_fDefunct;

    std::list<SR_LOG_ENTRY *>            m_ChgLogList;       
    std::list<SR_LOG_ENTRY *>::iterator  m_itCurChgLogEntry;     // iterator for above list
    
    DWORD BuildList(LPWSTR pszChgLog);
    DWORD InsertEntryIntoList(SR_LOG_ENTRY* pEntry);   

public:    
    CRestorePoint();
    ~CRestorePoint();

    void SetDir(LPWSTR szDir) {
        lstrcpy(m_szRPDir, szDir);
    }

    LPWSTR GetDir() {
        return m_szRPDir;
    }

    LPWSTR GetName() {
    	if (m_pRPInfo)
        	return m_pRPInfo->szDescription;
		else 
			return NULL;
    }

    DWORD GetType() {
    	if (m_pRPInfo)    	
	        return m_pRPInfo->dwRestorePtType;
		else return 0;	        
	        
    }

    DWORD GetEventType() {
    	if (m_pRPInfo)    	
	    	return m_pRPInfo->dwEventType;
	    else return 0;	
   	}
   	
    FILETIME *GetTime() {
        return &m_Time;
    }        

    BOOL IsDefunct() {
        return m_fDefunct;
    }

    DWORD GetNum();
    BOOL  Load(RESTOREPOINTINFOW *pRpinfo);
    DWORD ReadLog();
    DWORD WriteLog();
    BOOL  DeleteLog();
    DWORD Cancel();
    
    // need to call SetDir before calling any of these methods 
    
    DWORD FindFirstChangeLogEntry(LPWSTR pszDrive, 
                                  BOOL fForward, 
                                  CChangeLogEntry&);
    DWORD FindNextChangeLogEntry(CChangeLogEntry&);
    DWORD FindClose();     

    DWORD ReadSize (const WCHAR *pwszDrive, INT64 *pllSize);
    DWORD WriteSize (const WCHAR *pwszDrive, INT64 llSize);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flhashlist.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    hashlist.h

Abstract: 
  

Revision History:
      Eugene Mesgar        (eugenem)    6/16/99
        created

******************************************************************************/

#ifndef __CFLHASHLIST__
#define __CFLHASHLIST__

#include "flstructs.h"

#define LARGEST_HASH_SIZE   1003

class CFLHashList
{
    LPVOID  m_pBasePointer;
    LONG    m_lNumElements;

    LONG    m_lNumHashSpots;
    LONG    m_ilOpenEntry;
    DWORD   m_dwSize;
   

    ListHeader  *m_pListHeader;
    ListEntry   *m_pNodeIndex;
    BlobHeader  *m_pBlobHeader;

    DWORD       *m_paHashArray;       // base index pointer

    HANDLE      m_hHeapToUse;
public:
    CFLHashList();
    CFLHashList(HANDLE hHeap);

    virtual ~CFLHashList();

    BOOL Init(LONG lNumNodes, DWORD dwNumChars);
    BOOL AddFile(LPTSTR szFile, TCHAR chType);
    BOOL CleanUpMemory();

    DWORD CreatePathElem( LPTSTR pszData, BYTE *pbLargeBuffer );

    DWORD GetSize();
    LPVOID GetBasePointer();


    BOOL IsPrime(DWORD dwNumber);
    DWORD GetNextHighestPrime( DWORD dwNumber );
    

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flbuilder.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    CFLBuilder.h

Abstract: see CFLBuilder.cpp

Revision History:
      Eugene Mesgar        (eugenem)    6/16/99
        created

******************************************************************************/

#ifndef __FLBUILDER__
#define __FLBUILDER__


#include "xmlparser.h"

//
//  Local Data structres.
//

typedef struct flFileListTag FL_FILELIST, *LPFL_FILELIST;

struct flFileListTag {
    LPTSTR szFileName;
    TCHAR chType;
    LPFL_FILELIST pNext;
};
 
typedef struct flTreeNodeTag FLTREE_NODE, *LPFLTREE_NODE;

struct flTreeNodeTag 
{
    LPTSTR szPath;
    TCHAR chType;
   
    //
    // hashlist info
    //

    LPFL_FILELIST pFileList;
    LONG lNumFilesHashed;
    LONG lFileDataSize;     // # of chars in data file 

    LPFLTREE_NODE pParent;
    LPFLTREE_NODE pChild;
    LPFLTREE_NODE pSibling;

    //
    // long node number
    //

    LONG lNodeNumber;

    //
    // is this a protected directory
    //

    BOOL fDisableDirectory;
};



class CFLDatBuilder
{
    LONG    m_lNodeCount, m_lFileListCount;
    LONG    m_lNumFiles, m_lNumChars;
   
    //
    // xml parser
    //

    CXMLFileListParser  m_XMLParser;

    //
    // tree root node
    //
    
    LPFLTREE_NODE      m_pRoot;

    //
    // default node type
    //

    TCHAR               m_chDefaultType;

    HANDLE              m_hHeapToUse;
  
public:

    BOOL BuildTree(LPCTSTR pszFile, LPCTSTR pszOutFile);
    BOOL VerifyVxdDat(LPCTSTR pszFile);
    
    CFLDatBuilder();
    virtual ~CFLDatBuilder();
 
private:
    LPFLTREE_NODE CreateNode(LPTSTR szPath, TCHAR chType, LPFLTREE_NODE pParent, BOOL fDisable);
    LPFL_FILELIST CreateList();

    void PrintTree(LPFLTREE_NODE pTree, LONG lLevel);
    void PrintList(LPFL_FILELIST pList, LONG lLevel);

    //
    // nulls list and recurses
    //

    BOOL DeleteTree(LPFLTREE_NODE pTree);
    BOOL DeleteList(LPFL_FILELIST pList);

    //
    //  This is for files or directories like *:\Recycle Bin
    //

    BOOL AddMetaDriveFileDir( LPTSTR szInPath, TCHAR chType, BOOL fFile, BOOL fDisable );

    BOOL AddTreeNode(LPFLTREE_NODE *pParent, LPTSTR szFullPath, TCHAR chType, LONG lNumElements, LONG lLevel, BOOL fFile, BOOL fDisable);
    BOOL AddFileToList(LPFLTREE_NODE pNode, LPFL_FILELIST *pList, LPTSTR szFile, TCHAR chType);

    LONG CountTokens(LPTSTR szStr, TCHAR chDelim);
    LPTSTR _MyStrDup( LPTSTR szIn );


    LONG GetNextHighestPrime( LONG lNumber );
    BOOL IsPrime(LONG lNumber);

    LONG CalculateNumberOfHashBuckets( LPFLTREE_NODE pRoot );

    BOOL ConvertToInternalFormat ( LPTSTR szBuf, LPTSTR szBuf2 );

    //
    // Additional info merging routines
    //

    DWORD SetPrivilegeInAccessToken( LPCTSTR pszPrivilegeName );
    BOOL  MergeUserRegistryInfo( 
              LPCTSTR pszUserProfilePath,
              LPCTSTR pszUserProfileHive,
              LPCTSTR pszUserSid );
    BOOL  AddUserProfileInfo(  
              HKEY hKeyUser,
              LPCTSTR pszUserProfilePath );
    BOOL  AddNodeForKeyValue(
              HKEY    hKeyUser,
              LPCTSTR pszSubKey,
              LPCTSTR pszValue );
    BOOL  AddRegistrySnapshotEntry(LPTSTR pszPath);

    BOOL  MergeFilesNotToBackupInfo( );
    BOOL  MergeDriveTableInfo( );
    BOOL  MergeAllUserRegistryInfo( );
    BOOL  MergeSfcDllCacheInfo( );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flhashlist.cpp ===
//++
// 
// Copyright (c) 1999 Microsoft Corporation
// 
// Module Name:
//     hashlist.cpp
// 
// Abstract: 
//     Used for creating hash list blobs.
// 
// Revision History:
//     Eugene Mesgar        (eugenem)    6/16/99
//         created
//     Kanwaljit Marok      (kmaork )    6/07/99
//         modified and ported to NT
//
//--

#include "flstructs.h"
#include "flhashlist.h"

#include "commonlibh.h"

#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile


#define TRACE_FILEID  0
#define FILEID        0
#define SAFEDELETE(p)  if (p) { HeapFree( m_hHeapToUse, 0, p); p = NULL;} else ;

CFLHashList::CFLHashList()
{
    m_pBasePointer = NULL;
    m_pListHeader = NULL;
    m_paHashArray = NULL;
    m_pBlobHeader = NULL;

    m_lNumElements = m_ilOpenEntry = 0;
    m_dwSize = 0;
    m_ilOpenEntry = 0;
    m_hHeapToUse = GetProcessHeap();
}

CFLHashList::CFLHashList(HANDLE hHeap )
{

    m_pBasePointer = NULL;
    m_pListHeader = NULL;
    m_paHashArray = NULL;
    m_pBlobHeader = NULL;

    m_lNumElements = m_ilOpenEntry = 0;
    m_dwSize = 0;
    m_ilOpenEntry = 0;
    m_hHeapToUse = hHeap;
}

CFLHashList::~CFLHashList()
{
    CleanUpMemory();
}

BOOL CFLHashList::CleanUpMemory()
{
    if( m_pBasePointer )
    {
        HeapFree( m_hHeapToUse, 0,  m_pBasePointer );
        m_pBasePointer = NULL;
    }

    m_dwSize = 0;
    m_ilOpenEntry = 0;
    m_lNumElements = 0;
    m_pBasePointer = NULL;
    m_pBlobHeader = NULL;
    m_paHashArray = NULL;
    m_pListHeader = NULL;
    return(TRUE);
}

// 
// Init function.. allocates memory, sets up base structures
// 

BOOL 
CFLHashList::Init(
    LONG lNumNodes, 
    DWORD dwNumChars)
{
    DWORD dwBlobSize;
    DWORD dwNumBuckets=0;

    TraceFunctEnter("CFLHashList::Init");

    //
    // Get the number of buckets we need
    //

    dwNumBuckets = GetNextHighestPrime( lNumNodes );

    //
    // We add 1 to NumNodes since the vxddat ignores node index since 
    // in the hashtable index 0 is null.
    //

    lNumNodes++;

    //
    // header    
    // size for dynmaic hash buckets        
    // list entries physical data
    //

    dwBlobSize = sizeof( ListHeader ) +  
                 ( sizeof(DWORD) * dwNumBuckets ) + 
                 ( sizeof(ListEntry)  * (lNumNodes) ) + 
                 ( dwNumChars*sizeof(WCHAR)) + 
                 ( sizeof(WCHAR)*(lNumNodes-1)) ;
    
    if( m_pBasePointer )
    {
        if( CleanUpMemory() == FALSE )
        {
            DebugTrace(FILEID, "Error cleaning up memory.",0);
            goto cleanup;
        }
    }

    if( (m_pBasePointer = HeapAlloc( m_hHeapToUse, 0,  dwBlobSize ) ) == NULL )
    {
        DebugTrace(FILEID, "Error allocating memory.", 0);
        goto cleanup;
    }

    memset(m_pBasePointer, 0, dwBlobSize );

    m_pBlobHeader = (BlobHeader *) m_pBasePointer;
    m_pListHeader = (ListHeader *) m_pBasePointer;
    m_pNodeIndex  = (ListEntry *)  ( (BYTE *) m_pBasePointer + 
                                      sizeof( ListHeader ) + 
                                      ( sizeof(DWORD) * dwNumBuckets ) );
    m_paHashArray = (DWORD *) ( (BYTE *) m_pBasePointer + sizeof( ListHeader ));


    m_pBlobHeader->m_dwBlbType = BLOB_TYPE_HASHLIST;
    m_pBlobHeader->m_dwVersion = BLOB_VERSION_NUM;
    m_pBlobHeader->m_dwMagicNum= BLOB_MAGIC_NUM  ;
    m_pBlobHeader->m_dwEntries = lNumNodes - 1; // actual entries is one less  
    m_pBlobHeader->m_dwMaxSize = dwBlobSize;


    m_pListHeader->m_dwDataOff = sizeof(ListHeader) + 
                                 ( sizeof(DWORD) * dwNumBuckets ) + 
                                 ( sizeof(ListEntry) * lNumNodes );
    m_pListHeader->m_iHashBuckets = dwNumBuckets;

    m_dwSize = dwBlobSize;
    m_ilOpenEntry = 1;
    m_lNumElements = lNumNodes;
 
    TraceFunctLeave();
    return(TRUE);

cleanup:
    
    SAFEDELETE( m_pBasePointer );
    TraceFunctLeave();
    return( FALSE );
}

//
//  is prime? these functions can be optimized i bet                   
//

BOOL 
CFLHashList::IsPrime(
    DWORD dwNumber)
{
    DWORD cdw;

    //
    // prevent divide by 0 problems
    //

    if( dwNumber == 0 )
    {
        return FALSE;
    }

    if( dwNumber == 1 )
    {
        return TRUE;
    }
 
    for(cdw = 2;cdw < dwNumber;cdw++)
    {
        if( (dwNumber % cdw ) == 0 )
        {
            return FALSE;
        }

    }

    return TRUE;
}

// 
// get the next prime number
// 

DWORD CFLHashList::GetNextHighestPrime( DWORD dwNumber )
{
LONG clLoop;

    if( dwNumber >= LARGEST_HASH_SIZE )
    {
        return( LARGEST_HASH_SIZE );
    }
    
    for( clLoop = dwNumber; clLoop < LARGEST_HASH_SIZE;clLoop++)
    {
        if( IsPrime( clLoop ) )
        {
            return( clLoop );
        }
    }

    // nothing found, return large hash size.

    return( LARGEST_HASH_SIZE );
}

//
//  Adds a file to the hashed list
//

BOOL CFLHashList::AddFile(LPTSTR szFile, TCHAR chType)
{
BYTE abBuf[1024];
LONG lPeSize, lHashIndex, lNodeNum;
ListEntry *pEntry;

    TraceFunctEnter("CFLHashList::AddFile");


    if( (lPeSize = CreatePathElem( szFile, abBuf )) == 0 )
    {
        DebugTrace(FILEID,"Error creating PathElement",0);
        goto cleanup;
    }

    if( m_ilOpenEntry == m_lNumElements ) 
    {
        DebugTrace(FILEID,"Too many elements in HashList.",0);
        goto cleanup;
    }

    if( (ULONG) lPeSize > ( m_dwSize - m_pListHeader->m_dwDataOff ) )
    {
        DebugTrace(FILEID,"Insuffienct space left in data section",0);
        goto cleanup;
    }

    //
    // get a new node
    //

    lNodeNum = m_ilOpenEntry++; 

    //
    // m_pNodeIndex is the base pointer to all file nodes
    //

    pEntry = m_pNodeIndex + lNodeNum;

    pEntry->m_dwDataLen = lPeSize;
    pEntry->m_dwData = m_pListHeader->m_dwDataOff;
   
    //
    // move global data offset.
    //

    m_pListHeader->m_dwDataOff += lPeSize;
    
    //
    // copy the entry into our data space
    //

    memcpy( (BYTE *) m_pBasePointer + pEntry->m_dwData, abBuf, lPeSize );

    //
    // hash the name and add it to the linked lsit
    //

    lHashIndex = HASH( (BYTE *) m_pListHeader,  (PathElement *) abBuf );
    

    pEntry->m_iNext = m_paHashArray[lHashIndex];
    m_paHashArray[lHashIndex] = lNodeNum;

    //
    // set the type.
    //

    if( chType == _TEXT('i') || chType == _TEXT('I') )
        pEntry->m_dwType = NODE_TYPE_INCLUDE;
    else if( chType == _TEXT('e') || chType == _TEXT('E') )
        pEntry->m_dwType = NODE_TYPE_EXCLUDE;
    else
        pEntry->m_dwType = NODE_TYPE_UNKNOWN;
    
    TraceFunctLeave();
    return(TRUE);
    
cleanup:

    TraceFunctLeave();
    return(FALSE);
}

//
// Helper to convert path elements
//
                                                            
DWORD CFLHashList::CreatePathElem( LPTSTR pszData, BYTE *pbLargeBuffer )
{
    int         cbLen, i;
    DWORD       dwReturn=0;
    PathElement *pElem =  (PathElement *)pbLargeBuffer;

    TraceFunctEnter("CFLHashList::CreatePathElem");

    if( NULL == pszData )
    {
        ErrorTrace(FILEID, "NULL pszData sent to CreatePathElem",0);
        goto cleanup;
    }

    cbLen = _tcslen(pszData);

    //
    // Add on to cbLen for LENGH char in prefixed strings.
    //

    pElem->pe_length = (USHORT) (cbLen+1)*sizeof(USHORT);

    //
    // if we're not in unicode, lets make sure the high bits are clean
    // Add sizeof(USHORT) to pElem offset to move past length char.
    //

    memset( pElem + sizeof(USHORT), 0, cbLen*2);


#ifndef UNICODE
    if( !MultiByteToWideChar(
        GetCurrentCodePage(),
        0,
        pszData,
        -1,
        pElem->pe_unichars, //move right 2 bytes past the length prefix
        MAX_BUFFER) )
    {
        DWORD dwError;
        dwError = GetLastError();
        ErrorTrace(FILEID, "Error converting to Wide char ec-%d",dwError);
        goto cleanup;
    }
#else
    RtlCopyMemory( pElem->pe_unichars,
                   pszData,
                   cbLen*sizeof(WCHAR) );
#endif
                
    dwReturn = pElem->pe_length;
    
cleanup:

    TraceFunctLeave();
    return dwReturn;
}


DWORD CFLHashList::GetSize()
{
    return( m_dwSize );
}


LPVOID CFLHashList::GetBasePointer()
{
    return( m_pBasePointer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\commonlib.cpp ===
//++
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  File:       commonlib.cpp
//
//  Contents:	Implements functions used across binaries in SFP
//				
//
//  History:    AshishS    Created     07/02/99
//
//--


#include "commonlibh.h"

#ifdef THIS_FILE
#undef THIS_FILE
#endif
static char __szTraceSourceFile[] = __FILE__;
#define THIS_FILE __szTraceSourceFile

//
// #define TRACEID SFPCOMLIBID
//

#define TRACEID 100

#define TOASCII(str)    str
#define USES_CONVERSION



//
//  MBCS Char Index Function
//

inline LPTSTR CharIndex(LPTSTR pszStr, DWORD idwIndex)
{
#ifdef _MBCS
    DWORD   cdwIndex;
    
    for( cdwIndex = 0;cdwIndex < idwIndex; cdwIndex++)
    {
        pszStr = _tcsinc( pszStr );
    }
#else
    pszStr = pszStr + idwIndex;   
#endif

    return( pszStr );
}


//
//  Calculate the Real size of a MBCS String
//

DWORD StringLengthBytes( LPTSTR pszStr )
{
    DWORD   cdwNumBytes = 0;

#ifdef _MBCS
    for( ; *pszStr; pszStr = _tcsinc( pszTemp ) )
    {
        cdwNumBytes += _tclen( pszTemp )      
    }

    //
    // Add one for the NULL char
    //

    cdwNumBytes += sizeof( TCHAR );
#else
 
    //
    // Return (length+NULL)*sizeof(TCHAR)
    //

    cdwNumBytes = (_tcslen( pszStr ) + 1) * sizeof(TCHAR);
#endif

    return( cdwNumBytes );
}


//
//  String Trimming-- this is a quite complicated routine because of all
//  the work needed to get around MBCS string manipulation.
//

void TrimString( LPTSTR pszStr )
{
    WCHAR   *pszStart=NULL;
    WCHAR   *pszBufStart = NULL;

    LONG    cStrLen =0;
    DWORD   cdwOrigSizeBytes;

    WCHAR   szStrBuf[MAX_BUFFER];

    DWORD   dwError;

    TraceFunctEnter("TrimString");

    if( !pszStr )
    {
        ErrorTrace(TRACEID, "NULL String passed to trim string");
        goto cleanup;
    }

    //
    //  Find the original size in bytes so we can convert back
    //  to MBCS later.
    //

    cdwOrigSizeBytes = StringLengthBytes( pszStr );

#ifndef _UNICODE
    if( !MultiByteToWideChar(  
            GetCurrentCodePage(),
            0,
            pszStr,
            -1,
            szStrBuf,
            MAX_BUFFER ) )
    {
        dwError = GetLastError();
        ErrorTrace( TRACEID, "MultiByteToWideChar( ) failed-  ec--%d", dwError);
        goto cleanup;        
    }
    pszStart = szStrBuf;
    pszBufStart = szStrBuf;
#else
    pszStart = pszStr;
    pszBufStart = pszStr;
#endif

    //
    // get the first non whitespace characters
    //

    for( ; (*pszStart == L' ' || *pszStart == L'\t' || *pszStart == L'\n' || *pszStart == L'\r'); pszStart++ )
    {
        ;
    }

    cStrLen = wcslen( pszStart );

    if( cStrLen == 0 )
    {
        DebugTrace(TRACEID, "Empty string in Trim String.",0);
        goto cleanup;
    }

    //
    // go back before the null char
    //

    cStrLen--;
    
    while( (cStrLen >= 0) && ( (pszStart[cStrLen] == L' ') || (pszStart[cStrLen] ==  L'\t' ) ||  (pszStart[cStrLen] ==  L'\n' ) || (pszStart[cStrLen] ==  L'\r' )  )  )
    {
        pszStart[cStrLen--] = 0;

        //pszStart[cStrLen--] = 0;
    }

   
    if( cStrLen == -1 )
    {
        DebugTrace(TRACEID, "Empty string in Trim String.",0);
        goto cleanup;
    }
    
    //
    //  Shift the memory back left ( The +2 is because we need to 
    //  move the null and cStrLen is an index value at this point)
    //

    MoveMemory( (PVOID) pszBufStart, pszStart,(cStrLen + 2)*sizeof(WCHAR) );

//
//  Convert back
//

#ifndef _UNICODE
    if(!WideCharToMultiByte(
        GetCurrentCodePage(),              // code page
        0,                     // performance and mapping flags
        pszBufStart,            // address of wide-character string
        -1,                  // number of characters in string
        pszStr,             // address of buffer for new string
        cdwOrigSizeBytes,          // size of buffer
        NULL,                // address of default for unmappable 
                         // characters
        NULL) )   // address of flag set when default 
    {
        dwError = GetLastError();
        ErrorTrace( TRACEID, "MultiByteToWideChar( ) failed-  ec--%d", dwError);
        goto cleanup;   
    }
#endif


cleanup:
    TraceFunctLeave();
    return;
}

//
//  A buffer safe string copy. The buffer is in characters. 
//

BOOL BufStrCpy(LPTSTR pszBuf, LPTSTR pszSrc, LONG lBufSize)
{
    DWORD    cdwSrcLen=0;
    DWORD    cdwBytesUsed=0;
    DWORD    cdwNumCharsToCopy;

    cdwSrcLen = _tcslen( pszSrc );

    if( (unsigned) lBufSize >= StringLengthBytes( pszSrc )  )
    {
        _tcscpy( pszBuf, pszSrc );
        return TRUE;
    }


#ifdef _MBCS
    LPTSTR  pszTemp;
    DWORD   cdwBufLeft;

    //Save room for the NULL char
    cdwBufLeft = (lBufSize-1) * sizeof(TCHAR);
    pszTemp = pszSrc;
    cdwNumCharsToCopy = 0;

    while( (_tcsnextc(pszTemp) != 0) && ( cdwBufLeft > 0 ) )
    {
        cdwBufLeft -= _tclen( pszTemp );
        pszTemp = _tcsinc( pszTemp );
        
        if( cdwBufLeft > 0 )
        {
            cdwNumCharsToCopy++;
        }

    }
#else
    cdwNumCharsToCopy = lBufSize - 1;
#endif

    _tcsncpy( pszBuf, pszSrc, cdwNumCharsToCopy );

    CHARINDEX( pszBuf, cdwNumCharsToCopy ) = 0;

    return TRUE;
}

//
//  Function:   GetLine
//  Desc    :   Gets a line from a file stream, ignores empty lines and 
//              lines starting with '#'- it also trims off whitespace 
//              and newline (\n) and return (\r) characters from the input.
//  Returns:    0   = Failed or end of st stream
//              or
//              Length of the string read in ( characters )
//

LONG 
GetLine(FILE *fl, LPTSTR pszBuf, LONG lMaxBuf)
{
    LONG lRead;
    
    _ASSERT( fl );
    _ASSERT( pszBuf );
    
    if( lMaxBuf <= 0 )
    {
        return( 0 );
    }

    do 
    {
        pszBuf[0] = 0;
        if( _fgetts( pszBuf, lMaxBuf, fl ) == NULL )
        {
            // our buffer might be too small 
            return( 0 );
        }

        // trim the buffer, do it this point so  # doesn't get missed because of a space
        TrimString( pszBuf );

        if( _tcsnextc(pszBuf) == 0 )
        {
            continue;
        }

    } while( _tcsnextc(pszBuf) == _TEXT('#') );

    lRead = _tcslen( pszBuf );
  
    return( lRead );
}

//
//  Function:   GetField
//  Desc    :   Gets a field _lNum_ (0 based index) delimited by _chSep_ 
//              from string psmMain and puts it into pszInto.  pszInto 
//              should be >= in size as pszMain since GetField assumes 
//              there is enough space.
//  Returns:    1 -TRUE, 0, FALSE
//

LONG GetField(LPTSTR pszMain, LPTSTR pszInto, LONG lNum, TCHAR chSep)
{

    WCHAR           *pszP;
    WCHAR           *pszI;

    LONG            ToFind;
    WCHAR           szMainBuf[MAX_BUFFER];
    WCHAR           szIntoBuf[MAX_BUFFER];

    DWORD           dwError;
    BOOL            fReturn = FALSE;

    TraceFunctEnter("CXMLFileListParser::GetField");
    

    if(!pszMain || !pszInto)
    {
        goto cleanup;
    }

#ifndef _UNICODE
    if( !MultiByteToWideChar(  
            CP_OEMCP,
            0,
            pszMain,
            -1,
            szMainBuf,
            MAX_BUFFER ) )
    {
        dwError = GetLastError();
        ErrorTrace( TRACEID, "MultiByteToWideChar( ) failed-  ec--%d", dwError);
        goto cleanup;        
    }

    pszP = szMainBuf;
    pszI = szIntoBuf;
#else
    pszP = pszMain;
    pszI = pszInto;
#endif


    ToFind = lNum;                                                         

    while( *pszP != 0 && ToFind > 0) 
    {
        if( *pszP == (WCHAR) ((TBYTE) chSep)    )
        {
            ToFind--;
        }
        pszP++; 
    }

    if( *pszP == 0 )
    {
        goto cleanup;
    }

    while(*pszP != 0 && *pszP != (WCHAR) ((TBYTE) chSep) )
    {
        *pszI = *pszP;
        pszI++; 
        pszP++; 

    }
    *pszI = 0;


#ifndef _UNICODE

     //
     // Even though we know by definition the products is smaller than 
     // the source, we need to get the exact size or otherwise 
     // WidCharToMultiByte will blow some bounds.
     //

    if(!WideCharToMultiByte(
        CP_OEMCP,            // code page
        0,                   // performance and mapping flags
        szIntoBuf,           // address of wide-character string
        -1,                  // number of characters in string
        pszInto,             // address of buffer for new string
        StringLengthBytes(pszMain),          // size of buffer
        NULL,                // address of default for unmappable char
        NULL) )              // address of flag set when default 
    {
        dwError = GetLastError();
        ErrorTrace( TRACEID, "MultiByteToWideChar( ) failed-  ec--%d", dwError);
        goto cleanup;   
    }

#endif

    fReturn = TRUE;

cleanup:

    TraceFunctLeave();

    return( fReturn );

}   

inline UINT  GetCurrentCodePage()
{
    //
    // the current code page value
    //
    static UINT     uiLocal;    

    //
    // only query once-- by ANSI standard, should init to 0
    //

    static BOOL     fPrevQuery;

    TraceFunctEnter("GetCurrentCodePage");

    //
    //  Only bother with the query stuff once
    //  Load variables onto the stack only when needed.
    //

    if( FALSE == fPrevQuery )
    {
        TCHAR       *pszCurrent;

        // 256 should be able to fit the language name.
        TCHAR       szBuffer[256];

        uiLocal = CP_ACP;
        pszCurrent = NULL;

#ifndef UNICODE
        pszCurrent = setlocale( LC_CTYPE, "");
#else
        pszCurrent = _wsetlocale( LC_CTYPE, L"");
#endif

        if( NULL == pszCurrent )
        {
            ErrorTrace(TRACEID, "Error querying code locale.",0);
            goto cleanup;
        }

        if( FALSE == GetField( pszCurrent, szBuffer, 1, _TEXT('.')) )
        {
            ErrorTrace(TRACEID, "Error getting code page.",0);
            goto cleanup;
        }
    
        uiLocal = _ttoi( szBuffer );
        // some bugus input
        if( uiLocal == 0 )
        {
            // default to the ansi code page
            uiLocal = CP_ACP;
        }
        fPrevQuery = TRUE;
   }

cleanup:
    TraceFunctLeave();
    return( uiLocal );
}

#define DIFF( a, b )   (INT)(INT_PTR)( (PBYTE)(a) - (PBYTE)(b) )

BOOL
ExpandShortNames(
    LPTSTR pFileName,
    DWORD  cbFileName,
    LPTSTR LongName,
    DWORD  cbLongName
    )
{
    PTSTR pStart;
    PTSTR pEnd;
    PTSTR pCurrent;
    TCHAR ShortName[MAX_PATH];
    DWORD cbShortName = 0, LongNameIndex = 0;

    WIN32_FIND_DATA fd;

    BOOL bRet = TRUE;

    pStart    = pFileName;
    pCurrent  = pFileName;

    LongNameIndex = 0;

    // 
    // scan the entire string
    //

    while (*pCurrent)
    {
        //
        //
        // in this example the pointers are like this:
        //
        //  \Device\HarddiskDmVolumes\PhysicalDmVolumes\
        //          BlockVolume3\Progra~1\office.exe
        //                      ^        ^
        //                      |        |
        //                     pStart   pEnd
        //
        // pStart always points to the last seen '\\' .
        //
    
        //
        // is this a potential start of a path part?
        //
        
        if (*pCurrent == L'\\')
        {
            DWORD cbElem = DIFF(pCurrent, pStart) + sizeof(TCHAR);

            if (LongNameIndex + cbElem > cbLongName )
            {
                bRet = FALSE;
                goto End;
            }
 
            //
            // yes.  copy in the dest string and update pStart.
            //
            
            RtlCopyMemory( (PBYTE)LongName + LongNameIndex,
                           pStart,
                           cbElem );  // include '\\'
 
            LongNameIndex += cbElem;

            pStart = pCurrent;
        }

        //
        // does this current path part contain a short version (~)
        //

        if (*pCurrent == L'~')
        {

            //
            // we need to expand this part.
            //

            //
            // find the end
            //

            while (*pCurrent != L'\\' && *pCurrent != 0)
            {
                pCurrent++ ;
            }

            pEnd = pCurrent;

            cbShortName = DIFF(pEnd, pFileName);

            CopyMemory( ShortName,  pFileName,  cbShortName );

            ShortName[cbShortName/sizeof(TCHAR)] = 0;

            if ( FindFirstFile( ShortName,
                                &fd ) )
            {
                 DWORD cbElem = (_tcslen(fd.cFileName)+1) * sizeof(TCHAR);

                 if ((LongNameIndex + cbElem) > cbLongName )
                 {
                     bRet = FALSE;
                     goto End;
                 }
            
                 RtlCopyMemory( (PBYTE)LongName + LongNameIndex,
                                fd.cFileName,
                                cbElem );  // include '\\'

                 LongNameIndex += cbElem;

                 LongName[(LongNameIndex - sizeof(TCHAR))/sizeof(TCHAR)] = 
                     TEXT('\\');
            }
            else
            {
                 DWORD cbElem = (_tcslen(ShortName) + 1) * sizeof( TCHAR );
            
                 if ((LongNameIndex + cbElem) > cbLongName )
                 {
                     bRet = FALSE;
                     goto End;
                 }

                 RtlCopyMemory( (PBYTE)LongName + LongNameIndex,
                                pStart,
                                cbElem + sizeof(TCHAR));  // include '\\'
 
                 LongNameIndex += cbElem;
            }

            pStart = pEnd + 1;

            if ( *pEnd == TEXT('\\') )
            {
                pCurrent = pStart;
                continue;
            }
            else
            {
                pCurrent = pEnd;
            }

        }   // if (*pCurrent == L'~')

        pCurrent++;
    }  

    if ( pEnd != pCurrent )
    {
        DWORD cbElem = DIFF( pCurrent, pStart ) + sizeof(TCHAR);

        if ((LongNameIndex + cbElem) > cbLongName )
        {
             bRet = FALSE;
             goto End;
        }

        RtlCopyMemory( (PBYTE)LongName + LongNameIndex,
                       pStart,
                       cbElem);  // include '\\'

        LongNameIndex += cbElem;
    }

    LongName[(LongNameIndex - sizeof(TCHAR))/sizeof(TCHAR)] = 0;

End:
    return bRet;

}   // SrExpandShortNames
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flstructs.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    flstucts.h
 *
 *  Abstract:
 *    This file includes appropriate headers for the Blob structs.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef __FILELIST_STRUCTS__
#define __FILELIST_STRUCTS__

#define DRIVE_LETTER_SIZE 8

#define RING3

#include "common.h"
#include "pathtree.h"
#include "hashlist.h"
#include "atlbase.h"
#include "msxml.h"

#endif // __FILELIST_STRUCTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\blob.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    Blob.h
 *
 *  Abstract:
 *    This file blob related definitions for ring0 / ring3
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _BLOB_H_
#define _BLOB_H_

#ifdef __cplusplus
extern "C" {
#endif

#define BLOB_VERSION_NUM  3     // Version 3 for Whistler
#define BLOB_MAGIC_NUM    12345 // Magic number

enum BLOB_TYPE 
{
    BLOB_TYPE_CONFIG   = 0,     // Config blob may contain other blobs
    BLOB_TYPE_PATHTREE = 1,     // Path tree blob 
    BLOB_TYPE_HASHLIST = 2,     // Hashed list blob
    BLOB_TYPE_CONTAINER= 3,     // Container for other blobs
};

typedef struct _BLOB_HEADER       
{                        
    DWORD m_dwMaxSize ;    
    DWORD m_dwVersion ;   
    DWORD m_dwBlbType ;   
    DWORD m_dwEntries ;   
    DWORD m_dwMagicNum;
} BlobHeader;                        


#ifndef __FILELIST_STRUCTS__

#define DEFINE_BLOB_HEADER() BlobHeader

#else

#define DEFINE_BLOB_HEADER() BlobHeader m_BlobHeader

#endif

//
// Some convenience macros
//

#define INIT_BLOB_HEADER( pBlob, MaxSize, Version, BlbType, Entries ) \
    ((BlobHeader *)pBlob)->m_dwMaxSize  = MaxSize; \
    ((BlobHeader *)pBlob)->m_dwVersion  = Version; \
    ((BlobHeader *)pBlob)->m_dwBlbType  = BlbType; \
    ((BlobHeader *)pBlob)->m_dwEntries  = Entries; \
    ((BlobHeader *)pBlob)->m_dwMagicNum = BLOB_MAGIC_NUM;

#define BLOB_HEADER(pBlob)       ( ((BlobHeader *)pBlob) )
#define BLOB_MAXSIZE(pBlob)      ( ((BlobHeader *)pBlob)->m_dwMaxSize  )
#define BLOB_VERSION(pBlob)      ( ((BlobHeader *)pBlob)->m_dwVersion  )
#define BLOB_BLBTYPE(pBlob)      ( ((BlobHeader *)pBlob)->m_dwBlbType  )
#define BLOB_ENTRIES(pBlob)      ( ((BlobHeader *)pBlob)->m_dwEntries  )
#define BLOB_MAGIC(pBlob)        ( ((BlobHeader *)pBlob)->m_dwMagicNum )

#define VERIFY_BLOB_VERSION(pBlob)  (BLOB_VERSION(pBlob) == BLOB_VERSION_NUM)
#define VERIFY_BLOB_MAGIC(pBlob)    (BLOB_MAGIC(pBlob)   == BLOB_MAGIC_NUM  )

#ifdef __cplusplus
}
#endif

#endif  // _BLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flpathtree.h ===
/******************************************************************************

Copyright (c) 1999 Microsoft Corporation

Module Name:
    pathtree.h

Abstract: 
  

Revision History:
      Eugene Mesgar        (eugenem)    6/16/99
        created

******************************************************************************/

#ifndef __CFLPATHTREE__
#define __CFLPATHTREE__

#include "flstructs.h"

class CFLPathTree
{

    LPVOID  m_pBasePointer;
    LONG    m_lNumElements;
    DWORD   m_dwSize;
   

    TreeHeader  *m_pTreeHeader;
    TreeNode    *m_pNodeIndex;
    BlobHeader  *m_pBlobHeader;

    HANDLE      m_hHeapToUse;
public:
    CFLPathTree();
    CFLPathTree(HANDLE hHeap);
    ~CFLPathTree();


    DWORD GetSize();
    LPVOID GetBasePointer();

    BOOL BuildTree(LPFLTREE_NODE pTree,LONG lNumNodes, DWORD dwDefaultType,  LONG lNumFileList, LONG lNumFiles, LONG lNumBuckets,  LONG lNumChars);
    BOOL RecBuildTree( LPFLTREE_NODE pTree, LONG lLevel );
    DWORD CreatePathElem( LPTSTR pszData, BYTE *pbLargeBuffer );
    void CleanUpMemory();
    BOOL CopyPathElem (WCHAR * pszPath, TreeNode *pNode);
};












#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\chglogformat.h ===
#ifndef _CHGLOGFORMAT_H_
#define _CHGLOGFORMAT_H_

#pragma pack(1)
typedef struct {
    DWORD   dwSize;
    INT64   llSeqNum;         // seq num associated with the change log entry
    DWORD   dwOpr;            // file operation
    DWORD   dwDestAttr;       // file attributes of the destination file
    DWORD   dwFlags;          // flags - compressed file, acl in temp file etc.
    WCHAR   szData[1];        // szData will contain size-prefixed szSrc, szDest, szTemp and/or bAcl
}   CHGLOGENTRY;
#pragma pack()



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\filelist\flpathtree.cpp ===
//++
// 
// Copyright (c) 1999 Microsoft Corporation
// 
// Module Name:
//     pathtree.cpp
// 
// Abstract: 
//     Used to create a pathtree blob. closeley tied into the CFLDatBuilder 
//     class.
// 
// Revision History:
//       Eugene Mesgar        (eugenem)    6/16/99
//         created
//       Kanwaljit Marok      (kmarok)     6/07/2000
//         Converted to unicode and ported to NT
//--

#include "flstructs.h"
#include "flbuilder.h"
#include "flpathtree.h"
#include "flhashlist.h"
#include "commonlibh.h"

#ifdef THIS_FILE

#undef THIS_FILE

#endif

static char __szTraceSourceFile[] = __FILE__;

#define THIS_FILE __szTraceSourceFile


#define TRACE_FILEID  0
#define FILEID        0

CFLPathTree::CFLPathTree(HANDLE hHeap)
{
    
    m_pBasePointer = NULL;
    m_lNumElements = 0;
    m_dwSize = 0;

    m_pTreeHeader = NULL;
    m_pNodeIndex = NULL;
    m_pBlobHeader = NULL;

    m_hHeapToUse = hHeap;

}

CFLPathTree::CFLPathTree()
{
    TraceFunctEnter("CFLPathTree::CFLPathTree");

    m_hHeapToUse = GetProcessHeap();

    m_pBasePointer = NULL;
    m_lNumElements = 0;
    m_dwSize = 0;

    m_pTreeHeader = NULL;
    m_pNodeIndex = NULL;
    m_pBlobHeader = NULL;

    TraceFunctLeave();
}


CFLPathTree::~CFLPathTree()
{
    TraceFunctEnter("CFLPathTree::~CFLPathTree");
    CleanUpMemory();
    TraceFunctLeave();
}

void CFLPathTree::CleanUpMemory()
{
    TraceFunctEnter("CFLPathTree::CleanUpMemory");

    if( m_pBasePointer )
    {
        if( HeapFree( m_hHeapToUse, 0, m_pBasePointer) == 0)
        {
            printf("%d\n", GetLastError() );
        }
        m_pBasePointer = NULL;
    }

    m_lNumElements = 0;
    m_dwSize = 0;

    m_pTreeHeader = NULL;
    m_pNodeIndex = NULL;
    m_pBlobHeader = NULL;

    TraceFunctLeave();
}

BOOL 
CFLPathTree::BuildTree(
    LPFLTREE_NODE pTree,
    LONG lNumNodes, 
    DWORD dwDefaultType, 
    LONG lNumFileList, 
    LONG lNumFiles, 
    LONG lNumBuckets, 
    LONG lNumChars)
{
    DWORD dwBlobSize;

    TraceFunctEnter("CFLPathTree::BuildTree");

    //
    // size of the header, and all the entries;
    //

    dwBlobSize = sizeof( TreeHeader ) + ( sizeof( TreeNode ) * lNumNodes );
    
    //
    // size of all filelist hashes
    //

    dwBlobSize += ( sizeof( ListHeader ) * lNumFileList ) + ( sizeof( ListEntry ) * lNumFiles );

    //
    // each file list tacks on one extra used file. so we need to account this.
    //

    dwBlobSize += sizeof( ListEntry ) * lNumFileList;

    //
    // tack on the space we need for all our hash array buckets
    //

    dwBlobSize += (lNumBuckets *  sizeof(DWORD));

    //
    // data file pathlengths. (numtreenodes)*ushort (this is for 
    // the pe->length in the pathtree element) + lNumFiles*ushort 
    // (pe->length in the pathtree elemtn) + numchars*ushort
    //

    dwBlobSize += sizeof(USHORT) *  ( lNumFiles + lNumChars + lNumNodes );

    CleanUpMemory();

    if( (m_pBasePointer = HeapAlloc( m_hHeapToUse, 0, dwBlobSize ) ) == NULL ) 
    {
        DebugTrace(FILEID, "Error allocating memory.",0);
        goto cleanup;
    }

    memset( m_pBasePointer, 0, dwBlobSize );

    m_pBlobHeader = (BlobHeader *) m_pBasePointer;
    m_pTreeHeader = (TreeHeader *) m_pBasePointer;
    m_pNodeIndex  = (TreeNode *) ((BYTE *) m_pBasePointer + sizeof( TreeHeader ) );

    m_pBlobHeader->m_dwBlbType = BLOB_TYPE_PATHTREE;
    m_pBlobHeader->m_dwVersion = BLOB_VERSION_NUM;
    m_pBlobHeader->m_dwMagicNum= BLOB_MAGIC_NUM  ;
    m_pBlobHeader->m_dwEntries = lNumNodes;
    m_pBlobHeader->m_dwMaxSize = dwBlobSize;

    m_pTreeHeader->m_dwDataOff = sizeof(TreeHeader) + (sizeof(TreeNode) * lNumNodes );
    m_pTreeHeader->m_dwMaxNodes = lNumNodes;
    m_pTreeHeader->m_dwDataSize = dwBlobSize - sizeof(TreeHeader) - ( sizeof(TreeNode) * lNumNodes  );
    m_pTreeHeader->m_dwDefault = dwDefaultType;

    m_dwSize = dwBlobSize;
    m_lNumElements = lNumNodes;

    if( RecBuildTree( pTree, 0 ) == FALSE )
    {
        DebugTrace(FILEID, "Error building path tree blob", 0);
        goto cleanup;
    }

    TraceFunctLeave();
    return(TRUE);

cleanup:

    TraceFunctLeave();
    return(FALSE);
}

BOOL CFLPathTree::CopyPathElem (WCHAR * pszPath, TreeNode *pNode)
{
    TraceFunctEnter("CFLPathTree::CopyPathElem");

    LONG lPeSize;
    BYTE abBuf[1024];

    if( (lPeSize = CreatePathElem( pszPath, abBuf )) == 0 )
    {
        DebugTrace(FILEID,"Error creating path element",0);
        goto cleanup;
    }

    if( (ULONG) lPeSize > ( m_dwSize - m_pTreeHeader->m_dwDataOff ) )
    {
        DebugTrace(FILEID, "Not enougn memory to allocate path element.",0);
        goto cleanup;
    }

    pNode->m_dwData = m_pTreeHeader->m_dwDataOff;
    m_pTreeHeader->m_dwDataOff += lPeSize;

    memcpy( (BYTE *) m_pBasePointer + pNode->m_dwData  , abBuf, lPeSize );

    TraceFunctLeave();
    return TRUE;

cleanup:
    TraceFunctLeave();
    return FALSE;
}

BOOL 
CFLPathTree::RecBuildTree( 
    LPFLTREE_NODE pTree, 
    LONG lLevel )
{
    TreeNode *pNode;

    TraceFunctEnter("CFLPathTree::RecBuildTree");

    if( ! m_pBasePointer  ) 
    {
        TraceFunctLeave();
        return(FALSE);
    }

    //
    // we've ended our recursion
    //

    if( !pTree ) 
    {
        TraceFunctLeave();
        return( TRUE );
    }

    //
    // We enumerated all the nodes when we created them
    // initially so makeing this tree is cake.
    //

    pNode = m_pNodeIndex + pTree->lNodeNumber;

    if( pTree->pParent )
    {
        pNode->m_iFather = pTree->pParent->lNodeNumber;
    }

    if( pTree->pSibling )
    {
        pNode->m_iSibling = pTree->pSibling->lNodeNumber;
    }

    if( pTree->pChild )
    {
        pNode->m_iSon = pTree->pChild->lNodeNumber;
    }

    //
    // set the node type.
    //

    if( pTree->chType == _TEXT('i') || pTree->chType == _TEXT('I') )
        pNode->m_dwType = NODE_TYPE_INCLUDE;
    else if( pTree->chType == _TEXT('e') || pTree->chType == _TEXT('E') )
        pNode->m_dwType = NODE_TYPE_EXCLUDE;
    else
        pNode->m_dwType = NODE_TYPE_UNKNOWN;

    if (CopyPathElem (pTree->szPath, pNode) == FALSE)
        goto cleanup;

    if (pTree->fDisableDirectory)
    {
        pNode->m_dwFlags |= TREEFLAGS_DISABLE_SUBTREE; 
    }
    else
    {
        pNode->m_dwFlags &= ~TREEFLAGS_DISABLE_SUBTREE; 
    }

    //
    // now take care of the file list.
    //

    if( pTree->pFileList )
    {
        LPFL_FILELIST pList = pTree->pFileList;
        CFLHashList hashList( m_hHeapToUse );
        
        if( hashList.Init( pTree->lNumFilesHashed, pTree->lFileDataSize) == FALSE )
        {   
            DebugTrace(FILEID, "Error initializeing a hashlist blob",0);
            goto cleanup;
        }

        //
        // build the list
        //

        while( pList )
        {
            if( hashList.AddFile( pList->szFileName, pList->chType ) == FALSE )
            {
                hashList.CleanUpMemory();
                goto cleanup;
            }
            pList = pList->pNext;
        }

        //
        // do we have enough memory?
        //

        if( (ULONG) hashList.GetSize() > ( m_dwSize - m_pTreeHeader->m_dwDataOff ) )
        {
            hashList.CleanUpMemory();
            DebugTrace(FILEID, "Hash blob too big to fit in memory.",0);
            goto cleanup;
        }

        //
        // set the node's data pointer
        //

        pNode->m_dwFileList = m_pTreeHeader->m_dwDataOff;

        //
        // move forward the global data pointer offset
        //

        m_pTreeHeader->m_dwDataOff += hashList.GetSize();

        //
        // copy the memory over
        //

        memcpy( (BYTE *) m_pBasePointer + pNode->m_dwFileList, hashList.GetBasePointer(), hashList.GetSize() );

        hashList.CleanUpMemory();

    }
    
    if( pTree->pChild )
    {
        if( RecBuildTree( pTree->pChild, lLevel + 1 ) == FALSE )
        {
            goto cleanup;
        }
    }

    if( pTree->pSibling )
    {
        if( RecBuildTree( pTree->pSibling, lLevel ) == FALSE )
        {
            goto cleanup;
        }
    }

    TraceFunctLeave();
    return( TRUE );

cleanup:

    TraceFunctLeave();
    return( FALSE );
}


DWORD CFLPathTree::GetSize()
{
    return( m_dwSize );
}

LPVOID CFLPathTree::GetBasePointer()
{
    return( m_pBasePointer );
}


DWORD 
CFLPathTree::CreatePathElem( 
    LPTSTR pszData, 
    BYTE *pbLargeBuffer )
{
    int         cbLen, i;
    DWORD       dwReturn=0;
    PathElement *pElem =  (PathElement *)pbLargeBuffer;

    TraceFunctEnter("CFLHashList::CreatePathElem");

    if( NULL == pszData )
    {
        ErrorTrace(FILEID, "NULL pszData sent to CreatePathElem",0);
        goto cleanup;
    }

    cbLen = _tcslen(pszData);

    //
    // Add on to cbLen for LENGH char in prefixed strings.
    //

    pElem->pe_length = (USHORT) (cbLen+1)*sizeof(USHORT);

    //
    // if we're not in unicode, lets make sure the high bits are clean
    // Add sizeof(USHORT) to pElem offset to move past length char.
    //

    memset( pElem + sizeof(USHORT), 0, cbLen*2);


#ifndef UNICODE
    if( !MultiByteToWideChar(
            GetCurrentCodePage(),
            0,
            pszData,
            -1,
            pElem->pe_unichars, // move right 2 bytes past the length prefix
            MAX_BUFFER) )
    {
        DWORD dwError;
        dwError = GetLastError();
        ErrorTrace(FILEID, "Error converting to Wide char ec-%d",dwError);
        goto cleanup;
    }
#else
    RtlCopyMemory( pElem->pe_unichars,
                   pszData,
                   cbLen*sizeof(WCHAR) );
#endif
                
    dwReturn = pElem->pe_length;
    
cleanup:
    TraceFunctLeave();
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\hashlist.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    hashlist.h
 *
 *  Abstract:
 *    This file contains the implementation for hashlist.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _HASHED_LIST_H_
#define _HASHED_LIST_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "common.h"

#ifdef RING3

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#endif

//
// Ordered List Structures
//

#define MAX_BUCKETS 1000
#define MAX_EXT_LEN 256   // Length of extension PathElem

#define SR_MAX_EXTENSION_CHARS    20
#define SR_MAX_EXTENSION_LENGTH   sizeof(UNICODE_STRING) +  \
                                  ((SR_MAX_EXTENSION_CHARS + 1) * sizeof(WCHAR))

typedef struct LIST_HEADER
{
    DEFINE_BLOB_HEADER(); // Define common header for blob.

    DWORD m_dwDataOff   ; // Offset for next available entry.
    DWORD m_iFreeNode   ; // Next free node.
    DWORD m_iHashBuckets; // Number of hash buckets.
} ListHeader;

//
// Hash list entry node.
//

typedef struct  
{
    INT   m_iNext     ;               // Index to next sibling
    DWORD m_dwData    ;               // Offset for node data
    DWORD m_dwDataLen ;               // Length of node data
    DWORD m_dwType    ;               // Node Type 
} ListEntry;

//
// Ordered List related macros
//

#define LIST_HEADER(pList)          ( (ListHeader*) pList )
#define LIST_CURRDATAOFF(pList)     ( LIST_HEADER(pList)->m_dwDataOff )
#define LIST_NODES(pList) ( (ListEntry*) (                                     \
                            (BYTE*)pList      +                                \
                            sizeof(ListHeader)+                                \
                            LIST_HEADER(pList)->m_iHashBuckets * sizeof(DWORD))\
                          )
#define LIST_NODEPTR(pList, iNode)  ( LIST_NODES(pList) + iNode)
#define LIST_HASHARR(pList) ( (DWORD *)                                        \
                              ((BYTE*)pList    +                               \
                              sizeof(ListHeader))                              \
                            )
                               

#define STR_BYTES( pEntry ) (INT)(pEntry->m_dwDataLen - sizeof(USHORT))


//
// Hashing related inline functions / macros
// 

#define HASH_BUCKET(pList, iHash) \
    ( LIST_HASHARR(pList)[ iHash ]   )

static __inline INT 
CALC_LIST_SIZE( 
   DWORD dwMaxBuckets, 
   DWORD dwMaxNodes  , 
   DWORD dwDataSize  )
{
    INT iSize = sizeof(ListHeader) +  
        (dwMaxNodes + 1) * sizeof(ListEntry) +  
        dwDataSize;

    if ( dwMaxBuckets > MAX_BUCKETS )
        iSize += (MAX_BUCKETS*sizeof(DWORD));
    else
        iSize += (dwMaxBuckets*sizeof(DWORD));

    return iSize;
}

static __inline INT HASH(BYTE * pList, PathElement * pe) 
{
    unsigned long g, h = 0;
    INT i;
    INT cbChars = (pe->pe_length / sizeof(USHORT)) - 1;
    USHORT * pStr = pe->pe_unichars;

    for( i = 0; i < cbChars; i++ )
    {
         h = ( h << 4 ) + *pStr++;
         if ( g = h & 0xF0000000 ) h ^= g >> 24;
         h &= ~g;
    }
       
    return (h % LIST_HEADER(pList)->m_iHashBuckets);
}

static __inline INT HASHSTR(PBYTE pList, LPWSTR pStr, USHORT Size) 
{
    INT i;
    unsigned long g, h = 0;
    USHORT NumChars = Size/sizeof(WCHAR);

    for( i = 0; i < NumChars; i++ )
    {
         h = ( h << 4 ) + *pStr++;
         if ( g = h & 0xF0000000 ) h ^= g >> 24;
         h &= ~g;
    }
       
    return (h % LIST_HEADER(pList)->m_iHashBuckets);
}
      
// 
// Function Prototypes.
//

BOOL 
MatchEntry(
    IN  PBYTE  pList,       // Pointer to hash list
    IN  LPWSTR pStr,        // Pointer to unicode path string
    IN  INT    NumChars,    // Number  of unichars in path string
    OUT PINT   pType );     // Pointer to variable returning ext type

BOOL   
MatchExtension( 
    IN  PBYTE  pList,               // Pointer to hash list
    IN  PUNICODE_STRING pPath,      // Pointer to unicode path
    OUT PINT   pType,               // Pointer to node type
    OUT PBOOL  pfHasExt );          // Pointer to BOOL var returning ext result

#ifdef __cplusplus
}
#endif

#endif _HASHED_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\commonlib.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  File:       commonlib.h
//
//  Contents:	Prototypes of functions used across binaries in SFP
//				
//
//  History:    AshishS    Created     07/02/99
//
//----------------------------------------------------------------------------

#ifndef  _COMMON_LIB_H
#define  _COMMON_LIB_H

// #include <sfp.h>

PVOID SFPMemAlloc( DWORD dwBytesToAlloc );
VOID SFPMemFree( PVOID pvMemPtr );

#define SFP_SAFE_FREE(x) { if ( (x) ) { SFPMemFree(x); (x) = NULL; } }

/*
 *  Macro to get char index's other than Str[i]
 */
#define CHARINDEX(str,i)    (  *(CharIndex(str,i)) )

#ifndef MAX_BUFFER
#define MAX_BUFFER          1024
#endif



#if 0

DWORD GetFileVersion(TCHAR * pszFile,
                     INT64 * pFileVersion);

BOOL DoesFileExist(TCHAR * pszFileName);

BOOL DoesDirExist(TCHAR * pszFileName );

LPSTR GetFileNameFromPathA(LPCSTR pszPath, int cchText);

LPWSTR GetFileNameFromPathW(LPCWSTR pszPath, int cchText);

#ifdef UNICODE
#define GetFileNameFromPath  GetFileNameFromPathW
#else
#define GetFileNameFromPath  GetFileNameFromPathA
#endif // !UNICODE



WCHAR * SFPConvertToUnicode(CHAR * pszCatalogFile);

TCHAR * SFPDuplicateString(TCHAR * pszString);

CHAR * SFPConvertToANSI(WCHAR * pwszString, DWORD dwBytes);

WCHAR * SFPDuplicateMemory(WCHAR * pwszString, DWORD dwBytes);

INT64 MakeVersionFromString(TCHAR * pszVersion);

#endif

/*
 *  Registry Functions
 */
     
BOOL WriteRegKey(BYTE  * pbRegValue,
                 DWORD  dwNumBytes,
                 TCHAR  * pszRegKey,
                 TCHAR  * pszRegValueName,
                 DWORD  dwRegType);


BOOL ReadRegKeyOrCreate(BYTE * pbRegValue, // The value of the reg key will be
                         // stored here
                        DWORD * pdwNumBytes, // Pointer to DWORD conataining
                         // the number of bytes in the above buffer - will be
                         // set to actual bytes stored.
                        TCHAR  * pszRegKey, // Reg Key to be opened
                        TCHAR  * pszRegValueName, // Reg Value to query
                        DWORD  dwRegTypeExpected, 
                        BYTE  * pbDefaultValue, // default value
                        DWORD   dwDefaultValueSize); // size of default value

BOOL ReadRegKey(BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
                DWORD * pdwNumBytes, // Pointer to DWORD conataining
                 // the number of bytes in the above buffer - will be
                 // set to actual bytes stored.
                TCHAR  * pszRegKey, // Reg Key to be opened
                TCHAR  * pszRegValueName, // Reg Value to query
                DWORD  dwRegTypeExpected);




/*
 *  MBCS Char Index function
 */

LPTSTR CharIndex(LPTSTR pszStr, DWORD idwIndex);
//Calculate the Real size of a MBCS String
DWORD StringLengthBytes( LPTSTR pszStr );


/*
 *  String Functions
 */


void TrimString( LPTSTR pszStr );

BOOL BufStrCpy(LPTSTR pszBuf, LPTSTR pszSrc, LONG lBufSize);

LONG GetLine(FILE *fl, LPTSTR pszBuf, LONG lMaxBuf);

// gets a char delemited field
LONG GetField(LPTSTR pszMain, LPTSTR pszInto, LONG lNum, TCHAR chSep);



/*
 *  Function to get the current locale
 */
UINT  GetCurrentCodePage();


#if DEBUG
void SfpLogToStateMgrWindow( LPTSTR szLogMsg );
#else
#define SfpLogToStateMgrWindow( msg )
#endif

BOOL
ExpandShortNames(
    LPTSTR pFileName,
    DWORD  cbFileName,
    LPTSTR LongName,
    DWORD  cbLongName
    );

#endif //_COMMON_LIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\common.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    Common.h
 *
 *  Abstract:
 *    This file common ring0 / ring3 definitions
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _COMMON_H_
#define _COMMON_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Include for required definitions ...
//

#ifdef RING3

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>

#define ALLOCATE(a)  LocalAlloc( LPTR, a )
#define FREE(a)      LocalFree( a )

#endif

typedef __int64 INT64;

#define PATH_SEPARATOR_STR  "\\"
#define PATH_SEPARATOR_CHAR '\\'
#define ALL_FILES_WILDCARD  "*.*"
#define FILE_EXT_WCHAR      L'.'
#define FILE_EXT_CHAR        '.'

#define MAX_DRIVES          26

enum NODE_TYPE
{
    NODE_TYPE_UNKNOWN = 0,
    NODE_TYPE_INCLUDE = 1,
    NODE_TYPE_EXCLUDE = 2
};

#include "ppath.h"
#include "blob.h"

#ifdef __cplusplus
}
#endif

#endif // _COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\srrestoreptapi.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    SRRestorePtAPI.h

Abstract:
    This file contains the declarations for the SRRESTOREPT_API

******************************************************************************/

#if !defined( _SRRESTOREPTAPI_H )
#define _SRRESTOREPTAPI_H

//
// Type of Event
//

#define MIN_EVENT               		 100
#define BEGIN_SYSTEM_CHANGE     		 100
#define END_SYSTEM_CHANGE       		 101
#define BEGIN_NESTED_SYSTEM_CHANGE       102	// for Whistler only - use this to prevent nested restore pts
#define END_NESTED_SYSTEM_CHANGE         103	// for Whistler only - use this to prevent nested restore pts
#define MAX_EVENT               		 103

//
// Type of Restore Points
//

#define MIN_RPT                 0
#define APPLICATION_INSTALL     0
#define APPLICATION_UNINSTALL   1
#define DESKTOP_SETTING         2    /* Not implemented */
#define ACCESSIBILITY_SETTING   3    /* Not implemented */
#define OE_SETTING              4    /* Not implemented */
#define APPLICATION_RUN         5    /* Not implemented */
#define RESTORE                 6
#define CHECKPOINT              7
#define WINDOWS_SHUTDOWN        8    /* Not implemented */
#define WINDOWS_BOOT            9    /* Not implemented */
#define DEVICE_DRIVER_INSTALL   10
#define FIRSTRUN                11
#define MODIFY_SETTINGS         12
#define CANCELLED_OPERATION     13   /* Only valid for END_SYSTEM_CHANGE */
#define BACKUP_RECOVERY			14
#define MAX_RPT                 14


#define MAX_DESC                64
#define MAX_DESC_W				256   // longer for Whistler

//
// for Millennium compatibility
//

#pragma pack(push, srrestoreptapi_include)
#pragma pack(1)

//
// Restore point information
//

typedef struct _RESTOREPTINFOA {
    DWORD   dwEventType;                // Type of Event - Begin or End
    DWORD   dwRestorePtType;            // Type of Restore Point - App install/uninstall
    INT64   llSequenceNumber;           // Sequence Number - 0 for begin
    CHAR    szDescription[MAX_DESC];    // Description - Name of Application / Operation
} RESTOREPOINTINFOA, *PRESTOREPOINTINFOA;

typedef struct _RESTOREPTINFOW {
    DWORD   dwEventType;       
    DWORD   dwRestorePtType;   
    INT64   llSequenceNumber;  
    WCHAR   szDescription[MAX_DESC_W]; 
} RESTOREPOINTINFOW, *PRESTOREPOINTINFOW;


//
// Status returned by System Restore
//

typedef struct _SMGRSTATUS {
    DWORD   nStatus;            // Status returned by State Manager Process
    INT64   llSequenceNumber;   // Sequence Number for the restore point
} STATEMGRSTATUS, *PSTATEMGRSTATUS;

#pragma pack(pop, srrestoreptapi_include)


#ifdef __cplusplus
extern "C" {
#endif

//
// RPC call to set a restore point
//
// Return value  TRUE if the call was a success
//               FALSE if the call failed
//
// If pSmgrStatus nStatus field is set as follows
//
// ERROR_SUCCESS              If the call succeeded (return value will be TRUE)
//
// ERROR_TIMEOUT              If the call timed out due to a wait on a mutex for
//                            for setting restore points.
//
// ERROR_INVALID_DATA         If the cancel restore point is called with an invalid
//                            sequence number
//
// ERROR_INTERNAL_ERROR       If there are internal failures.
//
// ERROR_BAD_ENVIRONMENT      If the API is called in SafeMode
//
// ERROR_SERVICE_DISABLED     If SystemRestore is Disabled.
//
// ERROR_DISK_FULL 			  If System Restore is frozen (Windows Whistler only)
//
// ERROR_ALREADY_EXISTS       If this is a nested restore point

BOOL __stdcall
SRSetRestorePointA(
                  PRESTOREPOINTINFOA  pRestorePtSpec,  // [in] Restore Point specification
                  PSTATEMGRSTATUS     pSMgrStatus      // [out] Status returned 
                  );


BOOL __stdcall
SRSetRestorePointW(
                  PRESTOREPOINTINFOW  pRestorePtSpec,
                  PSTATEMGRSTATUS     pSMgrStatus    
                  );

DWORD __stdcall
SRRemoveRestorePoint(DWORD dwRPNum);
                  
#ifdef __cplusplus
}
#endif


#ifdef UNICODE
#define RESTOREPOINTINFO        RESTOREPOINTINFOW
#define PRESTOREPOINTINFO       PRESTOREPOINTINFOW
#define SRSetRestorePoint       SRSetRestorePointW
#else
#define RESTOREPOINTINFO        RESTOREPOINTINFOA
#define PRESTOREPOINTINFO       PRESTOREPOINTINFOA
#define SRSetRestorePoint       SRSetRestorePointA
#endif


#endif // !defined( _RESTOREPTAPI_H )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\logfmt.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    logfmt.h

Abstract:

    contains format for log header and entries

Author:

    Kanwaljit Marok (kmarok)     01-March-2000

Revision History:

--*/

#ifndef _LOGFMT_H_
#define _LOGFMT_H_

#define SR_LOG_VERSION       2
#define SR_LOG_MAGIC_NUMBER  0xabcdef12
#define SR_LOG_PROCNAME_SIZE 16

#define SR_LOG_FIXED_SUBRECORDS 3

#define ACL_FILE_PREFIX     L"S"
#define ACL_FILE_SUFFIX     L".Acl"

//
// these are the interesting types of entries
//

typedef enum _RECORD_TYPE
{
    RecordTypeLogHeader  = 0,      // Log header for SR Log
    RecordTypeLogEntry   = 1,      // Log Entry  for SR Log
    RecordTypeVolumePath = 2,      // Log Entry Volume Path ( SubRec )
    RecordTypeFirstPath  = 3,      // Log Entry First Path  ( SubRec )
    RecordTypeSecondPath = 4,      // Log Entry Second Path ( SubRec )
    RecordTypeTempPath   = 5,      // Log Entry Temp File   ( SubRec )
    RecordTypeAclInline  = 6,      // Log Entry ACL Info    ( SubRec )
    RecordTypeAclFile    = 7,      // Log Entry ACL Info    ( SubRec )
    RecordTypeDebugInfo  = 8,      // Option rec for debug  ( SubRec )
    RecordTypeShortName  = 9,      // Option rec for short names ( SubRec )

    RecordTypeMaximum
    
} RECORD_TYPE;

//
// this struct is the basic template for a log entry
//

typedef struct _RECORD_HEADER
{
    //
    // size of the entry including the trailing dword size
    //

    DWORD RecordSize;

    //
    // type of record
    //

    DWORD RecordType;

} RECORD_HEADER, *PRECORD_HEADER;

#define RECORD_SIZE(pRecord)         ( ((PRECORD_HEADER)pRecord)->RecordSize )
#define RECORD_TYPE(pRecord)         ( ((PRECORD_HEADER)pRecord)->RecordType )

//
// this struct is the basic template for a SR log entry
//

typedef struct _SR_LOG_ENTRY
{
    //
    // Log entry header
    //

    RECORD_HEADER Header;

    //
    // magic number for consistency check
    //

    DWORD MagicNum;

    //
    // event type for this entry , create, delete...
    //

    DWORD EntryType;

    //
    // any special flags to be passed
    //

    DWORD EntryFlags;

    //
    // attributes for the entry
    //

    DWORD Attributes;

    //
    // sequence number  for the entry
    //

    INT64 SequenceNum;

    //
    // process name making this change
    //

    WCHAR ProcName[ SR_LOG_PROCNAME_SIZE ];

    //
    // start of variable length data, data includes subrecords and
    // the end size
    //

    BYTE SubRecords[1];

} SR_LOG_ENTRY, *PSR_LOG_ENTRY;

#define ENTRYFLAGS_TEMPPATH    0x01
#define ENTRYFLAGS_SECONDPATH  0x02
#define ENTRYFLAGS_ACLINFO     0x04
#define ENTRYFLAGS_DEBUGINFO   0x08
#define ENTRYFLAGS_SHORTNAME   0x10

//
// this struct defines SR Log header
//

typedef struct _SR_LOG_HEADER
{
    //
    // Log entry header
    //

    RECORD_HEADER Header;

    //
    // magic number for consistency check
    //

    DWORD MagicNum;

    //
    // log version number
    //

    DWORD LogVersion;

    //
    // end size
    //

    //
    // start of variable length data, data includes subrecords and
    // the end size
    //

    BYTE SubRecords[1];

} SR_LOG_HEADER, *PSR_LOG_HEADER;


//
// this struct defines SR Log debugInfo struct
//

#define PROCESS_NAME_MAX    12
#define PROCESS_NAME_OFFSET 0x194

typedef struct _SR_LOG_DEBUG_INFO
{
    //
    // Log entry header
    //

    RECORD_HEADER Header;

    //
    // Thread Id
    //

    HANDLE ThreadId;

    //
    // ProcessId
    //

    HANDLE ProcessId;

    //
    // Event time stamp
    //

    ULARGE_INTEGER TimeStamp;

    //
    // Process Name
    //

    CHAR ProcessName[ PROCESS_NAME_MAX + 1 ];

} SR_LOG_DEBUG_INFO, *PSR_LOG_DEBUG_INFO;


//
// Some useful macros
//

#define GET_END_SIZE( a )  \
        *((PDWORD)((PBYTE)a+((PRECORD_HEADER)a)->RecordSize-sizeof(DWORD)))

#define UPDATE_END_SIZE( a, b )  \
        GET_END_SIZE(a)=b;

#define STRING_RECORD_SIZE(pRecord)   ( sizeof( RECORD_HEADER ) +         \
                                        (pRecord)->Length +                 \
                                        sizeof(WCHAR) )  // NULL term extra

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\pathtree.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    hashlist.h
 *
 *  Abstract:
 *    This file contains the definitions for pathtree.
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _PATHTREE_H_
#define _PATHTREE_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "common.h"

#define ALLVOLUMES_PATH_A      "__ALLVOLUMES__"
#define ALLVOLUMES_PATH_W     L"__ALLVOLUMES__"
#define ALLVOLUMES_PATH_T TEXT("__ALLVOLUMES__")

#define TREEFLAGS_DISABLE_SUBTREE   0x00000001

//
// Tree specific structures.
//

typedef struct  
{
    //
    // Directory related stuff.
    //

    INT   m_iFather   ;             // Index to the parent node
    INT   m_iSon      ;             // Index to the first son
    INT   m_iSibling  ;             // Index to next sibling
    DWORD m_dwData    ;             // Offset for node data
    DWORD m_dwFileList;             // Offset for file list
    DWORD m_dwType    ;             // Node Type
    DWORD m_dwFlags   ;             // Misc flags

} TreeNode;

typedef struct 
{
    DEFINE_BLOB_HEADER();           // Define common blob members

    // 
    // Tree related header stuff
    //

    DWORD m_dwMaxNodes ;            // Max number of nodes allowed
    DWORD m_dwDataSize ;            // Data section size
    DWORD m_dwDataOff  ;            // Current Data Offset
    INT   m_iFreeNode  ;            // Next free node
    DWORD m_dwDefault  ;            // Default node type

} TreeHeader;

//
// Tree Related Macros.
//

#define TREE_NODES(pTree)    ( (TreeNode*) ((BYTE *)pTree+sizeof(TreeHeader)) )
#define TREE_NODEPTR(pTree, iNode)  ( TREE_NODES(pTree) + iNode)
#define TREE_HEADER(pTree)          ( (TreeHeader *) pTree )
#define TREE_CURRDATAOFF(pTree)     ( ((TreeHeader *)pTree)->m_dwDataOff )
#define TREE_CURRDATAPTR(pTree)     ( (BYTE *)pTree + TREE_CURRDATAOFF(pTree) )
#define TREE_DATA(pTree)     ( (BYTE *)TREE_NODES(pTree) +  \
                               (sizeof(TreeNode) * \
                               TREE_HEADER(pTree)->m_dwMaxNodes) \
                             ) 

#define TREE_DATA_OFF(pTree) ( sizeof(TreeHeader) +              \
                               (sizeof(TreeNode) *               \
                               TREE_HEADER(pTree)->m_dwMaxNodes) \
                             ) 

#define TREE_DRIVENODE( pTree, iDrive ) \
                             ( TREE_HEADER(pTree)->m_arrDrive[ iDrive ] )

#define TREE_NODELISTOFF( pTree, iNode ) \
        TREE_NODEPTR( pTree, iNode )->m_dwFileList

#define DRIVE_INDEX( drive ) ( drive - L'A' )

#define TREE_ROOT_NODE 0     // Root node is always assigned as 0

//
// Function Prototypes.
//

BOOL   
MatchPrefix(
    BYTE * pTree, 
    INT iParent, 
    struct PathElement * ppElem , 
    INT * pNode,
    INT * pLevel,
    INT * pType,
    BOOL* pfDisable,
    BOOL* pfExactMatch
    );

BOOL
ConvertToParsedPath(
    LPWSTR  lpszPath,   
    USHORT  nPathLen,
    PBYTE   pPathBuf,
    WORD    nPathSize
    );

#ifdef __cplusplus
}
#endif

#endif _PATHTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\snapshot.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    snapshot.h
 *
 *  Abstract:
 *    CSnapshot, CSnapshot class definitions
 *
 *  Revision History:
 *    Ashish Sikka (ashishs)  05/05/2000
 *        created
 *
 *****************************************************************************/

#ifndef _SNAPSHOT_H_
#define _SNAPSHOT_H_



typedef HRESULT (WINAPI *PF_REG_DB_API)(PWCHAR);
typedef DWORD (WINAPI *PSNAPSHOTCALLBACK) (LPCWSTR);

class CTokenPrivilege
{
public:
    DWORD SetPrivilegeInAccessToken(WCHAR * pszPrivilegeName);

    CTokenPrivilege ()
    {
        m_fNewToken = FALSE;
    }
    ~CTokenPrivilege ()
    {
        if (m_fNewToken)
            SetThreadToken (NULL, NULL);  // remove impersonation token
    }
private:
    BOOL m_fNewToken;
};

class CSnapshot
{
public:
    CSnapshot();
    ~CSnapshot();
    
    DWORD CreateSnapshot(WCHAR * pszRestoreDir, HMODULE hCOMDll, LPWSTR pszRpLast, BOOL fSerialized);


     // This function must be called to Initialize a restore
     // operation. This must be called before calling
     // GetSystemHivePath GetSoftwareHivePath
    DWORD InitRestoreSnapshot(WCHAR * pszRestoreDir);    

     // Caller must reboot machine after calling this function
    DWORD RestoreSnapshot(WCHAR * pszRestoreDir);

    DWORD DeleteSnapshot(WCHAR * pszRestoreDir);

     // this returns the path of the system hive. The caller must pass
     // in a buffer with length of this buffer in dwNumChars
    DWORD GetSystemHivePath(WCHAR * pszRestoreDir,
                            WCHAR * pszHivePath,
                            DWORD   dwNumChars);

     // this returns the path of the software hive. The caller must pass
     // in a buffer with length of this buffer in dwNumChars
    DWORD GetSoftwareHivePath(WCHAR * pszRestoreDir,
                              WCHAR * pszHivePath,
                              DWORD   dwNumChars);

    DWORD GetSamHivePath (WCHAR * pszRestoreDir,
                          WCHAR * pszHivePath,
                          DWORD   dwNumChars);

     // this function must be called after a restore operation to
     // cleanup files created by RegReplaceKey.
    DWORD CleanupAfterRestore(WCHAR * pszRestoreDir);
    
    
private:
    HMODULE m_hRegdbDll ;
    PF_REG_DB_API m_pfnRegDbBackup;
    PF_REG_DB_API m_pfnRegDbRestore;
    
    DWORD DoCOMDbSnapshot(WCHAR * pszSnapshotDir, HMODULE hCOMDll);
    DWORD DoRegistrySnapshot(WCHAR * pszSnapshotDir);
    DWORD RestoreRegistrySnapshot(WCHAR * pszSnapShotDir);
    DWORD RestoreCOMDbSnapshot(WCHAR * pszSnapShotDir);
    DWORD GetCOMplusBackupFN(HMODULE hCOMDll);
    DWORD GetCOMplusRestoreFN();
};


#endif // _SNAPSHOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\ppath.h ===
/******************************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  Module Name:
 *    ifsr3.h
 *
 *  Abstract:
 *    This file contains definitions from ring 0 required in ring 3
 *
 *  Revision History:
 *    Kanwaljit S Marok  ( kmarok )  05/17/99
 *        created
 *
 *****************************************************************************/

#ifndef _IFSR3_H_ 
#define _IFSR3_H_ 

#ifdef __cplusplus
extern "C" {
#endif

#define CALC_PPATH_SIZE( a )    ( ( a + 3 ) * sizeof( WCHAR ) )
#define MAX_PPATH_SIZE            CALC_PPATH_SIZE(MAX_PATH)

typedef struct PathElement PathElement;
typedef struct ParsedPath ParsedPath;
typedef ParsedPath *path_t;

struct PathElement {
	unsigned short	pe_length;
	unsigned short	pe_unichars[1];
}; /* PathElement */

struct ParsedPath {
	unsigned short	pp_totalLength;
	unsigned short	pp_prefixLength;
	struct PathElement pp_elements[1];
}; /* ParsedPath */


#define IFSPathSize(ppath)	((ppath)->pp_totalLength + sizeof(short))
#define IFSPathLength(ppath) ((ppath)->pp_totalLength - sizeof(short)*2)
#define IFSLastElement(ppath)	((PathElement *)((char *)(ppath) + (ppath)->pp_prefixLength))
#define IFSNextElement(pel)	((PathElement *)((char *)(pel) + (pel)->pe_length))
#define IFSIsRoot(ppath)	((ppath)->pp_totalLength == 4)

// New defines

#define IFSPathElemChars(pel) ( (((PathElement*)pel)->pe_length/sizeof(USHORT)) - 1 )

#ifdef __cplusplus
}
#endif

#endif // _IFSR3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\srapi.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    srapi.h

Abstract:

    This module defines the public System Restore interface for nt.

Author:

    Paul McDaniel (paulmcd)       24-Feb-2000

Revision History:

    Paul McDaniel (paulmcd)       18-Apr-2000   completely new version

--*/

#ifndef _SRAPI_H_
#define _SRAPI_H_

#ifdef __cplusplus
extern "C" {
#endif


/***************************************************************************++

Routine Description:

    SrCreateControlHandle is used to retrieve a HANDLE that can be used 
    to perform control operations on the driver.  

Arguments:

    pControlHandle - receives the newly created HANDLE.  The controlling 
        application must call CloseHandle when it is done.
    
    Options - one of the below options.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/

#define SR_OPTION_OVERLAPPED                0x00000001  // for async
#define SR_OPTION_VALID                     0x00000001  // 

ULONG
WINAPI
SrCreateControlHandle (
    IN  ULONG Options,
    OUT PHANDLE pControlHandle
    );

/***************************************************************************++

Routine Description:

    SrCreateRestorePoint is called by the controlling application to declare
    a new restore point.  The driver will create a local restore directory
    and then return a unique sequence number to the controlling app.

Arguments:

    ControlHandle - the control HANDLE.

    pNewRestoreNumber - holds the new restore number on return.  example: if 
        the new restore point directory is \_restore\rp5 this will return 
        the number 5
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrCreateRestorePoint (
    IN HANDLE ControlHandle,
    OUT PULONG pNewRestoreNumber
    );

/***************************************************************************++

Routine Description:

    SrGetNextSequenceNum is called by the application to get the next
    available sequence number from the driver.

Arguments:

    ControlHandle - the control HANDLE.

    pNewSequenceNumber - holds the new sequnce number on return.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrGetNextSequenceNum(
    IN HANDLE ControlHandle,
    OUT PINT64 pNextSequenceNum
    );

/***************************************************************************++

Routine Description:

    SrReloadConfiguration causes the driver to reload it's configuration 
    from it's configuration file that resides in a preassigned location.
    A controlling service can update this file, then alert the driver to 
    reload it.

    this file is %systemdrive%\_restore\_exclude.cfg .

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrReloadConfiguration (
    IN HANDLE ControlHandle
    );


/***************************************************************************++

Routine Description:

    SrStopMonitoring will cause the driver to stop monitoring file changes.
    The default state of the driver on startup is to monitor file changes.

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrStopMonitoring (
    IN HANDLE ControlHandle
    );

/***************************************************************************++

Routine Description:

    SrStartMonitoring will cause the driver to start monitoring file changes.
    The default state of the driver on startup is to monitor file changes.
    This api is only needed in the case that the controlling application has 
    called SrStopMonitoring and wishes to restart it.

Arguments:

    ControlHandle - the control HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
ULONG
WINAPI
SrStartMonitoring (
    IN HANDLE ControlHandle
    );

//
// these are the interesting types of events that can happen.
//


typedef enum _SR_EVENT_TYPE
{
    SrEventInvalid = 0,             // no action has been set

    SrEventStreamChange = 0x01,     // data is being changed in a stream
    SrEventAclChange = 0x02,        // an acl on a file or directory is changing
    SrEventAttribChange = 0x04,     // an attribute on a file or directory is changing
    SrEventStreamOverwrite = 0x08,  // a stream is being opened for overwrite
    SrEventFileDelete = 0x10,       // a file is being opened for delete
    SrEventFileCreate = 0x20,       // a file is newly created, not overwriting anything
    SrEventFileRename = 0x40,       // a file is renamed (within monitored space)
    
    SrEventDirectoryCreate = 0x80,  // a dir is created
    SrEventDirectoryRename = 0x100, // a dir is renamed (within monitored space)
    SrEventDirectoryDelete = 0x200, // an empty dir is deleted

    SrEventMountCreate = 0x400,     // a mount point was created
    SrEventMountDelete = 0x800,     // a mount point was deleted

    SrEventVolumeError = 0x1000,    // a non-recoverable error occurred on the volume

    SrEventMaximum = 0x1000,

    SrEventStreamCreate = 0x2000,   // a stream has been created.  This will never
                                    //   be logged, but is used to make sure that
                                    //   we handle stream creations correctly.
    SrEventLogMask = 0xffff,

    //
    // flags
    //
    
    SrEventNoOptimization   = 0x00010000,   // this flag on means no optimizations are to be performed
    SrEventIsDirectory      = 0x00020000,   // this event happened on a directory
    SrEventIsNotDirectory   = 0x00040000,   // this event happened on a non-directory (file)
    SrEventSimulatedDelete  = 0x00080000,   // when set this is a simulated DELETE operation -- 
                                            //    the file is not really being deleted, but to 
                                            //    SR it looks like a delete.
    SrEventInPreCreate      = 0x00100000,   // when set, the create has not yet been succeeded by the filesystem
    SrEventOpenById         = 0x00200000    // when set, the create has not yet been succeeded by the filesystem
                                            //    and this file is being opened by ID.
    
} SR_EVENT_TYPE;


//
// this structure represents a notification from kernel mode
// to user mode.  This is because of interesting volume activity
//

typedef enum _SR_NOTIFICATION_TYPE
{
    SrNotificationInvalid = 0,      // no action has been set

    SrNotificationVolumeFirstWrite, // The first write on a volume occured
    SrNotificationVolume25MbWritten,// 25 meg has been written the the volume
    SrNotificationVolumeError,      // A backup just failed, Context holds the win32 code.

    SrNotificationMaximum
    
} SR_NOTIFICATION_TYPE, * PSR_NOTIFICATION_TYPE;

#define SR_NOTIFY_BYTE_COUNT    25 * (1024 * 1024)

//
// this the largest nt path the sr chooses to monitor.  paths larger than
// this will be silently ignored and passed down to the file system 
// unmonitored.
//
//  NOTE: This lenght INCLUDES the terminating NULL at the end of the 
//  filename string.
//

#define SR_MAX_FILENAME_LENGTH         1000

// 
// Restore needs to prepend the volume guid in addition to the filepath -- 
// so the maximum filepath length relative to the volume that can be supported
// is 1000 - strlen(guid) = 952 characters
// restore also appends suffixes like (2) to these names in cases of locked or
// conflicting files, so to be really safe, we choose an even smaller number
//

#define SR_MAX_FILENAME_PATH           940


#define MAKE_TAG(tag)   ( (ULONG)(tag) )

#define SR_NOTIFICATION_RECORD_TAG    MAKE_TAG( 'RNrS' )

#define IS_VALID_NOTIFICATION_RECORD(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == SR_NOTIFICATION_RECORD_TAG))


typedef struct _SR_NOTIFICATION_RECORD
{
    //
    // SR_NOTIFICATION_RECORD_TAG
    //
    
    ULONG Signature;

    //
    // reserved
    //

    LIST_ENTRY ListEntry;

    //
    // the type of notification
    //
    
    SR_NOTIFICATION_TYPE NotificationType;

    //
    // the name of the volume being notified for
    //

    UNICODE_STRING VolumeName;

    //
    // a context/parameter
    //

    ULONG Context;

} SR_NOTIFICATION_RECORD, * PSR_NOTIFICATION_RECORD;


/***************************************************************************++

Routine Description:


    SrWaitForNotificaiton is used to receive volume activity notifications 
    from the driver.  This includes new volume, delete volume, and out of disk
    space for a volume.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

    pNotification - the buffer to hold the NOTIFICATION_RECORD.

    NotificationLength - the length in bytes of pNotification

    pOverlapped - an OVERLAPPED structure if async io is enabled on the 
        HANDLE.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG
WINAPI
SrWaitForNotification (
    IN HANDLE ControlHandle,
    OUT PSR_NOTIFICATION_RECORD pNotification,
    IN ULONG NotificationLength,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    );

/***************************************************************************++

Routine Description:

    SrSwitchAllLogs is used to cause the filter to close all of the open
    log files on all volumes, and use new log files.  this is used so that
    another process can parse these files without worrying about the filter
    writing to them.  use this to get a consistent view of the restore point.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG
WINAPI
SrSwitchAllLogs (
    IN HANDLE ControlHandle
    );


/***************************************************************************++

Routine Description:

    SrDisableVolume is used to temporarily disable monitoring on the 
    specified volume.  this is reset by a call to SrReloadConfiguration.
    There is no EnableVolume.

Arguments:

    ControlHandle - the HANDLE from SrCreateControlHandle.

    pVolumeName - the name of the volume to disable, in the nt format of 
        \Device\HarddiskDmVolumes\PhysicalDmVolumes\BlockVolume3.

Return Value:

    ULONG - Completion status.

--***************************************************************************/

ULONG
WINAPI
SrDisableVolume (
    IN HANDLE ControlHandle,
    IN PWSTR pVolumeName
    );


#define _SR_REQUEST(ioctl)                                                  \
                ((((ULONG)(ioctl)) >> 2) & 0x03FF)


#define SR_CREATE_RESTORE_POINT             0
#define SR_RELOAD_CONFIG                    1
#define SR_START_MONITORING                 2
#define SR_STOP_MONITORING                  3
#define SR_WAIT_FOR_NOTIFICATION            4
#define SR_SWITCH_LOG                       5
#define SR_DISABLE_VOLUME                   6
#define SR_GET_NEXT_SEQUENCE_NUM            7

#define SR_NUM_IOCTLS                       8

#define IOCTL_SR_CREATE_RESTORE_POINT       CTL_CODE( FILE_DEVICE_UNKNOWN, SR_CREATE_RESTORE_POINT, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define IOCTL_SR_RELOAD_CONFIG              CTL_CODE( FILE_DEVICE_UNKNOWN, SR_RELOAD_CONFIG, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_SR_START_MONITORING           CTL_CODE( FILE_DEVICE_UNKNOWN, SR_START_MONITORING, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_SR_STOP_MONITORING            CTL_CODE( FILE_DEVICE_UNKNOWN, SR_STOP_MONITORING, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_SR_WAIT_FOR_NOTIFICATION      CTL_CODE( FILE_DEVICE_UNKNOWN, SR_WAIT_FOR_NOTIFICATION, METHOD_OUT_DIRECT, FILE_READ_ACCESS )
#define IOCTL_SR_SWITCH_LOG                 CTL_CODE( FILE_DEVICE_UNKNOWN, SR_SWITCH_LOG, METHOD_NEITHER, FILE_WRITE_ACCESS )
#define IOCTL_SR_DISABLE_VOLUME             CTL_CODE( FILE_DEVICE_UNKNOWN, SR_DISABLE_VOLUME, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define IOCTL_SR_GET_NEXT_SEQUENCE_NUM      CTL_CODE( FILE_DEVICE_UNKNOWN, SR_GET_NEXT_SEQUENCE_NUM,METHOD_BUFFERED, FILE_WRITE_ACCESS )

//
// Names of the object directory, devices, driver, and service.
//

#define SR_CONTROL_DEVICE_NAME  L"\\FileSystem\\Filters\\SystemRestore"
#define SR_DRIVER_NAME          L"SR.SYS"
#define SR_SERVICE_NAME         L"SR"


//
// The current interface version number. This version number must be
// updated after any significant changes to the interface (especially
// structure changes).
//

#define SR_INTERFACE_VERSION_MAJOR  0x0000
#define SR_INTERFACE_VERSION_MINOR  0x0005


//
// The name of the EA (Extended Attribute) passed to NtCreateFile(). This
// allows us to pass version information at the time the driver is opened,
// allowing SR.SYS to immediately fail open requests with invalid version
// numbers.
//
// N.B. The EA name (including the terminator) must be a multiple of eight
// to ensure natural alignment of the SR_OPEN_PACKET structure used as
// the EA value.
//

//                                   7654321076543210
#define SR_OPEN_PACKET_NAME         "SrOpenPacket000"
#define SR_OPEN_PACKET_NAME_LENGTH  (sizeof(SR_OPEN_PACKET_NAME) - 1)
C_ASSERT( ((SR_OPEN_PACKET_NAME_LENGTH + 1) & 7) == 0 );


//
// The following structure is used as the value for the EA named above.
//

typedef struct SR_OPEN_PACKET
{
    USHORT MajorVersion;
    USHORT MinorVersion;

} SR_OPEN_PACKET, *PSR_OPEN_PACKET;


//
// Registry paths.
//

#define REGISTRY_PARAMETERS             L"\\Parameters"
#define REGISTRY_DEBUG_CONTROL          L"DebugControl"
#define REGISTRY_PROCNAME_OFFSET        L"ProcessNameOffset"
#define REGISTRY_STARTDISABLED          L"FirstRun"
#define REGISTRY_DONTBACKUP             L"DontBackup"
#define REGISTRY_MACHINE_GUID           L"MachineGuid"

#define REGISTRY_SRSERVICE              L"\\SRService"
#define REGISTRY_SRSERVICE_START        L"Start"

//
// directory and file paths
//

#define SYSTEM_VOLUME_INFORMATION       L"\\System Volume Information"
#define RESTORE_LOCATION                SYSTEM_VOLUME_INFORMATION L"\\_restore%ws"
#define GENERAL_RESTORE_LOCATION        SYSTEM_VOLUME_INFORMATION L"\\_restore"
#define RESTORE_FILELIST_LOCATION       RESTORE_LOCATION L"\\_filelst.cfg"

//
// used as a prefix for restore point subdirs (e.g. \_restore\rp5)
//

#define RESTORE_POINT_PREFIX            L"RP"

//
// used as a prefix for the backup files in a restore point subdir
// (e.g. \_restore\rp5\A0000025.dll) 
//

#define RESTORE_FILE_PREFIX             L"A"

#ifdef __cplusplus
}
#endif


#endif // _SRAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\srdefs.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srdefs.h
 *
 *  Abstract:
 *    SR constants definitions.
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _SRDEFS_H_
#define _SRDEFS_H_

// service names
static LPCWSTR s_cszServiceName     = L"SRService";
static LPCWSTR s_cszFilterName      = L"SR";
static LPCWSTR s_cszServiceDispName = L"System Restore Service";

// log file names
static LPCWSTR s_cszRestorePointLogName     = L"rp.log";
static LPCWSTR s_cszCurrentChangeLog        = L"change.log";
static LPCWSTR s_cszChangeLogPrefix         = L"change.log.";
static LPCWSTR s_cszChangeLogSuffix         = L"";
static LPCWSTR s_cszFifoLog                 = L"fifo.log";

// directories
static LPCWSTR s_cszSysVolInfo              = L"System Volume Information";
static LPCWSTR s_cszRestoreDir              = L"_restore";
static LPCWSTR s_cszRPDir                   = L"RP";
static LPCWSTR s_cszFifoedRpDir             = L"Fifoed";

//
// patch constants
//
static LPCWSTR s_cszReferenceDir            = L"RefRP";
static LPCWSTR s_cszPatchWindow             = L"PatchWindow";
static LPCWSTR s_cszPatchCompleteMarker     = L"patover";
static LPCWSTR s_cszPatchExtension          = L"._sr";


// reg hives for snapshot
static LPCWSTR s_cszSnapshotHardwareHive    = L"Hardware";
static LPCWSTR s_cszSnapshotUsersHive       = L"USERS";
static LPCWSTR s_cszSnapshotProfileList     = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList";
static LPCWSTR s_cszSnapshotProfileImagePath = L"ProfileImagePath";
static LPCWSTR s_cszSnapshotNTUserDat       = L"ntuser.dat";

// sr regkey constants
static LPCWSTR s_cszServiceRootRegKey       = L"System\\CurrentControlSet\\Services\\SRService";
static LPCWSTR s_cszServiceRegKey           = L"System\\CurrentControlSet\\Services\\SRService\\Parameters";
static LPCWSTR s_cszSRRegKey                = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore";
static LPCWSTR s_cszSRRegKey2               = L"Microsoft\\Windows NT\\CurrentVersion\\SystemRestore";
static LPCWSTR s_cszSRSnapshotRegKey        = L"FilesToSnapshot";
static LPCWSTR s_cszSRCfgRegKey             = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\Cfg";
static LPCWSTR  s_cszRegHiveTmp             = L"SystemRestoreSnapshot";
static LPCWSTR s_cszSRMachineGuid           = L"MachineGuid";
static LPCWSTR s_cszFilterRegKey            = L"System\\CurrentControlSet\\Services\\SR\\Parameters";
static LPCWSTR s_cszGroupPolicy             = L"Software\\Policies\\Microsoft\\Windows NT\\SystemRestore";
static LPCWSTR s_cszDisableSR               = L"DisableSR";
static LPCWSTR s_cszDisableConfig           = L"DisableConfig";
static LPCWSTR s_cszDSMax                   = L"DSMax";
static LPCWSTR s_cszDSMin                   = L"DSMin";
static LPCWSTR s_cszRPSessionInterval       = L"RPSessionInterval";
static LPCWSTR s_cszRPGlobalInterval        = L"RPGlobalInterval";
static LPCWSTR s_cszRPLifeInterval          = L"RPLifeInterval";
static LPCWSTR s_cszTimerInterval           = L"TimerInterval";
static LPCWSTR s_cszCompressionBurst        = L"CompressionBurst";
static LPCWSTR s_cszSRStatus                = L"SRStatus";
static LPCWSTR s_cszFirstRun                = L"FirstRun";
static LPCWSTR s_cszDiskPercent             = L"DiskPercent";
static LPCWSTR s_cszThawInterval            = L"ThawInterval";
static LPCWSTR s_cszDebugBreak              = L"DebugBreak";
static LPCWSTR s_cszRestoreInProgress       = L"RestoreInProgress";
static LPCWSTR s_cszTestBroadcast           = L"TestBroadcast";
static LPCWSTR s_cszCreateFirstRunRp        = L"CreateFirstRunRp";
static LPCWSTR s_cszRestoreStatus           = L"RestoreStatus";
static LPCWSTR s_cszSRUnattendedSection     = L"SystemRestore";
static LPCWSTR s_cszRestoreDiskSpaceError   = L"RestoreDiskSpaceError";
static LPCWSTR s_cszRestoreSafeModeStatus   = L"RestoreSafeModeStatus";
static LPCWSTR s_cszRegLMSYSSessionMan      = L"CurrentControlSet\\Control\\Session Manager";
static LPCWSTR s_cszCallbacksRegKey         = L"SnapshotCallbacks";


// sync objects
static LPCWSTR s_cszSRInitEvent             = L"SRInitEvent";
static LPCWSTR s_cszSRStopEvent             = L"SRStopEvent";
static LPCWSTR s_cszIdleRequestEvent        = L"SRIdleReqEvent";
static LPCWSTR s_cszDSMutex                 = L"SRDataStore";

// rpc 
static LPWSTR s_cszRPCProtocol              = L"ncalrpc";
static LPWSTR s_cszRPCEndPoint              = L"srrpc";

// datastore files
static const WCHAR s_cszRestorePointSize[]  = L"\\RestorePointSize";
static LPCWSTR     s_cszFilelistDat         = L"_filelst.cfg";
static LPCWSTR     s_cszWinRestDir          = L"%SystemRoot%\\system32\\restore\\";
static LPCWSTR     s_cszFilelistXml         = L"filelist.xml";
static LPCWSTR     s_cszMofFile             = L"sr.mof";
static const WCHAR s_cszDriveTable[]        = L"drivetable.txt";

// restore point names
static LPCWSTR s_cszSystemCheckpointName    = L"System Checkpoint";

// default registry values
// values in MB and seconds
#define SR_DEFAULT_DSMIN                    200             // system drive
#define SR_DEFAULT_DSMIN_NONSYSTEM          50              // non-system drive
#define SR_DEFAULT_DSMAX                    400             // all drives
#define SR_DEFAULT_RPSESSIONINTERVAL        0               // not configured
#define SR_DEFAULT_RPGLOBALINTERVAL         (24*60*60)      // 24 hrs
#define SR_DEFAULT_RPLIFEINTERVAL           7776000         // 90 days
#define SR_DEFAULT_TIMERINTERVAL            (2*60)          // 2 minutes
#define SR_DEFAULT_THAW_INTERVAL            (15*60)         // 15 minutes
#define SR_DEFAULT_IDLEINTERVAL             (60*60)         // 1 hour
#define SR_DEFAULT_COMPRESSIONBURST         60              // 60 seconds
#define SR_STATUS_ENABLED                   0
#define SR_STATUS_DISABLED                  1
#define SR_STATUS_FROZEN                    2
#define SR_FIRSTRUN_YES                     1
#define SR_FIRSTRUN_NO                      0
#define SR_DEFAULT_DISK_PERCENT             12
#define MAX_FREEZETHAW_LOG_MESSAGES         20

static LPCWSTR s_cszSessionManagerRegKey    = L"System\\CurrentControlSet\\Control\\Session Manager";
static LPCWSTR s_cszMoveFileExRegValue      = L"PendingFileRenameOperations";

static LPCWSTR s_cszCOMDllName        		= L"catsrvut.dll";

// other constants
#define SR_IDLETIME                         2      // 2 minutes

// thresholds and targets
#define THRESHOLD_FIFO_PERCENT              90
#define TARGET_FIFO_PERCENT                 75  

#define THRESHOLD_FIFO_DISKSPACE            80     // in MB
#define THRESHOLD_FREEZE_DISKSPACE          50     // in MB
#define THRESHOLD_RESTORE_DISKSPACE         60     // in MB
#define THRESHOLD_UI_DISKSPACE         		80     // in MB
#define THRESHOLD_THAW_DISKSPACE            200    // in MB

#define MEGABYTE                            (1024 * 1024)
#define GUID_STRLEN                         50
#define MAX_MOUNTPOINT_PATH                 100

// test messages

static LPCWSTR 	s_cszTM_Freeze				= L"SRTMFreeze";
static LPCWSTR 	s_cszTM_Thaw				= L"SRTMThaw";
static LPCWSTR 	s_cszTM_Fifo				= L"SRTMFifo";
static LPCWSTR 	s_cszTM_FifoStart			= L"SRTMFifoStart";
static LPCWSTR 	s_cszTM_FifoStop			= L"SRTMFifoStop";
static LPCWSTR 	s_cszTM_Enable				= L"SRTMEnable";
static LPCWSTR 	s_cszTM_Disable				= L"SRTMDisable";
static LPCWSTR  s_cszTM_CompressStart		= L"SRTMCompressStart";
static LPCWSTR  s_cszTM_CompressStop		= L"SRTMCompressStop";

static LPCWSTR s_cszUserPrefix        = L"_REGISTRY_USER_";
static LPCWSTR s_cszHKLMFilePrefix    = L"_REGISTRY_MACHINE_";
static LPCWSTR s_cszSystemHiveName    = L"SYSTEM";
static LPCWSTR s_cszSoftwareHiveName  = L"SOFTWARE";
static LPCWSTR s_cszSamHiveName       = L"SAM";
static LPCWSTR s_cszSecurityHiveName  = L"SECURITY";
static LPCWSTR s_cszRegHiveCopySuffix  = L"_PerRestoreCopy";
static LPCWSTR s_cszRegReplaceBackupSuffix = L"_RegReplaceBak";
static LPCWSTR  s_cszDRMKey1           = L"CLSID\\{8D8763AB-E93B-4812-964E-F04E0008FD50}";
static LPCWSTR  s_cszDRMKey2           = L"CLSID\\{3DA165B6-CC41-11d2-BDC6-00C04F79EC6B}";
static LPCWSTR  s_cszRemoteAssistanceKey = L"Microsoft\\Remote Desktop";
static LPCWSTR  s_cszPasswordHints = L"Microsoft\\Windows\\CurrentVersion\\Hints";
static LPCWSTR  s_cszContentAdvisor= L"Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings";
static LPCWSTR  s_cszWPAKey            = L"System\\CurrentControlSet\\Control\\Session Manager\\WPA";
static LPCWSTR  s_cszWPAKeyRelative    = L"WPA";

static LPCWSTR  s_cszDRMKeyBackupFile   = L"DRMData";

static LPCWSTR  s_cszMachineSecret      = L"$machine.acc";
static LPCWSTR  s_cszAutologonSecret    = L"DefaultPassword";
static LPCWSTR  s_cszRestoreSAMHiveName = L"SAM_Restore";
static LPCWSTR  s_cszRestoreSYSTEMHiveName = L"SYSTEM_Restore";
static LPCWSTR  s_cszRestoreSECURITYHiveName = L"SECURITY_Restore";

#define SNAPSHOT_DIR_NAME  		L"\\snapshot"
#define SRREG_VAL_MOVEFILEEX    L"PendingFileRenameOperations"
#define SRREG_PATH_SHELL        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\SystemRestore\\Shell"
#define SRREG_PATH_SESSIONMGR   L"System\\CurrentControlSet\\Control\\Session Manager"
#define SRREG_VAL_DEBUGTESTUNDO L"DebugTestUndo"

#define VOLUMENAME_FORMAT   L"\\\\?\\"

#define CLSNAME_RSTRSHELL  L"PCHShell Window"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\srrpcapi.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    srrpcapi.h
 *
 *  Abstract:
 *    Declarations for private RPC API
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _SRRPCAPI_H_
#define _SRRPCAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI    DisableSR(LPCWSTR pszDrive);
DWORD WINAPI    EnableSR(LPCWSTR pszDrive);
DWORD WINAPI    EnableSREx(LPCWSTR pszDrive, BOOL fWait);

DWORD WINAPI    DisableFIFO(DWORD dwRPNum);
DWORD WINAPI    EnableFIFO();

DWORD WINAPI    SRUpdateDSSize(LPCWSTR pszDrive, UINT64 ullSizeLimit);
DWORD WINAPI    SRSwitchLog();
DWORD WINAPI    SRUpdateMonitoredListA(LPCSTR pszXMLFile);
DWORD WINAPI    SRUpdateMonitoredListW(LPCWSTR pwszXMLFile);

#ifdef UNICODE
#define SRUpdateMonitoredList   SRUpdateMonitoredListW
#else
#define SRUpdateMonitoredList   SRUpdateMonitoredListA
#endif

void WINAPI     SRNotify(LPCWSTR pszDrive, DWORD dwFreeSpaceInMB, BOOL fImproving);

DWORD WINAPI    SRFifo(LPCWSTR pszDrive, 
                       DWORD dwTargetRp, 
                       int nPercent, 
                       BOOL fIncludeCurrentRp, 
                       BOOL fFifoAtleastOneRp);
DWORD WINAPI    SRCompress(LPCWSTR pszDrive);
DWORD WINAPI    SRFreeze(LPCWSTR pszDrive);
DWORD WINAPI    ResetSR(LPCWSTR pszDrive);
DWORD WINAPI	SRPrintState();	

//
// Registration of callback method for third-parties to 
// do their own snapshotting and restoration for their components.
// Applications can call this method with the full path of their dll.
// System Restore will load each registered dll dynamically and call one of the 
// following functions in the dll:
// "CreateSnapshot" when creating a restore point 
// "RestoreSnapshot" when restoring to a restore point
//  
// returns ERROR_SUCCESS on success
// Win32 error on failure
//

DWORD WINAPI SRRegisterSnapshotCallback(LPCWSTR pszDllPath);

//
// corresponding unregistration function to above function.
// Applications can call this to unregister any snapshot callbacks
// they have already registered
//
// returns ERROR_SUCCESS on success
// Win32 error on failure
//

DWORD WINAPI SRUnregisterSnapshotCallback(LPCWSTR pszDllPath);

//
// callback function names
//

static LPCSTR s_cszCreateSnapshotCallback   = "CreateSnapshot";
static LPCSTR s_cszRestoreSnapshotCallback  = "RestoreSnapshot";


// 
// applications should define their callback functions as
// DWORD WINAPI CreateSnapshot(LPCWSTR pszSnapshotDir) 
//              pszSnapshotDir: SystemRestore will create this directory 
//              The application can store its snapshot data in this directory

// DWORD WINAPI RestoreSnapshot(LPCWSTR pszSnapshotDir)
//              pszSnapshotDir: This directory is the same as the one passed to CreateSnapshot
//              Applications can retrieve the snapshot data from this directory
//

DWORD WINAPI    CreateSnapshot(LPCWSTR pszSnapshotDir);
DWORD WINAPI    RestoreSnapshot(LPCWSTR pszSnapshotDir);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\config.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config.h

Abstract:

    This is a local header file for config.c

Author:

    Paul McDaniel (paulmcd)     27-Apr-2000
    
Revision History:

--*/


#ifndef _CONFIG_H_
#define _CONFIG_H_


NTSTATUS
SrReadConfigFile (
    );

NTSTATUS
SrWriteConfigFile (
    );

NTSTATUS
SrReadBlobInfo (
    );

NTSTATUS
SrReadBlobInfoWorker( 
    IN PVOID pContext
    );

NTSTATUS
SrWriteRegistry (
    );

NTSTATUS
SrReadRegistry (
    IN PUNICODE_STRING pRegistry,
    IN BOOLEAN InDriverEntry
    );


#endif // _CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\config.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    config.c

Abstract:

    This is where we handle both our file based config and registry based
    config.

    most config is stored in the registry, with the file base config being
    reserved for config that must not be reverted during a restore.
    
Author:

    Paul McDaniel (paulmcd)     27-Apr-2000

Revision History:

--*/


#include "precomp.h"

//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//
NTSTATUS
SrWriteLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

LONG
SrReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
SrReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    );

//
// linker commands
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrWriteLongParameter )
#pragma alloc_text( PAGE, SrReadLongParameter )
#pragma alloc_text( PAGE, SrReadGenericParameter )
#pragma alloc_text( PAGE, SrReadRegistry )
#pragma alloc_text( PAGE, SrReadConfigFile )
#pragma alloc_text( PAGE, SrWriteConfigFile )
#pragma alloc_text( PAGE, SrReadBlobInfo )
#pragma alloc_text( PAGE, SrReadBlobInfoWorker )
#endif  // ALLOC_PRAGMA

/***************************************************************************++

Routine Description:

    Writes a single (LONG/ULONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to write.

    Value - Supplies the value.

Return Value:

    LONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
NTSTATUS
SrWriteLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )
{
    UNICODE_STRING valueKeyName;
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    RtlInitUnicodeString( &valueKeyName,
                          ValueName );

    status = ZwSetValueKey( ParametersHandle,
                            &valueKeyName,
                            0,
                            REG_DWORD,
                            &DefaultValue,
                            sizeof( LONG ) );

    return status;

}   // SrReadLongParameter

/***************************************************************************++

Routine Description:

    Reads a single (LONG/ULONG) value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    DefaultValue - Supplies the default value.

Return Value:

    LONG - The value read from the registry or the default if the
        registry data was unavailable or incorrect.

--***************************************************************************/
LONG
SrReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )
{
    PKEY_VALUE_PARTIAL_INFORMATION information;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(LONG)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, read it from the registry.
    //

    RtlInitUnicodeString( &valueKeyName,
                          ValueName );

    information = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

    status = ZwQueryValueKey( ParametersHandle,
                              &valueKeyName,
                              KeyValuePartialInformation,
                              (PVOID)information,
                              sizeof(buffer),
                              &informationLength );

    //
    // If the read succeeded, the type is DWORD and the length is
    // sane, use it. Otherwise, use the default.
    //

    if (status == STATUS_SUCCESS &&
        information->Type == REG_DWORD &&
        information->DataLength == sizeof(returnValue))
    {
        RtlCopyMemory( &returnValue, information->Data, sizeof(returnValue) );
    } else {
        returnValue = DefaultValue;
    }

    return returnValue;

}   // SrReadLongParameter



/***************************************************************************++

Routine Description:

    Reads a single free-form value from the registry.

Arguments:

    ParametersHandle - Supplies an open registry handle.

    ValueName - Supplies the name of the value to read.

    Value - Receives the value read from the registry.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    )
{
    KEY_VALUE_PARTIAL_INFORMATION partialInfo;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION newValue;
    ULONG dataLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Build the value name, then perform an initial read. The read
    // should fail with buffer overflow, but that's OK. We just want
    // to get the length of the data.
    //

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey( ParametersHandle,
                              &valueKeyName,
                              KeyValuePartialInformation,
                              (PVOID)&partialInfo,
                              sizeof(partialInfo),
                              &informationLength );

    if (NT_ERROR(status))
    {
        return status;
    }

    //
    // Determine the data length. Ensure that strings and multi-sz get
    // properly terminated.
    //

    dataLength = partialInfo.DataLength - 1;

    if (partialInfo.Type == REG_SZ || partialInfo.Type == REG_EXPAND_SZ)
    {
        dataLength += 1;
    }

    if (partialInfo.Type == REG_MULTI_SZ)
    {
        dataLength += 2;
    }

    //
    // Allocate the buffer.
    //

    newValue = SR_ALLOCATE_STRUCT_WITH_SPACE( PagedPool,
                                              KEY_VALUE_PARTIAL_INFORMATION,
                                              dataLength,
                                              SR_REGISTRY_TAG );

    if (newValue == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // update the actually allocated length for later use
    //

    dataLength += sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    RtlZeroMemory( newValue, dataLength );

    //
    // Perform the actual read.
    //

    status = ZwQueryValueKey( ParametersHandle,
                              &valueKeyName,
                              KeyValuePartialInformation,
                              (PVOID)(newValue),
                              dataLength,
                              &informationLength );

    if (NT_SUCCESS(status))
    {
        *Value = newValue;
    }
    else
    {
        SR_FREE_POOL( newValue, SR_REGISTRY_TAG );
    }

    RETURN(status);

}   // SrReadGenericParameter


/***************************************************************************++

Routine Description:

    Reads all of the config from the registry and stores it into global.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrReadRegistry(
    IN PUNICODE_STRING pRegistry,
    IN BOOLEAN InDriverEntry
    )
{    
    NTSTATUS            Status;
    PWCHAR              Buffer;
    USHORT              BufferSize;
    UNICODE_STRING      KeyName = {0,0,NULL};
    UNICODE_STRING      SetupKeyName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              RegHandle = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION  pValue = NULL;
    ULONG               ServiceStartType;

    PAGED_CODE();

    //
    // setup the defaults
    //
    
    global->DebugControl   = SR_DEBUG_DEFAULTS;
    global->ProcNameOffset = PROCESS_NAME_OFFSET;
    global->Disabled = TRUE;
    global->DontBackup = FALSE;

    if (InDriverEntry)
    {
#ifndef SYNC_LOG_WRITE
        global->LogBufferSize  = SR_DEFAULT_LOG_BUFFER_SIZE;
        global->LogFlushFrequency = SR_DEFAULT_LOG_FLUSH_FREQUENCY;
        global->LogFlushDueTime.QuadPart = (LONGLONG)-1 * (global->LogFlushFrequency * 
                                                           NANO_FULL_SECOND);
#endif        
        global->LogAllocationUnit = SR_DEFAULT_LOG_ALLOCATION_UNIT;
    }

    //
    //  We are going to use this buffer for all the key names we need to construct.
    //  make sure that it is large enough to hold the larger of these two names.
    //

    if (sizeof(REGISTRY_PARAMETERS) > sizeof( REGISTRY_SRSERVICE ))
    {
        BufferSize = (USHORT) sizeof(REGISTRY_PARAMETERS);
    }
    else
    {
        BufferSize = (USHORT) sizeof( REGISTRY_SRSERVICE );
    }
    BufferSize += pRegistry->Length;
    Buffer = SR_ALLOCATE_ARRAY( PagedPool,
                                WCHAR,
                                BufferSize/sizeof( WCHAR ),
                                SR_REGISTRY_TAG );
    if (Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }
    
    //
    // Open the SR Service registry key
    //

    KeyName.Buffer = Buffer;
    KeyName.MaximumLength = BufferSize;
    
    {
        //
        //  First we need to strip off the filter's service name from the
        //  registry location.
        //
        
        PWCHAR ServiceName = NULL;
        ULONG ServiceNameLength = 0;
            
        Status = SrFindCharReverse( pRegistry->Buffer, 
                                    pRegistry->Length, 
                                    L'\\',
                                    &ServiceName, 
                                    &ServiceNameLength );

        if (!NT_SUCCESS( Status ))
        {
            goto end;
        }

        ASSERT( ServiceName != NULL );
        ASSERT( ServiceNameLength > 0 );

        KeyName.Length = pRegistry->Length - ((USHORT)ServiceNameLength);
        RtlCopyMemory( KeyName.Buffer,
                       pRegistry->Buffer,
                       KeyName.Length );

        NULLPTR( ServiceName );

        //
        //  Append SRService's name to the registry path.
        //
        
        Status = RtlAppendUnicodeToString( &KeyName, REGISTRY_SRSERVICE );

        if (!NT_SUCCESS( Status ))
        {
            goto end;
        }
    }

    //
    //  We've built up the SR Service's name, so go open that registry location.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    Status = ZwOpenKey( &RegHandle, KEY_READ, &ObjectAttributes );
    if (!NT_SUCCESS( Status ))
        goto end;

    ServiceStartType = (ULONG)SrReadLongParameter( RegHandle,
                                                   REGISTRY_SRSERVICE_START,
                                                   SERVICE_DISABLED );

    ZwClose( RegHandle );
    NULLPTR( RegHandle );

    //
    //  Now open the filter's registry parameters key.
    //

    KeyName.Length = 0;

    RtlCopyUnicodeString( &KeyName,  pRegistry );
    
    Status = RtlAppendUnicodeToString( &KeyName, REGISTRY_PARAMETERS );
    if (!NT_SUCCESS( Status ))
    {
        goto end;
    }

    InitializeObjectAttributes( &ObjectAttributes,      // ObjectAttributes
                                &KeyName,               // ObjectName
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,      // Attributes
                                NULL,                   // RootDirectory
                                NULL );                 // SecurityDescriptor

    Status = ZwOpenKey( &RegHandle, KEY_READ | KEY_WRITE, &ObjectAttributes );
    if (!NT_SUCCESS( Status ))
    {
        goto end;
    }

    //
    //  If the usermode service is disabled, we want to set first run
    //  and keep the filter disabled.
    //

    if (ServiceStartType == SERVICE_DISABLED)
    {
        Status = SrWriteLongParameter( RegHandle,
                                       REGISTRY_STARTDISABLED,
                                       1 );
        CHECK_STATUS( Status );

        //
        //  No matter what, accept the defaults and exit.
        //
        goto end;
    }

    //
    //  The Usermode service is not disabled, so go ahead and read our
    //  parameters to figure out the filter starting configuration.
    //

#ifdef CONFIG_LOGGING_VIA_REGISTRY

    //
    //  We will only read these globals from the registry if 
    //  CONFIG_LOGGING_VIA_REGISTRY is defined.  This was added more for
    //  initial tuning of these parameters to find a good place for the
    //  default values to be set.  We don't want to test all possible values
    //  that could be set for the parameters, so we are disabling this
    //  feature in the released version of sr.sys.
    //
    
    if (InDriverEntry)
    {
#ifndef SYNC_LOG_WRITE        
        global->LogBufferSize = (ULONG)SrReadLongParameter( RegHandle,
                                                            REGISTRY_LOG_BUFFER_SIZE,
                                                            global->LogBufferSize );

        global->LogFlushFrequency = (ULONG)SrReadLongParameter( RegHandle,
                                                                REGISTRY_LOG_FLUSH_FREQUENCY,
                                                                global->LogFlushFrequency );

#endif

        global->LogAllocationUnit = (ULONG)SrReadLongParameter( RegHandle,
                                                                REGISTRY_LOG_ALLOCATION_UNIT,
                                                                global->LogAllocationUnit );
    }
#endif

#ifndef SYNC_LOG_WRITE        
    global->LogFlushDueTime.QuadPart = (LONGLONG)-1 * (global->LogFlushFrequency * 
                                                       NANO_FULL_SECOND);
#endif

    //
    //  Read the debug flags.
    //
    
    global->DebugControl = (ULONG)SrReadLongParameter( RegHandle,
                                                       REGISTRY_DEBUG_CONTROL,
                                                       global->DebugControl );


    //
    // Read the processname offset from the registry
    //

    SrTrace(INIT, ("\tProcessNameOffset(Def) = %X\n", global->ProcNameOffset));
    global->ProcNameOffset = (ULONG)SrReadLongParameter( RegHandle,
                                                         REGISTRY_PROCNAME_OFFSET,
                                                         global->ProcNameOffset );

    //
    // read to see if we should startup disabled.
    //

    global->Disabled = (BOOLEAN)SrReadLongParameter( RegHandle,
                                                     REGISTRY_STARTDISABLED,
                                                     global->Disabled );


    //
    // read to see if we should make any copies
    //

    global->DontBackup = (BOOLEAN)SrReadLongParameter( RegHandle,
                                                       REGISTRY_DONTBACKUP,
                                                       global->DontBackup );


    //
    // read the machine guid
    //

    Status = SrReadGenericParameter( RegHandle,
                                     REGISTRY_MACHINE_GUID,
                                     &pValue );

    if (NT_SUCCESS(Status))
    {
        ASSERT(pValue != NULL);

        RtlZeroMemory( &global->MachineGuid[0], 
                       sizeof(global->MachineGuid) );
                           
        if ( pValue->Type == REG_SZ && 
             pValue->DataLength < sizeof(global->MachineGuid) )
        {
            RtlCopyMemory( &global->MachineGuid[0],
                           &pValue->Data[0],
                           pValue->DataLength );
        }

        SR_FREE_POOL(pValue, SR_REGISTRY_TAG);
        pValue = NULL;
    }

    Status = STATUS_SUCCESS;

    //
    // close the old handle
    //
    
    ZwClose(RegHandle);
    NULLPTR( RegHandle );

    //
    // check if we are in the middle of gui mode setup
    //

    (VOID)RtlInitUnicodeString(&SetupKeyName, UPGRADE_CHECK_SETUP_KEY_NAME);

    InitializeObjectAttributes( &ObjectAttributes,      // ObjectAttributes
                                &SetupKeyName,          // ObjectName
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,      // Attributes
                                NULL,                   // RootDirectory
                                NULL );                 // SecurityDescriptor

    Status = ZwOpenKey( &RegHandle, KEY_READ, &ObjectAttributes );
    if (Status == STATUS_SUCCESS && !global->Disabled)
    {

        global->Disabled = (BOOLEAN) SrReadLongParameter( RegHandle, 
                                                          UPGRADE_CHECK_SETUP_VALUE_NAME,
                                                          global->Disabled );

#if DBG
        if (global->Disabled)
        {
            SrTrace(INIT, ("sr!SrReadRegistry: disabled due to setup\n"));
        }
#endif

    }
    
    Status = STATUS_SUCCESS;

    SrTrace(INIT, ("SR!SrReadRegistry(%wZ)\n", pRegistry));
    SrTrace(INIT, ("\tDisabled = %d\n", global->Disabled));
    SrTrace(INIT, ("\tDontBackup = %d\n", global->DontBackup));
    SrTrace(INIT, ("\tDebugControl = %X\n", global->DebugControl));
    SrTrace(INIT, ("\tProcessNameOffset = %X\n", global->ProcNameOffset));
    SrTrace(INIT, ("\tMachineGuid = %ws\n", &global->MachineGuid[0]));

end:

    ASSERT(pValue == NULL);

    if (RegHandle != NULL)
    {
        ZwClose(RegHandle);
        RegHandle = NULL;
    }

    if (KeyName.Buffer != NULL)
    {
        SR_FREE_POOL(KeyName.Buffer, SR_REGISTRY_TAG);
        KeyName.Buffer = NULL;
    }

    //
    // no big deal if this fails... we default everything.
    //

    CHECK_STATUS(Status);
    return STATUS_SUCCESS;
    
}   // SrReadRegistry
 
/***************************************************************************++

Routine Description:

    Reads the file based config into global->FileConfig.

Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrReadConfigFile(
    )
{
    NTSTATUS            Status;
    HANDLE              FileHandle = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PUNICODE_STRING     pFileName = NULL;
    ULONG               CharCount;
    PSR_DEVICE_EXTENSION pSystemVolumeExtension = NULL;

    PAGED_CODE();

    ASSERT( IS_GLOBAL_LOCK_ACQUIRED() );

    //
    // allocate space for a filename
    //

    Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pFileName);
    if (!NT_SUCCESS( Status ))
        goto end;

    //
    // get the location of the system volume
    //

    Status = SrGetSystemVolume( pFileName,
                                &pSystemVolumeExtension,
                                SR_FILENAME_BUFFER_LENGTH );
    
    //
    //  This should only happen if there was some problem with SR attaching
    //  in the mount path.  This check was added to make SR more robust to
    //  busted filters above us.  If other filters cause us to get mounted,
    //  we won't have an extension to return here.  While those filters are
    //  broken, we don't want to AV.
    //
    
    if (pSystemVolumeExtension == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto end;
    }
                                    
    if (!NT_SUCCESS( Status ))
        goto end;

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pSystemVolumeExtension ) );

    //
    // now put the config file location in the string
    //

    CharCount = swprintf( &pFileName->Buffer[pFileName->Length/sizeof(WCHAR)],
                          RESTORE_CONFIG_LOCATION,
                          global->MachineGuid );

    pFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

    //
    // attempt to open the file
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                pFileName,
                                OBJ_KERNEL_HANDLE, 
                                NULL,
                                NULL );

    Status = SrIoCreateFile( &FileHandle,
                             FILE_GENERIC_READ,                  // DesiredAccess
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,                               // AllocationSize
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN,                      // OPEN_EXISTING
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             NULL,                               // EaBuffer
                             0,                                  // EaLength
                             0,
                             pSystemVolumeExtension->pTargetDevice );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND || 
        Status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        //
        // not there?  that's ok (firstrun)
        //

        RtlZeroMemory(&global->FileConfig, sizeof(global->FileConfig));
        
        global->FileConfig.Signature = SR_PERSISTENT_CONFIG_TAG;

        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // any other errors?
    //
    
    else if (!NT_SUCCESS( Status ))
        goto end;

    //
    // read the structure
    //

    Status = ZwReadFile( FileHandle,
                         NULL,      // Event
                         NULL,      // ApcRoutine OPTIONAL,
                         NULL,      // ApcContext OPTIONAL,
                         &IoStatusBlock,
                         &global->FileConfig,
                         sizeof(global->FileConfig),
                         NULL,      // ByteOffset
                         NULL );    // Key
    
    if (!NT_SUCCESS( Status ))
        goto end;

    if (IoStatusBlock.Information != sizeof(global->FileConfig))
    {
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto end;
    }

    if (global->FileConfig.Signature != SR_PERSISTENT_CONFIG_TAG)
    {
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        goto end;
    }


    //
    // close the file
    //
    
    ZwClose(FileHandle);
    FileHandle = NULL;

    //
    // now update our file number counters, use the stored next file number
    //

    global->LastFileNameNumber = global->FileConfig.FileNameNumber;

    //
    // update the saved file config by the increment to handle power
    // failures.  when the machine recoveres from a power failure, we will
    // use +1000 for the next temp file numbers to avoid any accidental 
    // overlap
    //
    
    global->FileConfig.FileNameNumber += SR_FILE_NUMBER_INCREMENT;

    //
    // now update our Seq number counters
    //

    global->LastSeqNumber = global->FileConfig.FileSeqNumber;

    //
    // update the saved file config by the increment to handle power
    // failures.  when the machine recoveres from a power failure, we will
    // use +1000 for the next temp file numbers to avoid any accidental 
    // overlap
    //
    
    global->FileConfig.FileSeqNumber += SR_SEQ_NUMBER_INCREMENT;

    //
    // temporarily write out this update
    //

    Status = SrWriteConfigFile();
    if (!NT_SUCCESS( Status ))
        goto end;


    SrTrace(INIT, ("SR!SrReadConfigFile()\n"));
    SrTrace(INIT, ("\tLastFileNameNumber = %d\n", 
            global->LastFileNameNumber ));
    SrTrace(INIT, ("\tFileConfig.FileNameNumber = %d\n", 
            global->FileConfig.FileNameNumber ));
    SrTrace(INIT, ("\tFileConfig.FileSeqNumber = %I64d\n", 
            global->FileConfig.FileSeqNumber ));
    SrTrace(INIT, ("\tFileConfig.CurrentRestoreNumber = %d\n", 
            global->FileConfig.CurrentRestoreNumber ));



end:

    if (FileHandle != NULL)
    {
        ZwClose(FileHandle);
        FileHandle = NULL;
    }

    if (pFileName != NULL)
    {
        SrFreeFileNameBuffer(pFileName);
        pFileName = NULL;
    }

    RETURN(Status);

}   // SrReadConfigFile


/***************************************************************************++

Routine Description:

    Writes the contents of global->FileConfig to the file based config.
 
Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrWriteConfigFile(
    )
{
    NTSTATUS            Status;
    HANDLE              FileHandle = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PUNICODE_STRING     pFileName = NULL;
    ULONG               CharCount;
    PUCHAR              pBuffer = NULL;
    PFILE_OBJECT        pFileObject = NULL;
    PDEVICE_OBJECT      pDeviceObject;
    PSR_DEVICE_EXTENSION pSystemVolumeExtension = NULL;
    
    FILE_END_OF_FILE_INFORMATION EndOfFileInformation;

    PAGED_CODE();

    ASSERT( IS_GLOBAL_LOCK_ACQUIRED() );


try {

    //
    // make sure we have a semi-good global structure
    //

    if (global->FileConfig.Signature != SR_PERSISTENT_CONFIG_TAG)
    {
        Status = STATUS_DEVICE_CONFIGURATION_ERROR;
        leave;
    }

    //
    // allocate space for a filename
    //
    

    Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pFileName);
    if (!NT_SUCCESS( Status ))
        leave;

    //
    // get the location of the system volume
    //

    Status = SrGetSystemVolume( pFileName,
                                &pSystemVolumeExtension,
                                SR_FILENAME_BUFFER_LENGTH );
                                    
    if (!NT_SUCCESS( Status ))
        leave;

    //
    // and now append on the _restore location and the filename
    //

    CharCount = swprintf( &pFileName->Buffer[pFileName->Length/sizeof(WCHAR)],
                          RESTORE_CONFIG_LOCATION,
                          global->MachineGuid );

    pFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

    //
    // attempt to open the file
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                pFileName,
                                OBJ_KERNEL_HANDLE, 
                                NULL,
                                NULL );

    if (pSystemVolumeExtension) {

        //
        //  Most of the time when this routine is called, we are attached
        //  to the system volume already, so just send all IO to the filters
        //  below us by using SrIoCreateFile to get the file handle.
        //

        ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pSystemVolumeExtension ) );
        
        Status = SrIoCreateFile( &FileHandle,
                                 FILE_GENERIC_WRITE,                 // DesiredAccess
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,                               // AllocationSize
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                 FILE_OPEN_IF,
                                 FILE_SYNCHRONOUS_IO_NONALERT
                                  | FILE_NO_INTERMEDIATE_BUFFERING,
                                 NULL,                               // EaBuffer
                                 0,                                  // EaLength
                                 0,
                                 pSystemVolumeExtension->pTargetDevice );
        
    } else {

        //
        //  When this is called from SrUnload, we have already detached
        //  our device from the filter stack, so just use the regular
        //  ZwCreateFile to open the config file.
        //
        
        Status = ZwCreateFile( &FileHandle,
                               FILE_GENERIC_WRITE,                 // DesiredAccess
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                               // AllocationSize
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                               FILE_OPEN_IF,
                               FILE_SYNCHRONOUS_IO_NONALERT
                                | FILE_NO_INTERMEDIATE_BUFFERING,
                               NULL,                               // EaBuffer
                               0 );                                // EaLength
    }

    //
    // it's possible for the path to have been deleted by the service
    // if we reported a volume error while processing.  during shutdown
    // we will not be able to write our config file, that's ok to ignore,
    // we are shutting down.
    //
    
    if (Status == STATUS_OBJECT_PATH_NOT_FOUND)
    {
        Status = STATUS_SUCCESS;
        leave;
    }
    else if (!NT_SUCCESS( Status ))
    {
        leave;
    }
    
    //
    // get the file object
    //
    
    Status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &pFileObject,
                                        NULL );

    if (!NT_SUCCESS( Status ))
        leave;

    //
    // now the device so that we have the sector size
    //
    
    pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));

    //
    // allocate a PAGE to use as a temp buffer for sector alignment.
    //

    pBuffer = SR_ALLOCATE_POOL( PagedPool, 
                                PAGE_SIZE, 
                                SR_PERSISTENT_CONFIG_TAG );
                                
    if (pBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        leave;
    }

    //
    // copy just our bytes
    //
    
    RtlCopyMemory(pBuffer, &global->FileConfig, sizeof(global->FileConfig));

    //
    // uncached reads and writes need to be sector aligned, plus the data 
    // being asked for needs to be sector padded.  since PAGE_SIZE is a power 
    // of 2, and sector sizes are powers of 2, then will always be aligned 
    // (ExAllocatePool page aligns all allocations over a page).
    //
    // we need to also make sure it is also sector padded.
    //

    ASSERT(pDeviceObject->SectorSize >= sizeof(global->FileConfig));
    ASSERT(pDeviceObject->SectorSize <= PAGE_SIZE);
    
    //
    // write the sector
    //

    Status = ZwWriteFile( FileHandle,
                          NULL,      // Event
                          NULL,      // ApcRoutine OPTIONAL,
                          NULL,      // ApcContext OPTIONAL,
                          &IoStatusBlock,
                          pBuffer,
                          pDeviceObject->SectorSize,
                          NULL,      // ByteOffset
                          NULL );    // Key

    if (!NT_SUCCESS( Status ))
        leave;

    //
    // truncate the file
    //

    EndOfFileInformation.EndOfFile.QuadPart = sizeof(global->FileConfig);

    Status = ZwSetInformationFile( FileHandle,
                                   &IoStatusBlock,
                                   &EndOfFileInformation,
                                   sizeof(EndOfFileInformation),
                                   FileEndOfFileInformation );
                
    if (!NT_SUCCESS( Status ))
        leave;


    SrTrace(INIT, ("SR!SrWriteConfigFile()\n"));
    SrTrace(INIT, ("\tLastFileNameNumber = %d\n", 
            global->LastFileNameNumber ));
    SrTrace(INIT, ("\tFileConfig.FileNameNumber = %d\n", 
            global->FileConfig.FileNameNumber ));
    SrTrace(INIT, ("\tFileConfig.FileSeqNumber = %I64d\n", 
            global->FileConfig.FileSeqNumber ));
    SrTrace(INIT, ("\tFileConfig.CurrentRestoreNumber = %d\n", 
            global->FileConfig.CurrentRestoreNumber ));


} finally {

    //
    // check for unhandled exceptions
    //

    Status = FinallyUnwind(SrWriteConfigFile, Status);
    
    if (pFileObject != NULL)
    {
        ObDereferenceObject(pFileObject);
        pFileObject = NULL;
    }

    if (FileHandle != NULL)
    {
        ZwClose(FileHandle);
        FileHandle = NULL;
    }

    if (pFileName != NULL)
    {
        SrFreeFileNameBuffer(pFileName);
        pFileName = NULL;
    }

    if (pBuffer != NULL)
    {
        SR_FREE_POOL(pBuffer, SR_PERSISTENT_CONFIG_TAG);
        pBuffer = NULL;
    }
    
}

    RETURN(Status);


}   // SrWriteConfigFile


/***************************************************************************++

Routine Description:

    Queue the necessary work off to a worker thread to
    reads in the blob info for file list exclusions.

    Note: If an error is returned, a volume error has already been
    generated.
 
Arguments:

Return Value:

    NTSTATUS - completion code.

--***************************************************************************/
NTSTATUS
SrReadBlobInfo(
    )
{
    NTSTATUS        Status;

    PAGED_CODE();

    if (_globals.HitErrorLoadingBlob)
    {
        Status = SR_STATUS_VOLUME_DISABLED;
    }
    else 
    {

        Status = SrPostSyncOperation( SrReadBlobInfoWorker,
                                      NULL );
    }

    return Status;
}   // SrReadBlobInfo

/***************************************************************************++

Routine Description:

    Does the work to read in the blob info for file list exclusions.

    This work is done in a worker thread to avoid stack overflow when loading
    this information.

    If there is some problem loading the blob, a volume error is generated on
    the system volume so that the service knows to shut down all the other
    volumes.
 
Arguments:

    pOpenContext -- All the necessary information to perform the work of
        loading the blob info structure.

Return Value:

    NTSTATUS - the status of this operation.

--***************************************************************************/
NTSTATUS
SrReadBlobInfoWorker( 
    IN PVOID pOpenContext
    )
{
    NTSTATUS        Status;
    PUNICODE_STRING pFileName = NULL;
    ULONG           CharCount;
    PSR_DEVICE_EXTENSION pSystemVolumeExtension = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( pOpenContext );

    //
    // allocate space for a filename
    //

    Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pFileName);
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // get the location of the system volume
    //

    Status = SrGetSystemVolume( pFileName, 
                                &pSystemVolumeExtension,
                                SR_FILENAME_BUFFER_LENGTH );
                                    
    //
    //  This should only happen if there was some problem with SR attaching
    //  in the mount path.  This check was added to make SR more robust to
    //  busted filters above us.  If other filters cause us to get mounted,
    //  we won't have an extension to return here.  While those filters are
    //  broken, we don't want to AV.
    //
    
    if (pSystemVolumeExtension == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto end;
    }
                                    
    if (!NT_SUCCESS(Status))
        goto end;

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pSystemVolumeExtension ) );
    
    //
    // load the file list config data
    //

    CharCount = swprintf( &pFileName->Buffer[pFileName->Length/sizeof(WCHAR)],
                          RESTORE_FILELIST_LOCATION,
                          global->MachineGuid );

    pFileName->Length += (USHORT)CharCount * sizeof(WCHAR);

    Status = SrLoadLookupBlob( pFileName,
                               pSystemVolumeExtension->pTargetDevice,
                               &global->BlobInfo ); 
    
    if (!NT_SUCCESS(Status))
    {
        NTSTATUS TempStatus;
        //
        //  We can't load the lookup blob, so set the global flag that we hit
        //  an error trying to load the blob so we don't keep trying then 
        //  generate a volume error on the system volume so that all the volumes
        //  will get frozen.
        //

        _globals.HitErrorLoadingBlob = TRUE;

        SrTrace( VERBOSE_ERRORS,
                 ( "sr!SrReadBlobInfoWorker: error loading blob%X!\n",
                   Status ));
        
        TempStatus = SrNotifyVolumeError( pSystemVolumeExtension, 
                                          pFileName, 
                                          Status, 
                                          SrEventVolumeError );

        CHECK_STATUS( TempStatus );
    }

end:

    if (pFileName != NULL)
    {
        SrFreeFileNameBuffer(pFileName);
        pFileName = NULL;
    }

    RETURN(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\srshell.h ===
/******************************************************************************

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:
    SRShell.h

Abstract:
    This file defines external constants and structures for SR UI and any
    related components.

Revision History:
    Seong Kook Khang (SKKhang)  01/30/2000
        created
    Seong Kook Khang (SKKhang)  06/22/2000
        Expanded for Whistler

******************************************************************************/

#ifndef _SRSHELL_H__INCLUDED_
#define _SRSHELL_H__INCLUDED_


/////////////////////////////////////////////////////////////////////////////
//
// Constants / Structures
//
/////////////////////////////////////////////////////////////////////////////

// Restore Drive Info Flags
#define RDIF_SYSTEM     0x00000001  // drive contains system
#define RDIF_FROZEN     0x00000002  // drive is frozen
#define RDIF_EXCLUDED   0x00000004  // drive is excluded
#define RDIF_OFFLINE    0x00000008  // drive is not connected


/////////////////////////////////////////////////////////////////////////////
//
// SR Restore Log
//
/////////////////////////////////////////////////////////////////////////////

#define RSTRLOG_SIGNATURE1  0x72747372      // "rstr"
#define RSTRLOG_SIGNATURE2  0x1A676F6C      // "log" + EOF
#define RSTRLOG_VER_MAJOR   3
#define RSTRLOG_VER_MINOR   0
#define RSTRLOG_VERSION     MAKELONG(RSTRLOG_VER_MINOR, RSTRLOG_VER_MAJOR)

// File headers of rstrlog.dat file.
//
struct SRstrLogHdrBase
{
    DWORD  dwSig1;      // Signature (part 1/2)
    DWORD  dwSig2;      // Signature (part 2/2)
    DWORD  dwVer;       // Version
};

#define RLHF_SILENT     0x00000001
#define RLHF_UNDO       0x00000002

struct SRstrLogHdrV3
{
    DWORD  dwFlags;     // Flags
    DWORD  dwRPNum;     // Chosen Restore Point ID
    DWORD  dwRPNew;     // Restore Point ID of the new "Restore" RP
    DWORD  dwDrives;    // Number of Drives
};

// Information about each drives follows SRstrLogHdrRPInfo:
// 1. DWORD flags
// 2. Dynamic sized string of drive letter or mount point.
// 3. Dynamic sized string of unique volume name (GUID).

struct SRstrLogHdrV3Ex
{
    DWORD  dwRPNew;     // Restore Point ID of the new "Restore" RP
    DWORD  dwCount;     // Number of supposed-to-be entries
                        //  used to validate if every entry is in the log file.
};

// Constants to indicate result of Restore for each restore entries.
//
enum     // Result Code for Log Entries
{
    RSTRRES_UNKNOWN  = 0,
    RSTRRES_FAIL,           // 1 - Failure. (THE ONLY CONDITION TO ABORT RESTORE!)
    RSTRRES_OK,             // 2 - Succeeded.
    //RSTRRES_WININIT,        // 3 - Locked target, sent to wininit.ini.
    RSTRRES_LOCKED,         // 3 - Locked target, use MoveFileEx.
    RSTRRES_DISKRO,         // 4 - Target disk is read-only.
    RSTRRES_EXISTS,         // 5 - Removed existing ghost file.
    RSTRRES_IGNORE,         // 6 - Ignored special files, e.g. wininit.ini.
    RSTRRES_NOTFOUND,       // 7 - Target file/dir not exists, ignored.
    RSTRRES_COLLISION,      // 8 - Folder name conflict, existing dir was renamed.
    RSTRRES_OPTIMIZED,      // 9 - Entry has been optimized, without any temp file.
    RSTRRES_LOCKED_ALT,     // 10 - Locked target, but could be renamed. Use MoveFileEx to delete renamed file.
    RSTRRES_SENTINEL
};

#define RSTRLOGID_COLLISION  0xFFFFFFFF
#define RSTRLOGID_ENDOFMAP   0xFFFFFFFE
#define RSTRLOGID_STARTUNDO  0xFFFFFFFD
#define RSTRLOGID_ENDOFUNDO  0xFFFFFFFC
#define RSTRLOGID_SNAPSHOTFAIL 0xFFFFFFFB

// Structure for restore entries stored in rstrlog.dat file.
//
// This structure will be followed by three entries of DWORD-aligned
//  strings: (1) source path (2) destination path (3) alternative path
//
struct SRstrEntryHdr
{
    DWORD  dwID;        // Entry ID (zero-based). 0xFFFFFFFF means a collision entry.
    DWORD  dwOpr;       // Operation type
    INT64  llSeq;       // Sequence Number
    //DWORD  dwFlags;     // Flags
    DWORD  dwRes;       // Result code
    DWORD  dwErr;       // WIN32 error code
};


/////////////////////////////////////////////////////////////////////////////
//
// SRRSTR.DLL (rstrcore)
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// IRestoreContext

struct IRestoreContext
{
    virtual BOOL  IsAnyDriveOfflineOrDisabled( LPWSTR szOffline ) = 0;
    virtual void  SetSilent() = 0;
    virtual BOOL  Release() = 0;
    virtual void  SetUndo() = 0;
};

/////////////////////////////////////////////////////////////////////////////
// External APIs

extern "C"
{
BOOL APIENTRY  IsSRFrozen();
BOOL APIENTRY  CheckPrivilegesForRestore();
BOOL APIENTRY  InvokeDiskCleanup( LPCWSTR cszDrive );
BOOL APIENTRY  PrepareRestore( int nRP, IRestoreContext **ppCtx );
BOOL APIENTRY  InitiateRestore( IRestoreContext *pCtx, DWORD *pdwNewRP );
BOOL APIENTRY  ResumeRestore();

typedef BOOL (APIENTRY * PREPFUNC) ( int nRP, IRestoreContext **ppCtx );
typedef BOOL (APIENTRY * INITFUNC) ( IRestoreContext *pCtx, DWORD *pdwNewRP );
}


#endif //_SRSHELL_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\utils.h ===
/******************************************************************************
 *
 *  Copyright (c) 2000 Microsoft Corporation
 *
 *  Module Name:
 *    utils.h
 *
 *  Abstract:
 *    Declarations for commonly used util functions.
 *
 *  Revision History:
 *    Brijesh Krishnaswami (brijeshk)  03/17/2000
 *        created
 *
 *****************************************************************************/

#ifndef _UTILS_H_
#define _UTILS_H_

// trace macros

#define TENTER TraceFunctEnter
#define TLEAVE TraceFunctLeave
#define TRACE  DebugTrace

#define tenter TraceFunctEnter
#define tleave TraceFunctLeave
#define trace  DebugTrace


// lock macros

#define LOCKORLEAVE(a)     if (! (a = m_DSLock.Lock(CLock::TIMEOUT))) { dwRc = ERROR_TIMEOUT; goto done; }
#define LOCKORLEAVE_EX(a, t)   if (! (a = m_DSLock.Lock(t))) { dwRc = ERROR_TIMEOUT; goto done; }
#define UNLOCK(a)           if (a) { m_DSLock.Unlock(); a = FALSE; }


#define CHECKERR(f, trace) dwErr = (f); if (dwErr != ERROR_SUCCESS) 	\
							   {							\
							   		TRACE(0, "! %s : %ld", trace, dwErr);	\
							   		goto Err;						\
							   }		


// mem macros

#define SRMemAlloc(a) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, a)
#define SRMemFree(a) if (a) HeapFree(GetProcessHeap(), 0, a)

// unicode-ansi conversion routines
WCHAR * ConvertToUnicode(CHAR * pszString);
CHAR *  ConvertToANSI(WCHAR * pszwString);

#define UnicodeStringToWchar(US, pwsz) CopyMemory(pwsz, US.Buffer, US.Length); \
                                        pwsz[US.Length/sizeof(WCHAR)]=L'\0'

// directory traversal routines

DWORD GetFileSize_Recurse (const WCHAR *pwszDir,
                           INT64 *pllTotalBytes,
                           BOOL *pfStop);

DWORD CompressFile (const WCHAR *pwszPath, BOOL fCompress, BOOL fDirectory);

DWORD TakeOwn (const WCHAR *pwszFile);
DWORD Delnode_Recurse (const WCHAR *pwszDir, BOOL fDeleteRoot, BOOL *pfStop);

DWORD CopyFile_Recurse (const WCHAR *pwszSource, const WCHAR *pwszDest);

// returns system drive as "C:\" (if system drive is C) or as volume name

#define MAX_SYS_DRIVE 10
BOOL GetSystemDrive(LPWSTR pszDrive);

// returns TRUE if pszDrive contains the string L"C:" (if system drive is C)
BOOL IsSystemDrive(LPWSTR pszDrive);

// restore point routines
LPWSTR GetMachineGuid();
LPWSTR MakeRestorePath(LPWSTR pszDest, LPCWSTR pszDrive, LPCWSTR pszSuffix);
ULONG  GetID(LPCWSTR pszStr);

// registry routines
DWORD RegReadDWORD(HKEY hKey, LPCWSTR pszName, PDWORD pdwValue);
DWORD RegWriteDWORD(HKEY hKey, LPCWSTR pszName, PDWORD pdwValue);


// set/get start type of specified service
DWORD SetServiceStartup(LPCWSTR pszName, DWORD dwStartType);
DWORD GetServiceStartup(LPCWSTR pszName, PDWORD pdwStartType);
DWORD GetServiceStartupRegistry(LPCWSTR pszName, PDWORD pdwStartType);

BOOL  StopSRService(BOOL fWait);

// get the current domain or workgroup name
DWORD GetDomainMembershipInfo (WCHAR *pwszPath, WCHAR *pwszzBuffer);

// get the LSA secrets for restore
DWORD GetLsaRestoreState (HKEY hKeySoftware);
DWORD SetLsaSecret (PVOID hPolicy, const WCHAR *wszSecret,
                    WCHAR * wszSecretValue);

BOOL DoesDirExist(const TCHAR * pszFileName );

BOOL DoesFileExist(const TCHAR * pszFileName);

// this function creates all sub directories under the specified file
// name. 
BOOL CreateBaseDirectory(const WCHAR * pszFileName);

DWORD SRLoadString(LPCWSTR pszModule, DWORD dwStringId, LPWSTR pszString, DWORD cbBytes);
     
// sets acl allowing specific access to LocalSystem/Admin 
// and to everyone

DWORD
SetAclInObject(HANDLE hObject,
               DWORD  dwObjectType,
               DWORD  dwSystemMask,
               DWORD  dwEveryoneMask,
               BOOL   fInherit);

// sets acl to a named object allowing specific access to
// LocalSystem/Admin and to everyone
DWORD
SetAclInNamedObject(WCHAR * pszDirName, DWORD dwObjectType,
                    DWORD dwSystemMask, DWORD dwEveryoneMask,
                    DWORD dwSystemInherit, DWORD dwEveryOneInherit);

// sets the right ACL on the root of the DS on a drive
DWORD SetCorrectACLOnDSRoot(WCHAR * wcsPath);

// returns if Everyone has write access to the directory
BOOL IsDirectoryWorldAccessible(WCHAR * pszObjectName);

// returns if the file is owned by the administrators group or system
BOOL IsFileOwnedByAdminOrSystem(WCHAR * pszObjectName);

void
PostTestMessage(UINT msg, WPARAM wp, LPARAM lp);

// inline mem alloc class
class CSRAlloc
{
public:

    inline void *operator new(size_t size)
    {
        return SRMemAlloc (size);
    }

    inline void operator delete (void * pv)
    {
        SRMemFree (pv);
    }
};


//////////////////////////////////////////////////////////////////////
// CLock - class that allows exclusive access to a resource
//         uses a mutex - does not differentiate between readers/writers

class CLock
{
    HANDLE hResource;
    
    public:        
        BOOL   fHaveLock;    
        
        CLock();
        ~CLock();
        
        DWORD Init();
        BOOL  Lock(int iTimeOut);
        void  Unlock();        
        
        static const enum {TIMEOUT = 10*60000};
};


// 
// util function that checks the SR Stop event
// to see if it has been signalled or not
// will return TRUE if the event does not exist
//

BOOL IsStopSignalled(HANDLE hEvent);


// The following function logs the name of a file in the DS. The
// problem right now is that the path of the DS is so long that the
// relevant information is thrown away from the trace buffer.
void LogDSFileTrace(DWORD dwTraceID,
                    const WCHAR * pszPrefix, // Initial message to be traced 
                    const WCHAR * pszDSFile);

typedef DWORD (* PPROCESSFILEMETHOD) (WCHAR * pszBaseDir,// Base Directory
                                      const WCHAR * pszFile);
                                      // File to process


DWORD DeleteGivenFile(WCHAR * pszBaseDir, // Base Directory
                      const WCHAR * pszFile); // file to delete


DWORD ProcessGivenFiles(WCHAR * pszBaseDir,
                        PPROCESSFILEMETHOD    pfnMethod,
                        WCHAR  * pszFindFileData);

//++-----------------------------------------------------------------------
//
//   Function: WriteRegKey
//
//   Synopsis: This function writes into a registry key. It also creates it
//             if it does not exist.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//              FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL WriteRegKey(BYTE  * pbRegValue,
                 DWORD  dwNumBytes,
                 const TCHAR  * pszRegKey,
                 const TCHAR  * pszRegValueName,
                 DWORD  dwRegType);


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//  
//   Synopsis: This function reads a registry key and creates it
//   if it does not exist with the default value.
//  
//   Arguments: 
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------
BOOL ReadRegKeyOrCreate(BYTE * pbRegValue, // The value of the reg key will be
                         // stored here
                        DWORD * pdwNumBytes, // Pointer to DWORD conataining
                         // the number of bytes in the above buffer - will be
                         // set to actual bytes stored.
                        const TCHAR  * pszRegKey, // Reg Key to be opened
                        const TCHAR  * pszRegValueName, // Reg Value to query
                        DWORD  dwRegTypeExpected, 
                        BYTE  * pbDefaultValue, // default value
                        DWORD   dwDefaultValueSize); // size of default value


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//  
//   Synopsis: This function reads a registry key.
//  
//   Arguments: 
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
                DWORD * pdwNumBytes, // Pointer to DWORD conataining
                 // the number of bytes in the above buffer - will be
                 // set to actual bytes stored.
                const TCHAR  * pszRegKey, // Reg Key to be opened
                const TCHAR  * pszRegValueName, // Reg Value to query
                DWORD  dwRegTypeExpected); // Expected type of Value
     


// this function checks to see of the restore failed because of disk space
BOOL CheckForDiskSpaceError();

// this function sets the error hit by restore in the registry
BOOL SetRestoreError(DWORD dwRestoreError);

// this function sets the status whether restore was done in safe mode
BOOL SetRestoreSafeModeStatus(DWORD dwSafeModeStatus);
// this function checks to see if the last restore was done in safe mode
BOOL WasLastRestoreInSafeMode();

LPCWSTR  GetSysErrStr();
LPCWSTR  GetSysErrStr( DWORD dwErr );

DWORD SRCopyFile( LPCWSTR cszSrc, LPCWSTR cszDst );
DWORD SRCreateSubdirectory ( LPCWSTR cszDst, LPSECURITY_ATTRIBUTES pSecAttr);

// this function returns whether the SR service is running
BOOL IsSRServiceRunning();

LPWSTR  SRGetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPDWORD pdwData );
BOOL    SRSetRegMultiSz( HKEY hkRoot, LPCWSTR cszSubKey, LPCWSTR cszValue, LPCWSTR cszData, DWORD cbData );

// this returns the name after the volume name
// For example input: c:\file output: file
//             input \\?\Volume{GUID}\file1  output: file1
WCHAR * ReturnPastVolumeName(const WCHAR * pszFileName);

//This API sets the ShortFileName for a given file
DWORD SetShortFileName(const WCHAR * pszFile, // complete file path
                       const WCHAR * pszShortName); // desired short file name


void SRLogEvent (HANDLE hEventSource,
                 WORD wType,
                 DWORD dwID,
                 void * pRawData,
                 DWORD dwDataSize,
                 const WCHAR * pszS1,
                 const WCHAR * pszS2,
                 const WCHAR * pszS3);

BOOL IsAdminOrSystem();
BOOL IsPowerUsers();

void ChangeCCS(HKEY hkMount, LPWSTR pszString);

void RemoveTrailingFilename(WCHAR * pszString, WCHAR wchSlash);


class CSRClientLoader
{
public:
    CSRClientLoader();
    ~CSRClientLoader();
    
    BOOL LoadSrClient();
    HMODULE      m_hSRClient;
    
private:

    HMODULE      m_hFrameDyn;


    BOOL LoadFrameDyn();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\context.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    context.h

Abstract:

    This module contains the context handling routines

Author:

    Neal Christiansen (nealch)     08-Jan-2001

Revision History:

--*/

#ifndef _CONTEXT_H_
#define _CONTEXT_H_

VOID
SrInitContextCtrl (
    IN PSR_DEVICE_EXTENSION pExtension
    );

VOID
SrCleanupContextCtrl(
    IN PSR_DEVICE_EXTENSION pExtension
    );

VOID
SrDeleteAllContexts(
    IN PSR_DEVICE_EXTENSION pExtension
    );

VOID
SrDeleteContext(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext
    );

VOID
SrLinkContext( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN OUT PSR_STREAM_CONTEXT *ppFileContext
    );

NTSTATUS
SrCreateContext (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN SR_EVENT_TYPE EventType,
    IN USHORT FileAttributes,
    OUT PSR_STREAM_CONTEXT *pRetContext
    );

#define SrFreeContext( pCtx ) \
    (ASSERT((pCtx)->UseCount == 0), \
     ExFreePool( (pCtx) ))

NTSTATUS
SrGetContext(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN SR_EVENT_TYPE EventType,
    OUT PSR_STREAM_CONTEXT *pRetContext
    );

PSR_STREAM_CONTEXT
SrFindExistingContext(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject
    );

VOID
SrMakeContextUninteresting (
    IN PSR_STREAM_CONTEXT pFileContext
    );

VOID
SrReleaseContext(
    IN PSR_STREAM_CONTEXT pFileContext
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\inc\xmlparser.h ===
//++
//
// Copyright (c) 1999 Microsoft Corporation
//
// Module Name:
//     CXMLParser.h
//
// Abstract: ( references CXMLParser.cpp )
//     This file contains the functions used by Filelist in order to real the
//     XML encoded list of files/directories. It also performs translations
//     between symbols like %windir% to C:\windows
//
// Revision History:
//     Eugene Mesgar        (eugenem)    6/16/99
//       created
//     Kanwaljit Marok      (kmarok)     6/06/00
//       ported
//
//--

#ifndef _XMLFILELISTPARSER_H
#define _XMLFILELISTPARSER_H

#ifndef MAX_BUFFER
#define MAX_BUFFER          1500
#endif

#define MAX_REPLACE_ENTRIES 50


#define NUM_FILE_TYPES      3

#define INCLUDE_COLL        0
#define EXCLUDE_COLL        1
#define SNAPSHOT_COLL       2

#include <xmlparser.h>

//
//  Public File type
// 

#define INCLUDE_TYPE        _TEXT('i')
#define EXCLUDE_TYPE        _TEXT('e')
#define SNAPSHOT_TYPE       _TEXT('s')

class CXMLFileListParser
{
    //
    //  # of times we've initialized the com space
    //

    LONG    m_clComInitialized;

    //
    // references the currently open document
    //
    IXMLDocument           *m_pDoc;
 
    //
    // references the named sub collection
    //

    IXMLElementCollection *m_pDir[NUM_FILE_TYPES];
    IXMLElementCollection *m_pFiles[NUM_FILE_TYPES]; 
    IXMLElementCollection *m_pExt[NUM_FILE_TYPES];

    //
    // version
    //

    DWORD m_adwVersion[4];
    
    //
    // default node type
    //

    TCHAR m_chDefaultType;

public:

    BOOL Init(LPCTSTR pszFile);
    BOOL Init();

    //
    // return symbol translated versions
    // pchType values == 'S', 'I', 'E' (snapshot,include,exclude)
    //

    LONG GetDirectory(LONG ilElement, 
                      LPTSTR pszBuf, 
                      LONG lBufMax, 
                      TCHAR chType);

    LONG GetDirectory(LONG ilElement, 
                      LPTSTR pszBuf, 
                      LONG lBufMax, 
                      TCHAR chType, 
                      BOOL *pfDisable);

    LONG GetExt (LONG ilElement, LPTSTR pszBuf, LONG lBufMax, TCHAR chType);
    LONG GetFile(LONG ilElement, LPTSTR pszBuf, LONG lBufMax, TCHAR chType);

    //
    // file list version info ( pointer to 4 dword array );
    //

    BOOL GetVersion(LPDWORD pdwVersion);

    //
    // get the default type
    //

    TCHAR GetDefaultType();

    //
    // return the number of elements in the sets
    //

    LONG GetDirectoryCount(TCHAR chType);
    LONG GetExtCount(TCHAR chType);
    LONG GetFileCount(TCHAR chType);
    
    //
    // Debug function to print current file translations supported.
    //
 
    void DebugPrintTranslations();

    CXMLFileListParser();                       

    virtual ~CXMLFileListParser();          
 
private:

    //
    // load & unloading the symbolic location->true location mappings
    // there is just dummy code in here which hard codes some generic mapping.
    //

    BOOL PopulateReplaceEntries();
    BOOL DepopulateReplaceEntries();

    //
    // inplace search and function which search&replaces on the 
    // symbol->location mappings
    //

    LONG SearchAndReplace(LPTSTR szBuf, LONG lMaxBuf);

    //
    // the true guts of the GetExt/File/Directory functions
    //

    LONG GetFileInfo(IXMLElementCollection *pCol, 
                     LONG ilElement, 
                     LPTSTR pszBuf, 
                     LONG lBufMax, 
                     BOOL *pfDisable);

    BOOL LoadOneCollection(IXMLElement *pColHead, 
                           IXMLElementCollection **pCol );

    LONG GetCollectionSize(IXMLElementCollection *pCol);

    //
    // init broken down
    //

    BOOL ParseFile(LPCTSTR pszFile);
    BOOL LoadCollections();
    BOOL ParseVersion(IXMLElement *pVerElement);

    //
    // helper functions
    //

    LONG ConvertAndFreeBSTR(BSTR bstrIn, LPTSTR szpOut, LONG lMaxBuf);
    LONG TranslateType(TCHAR chType);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\context.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains the context handling routines

Author:

    Neal Christiansen (nealch)     27-Dec-2000

Revision History:

--*/

#include "precomp.h"

//
//  Local prototypes
//

VOID
SrpDeleteContextCallback(
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrInitContextCtrl )
#pragma alloc_text( PAGE, SrCleanupContextCtrl )
#pragma alloc_text( PAGE, SrDeleteAllContexts )
#pragma alloc_text( PAGE, SrDeleteContext )
#pragma alloc_text( PAGE, SrpDeleteContextCallback )
#pragma alloc_text( PAGE, SrLinkContext )
#pragma alloc_text( PAGE, SrCreateContext )
#pragma alloc_text( PAGE, SrGetContext )
#pragma alloc_text( PAGE, SrFindExistingContext )
#pragma alloc_text( PAGE, SrReleaseContext )

#endif  // ALLOC_PRAGMA


///////////////////////////////////////////////////////////////////////////
//
//                      Context support routines
//
///////////////////////////////////////////////////////////////////////////

/***************************************************************************++

Routine Description:

    This initializes the context control information for a given volume

Arguments:

    pExtension - Contains context to init

Return Value:

    None

--***************************************************************************/
VOID
SrInitContextCtrl (
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    PAGED_CODE();

    InitializeListHead( &pExtension->ContextCtrl.List );
    ExInitializeResourceLite( &pExtension->ContextCtrl.Lock );
}


/***************************************************************************++

Routine Description:

    This cleans up the context control information for a given volume

Arguments:

    pExtension - Contains context to cleanup

Return Value:

    None

--***************************************************************************/
VOID
SrCleanupContextCtrl (
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    PAGED_CODE();

    //
    //  Remove all contexts they may still exist
    //

    SrDeleteAllContexts( pExtension );
    ExDeleteResourceLite( &pExtension->ContextCtrl.Lock );
}


/***************************************************************************++

Routine Description:

    This will free all existing contexts for the given device extension.
    We don't worry about holding the mutex lock for a long time because
    nobody else should be using this extension anyway.

Arguments:

    pExtension - Contains contexts to cleanup

Return Value:

    None

--***************************************************************************/
VOID
SrDeleteAllContexts (
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    PLIST_ENTRY link;
    PSR_STREAM_CONTEXT pFileContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    LIST_ENTRY localHead;
#if DBG
    ULONG deleteNowCount = 0;
    ULONG deleteDeferredCount = 0;
    ULONG deleteInCallbackCount = 0;
#endif


    PAGED_CODE();
    INC_STATS(TotalContextDeleteAlls);

    InitializeListHead( &localHead );

    try
    {
        //
        //  Acquire list lock
        //

        SrAcquireContextLockExclusive( pExtension );

        //
        //  Walk the list of contexts and release each one
        //

        while (!IsListEmpty( &pExtension->ContextCtrl.List ))
        {
            //
            //  Unlink from top of list
            //

            link = RemoveHeadList( &pExtension->ContextCtrl.List );
            pFileContext = CONTAINING_RECORD( link, SR_STREAM_CONTEXT, ExtensionLink );

            //
            //  Mark that we are unlinked from the list.  We need to do this
            //  because of the race condition between this routine and the
            //  deleteCallback from the FS.
            //

            ASSERT(FlagOn(pFileContext->Flags,CTXFL_InExtensionList));
            RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InExtensionList);

            //
            //  Try and remove ourselves from the File Systems context control
            //  structure.  Note that the file system could be trying to tear
            //  down their context control right now.  If they are then we 
            //  will get a NULL back from this call.  This is OK because it
            //  just means that they are going to free the memory, not us.
            //  NOTE:  This will be safe becase we are holding the ContextLock
            //         exclusivly.  If this were happening then they would be
            //         blocked in the callback routine on this lock which
            //         means the file system has not freed the memory for
            //         this yet.
            //  
            
            if (FlagOn(pFileContext->Flags,CTXFL_InStreamList))
            {
                ctxCtrl = FsRtlRemovePerStreamContext( pFileContext->ContextCtrl.InstanceId,
                                                    pExtension,
                                                    pFileContext->ContextCtrl.InstanceId );

                //
                //  Always clear the flag wether we found it in the list or
                //  not.  We can have the flag set and not be in the list if
                //  after we acquired the context list lock we context swapped
                //  and the file system is right now in SrpDeleteContextCallback
                //  waiting on the list lock.
                //

                RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InStreamList);

                //
                //  Handle wether we were still attached to the file or not.
                //

                if (NULL != ctxCtrl)
                {
                    ASSERT(pFileContext == CONTAINING_RECORD(ctxCtrl,SR_STREAM_CONTEXT,ContextCtrl));

                    //
                    //  To save time we don't do the free now (with the lock
                    //  held).  We link into a local list and then free it
                    //  later (in this routine).  We can do this because it
                    //  is no longer on any list.
                    //

                    InsertHeadList( &localHead, &pFileContext->ExtensionLink );
                }
                else
                {
                    //
                    //  The context is in the process of being freed by the file
                    //  system.  Don't do anything with it here, it will be
                    //  freed in the callback.
                    //

                    INC_STATS(TotalContextsNotFoundInStreamList);
                    INC_LOCAL_STATS(deleteInCallbackCount);
                }
            }
        }
    }
    finally
    {
        SrReleaseContextLock( pExtension );
    }

    //
    //  We have removed everything from the list and release the list lock.
    //  Go through and figure out what entries we can free and then do it.
    //

    SrTrace(CONTEXT_LOG, ("Sr!SrDeleteAllContexts:   Starting (%p)\n",
                                    &localHead ));

    while (!IsListEmpty( &localHead ))
    {
        //
        //  Get next entry of the list and get our context back
        //

        link = RemoveHeadList( &localHead );
        pFileContext = CONTAINING_RECORD( link, SR_STREAM_CONTEXT, ExtensionLink );

        //
        //  Decrement the USE count and see if we can free it now
        //

        ASSERT(pFileContext->UseCount > 0);

        if (InterlockedDecrement( &pFileContext->UseCount ) <= 0)
        {
            //
            //  No one is using it, free it now
            //

            SrFreeContext( pFileContext );

            INC_STATS(TotalContextNonDeferredFrees);
            INC_LOCAL_STATS(deleteNowCount);
        }
        else
        {
            //
            //  Someone still has a pointer to it, it will get deleted
            //  later when they release
            //

            INC_LOCAL_STATS(deleteDeferredCount);
            SrTrace( CONTEXT_LOG, ("Sr!SrDeleteAllContexts:  DEFERRED    (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                                   pFileContext,
                                   pFileContext->Flags,
                                   pFileContext->UseCount,
                                   (pFileContext->FileName.Length+
                                        pFileContext->StreamNameLength)/
                                        sizeof(WCHAR),
                                   pFileContext->FileName.Buffer));
        }
    }

    SrTrace(CONTEXT_LOG, ("Sr!SrDeleteAllContexts:   For \"%wZ\" %d deleted now, %d deferred, %d close contention\n",
                          pExtension->pNtVolumeName,
                          deleteNowCount,
                          deleteDeferredCount,
                          deleteInCallbackCount ));
}


/***************************************************************************++

Routine Description:

    This will unlink and release the given context.

Arguments:

Return Value:

    None

--***************************************************************************/
VOID
SrDeleteContext (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    BOOLEAN releaseLock = FALSE;

    PAGED_CODE();

    SrTrace( CONTEXT_LOG, ("Sr!SrDeleteContext:                   (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                           pFileContext,
                           pFileContext->Flags,
                           pFileContext->UseCount,
                           (pFileContext->FileName.Length+
                                pFileContext->StreamNameLength)/
                                sizeof(WCHAR),
                           pFileContext->FileName.Buffer));

    try {

        //
        //  Acquire list lock
        //

        SrAcquireContextLockExclusive( pExtension );
        releaseLock = TRUE;

        //
        //  Remove from extension list (if still in it)
        //

        if (FlagOn(pFileContext->Flags,CTXFL_InExtensionList))
        {
            RemoveEntryList( &pFileContext->ExtensionLink );
            RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InExtensionList);
        }

        //
        //  See if still in stream list.
        //

        if (!FlagOn(pFileContext->Flags,CTXFL_InStreamList))
        {
            //
            //  Not in stream list, release lock and return
            //

            leave;
        }
        else
        {
            //
            //  Remove from Stream list
            //

            ctxCtrl = FsRtlRemovePerStreamContext( pFileContext->ContextCtrl.InstanceId,
                                                pExtension,
                                                pFileContext->ContextCtrl.InstanceId );
            //
            //  Always clear the flag wether we found it in the list or not.  We
            //  can have the flag set and not be in the list if after we acquired
            //  the context list lock we context swapped and the file system 
            //  is right now in SrpDeleteContextCallback waiting on the list lock.
            //

            RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InStreamList);

            //
            //
            //
            //  Release list lock
            //

            SrReleaseContextLock( pExtension );
            releaseLock = FALSE;

            //
            //  The context is now deleted from all of the lists and the lock is
            //  removed.  We need to see if we found this entry on the systems context
            //  list.  If not that means the callback was in the middle of trying
            //  to free this (while we were) and has already deleted it.
            //  If we found a structure then delete it now ourselves.
            //

            if (NULL != ctxCtrl)
            {
                ASSERT(pFileContext == CONTAINING_RECORD(ctxCtrl,SR_STREAM_CONTEXT,ContextCtrl));

                //
                //  Decrement USE count, free context if zero
                //

                ASSERT(pFileContext->UseCount > 0);

                if (InterlockedDecrement( &pFileContext->UseCount ) <= 0)
                {
                    INC_STATS(TotalContextNonDeferredFrees);
                    SrFreeContext( pFileContext );
                }
                else
                {
                    SrTrace( CONTEXT_LOG, ("Sr!SrDeleteContext:       DEFERRED    (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                                           pFileContext,
                                           pFileContext->Flags,
                                           pFileContext->UseCount,
                                           (pFileContext->FileName.Length+
                                                pFileContext->StreamNameLength)/
                                                sizeof(WCHAR),
                                           pFileContext->FileName.Buffer));
                }
            }
            else
            {
                INC_STATS(TotalContextsNotFoundInStreamList);
            }
        }
    }finally {

        if (releaseLock)
        {
            SrReleaseContextLock( pExtension );
        }
    }
}


/***************************************************************************++

Routine Description:

    This is called by base file systems when a context needs to be deleted.

Arguments:

Return Value:

--***************************************************************************/
VOID
SrpDeleteContextCallback (
    IN PVOID Context
    )
{
    PSR_STREAM_CONTEXT pFileContext = Context;
    PSR_DEVICE_EXTENSION pExtension;
    
    PAGED_CODE();

    pExtension = (PSR_DEVICE_EXTENSION)pFileContext->ContextCtrl.OwnerId;
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(pFileContext->ContextCtrl.OwnerId == pExtension);

    SrTrace( CONTEXT_LOG, ("Sr!SrpDeleteContextCB:                (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                           pFileContext,
                           pFileContext->Flags,
                           pFileContext->UseCount,
                           (pFileContext->FileName.Length+
                                pFileContext->StreamNameLength)/
                                sizeof(WCHAR),
                           pFileContext->FileName.Buffer));

    //
    //  When we get here we have already been removed from the stream list,
    //  flag that this has happened.  
    //

    RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InStreamList);

    //
    //  Lock the context list lock in the extension
    //

    SrAcquireContextLockExclusive( pExtension );

    //
    //  See if we are still linked into the extension list.  If not then skip
    //  the unlinking.  This can happen if someone is trying to delete this
    //  context at the same time as we are.
    //

    if (FlagOn(pFileContext->Flags,CTXFL_InExtensionList))
    {
        RemoveEntryList( &pFileContext->ExtensionLink );
        RtlInterlockedClearBitsDiscardReturn(&pFileContext->Flags,CTXFL_InExtensionList);
    }

    SrReleaseContextLock( pExtension );

    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pFileContext->UseCount > 0);

    if (InterlockedDecrement( &pFileContext->UseCount ) <= 0)
    {
        INC_STATS(TotalContextCtxCallbackFrees);
        SrFreeContext( pFileContext );
    }
    else
    {
        SrTrace( CONTEXT_LOG, ("Sr!SrpDeleteContextCB:    DEFFERED    (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));
    }
}


/***************************************************************************++

Routine Description:

    This will link the given context into the context hash table for the
    given volume.  
    NOTE:   It is possible for this entry to already exist in the table (since
            between the time we initially looked and the time we inserted
            (which is now) someone else may have inserted one.  If we find an
            entry that already exists we will free the entry passed in and
            return the entry found.  

Arguments:

Return Value:

--***************************************************************************/
VOID
SrLinkContext ( 
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN OUT PSR_STREAM_CONTEXT *ppFileContext
    )
{
    NTSTATUS status;
    PSR_STREAM_CONTEXT pFileContext = *ppFileContext;
    PSR_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    
    PAGED_CODE();
    ASSERT(pFileObject->FsContext != NULL);
    ASSERT(pFileContext != NULL);

    //
    //  If this is flagged as a temporary context then don't link it in
    //  and return now
    //

    if (FlagOn(pFileContext->Flags,CTXFL_Temporary))
    {
        INC_STATS(TotalContextTemporary);

        SrTrace( CONTEXT_LOG, ("Sr!SrpLinkContext:              Tmp:  (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));
        return;
    }

    //
    //  See if this should be a temporary context
    //

    if (pExtension->ContextCtrl.AllContextsTemporary != 0)
    {
        //
        //  yes, don't link into list, mark as temporary
        //

        SetFlag(pFileContext->Flags,CTXFL_Temporary);

        INC_STATS(TotalContextTemporary);

        SrTrace( CONTEXT_LOG, ("Sr!SrpLinkContext:           AllTmp:  (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));

        return;
    }

    //
    //  See if we need to query the link count.
    //

    if (FlagOn(pFileContext->Flags,CTXFL_QueryLinkCount))
    {
        FILE_STANDARD_INFORMATION standardInformation;

        ClearFlag(pFileContext->Flags,CTXFL_QueryLinkCount);
        
        //
        //  Retrieve the information to determine if this is a directory or not
        //

        status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pFileObject,
                                         &standardInformation,
                                         sizeof( standardInformation ),
                                         FileStandardInformation,
                                         NULL );

        if (!NT_SUCCESS( status ))
        {
            //
            //  If we hit some error querying this link count here, just
            //  assume that we need to make this context temporary and don't
            //  link it into the lists since that is the conservative 
            //  assumption.
            //

            SetFlag(pFileContext->Flags,CTXFL_Temporary);
            return;
        }

        pFileContext->LinkCount = standardInformation.NumberOfLinks;
        
        if (standardInformation.NumberOfLinks > 1)
        {
            //
            //  This file has more than one link to it, therefore to avoid
            //  aliasing problems, mark this context temporary.
            //

            SetFlag(pFileContext->Flags,CTXFL_Temporary);
            return;
        }

        //
        //  This file does not have more than 1 link on it, so we can go ahead
        //  and try to put this context into the list for others to use.
        //
    }
    
    //
    //  We need to figure out if a duplicate entry already exists on
    //  the context list for this file object.  Acquire our list lock
    //  and then see if it exists.  If not insert into all the lists.
    //  If so then simply free this new entry and return the duplicate.
    //
    //  This can happen for 2 reasons:
    //  - Someone created an entry at the exact same time as we were
    //    creating an entry.
    //  - When someone does a create with overwrite or supersede we
    //    do not have the information yet to see if a context already
    //    exists.  Because of this we have to create a new context
    //    everytime.  During post-create we then see if one already
    //    exists.
    //

    //
    //  Initalize the context control structure.  We do this now so we
    //  don't have to do it while the lock is held (even if we might
    //  have to free it because of a duplicate found)
    //

    FsRtlInitPerStreamContext( &pFileContext->ContextCtrl,
                               pExtension,
                               pFileObject->FsContext,
                               SrpDeleteContextCallback );

    //
    //  Acquire list lock exclusivly
    //

    SrAcquireContextLockExclusive( pExtension );

    ASSERT(pFileContext->UseCount == 1);
    ASSERT(!FlagOn(pFileContext->Flags,CTXFL_InExtensionList));

    //
    //  See if we have an entry already on the list
    //

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(pFileObject),
                                        pExtension,
                                        NULL );

    if (NULL != ctxCtrl)
    {
        //
        //  The context already exists so free the new one we just
        //  created.  First increment the use count on the one we found
        //

        ctx = CONTAINING_RECORD(ctxCtrl,SR_STREAM_CONTEXT,ContextCtrl);

        ASSERT(FlagOn(ctx->Flags,CTXFL_InExtensionList));
        ASSERT(!FlagOn(ctx->Flags,CTXFL_Temporary));
        ASSERT(ctx->UseCount > 0);

        //
        //  See if we should use the found context?
        //

        if (FlagOn(ctx->Flags,CTXFL_DoNotUse))
        {
            //
            //  The found context should not be used so use our current
            //  context and mark it as temporary. Free the lock.
            //

            INC_STATS(TotalContextTemporary);
            RtlInterlockedSetBitsDiscardReturn(&pFileContext->Flags,CTXFL_Temporary);

            SrReleaseContextLock( pExtension );

            SrTrace( CONTEXT_LOG, ("Sr!SrpLinkContext:           Tmp:     (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                                   pFileContext,
                                   pFileContext->Flags,
                                   pFileContext->UseCount,
                                   (pFileContext->FileName.Length+
                                        pFileContext->StreamNameLength)/
                                        sizeof(WCHAR),
                                   pFileContext->FileName.Buffer));
        }
        else
        {

            //
            //  Bump ref count and release lock
            //

            InterlockedIncrement( &ctx->UseCount );

            SrReleaseContextLock( pExtension );

            //
            //  Verify the found entry
            //

            ASSERT(RtlEqualUnicodeString( &pFileContext->FileName,
                                          &ctx->FileName,
                                          TRUE ));
            ASSERT(FlagOn(pFileContext->Flags,CTXFL_IsDirectory) == FlagOn(ctx->Flags,CTXFL_IsDirectory));
            ASSERT(FlagOn(pFileContext->Flags,CTXFL_IsInteresting) == FlagOn(ctx->Flags,CTXFL_IsInteresting));

            SrTrace( CONTEXT_LOG, ("Sr!SrpLinkContext:        Rel Dup:    (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                                   pFileContext,
                                   pFileContext->Flags,
                                   pFileContext->UseCount,
                                   (pFileContext->FileName.Length+
                                        pFileContext->StreamNameLength)/
                                        sizeof(WCHAR),
                                   pFileContext->FileName.Buffer));

            //
            //  Free the new structure because it was already resident.  Note
            //  that this entry has never been linked into any lists so we know
            //  no one else has a refrence to it.  Decrement use count to keep
            //  the ASSERTS happy then free the memory.
            //

            INC_STATS(TotalContextDuplicateFrees);

            pFileContext->UseCount--;
            SrFreeContext( pFileContext );

            //
            //  Return the one we found in the list
            //

            *ppFileContext = ctx;
        }    

        return;
    }

    ASSERT(!FlagOn(pFileContext->Flags,CTXFL_Temporary));

    //
    //  Increment the USE count
    //

    InterlockedIncrement( &pFileContext->UseCount );

    //
    //  Link into Stream context 
    //

    status = FsRtlInsertPerStreamContext( FsRtlGetPerStreamContextPointer(pFileObject),
                                       &pFileContext->ContextCtrl );
    ASSERT(status == STATUS_SUCCESS);

    //
    //  Link into Device extension
    //

    InsertHeadList( &pExtension->ContextCtrl.List, &pFileContext->ExtensionLink );

    //
    //  Mark that we have been inserted into both lists
    //

    RtlInterlockedSetBitsDiscardReturn( &pFileContext->Flags,
                                        CTXFL_InExtensionList|CTXFL_InStreamList );

    //
    //  Release lock
    //

    SrReleaseContextLock( pExtension );
}


/***************************************************************************++

Routine Description:

    This will allocate and initialize a context structure but it does NOT
    link it into the context hash list.
    

Arguments:

    pExtension - The SR device extension for this volume.
    pFileObject - The file object for the file on which we are creating a
        context.
    EventType - The event that is causing us to create this context.  This
        may also contain other flags that we will use to control our context
        creation process.
    FileAttributes - Will only be non-zero if the SrEventInPreCreate flag
        is set in the EventType field.
    pRetContext - Gets set to the context that is generated.

Return Value:

--***************************************************************************/
NTSTATUS
SrCreateContext (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN SR_EVENT_TYPE EventType,
    IN USHORT FileAttributes,
    OUT PSR_STREAM_CONTEXT *pRetContext
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    SRP_NAME_CONTROL nameControl;
    FILE_STANDARD_INFORMATION  standardInformation;
    PSR_STREAM_CONTEXT ctx;
    BOOLEAN isDirectory;
    ULONG linkCount = 0;
    BOOLEAN isInteresting;
    BOOLEAN reasonableErrorInPreCreate = FALSE;
    ULONG contextSize;
    USHORT fileAttributes;
    BOOLEAN isVolumeOpen = FALSE;

    PAGED_CODE();

    //
    //  initialize to NULL pointer
    //

    *pRetContext = NULL;

    //
    //  The nameControl structure is used for retrieving file names
    //  efficiently.  It contains a small buffer for holding names.  If this
    //  buffer is not big enough we will dynamically allocate a bigger buffer.
    //  The goal is to have most names fit in the buffer on the stack.
    //

    SrpInitNameControl( &nameControl );

    //
    //  See if they have explicitly told us if this is a directory or not.  If
    //  neither then query for the directory.
    //

    if (FlagOn(EventType,SrEventIsDirectory))
    {
        isDirectory = TRUE;

#if DBG
        //
        //  Verify this really is a directory
        //

        status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pFileObject,
                                         &standardInformation,
                                         sizeof( standardInformation ),
                                         FileStandardInformation,
                                         NULL );
        ASSERT(!NT_SUCCESS_NO_DBGBREAK(status) || standardInformation.Directory);
#endif
    }
    else if (FlagOn(EventType,SrEventIsNotDirectory))
    {
        isDirectory = FALSE;

#if DBG
        //
        //  Verify this really is NOT a directory.  We can not do this check
        //  if we are in pre-create.
        //

        if (!FlagOn( EventType, SrEventInPreCreate ))
        {
            status = SrQueryInformationFile( pExtension->pTargetDevice,
                                             pFileObject,
                                             &standardInformation,
                                             sizeof( standardInformation ),
                                             FileStandardInformation,
                                             NULL );
            ASSERT(!NT_SUCCESS_NO_DBGBREAK(status) || !standardInformation.Directory);
        }
        else
        {
            ASSERT(FlagOn(EventType,SrEventStreamOverwrite));
        }
#endif
    }
    else
    {
        ASSERT(pFileObject->FsContext != NULL);

        //
        //  Retrieve the information to determine if this is a directory or not
        //

        status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pFileObject,
                                         &standardInformation,
                                         sizeof( standardInformation ),
                                         FileStandardInformation,
                                         NULL );

        if (status == STATUS_INVALID_PARAMETER)
        {
            //
            //  pFileObject represents an open to the volume.  The file system
            //  won't let us query information on volume opens.
            //
            //  Any operations on this file object won't be of interest to us
            //  and there is no need for us to do any of our name generation
            //  work, so initialize the appropriate variables and jump down 
            //  to the context creation.
            //

            status = STATUS_SUCCESS;
            isInteresting = FALSE;
            isDirectory = FALSE;
            isVolumeOpen = TRUE;
            goto InitContext;
        }
        else if (!NT_SUCCESS( status ))
        {
            goto Cleanup;
        }

        //
        //  Flag if this is a directory or not
        //

        INC_STATS(TotalContextDirectoryQuerries);
        isDirectory = standardInformation.Directory;
        linkCount = standardInformation.NumberOfLinks;

        SrTrace( CONTEXT_LOG_DETAILED,
                 ("Sr!SrpCreateContext:      QryDir:                Event=%06x       Dir=%d\n",
                 EventType,
                 isDirectory) );
    }

    if (FlagOn( EventType, SrEventInPreCreate ))
    {
        fileAttributes = FileAttributes;
    }
    else
    {
        FILE_BASIC_INFORMATION basicInformation;

        status = SrQueryInformationFile( pExtension->pTargetDevice,
                                         pFileObject,
                                         &basicInformation,
                                         sizeof( basicInformation ),
                                         FileBasicInformation,
                                         NULL );

        if (!NT_SUCCESS( status ))
        {
            goto Cleanup;
        }

        fileAttributes = (USHORT) basicInformation.FileAttributes;
    }

    //
    //  We are interested in all directories, but we are not interested in 
    //  files that have the following attributes:
    //     FILE_ATTRIBUTE_SPARSE_FILE
    //     FILE_ATTRIBUTE_REPARSE_POINT
    //
    //  If either of these are set, the file is not interesting.
    //

    if (!isDirectory &&
        FlagOn( fileAttributes, 
                (FILE_ATTRIBUTE_SPARSE_FILE | FILE_ATTRIBUTE_REPARSE_POINT) ))
    {
        isInteresting = FALSE;

#if DBG
        //
        //  For debug purposes, we may still want to keep the name for
        //  file.
        //
        
        if (FlagOn(_globals.DebugControl,SR_DEBUG_KEEP_CONTEXT_NAMES))
        {
            BOOLEAN temp;
            status = SrIsFileEligible( pExtension,
                                       pFileObject,
                                       isDirectory,
                                       EventType, 
                                       &nameControl,
                                       &temp,
                                       &reasonableErrorInPreCreate );

            if (!NT_SUCCESS_NO_DBGBREAK( status ))
            {
                goto Cleanup;
            }
        }
#endif        
    }
    else
    {
        //
        //  Determine if this file is interesting or not.  Note that this
        //  returns the full name of the file if it is interesting.
        //

        status = SrIsFileEligible( pExtension,
                                   pFileObject,
                                   isDirectory,
                                   EventType, 
                                   &nameControl,
                                   &isInteresting,
                                   &reasonableErrorInPreCreate );

        if (!NT_SUCCESS_NO_DBGBREAK( status ))
        {
            goto Cleanup;
        }
    }

InitContext:
    
    //
    //  now allocate a new context structure.  Note that we do this even
    //  if the file is not interesting.  If this is a NON-DEBUG OS then
    //  we will not store the names.  In the DEBUG OS we always store the
    //  name.
    //

    contextSize = sizeof(SR_STREAM_CONTEXT);

    if (isInteresting ||
        FlagOn(_globals.DebugControl,SR_DEBUG_KEEP_CONTEXT_NAMES))
    {
        contextSize += (nameControl.Name.Length + 
                        nameControl.StreamNameLength +  
                        sizeof(WCHAR));
    }

    ctx = ExAllocatePoolWithTag( PagedPool, 
                                 contextSize,
                                 SR_STREAM_CONTEXT_TAG );

    if (!ctx)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

#if DBG
    INC_STATS(TotalContextCreated);
    if (isDirectory)    INC_STATS(TotalContextDirectories);
    if (isInteresting)  INC_STATS(TotalContextIsEligible);
#endif

    //
    //  Initialize the context structure indcluding setting of the name
    //

    RtlZeroMemory(ctx,sizeof(SR_STREAM_CONTEXT));
    ctx->UseCount = 1;
    //ctx->Flags = 0;               //zeroed with structure just above
    if (isDirectory)    SetFlag(ctx->Flags,CTXFL_IsDirectory);
    if (isInteresting)  SetFlag(ctx->Flags,CTXFL_IsInteresting);
    if (isVolumeOpen)   SetFlag(ctx->Flags,CTXFL_IsVolumeOpen);
    
    //
    //  ISSUE-2001-02-16-NealCh  When SR is ported to the FilterMgr the
    //      contexts need to be made FILE contexts instead of STREAM
    //      contexts.
    //
    //  Because contexts are tracked per stream instead of per file we need
    //  to mark all contexts associated with a stream as temporary.  This
    //  problem showed up when renaming a file into/out of monitored
    //  space and we were not properly updating the stream contexts.  When a
    //  file is renamed, we need to invalid all stream contexts for the file,
    //  but we cannot easily do this in the current model.
    //

    if (nameControl.StreamNameLength != 0)      
    {
        SetFlag(ctx->Flags,CTXFL_Temporary);
    }

    //
    //  If this file has more than link, we need to mark the context
    //  as temporary to avoid aliasing problems.
    //
    //  Also note that if the file is being deleted, the link count has already
    //  been decremented for the pending removal of that link.  Therefore, if
    //  this is for an SrEventFileDelete event, we must use a temporary context
    //  if the linkCount > 0.
    //

    if ((linkCount > 1) ||
        (FlagOn( EventType, SrEventFileDelete ) && (linkCount > 0)))
    {
        SetFlag(ctx->Flags,CTXFL_Temporary);
    }
    else if (linkCount == 0 && !isDirectory && !isVolumeOpen)
    {
        //
        //  We only have to query the link count for files and 
        //  there are some paths where we don't know the link count and cannot
        //  determine it yet (for example, in the pre-create path, we don't
        //  have a valid file object to use to query the file sytem for this
        //  information).  In this case, flag the context as such and we will
        //  do the query when we link the context into FilterContexts.
        //

        SetFlag(ctx->Flags,CTXFL_QueryLinkCount);
    }

    //
    //  In all cases, store the current link count in the context.
    //

    ctx->LinkCount = linkCount;

    //
    //  We normally only keep the name if it is interesting.  If the debug
    //  flag to keep the name is on, keep that name also.  Note also that
    //  we try to keep the name of the stream seperate (so we can see it)
    //  but it is not part of the actual name
    //

    if (isInteresting ||
        FlagOn(_globals.DebugControl,SR_DEBUG_KEEP_CONTEXT_NAMES))
    {
        //
        //  Insert the file name (include the stream name if they want it)
        //

        RtlInitEmptyUnicodeString( &ctx->FileName, 
                                   (PWCHAR)(ctx + 1), 
                                   contextSize - sizeof(SR_STREAM_CONTEXT) );

        //
        //  We use this routine (instead of copy unicode string) because
        //  we want to copy the stream name in as well
        //

        RtlCopyMemory( ctx->FileName.Buffer,
                       nameControl.Name.Buffer,
                       nameControl.Name.Length + nameControl.StreamNameLength );

        ctx->FileName.Length = nameControl.Name.Length;
        ctx->StreamNameLength = nameControl.StreamNameLength;
    }
    else
    {
        //
        //  Set a NULL filename
        //

        /*RtlInitEmptyUnicodeString( &ctx->FileName, 
                                   NULL,
                                   0 );*/   //zeroed above with structure
        //ctx->StreamNameLength = 0;        //zeroed above with structure
    }

    //
    //  Return the object context
    //

    *pRetContext = ctx;

    //
    //  Cleanup the local nameControl structure
    //

Cleanup:
    //
    //  See if we need to disable logging.  We will in the following
    //  situations:
    //  - We are in PRE-CREATE and we got an unreasonable error.
    //  - We get an out of memory error at any time
    //  - We are in all other operations and we get a non-volume related error
    //

    if (((!FlagOn(EventType, SrEventInPreCreate)) ||
         !reasonableErrorInPreCreate ||
         (STATUS_INSUFFICIENT_RESOURCES == status)) &&
        CHECK_FOR_VOLUME_ERROR(status))
    {
        //
        //  Trigger the failure notification to the service.
        //

        NTSTATUS tempStatus = SrNotifyVolumeError( pExtension,
                                                   &nameControl.Name,
                                                   status,
                                                   EventType );
        CHECK_STATUS(tempStatus);
    }

    SrpCleanupNameControl( &nameControl );
    return status;
}


/***************************************************************************++

Routine Description:

    This will see if a given context already exists.  If not it will create
    one and return it.  Note:  the return context pointer is NULL on a
    failure.

    This will also see if all contexts are to be temporary (global flag in
    the extension).  If so, a temproary context is always created.  It also
    see if the context that is found is being renamed.  If so then a
    temporary context is also created and returned.

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
SrGetContext (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN SR_EVENT_TYPE EventType,
    OUT PSR_STREAM_CONTEXT *pRetContext
    )
{
    PSR_STREAM_CONTEXT pFileContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    NTSTATUS status;
    BOOLEAN makeTemporary = FALSE;

    PAGED_CODE();

    //
    //  Bump total search count
    //

    INC_STATS(TotalContextSearches);

    //
    //  See if the all-contexts-temporary state is on.  If not then do
    //  the normal search.
    //

    if (pExtension->ContextCtrl.AllContextsTemporary == 0)
    {
        //
        //  Try and locate the context structure.  We acquire the list lock
        //  so that we can gurantee that the context will not go away between
        //  the time when we find it and can increment the use count
        //

        SrAcquireContextLockShared( pExtension );

        ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(pFileObject),
                                            pExtension,
                                            NULL );

        if (NULL != ctxCtrl)
        {
            //
            //  We found and entry
            //

            pFileContext = CONTAINING_RECORD(ctxCtrl,SR_STREAM_CONTEXT,ContextCtrl);

            ASSERT(FlagOn(pFileContext->Flags,CTXFL_InExtensionList));
            ASSERT(!FlagOn(pFileContext->Flags,CTXFL_Temporary));
            ASSERT(pFileContext->UseCount > 0);

            //
            //  See if this file is in the middle of an operation that makes
            //  the name possibly stale (e.g., rename, hardlink creation)
            //

            if (FlagOn(pFileContext->Flags,CTXFL_DoNotUse))
            {
                //
                //  We should not use this context, unlock and set flag so we
                //  will create a temporary context.
                //

                SrReleaseContextLock( pExtension );
                makeTemporary = TRUE;
                NULLPTR(pFileContext);
            }
            else
            {
                //
                //  We want this context so bump the use count and release
                //  the lock
                //

                InterlockedIncrement( &pFileContext->UseCount );

                SrReleaseContextLock( pExtension );
                INC_STATS(TotalContextFound);

                SrTrace( CONTEXT_LOG, ("Sr!SrGetContext:          Found:      (%p) Event=%06x Fl=%03x Use=%d \"%.*S\"\n",
                                       pFileContext,
                                       EventType,
                                       pFileContext->Flags,
                                       pFileContext->UseCount,
                                       (pFileContext->FileName.Length+
                                            pFileContext->StreamNameLength)/
                                            sizeof(WCHAR),
                                       pFileContext->FileName.Buffer ));

                //
                //  Return the found context
                //

                *pRetContext = pFileContext;
                return STATUS_SUCCESS;
            }
        }
        else
        {
            //
            //  We didn't find a context, release the lock
            //

            SrReleaseContextLock( pExtension );
        }
    }

    //
    //  See if contexts are supported for this particular file.  Note that
    //  NTFS does not support contexts on paging files.
    //

    ASSERT(FsRtlGetPerStreamContextPointer(pFileObject) != NULL);

    if (!FlagOn(FsRtlGetPerStreamContextPointer(pFileObject)->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))
    {
        INC_STATS(TotalContextsNotSupported);
        *pRetContext = NULL;
        return SR_STATUS_CONTEXT_NOT_SUPPORTED;
    }

    //
    //  If we get here we need to create a context, do it
    //

    ASSERT( !FlagOn( EventType, SrEventInPreCreate ) );
    status = SrCreateContext( pExtension,
                              pFileObject,
                              EventType,
                              0,
                              &pFileContext );
                               
    if (!NT_SUCCESS_NO_DBGBREAK( status ))
    {
        *pRetContext = NULL;
        return status;
    }       

    //
    //  Mark context temporary (if requested)
    //

    if (makeTemporary)
    {
        RtlInterlockedSetBitsDiscardReturn(&pFileContext->Flags,CTXFL_Temporary);

        INC_STATS(TotalContextTemporary);

        SrTrace( CONTEXT_LOG, ("Sr!SrpLinkContext:        RenAllTmp:  (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));
    }
    else
    {

        //
        //  Insert the context into the linked list.  Note that the
        //  link routine will see if this entry has already been added to
        //  the list (could happen while we were building it).  If so it
        //  will release the one we created and use the one it found in
        //  the list.  It will return the new entry (if it was changed).
        //  The link routine properly handles temporary contexts.
        //

        SrLinkContext( pExtension,
                       pFileObject,
                       &pFileContext );
    }

    SrTrace( CONTEXT_LOG, ("Sr!SrGetContext:          Created%s (%p) Event=%06x Fl=%03x Use=%d \"%.*S\"\n",
                           (FlagOn(pFileContext->Flags,CTXFL_Temporary) ? "Tmp:" : ":   "),
                           pFileContext,
                           EventType,
                           pFileContext->Flags,
                           pFileContext->UseCount,
                           (pFileContext->FileName.Length+
                                pFileContext->StreamNameLength)/
                                sizeof(WCHAR),
                           pFileContext->FileName.Buffer));

    //
    //  Return the context
    //

    ASSERT(pFileContext->UseCount > 0);

    *pRetContext = pFileContext;
    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    This will see if the given context already exists.  If so it will
    bump the refrence count and return the context.  If not, NULL
    is returned.

oArguments:

Return Value:

--***************************************************************************/
PSR_STREAM_CONTEXT
SrFindExistingContext (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject
    )
{
    PSR_STREAM_CONTEXT pFileContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;

    PAGED_CODE();

    //
    //  Try and locate the context structure.  We acquire the list lock
    //  so that we can gurantee that the context will not go away between
    //  the time when we find it and can increment the use count
    //

    INC_STATS(TotalContextSearches);
    SrAcquireContextLockShared( pExtension );

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(pFileObject),
                                        pExtension,
                                        NULL );

    if (NULL != ctxCtrl)
    {
        //
        //  We found the entry, increment use count
        //

        pFileContext = CONTAINING_RECORD(ctxCtrl,SR_STREAM_CONTEXT,ContextCtrl);

        InterlockedIncrement( &pFileContext->UseCount );

        //
        //  Release the list lock
        //

        SrReleaseContextLock( pExtension );
        INC_STATS(TotalContextFound);

        //
        //  arbitrary test to see if there are too many concurrent accesses
        //  to this context.
        //

        ASSERT(pFileContext->UseCount < 10);

        SrTrace( CONTEXT_LOG, ("Sr!FindExistingContext:   Found:      (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));
    }
    else
    {
        //
        //  Release the list lock while we create the new context.
        //

        SrReleaseContextLock( pExtension );

        pFileContext = NULL;
    }

    return pFileContext;
}

/***************************************************************************++

Routine Description:

    This routine takes a context and does the necessary work to make it
    uninteresting.  This can happen when a file is renamed into the store.

Arguments:

Return Value:

--***************************************************************************/
VOID
SrMakeContextUninteresting (
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    RtlInterlockedClearBitsDiscardReturn( &pFileContext->Flags,
                                          CTXFL_IsInteresting );
}

/***************************************************************************++

Routine Description:

    This decrements the use count for the given context.  If it goes to zero
    it frees the memory.

Arguments:

Return Value:

--***************************************************************************/
VOID
SrReleaseContext (
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    PAGED_CODE();

    SrTrace( CONTEXT_LOG_DETAILED, ("Sr!SrReleaseContext:      Release     (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                                    pFileContext,
                                    pFileContext->Flags,
                                    pFileContext->UseCount,
                                    (pFileContext->FileName.Length+
                                        pFileContext->StreamNameLength)/
                                        sizeof(WCHAR),
                                    pFileContext->FileName.Buffer));
    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pFileContext->UseCount > 0);

    if (InterlockedDecrement( &pFileContext->UseCount ) <= 0)
    {
        ASSERT(!FlagOn(pFileContext->Flags,CTXFL_InExtensionList));

        //
        //  Free the memory
        //

        SrTrace( CONTEXT_LOG, ("Sr!SrReleaseContext:      Freeing     (%p)              Fl=%03x Use=%d \"%.*S\"\n",
                               pFileContext,
                               pFileContext->Flags,
                               pFileContext->UseCount,
                               (pFileContext->FileName.Length+
                                    pFileContext->StreamNameLength)/
                                    sizeof(WCHAR),
                               pFileContext->FileName.Buffer));

        INC_STATS(TotalContextDeferredFrees);
        SrFreeContext( pFileContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\control.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    control.c

Abstract:

    this has code for the sr control object.  this is the object that is 
    created that matches the HANDLE usermode uses to perform operations
    with the sr driver
    
Author:

    Paul McDaniel (paulmcd)     23-Jan-2000

Revision History:

--*/


#include "precomp.h"

//
// Private constants.
//

//
// Private types.
//

//
// Private prototypes.
//

//
// linker commands
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrCreateControlObject )
#pragma alloc_text( PAGE, SrDeleteControlObject )
#pragma alloc_text( PAGE, SrCancelControlIo )
#pragma alloc_text( PAGE, SrReferenceControlObject)
#pragma alloc_text( PAGE, SrDereferenceControlObject )
#endif  // ALLOC_PRAGMA


//
// Private globals.
//


//
// Public globals.
//

//
// Public functions.
//


    //
    // you must have the lock EXCLUSIVE prior to calling this !
    //

NTSTATUS
SrCreateControlObject(
    OUT PSR_CONTROL_OBJECT * ppControlObject,
    IN  ULONG Options
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSR_CONTROL_OBJECT pControlObject = NULL;

    PAGED_CODE();

    SrTrace(FUNC_ENTRY, ("SR!SrCreateControlObject()\n"));
    
    //
    // allocate the control object
    //

    pControlObject = SR_ALLOCATE_STRUCT(
                            NonPagedPool, 
                            SR_CONTROL_OBJECT, 
                            SR_CONTROL_OBJECT_TAG
                            );

    if (pControlObject == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    //
    // wipe it clean
    //
    
    RtlZeroMemory(pControlObject, sizeof(SR_CONTROL_OBJECT));

    pControlObject->Signature = SR_CONTROL_OBJECT_TAG;

    //
    // Start the refcount at 1 (the caller's ref) 
    //
    
    pControlObject->RefCount = 1;

    //
    // Copy over the info from create
    //

    pControlObject->Options = Options;
    
    //
    // Init our lists
    //

    InitializeListHead(&pControlObject->IrpListHead);
    InitializeListHead(&pControlObject->NotifyRecordListHead);

    //
    // Fill in the EPROCESS
    //

    pControlObject->pProcess = IoGetCurrentProcess();

    //
    // return the object
    //
    
    *ppControlObject = pControlObject;

    //
    // all done
    //

    SrTrace(NOTIFY, ("SR!SrCreateControlObject(%p)\n", pControlObject));

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pControlObject != NULL)
        {
            SR_FREE_POOL_WITH_SIG(pControlObject, SR_CONTROL_OBJECT_TAG);
        }
    }

    RETURN(Status);
    
}   // SrCreateControlObject


NTSTATUS
SrDeleteControlObject(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    NTSTATUS    Status;
    PLIST_ENTRY pEntry;

    ASSERT(IS_GLOBAL_LOCK_ACQUIRED());

    PAGED_CODE();

    SrTrace(NOTIFY, ("SR!SrDeleteControlObject(%p)\n", pControlObject));

    if (IS_VALID_CONTROL_OBJECT(pControlObject) == FALSE)
    {
        RETURN(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // cancel all pending io (just in case) 
    //
    
    Status = SrCancelControlIo(pControlObject);
    CHECK_STATUS(Status);

    //
    // dump all of our pending notif records... 
    //

    while (IsListEmpty(&pControlObject->NotifyRecordListHead) == FALSE)
    {
        PSR_NOTIFICATION_RECORD pRecord;
        
        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pControlObject->NotifyRecordListHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pRecord = CONTAINING_RECORD( pEntry, 
                                     SR_NOTIFICATION_RECORD, 
                                     ListEntry );
                        
        ASSERT(IS_VALID_NOTIFICATION_RECORD(pRecord));

        //
        // free the record
        //

        SR_FREE_POOL_WITH_SIG(pRecord, SR_NOTIFICATION_RECORD_TAG);

        //
        // move on to the next one
        //

    }   // while (IsListEmpty(&pControlObject->NotifyRecordListHead) == FALSE)

    //
    // we no longer have a process lying around
    //
    
    pControlObject->pProcess = NULL;
    
    //
    // and release the final reference ... this should delete it
    // (pending async cancels)
    //

    SrDereferenceControlObject(pControlObject);
    pControlObject = NULL;

    //
    // all done
    //
    
    RETURN(STATUS_SUCCESS);
    
}   // SrDeleteControlObject


NTSTATUS
SrCancelControlIo(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    PLIST_ENTRY pEntry;

    ASSERT(IS_GLOBAL_LOCK_ACQUIRED());

    PAGED_CODE();

    SrTrace(NOTIFY, ("SR!SrCancelControlIo(%p)\n", pControlObject));

    if (IS_VALID_CONTROL_OBJECT(pControlObject) == FALSE)
    {
        RETURN(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // loop over the list and cancel any pending io.
    //

    while (!IsListEmpty(&pControlObject->IrpListHead))
    {
        PIRP pIrp;

        //
        // Pop it off the list.
        //

        pEntry = RemoveHeadList(&pControlObject->IrpListHead);
        pEntry->Blink = pEntry->Flink = NULL;

        pIrp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);
        ASSERT(IS_VALID_IRP(pIrp));

        //
        // pop the cancel routine
        //

        if (IoSetCancelRoutine(pIrp, NULL) == NULL)
        {
            //
            // IoCancelIrp pop'd it first
            //
            // ok to just ignore this irp, it's been pop'd off the queue
            // and will be completed in the cancel routine.
            //
            // keep looping
            //

            pIrp = NULL;

        }
        else
        {
            PSR_CONTROL_OBJECT pIrpControlObject;

            //
            // cancel it.  even if pIrp->Cancel == TRUE we are supposed to
            // complete it, our cancel routine will never run.
            //

            pIrpControlObject = (PSR_CONTROL_OBJECT)(
                                    IoGetCurrentIrpStackLocation(pIrp)->
                                        Parameters.DeviceIoControl.Type3InputBuffer
                                    );

            ASSERT(pIrpControlObject == pControlObject);
            ASSERT(IS_VALID_CONTROL_OBJECT(pIrpControlObject));

            SrDereferenceControlObject(pIrpControlObject);

            IoGetCurrentIrpStackLocation(pIrp)->
                Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            pIrp = NULL;
        }

        //
        // move on to the next one
        //
        
    }

    //
    // our irp list should now empty.
    //
    
    ASSERT(IsListEmpty(&pControlObject->IrpListHead));

    RETURN(STATUS_SUCCESS);

}   // SrCancelControlIo

VOID
SrReferenceControlObject(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    LONG RefCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));

    RefCount = InterlockedIncrement( &pControlObject->RefCount );

}   // SrReferenceControlObject


VOID
SrDereferenceControlObject(
    IN PSR_CONTROL_OBJECT pControlObject
    )
{
    LONG        RefCount;
    
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject));

    RefCount = InterlockedDecrement( &pControlObject->RefCount );

    if (RefCount == 0)
    {

        //
        // there better not be any items on any lists
        //

        ASSERT(IsListEmpty(&pControlObject->NotifyRecordListHead));
        ASSERT(IsListEmpty(&pControlObject->IrpListHead));

        //
        // and the memory
        //
        
        SR_FREE_POOL_WITH_SIG(pControlObject, SR_CONTROL_OBJECT_TAG);

    }

}   // SrDereferenceControlObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\control.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    control.h

Abstract:

    This is a local header file for control.c

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000
    
Revision History:

--*/


#ifndef _CONTROL_H_    
#define _CONTROL_H_


#define SR_CONTROL_OBJECT_CONTEXT       ULongToPtr(SR_CONTROL_OBJECT_TAG)

#define IS_VALID_CONTROL_OBJECT(pObject) \
    (((pObject) != NULL) && ((pObject)->RefCount > 0) && ((pObject)->Signature == SR_CONTROL_OBJECT_TAG))

//
// locked by global->ControlResource
//

typedef struct _SR_CONTROL_OBJECT
{
    //
    // NonPagedPool
    //

    //
    // SR_CONTROL_OBJECT_TAG
    //
    
    ULONG Signature;

    //
    // a zero-based reference count
    //
    
    LONG RefCount;

    //
    // the Options passed into SrCreateMonitor
    //

    ULONG Options;

    //
    // Irps that have not been completed yet are placed on IrpListHead
    //

    LIST_ENTRY IrpListHead;

    //
    // Notify Records that have not been completed to irps are placed on 
    // NotifyRecordListHead
    //

    LIST_ENTRY NotifyRecordListHead;

    //
    // The process that created this control object
    //

    PEPROCESS pProcess;

} SR_CONTROL_OBJECT, *PSR_CONTROL_OBJECT;




NTSTATUS
SrCreateControlObject (
    OUT PSR_CONTROL_OBJECT * ppControlObject,
    IN  ULONG Options
    );


NTSTATUS
SrDeleteControlObject (
    IN PSR_CONTROL_OBJECT pControlObject
    );

NTSTATUS
SrCancelControlIo (
    IN PSR_CONTROL_OBJECT pControlObject
    );


VOID
SrReferenceControlObject (
    IN PSR_CONTROL_OBJECT pControlObject
    );


VOID
SrDereferenceControlObject (
    IN PSR_CONTROL_OBJECT pControlObject
    );




#endif // _CONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\copyfile.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    copyfile.h

Abstract:

    This is a local header file for copyfile.c

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000
    
Revision History:

--*/


#ifndef _COPYFILE_H_
#define _COPYFILE_H_


NTSTATUS
SrBackupFile(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pOriginalFileObject,
    IN PUNICODE_STRING pSourceFileName,
    IN PUNICODE_STRING pDestFileName,
    IN BOOLEAN CopyDataStreams,
    OUT PULONGLONG pBytesWritten OPTIONAL,
    OUT PUNICODE_STRING pShortFileName OPTIONAL
    );


NTSTATUS
SrBackupFileAndLog (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PUNICODE_STRING pFileName,
    IN PUNICODE_STRING pDestFileName,
    IN BOOLEAN CopyDataStreams
    );


#endif // _COPYFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\copyfile.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    copyfile.c

Abstract:

    This is where the kernel mode copyfile is performed.  Really it is more
    of a backup process then a copyfile.

    The main funcion is SrBackupFile.  This is called in response to a 
    file modification in order to preservce the old state of that file
    being modified.

    SrBackupFile was stolen from kernel32.dll:CopyFileExW.  It was converted
    to kernel mode and stripped down to handle just the SR backup 
    requirements.

    SrCopyStream was also stolen from kernel32.dll and converted to kernel
    mode.  However the main data copy routing SrCopyDataBytes was written new.
    
Author:

    Paul McDaniel (paulmcd)     03-Apr-2000

Revision History:

--*/


#include "precomp.h"

//
// Private constants.
//

#define SR_CREATE_FLAGS     (FILE_SEQUENTIAL_ONLY               \
                             | FILE_WRITE_THROUGH               \
                             | FILE_NO_INTERMEDIATE_BUFFERING   \
                             | FILE_NON_DIRECTORY_FILE          \
                             | FILE_OPEN_FOR_BACKUP_INTENT      \
                             | FILE_SYNCHRONOUS_IO_NONALERT) 


//
// Private types.
//

#define IS_VALID_HANDLE_FILE_CHANGE_CONTEXT(pObject) \
    (((pObject) != NULL) && ((pObject)->Signature == SR_BACKUP_FILE_CONTEXT_TAG))

typedef struct _SR_BACKUP_FILE_CONTEXT
{
    //
    // NonPagedPool
    //
    
    //
    // = SR_BACKUP_FILE_CONTEXT_TAG
    //
    
    ULONG Signature;

    WORK_QUEUE_ITEM WorkItem;

    KEVENT Event;
    
    NTSTATUS Status;

    SR_EVENT_TYPE EventType;
    
    PFILE_OBJECT pFileObject;

    PUNICODE_STRING pFileName;

    PSR_DEVICE_EXTENSION pExtension;

    PUNICODE_STRING pDestFileName;

    BOOLEAN CopyDataStreams;

    PACCESS_TOKEN pThreadToken;

} SR_BACKUP_FILE_CONTEXT, * PSR_BACKUP_FILE_CONTEXT;

//
// Private prototypes.
//

NTSTATUS
SrMarkFileForDelete (
    HANDLE FileHandle
    );

NTSTATUS
SrCopyStream (
    IN HANDLE SourceFileHandle,
    IN PDEVICE_OBJECT pTargetDeviceObject,
    IN PUNICODE_STRING pDestFileName,
    IN HANDLE DestFileHandle OPTIONAL,
    IN PLARGE_INTEGER pFileSize,
    OUT PHANDLE pDestFileHandle
    );

NTSTATUS
SrCopyDataBytes (
    IN HANDLE SourceFile,
    IN HANDLE DestFile,
    IN PLARGE_INTEGER FileSize,
    IN ULONG SectorSize
    );

BOOLEAN
SrIsFileEncrypted (
    PSR_DEVICE_EXTENSION pExtension,
    PFILE_OBJECT pFileObject
    );

//
// linker commands
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SrCopyDataBytes )
#pragma alloc_text( PAGE, SrCopyStream )
#pragma alloc_text( PAGE, SrBackupFile )
#pragma alloc_text( PAGE, SrMarkFileForDelete )
#pragma alloc_text( PAGE, SrBackupFileAndLog )
#pragma alloc_text( PAGE, SrIsFileEncrypted )
#endif  // ALLOC_PRAGMA

/***************************************************************************++

Routine Description:

    This routine copies the all data from SourceFile to DestFile.  To read
    the data from the SourceFile, the file is memory mapped so that we bypass
    any byte range locks that may be held on the file.

Arguments:

    SourceFile - Handle to the file from which to copy.

    DestFile - Handle for the file into which to copy

    Length - the total size of the file (if it is less than the total size,
                more bytes might be copied than Length ).

Return Value:

    status of the copy
    
--***************************************************************************/
NTSTATUS
SrCopyDataBytes(
    IN HANDLE SourceFile,
    IN HANDLE DestFile,
    IN PLARGE_INTEGER pFileSize,
    IN ULONG SectorSize
    )
{
#define	MM_MAP_ALIGNMENT (64 * 1024 /*VACB_MAPPING_GRANULARITY*/)   // The file offset granularity that MM enforces.
#define	COPY_AMOUNT	(64 * 1024)	// How much we read or write at a time.  Must be >= MM_MAP_ALIGNMENT
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER  ByteOffset;
    HANDLE SectionHandle = NULL;

    PAGED_CODE();

    ASSERT( SourceFile != NULL );
    ASSERT( DestFile != NULL );
    ASSERT( SectorSize > 0 );
    ASSERT( pFileSize != NULL );
    ASSERT( pFileSize->QuadPart > 0 );
    ASSERT( pFileSize->HighPart == 0 );

	Status = ZwCreateSection( &SectionHandle,
                              SECTION_MAP_READ | SECTION_QUERY,
                              NULL,
                              pFileSize,
                              PAGE_READONLY,
                              SEC_COMMIT,
                              SourceFile );
    
	if (!NT_SUCCESS(Status))
	{
		goto SrCopyDataBytes_Exit;
	}

    ByteOffset.QuadPart = 0;
    
	while (ByteOffset.QuadPart < pFileSize->QuadPart)
	{
		ULONG ValidBytes, BytesToCopy;
		PCHAR MappedBuffer = NULL;
		LARGE_INTEGER MappedOffset;
		SIZE_T ViewSize;
		PCHAR CopyIntoAddress;

        //
        //  Set MappedOffset to the greatest, lower offset from ByteOffset that
        //  is align to the valid alignment allowed by the memory manager.
        //
        
		MappedOffset.QuadPart = ByteOffset.QuadPart - (ByteOffset.QuadPart % MM_MAP_ALIGNMENT);
		ASSERT( (MappedOffset.QuadPart <= ByteOffset.QuadPart) && 
		        ((MappedOffset.QuadPart + MM_MAP_ALIGNMENT) > ByteOffset.QuadPart) );

		if ((pFileSize->QuadPart - MappedOffset.QuadPart) > COPY_AMOUNT)
		{
			//
			// We can't map enough of the file to do the whole copy
			// here, so only map COPY_AMOUNT on this pass.
			//
			ViewSize = COPY_AMOUNT;
		}
		else
		{
			//
			// We can map all the way to the end of the file.
			//
			ViewSize = (ULONG)(pFileSize->QuadPart - MappedOffset.QuadPart);
		}

		//
		//  Calculate the amount of the view size that contains valid data
		//  based on any adjustments we needed to do to make sure that
		//  the MappedOffset was correctly aligned.
		//
		
		ASSERT(ViewSize >=
               (ULONG_PTR)(ByteOffset.QuadPart - MappedOffset.QuadPart));
		ValidBytes = (ULONG)(ViewSize - (ULONG)(ByteOffset.QuadPart - MappedOffset.QuadPart));
		
		//
		// Now round ValidBytes up to a sector size.
		//
		
		BytesToCopy = ((ValidBytes + SectorSize - 1) / SectorSize) * SectorSize;

		ASSERT(BytesToCopy <= COPY_AMOUNT);

		//
		// Map in the region from which we're about to copy.
		//
		Status = ZwMapViewOfSection( SectionHandle,
                                     NtCurrentProcess(),
                                     &MappedBuffer,
                                     0,							// zero bits
                                     0,							// commit size (ignored for mapped files)
                                     &MappedOffset,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,							// allocation type
                                     PAGE_READONLY);

		if (!NT_SUCCESS( Status ))
		{
			goto SrCopyDataBytes_Exit;
		}

        //
	    //  We should have enough space allocated for the rounded up read
	    // 
	    
    	ASSERT( ViewSize >= BytesToCopy );

		CopyIntoAddress = MappedBuffer + (ULONG)(ByteOffset.QuadPart - MappedOffset.QuadPart);

        //
        //  Since this handle was opened synchronously, the IO Manager takes
        //  care of waiting until the operation is complete.
        //
        
		Status = ZwWriteFile( DestFile,
		                      NULL,
		                      NULL,
		                      NULL,
		                      &IoStatusBlock,
		                      MappedBuffer,
		                      BytesToCopy,
		                      &ByteOffset,
		                      NULL );

        //
        //  Whether or not we successfully wrote this block of data, we want
        //  to unmap the current view of the section.
        //
        
		ZwUnmapViewOfSection( NtCurrentProcess(), MappedBuffer );
		NULLPTR( MappedBuffer );

		if (!NT_SUCCESS( IoStatusBlock.Status ))
		{
			goto SrCopyDataBytes_Exit;
		}

		ASSERT( IoStatusBlock.Information == BytesToCopy );
		ASSERT( BytesToCopy >= ValidBytes );

		//
		//  Add in the number of valid data bytes that we actually copied 
		//  into the file.
		//

		ByteOffset.QuadPart += ValidBytes;

		//
		//  Check to see if we copied more bytes than we had of valid data.
		//  If we did, we need to truncate the file.
		//

		if (BytesToCopy > ValidBytes)
		{
		    FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
		    
    		//
    		//  Then truncate the file to this length.
    		//
    		
            EndOfFileInformation.EndOfFile.QuadPart = ByteOffset.QuadPart;

            Status = ZwSetInformationFile( DestFile,
                                           &IoStatusBlock,
                                           &EndOfFileInformation,
                                           sizeof(EndOfFileInformation),
                                           FileEndOfFileInformation );
                        
            if (!NT_SUCCESS( Status ))
                goto SrCopyDataBytes_Exit;
		}
	}

SrCopyDataBytes_Exit:

	if (SectionHandle != NULL) {
		ZwClose( SectionHandle );
		NULLPTR( SectionHandle );
	}

    return Status;
#undef	COPY_AMOUNT
#undef	MM_MAP_ALIGNMENT
}

/*++

Routine Description:

    This is an internal routine that copies an entire file (default data stream
    only), or a single stream of a file.  If the hTargetFile parameter is
    present, then only a single stream of the output file is copied.  Otherwise,
    the entire file is copied.

Arguments:

    SourceFileHandle - Provides a handle to the source file.

    pNewFileName - Provides a name for the target file/stream.  this is the
        NT file name, not a win32 file name if a full name is passed, 
        otherwise it's just the stream name.

    DestFileHandle - Optionally provides a handle to the target file.  If the
        stream being copied is an alternate data stream, then this handle must
        be provided. NULL means it's not provided.

    pFileSize - Provides the size of the input stream.

    pDestFileHandle - Provides a variable to store the handle to the target file.

Return Value:

    NTSTATUS code

--*/

NTSTATUS
SrCopyStream(
    IN HANDLE SourceFileHandle,
    IN PDEVICE_OBJECT pTargetDeviceObject,
    IN PUNICODE_STRING pDestFileName,
    IN HANDLE DestFileHandle OPTIONAL,
    IN PLARGE_INTEGER pFileSize,
    OUT PHANDLE pDestFileHandle
    )
{
    HANDLE                      DestFile = NULL;
    NTSTATUS                    Status;
    FILE_BASIC_INFORMATION      FileBasicInformationData;
    FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
    IO_STATUS_BLOCK             IoStatus;
    ULONG                       DesiredAccess;
    ULONG                       DestFileAccess;
    ULONG                       SourceFileAttributes;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PFILE_FULL_EA_INFORMATION   EaBuffer = NULL;
    ULONG                       EaSize = 0;

    PAGED_CODE();

    ASSERT( SourceFileHandle != NULL );
    ASSERT( pTargetDeviceObject != NULL );
    ASSERT( pDestFileName != NULL );
    ASSERT( pFileSize != NULL );

    //
    //  Get times and attributes for the file if the entire file is being
    //  copied
    //

    Status = ZwQueryInformationFile( SourceFileHandle,
                                     &IoStatus,
                                     (PVOID) &FileBasicInformationData,
                                     sizeof(FileBasicInformationData),
                                     FileBasicInformation );

    SourceFileAttributes = NT_SUCCESS(Status) ?
                             FileBasicInformationData.FileAttributes :
                             0;

    if (DestFileHandle == NULL)
    {

        if ( !NT_SUCCESS(Status) ) 
        {
            goto end;
        }
    } 
    else 
    {

        //
        //  A zero in the file's attributes informs latter DeleteFile that
        //  this code does not know what the actual file attributes are so
        //  that this code does not actually have to retrieve them for each
        //  stream, nor does it have to remember them across streams.  The
        //  error path will simply get them if needed.
        //

        FileBasicInformationData.FileAttributes = 0;
    }

    //
    // Create the destination file or alternate data stream
    //

    if (DestFileHandle == NULL)
    {
        ULONG CreateOptions = 0;
        PFILE_FULL_EA_INFORMATION EaBufferToUse = NULL;
        ULONG SourceFileFsAttributes = 0;
        ULONG EaSizeToUse = 0;

        ULONG DestFileAttributes = 0;

        FILE_BASIC_INFORMATION DestBasicInformation;

        // We're being called to copy the unnamed stream of the file, and
        // we need to create the file itself.

        //
        // Determine the create options
        //

        CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                            | FILE_WRITE_THROUGH
                            | FILE_NO_INTERMEDIATE_BUFFERING
                            | FILE_OPEN_FOR_BACKUP_INTENT ;

        if (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            CreateOptions |= FILE_DIRECTORY_FILE;
        else
            CreateOptions |= FILE_NON_DIRECTORY_FILE  | FILE_SEQUENTIAL_ONLY;

        //
        // Determine what access is necessary based on what is being copied
        //

        DesiredAccess = SYNCHRONIZE 
                        | FILE_READ_ATTRIBUTES 
                        | GENERIC_WRITE 
                        | DELETE;

        if (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
        {
            // We may or may not be able to get FILE_WRITE_DATA access, 
            // necessary for setting compression.
            //
            DesiredAccess &= ~GENERIC_WRITE;
            DesiredAccess |= FILE_WRITE_DATA 
                             | FILE_WRITE_ATTRIBUTES 
                             | FILE_WRITE_EA 
                             | FILE_LIST_DIRECTORY;
        }

        //
        // We need read access for compression, write_dac for the DACL
        //
        
        DesiredAccess |= GENERIC_READ | WRITE_DAC;
        DesiredAccess |= WRITE_OWNER;
        
        //
        // we can get this as we always have SeSecurityPrivilege (kernelmode)
        //
        
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;

        //
        // get the object attributes ready
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pDestFileName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
        SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

        //
        //  Get the EAs
        //

        EaBuffer = NULL;
        EaSize = 0;

//
// paulmcd:  5/25/2000 remove ea support until we get it into ntifs.h  
// (the public header)
//

#ifdef EA_SUPPORT

        Status = ZwQueryInformationFile( SourceFileHandle,
                                         &IoStatus,
                                         &EaInfo,
                                         sizeof(EaInfo),
                                         FileEaInformation );
                    
        if (NT_SUCCESS(Status) && EaInfo.EaSize > 0) 
        {

            EaSize = EaInfo.EaSize;

            do 
            {

                EaSize *= 2;
                EaBuffer = (PFILE_FULL_EA_INFORMATION)
                                SR_ALLOCATE_ARRAY( PagedPool,
                                                   UCHAR,
                                                   EaSize, 
                                                   SR_EA_DATA_TAG );
                if (EaBuffer == NULL) 
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto end;
                }

                Status = ZwQueryEaFile( SourceFileHandle,
                                        &IoStatus,
                                        EaBuffer,
                                        EaSize,
                                        FALSE,
                                        (PVOID)NULL,
                                        0,
                                        (PULONG)NULL,
                                        TRUE );

                if ( !NT_SUCCESS(Status) ) 
                {
                    SR_FREE_POOL(EaBuffer, SR_EA_DATA_TAG);
                    EaBuffer = NULL;
                    IoStatus.Information = 0;
                }

            } while ( Status == STATUS_BUFFER_OVERFLOW ||
                      Status == STATUS_BUFFER_TOO_SMALL );


            EaSize = (ULONG)IoStatus.Information;

        }   // if ( NT_SUCCESS(Status) && EaInfo.EaSize )

#endif // EA_SUPPORT

        //
        // Open the destination file.
        //

        DestFileAccess = DesiredAccess;
        EaBufferToUse = EaBuffer;
        EaSizeToUse = EaSize;

        //
        // Turn off FILE_ATTRIBUTE_OFFLINE for destination
        //
        
        SourceFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;

        while (DestFile == NULL) 
        {
            //
            //  Attempt to create the destination - if the file already
            //  exists, we will overwrite it.
            //

            Status = SrIoCreateFile( &DestFile,
                                     DestFileAccess,
                                     &ObjectAttributes,
                                     &IoStatus,
                                     NULL,
                                     SourceFileAttributes 
                                          & FILE_ATTRIBUTE_VALID_FLAGS,
                                     FILE_SHARE_READ|FILE_SHARE_WRITE,
                                     FILE_OVERWRITE_IF,
                                     CreateOptions,
                                     EaBufferToUse,
                                     EaSizeToUse,
                                     IO_IGNORE_SHARE_ACCESS_CHECK,
                                     pTargetDeviceObject );

            // If this was successful, then break out of this while loop.
            // The remaining code in this loop attempt to recover from the problem,
            // then it loops back to the top and attempt the NtCreateFile again.

            if (NT_SUCCESS(Status))
            {
                break;  // while( TRUE )
            } 

            //
            // If the destination has not been successfully created/opened, 
            // see if it's because EAs aren't supported
            //

            if( EaBufferToUse != NULL &&
                Status == STATUS_EAS_NOT_SUPPORTED ) 
            {

                // Attempt the create again, but don't use the EAs

                EaBufferToUse = NULL;
                EaSizeToUse = 0;
                DestFileAccess = DesiredAccess;
                continue;

            }   // if( EaBufferToUse != NULL ...

            //
            // completely failed! no more tricks.
            //
            
            DestFile = NULL;
            goto end;

        }   // while (DestFile == NULL)

        //
        // If we reach this point, we've successfully opened the dest file.
        //

        //
        // Get the File & FileSys attributes for the target volume, plus
        // the FileSys attributes for the source volume.
        //

        SourceFileFsAttributes = 0;
        DestFileAttributes = 0;

        Status = ZwQueryInformationFile( DestFile,
                                         &IoStatus,
                                         &DestBasicInformation,
                                         sizeof(DestBasicInformation),
                                         FileBasicInformation );
                                         
        if (!NT_SUCCESS( Status )) 
            goto end;

        DestFileAttributes = DestBasicInformation.FileAttributes;


        //
        // If the source file is encrypted, check that the target was successfully
        // set for encryption (e.g. it won't be for FAT).
        //

        if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            !(DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) 
        {
            //
            // CODEWORK:  paulmcd.. need to figure out how to appropriately
            // handle the $EFS stream.
            //

            ASSERT(FALSE);
            
            SrTrace(NOTIFY, ("sr!SrCopyStream(%wZ):failed to copy encryption\n", 
                    pDestFileName )); 

            
        }   // if( SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ...

    } 
    else // if (DestFileHandle == NULL)
    {    

        // We're copying a named stream.

        //
        // Create the output stream relative to the file specified by the
        // DestFileHandle file handle.
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pDestFileName,
                                    OBJ_KERNEL_HANDLE,
                                    DestFileHandle,
                                    (PSECURITY_DESCRIPTOR)NULL );

        DesiredAccess = GENERIC_WRITE | SYNCHRONIZE;
        
        Status = SrIoCreateFile( &DestFile,
                                 DesiredAccess,
                                 &ObjectAttributes,
                                 &IoStatus,
                                 pFileSize,
                                 SourceFileAttributes,
                                 FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                 FILE_OPEN_IF,
                                 SR_CREATE_FLAGS,
                                 NULL,                // EaBuffer
                                 0,                   // EaLength
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pTargetDeviceObject );

        if (!NT_SUCCESS( Status ))
        {

            if (Status != STATUS_ACCESS_DENIED) 
                goto end;

            //
            // Determine whether or not this failed because the file
            // is a readonly file.  If so, change it to read/write,
            // re-attempt the open, and set it back to readonly again.
            //

            Status = ZwQueryInformationFile( DestFileHandle,
                                             &IoStatus,
                                             (PVOID) &FileBasicInformationData,
                                             sizeof(FileBasicInformationData),
                                             FileBasicInformation );

            if (!NT_SUCCESS( Status )) 
            {
                goto end;
            }

            if (FileBasicInformationData.FileAttributes 
                    & FILE_ATTRIBUTE_READONLY) 
            {
                ULONG attributes = FileBasicInformationData.FileAttributes;

                RtlZeroMemory( &FileBasicInformationData,
                               sizeof(FileBasicInformationData) );
                               
                FileBasicInformationData.FileAttributes 
                                                    = FILE_ATTRIBUTE_NORMAL;
                
                (VOID) ZwSetInformationFile( DestFileHandle,
                                             &IoStatus,
                                             &FileBasicInformationData,
                                             sizeof(FileBasicInformationData),
                                             FileBasicInformation );
                          
                Status = SrIoCreateFile( &DestFile,
                                         DesiredAccess,
                                         &ObjectAttributes,
                                         &IoStatus,
                                         pFileSize,
                                         SourceFileAttributes,
                                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                                         FILE_OPEN_IF,
                                         SR_CREATE_FLAGS,
                                         NULL,                // EaBuffer
                                         0,                   // EaLength
                                         IO_IGNORE_SHARE_ACCESS_CHECK,
                                         pTargetDeviceObject );
                            
                FileBasicInformationData.FileAttributes = attributes;
                
                (VOID) ZwSetInformationFile( DestFileHandle,
                                             &IoStatus,
                                             &FileBasicInformationData,
                                             sizeof(FileBasicInformationData),
                                             FileBasicInformation );
                            
                if (!NT_SUCCESS( Status ))
                    goto end;
                    
            } 
            else 
            {
                //
                // it wasn't read only... just fail, nothing else to try
                //
                
                goto end;
            }
        }

    }   // else [if (DestFileHandle == NULL)]

    //
    // is there any stream data to copy?
    //

    if (pFileSize->QuadPart > 0)
    {
        //
        // Preallocate the size of this file/stream so that extends do not
        // occur.
        //

        EndOfFileInformation.EndOfFile = *pFileSize;
        Status = ZwSetInformationFile( DestFile,
                                       &IoStatus,
                                       &EndOfFileInformation,
                                       sizeof(EndOfFileInformation),
                                       FileEndOfFileInformation );
                    
        if (!NT_SUCCESS( Status ))
            goto end;

        //
        // now copy the stream bits
        //

        Status = SrCopyDataBytes( SourceFileHandle,
                                  DestFile,
                                  pFileSize,
                                  pTargetDeviceObject->SectorSize );

        if (!NT_SUCCESS( Status ))
            goto end;

    }

end:    

    if (!NT_SUCCESS( Status ))
    {
        if (DestFile != NULL) 
        {
            SrMarkFileForDelete(DestFile);
            
            ZwClose(DestFile);
            DestFile = NULL;
        }
    }

    //
    // set the callers pointer 
    // (even if it's not valid, this clears the callers buffer)
    //
    
    *pDestFileHandle = DestFile;

    if ( EaBuffer ) 
    {
        SR_FREE_POOL(EaBuffer, SR_EA_DATA_TAG);
    }

    RETURN(Status);
    
}   // SrCopyStream





/***************************************************************************++

Routine Description:

    this routine will copy the source file to the dest file.  the dest
    file is opened create so it must not already exist.  if the 
    CopyDataStreams is set all alternate streams are copied including the 
    default data stream.  the DACL is copied to the dest file but the dest
    file has the owner set to admins regardless of the source file object.

    if it fails it cleans up and deletes the dest file.

    it checks to make sure the volume has at least 50mb free prior to 
    the copy.


BUGBUG: paulmcd:8/2000: this routine does not copy the $EFS meta-data

Arguments:

    pExtension - SR's device extension for the volume on which this file
        resides.
    pOriginalFileObject - the file object to which this operation is occuring.
        This file object could represent a name data stream on the file.
    pSourceFileName - The name of the file to backup (excluding any stream
        component).
    pDestFileName - The name of the destination file to which this file will 
        be copied.
    CopyDataStreams - If TRUE, we should copy all the data streams of this
        file.
    pBytesWritten - Is set to the number of bytes written in the restore
        location as a result of backing up this file.
    pShortFileName - Is set to the short file name of the file we backed up
        if we were able to successfully back up the file and this file has
        a short name.
    
Return Value:

    ULONG - Completion status.

--***************************************************************************/
NTSTATUS
SrBackupFile(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pOriginalFileObject,
    IN PUNICODE_STRING pSourceFileName,
    IN PUNICODE_STRING pDestFileName,
    IN BOOLEAN CopyDataStreams,
    OUT PULONGLONG pBytesWritten OPTIONAL,
    OUT PUNICODE_STRING pShortFileName OPTIONAL
    )
{
    HANDLE      SourceFileHandle = NULL;
    HANDLE      DestFile = NULL;
    NTSTATUS    Status;
    HANDLE      OutputStream;
    HANDLE      StreamHandle;
    ULONG       StreamInfoSize;
    OBJECT_ATTRIBUTES objAttr;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatus;
    LARGE_INTEGER       BytesToCopy;
    UNICODE_STRING      StreamName;
    PFILE_OBJECT        pSourceFileObject = NULL;
    
    FILE_STANDARD_INFORMATION   FileInformation;
    FILE_BASIC_INFORMATION      BasicInformation;
    PFILE_STREAM_INFORMATION    StreamInfo;
    PFILE_STREAM_INFORMATION    StreamInfoBase = NULL;
    
    struct {
        FILE_FS_ATTRIBUTE_INFORMATION Info;
        WCHAR Buffer[ 50 ];
    } FileFsAttrInfoBuffer;


    PAGED_CODE();

    ASSERT(pOriginalFileObject != NULL);
    ASSERT(pSourceFileName != NULL);

    try 
    {
        if (pBytesWritten != NULL)
        {
            *pBytesWritten = 0;
        }

        //
        //  First open a new handle to the source file so that we don't
        //  interfere with the user's read offset.
        //

        InitializeObjectAttributes( &objAttr,
                                    pSourceFileName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );
        
        Status = SrIoCreateFile( &SourceFileHandle,
                                 GENERIC_READ,
                                 &objAttr,
                                 &IoStatus,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_OPEN,
                                 FILE_NON_DIRECTORY_FILE | FILE_COMPLETE_IF_OPLOCKED,
                                 NULL,
                                 0,
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pExtension->pTargetDevice );

        if (Status == STATUS_ACCESS_DENIED)
        {
            //
            //  This may be a file that is in the process of getting decrypted.
            //  Check to see if this file is currently encrypted.  If so, we
            //  we assume that we got STATUS_ACCESS_DENIED because the file is
            //  in its transition state and keep going.
            //

            if (SrIsFileEncrypted( pExtension, pOriginalFileObject ))
            {
                Status = SR_STATUS_IGNORE_FILE;
                leave;
            }
            else
            {
                CHECK_STATUS( Status );
                leave;
            }
        }
        else if (Status == STATUS_FILE_IS_A_DIRECTORY)
        {
            //
            //  We probably got to here because someone modified or deleted
            //  a named datastream on a directory.  We don't support that,
            //  so we will just propagate this error up to the caller.  They
            //  will know whether or not this is a reasonable error.
            //

            leave;
        }
        else if (!NT_SUCCESS( Status )) {

            leave;
        }
                                 
#if DBG
        if (CopyDataStreams)
        {
            SrTrace(NOTIFY, ("sr!SrBackupFile: copying\n\t%wZ\n\tto %ws\n", 
                    pSourceFileName, 
                    SrpFindFilePartW(pDestFileName->Buffer) ));

        }
        else
        {
            SrTrace(NOTIFY, ("sr!SrBackupFile: copying [no data]\n\t%ws\n\tto %wZ\n", 
                    SrpFindFilePartW(pSourceFileName->Buffer), 
                    pDestFileName ));

        }
#endif

        //
        //  Now we have our own handle to this file and all IOs on this handle
        //  we start at our pTargetDevice.
        //
                                 
        //
        // check for free space, we don't want to bank on the fact that 
        // the service is up and running to protect us from filling the disk
        //

        Status = SrCheckFreeDiskSpace( SourceFileHandle, pSourceFileName );

        if (!NT_SUCCESS( Status ))
            leave;
            
        //
        // does the caller want us to copy any actual $DATA?
        //

        if (CopyDataStreams)
        {
            //
            //  Size the source file to determine how much data is to be copied
            //

            Status = ZwQueryInformationFile( SourceFileHandle,
                                             &IoStatus,
                                             (PVOID) &FileInformation,
                                             sizeof(FileInformation),
                                             FileStandardInformation );

            if (!NT_SUCCESS( Status )) 
                leave;

            //
            // copy the entire file
            //
            
            BytesToCopy = FileInformation.EndOfFile;

        }
        else
        {
            //
            // don't copy anything
            //
            
            BytesToCopy.QuadPart = 0;
        }
        
        //
        //  Get the timestamp info as well.
        //

        Status = ZwQueryInformationFile( SourceFileHandle,
                                         &IoStatus,
                                         (PVOID) &BasicInformation,
                                         sizeof(BasicInformation),
                                         FileBasicInformation );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // we don't support sparse or reparse points.  If this
        // file is either sparse or contains a resparse point, just
        // skip it.
        //
        
        if (FlagOn( BasicInformation.FileAttributes, 
                    FILE_ATTRIBUTE_SPARSE_FILE | FILE_ATTRIBUTE_REPARSE_POINT )) {

#if DBG
            if (FlagOn( BasicInformation.FileAttributes,
                         FILE_ATTRIBUTE_SPARSE_FILE )) {
                         
                SrTrace( NOTIFY, ("sr!SrBackupFile: Ignoring sparse file [%wZ]\n",
                                  pSourceFileName) );
            }

            if (FlagOn( BasicInformation.FileAttributes,
                         FILE_ATTRIBUTE_REPARSE_POINT )) {
                         
                SrTrace( NOTIFY, ("sr!SrBackupFile: Ignoring file with reparse point [%wZ]\n",
                                  pSourceFileName) );
            }
#endif            
            Status = SR_STATUS_IGNORE_FILE;
            leave;
        }
        
        //
        // are we supposed to copy the data?  if so, check for the existence
        // of alternate streams
        //

        if (CopyDataStreams)
        {
            //
            //  Obtain the full set of streams we have to copy.  Since the Io 
            //  subsystem does not provide us a way to find out how much space 
            //  this information will take, we must iterate the call, doubling 
            //  the buffer size upon each failure.
            //
            //  If the underlying file system does not support stream enumeration,
            //  we end up with a NULL buffer.  This is acceptable since we have 
            //  at least a default data stream,
            //

            StreamInfoSize = 4096;
            
            do 
            {
                StreamInfoBase = (PFILE_STREAM_INFORMATION)
                                    SR_ALLOCATE_ARRAY( PagedPool,
                                                       UCHAR,
                                                       StreamInfoSize,
                                                       SR_STREAM_DATA_TAG );

                if (StreamInfoBase == NULL) 
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                Status = ZwQueryInformationFile( SourceFileHandle,
                                                 &IoStatus,
                                                 (PVOID) StreamInfoBase,
                                                 StreamInfoSize,
                                                 FileStreamInformation );

                if (Status == STATUS_INVALID_PARAMETER || 
                    !NT_SUCCESS( Status )) 
                {
                    //
                    //  We failed the call.  Free up the previous buffer and 
                    //  set up for another pass with a buffer twice as large
                    //

                    SR_FREE_POOL(StreamInfoBase, SR_STREAM_DATA_TAG);
                    StreamInfoBase = NULL;
                    StreamInfoSize *= 2;
                }
                else if( IoStatus.Information == 0 ) {
                    //
                    // There are no streams (SourceFileHandle must be a 
                    //  directory).
                    //
                    SR_FREE_POOL(StreamInfoBase, SR_STREAM_DATA_TAG);
                    StreamInfoBase = NULL;
                }

            } while ( Status == STATUS_BUFFER_OVERFLOW || 
                      Status == STATUS_BUFFER_TOO_SMALL );

            //
            // ignore status, failing to read the streams probably means there
            // are no streams
            //

            Status = STATUS_SUCCESS;
           
        }   // if (CopyDataStreams)
        
        //
        //  Set the Basic Info to change only the filetimes
        //
        
        BasicInformation.FileAttributes = 0;

        //
        // Copy the default data stream, EAs, etc. to the output file
        //

        Status = SrCopyStream( SourceFileHandle,
                               pExtension->pTargetDevice,
                               pDestFileName,
                               NULL,
                               &BytesToCopy,
                               &DestFile );

        //
        // the default stream copy failed!
        // 
        
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // remember how much we just copied
        //

        if (pBytesWritten != NULL)
        {
            *pBytesWritten += BytesToCopy.QuadPart;
        }
        
        //
        // If applicable, copy one or more of the the DACL, SACL, owner, and 
        // group.
        //


        Status = ZwQueryVolumeInformationFile( SourceFileHandle,
                                               &IoStatus,
                                               &FileFsAttrInfoBuffer.Info,
                                               sizeof(FileFsAttrInfoBuffer),
                                               FileFsAttributeInformation );
                                               
        if (!NT_SUCCESS( Status )) 
            leave;

        if (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_PERSISTENT_ACLS)
        {
            //
            //  Set the appropriate ACL on our destination file.  We will NOT copy
            //  the ACL from the source file since we have that information
            //  recorded in the change log.
            //

            Status = SrSetFileSecurity( DestFile, SrAclTypeRPFiles );

            if (!NT_SUCCESS( Status ))
                leave;
        }

        //
        // Attempt to determine whether or not this file has any alternate
        // data streams associated with it.  If it does, attempt to copy each
        // to the output file.  Note that the stream information may have
        // already been obtained if a progress routine was requested.
        //

        if (StreamInfoBase != NULL) 
        {
            StreamInfo = StreamInfoBase;

            while (TRUE) 
            {
                Status = STATUS_SUCCESS;

                //
                //  Skip the default data stream since we've already copied
                //  it.  Alas, this code is NTFS specific and documented
                //  nowhere in the Io spec.
                //

                if (StreamInfo->StreamNameLength <= sizeof(WCHAR) ||
                    StreamInfo->StreamName[1] == ':') 
                {
                    if (StreamInfo->NextEntryOffset == 0)
                        break;      // all done with streams
                    StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                                    StreamInfo->NextEntryOffset);
                    continue;   // Move on to the next stream
                }

                //
                // Build a string descriptor for the name of the stream.
                //

                StreamName.Buffer = &StreamInfo->StreamName[0];
                StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                StreamName.MaximumLength = StreamName.Length;

                //
                // Open the source stream.
                //

                InitializeObjectAttributes( &ObjectAttributes,
                                            &StreamName,
                                            OBJ_KERNEL_HANDLE,
                                            SourceFileHandle,
                                            NULL );

                Status = SrIoCreateFile( &StreamHandle,
                                         GENERIC_READ
                                          |FILE_GENERIC_READ,
                                         &ObjectAttributes,
                                         &IoStatus,
                                         NULL,
                                         0,
                                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                         FILE_OPEN,
                                         SR_CREATE_FLAGS,
                                         NULL,
                                         0,
                                         IO_IGNORE_SHARE_ACCESS_CHECK,
                                         pExtension->pTargetDevice );

                if (!NT_SUCCESS(Status)) 
                    leave;
                    
                OutputStream = NULL;

                Status = SrCopyStream( StreamHandle,
                                       pExtension->pTargetDevice,
                                       &StreamName,
                                       DestFile,
                                       &StreamInfo->StreamSize,
                                       &OutputStream );
                        
                ZwClose(StreamHandle);
                StreamHandle = NULL;
                
                if (OutputStream != NULL) 
                {
                    //
                    //  We set the last write time on all streams
                    //  since there is a problem with RDR caching
                    //  open handles and closing them out of order.
                    //

                    if (NT_SUCCESS(Status)) 
                    {
                        Status = ZwSetInformationFile( OutputStream,
                                                       &IoStatus,
                                                       &BasicInformation,
                                                       sizeof(BasicInformation),
                                                       FileBasicInformation );
                    }

                    ZwClose(OutputStream);
                }


                if (!NT_SUCCESS( Status )) 
                    leave;

                //
                // remember how much we just copied
                //
                
                if (pBytesWritten != NULL)
                {
                    *pBytesWritten += StreamInfo->StreamSize.QuadPart;
                }

                //
                // anymore streams?
                //
                
                if (StreamInfo->NextEntryOffset == 0) 
                {
                    break;
                }

                //
                // move on to the next one
                //
                
                StreamInfo =
                    (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                               StreamInfo->NextEntryOffset);

            }   // while (TRUE)
            
        }   // if ( StreamInfoBase != NULL )


        //
        // set the last write time for the default steam so that it matches the
        // input file.
        //

        Status = ZwSetInformationFile( DestFile,
                                       &IoStatus,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       FileBasicInformation );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Now get the short file name for the file that we have successfully 
        //  backed up.  If we are backing up this file in response to a 
        //  modification of a named stream on this file, this is the only
        //  time we have a handle to the primary data stream.
        //
        
        if (pShortFileName != NULL)
        {

            Status = ObReferenceObjectByHandle( SourceFileHandle,
                                                0,
                                                *IoFileObjectType,
                                                KernelMode,
                                                &pSourceFileObject,
                                                NULL );
            if (!NT_SUCCESS( Status ))
                leave;

            //
            //  Use the pSourceFileObject to get the short name.
            //

            Status = SrGetShortFileName( pExtension,
                                         pSourceFileObject,
                                         pShortFileName );

            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                //
                //  This file doesn't have a short name.
                //

                Status = STATUS_SUCCESS;
            } 
            else if (!NT_SUCCESS(Status))
            {
                //
                //  We hit an unexpected error, so leave.
                //
                
                leave;
            }
        }
    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrBackupFile, Status);

        //
        // did we fail?
        //
        
        if ((Status != SR_STATUS_IGNORE_FILE) &&
            !NT_SUCCESS( Status ))
        {
            if (DestFile != NULL) 
            {
                //
                // delete the dest file
                //
                
                SrMarkFileForDelete(DestFile);
            }
        }

        if (DestFile != NULL) 
        {
            ZwClose(DestFile);
            DestFile = NULL;
        }

        if (pSourceFileObject != NULL)
        {
            ObDereferenceObject( pSourceFileObject );
            NULLPTR( pSourceFileObject );
        }
        if (SourceFileHandle != NULL) 
        {
            ZwClose(SourceFileHandle);
            SourceFileHandle = NULL;
        }

        if (StreamInfoBase != NULL) 
        {
            SR_FREE_POOL(StreamInfoBase, SR_STREAM_DATA_TAG);
            StreamInfoBase = NULL;
        }
    }   // finally

#if DBG
    if (Status == STATUS_FILE_IS_A_DIRECTORY)
    {
        return Status;
    }
#endif

    RETURN(Status);
}   // SrBackupFile





/*++

Routine Description:

    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:

    FileHandle - Supplies a handle to the file that is to be marked for delete.

Return Value:

    None.

--*/

NTSTATUS
SrMarkFileForDelete(
    HANDLE FileHandle
    )
{
#undef DeleteFile

    FILE_DISPOSITION_INFORMATION    DispositionInformation;
    IO_STATUS_BLOCK                 IoStatus;
    FILE_BASIC_INFORMATION          BasicInformation;
    NTSTATUS                        Status;

    PAGED_CODE();

    BasicInformation.FileAttributes = 0;
    
    Status = ZwQueryInformationFile( FileHandle,
                                     &IoStatus,
                                     &BasicInformation,
                                     sizeof(BasicInformation),
                                     FileBasicInformation );

    if (!NT_SUCCESS( Status ))
        goto end;

    if (BasicInformation.FileAttributes & FILE_ATTRIBUTE_READONLY) 
    {
        RtlZeroMemory(&BasicInformation, sizeof(BasicInformation));
        
        BasicInformation.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        
        Status = ZwSetInformationFile( FileHandle,
                                       &IoStatus,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       FileBasicInformation );

        if (!NT_SUCCESS( Status ))
            goto end;
    }

    RtlZeroMemory(&DispositionInformation, sizeof(DispositionInformation));
    
    DispositionInformation.DeleteFile = TRUE;
    
    Status = ZwSetInformationFile( FileHandle,
                                   &IoStatus,
                                   &DispositionInformation,
                                   sizeof(DispositionInformation),
                                   FileDispositionInformation );

    if (!NT_SUCCESS( Status ))
        goto end;

end:
    RETURN(Status);
    
}   // SrMarkFileForDelete


/***************************************************************************++

Routine Description:

    calls SrBackupFile then calls SrUpdateBytesWritten and SrLogEvent

Arguments:

    EventType - the event that occurred
    
    pFileObject - the file object that just changed
    
    pFileName - the name of the file that changed

    pDestFileName - the dest file to copy to

    CopyDataStreams - should we copy the data streams.

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS
SrBackupFileAndLog(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PUNICODE_STRING pFileName,
    IN PUNICODE_STRING pDestFileName,
    IN BOOLEAN CopyDataStreams
    )
{
    NTSTATUS    Status;
    ULONGLONG   BytesWritten;
    WCHAR           ShortFileNameBuffer[SR_SHORT_NAME_CHARS+1];
    UNICODE_STRING  ShortFileName;

    PAGED_CODE();

    RtlInitEmptyUnicodeString( &ShortFileName,
                               ShortFileNameBuffer,
                               sizeof(ShortFileNameBuffer) );

    //
    // backup the file
    //
    
    Status = SrBackupFile( pExtension,
                           pFileObject,
                           pFileName, 
                           pDestFileName, 
                           CopyDataStreams,
                           &BytesWritten,
                           &ShortFileName );

    if (Status == SR_STATUS_IGNORE_FILE)
    {
        //
        //  During the backup process we realized that we wanted to ignore
        //  this file, so change this status to STATUS_SUCCESS and don't
        //  try to log this operation.
        //
        
        Status = STATUS_SUCCESS;
        goto SrBackupFileAndLog_Exit;
    }
    else if (!NT_SUCCESS_NO_DBGBREAK( Status ))
    {
        goto SrBackupFileAndLog_Exit;
    }
    
    //
    // SrHandleFileOverwrite passes down SrEventInvalid which means it
    // doesn't want it logged yet.
    //
    
    if (EventType != SrEventInvalid)
    {
        //
        // Only update the bytes written if this is an event we want
        // to log.  Otherwise, this event doesn't affect the number
        // of bytes in the store.
        //

        Status = SrUpdateBytesWritten(pExtension, BytesWritten);
        
        if (!NT_SUCCESS( Status ))
        {
            goto SrBackupFileAndLog_Exit;
        }

		//
		//  Go ahead and log this event now.
		//
		
        Status = SrLogEvent( pExtension, 
                             EventType,
                             pFileObject,
                             pFileName,
                             0,
                             pDestFileName,
                             NULL,
                             0,
                             &ShortFileName );

        if (!NT_SUCCESS( Status ))
        {
            goto SrBackupFileAndLog_Exit;
        }
    }

SrBackupFileAndLog_Exit:

#if DBG

    //
    //  When dealing with modifications to streams on directories, this
    //  is a valid error code to return.
    //
    
    if (Status == STATUS_FILE_IS_A_DIRECTORY)
    {
        return Status;
    }
#endif 

    RETURN(Status);
}   // SrBackupFileAndLog

BOOLEAN
SrIsFileEncrypted (
    PSR_DEVICE_EXTENSION pExtension,
    PFILE_OBJECT pFileObject
    )
{
    FILE_BASIC_INFORMATION fileBasicInfo;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  First do a quick check to see if this volume supports encryption
    //  if we already have the file system attributes cached.
    //

    if (pExtension->CachedFsAttributes)
    {
        if (!FlagOn( pExtension->FsAttributes, FILE_SUPPORTS_ENCRYPTION ))
        {
            //
            //  The file system doesn't support encryption, therefore this
            //  file cannot be encrypted.
            return FALSE;
        }
    }

    status = SrQueryInformationFile( pExtension->pTargetDevice,
                                     pFileObject,
                                     &fileBasicInfo,
                                     sizeof( fileBasicInfo ),
                                     FileBasicInformation,
                                     NULL );

    if (!NT_SUCCESS( status ))
    {
        //
        //  We couldn't read the basic information for this file, so we must
        //  assume that it is not encrypted.
        //
        
        return FALSE;
    }

    if (FlagOn( fileBasicInfo.FileAttributes, FILE_ATTRIBUTE_ENCRYPTED ))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\dispatch.h ===
//depot/private/pch_m1/admin/pchealth/sr/kernel/dispatch.h#6 - edit change 19187 (text)
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

    contains prototypes for functions in dispatch.c

Author:

    Paul McDaniel (paulmcd)     01-March-2000

Revision History:

--*/


#ifndef _DISPATCH_H_
#define _DISPATCH_H_


NTSTATUS
SrMajorFunction(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SrPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrWrite (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SrSetHardLink(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pOriginalFileObject,
    IN PFILE_LINK_INFORMATION pLinkInformation
    );

NTSTATUS
SrSetSecurity (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrFsControlReparsePoint (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

NTSTATUS
SrFsControlMount (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

NTSTATUS
SrFsControlLockOrDismount (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

VOID
SrFsControlWriteRawEncrypted (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

VOID
SrFsControlSetSparse (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PIRP pIrp
    );

NTSTATUS
SrPnp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SrStopProcessingCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT EventToSignal
    );

NTSTATUS
SrShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    );

#endif // _DISPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\event.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    event.c

Abstract:

    This module contains the event handling logic for sr

    There are 3 main entrypoints to this module:

        SrHandleEvent
        SrHandleRename
        SrHandleDirectoryRename

Author:

    Paul McDaniel (paulmcd)     18-Apr-2000

Revision History:

--*/

#include "precomp.h"


//
// Private constants.
//

//
// event optimization defines
//


//
// Private types.
//

#define IS_VALID_TRIGGER_ITEM(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == SR_TRIGGER_ITEM_TAG))

typedef struct _SR_TRIGGER_ITEM
{
    //
    // PagedPool
    //

    //
    // = SR_TRIGGER_ITEM_TAG
    //
    
    ULONG               Signature;
    LIST_ENTRY          ListEntry;
    PUNICODE_STRING     pDirectoryName;
    BOOLEAN             FreeDirectoryName;
    HANDLE              DirectoryHandle;
    PFILE_OBJECT        pDirectoryObject;
    ULONG               FileEntryLength;
    PFILE_DIRECTORY_INFORMATION pFileEntry;

} SR_TRIGGER_ITEM, *PSR_TRIGGER_ITEM;

typedef struct _SR_COUNTED_EVENT
{
    //
    // NonPagedPool
    //
    
    LONG WorkItemCount;
    KEVENT Event;
    
} SR_COUNTED_EVENT, *PSR_COUNTED_EVENT;


#define IS_VALID_BACKUP_DIRECTORY_CONTEXT(pObject)   \
    (((pObject) != NULL) && ((pObject)->Signature == SR_BACKUP_DIRECTORY_CONTEXT_TAG))

typedef struct _SR_BACKUP_DIRECTORY_CONTEXT
{
    //
    // PagedPool
    //

    //
    // = SR_BACKUP_DIRECTORY_CONTEXT_TAG
    //

    ULONG Signature;
    
    WORK_QUEUE_ITEM WorkItem;

    PSR_DEVICE_EXTENSION pExtension;
    
    UNICODE_STRING DirectoryName;

    BOOLEAN EventDelete;

    PSR_COUNTED_EVENT pEvent;

} SR_BACKUP_DIRECTORY_CONTEXT, * PSR_BACKUP_DIRECTORY_CONTEXT;


//
// Private prototypes.
//

NTSTATUS
SrpIsFileStillEligible (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext,
    IN SR_EVENT_TYPE EventType,
    OUT PBOOLEAN pMonitorFile);

VOID
SrFreeTriggerItem (
    IN PSR_TRIGGER_ITEM pItem
    );

NTSTATUS
SrTriggerEvents (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pDirectoryName,
    IN BOOLEAN EventDelete
    );

NTSTATUS
SrHandleDelete(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext
    );

VOID
SrCreateRestoreLocationWorker (
    IN PSR_WORK_ITEM pWorkItem
    );

NTSTATUS
SrHandleFileChange (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PUNICODE_STRING pFileName
    );

NTSTATUS
SrHandleFileOverwrite(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN OUT PSR_OVERWRITE_INFO pOverwriteInfo,
    IN PSR_STREAM_CONTEXT pFileContext
    );

NTSTATUS
SrRenameFileIntoStore(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN HANDLE FileHandle,
    IN PUNICODE_STRING pOriginalFileName,
    IN PUNICODE_STRING pFileName,
    IN SR_EVENT_TYPE EventType,
    OUT PFILE_RENAME_INFORMATION * ppRenameInfo OPTIONAL
    );

//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrpIsFileStillEligible )
#pragma alloc_text( PAGE, SrHandleEvent )
#pragma alloc_text( PAGE, SrLogEvent )
#pragma alloc_text( PAGE, SrHandleDelete )
#pragma alloc_text( PAGE, SrCreateRestoreLocation )
#pragma alloc_text( PAGE, SrCreateRestoreLocationWorker )
#pragma alloc_text( PAGE, SrHandleFileChange )
#pragma alloc_text( PAGE, SrHandleFileOverwrite )
#pragma alloc_text( PAGE, SrRenameFileIntoStore )
#pragma alloc_text( PAGE, SrTriggerEvents )
#pragma alloc_text( PAGE, SrHandleDirectoryRename )
#pragma alloc_text( PAGE, SrHandleFileRenameOutOfMonitoredSpace )
#pragma alloc_text( PAGE, SrHandleOverwriteFailure )
#pragma alloc_text( PAGE, SrFreeTriggerItem )

#endif  // ALLOC_PRAGMA


//
// Private globals.
//

//
// Public globals.
//

//
// Public functions.
//


/***************************************************************************++

Routine Description:

    

Arguments:

Return Value:

    NTSTATUS - Completion status. can return STATUS_PENDING.

--***************************************************************************/
NTSTATUS
SrpIsFileStillEligible (
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PSR_STREAM_CONTEXT pFileContext,
    IN SR_EVENT_TYPE EventType,
    OUT PBOOLEAN pMonitorFile
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    *pMonitorFile = TRUE;

    //
    //  If is is not an overwrite, keep going
    //

    if (!(EventType & SrEventStreamOverwrite))
    {
        BOOLEAN HasBeenBackedUp;
        //
        // it is a match, but have we been told to skip it?
        // Since this routine can be called without the caller
        // having the activity lock acquired, we acquire it now
        //
    
        HasBeenBackedUp = SrHasFileBeenBackedUp( pExtension,
                                                 &pFileContext->FileName,
                                                 pFileContext->StreamNameLength,
                                                 EventType );

        if (HasBeenBackedUp)
        {
            //
            // skip it
            //
        
            *pMonitorFile = FALSE;

            SrTrace( CONTEXT_LOG, ("Sr!SrpIsFileStillEligible:NO:         (%p) Event=%06x Fl=%03x Use=%d \"%.*S\"\n",
                                   pFileContext,
                                   EventType,
                                   pFileContext->Flags,
                                   pFileContext->UseCount,
                                   (pFileContext->FileName.Length+
                                       pFileContext->StreamNameLength)/
                                       sizeof(WCHAR),
                                   pFileContext->FileName.Buffer));

            //
            // we are skipping this event due to the history, should we 
            // log it regardless ?
            //

            if (EventType & SR_ALWAYS_LOG_EVENT_TYPES)
            {
                status = SrLogEvent( pExtension,
                                     EventType,
                                     NULL,
                                     &pFileContext->FileName,
                                     RECORD_AGAINST_STREAM( EventType, 
                                                            pFileContext->StreamNameLength ),
                                     NULL,
                                     NULL,
                                     0,
                                     NULL );
            }
        }
    }

    return status;
}



/***************************************************************************++

Routine Description:

    this is the main entry point for event handling.

    anytime an interesting event happens this function is called to see 
    if this file is interesting to monitor, and then actually handles
    the event.

    it is possible for this to return STATUS_PENDING, in which case you must 
    call it again after the fsd see's the event so that it can do 
    post-processing.

    Delete is a case where this 2-step event handling happens.

Arguments:

    EventType - the event that just occured

    pOverwriteInfo - this is only supplied from an MJ_CREATE, for use in 
        overwrite optimizations
        
    pFileObject - the fileobject that the event occured on.
    
    pFileContext - Optionall a context structure that is passed in.  Most
        of the time it will be NULL.

Return Value:

    NTSTATUS - Completion status. can return STATUS_PENDING.

--***************************************************************************/
NTSTATUS
SrHandleEvent(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext OPTIONAL,
    IN OUT PSR_OVERWRITE_INFO pOverwriteInfo OPTIONAL,
    IN PUNICODE_STRING pFileName2 OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN releaseLock = FALSE;
    BOOLEAN releaseContext = FALSE;
    BOOLEAN isStillInteresting;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));

    try {    

        //
        //  If a context was not passed in then get it now.
        //

        if (pFileContext == NULL)
        {
            //
            //  Get the context for this operation.  Create always calls
            //  with the context parameter fill in so we can always so
            //  we are NOT in create from this routine
            //

            Status = SrGetContext( pExtension,
                                   pFileObject,
                                   EventType,
                                   &pFileContext );

            if (!NT_SUCCESS( Status ))
            {
                leave;
            }

            //
            //  We only want to release contexts which we have obtained
            //  ourselves.  Mark that we need to release this one
            //

            releaseContext = TRUE;
        }
        VALIDATE_FILENAME( &pFileContext->FileName );

#if DBG
        //
        //  Validate we have the correct directory state with the
        //  given event.
        //

        if ((EventType & (SrEventDirectoryCreate |
                          SrEventDirectoryRename |
                          SrEventDirectoryDelete |
                          SrEventMountCreate | 
                          SrEventMountDelete)) != 0)
        {
            ASSERT(FlagOn(pFileContext->Flags,CTXFL_IsDirectory));
        }

        if ((EventType & (SrEventFileCreate |
                          SrEventFileRename |
                          SrEventFileDelete |
                          SrEventStreamChange |
                          SrEventStreamOverwrite |
                          SrEventStreamCreate)) != 0)
        {
            ASSERT(!FlagOn(pFileContext->Flags,CTXFL_IsDirectory));
        }
#endif

        //
        //  If the file is not interesting, leave now
        //

        if (!FlagOn(pFileContext->Flags,CTXFL_IsInteresting))
        {
            leave;
        }

        //
        //  This looks to see if the file has already been backed up.
        //  If so it handles the appropriate logging and returns that
        //  the file is no longer eligible
        //

        Status = SrpIsFileStillEligible( pExtension,
                                         pFileContext,
                                         EventType,
                                         &isStillInteresting );

        if (!NT_SUCCESS( Status ) || !isStillInteresting)
        {
            leave;
        }

        //
        // Acquire the activity lock now
        //

        SrAcquireActivityLockShared( pExtension );
        releaseLock = TRUE;

        //
        //  Now that we've got the ActivityLock, make sure that the volume
        //  hasn't been disabled.
        //

        if (!SR_LOGGING_ENABLED(pExtension))
        {
            leave;
        }    

        //
        // now mark that we are handled this file.  it's IMPORTANT that 
        // we mark it PRIOR to handling the event, to prevent any potential
        // recursion issues with io related to handling this file+event.
        //

        if (EventType & SR_FULL_BACKUP_EVENT_TYPES)
        {
            //
            // if it's a full backup (or create) we don't care about 
            // subsequent mods
            //

            Status = SrMarkFileBackedUp( pExtension,
                                         &pFileContext->FileName,
                                         pFileContext->StreamNameLength,
                                         EventType,
                                         SR_IGNORABLE_EVENT_TYPES );
                                            
            if (!NT_SUCCESS( Status ))
                leave;
        }
        else if (EventType & SR_ONLY_ONCE_EVENT_TYPES)
        {
            Status = SrMarkFileBackedUp( pExtension, 
                                         &pFileContext->FileName,
                                         pFileContext->StreamNameLength,
                                         EventType,
                                         EventType );
            if (!NT_SUCCESS( Status ))
                leave;
        }
        
        //
        // should we short circuit out of here for testing mode?
        //

        if (global->DontBackup)
            leave;

        //
        // and now handle the event
        // a manual copy?
        //
                
        if ( FlagOn(EventType,SR_MANUAL_COPY_EVENTS) || 
             FlagOn(EventType,SrEventNoOptimization) )
        {
            ASSERT(!FlagOn(pFileContext->Flags,CTXFL_IsDirectory));

            //
            // copy the file, a change has occurred
            //
            
            Status = SrHandleFileChange( pExtension,
                                         EventType, 
                                         pFileObject, 
                                         &pFileContext->FileName );

            if (!NT_SUCCESS( Status ))
                leave;
        }

        //
        // we only handle clearing the FCB on delete's. do it now.
        // 

        else if ((FlagOn(EventType,SrEventFileDelete) ||
                  FlagOn(EventType,SrEventDirectoryDelete)) &&
                 !FlagOn(EventType,SrEventSimulatedDelete))
        {
            ASSERT(!FlagOn( EventType, SrEventNoOptimization ));
            
            //
            // handle deletes...
            //

            Status = SrHandleDelete( pExtension,
                                     pFileObject,
                                     pFileContext );

            //
            // nothing to do if this fails.  it already tried 
            // to manually copy if it had to.
            //
            
            if (!NT_SUCCESS( Status ))
                leave;

        }
        else if (FlagOn(EventType,SrEventStreamOverwrite))
        {
            ASSERT(IS_VALID_OVERWRITE_INFO(pOverwriteInfo));
            
            //
            // handle overwrites
            //

            Status = SrHandleFileOverwrite( pExtension,
                                            pOverwriteInfo, 
                                            pFileContext );

            if (!NT_SUCCESS( Status ))
                leave;

            //
            // this should really only fail if we can't open the file.
            // this means the caller can't also, so his create will fail
            // and we have no reason to copy anything.  
            //
            // if it fails it cleans up after itself.
            //
            // otherwise SrCreateCompletion checks more error scenarios
            //

        }
        else
        {
            SR_EVENT_TYPE eventToLog;
            
            //
            //  If we get to here, log the event
            //

            if (FlagOn( EventType, SrEventStreamCreate ))
            {
                eventToLog = SrEventFileCreate;
            }
            else
            {
                eventToLog = EventType;
            }

            Status = SrLogEvent( pExtension,
                                 eventToLog,
                                 pFileObject,
                                 &pFileContext->FileName,
                                 (FlagOn( EventType, SrEventStreamCreate ) ?
                                    pFileContext->StreamNameLength :
                                    0 ),
                                 NULL,
                                 pFileName2,
                                 0,
                                 NULL );
                                 
            if (!NT_SUCCESS( Status ))
                leave;
                                 
        }

        ASSERT(Status != STATUS_PENDING);

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrHandleEvent, Status);

        //
        // Check for any bad errors;  If the pFileContext is NULL,
        // this error was encountered in SrGetContext which already
        // generated the volume error.
        //

        if (CHECK_FOR_VOLUME_ERROR(Status) && pFileContext != NULL)
        {
            NTSTATUS TempStatus;
            
            //
            // trigger the failure notification to the service
            //

            TempStatus = SrNotifyVolumeError( pExtension,
                                              &pFileContext->FileName,
                                              Status,
                                              EventType );
                                             
            CHECK_STATUS(TempStatus);
        }
    
        //
        //  Cleanup state
        //

        if (releaseLock) 
        {
            SrReleaseActivityLock( pExtension );
        }

        if (releaseContext && (NULL != pFileContext))
        {
            SrReleaseContext( pFileContext );
            NULLPTR(pFileContext);
        }
    }

    RETURN(Status);
    
}   // SrHandleEvent


/***************************************************************************++

Routine Description:
    This function packs a log entry and then logs it.

Arguments:
    EventType - the event being handled
    
    pFileObject - the fileobject being handled

    pFileName - name of the file
    
    pTempName - name of the temp file if any
    
    pFileName2 - name of the dest file if any
    
Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrLogEvent(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject OPTIONAL,
    IN PUNICODE_STRING pFileName,
    IN USHORT FileNameStreamLength,
    IN PUNICODE_STRING pTempName OPTIONAL,
    IN PUNICODE_STRING pFileName2 OPTIONAL,
    IN USHORT FileName2StreamLength OPTIONAL,
    IN PUNICODE_STRING pShortName OPTIONAL
    )
{
    NTSTATUS        Status;
    PSR_LOG_ENTRY   pLogEntry  = NULL;
    PBYTE           pDebugBlob = NULL;
    
    ULONG           Attributes = 0xFFFFFFFF;    // note:paulmcd: this needs 
                                                // to be -1 as this 
                                                // communicates something 
                                                // special to the service 
                                                // when logged 
                                                
    ULONG           SecurityDescriptorSize = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptorPtr = NULL;

    WCHAR           ShortFileNameBuffer[SR_SHORT_NAME_CHARS+1];
    UNICODE_STRING  ShortFileName;

    PAGED_CODE();

    ASSERT(pFileName != NULL);
    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    VALIDATE_FILENAME( pFileName );

    //
    //  A stream creation event should be translated to a file create by this
    //  point.
    //
    
    ASSERT( !FlagOn( EventType, SrEventStreamCreate ) );

    try
    {

        Status = STATUS_SUCCESS;

        //
        // make sure we have the activity lock (we might not if we are 
        // called from IsFileEligible or SrNotifyVolumeError, 
        // you get the idea this function need to be callable from anywhere) .
        //

        SrAcquireActivityLockShared( pExtension );

        //
        // Verify we are still enabled
        //

        if (!SR_LOGGING_ENABLED(pExtension))
            leave;

        //
        // should we short circuit out of here for testing mode?
        //

        if (global->DontBackup)
            leave;

        //
        // mask out only the event code
        //
        
        EventType = EventType & SrEventLogMask ;

        if (pFileObject == NULL)
            goto log_it;
    
        //
        // For Attribute change/Directory delete operations, get the attributes.
        //
    
        if ( EventType & (SrEventAttribChange   |
                          SrEventDirectoryDelete|
                          SrEventFileDelete     |
                          SrEventStreamOverwrite|
                          SrEventStreamChange) )
        {
            FILE_BASIC_INFORMATION  BasicInformation;
    
            ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    
            //
            // we need to get the file attributes
            //

            Status = SrQueryInformationFile( pExtension->pTargetDevice,
                                             pFileObject, 
                                             &BasicInformation,
                                             sizeof( BasicInformation ),
                                             FileBasicInformation,
                                             NULL );

            if (!NT_SUCCESS( Status )) {

                leave;
            }

            Attributes = BasicInformation.FileAttributes;
        }
    
        if (EventType & (SrEventAclChange      |
                         SrEventDirectoryDelete|
                         SrEventStreamOverwrite|
                         SrEventStreamChange|
                         SrEventFileDelete) )
        {
            Status = SrGetAclInformation( pFileObject,
                                          pExtension,
                                          &SecurityDescriptorPtr,
                                          &SecurityDescriptorSize );
        
            if (!NT_SUCCESS(Status)) {
                leave;
            }


            //
            // did we get any acl info ?  if not and this was an aclchange
            // event it was triggered on fat and we need to ignore it
            //

            if (SecurityDescriptorPtr == NULL && 
                (EventType & SrEventAclChange))
            {

                //
                // ignore it
                //

                SrTrace( NOTIFY, ("sr!SrLogEvent: ignoring acl change on %wZ\n",
                         pFileName ));

                leave;

            }
            
        } 

        //
        //  Should we get the short name now?  Only need it if the name
        //  is changing via rename or delete.  When the name changes, we need
        //  to save the old name.  Sometimes the name is passed in, like in 
        //  the file delete case and the file is already gone when we log
        //  it, so this function can't get the short name.  If we are dealing
        //  with a file that has a named stream, it can't have a shortname
        //  so we don't need to check for one.
        //
        
        if ( (EventType & (SrEventFileRename     |
                           SrEventDirectoryRename|
                           SrEventFileDelete     |
                           SrEventDirectoryDelete))  && 
             (pShortName == NULL) &&
             (FileNameStreamLength == 0))
        {

            RtlInitEmptyUnicodeString( &ShortFileName,
                                       ShortFileNameBuffer,
                                       sizeof(ShortFileNameBuffer) );

            Status = SrGetShortFileName( pExtension, 
                                         pFileObject, 
                                         &ShortFileName );
                                         
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                //
                //  This file doesn't have a short name, so just leave 
                //  pShortName equal to NULL.
                //

                Status = STATUS_SUCCESS;
            } 
            else if (!NT_SUCCESS(Status))
            {
                //
                //  We hit an unexpected error, so leave.
                //
                
                leave;
            }
            else
            {
                pShortName = &ShortFileName;
            }
        }

log_it:    

        //
        // we need to make sure our disk structures are good and logging
        // has been started.
        //

        Status = SrCheckVolume(pExtension, FALSE);
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        //  Debug logging
        //

        SrTrace( LOG_EVENT, ("sr!SrLogEvent(%03X)%s: %.*ls [%wZ]\n",
                 EventType,
                 (FlagOn(EventType, SrEventFileDelete) && pFileObject == NULL) ? "[dummy]" : "",
                 (pFileName->Length + FileNameStreamLength)/sizeof( WCHAR ),
                 pFileName->Buffer ? pFileName->Buffer : L"",
                 pShortName ));

#if DBG
        if (EventType & (SrEventFileRename|SrEventDirectoryRename))
        {
            SrTrace( LOG_EVENT, ("                to  %.*ls\n",
                                 (pFileName2->Length + FileName2StreamLength)/sizeof(WCHAR),
                                 pFileName2->Buffer ? pFileName2->Buffer : L""));
        }
#endif        

        // 
        // Log it
        //
    
        if (DebugFlagSet( ADD_DEBUG_INFO ))
        {
            //
            // Get the debug info only in Checked build
            //

            pDebugBlob = SR_ALLOCATE_POOL( PagedPool, 
                                           SR_LOG_DEBUG_INFO_SIZE, 
                                           SR_DEBUG_BLOB_TAG );

            if ( pDebugBlob )
            {
                SrPackDebugInfo( pDebugBlob, SR_LOG_DEBUG_INFO_SIZE );
            }
        }

        //
        //  This routine will allocate a log entry of the appropriate size
        //  and fill it with the necessary data.  We are responsible for
        //  freeing the pLogEntry when we are through with it.
        //
        
        Status = SrPackLogEntry( &pLogEntry,
                                 EventType,
                                 Attributes,
                                 0,
                                 SecurityDescriptorPtr,
                                 SecurityDescriptorSize,
                                 pDebugBlob,
                                 pFileName,
                                 FileNameStreamLength,
                                 pTempName,
                                 pFileName2,
                                 FileName2StreamLength,
                                 pExtension,
                                 pShortName );

        if (!NT_SUCCESS( Status ))
        {
            leave;
        }
            
        //
        // Get the sequence number and log the entry
        // 

        Status = SrGetNextSeqNumber(&pLogEntry->SequenceNum);
        if (!NT_SUCCESS( Status ))
            leave;
            
        //
        // and write the log entry
        //
        
        Status = SrLogWrite( pExtension, 
                             NULL,
                             pLogEntry );
                             
        if (!NT_SUCCESS(Status)) {
            leave;
        }

    } 
    finally
    {
        Status = FinallyUnwind(SrLogEvent, Status);

        SrReleaseActivityLock( pExtension );
    
        if (pLogEntry)
        {
            SrFreeLogEntry( pLogEntry );
            pLogEntry = NULL;
        }
    
        if (SecurityDescriptorPtr)
        {
            SR_FREE_POOL( SecurityDescriptorPtr,  SR_SECURITY_DATA_TAG );
            SecurityDescriptorPtr = NULL;
        }

        if ( pDebugBlob )
        {
            SR_FREE_POOL(pDebugBlob, SR_DEBUG_BLOB_TAG);
            pDebugBlob = NULL;
        }
    }

    RETURN(Status);
}


/***************************************************************************++

Routine Description:
    this will perform delete functions prior to the fsd seeing 
    the mj_cleanup we are in the middle of intercepting.

    this means either copyfile (if another handle is open) or renaming the 
    file into our store and undeleting it.

Arguments:

    pExtension - SR's device extension for this volume.
    pFileObject - the file that is being deleted.  we temporarily
        undelete it.
    pFileContext - SR's context for this file.

Return Value:

    NTSTATUS - Completion status. can return STATUS_PENDING.

--***************************************************************************/
NTSTATUS
SrHandleDelete(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              NewFileHandle = NULL;
    PFILE_OBJECT        pNewFileObject = NULL;
    BOOLEAN             DeleteFile = FALSE;
    ULONG               NumberOfLinks;
#   define              OPEN_WITH_DELETE_PENDING_RETRY_COUNT 5
    INT                 openRetryCount;
    BOOLEAN             IsDirectory;
    FILE_DISPOSITION_INFORMATION DeleteInfo;
    SRP_NAME_CONTROL    OriginalFileName;
    PUNICODE_STRING     pOriginalFileName;
    BOOLEAN             cleanupNameCtrl = FALSE;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(pFileContext != NULL);
    ASSERT(pFileContext->FileName.Length > 0);
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT( ExIsResourceAcquiredShared( &pExtension->ActivityLock ) );

    IsDirectory = BooleanFlagOn(pFileContext->Flags,CTXFL_IsDirectory);

    try {

        if (!IsDirectory)
        {
            //
            //  If this is not a directory, we need to get the original name that
            //  the user used to open this file so that we properly maintain
            //  the name tunneling that the system provides.
            //

            SrpInitNameControl( &OriginalFileName );
            cleanupNameCtrl = TRUE;
            Status = SrpGetFileName( pExtension,
                                     pFileObject,
                                     &OriginalFileName );

            if (!NT_SUCCESS( Status ))
                leave;

            //
            //  We've got the name that the user originally opened the file
            //  with.  We don't want to do anything to normalize the name
            //  because to ensure that we don't break name tunneling we want to
            //  use the same name that the user used to do our rename into the
            //  store.  We have our normalized name for this file in the file
            //  context and we will use that for all logging purposes.

            pOriginalFileName = &(OriginalFileName.Name);
        }
        else
        {
            pOriginalFileName = &(pFileContext->FileName);
        }

        RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

        //
        // Setup now for the open we are doing
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pOriginalFileName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        //
        //  Someone might delete the file between the time we mark the file
        //  undeleted and the time we open it.  We will try a few times
        //  before giving up.
        //

        for (openRetryCount=OPEN_WITH_DELETE_PENDING_RETRY_COUNT;;) {

            //
            // undelete the file so that i can create a new FILE_OBJECT for this
            // file.  i need to create a new FILE_OBJECT in order to get a HANDLE.
            // i can't get a handle of off this file object as the handle count is 0,
            // we are processing this in CLEANUP.
            //

            DeleteInfo.DeleteFile = FALSE;

            Status = SrSetInformationFile( pExtension->pTargetDevice,
                                           pFileObject,
                                           &DeleteInfo,
                                           sizeof(DeleteInfo),
                                           FileDispositionInformation );

            if (!NT_SUCCESS( Status ))
                leave;
            
            //
            // make sure to "re" delete the file later
            //

            DeleteFile = TRUE;

            //
            //  Open the file.
            //
            //  This open and all operations on this handle will only be seen by
            //  filters BELOW SR on the filter stack.
            //

            Status = SrIoCreateFile( &NewFileHandle,
                                     FILE_READ_ATTRIBUTES|SYNCHRONIZE,
                                     &ObjectAttributes,
                                     &IoStatusBlock,
                                     NULL,
                                     FILE_ATTRIBUTE_NORMAL,
                                     FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                     FILE_OPEN_IF,                    //  OPEN_ALWAYS
                                     FILE_SYNCHRONOUS_IO_NONALERT
                                      | FILE_WRITE_THROUGH
                                      | (IsDirectory ? FILE_DIRECTORY_FILE : 0)
                                      | FILE_OPEN_FOR_BACKUP_INTENT,
                                     NULL,
                                     0,                                   // EaLength
                                     IO_IGNORE_SHARE_ACCESS_CHECK,
                                     pExtension->pTargetDevice );

            //
            //  If we don't get STATUS_DELETE_PENDING just go on
            //

            if (STATUS_DELETE_PENDING != Status) {

                break;
            }

            //
            //  If we get STATUS_DELETE_PENDING then someone did a
            //  SetInformation to mark the file for delete between the time
            //  we cleared the state and did the open.  We are simply going to
            //  try this again.  After too many retries we will fail the
            //  operation and return.
            //

            if (--openRetryCount <= 0) {

                SrTrace( NOTIFY, ("sr!SrHandleDelete: Tried %d times to open \"%wZ\", status is still STATUS_DELETE_PENDING, giving up\n",
                        OPEN_WITH_DELETE_PENDING_RETRY_COUNT,
                        &(pFileContext->FileName)));
                leave;
            }
        }

        //
        //  If we get this error it means we found a reparse point on a file
        //  and the filter that handles it is gone.  We can not copy the file
        //  so give that up.  After pondering it was decided that we should
        //  not stop logging so we will clear the error and return.
        //

        if (STATUS_IO_REPARSE_TAG_NOT_HANDLED == Status ||
            STATUS_REPARSE_POINT_NOT_RESOLVED == Status)
        {
            SrTrace( NOTIFY, ("sr!SrHandleDelete: Error %x ignored trying to open \"%wZ\" for copy\n",
                    Status,
                    &(pFileContext->FileName) ));

            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  Any other error should quit
        //

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // reference the file object
        //

        Status = ObReferenceObjectByHandle( NewFileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pNewFileObject,
                                            NULL );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // handle directory delete's
        //

        if (IsDirectory)
        {
            //
            // Log the event
            //

            Status = SrLogEvent ( pExtension,
                                  SrEventDirectoryDelete,
                                  pNewFileObject,
                                  &(pFileContext->FileName),
                                  pFileContext->StreamNameLength,
                                  NULL,         // pTempName
                                  NULL,         // pFileName2
                                  0,
                                  NULL );       // pShortName

            if (!NT_SUCCESS( Status ))
                leave;

            //
            // all done
            //

            leave;
        }

        //
        //  Check to make sure that this is not a delete of a stream.  If
        //  there is no stream name, we may be able to do our rename 
        //  optimization instead of doing a full backup.
        // 

        if (pFileContext->StreamNameLength == 0)
        {
            //
            // how many links does this file have?
            //
            
            Status = SrGetNumberOfLinks( pExtension->pTargetDevice,
                                         pNewFileObject,
                                         &NumberOfLinks);
            if (!NT_SUCCESS( Status )) {
                leave;
            }

            if (NumberOfLinks <= 1) {
                
                //
                //  Try to do the rename optimization here to just rename the 
                //  file about to be deleted into our store.  If this fails, we will
                //  try to just do a full backup of the file.
                //
                //  If the rename succeeds, this will also log the action.
                //

                ASSERT( pOriginalFileName != NULL );
                Status = SrRenameFileIntoStore( pExtension,
                                                pNewFileObject, 
                                                NewFileHandle,
                                                pOriginalFileName,
                                                &(pFileContext->FileName),
                                                SrEventFileDelete,
                                                NULL );
                                                
                if (NT_SUCCESS( Status )) {
                
                    //
                    //  Mark this file context as uninteresting now that it is 
                    //  renamed into the store.
                    //

                    SrMakeContextUninteresting( pFileContext );
                    
                    //
                    //  The rename was successful, so we do not need to re-delete
                    //  the file.
                    //
                    
                    DeleteFile = FALSE;

                    leave;
                }
            }
        }

        //
        //  We either couldn't do the rename optimization (because this is a 
        //  stream delete or the file has hardlinks) or the rename optimization 
        //  failed, so just do a full copy of the file as if a change happened.
        //  Do this AFTER we undelete the file so that the NtCreateFile will 
        //  work in SrBackupFile.  We will re-delete the file when we are 
        //  finished.
        //

        Status = SrHandleFileChange( pExtension,
                                     SrEventFileDelete, 
                                     pNewFileObject, 
                                     &(pFileContext->FileName) );

        if (Status == STATUS_FILE_IS_A_DIRECTORY)
        {
            //
            //  This is a change to a stream on a directory.  For now these
            //  operations are not supported, so we will just ignore this
            //  operation.
            //

            Status = STATUS_SUCCESS;
        }

        CHECK_STATUS( Status );

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrHandleDelete, Status);

        if (DeleteFile)
        {
            NTSTATUS TempStatus;
            
            //
            // "re" delete the file again, we are all done
            //

            DeleteInfo.DeleteFile = TRUE;

            TempStatus = SrSetInformationFile( pExtension->pTargetDevice,
                                               pFileObject,
                                               &DeleteInfo,
                                               sizeof(DeleteInfo),
                                               FileDispositionInformation );

            //
            // bug#173339: ntfs apparently will not let you delete an already
            // deleted file.  this file could have been deleted again while 
            // we were in the middle of processing as we are aborting here
            // due to multiple opens.  attempt to undelete it and delete it
            // to prove that this is the case.
            //
            
            if (TempStatus == STATUS_CANNOT_DELETE ||
                TempStatus == STATUS_DIRECTORY_NOT_EMPTY)
            {
                TempStatus = STATUS_SUCCESS;
            }

            CHECK_STATUS(TempStatus);

        }

        if (pNewFileObject != NULL)
        {
            ObDereferenceObject(pNewFileObject);
        }

        if (NewFileHandle != NULL)
        {
            ZwClose(NewFileHandle);
        }

        if (cleanupNameCtrl)
        {
            SrpCleanupNameControl( &OriginalFileName );
        }            
    }  

    RETURN(Status);
}   // SrHandleDelete

/***************************************************************************++

Routine Description:

    this will create a fresh restore location and current restore point.  
    it queue's off to the EX work queue to make sure that we are running in 
    the system token context so that we can access protected directories.

Arguments:

    pNtVolumeName - the nt name of the volume

Return Value:

    NTSTATUS - Completion status. 

--***************************************************************************/
NTSTATUS
SrCreateRestoreLocation(
    IN PSR_DEVICE_EXTENSION pExtension
    )
{
    NTSTATUS        Status;
    SR_WORK_ITEM    WorkItem;

    PAGED_CODE();

    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );
    
    ASSERT(IS_ACTIVITY_LOCK_ACQUIRED_EXCLUSIVE( pExtension ) ||
           IS_LOG_LOCK_ACQUIRED_EXCLUSIVE( pExtension ));

    //
    //  We need to create a new restore location
    //

    RtlZeroMemory( &WorkItem, sizeof(SR_WORK_ITEM) );
    
    WorkItem.Signature = SR_WORK_ITEM_TAG;
    KeInitializeEvent( &WorkItem.Event, NotificationEvent, FALSE );
    WorkItem.Parameter1 = pExtension;

    //
    //  Queue this off to another thread so that our thread token is 
    //  NT AUTHORITY\SYSTEM.  This way we can access the system volume info
    //  folder .
    //

    ExInitializeWorkItem( &WorkItem.WorkItem,
                          &SrCreateRestoreLocationWorker,
                          &WorkItem );

    ExQueueWorkItem( &WorkItem.WorkItem,
                     CriticalWorkQueue  );

    //
    //  Wait for it to finish
    //

    Status = KeWaitForSingleObject( &WorkItem.Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );

    ASSERT(NT_SUCCESS(Status));

    //
    //  Get the status code
    //

    RETURN( WorkItem.Status );
}

/***************************************************************************++

Routine Description:

    this will create a fresh restore location and current restore point.  
    this is run off the EX work queue to make sure that we are running in 
    the system token context so that we can access protected directories.

Arguments:

    pContext - the context (Parameter 1 is the nt name of the volume)

--***************************************************************************/
VOID
SrCreateRestoreLocationWorker(
    IN PSR_WORK_ITEM pWorkItem
    )
{
    NTSTATUS            Status;
    HANDLE              Handle = NULL;
    ULONG               CharCount;
    PUNICODE_STRING     pDirectoryName = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PSR_DEVICE_EXTENSION pExtension;
    PUNICODE_STRING     pVolumeName;
    BOOLEAN             DirectoryCreated;
    
    struct {
        FILE_FS_ATTRIBUTE_INFORMATION Info;
        WCHAR Buffer[ 50 ];
    } FileFsAttrInfoBuffer;

    ASSERT(IS_VALID_WORK_ITEM(pWorkItem));

    PAGED_CODE();

    pExtension = (PSR_DEVICE_EXTENSION) pWorkItem->Parameter1;
    ASSERT( IS_VALID_SR_DEVICE_EXTENSION( pExtension ) );
    
    pVolumeName = pExtension->pNtVolumeName;
    ASSERT(pVolumeName != NULL);

    RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));
    
    //
    //  grab a filename buffer
    //

    Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pDirectoryName);
    
    if (!NT_SUCCESS( Status )) {
        
        goto SrCreateRestoreLocationWorker_Cleanup;
    }

    //
    //  First make sure the system volume info directory is there
    //

    /* ISSUE-mollybro-2002-04-05 SR cannot use RtlCreateSystemVolumeInformationFolder API to create this directory.

        We explicitly do NOT use the routine RtlCreateSystemVolumeInformationFolder
        here because of a concern about recursion.  We are holding the volume's 
        activity lock exclusive when we spawn this worker thread to create our
        directories.  The Rtl routine will issue IOs to the top of the fs stack
        which could cause filters above us to generate IO on this volume in this
        worker thread that would deadlock with the thread that is waiting for this
        worker thread to finished this initialization work.
        
        For Longhorn, we should consider how to work around this so that SR can
        use the common RtlCreateSystemVolumeInformationFolder API, but for now we
        will continue to do this ourselves until we can rearchitect things to
        avoid these potential deadlocks.
    
    */

    CharCount = swprintf( pDirectoryName->Buffer,
                          VOLUME_FORMAT SYSTEM_VOLUME_INFORMATION,
                          pVolumeName );

    pDirectoryName->Length = (USHORT)CharCount * sizeof(WCHAR);

    InitializeObjectAttributes( &ObjectAttributes,
                                pDirectoryName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    Status = SrIoCreateFile( &Handle,
                             FILE_LIST_DIRECTORY 
                              |WRITE_OWNER|WRITE_DAC|SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL
                              | FILE_ATTRIBUTE_HIDDEN
                              | FILE_ATTRIBUTE_SYSTEM,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN_IF,                    //  OPEN_ALWAYS
                             FILE_DIRECTORY_FILE 
                              | FILE_WRITE_THROUGH
                              | FILE_SYNCHRONOUS_IO_NONALERT 
                              | FILE_OPEN_FOR_BACKUP_INTENT,
                             NULL,
                             0,                                 // EaLength
                             0,
                             pExtension->pTargetDevice );
    
    if (!NT_SUCCESS( Status )) {
        goto SrCreateRestoreLocationWorker_Cleanup;
    }

    DirectoryCreated = (IoStatusBlock.Information != FILE_OPENED);
    
    //
    //  Query for the volume properties to see if this volume supports
    //  ACLs or compression.
    //

    Status = ZwQueryVolumeInformationFile( Handle,
                                           &IoStatusBlock,
                                           &FileFsAttrInfoBuffer.Info,
                                           sizeof(FileFsAttrInfoBuffer),
                                           FileFsAttributeInformation );
                                           
    if (!NT_SUCCESS( Status )) {
        
        goto SrCreateRestoreLocationWorker_Cleanup;
    }

    //
    //  If we created the System Volume Information directory and this volume
    //  supports ACLs, we now need to put ACLs on this directory.
    //
    
    if (DirectoryCreated &&
        FlagOn( FileFsAttrInfoBuffer.Info.FileSystemAttributes, FILE_PERSISTENT_ACLS )) {

        SrTrace(NOTIFY, ("sr!srCreateRestoreLocation: setting ACL on sysvolinfo\n"));
        
        //
        // put the local system dacl on the folder (not so bad if it fails)
        //

        Status = SrSetFileSecurity( Handle, SrAclTypeSystemVolumeInformationDirectory );

        if (!NT_SUCCESS( Status )) {

            goto SrCreateRestoreLocationWorker_Cleanup;
        }
    }

    //
    //  We are done with the SVI handle, so close it.
    //

    ZwClose( Handle );
    Handle = NULL;

    //
    // and now create our _restore directory 
    //

    CharCount = swprintf( pDirectoryName->Buffer,
                          VOLUME_FORMAT RESTORE_LOCATION,
                          pVolumeName,
                          global->MachineGuid );

    pDirectoryName->Length = (USHORT)CharCount * sizeof(WCHAR);


    InitializeObjectAttributes( &ObjectAttributes,
                                pDirectoryName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    Status = SrIoCreateFile( &Handle,
                             FILE_LIST_DIRECTORY 
                              |WRITE_OWNER|WRITE_DAC|SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_NOT_CONTENT_INDEXED,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN_IF,                    //  OPEN_ALWAYS
                             FILE_DIRECTORY_FILE 
                              | FILE_SYNCHRONOUS_IO_NONALERT 
                              | FILE_WRITE_THROUGH 
                              | FILE_OPEN_FOR_BACKUP_INTENT,
                             NULL,
                             0,                                 // EaLength
                             0,
                             pExtension->pTargetDevice );

    if (!NT_SUCCESS( Status )) {
        
        goto SrCreateRestoreLocationWorker_Cleanup;
    }

    //
    //  Make sure the ACL and compression are set correctly
    //

    if ((IoStatusBlock.Information == FILE_OPENED) ||
        (IoStatusBlock.Information == FILE_CREATED)) {
        
        USHORT CompressionState;

        if (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_PERSISTENT_ACLS) {
            
            SrTrace(NOTIFY, ("sr!srCreateRestoreLocation: setting ACL on _restore{}\n"));

            //
            //  This volume supports ACLS, so set the proper ACLs on the _restore
            //  directory.
            //

            Status = SrSetFileSecurity( Handle, SrAclTypeRestoreDirectoryAndFiles );
            
            if (!NT_SUCCESS( Status )) {
                
                goto SrCreateRestoreLocationWorker_Cleanup;
            }
        }

        if (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_FILE_COMPRESSION) {
            
            //
            // Ensure that this folder is NOT marked for compression.
            // This inherits down to files created later in this folder.  This
            // should speed up our writes for copies and decrease the chance
            // of stack overflow while we are doing our backup operations.
            //
            // The service will come along and compress the file in the
            // directory at a later time.
            //

            CompressionState = COMPRESSION_FORMAT_NONE;
            
            Status = ZwFsControlFile( Handle,
                                      NULL,     // Event
                                      NULL,     // ApcRoutine
                                      NULL,     // ApcContext
                                      &IoStatusBlock,
                                      FSCTL_SET_COMPRESSION,
                                      &CompressionState,
                                      sizeof(CompressionState),
                                      NULL,     // OutputBuffer
                                      0 );
                                      
            ASSERT(Status != STATUS_PENDING);
            CHECK_STATUS(Status);
        }
    }

    //
    //  All done (just needed to create it)
    //
    
    ZwClose(Handle);
    Handle = NULL;

    //
    //  Now we need to create our current restore point sub directory
    //

    //
    //  We don't need to acquire a lock to read the current restore location
    //  because whoever scheduled this workitem already has the ActivityLock 
    //  and will not release it until we return.  This will prevent the 
    //  value from changing.
    //
    
    CharCount = swprintf( &pDirectoryName->Buffer[pDirectoryName->Length/sizeof(WCHAR)],
                          L"\\" RESTORE_POINT_PREFIX L"%d",
                          global->FileConfig.CurrentRestoreNumber );

    pDirectoryName->Length += (USHORT)CharCount * sizeof(WCHAR);

    InitializeObjectAttributes( &ObjectAttributes,
                                pDirectoryName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    Status = SrIoCreateFile( &Handle,
                             FILE_LIST_DIRECTORY | SYNCHRONIZE,
                             &ObjectAttributes,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                             FILE_OPEN_IF,                    //  OPEN_ALWAYS
                             FILE_DIRECTORY_FILE 
                              | FILE_WRITE_THROUGH
                              | FILE_SYNCHRONOUS_IO_NONALERT 
                              | FILE_OPEN_FOR_BACKUP_INTENT,
                             NULL,
                             0,                                 // EaLength
                             0,
                             pExtension->pTargetDevice );

    if (!NT_SUCCESS( Status )) {
        
        goto SrCreateRestoreLocationWorker_Cleanup;
    }

    //
    //  Again, if we created this directory, we need to set the ACL on it.
    //
    
    if (IoStatusBlock.Information != FILE_OPENED) {
        
        if (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_PERSISTENT_ACLS) {
            
            SrTrace(NOTIFY, ("sr!srCreateRestoreLocation: setting ACL on RP\n"));

            //
            //  This volume supports ACLS, so set the proper ACLs on the _restore
            //  directory.
            //

            Status = SrSetFileSecurity( Handle, SrAclTypeRPDirectory );
            
            if (!NT_SUCCESS( Status )) {
                
                goto SrCreateRestoreLocationWorker_Cleanup;
            }
        }
    }

    //
    // all done (just needed to create it)  no acl's on this subfolder,
    // it inherit from the parent (everyone=full control)
    //
    
    ZwClose(Handle);
    Handle = NULL;

    SrTrace( NOTIFY, ("SR!SrCreateRestoreLocationWorker(%wZ)\n", 
             pVolumeName ));


SrCreateRestoreLocationWorker_Cleanup:

    if (Handle != NULL)
    {
        ZwClose(Handle);
        Handle = NULL;
    }

    if (pDirectoryName != NULL)
    {
        SrFreeFileNameBuffer(pDirectoryName);
        pDirectoryName = NULL;
    }

    pWorkItem->Status = Status;
    KeSetEvent(&pWorkItem->Event, 0, FALSE);
}   // SrCreateRestoreLocationWorker


/***************************************************************************++

Routine Description:

    this handles any change event to the file that requires the file to be 
    copied.  it generates the dest file name then copies the source file to 
    the dest file.

Arguments:

    EventType - the event that occurred
    
    pFileObject - the file object that just changed
    
    pFileName - the name of the file that changed

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS
SrHandleFileChange(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN SR_EVENT_TYPE EventType,
    IN PFILE_OBJECT pFileObject,
    IN PUNICODE_STRING pFileName
    )
{
    NTSTATUS        Status;
    PUNICODE_STRING pDestFileName = NULL;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(pFileName != NULL);
    ASSERT( ExIsResourceAcquiredShared( &pExtension->ActivityLock ) );

    //
    // we need to make sure our disk structures are good and logging
    // has been started.
    //

    Status = SrCheckVolume(pExtension, FALSE);
    if (!NT_SUCCESS( Status ))
        goto end;

    //
    // get the name of the destination file for this guy
    //

    Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pDestFileName);
    if (!NT_SUCCESS( Status ))
        goto end;

    Status = SrGetDestFileName( pExtension,
                                pFileName, 
                                pDestFileName );
                                
    if (!NT_SUCCESS_NO_DBGBREAK( Status ))
        goto end;

    Status = SrBackupFileAndLog( pExtension,
                                 EventType,
                                 pFileObject,
                                 pFileName,
                                 pDestFileName,
                                 TRUE );

    if (!NT_SUCCESS_NO_DBGBREAK( Status ))
        goto end;

end:

    if (pDestFileName != NULL)
    {
        SrFreeFileNameBuffer(pDestFileName);
        pDestFileName = NULL;
    }
    
#if DBG

    //
    //  When dealing with modifications to streams on directories, this
    //  is a valid error code to return.
    //
    
    if (Status == STATUS_FILE_IS_A_DIRECTORY)
    {
        return Status;
    }
#endif 

    RETURN(Status);
}   // SrHandleFileChange


/***************************************************************************++

Routine Description:

    this will perform the optimization for overwrites.  this consists of a 
    rename and empty file create so that the caller will be allowed to 
    overwrite like normal.

    //  NOTE:   MollyBro    7-Dec-2000
    //
    //  We cannot use the RENAME optimization here because we create
    //  the following window --
    //      Between the time we rename the file into our store and the
    //      time we create the stub file to take its place, there is no
    //      file by this name in the directory.  Another request
    //      could come in and try to create this same file with the 
    //      FILE_CREATE flag set.  This operation would then succeed
    //      when it would have failed had SR not been doing its work.
    // 
    //  This is likely to break apps in hard-to-repeat ways, so just to
    //  be safe, we will do a full backup here.
    //  

Arguments:

    pFileObject - the file object that just changed
    
    pFileName - the name of the file

Return Value:

    NTSTATUS - Completion status. 

    see comments above.
    
--***************************************************************************/
NTSTATUS
SrHandleFileOverwrite(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN OUT PSR_OVERWRITE_INFO pOverwriteInfo,
    IN PSR_STREAM_CONTEXT pFileContext
    )
{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  pIrpSp;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              FileHandle = NULL;
    PFILE_OBJECT        pFileObject = NULL;
    IO_STATUS_BLOCK     IoStatusBlock;
    ULONG               DesiredAccess;
    ULONG               DesiredAttributes;
    ULONG               CreateOptions;
    BOOLEAN             SharingViolation = FALSE;
    BOOLEAN             MarkFile = FALSE;
    BOOLEAN             MountInPath = FALSE;
    PUNICODE_STRING     pTempFileName = NULL;
    HANDLE              TempFileHandle = NULL;
    PUNICODE_STRING     pFileName;

#if 0 /* NO_RENAME --- See note in function header block */
    BOOLEAN             RenamedFile = FALSE;
    PFILE_RENAME_INFORMATION pRenameInformation = NULL;
#endif

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_OVERWRITE_INFO(pOverwriteInfo));
    ASSERT(IS_VALID_IRP(pOverwriteInfo->pIrp));
    ASSERT(pFileContext != NULL);
    pFileName = &(pFileContext->FileName);
    
    ASSERT( ExIsResourceAcquiredShared( &pExtension->ActivityLock ) );
        
    try {

        pIrpSp = IoGetCurrentIrpStackLocation(pOverwriteInfo->pIrp);

        //
        // we are now all done with the inputs, clear the outputs
        //
        
        RtlZeroMemory(pOverwriteInfo, sizeof(*pOverwriteInfo));
        pOverwriteInfo->Signature = SR_OVERWRITE_INFO_TAG;

        Status = STATUS_SUCCESS;

        //
        // we need to use a combination of the caller's requested desired
        // access and the minimum required desired access to overwite a file.
        //
        // this way we gaurantee that if this NtCreateFile works, than the 
        // callers MJ_CREATE would also work.  we absolutely need to avoid any 
        // possibilty of the driver's NtCreateFile working in a scenario that 
        // the user-mode MJ_CREATE will subsequently fail.  if that were to 
        // happen, we would have overwritten the file when normally it would 
        // have failed, thus changing the behaviour of the os.  very bad.
        //

        //
        // start with the callers access requested
        //

        if (pIrpSp->Parameters.Create.SecurityContext == NULL)
        {
            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }
        
        DesiredAccess = pIrpSp->Parameters.Create.SecurityContext->DesiredAccess;

        //
        // now add on FILE_GENERIC_WRITE .
        //
        // FILE_GENERIC_WRITE is the least amount of access you must be able to 
        // get to overwrite a file.  you don't have to ask for it, but you 
        // must have it.  that is.. you can ask for READ access with overwrite 
        // specified, and the file will be overwritten, only if you had 
        // FILE_GENERIC_WRITE in addition to the read access
        //
        
        DesiredAccess |= FILE_GENERIC_WRITE;

        //
        // BUGBUG: the check for matching attributes only happens if OVERWRITE is 
        // set.  we might need to manually check this .  paulmcd 5/3/2000
        //
        
        DesiredAttributes = pIrpSp->Parameters.Create.FileAttributes;

        //
        // pass them back so that create can fix it if it fails really bad
        //
        
        pOverwriteInfo->CreateFileAttributes = DesiredAttributes;

        //
        // first open the file to see if there is one there
        //
        
        InitializeObjectAttributes( &ObjectAttributes,
                                    pFileName,
                                    OBJ_KERNEL_HANDLE          // don't let usermode trash myhandle
                                        |OBJ_FORCE_ACCESS_CHECK,    // force ACL checking
                                    NULL,                  // Root Directory
                                    NULL );

        //
        //  Setup the CreateOptions.  Always use FILE_SYNCHRONOUS_IO_NONALERT,
        //  but propagate FILE_OPEN_FOR_BACKUP_INTENT if that is set in the
        //  FullCreateOptions.
        //

        CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH;


        if (FlagOn( pIrpSp->Parameters.Create.SecurityContext->FullCreateOptions, 
                    FILE_OPEN_FOR_BACKUP_INTENT )) {

            SetFlag( CreateOptions, FILE_OPEN_FOR_BACKUP_INTENT );
        }

#if 0 /* NO_RENAME --- See note in function header block */
        //
        // notice the ShareAccess is set to 0.  we want this file exclusive.
        // if there are any other opens.. this optimization will fail and 
        // we'll copy the file manually.
        //

        //
        // BUGBUG: paulmcd 5/31 . what if this is an EFS file being OpenRaw'd 
        //  it doesn't require FILE_GENERIC_WRITE .
        //

        Status = ZwCreateFile( &FileHandle,
                               DesiredAccess,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                            // AllocationSize
                               DesiredAttributes,
                               0,                               // ShareAccess
                               FILE_OPEN,                       // OPEN_EXISTING
                               CreateOptions,
                               NULL,
                               0 );                             // EaLength

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {

            //
            // this is ok.. the file that is being overwritten (at least 
            // CREATE_ALWAYS) doesn't exist.  nothing to backup.
            //

            //
            // we log this in SrCreateCompletion so that we know the create
            // worked first
            //

            Status = STATUS_SUCCESS;
            leave;
        }
        else if (Status == STATUS_SHARING_VIOLATION)
        {
            SharingViolation = TRUE;
            Status = STATUS_SUCCESS;
        }
        else if (Status == STATUS_OBJECT_NAME_INVALID ||
                 Status == STATUS_OBJECT_PATH_INVALID ||
                 Status == STATUS_OBJECT_PATH_NOT_FOUND )
        {
            //
            // the file is not a valid filename.  no overwrite will happen.
            //

            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }
        else if (NT_SUCCESS_NO_DBGBREAK(Status) == FALSE)
        {
            //
            // we failed opening it.  this means the caller will fail opening it
            // that's ok.
            //

            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }
#endif /* NO_RENAME */

        //
        // at this point it's not a NEW file create that is going to work, 
        // double check that we should actually be interested in the MODIFY 
        // of this file
        //

        {
            BOOLEAN HasFileBeenBackedUp;
            
            HasFileBeenBackedUp = SrHasFileBeenBackedUp( pExtension,
                                                         pFileName,
                                                         pFileContext->StreamNameLength,
                                                         SrEventStreamChange );

            if (HasFileBeenBackedUp)
            {
                //
                // we don't care .  skip it
                //

                Status = STATUS_SUCCESS;
                leave;
            }
        }

#if 0 /* NO_RENAME */        
        //
        // otherwise resume processing
        //

        if (SharingViolation)
        {
            //
            // copy the file manually, we got a sharing violation, someone else
            // has this file open.  try to open it again allowing for sharing.
            //

#endif        

        //
        //  Note: In this path, if the operation will be successful, the name 
        //  we have should be a file.  It is possible to get a directory down 
        //  this path if the directory name could be an interesting file name 
        //  (like c:\test.exe\) and the user has opened the directory for 
        //  OVERWRITE, OVERWRITE_IF, or SUPERCEDE.  The user's open will fail, 
        //  so we just want to catch this problem as soon as possible by adding
        //  the FILE_NON_DIRECTORY_FILE CreateOption to avoid doing 
        //  unnecessary work.
        //
        
        Status = SrIoCreateFile( &FileHandle,
                                 DesiredAccess,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,                            // AllocationSize
                                 DesiredAttributes,
                                 pIrpSp->Parameters.Create.ShareAccess,// ShareAccess
                                 FILE_OPEN,                       // OPEN_EXISTING
                                 CreateOptions | FILE_NON_DIRECTORY_FILE,
                                 NULL,
                                 0,                               // EaLength
                                 0,
                                 pExtension->pTargetDevice );

        //  NO_RENAME
        //  NOTE: We have to add some more error handling here since we
        //  are not doing the ZwCreateFile above.
        //
        
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {

            //
            // this is ok.. the file that is being overwritten (at least 
            // CREATE_ALWAYS) doesn't exist.  nothing to backup.
            //

            //
            // we log this in SrCreateCompletion so that we know the create
            // worked first
            //

            Status = STATUS_SUCCESS;
            leave;
        }
        else if (Status == STATUS_SHARING_VIOLATION)
        {
            //
            //  Caller can't open this file either, so don't worry about 
            //  this file.
            //
            
            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
            
#if 0 /* NO_RENAME */            
            SharingViolation = TRUE;
            Status = STATUS_SUCCESS;
#endif /* NO_RENAME */            
        }
#if 0 /* NO_RENAME */
        else if (Status == STATUS_OBJECT_NAME_INVALID ||
                 Status == STATUS_OBJECT_PATH_INVALID ||
                 Status == STATUS_OBJECT_PATH_NOT_FOUND )
        {
            //
            // the file is not a valid filename.  no overwrite will happen.
            //

            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }
#endif /* NO_RENAME */        
        else if (!NT_SUCCESS_NO_DBGBREAK(Status))
        {
            //
            // we failed opening it.  this means the caller will fail opening it
            // that's ok.
            //

            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        //  otherwise we are able to open it (so is the caller).
        //
        //  Go ahead and copy off the file.
        //

        //
        // reference the file object
        //

        Status = ObReferenceObjectByHandle( FileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pFileObject,
                                            NULL );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // check for reparse/mount points
        //
        
        Status = SrCheckForMountsInPath( pExtension, 
                                         pFileObject,
                                         &MountInPath );
        
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // do we have a mount in the path
        //
        
        if (MountInPath)
        {
            //
            // ignore this, we should reparse and come back.
            //
            
            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }

        Status = SrHandleFileChange( pExtension,
                                     SrEventStreamChange, 
                                     pFileObject, 
                                     pFileName );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // we've handled this file
        //
        
        MarkFile = TRUE;

        //
        // let the caller know we copied the file
        //
        
        pOverwriteInfo->CopiedFile = TRUE;
        Status = STATUS_SUCCESS;
        
        leave;




#if 0 /* NO_RENAME */            
        }

        //
        // if the open succeeded, we have the right access
        //

        //
        // reference the file object
        //

        Status = ObReferenceObjectByHandle( FileHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pFileObject,
                                            NULL );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // check for reparse/mount points
        //
        
        Status = SrCheckForMountsInPath( pExtension, 
                                         pFileObject,
                                         &MountInPath );
        
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // do we have a new name?
        //
        
        if (MountInPath)
        {
            //
            // ignore this, we should reparse and come back.
            //
            
            pOverwriteInfo->IgnoredFile = TRUE;
            Status = STATUS_SUCCESS;
            leave;
        }

        //
        // this get's complicated.  when we rename this file out of this
        // directory, the directory could temporarily be empty. this is bad
        // as if sr.sys was never there, that directory would never have
        // been empty.  empty directories can be deleted.  bug#163292 shows
        // an example where we changed this semantic and broke somebody.
        //
        // we need to preserve the fact that this is a non-empty directory
        //
        // create an empty, delete_on_close, dummy file that will exist 
        // until we are done to keep the directory non-empty.
        // 

        //
        // first find the filename part in the full path
        //
        
        Status = SrFindCharReverse( pFileName->Buffer, 
                                    pFileName->Length, 
                                    L'\\',
                                    &pToken,
                                    &TokenLength );
                                    
        if (!NT_SUCCESS( Status ))
            leave;

        Status = SrAllocateFileNameBuffer( pFileName->Length 
                                            - TokenLength 
                                            + SR_UNIQUE_TEMP_FILE_LENGTH, 
                                           &pTempFileName );
                                           
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // and put our unique filename on there
        //
        
        pTempFileName->Length = pFileName->Length - (USHORT)TokenLength;

        RtlCopyMemory( pTempFileName->Buffer,
                       pFileName->Buffer,
                       pTempFileName->Length );

        RtlCopyMemory( &pTempFileName->Buffer[pTempFileName->Length/sizeof(WCHAR)],
                       SR_UNIQUE_TEMP_FILE,
                       SR_UNIQUE_TEMP_FILE_LENGTH );

        pTempFileName->Length += SR_UNIQUE_TEMP_FILE_LENGTH;
        pTempFileName->Buffer[pTempFileName->Length/sizeof(WCHAR)] = UNICODE_NULL;

        InitializeObjectAttributes( &ObjectAttributes,
                                    pTempFileName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = ZwCreateFile( &TempFileHandle,
                               FILE_GENERIC_WRITE|DELETE,
                               &ObjectAttributes,
                               &IoStatusBlock,
                               NULL,                            // AllocationSize
                               FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM,
                               0,                               // ShareAccess
                               FILE_CREATE,                     // CREATE_NEW
                               FILE_SYNCHRONOUS_IO_NONALERT|FILE_DELETE_ON_CLOSE,
                               NULL,
                               0 );                             // EaLength

        if (Status == STATUS_OBJECT_NAME_COLLISION)
        {
            //
            // there is already a file by this name.  bummer.  continue
            // hoping that this file is not deleted so we get to maintain
            // our non-empty directory status.  this is ok and even normal
            // if 2 overwrites are happening at the same time in the same
            // directory.
            //

            //
            // BUGBUG : paulmcd: 12/2000 : we need to fix this window also
            // if we put back the rename opt code.  we can't let this dummy
            // file go away
            //

            Status = STATUS_SUCCESS;

        }
        else if (!NT_SUCCESS( Status ))
            leave;

        //
        // now rename the file to the restore location
        //

        Status = SrRenameFileIntoStore( pExtension,
                                        pFileObject, 
                                        FileHandle, 
                                        pFileName,
                                        SrEventStreamOverwrite,
                                        &pRenameInformation );
                                        
        if (!NT_SUCCESS( Status ))
            leave;

        ASSERT(pRenameInformation != NULL);

        //
        // we have just renamed the file
        //
        
        RenamedFile = TRUE;

        //
        // and now create an empty dummy file that matches the original file 
        // attribs and security descriptor.
        //
        // we reuse SrBackupFile in this case for code-reuse.  we reverse the flow
        // and copy from the restore location into the volume, telling it not to
        // copy any data streams.
        //

        RenamedFileName.Length = (USHORT)pRenameInformation->FileNameLength;
        RenamedFileName.MaximumLength = (USHORT)pRenameInformation->FileNameLength;
        RenamedFileName.Buffer = &pRenameInformation->FileName[0];

        //
        // ignore JUST this create+acl change, it's our dummy backupfile
        //

        Status = SrMarkFileBackedUp( pExtension, 
                                     pFileName, 
                                     SrEventFileCreate|SrEventAclChange );
        if (!NT_SUCCESS( Status ))
            leave;
        
        Status = SrBackupFileAndLog( pExtension,
                                     SrEventInvalid,    // don't log this 
                                     pFileObject,
                                     &RenamedFileName,
                                     pFileName,
                                     FALSE );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // restore the history back to before we added CREATE's (above just prior
        // to the BackupFileKernelMode) .
        //

        Status = SrResetBackupHistory(pExtension, pFileName, RecordedEvents);
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // we've handled this file
        //
        
        MarkFile = TRUE;

        //
        // let the caller know we renamed the file
        //

        pOverwriteInfo->RenamedFile = TRUE;
        
        pOverwriteInfo->pRenameInformation = pRenameInformation;
        pRenameInformation = NULL;
        
        Status = STATUS_SUCCESS;
#endif /* NO_RENAME */

    } finally {

        //
        // check for unhandled exceptions
        //

        Status = FinallyUnwind(SrHandleFileOverwrite, Status);

        if (MarkFile)
        {
            NTSTATUS TempStatus;

            ASSERT(NT_SUCCESS(Status));
            
            //
            // we have to mark that we handled the MODIFY, in order to ignore
            // all subsequent MODIFY's
            //

            TempStatus = SrMarkFileBackedUp( pExtension,
                                             pFileName,
                                             pFileContext->StreamNameLength,
                                             SrEventStreamChange,
                                             SR_IGNORABLE_EVENT_TYPES );
                                             
            CHECK_STATUS(TempStatus);
        }

#if 0 /* NO_RENAME --- See note in function header block */
        //
        // did we fail AFTER renaming the file?
        //
        
        if (!NT_SUCCESS( Status ) && RenamedFile)
        {
            NTSTATUS TempStatus;
            
            //
            // put the file back!  we might have to overwrite if our
            // dummy file is there.  we want to force this file back 
            // to it's old name.
            //

            ASSERT(pRenameInformation != NULL);

            pRenameInformation->ReplaceIfExists = TRUE;
            pRenameInformation->RootDirectory = NULL;
            pRenameInformation->FileNameLength = pFileName->Length;

            ASSERT(pFileName->Length <= SR_MAX_FILENAME_LENGTH);

            RtlCopyMemory( &pRenameInformation->FileName[0],
                           pFileName->Buffer,
                           pFileName->Length );

            TempStatus = ZwSetInformationFile( FileHandle,
                                               &IoStatusBlock,
                                               pRenameInformation,
                                               SR_RENAME_BUFFER_LENGTH,
                                               FileRenameInformation );

            //
            // we did the best we could!
            //
            
            ASSERTMSG("sr!SrHandleFileOverwrite: couldn't fix the failed rename, file lost!", NT_SUCCESS_NO_DBGBREAK(TempStatus));

        }

        if (pRenameInformation != NULL)
        {
            SR_FREE_POOL(pRenameInformation, SR_RENAME_BUFFER_TAG);
            pRenameInformation = NULL;
        }
#endif
        if (pFileObject != NULL)
        {
            ObDereferenceObject(pFileObject);
            pFileObject = NULL;
        }

        if (FileHandle != NULL)
        {
            ZwClose(FileHandle);
            FileHandle = NULL;
        }

        if (TempFileHandle != NULL)
        {
            ZwClose(TempFileHandle);
            TempFileHandle = NULL;
        }

        if (pTempFileName != NULL)
        {
            SrFreeFileNameBuffer(pTempFileName);
            pTempFileName = NULL;
        }

    }   // finally

    RETURN(Status);
    
}   // SrHandleFileOverwrite



/***************************************************************************++

Routine Description:

    this will rename the file into the restore location.
    this is for delete optimizations.

Arguments:

    pExtension - SR's device extension for the volume on which this
        file resides.

    pFileObject - the file object to set the info on (created using
        IoCreateFileSpecifyDeviceObjectHint).
    
    FileHandle - a handle for use in queries. (created using
        IoCreateFileSpecifyDeviceObjectHint).

    pFileName - the original for the file that is about to be renamed.

    EventType - the type of event that is causing this rename.

    ppRenameInfo - you can know where we put it if you like

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS
SrRenameFileIntoStore(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN HANDLE FileHandle,
    IN PUNICODE_STRING pOriginalFileName,
    IN PUNICODE_STRING pFileName,
    IN SR_EVENT_TYPE EventType,
    OUT PFILE_RENAME_INFORMATION * ppRenameInfo OPTIONAL
    )
{
    NTSTATUS                    Status;
    IO_STATUS_BLOCK             IoStatusBlock;
    ULONG                       FileNameLength;
    PUCHAR                      pDestLocation;
    PFILE_RENAME_INFORMATION    pRenameInformation = NULL;
    PUNICODE_STRING             pDestFileName = NULL;
    FILE_STANDARD_INFORMATION   FileInformation;
    BOOLEAN                     RenamedFile = FALSE;
    
    PUNICODE_STRING             pShortName = NULL;
    WCHAR                       ShortFileNameBuffer[SR_SHORT_NAME_CHARS+1];
    UNICODE_STRING              ShortFileName;
    
    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT(FileHandle != NULL);
    ASSERT(FlagOn( pFileObject->Flags, FO_FILE_OBJECT_HAS_EXTENSION ));


    try {

        //
        //  Is our volume properly setup?
        //

        Status = SrCheckVolume(pExtension, FALSE);
        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Do we have enough room in the data store for this file?
        //

        Status = SrCheckFreeDiskSpace( FileHandle, pExtension->pNtVolumeName );
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // do we need to get the short name prior to the rename (for
        // delete's) .
        //

        if (FlagOn( EventType, SrEventFileDelete ))
        {

            RtlInitEmptyUnicodeString( &ShortFileName,
                                       ShortFileNameBuffer,
                                       sizeof(ShortFileNameBuffer) );
                                        
            Status = SrGetShortFileName( pExtension, 
                                         pFileObject, 
                                         &ShortFileName );
                                         
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                //
                //  This file doesn't have a short name, so just leave 
                //  pShortName equal to NULL.
                //

                Status = STATUS_SUCCESS;
            } 
            else if (!NT_SUCCESS(Status))
            {
                //
                //  We hit an unexpected error, so leave.
                //
                
                leave;
            }
            else
            {
                pShortName = &ShortFileName;
            }
        }
        
        //
        // now prepare to rename the file
        //

        pRenameInformation = SR_ALLOCATE_POOL( PagedPool, 
                                               SR_RENAME_BUFFER_LENGTH, 
                                               SR_RENAME_BUFFER_TAG );

        if (pRenameInformation == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        //
        // and get a buffer for a string
        //
        
        Status = SrAllocateFileNameBuffer( SR_MAX_FILENAME_LENGTH, 
                                           &pDestFileName );
                                           
        if (!NT_SUCCESS( Status ))
            leave;

        Status = SrGetDestFileName( pExtension,
                                    pFileName, 
                                    pDestFileName );
                                    
        if (!NT_SUCCESS( Status ))
            leave;

        pDestLocation = (PUCHAR)&pRenameInformation->FileName[0];
        
        //
        // save this now as it get's overwritten.
        //
        
        FileNameLength = pDestFileName->Length;
        
        //
        // and make sure it's in the right spot for the rename info now
        //

        RtlMoveMemory( pDestLocation, 
                       pDestFileName->Buffer, 
                       pDestFileName->Length + sizeof(WCHAR) );

        //
        // now initialize the rename info struct
        //
        
        pRenameInformation->ReplaceIfExists = TRUE;
        pRenameInformation->RootDirectory = NULL;
        pRenameInformation->FileNameLength = FileNameLength;

        SrTrace( NOTIFY, ("SR!SrRenameFileIntoStore:\n\t%wZ\n\tto %ws\n",
                 pFileName,
                 SrpFindFilePartW(&pRenameInformation->FileName[0]) ));

        //
        // and perform the rename
        //
        
        RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

        Status = ZwSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       pRenameInformation,
                                       SR_FILENAME_BUFFER_LENGTH,
                                       FileRenameInformation );
                        
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // we have now renamed the file
        //

        RenamedFile = TRUE;

        //
        // now get the filesize we just renamed
        //

        Status = ZwQueryInformationFile( FileHandle,
                                         &IoStatusBlock,
                                         &FileInformation,
                                         sizeof(FileInformation),
                                         FileStandardInformation );

        if (!NT_SUCCESS( Status ) || 
            NT_SUCCESS(IoStatusBlock.Status) == FALSE)
        {
            leave;
        }

        //
        // and update the byte count as we moved this into the store
        //

        Status = SrUpdateBytesWritten( pExtension, 
                                       FileInformation.EndOfFile.QuadPart );
                                       
        if (!NT_SUCCESS( Status ))
            leave;

    //
    // paulmcd: 5/24/2000 decided not to do this and let the link 
    // tracking system hack their code to make shortcuts not work in 
    // our store.
    //
#if 0   
            
        //
        // strip out the object if of the newly renamed file.
        // this prevents any existing shortcuts to link into our restore 
        // location.  this file should be considered gone from the fs
        //
        
        Status = ZwFsControlFile( FileHandle,               // file handle
                                  NULL,                     // event
                                  NULL,                     // apc routine
                                  NULL,                     // apc context
                                  &IoStatusBlock,           // iosb
                                  FSCTL_DELETE_OBJECT_ID,   // FsControlCode
                                  NULL,                     // input buffer
                                  0,                        // input buffer length
                                  NULL,                     // OutputBuffer for data from the FS
                                  0 );                      // OutputBuffer Length
        //
        // no big deal if this fails, it might not have had one.
        //
        
        CHECK_STATUS(Status);
        Status = STATUS_SUCCESS;

#endif

        //
        // Now Log event
        //

        Status = SrLogEvent( pExtension,
                             EventType,
                             pFileObject,
                             pFileName,
                             0,
                             pDestFileName,
                             NULL,
                             0,
                             pShortName );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // now strip the owner SID so that the old user no longer charged 
        // quota for this file.  it's in our store.
        //
        // its important to do this after we call SrLogEvent, as SrLogEvent
        // needs to query the valid security descriptor for logging.
        //

        Status = SrSetFileSecurity( FileHandle, SrAclTypeRPFiles );
        
        if (!NT_SUCCESS( Status ))
        {
            leave;
        }

        //
        // does the caller want to know where we just renamed it to?
        //
        
        if (ppRenameInfo != NULL)
        {
            //
            // let him own the buffer
            //
            
            *ppRenameInfo = pRenameInformation;
            pRenameInformation = NULL;
        }

    } finally {

        Status = FinallyUnwind(SrRenameFileIntoStore, Status);

        //
        // it better have succeeded or we better have the rename info around 
        //

        //
        // did we fail AFTER we renamed the file ?  we need to clean up after
        // ourselves if we did.
        //

        if (!NT_SUCCESS( Status ) && 
            RenamedFile && 
            pRenameInformation != NULL)
        {
            NTSTATUS TempStatus;
            
            SrTraceSafe( NOTIFY, ("SR!SrRenameFileIntoStore:FAILED!:renaming it back\n"));

            pRenameInformation->ReplaceIfExists = TRUE;
            pRenameInformation->RootDirectory = NULL;
            pRenameInformation->FileNameLength = pOriginalFileName->Length;

            RtlCopyMemory( &pRenameInformation->FileName[0], 
                           pOriginalFileName->Buffer, 
                           pOriginalFileName->Length );

            //
            // and perform the rename
            //
            
            RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

            TempStatus = ZwSetInformationFile( FileHandle,
                                               &IoStatusBlock,
                                               pRenameInformation,
                                               SR_FILENAME_BUFFER_LENGTH,
                                               FileRenameInformation );

            //
            // we did the best we could!
            //
            
            ASSERTMSG("sr!SrRenameFileIntoStore: couldn't fix the failed rename, file lost!", NT_SUCCESS_NO_DBGBREAK(TempStatus));

        }

        if (pRenameInformation != NULL)
        {
            SR_FREE_POOL(pRenameInformation, SR_RENAME_BUFFER_TAG);
            pRenameInformation = NULL;
        }

        if (pDestFileName != NULL)
        {
            SrFreeFileNameBuffer(pDestFileName);
            pDestFileName = NULL;
        }

    }

    RETURN(Status);

}   // SrRenameFileIntoStore


/***************************************************************************++

Routine Description:

    this routine is called in the rename code path.  if a directory is being
    renamed out of monitored space, we simulate delete's for all of the files
    in that directory.

Arguments:

    EventDelete - TRUE if we should trigger deletes, FALSE to trigger creates

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
SrTriggerEvents(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pDirectoryName,
    IN BOOLEAN EventDelete
    )
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    ULONG               FileNameLength;
    PUNICODE_STRING     pFileName = NULL;
    HANDLE              FileHandle = NULL;
    PFILE_OBJECT        pFileObject = NULL;
    UNICODE_STRING      StarFilter;
    PSR_TRIGGER_ITEM    pCurrentItem = NULL;
    LIST_ENTRY          DirectoryList;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));

    try {

        InitializeListHead(&DirectoryList);

        //
        // allocate the first work item
        //

        pCurrentItem = SR_ALLOCATE_STRUCT( PagedPool, 
                                           SR_TRIGGER_ITEM, 
                                           SR_TRIGGER_ITEM_TAG );
                                           
        if (pCurrentItem == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        
        RtlZeroMemory(pCurrentItem, sizeof(SR_TRIGGER_ITEM));
        pCurrentItem->Signature = SR_TRIGGER_ITEM_TAG;


        pCurrentItem->pDirectoryName = pDirectoryName;
        pCurrentItem->FreeDirectoryName = FALSE;

        //
        // make sure noboby is using this one passed in the arg list.
        //
        
        pDirectoryName = NULL;

        //
        // allocate a single temp filename buffer
        //
        
        Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, &pFileName);
        if (!NT_SUCCESS( Status ))
            leave;

        //
        // start our outer most directory handler
        //

start_directory:

        SrTrace( RENAME, ("sr!SrTriggerEvents: starting dir=%wZ\n", 
                 pCurrentItem->pDirectoryName ));

        //
        // Open the directory for list access
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    pCurrentItem->pDirectoryName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = SrIoCreateFile( &pCurrentItem->DirectoryHandle,
                                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,                            // AllocationSize
                                 FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,// ShareAccess
                                 FILE_OPEN,                       // OPEN_EXISTING
                                 FILE_DIRECTORY_FILE
                                  | FILE_OPEN_FOR_BACKUP_INTENT
                                  | FILE_SYNCHRONOUS_IO_NONALERT,
                                 NULL,
                                 0,                               // EaLength
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pExtension->pTargetDevice );

        if (!NT_SUCCESS( Status ))
            leave;


        //
        // reference the file object
        //

        Status = ObReferenceObjectByHandle( pCurrentItem->DirectoryHandle,
                                            0,
                                            *IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &pCurrentItem->pDirectoryObject,
                                            NULL );

        if (!NT_SUCCESS( Status ))
            leave;

        //
        // for creates: log the directory event first
        //
        
        if (!EventDelete)
        {

            Status = SrHandleEvent( pExtension,
                                    SrEventDirectoryCreate|SrEventIsDirectory, 
                                    pCurrentItem->pDirectoryObject,
                                    NULL,
                                    NULL,
                                    NULL );            // pFileName2
                                    
            if (!NT_SUCCESS( Status ))
                leave;
            
        }


        StarFilter.Length = sizeof(WCHAR);
        StarFilter.MaximumLength = sizeof(WCHAR);
        StarFilter.Buffer = L"*";

        pCurrentItem->FileEntryLength = SR_FILE_ENTRY_LENGTH;

        pCurrentItem->pFileEntry = (PFILE_DIRECTORY_INFORMATION)(
                        SR_ALLOCATE_ARRAY( PagedPool, 
                                           UCHAR, 
                                           pCurrentItem->FileEntryLength, 
                                           SR_FILE_ENTRY_TAG ) );

        if (pCurrentItem->pFileEntry == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        //
        // start the enumeration
        //

        Status = ZwQueryDirectoryFile( pCurrentItem->DirectoryHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       pCurrentItem->pFileEntry,
                                       pCurrentItem->FileEntryLength,
                                       FileDirectoryInformation,
                                       TRUE,                // ReturnSingleEntry
                                       &StarFilter,
                                       TRUE );              // RestartScan
        
        if (Status == STATUS_NO_MORE_FILES)
        {
            Status = STATUS_SUCCESS;
            goto finish_directory;
        }
        else if (!NT_SUCCESS( Status ))
        {
            leave;
        }

        //
        // enumerate all of the files in this directory and back them up
        //

        while (TRUE)
        {

            //
            // skip "." and ".."
            //

            if ((pCurrentItem->pFileEntry->FileNameLength == sizeof(WCHAR) &&
                pCurrentItem->pFileEntry->FileName[0] == L'.') || 
            
                (pCurrentItem->pFileEntry->FileNameLength == (sizeof(WCHAR)*2) &&
                pCurrentItem->pFileEntry->FileName[0] == L'.' &&
                pCurrentItem->pFileEntry->FileName[1] == L'.') )
            {
                //
                // skip it
                //
            }

            //
            // is this a directory?
            //

            else if (pCurrentItem->pFileEntry->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                PSR_TRIGGER_ITEM pParentItem;
                PUNICODE_STRING pDirNameBuffer;
                USHORT DirNameLength;
                
                //
                // remember a pointer to the parent item
                //

                pParentItem = pCurrentItem;

                //
                // insert the old item to the list, we'll get back to it
                //

                InsertTailList(&DirectoryList, &pCurrentItem->ListEntry);
                pCurrentItem = NULL;

                //
                // allocate a new current trigger item
                //

                pCurrentItem = SR_ALLOCATE_STRUCT( PagedPool, 
                                                   SR_TRIGGER_ITEM, 
                                                   SR_TRIGGER_ITEM_TAG );
                                                   
                if (pCurrentItem == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }
                
                RtlZeroMemory(pCurrentItem, sizeof(SR_TRIGGER_ITEM));
                pCurrentItem->Signature = SR_TRIGGER_ITEM_TAG;

                //
                // allocate a file name buffer
                //

                DirNameLength = (USHORT)(pParentItem->pDirectoryName->Length 
                                            + sizeof(WCHAR) 
                                            + pParentItem->pFileEntry->FileNameLength);

                Status = SrAllocateFileNameBuffer( DirNameLength, 
                                                   &pDirNameBuffer );

                if (!NT_SUCCESS( Status ))
                    leave;
                    
                //
                // construct a full path string for the sub directory
                //
                
                pDirNameBuffer->Length = DirNameLength;
                                                    
                RtlCopyMemory( pDirNameBuffer->Buffer,
                               pParentItem->pDirectoryName->Buffer,
                               pParentItem->pDirectoryName->Length );

                pDirNameBuffer->Buffer
                    [pParentItem->pDirectoryName->Length/sizeof(WCHAR)] = L'\\';
                
                RtlCopyMemory( &pDirNameBuffer->Buffer[(pParentItem->pDirectoryName->Length/sizeof(WCHAR)) + 1],
                               pParentItem->pFileEntry->FileName,
                               pParentItem->pFileEntry->FileNameLength );

                pDirNameBuffer->Buffer
                    [pDirNameBuffer->Length/sizeof(WCHAR)] = UNICODE_NULL;

                pCurrentItem->pDirectoryName = pDirNameBuffer;
                pCurrentItem->FreeDirectoryName = TRUE;

                //
                // now process this child directory
                //
                
                goto start_directory;
                
            }
            else
            {

                //
                // open the file, first construct a full path string to the file
                //

                FileNameLength = pCurrentItem->pDirectoryName->Length 
                                    + sizeof(WCHAR) 
                                    + pCurrentItem->pFileEntry->FileNameLength;

                
                if (FileNameLength > pFileName->MaximumLength)
                {
                    Status = STATUS_BUFFER_OVERFLOW;
                    leave;
                }

                pFileName->Length = (USHORT)FileNameLength;

                RtlCopyMemory( pFileName->Buffer,
                               pCurrentItem->pDirectoryName->Buffer,
                               pCurrentItem->pDirectoryName->Length );

                pFileName->Buffer[pCurrentItem->pDirectoryName->Length/sizeof(WCHAR)] = L'\\';
                
                RtlCopyMemory( &(pFileName->Buffer[(pCurrentItem->pDirectoryName->Length/sizeof(WCHAR)) + 1]),
                               pCurrentItem->pFileEntry->FileName,
                               pCurrentItem->pFileEntry->FileNameLength );

                SrTrace(RENAME, ("sr!SrTriggerEvents: file=%wZ\n", pFileName));

                InitializeObjectAttributes( &ObjectAttributes,
                                            pFileName,
                                            OBJ_KERNEL_HANDLE,
                                            NULL,
                                            NULL );

                ASSERT(FileHandle == NULL);
                
                Status = SrIoCreateFile( &FileHandle,
                                         FILE_READ_ATTRIBUTES|SYNCHRONIZE,
                                         &ObjectAttributes,
                                         &IoStatusBlock,
                                         NULL,                            // AllocationSize
                                         FILE_ATTRIBUTE_NORMAL,
                                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,// ShareAccess
                                         FILE_OPEN,                       // OPEN_EXISTING
                                         FILE_SEQUENTIAL_ONLY
                                          | FILE_WRITE_THROUGH
                                          | FILE_NO_INTERMEDIATE_BUFFERING
                                          | FILE_NON_DIRECTORY_FILE
                                          | FILE_OPEN_FOR_BACKUP_INTENT
                                          | FILE_SYNCHRONOUS_IO_NONALERT,
                                         NULL,
                                         0,                               // EaLength
                                         IO_IGNORE_SHARE_ACCESS_CHECK,
                                         pExtension->pTargetDevice );

                if (!NT_SUCCESS( Status ))
                    leave;

                //
                // reference the file object
                //

                Status = ObReferenceObjectByHandle( FileHandle,
                                                    0,
                                                    *IoFileObjectType,
                                                    KernelMode,
                                                    (PVOID *) &pFileObject,
                                                    NULL );

                if (!NT_SUCCESS( Status ))
                    leave;

                //
                // simulate a delete event happening on this file
                //

                Status = SrHandleEvent( pExtension,
                                        EventDelete ? 
                                            (SrEventFileDelete|SrEventNoOptimization|SrEventSimulatedDelete) : 
                                            SrEventFileCreate, 
                                        pFileObject,
                                        NULL,
                                        NULL,
                                        NULL );
                                        
                if (!NT_SUCCESS( Status ))
                    leave;

                //
                // all done with these
                //

                ObDereferenceObject(pFileObject);
                pFileObject = NULL;
                
                ZwClose(FileHandle);
                FileHandle = NULL;
                

            }

continue_directory:

            //
            // is there another file?
            //

            Status = ZwQueryDirectoryFile( pCurrentItem->DirectoryHandle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatusBlock,
                                           pCurrentItem->pFileEntry,
                                           pCurrentItem->FileEntryLength,
                                           FileDirectoryInformation,
                                           TRUE,            // ReturnSingleEntry
                                           NULL,            // FileName
                                           FALSE );         // RestartScan

            if (Status == STATUS_NO_MORE_FILES)
            {
                Status = STATUS_SUCCESS;
                break;
            }
            else if (!NT_SUCCESS( Status ))
            {
                leave;
            }

        }   // while (TRUE)

finish_directory:

        //
        // for deletes: simulate the event at the end.
        //

        if (EventDelete)
        {

            Status = SrHandleEvent( pExtension,
                                    SrEventDirectoryDelete|SrEventIsDirectory|SrEventSimulatedDelete,
                                    pCurrentItem->pDirectoryObject,
                                    NULL,
                                    NULL,
                                    NULL );            // pFileName2
                                    
            if (!NT_SUCCESS( Status ))
                leave;
            
        }

        //
        // we just finished a directory item, remove it and free it
        //

        SrFreeTriggerItem(pCurrentItem);
        pCurrentItem = NULL;

        //
        // is there another one ?
        //

        if (IsListEmpty(&DirectoryList) == FALSE)
        {
            PLIST_ENTRY pListEntry;
            
            //
            // finish it
            //
            
            pListEntry = RemoveTailList(&DirectoryList);

            pCurrentItem = CONTAINING_RECORD( pListEntry, 
                                              SR_TRIGGER_ITEM, 
                                              ListEntry );
                                              
            ASSERT(IS_VALID_TRIGGER_ITEM(pCurrentItem));

            SrTrace( RENAME, ("sr!SrTriggerEvents: resuming dir=%wZ\n", 
                     pCurrentItem->pDirectoryName ));

            goto continue_directory;
        }

        //
        // all done
        //
        
    } finally {

        Status = FinallyUnwind(SrTriggerEvents, Status);

        if (pFileObject != NULL)
        {
            ObDereferenceObject(pFileObject);
            pFileObject = NULL;
        }

        if (FileHandle != NULL)
        {
            ZwClose(FileHandle);
            FileHandle = NULL;
        }

        if (pFileName != NULL)
        {
            SrFreeFileNameBuffer(pFileName);
            pFileName = NULL;
        }

        if (pCurrentItem != NULL)
        {
            ASSERT(NT_SUCCESS_NO_DBGBREAK(Status) == FALSE);
            
            SrFreeTriggerItem(pCurrentItem);
            pCurrentItem = NULL;
        }

        ASSERT(IsListEmpty(&DirectoryList) || 
                NT_SUCCESS_NO_DBGBREAK(Status) == FALSE);

        while (IsListEmpty(&DirectoryList) == FALSE)
        {
            PLIST_ENTRY pListEntry;
            
            pListEntry = RemoveTailList(&DirectoryList);

            pCurrentItem = CONTAINING_RECORD( pListEntry, 
                                              SR_TRIGGER_ITEM, 
                                              ListEntry );
                                              
            ASSERT(IS_VALID_TRIGGER_ITEM(pCurrentItem));

            SrFreeTriggerItem(pCurrentItem);
        }

    }

    RETURN(Status);
    
}   // SrTriggerEvents


/***************************************************************************++

Routine Description:

    this is the second phase handling of a rename.  if a directory is renamed
    from non-monitored space to monitored space, we need to enumerate the 
    new directory and simluate (trigger) create events for each new file. 
    this results in a log entry being created for each new file that was 
    added .

Arguments:

    
--***************************************************************************/
NTSTATUS
SrHandleDirectoryRename(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pDirectoryName,
    IN BOOLEAN EventDelete
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    try {

        //
        //  Acquire the activily lock for the volume
        //

        SrAcquireActivityLockShared( pExtension );

        Status = STATUS_SUCCESS;

        //
        // did we just get disabled?
        //
        
        if (!SR_LOGGING_ENABLED(pExtension))
            leave;

        //
        // don't check the volume yet, we don't if there is anything 
        // interesting even though this could be a new restore point.
        // SrHandleEvent will check the volume (SrTriggerEvents calls it) .
        //
    
        //
        // it's a directory.  fire events on all of the children,
        // as they are moving also!
        //

        Status = SrTriggerEvents( pExtension, 
                                  pDirectoryName, 
                                  EventDelete );

        if (!NT_SUCCESS( Status ))
            leave;

    } finally {

        Status = FinallyUnwind(SrHandleDirectoryRename, Status);

        //
        // check for any bad errors
        //

        if (CHECK_FOR_VOLUME_ERROR(Status))
        {
            NTSTATUS TempStatus;
            
            //
            // trigger the failure notification to the service
            //

            TempStatus = SrNotifyVolumeError( pExtension,
                                              pDirectoryName,
                                              Status,
                                              SrEventDirectoryRename );
                                             
            CHECK_STATUS(TempStatus);

        }

        SrReleaseActivityLock( pExtension );
    }

    RETURN(Status);

}   // SrHandleDirectoryRename


/***************************************************************************++

Routine Description:

    This handles when a file is being renamed out of monitored space
    and we need to backup the file before the rename.  We return the name
    of the destination file we created so it can be logged with the
    operation if the rename is successful.

Arguments:

    pFileObject - the file object that just changed
    
    pFileName - the name of the file that changed

    ppDestFileName - this returns the allocated destination file name (if one
            is defined, so it can be logged with the entry)

Return Value:

    NTSTATUS - Completion status. 
    
--***************************************************************************/
NTSTATUS
SrHandleFileRenameOutOfMonitoredSpace(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PFILE_OBJECT pFileObject,
    IN PSR_STREAM_CONTEXT pFileContext,
    OUT PBOOLEAN pOptimizeDelete,
    OUT PUNICODE_STRING *ppDestFileName
    )
{
    ULONGLONG       BytesWritten;
    NTSTATUS        Status;
    BOOLEAN         HasFileBeenBackedUp;
    BOOLEAN         releaseLock = FALSE;

    PAGED_CODE();

    ASSERT(IS_VALID_SR_DEVICE_EXTENSION(pExtension));
    ASSERT(IS_VALID_FILE_OBJECT(pFileObject));
    ASSERT( pFileContext != NULL );

    //
    //  Initialize return parameters
    //

    *pOptimizeDelete = FALSE;
    *ppDestFileName = NULL;

    //
    //  See if the file has already been backed up because of a delete.  If so
    //  don't do it again.  
    //

    HasFileBeenBackedUp = SrHasFileBeenBackedUp( pExtension,
                                                 &(pFileContext->FileName),
                                                 pFileContext->StreamNameLength,
                                                 SrEventFileDelete );

    if (HasFileBeenBackedUp)
    {
        *pOptimizeDelete = TRUE;
        return STATUS_SUCCESS;
    }

    //
    //  Handle backing up the file
    //

    try {

        //
        //  Allocate a buffer to hold destination name
        //

        Status = SrAllocateFileNameBuffer(SR_MAX_FILENAME_LENGTH, ppDestFileName);

        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Acquire the activily lock for the volume
        //

        SrAcquireActivityLockShared( pExtension );
        releaseLock = TRUE;

        //
        // we need to make sure our disk structures are good and logging
        // has been started.
        //

        Status = SrCheckVolume(pExtension, FALSE);
        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Generate a destination file name
        //

        Status = SrGetDestFileName( pExtension,
                                    &(pFileContext->FileName), 
                                    *ppDestFileName );
                                
        if (!NT_SUCCESS( Status ))
            leave;

        //
        //  Backup the file
        //

        Status = SrBackupFile( pExtension,
                               pFileObject,
                               &(pFileContext->FileName), 
                               *ppDestFileName, 
                               TRUE,
                               &BytesWritten,
                               NULL );

        if (Status == SR_STATUS_IGNORE_FILE)
        {
            //
            //  We weren't able to open the file because it was encrypted in 
            //  another context.  Unfortunately, we cannot recover from this
            //  error, so return the actual error of STATUS_ACCESS_DENIED.
            //

            Status = STATUS_ACCESS_DENIED;
            CHECK_STATUS( Status );
            leave;
        }
        else if (!NT_SUCCESS(Status))
            leave;
        
	    //
	    // Update the bytes written.
	    //

	    Status = SrUpdateBytesWritten(pExtension, BytesWritten);
	    
	    if (!NT_SUCCESS(Status))
	        leave;
    }
    finally
    {
        if (releaseLock)
        {
            SrReleaseActivityLock( pExtension );
        }

        //
        //  If we are returning an error then do not return the string
        //  (and free it).
        //

        if (!NT_SUCCESS_NO_DBGBREAK(Status) && (NULL != *ppDestFileName))
        {
            SrFreeFileNameBuffer(*ppDestFileName);
            *ppDestFileName = NULL;
        }
    }    

    return Status;
}


/***************************************************************************++

Routine Description:

    this routine is called from the mj_create completion routine.  it
    happens if the mj_create failed in it's overwrite, but we thought it was
    going to work and renamed the destination file out from under the 
    overwrite.  in this case we have to cleanup after ourselves.

Arguments:

    
--***************************************************************************/
NTSTATUS
SrHandleOverwriteFailure(
    IN PSR_DEVICE_EXTENSION pExtension,
    IN PUNICODE_STRING pOriginalFileName,
    IN ULONG CreateFileAttributes,
    IN PFILE_RENAME_INFORMATION pRenameInformation
    )
{
    NTSTATUS            Status;
    NTSTATUS            TempStatus;
    HANDLE              FileHandle = NULL;
    UNICODE_STRING      FileName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    
    PAGED_CODE();

    try {

        SrAcquireActivityLockShared( pExtension );

        //
        // open the file that we renamed to.
        //

        FileName.Length = (USHORT)pRenameInformation->FileNameLength;
        FileName.MaximumLength = (USHORT)pRenameInformation->FileNameLength;
        FileName.Buffer = &pRenameInformation->FileName[0];

        InitializeObjectAttributes( &ObjectAttributes,
                                    &FileName,
                                    OBJ_KERNEL_HANDLE,
                                    NULL,
                                    NULL );

        Status = SrIoCreateFile( &FileHandle,
                                 DELETE|SYNCHRONIZE,
                                 &ObjectAttributes,
                                 &IoStatusBlock,
                                 NULL,                            // AllocationSize
                                 CreateFileAttributes,
                                 FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,// ShareAccess
                                 FILE_OPEN,                       // OPEN_EXISTING
                                 FILE_SYNCHRONOUS_IO_NONALERT
                                  | FILE_WRITE_THROUGH,
                                 NULL,
                                 0,                               // EaLength
                                 IO_IGNORE_SHARE_ACCESS_CHECK,
                                 pExtension->pTargetDevice );

        if (!NT_SUCCESS( Status ))
            leave;

        pRenameInformation->ReplaceIfExists = TRUE;
        pRenameInformation->RootDirectory = NULL;
        pRenameInformation->FileNameLength = pOriginalFileName->Length;

        RtlCopyMemory( &pRenameInformation->FileName[0],
                       pOriginalFileName->Buffer,
                       pOriginalFileName->Length );

        RtlZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

        Status = ZwSetInformationFile( FileHandle,
                                       &IoStatusBlock,
                                       pRenameInformation,
                                       SR_FILENAME_BUFFER_LENGTH,
                                       FileRenameInformation );
                        
        if (!NT_SUCCESS( Status ))
            leave;

    } finally {

        //
        // always report a volume failure
        //

        TempStatus = SrNotifyVolumeError( pExtension,
                                          pOriginalFileName,
                                          STATUS_UNEXPECTED_IO_ERROR,
                                          SrEventStreamOverwrite );

        if (NT_SUCCESS(TempStatus) == FALSE && NT_SUCCESS(Status))
        {
            //
            // only return this if we are not hiding some existing error
            // status code
            //
            
            Status = TempStatus;
        }

        SrReleaseActivityLock( pExtension );

        if (FileHandle != NULL)
        {
            ZwClose(FileHandle);
            FileHandle = NULL;
        }

    }

    RETURN(Status);
    
}   // SrFixOverwriteFailure

VOID
SrFreeTriggerItem(
    IN PSR_TRIGGER_ITEM pItem
    )
{
    PAGED_CODE();

    ASSERT(IS_VALID_TRIGGER_ITEM(pItem));

    if (pItem->FreeDirectoryName && pItem->pDirectoryName != NULL)
    {
        SrFreeFileNameBuffer(pItem->pDirectoryName);
        pItem->pDirectoryName = NULL;
    }

    if (pItem->pFileEntry != NULL)
    {
        SR_FREE_POOL(pItem->pFileEntry, SR_FILE_ENTRY_TAG);
        pItem->pFileEntry = NULL;
    }

    if (pItem->pDirectoryObject != NULL)
    {
        ObDereferenceObject(pItem->pDirectoryObject);
        pItem->pDirectoryObject = NULL;
    }

    if (pItem->DirectoryHandle != NULL)
    {
        ZwClose(pItem->DirectoryHandle);
        pItem->DirectoryHandle = NULL;
    }

    SR_FREE_POOL_WITH_SIG(pItem, SR_TRIGGER_ITEM_TAG);
    
}   // SrFreeTriggerItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\sr\kernel\dispatch.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    this is the major function code dispatch filter layer.

Author:

    Paul McDaniel (paulmcd)     23-Jan-2000

Revision History:

--*/



#include "precomp.h"

//
// Private constants.
//

#if DBG

PWSTR IrpMjCodes[] = 
{
    L"IRP_MJ_CREATE",
    L"IRP_MJ_CREATE_NAMED_PIPE",
    L"IRP_MJ_CLOSE",
    L"IRP_MJ_READ",
    L"IRP_MJ_WRITE",
    L"IRP_MJ_QUERY_INFORMATION",
    L"IRP_MJ_SET_INFORMATION",
    L"IRP_MJ_QUERY_EA",
    L"IRP_MJ_SET_EA",
    L"IRP_MJ_FLUSH_BUFFERS",
    L"IRP_MJ_QUERY_VOLUME_INFORMATION",
    L"IRP_MJ_SET_VOLUME_INFORMATION",
    L"IRP_MJ_DIRECTORY_CONTROL",
    L"IRP_MJ_FILE_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CONTROL",
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",
    L"IRP_MJ_SHUTDOWN",
    L"IRP_MJ_LOCK_CONTROL",
    L"IRP_MJ_CLEANUP",
    L"IRP_MJ_CREATE_MAILSLOT",
    L"IRP_MJ_QUERY_SECURITY",
    L"IRP_MJ_SET_SECURITY",
    L"IRP_MJ_POWER",
    L"IRP_MJ_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CHANGE",
    L"IRP_MJ_QUERY_QUOTA",
    L"IRP_MJ_SET_QUOTA",
    L"IRP_MJ_PNP",
    L"IRP_MJ_MAXIMUM_FUNCTION",
};

#endif // DBG

//
// Private types.
//

//
// Private prototypes.
//

NTSTATUS
SrCreateRestorePointIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrGetNextSeqNumIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrReloadConfigurationIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrSwitchAllLogsIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrDisableVolumeIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrStartMonitoringIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrStopMonitoringIoctl (
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
SrDismountCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SrMajorFunction )
#pragma alloc_text( PAGE, SrCleanup )
#pragma alloc_text( PAGE, SrCreate )
#pragma alloc_text( PAGE, SrSetInformation )
#pragma alloc_text( PAGE, SrSetHardLink )
#pragma alloc_text( PAGE, SrSetSecurity )
#pragma alloc_text( PAGE, SrCreateRestorePointIoctl )
#pragma alloc_text( PAGE, SrFsControl )
#pragma alloc_text( PAGE, SrFsControlReparsePoint )
#pragma alloc_text( PAGE, SrFsControlMount )
#pragma alloc_text( PAGE, SrFsControlLockOrDismount)
#pragma alloc_text( PAGE, SrFsControlWriteRawEncrypted )
#pragma alloc_text( PAGE, SrFsControlSetSparse )
#pragma alloc_text( PAGE, SrPnp )
#pragma alloc_text( PAGE, SrGetNextSeqNumIoctl )
#pragma alloc_text( PAGE, SrReloadConfigurationIoctl )
#pragma alloc_text( PAGE, SrSwitchAllLogsIoctl )
#pragma alloc_text( PAGE, SrDisableVolumeIoctl )
#pragma alloc_text( PAGE, SrStartMonitoringIoctl )
#pragma alloc_text( PAGE, SrStopMonitoringIoctl )
#pragma alloc_text( PAGE, SrShutdown )

#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- SrPassThrough
NOT PAGEABLE -- SrWrite
#endif // 0


//
// Private globals.
//

//
// Lookup table to verify incoming IOCTL codes.
//

typedef
NTSTATUS
(NTAPI * PFN_IOCTL_HANDLER)(
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION IrpSp
    );

typedef struct _SR_IOCTL_TABLE
{
    ULONG IoControlCode;
    PFN_IOCTL_HANDLER Handler;
} SR_IOCTL_TABLE, *PSR_IOCTL_TABLE;

SR_IOCTL_TABLE SrIoctlTable[] =
    {
        { IOCTL_SR_CREATE_RESTORE_POINT,        &SrCreateRestorePointIoctl },
        { IOCTL_SR_RELOAD_CONFIG,               &SrReloadConfigurationIoctl },
        { IOCTL_SR_START_MONITORING,            &SrStartMonitoringIoctl },
        { IOCTL_SR_STOP_MONITORING,             &SrStopMonitoringIoctl },
        { IOCTL_SR_WAIT_FOR_NOTIFICATION,       &SrWaitForNotificationIoctl },
        { IOCTL_SR_SWITCH_LOG,                  &SrSwitchAllLogsIoctl },
        { IOCTL_SR_DISABLE_VOLUME,              &SrDisableVolumeIoctl },
        { IOCTL_SR_GET_NEXT_SEQUENCE_NUM,       &SrGetNextSeqNumIoctl }
    };

C_ASSERT( SR_NUM_IOCTLS == DIMENSION(SrIoctlTable) );

//
// Public globals.
//

//
// Public functions.
//






/***************************************************************************++

Routine Description:

    Does any pre or post work for the IRP then passes it through to the 
    lower layer driver.

    NOTE: This routine is NOT pageable

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp
    )
{
    PSR_DEVICE_EXTENSION pExtension;

    //
    // this is NonPaged code!
    //

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);
    ASSERT(IS_VALID_DEVICE_OBJECT(DeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));

    //
    // Is this a function for our Control Device Object?
    //

    if (DeviceObject == _globals.pControlDevice)
    {
        return SrMajorFunction(DeviceObject, pIrp);
    }

    //
    // else it is a device we've attached to , grab our extension
    //
    
    ASSERT(IS_SR_DEVICE_OBJECT(DeviceObject));
    pExtension = DeviceObject->DeviceExtension;

    //
    // Now call the appropriate file system driver with the request.
    //

    IoSkipCurrentIrpStackLocation(pIrp);
    return IoCallDriver(pExtension->pTargetDevice, pIrp);
}   // SrPassThrough



/***************************************************************************++

Routine Description:

    Handles IRPs for the actual device control object vs. the sub-level
    fsd we are attached to .

Arguments:


Return Value:

    NTSTATUS - Status code.

--***************************************************************************/
NTSTATUS
SrMajorFunction(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpSp;
    PSR_CONTROL_OBJECT      pControlObject;
    ULONG                   Code;
    ULONG                   FunctionCode;
    PFILE_FULL_EA_INFORMATION pEaBuffer;
    PSR_OPEN_PACKET         pOpenPacket;

    UNREFERENCED_PARAMETER( pDeviceObject );

    ASSERT(IS_VALID_DEVICE_OBJECT(pDeviceObject));
    ASSERT(IS_VALID_IRP(pIrp));
    ASSERT(pDeviceObject == _globals.pControlDevice);

    //
    // < dispatch!
    //

    PAGED_CODE();

    SrTrace(FUNC_ENTRY, (
        "SR!SrMajorFunction(Function=%ls)\n", 
        IrpMjCodes[IoGetCurrentIrpStackLocation(pIrp)->MajorFunction]
        ));

    Status = STATUS_SUCCESS;
    
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpSp->MajorFunction)
    {

    //
    // IRP_MJ_CREATE is called to create a new HANDLE on 
    // SR_CONTROL_DEVICE_NAME
    //
    
    case IRP_MJ_CREATE:

        //
        // Find and validate the open packet.
        //

        pEaBuffer = (PFILE_FULL_EA_INFORMATION)
                        (pIrp->AssociatedIrp.SystemBuffer);

        if (pEaBuffer == NULL ||
            pEaBuffer->EaValueLength != sizeof(*pOpenPacket) ||
            pEaBuffer->EaNameLength != SR_OPEN_PACKET_NAME_LENGTH ||
            strcmp( pEaBuffer->EaName, SR_OPEN_PACKET_NAME ) )
        {

            Status = STATUS_REVISION_MISMATCH;
            goto CompleteTheIrp;
        }

        pOpenPacket =
            (PSR_OPEN_PACKET)( pEaBuffer->EaName + pEaBuffer->EaNameLength + 1 );

        ASSERT( (((ULONG_PTR)pOpenPacket) & 7) == 0 );

        //
        // For now, we'll fail if the incoming version doesn't EXACTLY match
        // the expected version. In future, we may need to be a bit more
        // flexible to allow down-level clients.
        //

        if (pOpenPacket->MajorVersion != SR_INTERFACE_VERSION_MAJOR ||
            pOpenPacket->MinorVersion != SR_INTERFACE_VERSION_MINOR)
        {

            Status = STATUS_REVISION_MISMATCH;
            goto CompleteTheIrp;
        }

        if (_globals.pControlObject != NULL) 
        {
            Status = STATUS_DEVICE_ALREADY_ATTACHED;
            goto CompleteTheIrp;
        }

        try {
            //
            // grab the lock
            //
            
            SrAcquireGlobalLockExclusive();

            //
            // Double check to make sure that the ControlObject hasn't
            // been created while we were waiting to get the lock.
            //

            if (_globals.pControlObject != NULL)
            {

                Status = STATUS_DEVICE_ALREADY_ATTACHED;
                leave;
            }

            //
            // Create a new OBJECT 
            //

            Status = SrCreateControlObject(&pControlObject, 0);
            if (!NT_SUCCESS(Status)) 
            {
                leave;
            }

            ASSERT(IS_VALID_CONTROL_OBJECT(pControlObject